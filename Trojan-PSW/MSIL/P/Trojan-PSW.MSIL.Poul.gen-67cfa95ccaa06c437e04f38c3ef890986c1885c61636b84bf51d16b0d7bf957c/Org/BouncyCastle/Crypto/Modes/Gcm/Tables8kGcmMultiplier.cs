// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Crypto.Modes.Gcm.Tables8kGcmMultiplier
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using Org.BouncyCastle.Crypto.Utilities;
using Org.BouncyCastle.Utilities;

namespace Org.BouncyCastle.Crypto.Modes.Gcm
{
  public class Tables8kGcmMultiplier : IGcmMultiplier
  {
    private byte[] H;
    private uint[][][] M;

    public void Init(byte[] H)
    {
      if (this.M == null)
        this.M = new uint[32][][];
      else if (Arrays.AreEqual(this.H, H))
        return;
      this.H = Arrays.Clone(H);
      this.M[0] = new uint[16][];
      this.M[1] = new uint[16][];
      this.M[0][0] = new uint[4];
      this.M[1][0] = new uint[4];
      this.M[1][8] = GcmUtilities.AsUints(H);
      for (int index = 4; index >= 1; index >>= 1)
      {
        uint[] x = (uint[]) this.M[1][index + index].Clone();
        GcmUtilities.MultiplyP(x);
        this.M[1][index] = x;
      }
      uint[] x1 = (uint[]) this.M[1][1].Clone();
      GcmUtilities.MultiplyP(x1);
      this.M[0][8] = x1;
      for (int index = 4; index >= 1; index >>= 1)
      {
        uint[] x2 = (uint[]) this.M[0][index + index].Clone();
        GcmUtilities.MultiplyP(x2);
        this.M[0][index] = x2;
      }
      int index1 = 0;
label_11:
      do
      {
        for (int index2 = 2; index2 < 16; index2 += index2)
        {
          for (int index3 = 1; index3 < index2; ++index3)
          {
            uint[] x3 = (uint[]) this.M[index1][index2].Clone();
            GcmUtilities.Xor(x3, this.M[index1][index3]);
            this.M[index1][index2 + index3] = x3;
          }
        }
        if (++index1 == 32)
          return;
      }
      while (index1 <= 1);
      this.M[index1] = new uint[16][];
      this.M[index1][0] = new uint[4];
      for (int index4 = 8; index4 > 0; index4 >>= 1)
      {
        uint[] x4 = (uint[]) this.M[index1 - 2][index4].Clone();
        GcmUtilities.MultiplyP8(x4);
        this.M[index1][index4] = x4;
      }
      goto label_11;
    }

    public void MultiplyH(byte[] x)
    {
      uint[] ns = new uint[4];
      for (int index = 15; index >= 0; --index)
      {
        uint[] numArray1 = this.M[index + index][(int) x[index] & 15];
        ns[0] ^= numArray1[0];
        ns[1] ^= numArray1[1];
        ns[2] ^= numArray1[2];
        ns[3] ^= numArray1[3];
        uint[] numArray2 = this.M[index + index + 1][((int) x[index] & 240) >> 4];
        ns[0] ^= numArray2[0];
        ns[1] ^= numArray2[1];
        ns[2] ^= numArray2[2];
        ns[3] ^= numArray2[3];
      }
      Pack.UInt32_To_BE(ns, x, 0);
    }
  }
}
