// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.OptionalRstParameters
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: ADE0A079-11DB-4A46-8BDE-D2A592CA8DEA
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Parite.b-45f75059f5cfde3143c1ae07d5d3f934aa0236ed48d7e158826e074f20ea58cc.exe

using System.ServiceModel.Security;
using System.Xml;

namespace Microsoft.InfoCards
{
  internal class OptionalRstParameters
  {
    private string m_tokenType = string.Empty;
    private string m_signatureAlgorithm;
    private string m_encryptionAlgorithm;
    private string m_canonicalizationAlgorithm;
    private string m_signWith;
    private string m_encryptWith;
    private string m_keyWrapAlgorithm;

    public static OptionalRstParameters CreateMergedParameters(
      OptionalRstParameters primary,
      OptionalRstParameters secondary)
    {
      return new OptionalRstParameters()
      {
        m_canonicalizationAlgorithm = !string.IsNullOrEmpty(primary.m_canonicalizationAlgorithm) ? primary.m_canonicalizationAlgorithm : secondary.m_canonicalizationAlgorithm,
        m_encryptionAlgorithm = !string.IsNullOrEmpty(primary.m_encryptionAlgorithm) ? primary.m_encryptionAlgorithm : secondary.m_encryptionAlgorithm,
        m_encryptWith = !string.IsNullOrEmpty(primary.m_encryptWith) ? primary.m_encryptWith : secondary.m_encryptWith,
        m_keyWrapAlgorithm = !string.IsNullOrEmpty(primary.m_keyWrapAlgorithm) || !string.IsNullOrEmpty(secondary.m_keyWrapAlgorithm) ? (!string.IsNullOrEmpty(primary.m_keyWrapAlgorithm) ? primary.m_keyWrapAlgorithm : secondary.m_keyWrapAlgorithm) : SecurityAlgorithmSuite.Default.DefaultAsymmetricKeyWrapAlgorithm,
        m_signatureAlgorithm = !string.IsNullOrEmpty(primary.m_signatureAlgorithm) ? primary.m_signatureAlgorithm : secondary.m_signatureAlgorithm,
        m_signWith = !string.IsNullOrEmpty(primary.m_signWith) ? primary.m_signWith : secondary.m_signWith,
        m_tokenType = !string.IsNullOrEmpty(primary.m_tokenType) ? primary.m_tokenType : secondary.m_tokenType
      };
    }

    public string SignatureAlgorithm
    {
      get => this.m_signatureAlgorithm;
      set => this.m_signatureAlgorithm = value;
    }

    public string EncryptionAlgorithm
    {
      get => this.m_encryptionAlgorithm;
      set => this.m_encryptionAlgorithm = value;
    }

    public string SignWith
    {
      get => this.m_signWith;
      set => this.m_signWith = value;
    }

    public string EncryptWith
    {
      get => this.m_encryptWith;
      set => this.m_encryptWith = value;
    }

    public string CanonicalizationAlgorithm
    {
      get => this.m_canonicalizationAlgorithm;
      set => this.m_canonicalizationAlgorithm = value;
    }

    public string KeyWrapAlgorithm
    {
      get => this.m_keyWrapAlgorithm;
      set => this.m_keyWrapAlgorithm = value;
    }

    public string TokenType
    {
      get => this.m_tokenType;
      set => this.m_tokenType = value;
    }

    public void WritePassOnElements(XmlDictionaryWriter writer, ProtocolProfile profile)
    {
      string defaultPrefix = profile.WSTrust.DefaultPrefix;
      if (!string.IsNullOrEmpty(this.TokenType))
      {
        writer.WriteStartElement(defaultPrefix, profile.WSTrust.TokenType, profile.WSTrust.Namespace);
        writer.WriteString(this.TokenType);
        writer.WriteEndElement();
      }
      if (!string.IsNullOrEmpty(this.SignatureAlgorithm))
      {
        writer.WriteStartElement(defaultPrefix, profile.WSTrust.SignatureAlgorithm, profile.WSTrust.Namespace);
        writer.WriteString(this.SignatureAlgorithm);
        writer.WriteEndElement();
      }
      if (string.IsNullOrEmpty(this.CanonicalizationAlgorithm))
        return;
      writer.WriteStartElement(defaultPrefix, profile.WSTrust.CanonicalizationAlgorithm, profile.WSTrust.Namespace);
      writer.WriteString(this.CanonicalizationAlgorithm);
      writer.WriteEndElement();
    }
  }
}
