// Decompiled with JetBrains decompiler
// Type: Mario_KS.Board
// Assembly: OnSerializingAttribute, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F72B5184-77D9-4DBB-B29C-2F3B04C48CCD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-8c2eb36fc68b33fc269eaa5f42a303b63ee25bccdd99c0c424285aee9317d94c.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;

namespace Mario_KS
{
  [Serializable]
  public class Board
  {
    public Padding Padding;
    public Cell SelectedCell;
    public Color BackColor;
    [NonSerialized]
    public Bitmap Picture;
    [NonSerialized]
    public List<Piece> Pieces;
    public Point Location;
    public Size Size;
    private Cell[,] aCells;

    public Board()
    {
      this.Padding = new Padding(0);
      this.Pieces = new List<Piece>();
      this.Location = new Point();
      this.Size = new Size(0, 0);
      this.aCells = new Cell[1, 1];
    }

    public event Board.CellSelectedEventHandler CellSelected;

    public event Board.BoardDrawingEventHandler BoardDrawing;

    public event Board.BoardDrawedEventHandler BoardDrawed;

    public int Width
    {
      get => this.aCells.GetUpperBound(0);
      set => this.Allocate((long) value, (long) this.Height);
    }

    public int Height
    {
      get => this.aCells.GetUpperBound(1);
      set => this.Allocate((long) this.Width, (long) value);
    }

    public List<Cell> Cells
    {
      get => this.Range();
      set
      {
        int width = this.Width;
        int index1 = 0;
        while (index1 <= width)
        {
          int height = this.Height;
          int index2 = 0;
          while (index2 <= height)
          {
            int index3;
            this.aCells[index1, index2] = value[index3];
            checked { ++index3; }
            checked { ++index2; }
          }
          checked { ++index1; }
        }
      }
    }

    public Cell get_Cells(Point Coordinates) => this.aCells[Coordinates.X, Coordinates.Y];

    public Cell get_Cells(int X, int Y) => this.aCells[X, Y];

    public bool IsRow(int Index) => Index >= 0 & Index <= this.Height;

    public bool IsColumn(int Index) => Index >= 0 & Index <= this.Width;

    public bool IsCell(int Row, int Column) => this.IsRow(Row) & this.IsColumn(Column);

    public bool DrawBackground(Graphics Surface, RectangleF Area)
    {
      Surface.FillRectangle((Brush) new SolidBrush(this.BackColor), Area);
      if (this.Picture != null)
      {
        try
        {
          Surface.DrawImage((Image) this.Picture, Area.Left, Area.Top, new RectangleF(Area.Left - (float) this.Location.X, Area.Top - (float) this.Location.Y, Area.Right - (float) this.Location.X, Area.Bottom - (float) this.Location.Y), GraphicsUnit.Pixel);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
          goto label_4;
        }
      }
      bool flag = true;
label_4:
      return flag;
    }

    public List<Cell> Range() => this.Range(new Rectangle(0, 0, this.Width, this.Height));

    public List<Cell> Range(Rectangle Area)
    {
      List<Cell> cellList = new List<Cell>();
      int left = Area.Left;
      int right = Area.Right;
      int index1 = left;
      while (index1 <= right)
      {
        int top = Area.Top;
        int bottom = Area.Bottom;
        int index2 = top;
        while (index2 <= bottom)
        {
          cellList.Add(this.aCells[index1, index2]);
          checked { ++index2; }
        }
        checked { ++index1; }
      }
      return cellList;
    }

    public void DrawAll(Graphics Surface)
    {
      // ISSUE: reference to a compiler-generated field
      Board.BoardDrawingEventHandler boardDrawingEvent = this.BoardDrawingEvent;
      bool Cancel;
      if (boardDrawingEvent != null)
        boardDrawingEvent(ref Cancel);
      if (Cancel)
        return;
      int num = checked (this.Location.X + this.Padding.Left);
      int width = this.Width;
      int index = 0;
      while (index <= width)
      {
        int PositionX = checked (num + this.aCells[index, 0].Margin.Left);
        this.DrawColumn(Surface, this.Location.Y, index, PositionX);
        Piece piece = this.Pieces[this.get_Cells(index, 0).PieceIndex];
        num = checked (PositionX + piece.Sprite.Width + this.get_Cells(index, 0).Margin.Right);
        checked { ++index; }
      }
      this.Size.Width = num;
      // ISSUE: reference to a compiler-generated field
      Board.BoardDrawedEventHandler boardDrawedEvent = this.BoardDrawedEvent;
      if (boardDrawedEvent == null)
        return;
      boardDrawedEvent();
    }

    public void DrawColumn(Graphics Surface, int Y, int ColumnIndex, int PositionX)
    {
      int num1 = checked (Y + this.Padding.Top);
      int height = this.Height;
      int index = 0;
      while (index <= height)
      {
        Cell aCell = this.aCells[ColumnIndex, index];
        int num2 = checked (num1 + aCell.Margin.Top);
        aCell.Position.X = PositionX;
        aCell.Position.Y = num2;
        this.DrawCell(Surface, this.aCells[ColumnIndex, index]);
        num1 = checked (num2 + aCell.Piece.Sprite.Height + aCell.Margin.Bottom);
        checked { ++index; }
      }
      this.Size.Height = num1;
    }

    public void DrawCell(Graphics Surface, Cell Cell, bool Background = true)
    {
      Piece piece = this.Pieces[Cell.PieceIndex];
      if (Background)
        this.DrawBackground(Surface, new RectangleF((float) Cell.Position.X, (float) Cell.Position.Y, (float) Cell.Piece.Sprite.Width, (float) Cell.Piece.Sprite.Height));
      if (Cell.Visible)
      {
        Sprite sprite = piece.Sprite;
        sprite.ImageAttributes = Cell.ImageAttributes;
        sprite.DrawSprite(Surface, checked (Cell.Position.X + Cell.Offset.X), checked (Cell.Position.Y + Cell.Offset.Y));
      }
    }

    private int Smallest(params int[] Values)
    {
      int num1;
      if (Values.Length >= 1)
      {
        num1 = Values[0];
        int[] numArray = Values;
        int index = 0;
        while (index < numArray.Length)
        {
          int num2 = numArray[index];
          if (num2 < num1)
            num1 = num2;
          checked { ++index; }
        }
      }
      return num1;
    }

    public void AddPiece(Sprite Sprite) => this.AddPiece(Sprite, new Padding(0));

    public void AddPiece(Sprite Sprite, Padding Margin)
    {
      Piece piece1 = new Piece();
      Piece piece2 = piece1;
      piece2.Index = checked (this.Pieces.Count + 1);
      piece2.Sprite = Sprite;
      this.Pieces.Add(piece1);
    }

    public Cell SelectCell(int X, int Y)
    {
      this.SelectedCell = this.aCells[X, Y];
      return this.SelectedCell;
    }

    public void ShiftColumn(int ColumnIndex, Axis Axis, int Amount)
    {
      int endPos = Axis.EndPos;
      int startPos = Axis.StartPos;
      int Index = endPos;
      while (Index >= startPos)
      {
        if (this.IsRow(Index) && this.IsRow(checked (Index + Amount)))
          this.aCells[ColumnIndex, Index].Swap(this.aCells[ColumnIndex, checked (Index + Amount)]);
        checked { Index += -1; }
      }
    }

    public Cell HitCell(int X, int Y)
    {
      int upperBound1 = this.aCells.GetUpperBound(0);
      int index1 = 0;
      while (index1 <= upperBound1)
      {
        int upperBound2 = this.aCells.GetUpperBound(1);
        int index2 = 0;
        while (index2 <= upperBound2)
        {
          Cell aCell = this.aCells[index1, index2];
          Sprite sprite = this.Pieces[aCell.PieceIndex].Sprite;
          if (aCell.Position.X <= X && aCell.Position.Y <= Y && checked (aCell.Position.X + sprite.Width) > X && checked (aCell.Position.Y + sprite.Height) > Y)
            return this.aCells[index1, index2];
          checked { ++index2; }
        }
        checked { ++index1; }
      }
      return (Cell) null;
    }

    public void Allocate(long Width, long Height, bool Randomize = false)
    {
      this.aCells = new Cell[checked ((int) Width + 1), checked ((int) Height + 1)];
      int num1 = checked ((int) Width);
      int X = 0;
      while (X <= num1)
      {
        int num2 = checked ((int) Height);
        int Y = 0;
        while (Y <= num2)
        {
          this.aCells[X, Y] = new Cell(X, Y, this);
          checked { ++Y; }
        }
        checked { ++X; }
      }
      if (!Randomize)
        return;
      this.RandomizeCells();
    }

    public List<Cell> FindSequence(
      int Lenght,
      Axis FirstAxis,
      Axis SecondAxis,
      bool StopAtEndOfAxis,
      bool InvertAxis)
    {
      List<Cell> sequence;
      try
      {
        sequence = this.FindSequence(Lenght, FirstAxis, SecondAxis, StopAtEndOfAxis, InvertAxis, 1)[0];
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        sequence = new List<Cell>();
        ProjectData.ClearProjectError();
      }
      return sequence;
    }

    public List<List<Cell>> FindSequence(
      int Lenght,
      Axis FirstAxis,
      Axis SecondAxis,
      bool StopAtEndOfAxis,
      bool InvertAxis,
      int Limit)
    {
      List<Cell> cellList1 = new List<Cell>();
      List<List<Cell>> sequence = new List<List<Cell>>();
      int startPos1 = FirstAxis.StartPos;
      int endPos1 = FirstAxis.EndPos;
      int distance1 = FirstAxis.Distance;
      int index1 = startPos1;
      while ((distance1 >> 31 ^ index1) <= (distance1 >> 31 ^ endPos1))
      {
        int startPos2 = SecondAxis.StartPos;
        int endPos2 = SecondAxis.EndPos;
        int distance2 = SecondAxis.Distance;
        int index2 = startPos2;
        while ((distance2 >> 31 ^ index2) <= (distance2 >> 31 ^ endPos2))
        {
          Cell cell = !InvertAxis ? this.aCells[index1, index2] : this.aCells[index2, index1];
          if (cellList1.Count > 0 && cell.PieceIndex == cellList1[0].PieceIndex)
          {
            cellList1.Add(cell);
            if (cellList1.Count >= Lenght)
            {
              sequence.Add(cellList1);
              List<Cell> cellList2 = cellList1;
              cellList1 = new List<Cell>();
              long num = (long) checked (cellList2.Count - 1);
              long index3 = 1;
              while (index3 <= num)
              {
                cellList1.Add(cellList2[checked ((int) index3)]);
                checked { ++index3; }
              }
              if (sequence.Count >= Limit & Limit > 0)
                goto label_15;
            }
          }
          else
          {
            cellList1.Clear();
            cellList1.Add(cell);
          }
          checked { index2 += distance2; }
        }
        if (StopAtEndOfAxis)
          cellList1.Clear();
        checked { index1 += distance1; }
      }
label_15:
      return sequence;
    }

    public void RandomizeCells() => this.RandomizeCells(new Axis(0, this.Width), new Axis(0, this.Height), 0, checked (this.Pieces.Count - 1));

    public void RandomizeCells(Axis FirstAxis, Axis SecondAxis, int MinValue, int MaxValue)
    {
      Random random = new Random();
      int startPos1 = FirstAxis.StartPos;
      int endPos1 = FirstAxis.EndPos;
      int index1 = startPos1;
      while (index1 <= endPos1)
      {
        int startPos2 = SecondAxis.StartPos;
        int endPos2 = SecondAxis.EndPos;
        int index2 = startPos2;
        while (index2 <= endPos2)
        {
          this.aCells[index1, index2].PieceIndex = checked ((int) Math.Round(unchecked (random.NextDouble() * (double) checked (MaxValue - MinValue) + (double) MinValue)));
          checked { ++index2; }
        }
        checked { ++index1; }
      }
    }

    public delegate void CellSelectedEventHandler(Cell Cell);

    public delegate void BoardDrawingEventHandler(ref bool Cancel);

    public delegate void BoardDrawedEventHandler();

    public delegate void RequenceFound(List<Cell> Cells);
  }
}
