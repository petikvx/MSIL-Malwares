// Decompiled with JetBrains decompiler
// Type: dotXMLToolsWPF.W2d.Opcodes.OpcodeFactory
// Assembly: LeaseMana, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 529A6AA6-AEB5-47F3-B86B-C5E3C5F9FA62
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-7e41c997a103e91b3815e9269a2d8806e5474c05620f8ff0ca591a586eae2f80.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;

namespace dotXMLToolsWPF.W2d.Opcodes
{
  public abstract class OpcodeFactory
  {
    private static readonly Dictionary<int, ISingleByteOpcodeFactory> _singleByteOpcodeFactories = new Dictionary<int, ISingleByteOpcodeFactory>();
    private static readonly Dictionary<string, IExtendedAsciiOpcodeFactory> _extendedAsciiOpcodeFactories = new Dictionary<string, IExtendedAsciiOpcodeFactory>();
    public const char extended_ascii_section_start_indicator = '(';
    public const char extended_ascii_section_end_indicator = ')';
    public const char extended_binary_section_start_indicator = '{';
    public const char extended_binary_section_end_indicator = '}';

    static OpcodeFactory()
    {
      foreach (Type type in ((IEnumerable<Type>) Assembly.GetAssembly(typeof (OpcodeFactory)).GetTypes()).Where<Type>((Func<Type, bool>) (t => t.IsClass)).Where<Type>((Func<Type, bool>) (t => !t.IsAbstract)).Where<Type>((Func<Type, bool>) (t => t.GetInterface(typeof (ISingleByteOpcodeFactory).Name) != (Type) null)).Where<Type>((Func<Type, bool>) (t => t.GetConstructor(Type.EmptyTypes) != (ConstructorInfo) null)))
      {
        ISingleByteOpcodeFactory instance = (ISingleByteOpcodeFactory) Activator.CreateInstance(type);
        if (OpcodeFactory._singleByteOpcodeFactories.ContainsKey(instance.OpcodeId))
          throw new InvalidOperationException(string.Format("A single byte opcode was already added to the list using the same id: {0}", (object) instance.OpcodeId));
        OpcodeFactory._singleByteOpcodeFactories[instance.OpcodeId] = instance;
      }
      foreach (Type type in ((IEnumerable<Type>) Assembly.GetAssembly(typeof (OpcodeFactory)).GetTypes()).Where<Type>((Func<Type, bool>) (t => t.IsClass)).Where<Type>((Func<Type, bool>) (t => !t.IsAbstract)).Where<Type>((Func<Type, bool>) (t => t.GetInterface(typeof (IExtendedAsciiOpcodeFactory).Name) != (Type) null)).Where<Type>((Func<Type, bool>) (t => t.GetConstructor(Type.EmptyTypes) != (ConstructorInfo) null)))
      {
        IExtendedAsciiOpcodeFactory instance = (IExtendedAsciiOpcodeFactory) Activator.CreateInstance(type);
        string opcodeId = instance.OpcodeId;
        if (OpcodeFactory._extendedAsciiOpcodeFactories.ContainsKey(opcodeId))
          throw new InvalidOperationException(string.Format("An extended ascii opcode was already added to the list using the same id: {0}", (object) instance.OpcodeId));
        OpcodeFactory._extendedAsciiOpcodeFactories[opcodeId] = instance;
      }
    }

    public abstract IOpcode ReadOpcode(Stream stream);

    protected static bool ExtendedAsciiIsBeginning(Stream stream)
    {
      if (stream.ReadByte() == 40)
        return true;
      --stream.Position;
      return false;
    }

    protected static bool ExtendedAsciiHasEnded(Stream stream)
    {
      OpcodeFactory.AdvanceThroughWhitespace(stream);
      if ((char) stream.ReadByte() == ')')
        return true;
      --stream.Position;
      return false;
    }

    public static IOpcode ParseSingleByteOpcode(int opcodeId, Stream stream)
    {
      ISingleByteOpcodeFactory byteOpcodeFactory;
      if (!OpcodeFactory._singleByteOpcodeFactories.TryGetValue(opcodeId, out byteOpcodeFactory))
        throw new OpcodeFactory.DwfParsingException(string.Format("Unrecognized single-byte opcode id: {0}", (object) opcodeId));
      return byteOpcodeFactory.ReadOpcode(stream);
    }

    public static IOpcode ReadExtendedAsciiOpcode(Stream stream)
    {
      string str = OpcodeFactory.ReadExtendedAsciiOpcodeName(stream);
      if (OpcodeFactory._extendedAsciiOpcodeFactories.ContainsKey(str))
        return OpcodeFactory._extendedAsciiOpcodeFactories[str].ReadOpcode(stream);
      string content = OpcodeFactory.PassThroughUnrecognizedExtendedAsciiOpcode(stream);
      Console.WriteLine(str + ": " + content);
      return (IOpcode) new UnrecognizedOpcode(str, content);
    }

    public static string PassThroughUnrecognizedExtendedAsciiOpcode(Stream stream)
    {
      bool flag1 = false;
      int num1 = 0;
      bool flag2 = false;
      string empty = string.Empty;
      do
      {
        int num2 = stream.ReadByte();
        empty += ((char) num2).ToString();
        if (flag1)
          flag1 = false;
        else if (flag2)
        {
          if (num2 == 39)
            flag2 = false;
        }
        else
        {
          int num3;
          switch (num2)
          {
            case 39:
              flag2 = true;
              goto label_17;
            case 40:
              ++num1;
              goto label_17;
            case 41:
              if (num1 != 0)
              {
                --num1;
                goto label_17;
              }
              else
                goto label_19;
            case 92:
              num3 = !flag1 ? 1 : 0;
              break;
            default:
              num3 = 0;
              break;
          }
          if (num3 != 0)
            flag1 = true;
          else if (num2 == 123)
            OpcodeFactory.ReadExtendedBinaryOpcode(stream);
label_17:;
        }
      }
      while (stream.Position < stream.Length);
label_19:
      if (stream.Position > stream.Length)
        throw new OpcodeFactory.DwfParsingException("Gone past stream length while reading extended ascii opcode.");
      return empty;
    }

    private static string ReadExtendedAsciiOpcodeName(Stream stream)
    {
      OpcodeFactory.AdvanceThroughWhitespace(stream);
      string empty = string.Empty;
      int num;
      do
      {
        num = stream.ReadByte();
        if (num != 32 && num != 41)
          empty += ((char) num).ToString();
        else
          break;
      }
      while (stream.Position < stream.Length);
      if (num == 41)
      {
        --stream.Position;
      }
      else
      {
        if (stream.Position > stream.Length)
          throw new OpcodeFactory.DwfParsingException("Gone past stream length while reading extended ascii opcode name.");
        OpcodeFactory.AdvanceThroughWhitespace(stream);
      }
      return empty;
    }

    public static IOpcode ReadExtendedBinaryOpcode(Stream stream)
    {
      int num = OpcodeFactory.ReadSignedLong(stream);
      if (num == 0)
      {
        while (OpcodeFactory.ReadChar(stream) != '}')
          ;
      }
      else
        stream.Position += (long) num;
      return (IOpcode) new UnrecognizedOpcode(string.Empty);
    }

    public static char ReadChar(Stream stream) => (char) stream.ReadByte();

    public static byte ReadUnsignedByte(Stream stream) => Convert.ToByte(stream.ReadByte());

    public static short ReadSignedShort(Stream stream)
    {
      byte[] numArray = new byte[2];
      stream.Read(numArray, 0, numArray.Length);
      OpcodeFactory.SwitchToBigEndianIfRequired(numArray);
      return BitConverter.ToInt16(numArray, 0);
    }

    public static ushort ReadUnsignedShort(Stream stream)
    {
      byte[] numArray = new byte[2];
      stream.Read(numArray, 0, numArray.Length);
      OpcodeFactory.SwitchToBigEndianIfRequired(numArray);
      return BitConverter.ToUInt16(numArray, 0);
    }

    public static int ReadSignedLong(Stream stream)
    {
      byte[] numArray = new byte[4];
      stream.Read(numArray, 0, numArray.Length);
      OpcodeFactory.SwitchToBigEndianIfRequired(numArray);
      return BitConverter.ToInt32(numArray, 0);
    }

    public static uint ReadUnsignedLong(Stream stream)
    {
      byte[] numArray = new byte[4];
      stream.Read(numArray, 0, numArray.Length);
      OpcodeFactory.SwitchToBigEndianIfRequired(numArray);
      return BitConverter.ToUInt32(numArray, 0);
    }

    public static long ReadIntegerString(Stream stream)
    {
      char[] source = new char[11]
      {
        '-',
        '0',
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9'
      };
      string empty = string.Empty;
      do
      {
        char ch = OpcodeFactory.ReadChar(stream);
        if (((IEnumerable<char>) source).Contains<char>(ch))
          empty += ch.ToString();
        else
          break;
      }
      while (stream.Position < stream.Length);
      return Convert.ToInt64(empty);
    }

    public static string ReadString(Stream stream)
    {
      string empty = string.Empty;
      int num = stream.ReadByte();
      switch (num)
      {
        case 34:
          return (string) null;
        case 39:
          bool flag = false;
          char ch;
          while ((ch = OpcodeFactory.ReadChar(stream)) != '\'' | flag)
          {
            flag = false;
            if (ch == '\\' && !flag)
              flag = true;
            else
              empty += ch.ToString();
          }
          return empty;
        default:
          char character = (char) num;
          do
          {
            empty += character.ToString();
            character = OpcodeFactory.ReadChar(stream);
          }
          while (!OpcodeFactory.IsWhitespace(character) && character != ')');
          if (character == ')')
            --stream.Position;
          return empty;
      }
    }

    public static void AdvanceThroughWhitespace(Stream stream)
    {
      do
        ;
      while (OpcodeFactory.IsWhitespace(OpcodeFactory.ReadChar(stream)));
      --stream.Position;
    }

    public static bool IsWhitespace(char character) => ((IEnumerable<char>) new char[4]
    {
      ' ',
      '\n',
      '\r',
      '\t'
    }).Contains<char>(character);

    private static void SwitchToBigEndianIfRequired(byte[] bytes)
    {
      if (BitConverter.IsLittleEndian)
        return;
      Array.Reverse((Array) bytes);
    }

    [Serializable]
    public class DwfParsingException : Exception
    {
      public DwfParsingException()
      {
      }

      public DwfParsingException(string message)
        : base(message)
      {
      }

      public DwfParsingException(string message, Exception inner)
        : base(message, inner)
      {
      }

      protected DwfParsingException(SerializationInfo info, StreamingContext context)
        : base(info, context)
      {
      }
    }
  }
}
