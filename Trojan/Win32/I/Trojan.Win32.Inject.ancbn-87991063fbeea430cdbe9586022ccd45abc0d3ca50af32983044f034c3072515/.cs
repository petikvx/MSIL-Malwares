// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Ressource, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7A61D5AB-B799-4526-BF58-A6DA1297213F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Inject.ancbn-87991063fbeea430cdbe9586022ccd45abc0d3ca50af32983044f034c3072515.exe

using System;
using System.Collections;
using System.IO;

internal sealed class \uE013
{
  public sealed class \uE009 : Stream, IDisposable
  {
    private const int \uE000 = 8192;
    private Stream \uE001;
    private bool \uE002;
    private bool \uE003;
    private \uE013.\uE00A \uE004;
    private byte[] \uE005;
    private int \uE006;

    public \uE009(Stream _param1)
      : this(_param1, false)
    {
    }

    public \uE009(Stream _param1, bool _param2)
    {
      this.\uE001 = _param1 != null ? _param1 : throw new ArgumentNullException();
      this.\uE002 = _param2;
      this.\uE003 = true;
      this.\uE005 = new byte[8192];
      this.\uE004 = new \uE013.\uE00A(_param1);
    }

    public Stream \uE000 => this.\uE001;

    public override bool CanSeek => false;

    public override bool CanRead => false;

    public override bool CanWrite => true;

    public override long Length => throw new NotImplementedException();

    public override long Position
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();

    public override void SetLength(long value) => throw new NotImplementedException();

    private void \uE004()
    {
      if (!this.\uE003)
        throw new InvalidOperationException("Stream is closed.");
    }

    private void \uE005() => this.\uE004();

    public override int Read(byte[] buffer, int offset, int count) => throw new NotSupportedException("Cannot decompress.");

    public override void Write(byte[] buffer, int offset, int count)
    {
      if (count < 0 || count > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (count));
      if (offset < 0 || offset > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (offset));
      if (offset + count > buffer.Length)
        throw new ArgumentException("offset + count out of buffer");
      this.\uE005();
      if (this.\uE006 + count > 8192)
        this.\uE006();
      if (count >= 8192)
      {
        int num;
        for (num = 0; count - num > 32768; num += 32768)
          this.\uE004.\uE000(buffer, offset + num, 32768, false);
        this.\uE004.\uE000(buffer, offset + num, count - num, false);
      }
      else
      {
        Array.Copy((Array) buffer, offset, (Array) this.\uE005, this.\uE006, count);
        this.\uE006 += count;
        if (this.\uE006 != 8192)
          return;
        this.\uE006();
      }
    }

    private void \uE006()
    {
      if (this.\uE006 <= 0)
        return;
      this.\uE004.\uE000(this.\uE005, 0, this.\uE006, false);
      this.\uE006 = 0;
    }

    public override void Flush()
    {
      this.\uE005();
      if (this.\uE006 > 0)
        this.\uE006();
      this.\uE004.\uE000(true, false);
      this.\uE000.Flush();
    }

    private void \uE007()
    {
      if (this.\uE006 > 0)
        this.\uE004.\uE000(this.\uE005, 0, this.\uE006, true);
      else
        this.\uE004.\uE000(false, true);
    }

    void IDisposable.Dispose()
    {
      if (this.\uE003)
      {
        this.\uE007();
        this.\uE005 = (byte[]) null;
        this.\uE004 = (\uE013.\uE00A) null;
        if (!this.\uE002)
        {
          this.\uE001.Close();
          this.\uE001 = (Stream) null;
        }
        this.\uE003 = false;
      }
      this.Close();
    }
  }

  private sealed class \uE00A
  {
    public const int \uE000 = 32768;
    private Stream \uE001;
    private \uE013.\uE010 \uE002;
    private \uE013.\uE00C \uE003;

    public \uE00A(Stream _param1)
    {
      this.\uE001 = _param1 != null ? _param1 : throw new ArgumentNullException();
      this.\uE002 = new \uE013.\uE010(_param1);
      this.\uE003 = new \uE013.\uE00C();
    }

    public Stream \uE000 => this.\uE001;

    internal void \uE000(
      \uE013.\uE00F _param1,
      out int[] _param2,
      out int[] _param3,
      out int _param4)
    {
      _param2 = new int[286];
      _param3 = new int[30];
      _param4 = 0;
      int index1 = 0;
      int index2 = 0;
      while (index1 < _param1.\uE000.Count)
      {
        ushort index3 = (ushort) _param1.\uE000[index1];
        if (index3 <= (ushort) 256)
        {
          ++_param2[(int) index3];
          ++index1;
        }
        else
        {
          ++_param2[(int) index3];
          ++_param3[(int) (ushort) _param1.\uE000[index1 + 2]];
          index1 += 4;
          _param4 += (int) (byte) _param1.\uE001[index2] + (int) (byte) _param1.\uE001[index2 + 1];
          index2 += 2;
        }
      }
    }

    public void \uE000(bool _param1, bool _param2)
    {
      this.\uE002.\uE000(_param2);
      if (_param1)
      {
        this.\uE002.\uE003(0, 2);
        this.\uE002.\uE000();
        this.\uE002.\uE003(0, 16);
        this.\uE002.\uE003((int) ushort.MaxValue, 16);
      }
      else
      {
        this.\uE002.\uE003(1, 2);
        \uE00F obj = \uE00D.\uE011[256];
        this.\uE002.\uE004(obj.\uE000, obj.\uE001);
      }
      if (!_param2)
        return;
      this.\uE002.\uE000();
    }

    public void \uE000(byte[] _param1, int _param2, int _param3, bool _param4)
    {
      if (_param3 > 32768)
        throw new ArgumentOutOfRangeException();
      \uE013.\uE00F obj = this.\uE003.\uE002(_param1, _param2, _param3);
      if (obj == null)
        throw new InvalidOperationException();
      if (obj.\uE002 != _param3)
        throw new InvalidOperationException();
      obj.\uE000();
      int[] numArray1;
      int[] numArray2;
      int num1;
      this.\uE000(obj, out numArray1, out numArray2, out num1);
      int[] numArray3 = \uE00D.\uE000(numArray1);
      int[] numArray4 = \uE00D.\uE000(numArray2);
      int num2 = (4 + _param3) * 8;
      int num3 = this.\uE002.\uE000 >= 3 ? num2 + (this.\uE002.\uE000 - 3) : num2 + (5 + this.\uE002.\uE000);
      int num4 = \uE00D.\uE002(numArray3, numArray1) + \uE00D.\uE002(numArray4, numArray2) + num1;
      int num5 = \uE00D.\uE003(numArray3, numArray4) + num1;
      bool flag1 = num5 <= num4 || num3 <= num4;
      if (!flag1)
      {
        int num6 = num4 + this.\uE000(numArray3, numArray4);
        flag1 = num5 <= num6 || num3 <= num6;
      }
      bool flag2 = num3 < num5;
      this.\uE002.\uE000(_param4);
      if (flag2 && flag1)
      {
        this.\uE002.\uE003(0, 2);
        this.\uE002.\uE000();
        int num7 = _param3;
        int num8 = ~_param3 & (int) ushort.MaxValue;
        this.\uE002.\uE003(num7, 16);
        this.\uE002.\uE003(num8, 16);
        this.\uE002.\uE000();
        this.\uE000(_param1, _param2, _param3);
      }
      else
      {
        \uE00F[] objArray1;
        \uE00F[] objArray2;
        if (flag1)
        {
          this.\uE002.\uE003(1, 2);
          objArray1 = \uE00D.\uE011;
          objArray2 = \uE00D.\uE012;
        }
        else
        {
          this.\uE002.\uE003(2, 2);
          this.\uE000(numArray3, numArray4);
          objArray1 = \uE00D.\uE000(numArray3);
          objArray2 = \uE00D.\uE000(numArray4);
        }
        this.\uE000(obj, objArray1, objArray2);
      }
      if (!_param4)
        return;
      this.\uE002.\uE000();
    }

    private void \uE000(\uE013.\uE00F _param1, \uE00F[] _param2, \uE00F[] _param3)
    {
      int index1 = 0;
      int index2 = 0;
      while (index1 < _param1.\uE000.Count)
      {
        int index3 = (int) (ushort) _param1.\uE000[index1];
        if (index3 <= 256)
        {
          \uE00F obj = _param2[index3];
          this.\uE002.\uE004(obj.\uE000, obj.\uE001);
          ++index1;
        }
        else
        {
          \uE00F obj = _param2[index3];
          this.\uE002.\uE004(obj.\uE000, obj.\uE001);
          if ((byte) _param1.\uE001[index2] > (byte) 0)
            this.\uE002.\uE003((int) (ushort) _param1.\uE000[index1 + 1], (int) (byte) _param1.\uE001[index2]);
          int index4 = index1 + 2;
          int index5 = index2 + 1;
          obj = _param3[(int) (ushort) _param1.\uE000[index4]];
          this.\uE002.\uE004(obj.\uE000, obj.\uE001);
          if ((byte) _param1.\uE001[index5] > (byte) 0)
            this.\uE002.\uE003((int) (ushort) _param1.\uE000[index4 + 1], (int) (byte) _param1.\uE001[index5]);
          index1 = index4 + 2;
          index2 = index5 + 1;
        }
      }
    }

    private void \uE000(byte[] _param1, int _param2, int _param3) => this.\uE000.Write(_param1, _param2, _param3);

    private void \uE000(int[] _param1, int[] _param2)
    {
      int[] numArray1 = new int[19];
      int num1 = 286;
      while (num1 > 257 && _param1[num1 - 1] == 0)
        --num1;
      int length = 30;
      while (length > 1 && _param2[length - 1] == 0)
        --length;
      int[] destinationArray = new int[num1 + length];
      Array.Copy((Array) _param1, 0, (Array) destinationArray, 0, num1);
      Array.Copy((Array) _param2, 0, (Array) destinationArray, num1, length);
      int[] numArray2 = \uE00D.\uE000(destinationArray, 0, destinationArray.Length);
      for (int index = 0; index < numArray2.Length; ++index)
      {
        ++numArray1[numArray2[index]];
        if (numArray2[index] >= 16)
          ++index;
      }
      int[] numArray3 = \uE00D.\uE000(numArray1, 7);
      int[] numArray4 = \uE00D.\uE014;
      int num2 = 19;
      while (num2 > 4 && numArray3[numArray4[num2 - 1]] == 0)
        --num2;
      int num3 = num1 - 257;
      int num4 = length - 1;
      int num5 = num2 - 4;
      \uE00F[] objArray = \uE00D.\uE000(numArray3);
      this.\uE002.\uE003(num3, 5);
      this.\uE002.\uE003(num4, 5);
      this.\uE002.\uE003(num5, 4);
      for (int index = 0; index < num2; ++index)
        this.\uE002.\uE003(numArray3[numArray4[index]], 3);
      for (int index1 = 0; index1 < numArray2.Length; ++index1)
      {
        int index2 = numArray2[index1];
        \uE00F obj = objArray[index2];
        this.\uE002.\uE004(obj.\uE000, obj.\uE001);
        if (index2 >= 16)
        {
          ++index1;
          this.\uE002.\uE003(numArray2[index1], \uE00D.\uE000(index2));
        }
      }
    }

    private int \uE000(int[] _param1, int[] _param2)
    {
      int[] numArray1 = new int[19];
      int num1 = 0;
      int num2 = 286;
      while (num2 > 257 && _param1[num2 - 1] == 0)
        --num2;
      int[] numArray2 = \uE00D.\uE000(_param1, 0, num2);
      for (int index = 0; index < numArray2.Length; ++index)
      {
        ++numArray1[numArray2[index]];
        if (numArray2[index] >= 16)
        {
          num1 += \uE00D.\uE000(numArray2[index]);
          ++index;
        }
      }
      int num3 = 30;
      while (num3 > 1 && _param2[num3 - 1] == 0)
        --num3;
      int[] numArray3 = \uE00D.\uE000(_param2, 0, num3);
      for (int index = 0; index < numArray3.Length; ++index)
      {
        ++numArray1[numArray3[index]];
        if (numArray3[index] >= 16)
        {
          num1 += \uE00D.\uE000(numArray3[index]);
          ++index;
        }
      }
      int[] numArray4 = \uE00D.\uE000(numArray1);
      int num4 = \uE00D.\uE002(numArray1, numArray4);
      int[] numArray5 = \uE00D.\uE014;
      int num5 = 19;
      while (num5 > 4 && numArray4[numArray5[num5 - 1]] == 0)
        --num5;
      return 14 + (num5 - 4 + 4) * 3 + num4 + num1;
    }
  }

  private sealed class \uE00B
  {
    public static readonly \uE013.\uE00B \uE000 = new \uE013.\uE00B()
    {
      \uE004 = 8,
      \uE005 = 32,
      \uE006 = 128,
      \uE007 = 256
    };
    private int \uE001;
    private int \uE002;
    private int \uE003;
    private int \uE004;

    public int \uE004
    {
      get => this.\uE001;
      set => this.\uE001 = value;
    }

    public int \uE005
    {
      get => this.\uE002;
      set => this.\uE002 = value;
    }

    public int \uE006
    {
      get => this.\uE003;
      set => this.\uE003 = value;
    }

    public int \uE007
    {
      get => this.\uE004;
      set => this.\uE004 = value;
    }
  }

  private sealed class \uE00C
  {
    private const int \uE000 = 258;
    private const int \uE001 = 32768;
    private \uE013.\uE00E \uE002;
    private \uE013.\uE00D \uE003;
    private \uE013.\uE00B \uE004;
    private int \uE005;

    internal \uE00C()
      : this(\uE013.\uE00B.\uE000)
    {
    }

    internal \uE00C(\uE013.\uE00B _param1)
    {
      this.\uE004 = _param1;
      this.\uE002 = new \uE013.\uE00E(65536);
      this.\uE003 = new \uE013.\uE00D(32768);
      this.\uE005 = 0;
    }

    internal \uE013.\uE00B \uE000 => this.\uE004;

    public \uE013.\uE00F \uE002(byte[] _param1, int _param2, int _param3)
    {
      if (this.\uE002.\uE004 + _param3 > this.\uE002.\uE003)
      {
        int num = this.\uE002.\uE004 - 32768;
        this.\uE002.\uE000(num);
        if (this.\uE005 >= num)
        {
          this.\uE005 -= num;
        }
        else
        {
          this.\uE003.\uE000(num - this.\uE005);
          this.\uE005 = 0;
        }
      }
      int num1 = this.\uE002.\uE004;
      this.\uE002.\uE000(_param1, _param2, _param3);
      if (this.\uE005 < num1)
        this.\uE003.\uE000(this.\uE002.\uE000, this.\uE005, num1 - this.\uE005);
      return this.\uE000.\uE006 <= 0 ? this.\uE003(this.\uE002.\uE000, num1, _param3) : this.\uE000(this.\uE003, this.\uE002.\uE000, num1, _param3, out this.\uE005);
    }

    private \uE013.\uE00F \uE003(byte[] _param1, int _param2, int _param3)
    {
      \uE013.\uE00F obj = new \uE013.\uE00F();
      obj.\uE000.Capacity = _param3 + 1;
      for (int index = 0; index < _param3; ++index)
        obj.\uE000(_param1[index]);
      return obj;
    }

    private \uE013.\uE00F \uE000(
      \uE013.\uE00D _param1,
      byte[] _param2,
      int _param3,
      int _param4,
      out int _param5)
    {
      \uE013.\uE00F obj1 = new \uE013.\uE00F();
      object obj2 = (object) null;
      int num = 0;
      while (num < _param4 - 2)
      {
        \uE013.\uE00D.\uE009 obj3 = _param1.\uE000(_param2, _param3 + num);
        if (obj3 != null)
        {
          object obj4;
          if (obj2 != null)
          {
            obj4 = obj2;
            obj2 = (object) null;
          }
          else
            obj4 = (object) this.\uE000(_param2, _param3, _param4, num, obj3, 3);
          \uE013.\uE00C.\uE009 obj5 = (\uE013.\uE00C.\uE009) obj4;
          bool flag = obj5.\uE001 >= 3;
          if (flag && num < _param4 - 3 && obj5.\uE001 < this.\uE004.\uE005)
          {
            \uE013.\uE00D.\uE009 obj6 = _param1.\uE000(_param2, _param3 + num + 1);
            if (obj6 != null)
            {
              \uE013.\uE00C.\uE009 obj7 = this.\uE000(_param2, _param3, _param4, num + 1, obj6, obj5.\uE001 + 1);
              if (obj7.\uE001 > obj5.\uE001)
              {
                obj2 = (object) obj7;
                flag = false;
              }
            }
          }
          if (flag)
          {
            obj1.\uE000(num - obj5.\uE000, obj5.\uE001);
            _param1.\uE000(_param2, _param3 + num);
            num += obj5.\uE001;
            _param1.\uE000(obj5.\uE001 - 1);
          }
          else
          {
            obj1.\uE000(_param2[_param3 + num]);
            _param1.\uE000(_param2, _param3 + num);
            ++num;
          }
        }
        else
        {
          obj1.\uE000(_param2[_param3 + num]);
          _param1.\uE000(_param2, _param3 + num);
          ++num;
        }
      }
      _param5 = _param3 + num;
      for (; num < _param4; ++num)
        obj1.\uE000(_param2[_param3 + num]);
      return obj1;
    }

    private \uE013.\uE00C.\uE009 \uE000(
      byte[] _param1,
      int _param2,
      int _param3,
      int _param4,
      \uE013.\uE00D.\uE009 _param5,
      int _param6)
    {
      int num1 = this.\uE004.\uE007;
      int num2 = 0;
      int num3 = -1;
      int num4 = 0;
      int num5 = _param6 - 1;
      int num6 = _param2 + _param4;
      while (_param5.\uE000())
      {
        int num7 = 0;
        int num8 = _param4 - _param5.\uE000;
        if (_param4 + num5 < _param3)
        {
          int num9 = _param2 + num8;
          if ((int) _param1[num9 + num5] == (int) _param1[num6 + num5])
          {
            while (num7 < 258 && _param4 + num7 < _param3 && (int) _param1[num9 + num7] == (int) _param1[num6 + num7])
              ++num7;
            if (num7 >= num2)
            {
              num2 = num7;
              num5 = num7;
              num3 = num8;
              if (num2 >= this.\uE004.\uE006)
                break;
            }
            if (num2 >= this.\uE004.\uE004)
              num1 >>= 2;
          }
          if (++num4 >= num1)
            break;
        }
        else
          break;
      }
      return new \uE013.\uE00C.\uE009()
      {
        \uE001 = num2,
        \uE000 = num3
      };
    }

    private struct \uE009
    {
      public int \uE000;
      public int \uE001;
    }
  }

  private sealed class \uE00D
  {
    private const int \uE000 = 16777216;
    private const int \uE001 = 256;
    private const ushort \uE002 = 65535;
    private const ushort \uE003 = 0;
    private int \uE004;
    private ushort[] \uE005;
    private int[] \uE006;
    private int \uE007;

    internal \uE00D(int _param1)
    {
      this.\uE004 = _param1;
      this.\uE005 = new ushort[this.\uE004];
      this.\uE006 = new int[256];
      this.\uE007 = 0;
      for (int index = 0; index < 256; ++index)
        this.\uE006[index] = (int) ushort.MaxValue;
    }

    internal \uE013.\uE00D.\uE009 \uE000(byte[] _param1, int _param2)
    {
      int index = \uE013.\uE00D.\uE000(_param1, _param2);
      return this.\uE006[index] == (int) ushort.MaxValue || this.\uE007 - this.\uE006[index] > this.\uE004 ? (\uE013.\uE00D.\uE009) null : new \uE013.\uE00D.\uE009(this, this.\uE007 - this.\uE006[index]);
    }

    internal void \uE000(byte[] _param1, int _param2)
    {
      int index1 = \uE013.\uE00D.\uE000(_param1, _param2);
      this.\uE005[this.\uE007 % this.\uE004] = this.\uE006[index1] == (int) ushort.MaxValue || this.\uE007 - this.\uE006[index1] >= this.\uE004 ? (ushort) 0 : (ushort) (this.\uE007 - this.\uE006[index1]);
      this.\uE006[index1] = this.\uE007;
      if (++this.\uE007 < 16777216)
        return;
      int num1 = this.\uE007 - this.\uE004;
      int num2 = num1 - num1 % this.\uE004;
      for (int index2 = 0; index2 < this.\uE006.Length; ++index2)
      {
        if (this.\uE006[index2] >= num2)
          this.\uE006[index2] -= num2;
        else
          this.\uE006[index2] = 0;
      }
      this.\uE007 -= num2;
    }

    internal void \uE000(byte[] _param1, int _param2, int _param3)
    {
      for (int index = 0; index < _param3; ++index)
        this.\uE000(_param1, _param2 + index);
    }

    internal void \uE000(int _param1) => this.\uE007 += _param1;

    private static int \uE000(byte[] _param0, int _param1) => (int) (byte) ((int) _param0[_param1] + (int) _param0[_param1 + 1] + (int) _param0[_param1 + 2]);

    internal sealed class \uE009
    {
      private \uE013.\uE00D \uE000;
      private int \uE001;
      private int \uE002;

      internal \uE009(\uE013.\uE00D _param1, int _param2)
      {
        this.\uE000 = _param1;
        this.\uE001 = _param2;
      }

      internal int \uE000 => this.\uE001;

      internal bool \uE000()
      {
        switch (this.\uE002)
        {
          case 0:
            this.\uE002 = 1;
            return true;
          case 1:
            ushort num = this.\uE000.\uE005[(this.\uE000.\uE007 - this.\uE001) % this.\uE000.\uE004];
            if (num == (ushort) 0)
            {
              this.\uE002 = 2;
              return false;
            }
            this.\uE001 += (int) num;
            if (this.\uE001 <= this.\uE000.\uE004)
              return true;
            this.\uE002 = 2;
            return false;
          default:
            return false;
        }
      }
    }
  }

  private sealed class \uE00E
  {
    private int \uE000;
    private byte[] \uE001;
    private int \uE002;

    public \uE00E(int _param1)
    {
      this.\uE000 = _param1;
      this.\uE001 = new byte[_param1];
      this.\uE002 = 0;
    }

    public byte[] \uE000 => this.\uE001;

    public int \uE003 => this.\uE000;

    public int \uE004 => this.\uE002;

    public void \uE000(byte[] _param1, int _param2, int _param3)
    {
      Array.Copy((Array) _param1, _param2, (Array) this.\uE001, this.\uE002, _param3);
      this.\uE002 += _param3;
    }

    public void \uE000(int _param1)
    {
      Array.Copy((Array) this.\uE001, _param1, (Array) this.\uE001, 0, this.\uE004 - _param1);
      this.\uE002 -= _param1;
    }
  }

  private sealed class \uE00F
  {
    internal ArrayList \uE000 = new ArrayList();
    internal ArrayList \uE001 = new ArrayList();
    internal int \uE002;

    public \uE00F() => this.\uE002 = 0;

    public void \uE000(byte _param1)
    {
      this.\uE000.Add((object) (ushort) _param1);
      ++this.\uE002;
    }

    public void \uE000(int _param1, int _param2)
    {
      if (_param1 < 1 || _param1 > 32768)
        throw new ArgumentOutOfRangeException();
      if (_param2 < 3 || _param2 > 258)
        throw new ArgumentOutOfRangeException();
      int num1;
      int num2;
      int num3;
      \uE00D.\uE00B(_param2, out num2, out num1, out num3);
      int num4;
      int num5;
      int num6;
      \uE00D.\uE00C(_param1, out num4, out num6, out num5);
      this.\uE000.Add((object) (ushort) num2);
      this.\uE000.Add((object) (ushort) num1);
      this.\uE001.Add((object) (byte) num3);
      this.\uE000.Add((object) (ushort) num4);
      this.\uE000.Add((object) (ushort) num6);
      this.\uE001.Add((object) (byte) num5);
      this.\uE002 += _param2;
    }

    internal void \uE000() => this.\uE000.Add((object) (ushort) 256);
  }

  private sealed class \uE010
  {
    private uint \uE000;
    private int \uE001;
    private Stream \uE002;

    internal \uE010(Stream _param1) => this.\uE002 = _param1;

    internal Stream \uE000 => this.\uE002;

    internal int \uE000 => (32 - this.\uE001) % 8;

    internal void \uE000(bool _param1) => this.\uE003(_param1 ? 1 : 0, 1);

    internal void \uE003(int _param1, int _param2)
    {
      uint num1 = this.\uE000 | checked ((uint) _param1) << this.\uE001;
      int num2;
      for (num2 = this.\uE001 + _param2; num2 >= 8; num2 -= 8)
      {
        this.\uE000.WriteByte((byte) num1);
        num1 >>= 8;
      }
      this.\uE000 = num1;
      this.\uE001 = num2;
    }

    internal void \uE004(int _param1, int _param2)
    {
      int num = 0;
      for (int index = _param2 - 1; index >= 0; --index)
      {
        num = num << 1 | _param1 & 1;
        _param1 >>= 1;
      }
      this.\uE003(num, _param2);
    }

    internal void \uE000()
    {
      if (this.\uE001 <= 0)
        return;
      this.\uE000.WriteByte((byte) this.\uE000);
      this.\uE000 = 0U;
      this.\uE001 = 0;
    }
  }
}
