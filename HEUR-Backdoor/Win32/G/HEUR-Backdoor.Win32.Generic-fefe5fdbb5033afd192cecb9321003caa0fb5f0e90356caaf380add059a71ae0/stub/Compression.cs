// Decompiled with JetBrains decompiler
// Type: stub.Compression
// Assembly: stub, Version=6.2.15.2, Culture=neutral, PublicKeyToken=null
// MVID: 6CAE2B56-3E3C-414E-A63C-DF5759216B41
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-fefe5fdbb5033afd192cecb9321003caa0fb5f0e90356caaf380add059a71ae0.exe

using Microsoft.VisualBasic.CompilerServices;
using stub.My;
using System;
using System.IO;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Ⴐ;

namespace stub
{
  public class Compression
  {
    public static byte[] Compress(byte[] bytData)
    {
      MemoryStream memoryStream = new MemoryStream();
      try
      {
        GZipStream gzipStream;
        switch (3)
        {
          case 2:
            try
            {
              int num = 0;
              while (true)
              {
                switch (num)
                {
                  case 1:
                    num = 5;
                    continue;
                  case 2:
                  case 4:
                  case 6:
                    Ⴈ.Ⴗ((Stream) gzipStream, 78, 106);
                    bytData = new byte[checked (MyComputer.Ⴀ(memoryStream, 941, 1023).Length - 1 + 1)];
                    goto case 1;
                  case 5:
                    goto label_8;
                  default:
                    MyComputer.Ⴗ(gzipStream, bytData, 0, bytData.Length, 699, 646);
                    num = 4;
                    continue;
                }
              }
label_8:
              bytData = MyComputer.Ⴀ(memoryStream, 411, 457);
            }
            finally
            {
              int num = 0;
              while (true)
              {
                switch (num)
                {
                  case 1:
                    goto label_14;
                  case 4:
                    gzipStream.Dispose();
                    goto case 5;
                  case 5:
                    num = 1;
                    continue;
                  default:
                    num = gzipStream == null ? 1 : 4;
                    continue;
                }
              }
label_14:;
            }
            switch (3)
            {
              case 0:
              case 4:
                break;
              default:
                Ⴈ.Ⴗ((Stream) memoryStream, 169, 141);
                break;
            }
            break;
          default:
            gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Compress);
            goto case 2;
        }
      }
      finally
      {
        int num = 5;
        while (true)
        {
          switch (num)
          {
            case 0:
            case 6:
              goto label_21;
            case 1:
            case 2:
              memoryStream.Dispose();
              num = 0;
              continue;
            default:
              num = memoryStream == null ? 0 : 1;
              continue;
          }
        }
label_21:;
      }
      byte[] numArray;
      switch (2)
      {
        case 1:
        case 4:
          return numArray;
        default:
          numArray = bytData;
          goto case 1;
      }
    }

    public static byte[] Decompress(byte[] bytData)
    {
      MemoryStream memoryStream = new MemoryStream(bytData);
      try
      {
        GZipStream gzipStream;
        switch (0)
        {
          case 2:
            try
            {
              int num1 = 3;
              int num2;
              int num3;
              while (true)
              {
                switch (num1)
                {
                  case 0:
                    num1 = 4;
                    continue;
                  case 1:
                    num1 = 0;
                    continue;
                  case 2:
                    num3 = Ⴐ.Ⴅ.Ⴃ(gzipStream, bytData, num2, 1024, 830, 847);
                    checked { num2 += num3; }
                    num1 = 9;
                    continue;
                  case 4:
                    goto label_14;
                  case 5:
                  case 7:
                    num1 = 6;
                    continue;
                  case 6:
                    bytData = (byte[]) MyApplication.Ⴃ((Array) bytData, (Array) new byte[checked (num2 + 1024 - 1 + 1)], 816, 774);
                    goto case 8;
                  case 8:
                    num1 = 2;
                    continue;
                  case 9:
                    num1 = num3 >= 1024 ? 7 : 10;
                    continue;
                  case 10:
                    bytData = (byte[]) MyApplication.Ⴃ((Array) bytData, (Array) new byte[checked (num2 - 1 + 1)], 899, 949);
                    goto case 1;
                  default:
                    num2 = 0;
                    num1 = 6;
                    continue;
                }
              }
label_14:
              Ⴈ.Ⴗ((Stream) gzipStream, 627, 599);
            }
            finally
            {
              int num = 1;
              while (true)
              {
                switch (num)
                {
                  case 0:
                    goto label_20;
                  case 2:
                    gzipStream.Dispose();
                    goto case 3;
                  case 3:
                  case 4:
                    num = 0;
                    continue;
                  default:
                    num = gzipStream == null ? 0 : 2;
                    continue;
                }
              }
label_20:;
            }
            switch (3)
            {
              case 0:
              case 1:
              case 2:
                break;
              default:
                Ⴈ.Ⴗ((Stream) memoryStream, 381, 345);
                break;
            }
            break;
          default:
            gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress);
            goto case 2;
        }
      }
      finally
      {
        int num = 3;
        while (true)
        {
          switch (num)
          {
            case 1:
              memoryStream.Dispose();
              num = 6;
              continue;
            case 2:
            case 4:
            case 6:
              goto label_27;
            default:
              num = memoryStream == null ? 6 : 1;
              continue;
          }
        }
label_27:;
      }
      byte[] numArray;
      switch (2)
      {
        case 4:
          return numArray;
        default:
          numArray = bytData;
          goto case 4;
      }
    }

    static Compression() => Ⴈ.Ⴃ();

    internal static System.Type Ⴓ([In] RuntimeTypeHandle obj0, [In] int obj1, [In] int obj2)
    {
label_3:
      int num1;
      switch (obj2 ^ obj1)
      {
        case 15:
          num1 = 4;
          break;
        default:
          num1 = 7;
          break;
      }
      int num2 = num1;
      while (true)
      {
        switch (num2)
        {
          case 0:
          case 2:
          case 4:
            goto label_8;
          case 1:
          case 7:
            num2 = 5;
            continue;
          case 3:
            num2 = 5;
            continue;
          case 5:
            goto label_3;
          default:
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (stub.Compression.Ⴓ);
            num2 = 5;
            continue;
        }
      }
label_8:
      return System.Type.GetTypeFromHandle(obj0);
    }

    internal static void Ⴅ([In] Exception obj0, [In] int obj1, [In] int obj2)
    {
      int num1 = 4;
      while (true)
      {
        switch (num1)
        {
          case 0:
          case 3:
          case 5:
            goto label_7;
          case 1:
          case 2:
            num1 = 4;
            continue;
          default:
            int num2;
            switch (obj2 ^ obj1)
            {
              case 63:
                num2 = 3;
                break;
              default:
                num2 = 1;
                break;
            }
            num1 = num2;
            continue;
        }
      }
label_7:
      ProjectData.SetProjectError(obj0);
    }

    internal static int Ⴀ([In] byte[] obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
label_3:
      int num1;
      switch (obj3 ^ obj2)
      {
        case 104:
          num1 = 1;
          break;
        default:
          num1 = 6;
          break;
      }
      int num2 = num1;
      while (true)
      {
        switch (num2)
        {
          case 0:
            goto label_3;
          case 1:
          case 2:
          case 5:
            goto label_8;
          case 4:
            num2 = 0;
            continue;
          case 6:
            num2 = 0;
            continue;
          default:
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (stub.Compression.Ⴀ);
            num2 = 0;
            continue;
        }
      }
label_8:
      return BitConverter.ToInt32(obj0, obj1);
    }

    internal static void Ⴐ([In] ListControl obj0, [In] bool obj1, [In] int obj2, [In] int obj3)
    {
      int num1 = 2;
      while (true)
      {
        switch (num1)
        {
          case 0:
          case 1:
          case 3:
            goto label_7;
          case 4:
            num1 = 2;
            continue;
          default:
            int num2;
            switch (obj3 ^ obj2)
            {
              case 32:
                num2 = 3;
                break;
              default:
                num2 = 4;
                break;
            }
            num1 = num2;
            continue;
        }
      }
label_7:
      obj0.FormattingEnabled = obj1;
    }

    internal static string Ⴗ([In] string obj0, [In] string obj1, [In] int obj2, [In] int obj3)
    {
label_0:
      switch ((obj3 ^ obj2) - 90)
      {
        case 0:
          return obj0 + obj1;
        default:
          goto label_0;
      }
    }

    internal static AppDomain Ⴄ([In] int obj0, [In] int obj1)
    {
label_0:
      switch ((obj1 ^ obj0) - 90)
      {
        case 0:
          return AppDomain.CurrentDomain;
        default:
          goto label_0;
      }
    }
  }
}
