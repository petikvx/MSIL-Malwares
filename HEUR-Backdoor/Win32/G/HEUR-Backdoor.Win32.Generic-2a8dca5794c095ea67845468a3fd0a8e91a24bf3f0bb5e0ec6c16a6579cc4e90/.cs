// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Protected, Version=6.2.8400.0, Culture=neutral, PublicKeyToken=null
// MVID: 52CBE997-50C3-42B2-A704-C908D57869A5
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-2a8dca5794c095ea67845468a3fd0a8e91a24bf3f0bb5e0ec6c16a6579cc4e90.exe

using System;
using System.Collections;

internal sealed class \uE02B
{
  internal static \uE02C[] \uE000 = new \uE02C[288];
  internal static \uE02C[] \uE001 = new \uE02C[32];
  internal static \uE02E \uE002;
  internal static readonly int[] \uE003 = new int[19];
  internal static readonly int[] \uE004;
  internal static readonly int[] \uE005;
  internal static readonly int[] \uE006;
  internal static readonly int[] \uE007;

  static \uE02B()
  {
    \uE02B.\uE003[0] = 16;
    \uE02B.\uE003[1] = 17;
    \uE02B.\uE003[2] = 18;
    \uE02B.\uE003[4] = 8;
    \uE02B.\uE003[5] = 7;
    \uE02B.\uE003[6] = 9;
    \uE02B.\uE003[7] = 6;
    \uE02B.\uE003[8] = 10;
    \uE02B.\uE003[9] = 5;
    \uE02B.\uE003[10] = 11;
    \uE02B.\uE003[11] = 4;
    \uE02B.\uE003[12] = 12;
    \uE02B.\uE003[13] = 3;
    \uE02B.\uE003[14] = 13;
    \uE02B.\uE003[15] = 2;
    \uE02B.\uE003[16] = 14;
    \uE02B.\uE003[17] = 1;
    \uE02B.\uE003[18] = 15;
    \uE02B.\uE004 = new int[29];
    \uE02B.\uE004[0] = 3;
    \uE02B.\uE004[1] = 4;
    \uE02B.\uE004[2] = 5;
    \uE02B.\uE004[3] = 6;
    \uE02B.\uE004[4] = 7;
    \uE02B.\uE004[5] = 8;
    \uE02B.\uE004[6] = 9;
    \uE02B.\uE004[7] = 10;
    \uE02B.\uE004[8] = 11;
    \uE02B.\uE004[9] = 13;
    \uE02B.\uE004[10] = 15;
    \uE02B.\uE004[11] = 17;
    \uE02B.\uE004[12] = 19;
    \uE02B.\uE004[13] = 23;
    \uE02B.\uE004[14] = 27;
    \uE02B.\uE004[15] = 31;
    \uE02B.\uE004[16] = 35;
    \uE02B.\uE004[17] = 43;
    \uE02B.\uE004[18] = 51;
    \uE02B.\uE004[19] = 59;
    \uE02B.\uE004[20] = 67;
    \uE02B.\uE004[21] = 83;
    \uE02B.\uE004[22] = 99;
    \uE02B.\uE004[23] = 115;
    \uE02B.\uE004[24] = 131;
    \uE02B.\uE004[25] = 163;
    \uE02B.\uE004[26] = 195;
    \uE02B.\uE004[27] = 227;
    \uE02B.\uE004[28] = 258;
    \uE02B.\uE005 = new int[29];
    int index1 = 8;
    int num1 = 0;
    for (; index1 < 28; ++index1)
    {
      if (index1 % 4 == 0)
        ++num1;
      \uE02B.\uE005[index1] = num1;
    }
    \uE02B.\uE006 = new int[30];
    \uE02B.\uE006[0] = 1;
    \uE02B.\uE006[1] = 2;
    \uE02B.\uE006[2] = 3;
    \uE02B.\uE006[3] = 4;
    \uE02B.\uE006[4] = 5;
    \uE02B.\uE006[5] = 7;
    \uE02B.\uE006[6] = 9;
    \uE02B.\uE006[7] = 13;
    \uE02B.\uE006[8] = 17;
    \uE02B.\uE006[9] = 25;
    \uE02B.\uE006[10] = 33;
    \uE02B.\uE006[11] = 49;
    \uE02B.\uE006[12] = 65;
    \uE02B.\uE006[13] = 97;
    \uE02B.\uE006[14] = 129;
    \uE02B.\uE006[15] = 193;
    \uE02B.\uE006[16] = 257;
    \uE02B.\uE006[17] = 385;
    \uE02B.\uE006[18] = 513;
    \uE02B.\uE006[19] = 769;
    \uE02B.\uE006[20] = 1025;
    \uE02B.\uE006[21] = 1537;
    \uE02B.\uE006[22] = 2049;
    \uE02B.\uE006[23] = 3073;
    \uE02B.\uE006[24] = 4097;
    \uE02B.\uE006[25] = 6145;
    \uE02B.\uE006[26] = 8193;
    \uE02B.\uE006[27] = 12289;
    \uE02B.\uE006[28] = 16385;
    \uE02B.\uE006[29] = 24577;
    \uE02B.\uE007 = new int[30];
    int index2 = 4;
    int num2 = 0;
    for (; index2 < 30; ++index2)
    {
      if (index2 % 2 == 0)
        ++num2;
      \uE02B.\uE007[index2] = num2;
    }
    for (int index3 = 0; index3 <= 143; ++index3)
    {
      \uE02B.\uE000[index3].\uE000 = 48 + index3;
      \uE02B.\uE000[index3].\uE001 = 8;
    }
    for (int index4 = 144; index4 <= (int) byte.MaxValue; ++index4)
    {
      \uE02B.\uE000[index4].\uE000 = 400 + index4 - 144;
      \uE02B.\uE000[index4].\uE001 = 9;
    }
    for (int index5 = 256; index5 <= 279; ++index5)
    {
      \uE02B.\uE000[index5].\uE000 = index5 - 256;
      \uE02B.\uE000[index5].\uE001 = 7;
    }
    for (int index6 = 280; index6 <= 287; ++index6)
    {
      \uE02B.\uE000[index6].\uE000 = 192 + index6 - 280;
      \uE02B.\uE000[index6].\uE001 = 8;
    }
    for (int index7 = 0; index7 <= 31; ++index7)
    {
      \uE02B.\uE001[index7].\uE000 = index7;
      \uE02B.\uE001[index7].\uE001 = 5;
    }
    \uE02B.\uE002 = \uE02B.\uE000(\uE02B.\uE000, \uE02B.\uE001);
  }

  internal static int \uE002(int[] _param0, int[] _param1)
  {
    int num = 0;
    for (int index = 0; index < _param0.Length; ++index)
      num += _param0[index] * _param1[index];
    return num;
  }

  internal static int \uE003(int[] _param0, int[] _param1)
  {
    int num = 0;
    for (int index = 0; index < _param0.Length; ++index)
      num += _param0[index] * \uE02B.\uE000[index].\uE001;
    for (int index = 0; index < _param1.Length; ++index)
      num += _param1[index] * \uE02B.\uE001[index].\uE001;
    return num;
  }

  internal static \uE02C[] \uE000(int[] _param0)
  {
    \uE02C[] objArray = new \uE02C[_param0.Length];
    for (int index = 0; index < _param0.Length; ++index)
      objArray[index].\uE001 = _param0[index];
    \uE02B.\uE000(objArray);
    return objArray;
  }

  internal static void \uE000(\uE02C[] _param0)
  {
    int num1 = _param0[0].\uE001;
    for (int index = 1; index < _param0.Length; ++index)
    {
      if (num1 < _param0[index].\uE001)
        num1 = _param0[index].\uE001;
    }
    int[] numArray1 = new int[num1 + 1];
    for (int index = 0; index < _param0.Length; ++index)
      ++numArray1[_param0[index].\uE001];
    int[] numArray2 = new int[num1 + 1];
    int num2 = 0;
    numArray1[0] = 0;
    for (int index = 1; index <= num1; ++index)
    {
      num2 = num2 + numArray1[index - 1] << 1;
      numArray2[index] = num2;
    }
    for (int index1 = 0; index1 < _param0.Length; ++index1)
    {
      int index2 = _param0[index1].\uE001;
      if (index2 != 0)
      {
        _param0[index1].\uE000 = numArray2[index2];
        ++numArray2[index2];
      }
    }
  }

  internal static \uE02E \uE000(\uE02C[] _param0, \uE02C[] _param1) => new \uE02E()
  {
    \uE000 = \uE02B.\uE000(_param0),
    \uE001 = \uE02B.\uE000(_param1)
  };

  internal static \uE02D \uE000(\uE02C[] _param0)
  {
    \uE02B.\uE015[] objArray = new \uE02B.\uE015[_param0.Length];
    int num = 0;
    for (int index = 0; index < _param0.Length; ++index)
    {
      if (_param0[index].\uE001 > 0)
        objArray[num++] = new \uE02B.\uE015()
        {
          \uE000 = _param0[index],
          \uE001 = (ushort) index
        };
    }
    if (_param0.Length < 1)
      throw new InvalidOperationException();
    return \uE02B.\uE000(objArray, num, 0, 0);
  }

  private static \uE02D \uE000(
    \uE02B.\uE015[] _param0,
    int _param1,
    int _param2,
    int _param3)
  {
    \uE02B.\uE015[] objArray1 = new \uE02B.\uE015[_param1];
    \uE02B.\uE015[] objArray2 = new \uE02B.\uE015[_param1];
    \uE02D obj1 = new \uE02D();
    obj1.\uE000 = false;
    int num1;
    int num2 = num1 = 0;
    for (int index = 0; index < _param1; ++index)
    {
      \uE02B.\uE015 obj2 = _param0[index];
      if (obj2.\uE000.\uE001 == _param3 && obj2.\uE000.\uE000 == _param2)
      {
        obj1.\uE000 = true;
        obj1.\uE001 = obj2.\uE001;
      }
      else if ((obj2.\uE000.\uE000 >> obj2.\uE000.\uE001 - _param3 - 1 & 1) != 0)
        objArray2[num2++] = obj2;
      else
        objArray1[num1++] = obj2;
    }
    if (obj1.\uE000)
    {
      if (num2 > 0 || num1 > 0)
        throw new InvalidOperationException();
    }
    else
    {
      if (num1 > 0)
        obj1.\uE002 = \uE02B.\uE000(objArray1, num1, _param2 << 1, _param3 + 1);
      if (num2 > 0)
        obj1.\uE003 = \uE02B.\uE000(objArray2, num2, _param2 << 1 | 1, _param3 + 1);
    }
    return obj1;
  }

  internal static void \uE000(int _param0, out int _param1, out int _param2)
  {
    _param1 = \uE02B.\uE004[_param0 - 257];
    _param2 = \uE02B.\uE005[_param0 - 257];
  }

  internal static void \uE00A(int _param0, out int _param1, out int _param2, out int _param3)
  {
    int index = Array.BinarySearch<int>(\uE02B.\uE004, _param0);
    if (index < 0)
      index = ~index - 1;
    _param1 = index + 257;
    _param2 = _param0 - \uE02B.\uE004[index];
    _param3 = \uE02B.\uE005[index];
  }

  internal static void \uE00B(int _param0, out int _param1, out int _param2, out int _param3)
  {
    int index = Array.BinarySearch<int>(\uE02B.\uE006, _param0);
    if (index < 0)
      index = ~index - 1;
    _param1 = index;
    _param2 = _param0 - \uE02B.\uE006[index];
    _param3 = \uE02B.\uE007[index];
  }

  internal static int[] \uE000(int[] _param0, int _param1) => \uE02B.\uE000.\uE002(_param0, _param1);

  internal static int[] \uE000(int[] _param0) => \uE02B.\uE000.\uE002(_param0, 15);

  internal static int \uE000(int _param0)
  {
    switch (_param0)
    {
      case 16:
        return 2;
      case 17:
        return 3;
      case 18:
        return 7;
      default:
        return 0;
    }
  }

  internal static int[] \uE000(int[] _param0, int _param1, int _param2)
  {
    ArrayList arrayList = new ArrayList();
    int num1 = 0;
    while (num1 < _param2)
    {
      if (_param0[_param1 + num1] == 0)
      {
        int num2 = 0;
        do
        {
          ++num2;
        }
        while (num1 + num2 < _param2 && num2 < 138 && _param0[_param1 + num1 + num2] == 0);
        if (num2 < 3)
        {
          if (num2 >= 1)
            arrayList.Add((object) 0);
          if (num2 >= 2)
            arrayList.Add((object) 0);
        }
        else if (num2 < 11)
        {
          arrayList.Add((object) 17);
          arrayList.Add((object) (num2 - 3));
        }
        else
        {
          arrayList.Add((object) 18);
          arrayList.Add((object) (num2 - 11));
        }
        num1 += num2;
      }
      else
      {
        int num3 = _param0[_param1 + num1++];
        arrayList.Add((object) num3);
        int num4 = 0;
        while (num1 + num4 < _param2 && num4 < 6 && _param0[_param1 + num1 + num4] == num3)
          ++num4;
        if (num4 >= 3)
        {
          arrayList.Add((object) 16);
          arrayList.Add((object) (num4 - 3));
          num1 += num4;
        }
      }
    }
    return (int[]) arrayList.ToArray(typeof (int));
  }

  private sealed class \uE000
  {
    internal static int[] \uE002(int[] _param0, int _param1)
    {
      int[] items = new int[_param0.Length];
      int[] numArray1 = new int[_param0.Length];
      for (int index = 0; index < items.Length; ++index)
        items[index] = index;
      Array.Copy((Array) _param0, (Array) numArray1, _param0.Length);
      Array.Sort<int, int>(numArray1, items);
      int sourceIndex = 0;
      while (sourceIndex < numArray1.Length && numArray1[sourceIndex] == 0)
        ++sourceIndex;
      int[] destinationArray = new int[numArray1.Length - sourceIndex];
      Array.Copy((Array) numArray1, sourceIndex, (Array) destinationArray, 0, destinationArray.Length);
      int[] numArray2;
      if (destinationArray.Length == 0)
        numArray2 = new int[0];
      else if (destinationArray.Length == 1)
        numArray2 = new int[1]{ 1 };
      else
        numArray2 = \uE02B.\uE000.\uE003(destinationArray, _param1);
      int[] numArray3 = new int[_param0.Length];
      for (int index = 0; index < numArray2.Length; ++index)
        numArray3[items[index + sourceIndex]] = numArray2[index];
      return numArray3;
    }

    private static int[] \uE003(int[] _param0, int _param1)
    {
      int length = _param0.Length;
      int[][] numArray1 = new int[_param1][];
      numArray1[0] = _param0;
      int[] numArray2 = new int[_param0.Length / 2];
      for (int index = 0; index < numArray2.Length; ++index)
        numArray2[index] = _param0[index * 2] + _param0[index * 2 + 1];
      for (int index1 = 1; index1 < _param1; ++index1)
      {
        int[] numArray3 = \uE02B.\uE000.\uE000(numArray2, _param0);
        numArray1[index1] = numArray3;
        numArray2 = new int[numArray3.Length / 2];
        for (int index2 = 0; index2 < numArray2.Length; ++index2)
          numArray2[index2] = numArray3[index2 * 2] + numArray3[index2 * 2 + 1];
      }
      int[] numArray4 = new int[length];
      int num1 = length - 1;
      for (int index3 = _param1 - 1; index3 >= 0; --index3)
      {
        int[] numArray5 = numArray1[index3];
        int num2 = 0;
        int index4 = 0;
        for (int index5 = 0; index5 < num1 * 2; ++index5)
        {
          if (index4 < _param0.Length && _param0[index4] == numArray5[index5])
          {
            ++numArray4[index4];
            ++index4;
          }
          else
            ++num2;
        }
        num1 = num2;
      }
      return numArray4;
    }

    private static int[] \uE000(int[] _param0, int[] _param1)
    {
      int[] numArray = new int[_param0.Length + _param1.Length];
      int index1 = 0;
      int index2 = 0;
      int num = 0;
      while (index1 < _param0.Length && index2 < _param1.Length)
        numArray[num++] = _param0[index1] >= _param1[index2] ? _param1[index2++] : _param0[index1++];
      while (index1 < _param0.Length)
        numArray[num++] = _param0[index1++];
      while (index2 < _param1.Length)
        numArray[num++] = _param1[index2++];
      return numArray;
    }
  }

  private struct \uE015
  {
    internal \uE02C \uE000;
    internal ushort \uE001;
  }
}
