// Decompiled with JetBrains decompiler
// Type: MentQ.MentQInfoBox
// Assembly: جdk6氏صڤSnb, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC493AC2-8E19-4B7E-8F8B-A7CB6CD6346F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-PSW.MSIL.Fareit.gen-125c88c0a34185a8a6c38ba5e7d461ccc5b9d8a1acc87871a618c3e15c32be42.exe

using System;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;

namespace MentQ
{
  [Category("MentQ")]
  public class MentQInfoBox : Control
  {
    private bool _antialias;
    private Image _backgroundImage;
    private Image _cachedTransparentImage;
    private MentQInfoBox.Iconlayout _iconLayout;
    private bool _imageContainer;
    private Color _imageContainerColor;
    private int _imageTransparency;
    private string _title;
    private MentQInfoBox.UnderlineStyle _underline;
    private Color _underlineColor;
    private int _underlineSize;

    public MentQInfoBox()
    {
      this.ImageContainerColor = Color.FromArgb(100, 30, 30, 30);
      this.ImageContainer = false;
      this.UnderlineSize = 4;
      this.Underline = MentQInfoBox.UnderlineStyle.Full;
      this.UnderlineColor = Color.FromArgb(100, 70, 70, 70);
      this.AntiAliasImage = true;
      this.Size = new Size(220, 65);
      this.BackColor = MentQDefaults.MentQBlue;
      this.Font = new Font("Verdana", 11.25f, FontStyle.Regular);
      this.ForeColor = Color.White;
      this.DoubleBuffered = true;
      this.ImageTransparency = (int) byte.MaxValue;
      this.Title = nameof (Title);
      this.SetStyle(ControlStyles.UserPaint | ControlStyles.ResizeRedraw | ControlStyles.AllPaintingInWmPaint | ControlStyles.CacheText | ControlStyles.OptimizedDoubleBuffer, true);
    }

    [Category("Appearance")]
    public override string Text
    {
      get => base.Text;
      set
      {
        base.Text = value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public string Title
    {
      get => this._title;
      set
      {
        this._title = value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public int ImageTransparency
    {
      get => this._imageTransparency;
      set
      {
        this._imageTransparency = value;
        if (this.BackgroundImage != null)
          this._cachedTransparentImage = this.ImageTransparency <= 0 ? (Image) null : this.EditBackgroundImage(this.BackgroundImage);
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public MentQInfoBox.Iconlayout BackgroundImageLayout
    {
      get => this._iconLayout;
      set
      {
        if (this.BackgroundImage != null && this.ImageTransparency > 0)
          this._cachedTransparentImage = this.EditBackgroundImage(this.BackgroundImage);
        this._iconLayout = value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public bool AntiAliasImage
    {
      get => this._antialias;
      set
      {
        this._antialias = value;
        if (this.BackgroundImage != null && this.ImageTransparency > 0)
          this._cachedTransparentImage = this.EditBackgroundImage(this.BackgroundImage);
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public MentQInfoBox.UnderlineStyle Underline
    {
      get => this._underline;
      set
      {
        if (value == MentQInfoBox.UnderlineStyle.Full | value == MentQInfoBox.UnderlineStyle.None)
          this._underline = value;
        if (value == MentQInfoBox.UnderlineStyle.ImageOnly | value == MentQInfoBox.UnderlineStyle.ExcludeImage && this.BackgroundImage != null)
          this._underline = value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public int UnderlineSize
    {
      get => this._underlineSize;
      set
      {
        this._underlineSize = value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public Color UnderlineColor
    {
      get => this._underlineColor;
      set
      {
        this._underlineColor = value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public bool ImageContainer
    {
      get => this._imageContainer;
      set
      {
        this._imageContainer = this.BackgroundImage != null && value;
        this.Invalidate();
      }
    }

    [Category("Appearance")]
    public Color ImageContainerColor
    {
      get => this._imageContainerColor;
      set
      {
        this._imageContainerColor = value;
        this.Invalidate();
      }
    }

    public override Image BackgroundImage
    {
      get => this._backgroundImage;
      set
      {
        this._backgroundImage = value;
        if (this.ImageTransparency > 0)
          this._cachedTransparentImage = this.EditBackgroundImage(this.BackgroundImage);
        this.Invalidate();
      }
    }

    protected override void OnPaint(PaintEventArgs e)
    {
      Graphics graphics = e.Graphics;
      graphics.Clear(this.Parent.BackColor);
      graphics.SmoothingMode = SmoothingMode.HighQuality;
      using (SolidBrush solidBrush1 = new SolidBrush(this.BackColor))
      {
        using (SolidBrush solidBrush2 = new SolidBrush(this.ForeColor))
        {
          using (SolidBrush solidBrush3 = new SolidBrush(Color.FromArgb(180, this.ForeColor)))
          {
            graphics.FillPath((Brush) solidBrush1, GlobalHelpers.GetRoundedRect(new Rectangle(-1, -1, this.Width + 1, this.Height + 1), 5));
            this.DrawImage(graphics);
            if (this.BackgroundImage != null)
              this.DrawUnderline(graphics, this.CalculateImageSize(this.BackgroundImage));
            else
              this.DrawUnderline(graphics, new SizeF());
            if (!string.IsNullOrEmpty(this.Title))
              graphics.DrawString(this.Title.ToUpper(), new Font("Verdana", 8f), (Brush) solidBrush3, 12f, (float) (((double) this.Height - (double) graphics.MeasureString(this.Text, this.Font).Height) / 2.0 - 7.0));
            graphics.DrawString(this.Text, this.Font, (Brush) solidBrush2, 12f, (float) (((double) this.Height - (double) graphics.MeasureString(this.Text, this.Font).Height) / 2.0 + (string.IsNullOrEmpty(this.Title) ? 0.0 : 8.0)));
          }
        }
      }
      if (!this.Enabled)
      {
        using (SolidBrush solidBrush = new SolidBrush(Color.FromArgb(100, 222, 222, 222)))
          graphics.FillPath((Brush) solidBrush, GlobalHelpers.GetRoundedRect(new Rectangle(-1, -1, this.Width + 1, this.Height + 1), 4));
      }
      base.OnPaint(e);
    }

    private void DrawImage(Graphics G)
    {
      if (this.BackgroundImage == null)
        return;
      SizeF imageSize = this.CalculateImageSize(this.BackgroundImage);
      if (this.ImageContainer)
      {
        G.SetClip(this.CalculateContainerPosition(imageSize));
        using (SolidBrush solidBrush = new SolidBrush(this.ImageContainerColor))
          G.FillPath((Brush) solidBrush, GlobalHelpers.GetRoundedRect(new RectangleF(-1f, -1f, (float) (this.Width + 1), (float) (this.Height + 1)), 5f));
        G.ResetClip();
      }
      if (this._cachedTransparentImage != null)
      {
        if (this.BackgroundImageLayout == MentQInfoBox.Iconlayout.Scaled)
          G.DrawImage(this._cachedTransparentImage, new RectangleF((float) ((double) this.Width - (double) imageSize.Width - 5.0), (float) (((double) this.Height - (double) imageSize.Height) / 2.0), imageSize.Width, imageSize.Height));
        else
          G.DrawImage(this._cachedTransparentImage, this.Width - this.BackgroundImage.Width - 5, (this.Height - this.BackgroundImage.Height) / 2);
      }
    }

    private void DrawUnderline(Graphics G, SizeF imageSizeF)
    {
      using (SolidBrush solidBrush = new SolidBrush(this.UnderlineColor))
      {
        using (new SolidBrush(this.BackColor))
        {
          if (this.Underline == MentQInfoBox.UnderlineStyle.None)
            return;
          Rectangle rect = new Rectangle(0, this.Height - this.UnderlineSize, this.Width, this.UnderlineSize);
          if (this.BackgroundImage != null)
          {
            Rectangle containerPosition = this.CalculateContainerPosition(imageSizeF);
            switch (this.Underline)
            {
              case MentQInfoBox.UnderlineStyle.ImageOnly:
                if (this.BackgroundImage != null)
                {
                  rect = new Rectangle(containerPosition.X, this.Height - this.UnderlineSize, containerPosition.Width, this.UnderlineSize);
                  break;
                }
                break;
              case MentQInfoBox.UnderlineStyle.ExcludeImage:
                if (this.BackgroundImage != null)
                {
                  rect = new Rectangle(0, this.Height - this.UnderlineSize, this.Width - containerPosition.Width + 5, this.UnderlineSize);
                  break;
                }
                break;
            }
          }
          G.SetClip(rect);
          G.FillPath((Brush) solidBrush, GlobalHelpers.GetRoundedRect(new Rectangle(-1, -1, this.Width + 1, this.Height + 1), 5));
          G.ResetClip();
        }
      }
    }

    private Image EditBackgroundImage(Image value) => GlobalHelpers.TuneTransparency(value, this.ImageTransparency, this.AntiAliasImage);

    private SizeF CalculateImageSize(Image value)
    {
      if (this.BackgroundImageLayout != MentQInfoBox.Iconlayout.Scaled)
        return new SizeF((float) value.Width, (float) value.Height);
      float num = (float) value.Height / (float) this.Height;
      return new SizeF((float) ((double) value.Width / (double) num - 15.0), (float) ((double) value.Height / (double) num - 15.0));
    }

    private Rectangle CalculateContainerPosition(SizeF imageSize) => new Rectangle(this.Width - Convert.ToInt32(imageSize.Width) - 10, 0, Convert.ToInt32(imageSize.Width) + 15, this.Height);

    public enum Iconlayout
    {
      None,
      Scaled,
    }

    public enum UnderlineStyle
    {
      ImageOnly,
      Full,
      None,
      ExcludeImage,
    }
  }
}
