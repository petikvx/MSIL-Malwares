// Decompiled with JetBrains decompiler
// Type: PvLogiciels.dotNetProtector.RuntimeInterop
// Assembly: Cursor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 73C73BAE-42C9-44D7-8457-F03085D10BAA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.Win32.Bifrose.fsi-7b7fbfb9ac364515a944cd87d2ef6c609fde5f288aae8488a9f4806dcc2f7a5a.exe

using \u0082\u009A;
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace PvLogiciels.dotNetProtector
{
  public class RuntimeInterop : IRuntime
  {
    internal Assembly[] \u0081\u00D7;

    private static unsafe byte* \u0081\u00AC(Assembly _param0) => (byte*) Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]).ToPointer();

    internal RuntimeInterop() => this.\u0081\u00D7 = new Assembly[0];

    internal unsafe Assembly \u0082\u0092(IntPtr _param1)
    {
      int id = AppDomain.CurrentDomain.Id;
      byte* numPtr = (byte*) \u0082\u0099.\u0081\u00B2(_param1.ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      _param1 = ptr;
      int num1 = Marshal.ReadInt32(ptr);
      int length1 = Marshal.ReadInt32(_param1, 4);
      int length2 = Marshal.ReadInt32(_param1, 8);
      IntPtr source1 = (IntPtr) (void*) (numPtr + 12);
      IntPtr source2 = (IntPtr) (void*) (numPtr + length1 + 12);
      byte[] numArray = new byte[length1];
      byte[] destination = numArray;
      int length3 = length1;
      Marshal.Copy(source1, destination, 0, length3);
      Assembly assembly;
      if (length2 != 0)
      {
        byte[] rawSymbolStore = new byte[length2];
        Marshal.Copy(source2, numArray, 0, length2);
        assembly = Assembly.Load(numArray, rawSymbolStore);
      }
      else
        assembly = Assembly.Load(numArray);
      Marshal.FreeCoTaskMem(_param1);
      if ((object) assembly != null && num1 >= 0)
      {
        Type[] types = assembly.GetTypes();
        IntPtr num2 = types[types.Length - 1].TypeHandle.Value;
        \u0082\u0099.\u0081\u00B3((byte*) Marshal.GetHINSTANCE(assembly.GetLoadedModules()[0]).ToPointer(), num2.ToPointer(), num1, id);
      }
      return assembly;
    }

    internal static unsafe void \u0081ú(Assembly _param0)
    {
      string assemblyString = PvLogiciels.dotNetProtector.Runtime.GetAssemblyString(_param0);
      IntPtr ptr = IntPtr.Zero;
      if (assemblyString != (string) null)
        ptr = Marshal.StringToCoTaskMemAnsi(assemblyString);
      \u0082\u0099.\u0081\u00B3((byte*) Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]).ToPointer(), (void*) 0, (int*) 0, (sbyte*) ptr.ToPointer(), AppDomain.CurrentDomain.Id);
      if (!(ptr != IntPtr.Zero))
        return;
      Marshal.FreeCoTaskMem(ptr);
    }

    public static IRuntime InitRuntime()
    {
      RuntimeInterop runtimeInterop = new RuntimeInterop();
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        AppDomain.CurrentDomain.ProcessExit += new EventHandler(RuntimeInterop.AppDomain_ProcessExit);
        return (IRuntime) runtimeInterop;
      }
      AppDomain.CurrentDomain.DomainUnload += new EventHandler(RuntimeInterop.AppDomain_DomainUnload);
      return (IRuntime) runtimeInterop;
    }

    public static void AppDomain_ProcessExit(object sender, EventArgs e)
    {
      GC.Collect();
      GC.WaitForPendingFinalizers();
      \u0082\u0099.\u0081\u00B8();
    }

    public static void AppDomain_DomainUnload(object sender, EventArgs e)
    {
      GC.Collect();
      GC.WaitForPendingFinalizers();
      \u0082\u0099.\u0081\u0083(AppDomain.CurrentDomain.Id);
    }

    public virtual void NGenInitRuntime()
    {
    }

    public virtual int UnloadDomain() => \u0082\u0099.\u0081\u0083(AppDomain.CurrentDomain.Id);

    public virtual unsafe int InitModule(Type pReserved1, IntPtr pReserved2, string Reserved3)
    {
      IntPtr ptr = IntPtr.Zero;
      if (Reserved3 != (string) null)
        ptr = Marshal.StringToCoTaskMemAnsi(Reserved3);
      IntPtr num1 = pReserved1.TypeHandle.Value;
      int num2 = \u0082\u0099.\u0081\u00B3((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer(), num1.ToPointer(), (int*) pReserved2.ToPointer(), (sbyte*) ptr.ToPointer(), AppDomain.CurrentDomain.Id);
      if (ptr != IntPtr.Zero)
        Marshal.FreeCoTaskMem(ptr);
      int length = \u0082\u0099.\u0081\u008A();
      if (length != 0)
      {
        this.\u0081\u00D7 = new Assembly[length];
        int index = 0;
        if (0 < length)
        {
          do
          {
            this.\u0081\u00D7[index] = (Assembly) null;
            ++index;
          }
          while (index < length);
        }
      }
      return num2;
    }

    public virtual unsafe string DesignLicenseKey(Type pReserved1, string pReserved2)
    {
      IntPtr ptr = Marshal.AllocCoTaskMem(IntPtr.Size);
      IntPtr coTaskMemAnsi = Marshal.StringToCoTaskMemAnsi(pReserved2);
      \u0082\u0099.Î((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer(), (sbyte*) coTaskMemAnsi.ToPointer(), (sbyte**) ptr.ToPointer());
      IntPtr num = Marshal.ReadIntPtr(ptr);
      string str = (string) null;
      if (num != IntPtr.Zero)
      {
        string stringAnsi = Marshal.PtrToStringAnsi(num);
        Marshal.FreeHGlobal(num);
        str = stringAnsi;
      }
      Marshal.FreeCoTaskMem(ptr);
      if (!(coTaskMemAnsi != IntPtr.Zero))
        return str;
      Marshal.FreeCoTaskMem(coTaskMemAnsi);
      return str;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool SameSoftware(Assembly pReserved, IntPtr pSoft, ulong SwMajor)
    {
      int num;
      if (\u0082\u0099.\u0081È((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pSoft.ToPointer(), SwMajor, &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    public virtual unsafe int HardwareScore(Assembly pReserved, ulong HwConfig1, ulong HwConfig2)
    {
      int num;
      if (\u0082\u0099.\u0081Ì((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), HwConfig1, HwConfig2, &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num;
    }

    public virtual unsafe IntPtr GenProductKey(
      Assembly pReserved,
      IntPtr pKeys,
      uint LicenseID)
    {
      sbyte* numPtr;
      if (\u0082\u0099.\u0081Ó((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), LicenseID, &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe uint GetLicenseId(Assembly pReserved, IntPtr pProductKey)
    {
      uint licenseId;
      if (\u0082\u0099.\u0081Ú((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pProductKey.ToPointer(), &licenseId) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return licenseId;
    }

    public virtual unsafe IntPtr DecodeActivationString(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr pActivationString)
    {
      byte* numPtr;
      if (\u0082\u0099.\u0081ß((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), (sbyte*) pActivationString.ToPointer(), &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr EncodeActivationRequest(Assembly pReserved, IntPtr preq)
    {
      sbyte* numPtr;
      if (\u0082\u0099.\u0081ç((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), preq.ToPointer(), &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration)
    {
      sbyte* config;
      if (\u0082\u0099.\u0081í((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, &config) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      IntPtr pAssemblyFile)
    {
      sbyte* config;
      if (\u0082\u0099.\u0081í((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, (sbyte*) pAssemblyFile.ToPointer(), &config) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity)
    {
      sbyte* usbConfig;
      if (\u0082\u0099.\u0081\u00B6((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, &usbConfig) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity,
      IntPtr pAssemblyFile)
    {
      sbyte* usbConfig;
      if (\u0082\u0099.\u0081\u00B6((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, (sbyte*) pAssemblyFile.ToPointer(), &usbConfig) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GenerateLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq)
    {
      sbyte* license;
      if (\u0082\u0099.\u0081\u00BE((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), &license) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) license;
    }

    public virtual unsafe IntPtr GenerateLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq,
      int tolerance,
      [MarshalAs(UnmanagedType.U1)] bool ignoreMinor,
      long RuntimeLicensesLimit)
    {
      sbyte* license;
      if (\u0082\u0099.\u0081\u00BE((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), tolerance, ignoreMinor ? 1 : 0, RuntimeLicensesLimit, &license) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) license;
    }

    public virtual unsafe IntPtr GenerateUsbLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq)
    {
      sbyte* usbLicense;
      if (\u0082\u0099.\u0082\u0083((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), &usbLicense, (byte) 0) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbLicense;
    }

    public virtual unsafe IntPtr GenerateUsbLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq,
      int tolerance,
      [MarshalAs(UnmanagedType.U1)] bool ignoreMinor,
      long RuntimeLicensesLimit)
    {
      sbyte* usbLicense;
      if (\u0082\u0099.\u0082\u0083((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), tolerance, ignoreMinor ? 1 : 0, RuntimeLicensesLimit, &usbLicense, (byte) 0) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbLicense;
    }

    public virtual unsafe Assembly ResolveAssembly(string Name)
    {
      byte[] bytes = Encoding.UTF8.GetBytes(Name);
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      int index = \u0082\u0099.\u0082\u008B(num.ToPointer());
      if (index >= 0)
      {
        Assembly[] assemblyArray = this.\u0081\u00D7;
        if (index < assemblyArray.Length)
        {
          if ((object) assemblyArray[index] == null)
            this.\u0081\u00D7[index] = this.\u0082\u0092(num);
          gcHandle.Free();
          return this.\u0081\u00D7[index];
        }
      }
      gcHandle.Free();
      return (Assembly) null;
    }

    public virtual unsafe Assembly GetEmbLockAssembly(Type pReserved1)
    {
      byte* numPtr = (byte*) \u0082\u0099.\u0081Ï((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      int length1 = Marshal.ReadInt32(ptr);
      IntPtr source = (IntPtr) (void*) (numPtr + 4);
      byte[] rawAssembly = new byte[length1];
      byte[] destination = rawAssembly;
      int length2 = length1;
      Marshal.Copy(source, destination, 0, length2);
      Assembly embLockAssembly = Assembly.Load(rawAssembly);
      Marshal.FreeCoTaskMem(ptr);
      return embLockAssembly;
    }

    public virtual unsafe Assembly GetEmbLockAssemblyName(Type pReserved1)
    {
      byte* numPtr = (byte*) \u0082\u0099.\u0083((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      string stringAnsi = Marshal.PtrToStringAnsi(ptr);
      Marshal.FreeCoTaskMem(ptr);
      Assembly lockAssemblyName = (Assembly) null;
      try
      {
        lockAssemblyName = Assembly.Load(stringAnsi);
      }
      catch (Exception ex)
      {
      }
      return lockAssemblyName;
    }

    public virtual unsafe ArrayList GetEmbLockAssemblyServices(Type pReserved1)
    {
      byte* ptr1 = (byte*) \u0082\u0099.\u00AB((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) ptr1 == IntPtr.Zero)
        return (ArrayList) null;
      IntPtr ptr2 = (IntPtr) (void*) ptr1;
      ArrayList assemblyServices = new ArrayList();
      if (*ptr1 != (byte) 0)
      {
        do
        {
          string stringAnsi = Marshal.PtrToStringAnsi((IntPtr) (void*) ptr1);
          assemblyServices.Add((object) stringAnsi);
          ptr1 = (byte*) (stringAnsi.Length + (IntPtr) ptr1 + 1);
        }
        while (*ptr1 != (byte) 0);
      }
      Marshal.FreeCoTaskMem(ptr2);
      return assemblyServices;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool ProductKeyChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082\u0099.µ((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool ConfigStringChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082\u0099.\u00BF((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool LicenseKeyChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082\u0099.È((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool IsDemo(Assembly pReserved)
    {
      int num;
      if (\u0082\u0099.Ì((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    public virtual unsafe int DaysLeft(Assembly pReserved)
    {
      int num;
      return \u0082\u0099.Ñ((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) != 0 ? num : throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
    }

    public virtual unsafe int MinutesLeft(Assembly pReserved)
    {
      int num;
      return \u0082\u0099.Ö((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) != 0 ? num : throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
    }

    public virtual unsafe uint GetProductID(Assembly pReserved) => \u0082\u0099.Ú((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer());

    public virtual unsafe IntPtr StartUsbDetect() => (IntPtr) \u0082\u0099.\u00A0();

    public virtual unsafe void EndUsbDetect(IntPtr handle) => \u0082\u0099.â(handle.ToPointer());

    public virtual unsafe IntPtr LoadNativeLibrary(Assembly pReserved, IntPtr[] pointers)
    {
      GCHandle gcHandle = GCHandle.Alloc((object) pointers, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) pointers, 0);
      IntPtr num2 = (IntPtr) \u0082\u0099.ê((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (void**) num1.ToPointer());
      gcHandle.Free();
      return num2;
    }

    public virtual unsafe void FreeNativeLibrary(IntPtr pLib) => \u0082\u0099.ï(pLib.ToPointer());

    public virtual StackFrame[] GetFrames(StackTrace trace) => trace == null ? new StackFrame[0] : trace.GetFrames();

    public virtual unsafe void EncodeTrace(Guid[] Guids, long[] Indexes, IntPtr[] Handles)
    {
      GCHandle gcHandle1 = GCHandle.Alloc((object) Guids, GCHandleType.Pinned);
      GCHandle gcHandle2 = GCHandle.Alloc((object) Indexes, GCHandleType.Pinned);
      GCHandle gcHandle3 = GCHandle.Alloc((object) Handles, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Guids, 0);
      IntPtr num2 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Indexes, 0);
      IntPtr num3 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Handles, 0);
      \u0082\u0099.ò(Handles.Length, num3.ToPointer(), num2.ToPointer(), num1.ToPointer());
      gcHandle1.Free();
      gcHandle2.Free();
      gcHandle3.Free();
    }
  }
}
