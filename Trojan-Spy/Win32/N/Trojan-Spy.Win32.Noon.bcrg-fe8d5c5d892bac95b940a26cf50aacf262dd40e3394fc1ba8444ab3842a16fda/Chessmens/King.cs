// Decompiled with JetBrains decompiler
// Type: ChessBoard.Chessmens.King
// Assembly: IArraySortHel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B08900B5-C53F-4995-B311-D7E8DC4113C6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcrg-fe8d5c5d892bac95b940a26cf50aacf262dd40e3394fc1ba8444ab3842a16fda.exe

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace ChessBoard.Chessmens
{
  public class King : BaseChessman
  {
    private int StartColumn = 4;

    public override ChessmenType Type => ChessmenType.King;

    private int StartRow => this.Color != Colorz.White ? 0 : 7;

    public King()
    {
label_1:
      int num1 = -774764163;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1708861488)) % 4U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * 304563327 ^ -1132519572;
            continue;
          case 2:
            goto label_3;
          case 3:
            num1 = (int) num2 * -258492708 ^ 228882066;
            continue;
          default:
            goto label_6;
        }
      }
label_3:
      return;
label_6:;
    }

    public King(Colorz color)
      : base(color)
    {
    }

    public override bool Equals(object obj)
    {
      bool flag1 = !(obj is King);
label_1:
      int num1 = 1277857367;
      bool flag2;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 580802679)) % 6U)
        {
          case 0:
            num1 = (int) num2 * 531018912 ^ -26967500;
            continue;
          case 1:
            flag2 = false;
            num1 = (int) num2 * 438004531 ^ 2145665678;
            continue;
          case 2:
            int num3 = flag1 ? 1026352648 : (num3 = 2057782316);
            num1 = num3 ^ (int) num2 * -441789311;
            continue;
          case 3:
            flag2 = base.Equals(obj);
            num1 = 1577828020;
            continue;
          case 4:
            goto label_1;
          default:
            goto label_7;
        }
      }
label_7:
      return flag2;
    }

    public override int GetHashCode()
    {
label_1:
      int num1 = 671299412;
      int hashCode;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1801164586)) % 4U)
        {
          case 0:
            goto label_1;
          case 2:
            hashCode = base.GetHashCode();
            num1 = (int) num2 * -683020041 ^ -1284428625;
            continue;
          case 3:
            num1 = (int) num2 * -1548857585 ^ 352689250;
            continue;
          default:
            goto label_5;
        }
      }
label_5:
      return hashCode;
    }

    public override List<Cell> GetAcceptableCells(
      BoardCell[,] boardCells,
      Cell currentCell,
      bool needToCheckShah = true)
    {
label_1:
      int num1 = -440026272;
      List<Cell> cellsForDirections;
      List<Cell> acceptableCells;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1510150724)) % 8U)
        {
          case 0:
            this.AdjustAcceptableCellsInCaseShah(boardCells, cellsForDirections, currentCell);
            num1 = (int) num2 * 613795984 ^ -533882733;
            continue;
          case 1:
            acceptableCells = cellsForDirections;
            num1 = (int) num2 * 244852751 ^ -735644658;
            continue;
          case 3:
            goto label_1;
          case 4:
            cellsForDirections = this.GetAcceptableCellsForDirections(boardCells, this.AnyDirections, currentCell, 1);
            cellsForDirections.AddRange((IEnumerable<Cell>) this.GetCastlingAcceptableCells(boardCells, currentCell));
            int num3 = needToCheckShah ? -2021250468 : (num3 = -222864670);
            num1 = num3 ^ (int) num2 * 15020740;
            continue;
          case 5:
            num1 = (int) num2 * 1212082597 ^ -2035162105;
            continue;
          case 6:
            this.AdjustCellsInCaseNearEnemyKing(boardCells, cellsForDirections, currentCell);
            num1 = -1256102067;
            continue;
          case 7:
            num1 = (int) num2 * -123843859 ^ -1086929135;
            continue;
          default:
            goto label_9;
        }
      }
label_9:
      return acceptableCells;
    }

    private void AdjustCellsInCaseNearEnemyKing(
      BoardCell[,] boardCells,
      List<Cell> acceptableCells,
      Cell currentCell)
    {
label_1:
      int num1 = -979043445;
      while (true)
      {
        uint num2;
        BoardCell boardCell;
        BoardCell king;
        int num3;
        switch ((num2 = (uint) (num1 ^ -868457672)) % 7U)
        {
          case 0:
            if (boardCell.Chessman.Color != Colorz.White)
            {
              num1 = (int) num2 * -1708346967 ^ 2095520499;
              continue;
            }
            num3 = 1;
            break;
          case 1:
            num1 = (int) num2 * -533355880 ^ 693108516;
            continue;
          case 2:
            num3 = 0;
            break;
          case 3:
            boardCell = boardCells[currentCell.Row, currentCell.Column];
            num1 = (int) num2 * 704329995 ^ 1707592742;
            continue;
          case 4:
            Cell enemyKingCell = new Cell(king.Row, king.Column);
            acceptableCells.RemoveAll((Predicate<Cell>) (cell => cell.IsNextTo(enemyKingCell)));
            num1 = (int) num2 * -1025759023 ^ 1326713972;
            continue;
          case 5:
            goto label_1;
          case 6:
            goto label_3;
          default:
            goto label_12;
        }
        Colorz currentColor = (Colorz) num3;
        king = King.FindKing(boardCells, currentColor);
        num1 = -1993322670;
      }
label_3:
      return;
label_12:;
    }

    public static BoardCell FindKing(BoardCell[,] boardCells, Colorz currentColor)
    {
label_1:
      int num1 = 718155001;
      BoardCell king;
      while (true)
      {
        uint num2;
        bool flag1;
        int column;
        int row;
        bool flag2;
        BaseChessman chessman;
        bool flag3;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1137472478)) % 19U)
        {
          case 0:
            num1 = 262827556;
            continue;
          case 1:
            num1 = 1033363025;
            continue;
          case 2:
            ++row;
            num1 = (int) num2 * -1516156583 ^ 1330465962;
            continue;
          case 3:
            int num4 = !flag2 ? -2004579133 : (num4 = -319720229);
            num1 = num4 ^ (int) num2 * -2041614820;
            continue;
          case 4:
            flag2 = row < 8;
            num1 = 403290158;
            continue;
          case 5:
            row = 0;
            num1 = (int) num2 * -1976267172 ^ 1036648782;
            continue;
          case 6:
            column = 0;
            num1 = 80465273;
            continue;
          case 8:
            goto label_1;
          case 9:
            int num5 = !flag3 ? -2005327281 : (num5 = -1357359829);
            num1 = num5 ^ (int) num2 * 1953064499;
            continue;
          case 10:
            king = new BoardCell(row, column, (BaseChessman) (chessman as King));
            num1 = (int) num2 * 65085892 ^ -1555959553;
            continue;
          case 11:
            num1 = (int) num2 * -1954026417 ^ 550402159;
            continue;
          case 12:
            num3 = chessman.Color == currentColor ? 1 : 0;
            break;
          case 13:
            flag1 = column < 8;
            num1 = 1874061565;
            continue;
          case 14:
            ++column;
            num1 = (int) num2 * 2116547904 ^ 248980206;
            continue;
          case 15:
            num1 = (int) num2 * -440365955 ^ 886147557;
            continue;
          case 16:
            chessman = boardCells[row, column].Chessman;
            if (chessman is King)
            {
              num1 = (int) num2 * -2145210588 ^ -993774857;
              continue;
            }
            num3 = 0;
            break;
          case 17:
            int num6 = flag1 ? -494394008 : (num6 = -509852750);
            num1 = num6 ^ (int) num2 * -566579196;
            continue;
          case 18:
            goto label_5;
          default:
            goto label_23;
        }
        flag3 = num3 != 0;
        num1 = 338126736;
      }
label_5:
      throw King.\u206A‭⁪‌‪‫⁬⁯⁫⁯⁪⁪‎‮‬‎‍‫⁪⁭‍⁬‪​‍​‭‮‫‎⁫‎‫‬‌⁭⁫‫‪‌‮(\u003CModule\u003E.\u200B⁭⁬⁮‏⁬‎⁪⁫⁯‎⁭‬⁭‎‏‌​‏‫⁯⁫‫‬‎‎‬⁮‫‮‎‫​⁪‭‍⁫‭⁮‮<string>(2695524007U));
label_23:
      return king;
    }

    private List<Cell> GetCastlingAcceptableCells(BoardCell[,] boardCells, Cell currentCell)
    {
      List<Cell> cellList = new List<Cell>();
label_1:
      int num1 = 1823074613;
      int[] numArray1;
      int index;
      Cell castlingCell;
      int rookStartColumn;
      bool flag;
      int[] numArray2;
      List<Cell> castlingAcceptableCells;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 641158084)) % 22U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * -2022113899 ^ 189505877;
            continue;
          case 2:
            castlingAcceptableCells = cellList;
            num1 = (int) num2 * -1536301002 ^ -1696943921;
            continue;
          case 3:
            numArray2 = numArray1;
            num1 = (int) num2 * -2017984618 ^ 1820570006;
            continue;
          case 4:
            castlingAcceptableCells = cellList;
            num1 = (int) num2 * 1243010666 ^ 1178572622;
            continue;
          case 5:
            int num3;
            num1 = num3 = BaseChessman.IsCellUnderShah(boardCells, currentCell, this.Color) ? 1348632126 : (num3 = 1893706611);
            continue;
          case 6:
            castlingAcceptableCells = cellList;
            num1 = (int) num2 * 252029688 ^ 1696246225;
            continue;
          case 7:
            numArray1 = new int[2]{ 0, 7 };
            num1 = 1069241262;
            continue;
          case 8:
            num1 = (int) num2 * 1876883474 ^ 952086674;
            continue;
          case 9:
            num1 = (int) num2 * 1708198684 ^ -88607256;
            continue;
          case 10:
            int num4;
            num1 = num4 = index < numArray2.Length ? 2023885971 : (num4 = 1634500120);
            continue;
          case 11:
            int num5 = !this.Moved ? 717700584 : (num5 = 679738529);
            num1 = num5 ^ (int) num2 * 1999334015;
            continue;
          case 12:
            num1 = (int) num2 * 783455188 ^ -2012710839;
            continue;
          case 13:
            num1 = (int) num2 * -1808026320 ^ -351910598;
            continue;
          case 14:
            castlingCell = this.GetCastlingCell(boardCells, rookStartColumn);
            flag = castlingCell != null;
            num1 = (int) num2 * -704081647 ^ 27595304;
            continue;
          case 15:
            num1 = 585776945;
            continue;
          case 17:
            ++index;
            num1 = (int) num2 * -1325005435 ^ -766102857;
            continue;
          case 18:
            index = 0;
            num1 = (int) num2 * 1793164334 ^ -1846830070;
            continue;
          case 19:
            cellList.Add(castlingCell);
            num1 = (int) num2 * -1064993283 ^ 817996352;
            continue;
          case 20:
            int num6 = flag ? 1544723917 : (num6 = 330367797);
            num1 = num6 ^ (int) num2 * 1912189262;
            continue;
          case 21:
            rookStartColumn = numArray2[index];
            num1 = 1764707005;
            continue;
          default:
            goto label_23;
        }
      }
label_23:
      return castlingAcceptableCells;
    }

    private Cell GetCastlingCell(BoardCell[,] boardCells, int rookStartColumn)
    {
label_1:
      int num1 = -1717141856;
      Cell castlingCell;
      bool isLeftCastling;
      bool moved;
      Rook chessman;
      bool flag1;
      bool flag2;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1913545069)) % 19U)
        {
          case 0:
            castlingCell = (Cell) null;
            num1 = (int) num2 * -2092844876 ^ -1623044166;
            continue;
          case 1:
            chessman = boardCells[this.StartRow, rookStartColumn].Chessman as Rook;
            num1 = (int) num2 * -876270546 ^ 1489977199;
            continue;
          case 2:
            flag2 = !this.CellsBetweenRookAndKingAreEmpty(boardCells, rookStartColumn);
            num1 = -962907834;
            continue;
          case 3:
            int num3 = !flag1 ? -1325356232 : (num3 = -2053803694);
            num1 = num3 ^ (int) num2 * -2074280294;
            continue;
          case 4:
            int num4 = this.KingCellsAreNotUnderShahWhileCastling(boardCells, isLeftCastling) ? -227691131 : (num4 = -919729898);
            num1 = num4 ^ (int) num2 * -902228390;
            continue;
          case 5:
            castlingCell = new Cell(this.StartRow, this.GetNewKingColumn(isLeftCastling));
            num1 = -1916018700;
            continue;
          case 6:
            int num5 = !moved ? 1663931610 : (num5 = 1325924666);
            num1 = num5 ^ (int) num2 * -1890896538;
            continue;
          case 7:
            castlingCell = (Cell) null;
            num1 = (int) num2 * -1742507472 ^ 513890112;
            continue;
          case 8:
            castlingCell = (Cell) null;
            num1 = (int) num2 * -1215368700 ^ 1725296671;
            continue;
          case 9:
            num1 = (int) num2 * 1461498579 ^ 1623933862;
            continue;
          case 10:
            moved = chessman.Moved;
            num1 = -1638745674;
            continue;
          case 11:
            isLeftCastling = rookStartColumn == 0;
            num1 = -111714945;
            continue;
          case 12:
            int num6 = flag2 ? -1656571231 : (num6 = -1351072102);
            num1 = num6 ^ (int) num2 * 1912624499;
            continue;
          case 13:
            num1 = (int) num2 * -808460056 ^ 1736383307;
            continue;
          case 14:
            goto label_1;
          case 15:
            castlingCell = (Cell) null;
            num1 = (int) num2 * 204131148 ^ 1217036255;
            continue;
          case 17:
            flag1 = chessman == null;
            num1 = (int) num2 * -1479098446 ^ 2117832174;
            continue;
          case 18:
            num1 = (int) num2 * -87963461 ^ 1301926226;
            continue;
          default:
            goto label_20;
        }
      }
label_20:
      return castlingCell;
    }

    private bool CellsBetweenRookAndKingAreEmpty(BoardCell[,] boardCells, int rookStartColumn)
    {
label_1:
      int num1 = -803073542;
      bool flag1;
      while (true)
      {
        uint num2;
        int num3;
        bool flag2;
        int num4;
        int index;
        bool flag3;
        int num5;
        int num6;
        switch ((num2 = (uint) (num1 ^ -1172459054)) % 17U)
        {
          case 0:
            int num7 = flag3 ? 454722764 : (num7 = 1223913178);
            num1 = num7 ^ (int) num2 * 606505121;
            continue;
          case 1:
            num1 = (int) num2 * -1775715864 ^ 1848224271;
            continue;
          case 2:
            num1 = (int) num2 * 1163114955 ^ -1184277100;
            continue;
          case 3:
            index = num4 + 1;
            num1 = (int) num2 * 1185167621 ^ -843652226;
            continue;
          case 4:
            if (!flag2)
            {
              num1 = (int) num2 * 175268977 ^ -1204659874;
              continue;
            }
            num5 = rookStartColumn;
            goto label_10;
          case 5:
            goto label_1;
          case 6:
            flag1 = true;
            num1 = (int) num2 * -710168657 ^ 1417161991;
            continue;
          case 7:
            if (flag2)
            {
              num6 = this.StartColumn;
              break;
            }
            num1 = (int) num2 * -1933238660 ^ -193201558;
            continue;
          case 8:
            flag1 = false;
            num1 = (int) num2 * -1822291899 ^ 849832642;
            continue;
          case 9:
            num1 = -1079581643;
            continue;
          case 10:
            num6 = rookStartColumn;
            break;
          case 11:
            flag3 = boardCells[this.StartRow, index].Chessman != null;
            num1 = -461091678;
            continue;
          case 12:
            flag2 = rookStartColumn == 0;
            num1 = (int) num2 * -1580926835 ^ 1255816285;
            continue;
          case 13:
            num5 = this.StartColumn;
            goto label_10;
          case 14:
            int num8;
            num1 = num8 = index < num3 ? -2120533575 : (num8 = -353164967);
            continue;
          case 15:
            ++index;
            num1 = (int) num2 * 1362984558 ^ -182749675;
            continue;
          default:
            goto label_24;
        }
        num3 = num6;
        num1 = -611654659;
        continue;
label_10:
        num4 = num5;
        num1 = -1198912436;
      }
label_24:
      return flag1;
    }

    private bool KingCellsAreNotUnderShahWhileCastling(BoardCell[,] boardCells, bool isLeftCastling)
    {
label_1:
      int num1 = 151871969;
      bool flag1;
      while (true)
      {
        uint num2;
        int newKingColumn;
        int column;
        int num3;
        bool flag2;
        bool flag3;
        int num4;
        int num5;
        switch ((num2 = (uint) (num1 ^ 361736476)) % 17U)
        {
          case 0:
            flag1 = false;
            num1 = (int) num2 * -129120654 ^ -491412676;
            continue;
          case 2:
            num1 = (int) num2 * 789462493 ^ 2112923305;
            continue;
          case 3:
            num4 = this.StartColumn;
            break;
          case 4:
            flag2 = column < num3;
            num1 = 1825110886;
            continue;
          case 5:
            int num6 = !flag2 ? -1797673925 : (num6 = -2108868377);
            num1 = num6 ^ (int) num2 * -173421847;
            continue;
          case 6:
            num1 = (int) num2 * 634436788 ^ -110873268;
            continue;
          case 7:
            flag3 = BaseChessman.IsCellUnderShah(boardCells, new Cell(this.StartRow, column), this.Color);
            num1 = 1282579587;
            continue;
          case 8:
            num5 = newKingColumn;
            goto label_18;
          case 9:
            if (isLeftCastling)
            {
              num4 = newKingColumn;
              break;
            }
            num1 = (int) num2 * -387738764 ^ 210336674;
            continue;
          case 10:
            int num7 = flag3 ? -971165558 : (num7 = -1194070625);
            num1 = num7 ^ (int) num2 * -1336413403;
            continue;
          case 11:
            goto label_1;
          case 12:
            num1 = (int) num2 * 789421569 ^ 1996012227;
            continue;
          case 13:
            if (!isLeftCastling)
            {
              num1 = (int) num2 * -498063550 ^ -854212634;
              continue;
            }
            num5 = this.StartColumn;
            goto label_18;
          case 14:
            flag1 = true;
            num1 = (int) num2 * -121877900 ^ -746635095;
            continue;
          case 15:
            ++column;
            num1 = 1174248607;
            continue;
          case 16:
            newKingColumn = this.GetNewKingColumn(isLeftCastling);
            num1 = (int) num2 * -2137696004 ^ -1766289616;
            continue;
          default:
            goto label_24;
        }
        int num8 = num4;
        num1 = 2127686016;
        continue;
label_18:
        num3 = num5;
        column = num8;
        num1 = 395573056;
      }
label_24:
      return flag1;
    }

    private int GetNewKingColumn(bool isLeftCastling)
    {
      if (isLeftCastling)
        goto label_4;
label_1:
      int num1 = 1992128098;
label_2:
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1982082539)) % 4U)
        {
          case 1:
            goto label_3;
          case 2:
            goto label_1;
          case 3:
            num1 = (int) num2 * 1851654439 ^ 447909034;
            continue;
          default:
            goto label_7;
        }
      }
label_3:
      int num3 = 6;
      goto label_5;
label_7:
      int newKingColumn;
      return newKingColumn;
label_4:
      num3 = 2;
label_5:
      newKingColumn = num3;
      num1 = 1132104984;
      goto label_2;
    }

    static ArgumentException \u206A‭⁪‌‪‫⁬⁯⁫⁯⁪⁪‎‮‬‎‍‫⁪⁭‍⁬‪​‍​‭‮‫‎⁫‎‫‬‌⁭⁫‫‪‌‮(
      [In] string obj0)
    {
      return new ArgumentException(obj0);
    }
  }
}
