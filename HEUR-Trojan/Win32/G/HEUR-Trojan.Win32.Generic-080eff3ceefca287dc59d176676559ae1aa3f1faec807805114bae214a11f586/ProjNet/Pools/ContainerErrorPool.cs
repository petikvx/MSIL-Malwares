// Decompiled with JetBrains decompiler
// Type: ProjNet.Pools.ContainerErrorPool
// Assembly: TYPELIBA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 97BB50BA-9882-4DFE-999C-7A4E4B448F1C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-080eff3ceefca287dc59d176676559ae1aa3f1faec807805114bae214a11f586.exe

using ProjNet.Roles;
using ProjNet.Rules;
using ProjNet.Shared;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TYPELIBA.Identifiers;
using TYPELIBA.Importers;

namespace ProjNet.Pools
{
  internal class ContainerErrorPool : MerchantEventRole
  {
    private double m_ConfigurationProcess;
    private double m_TokenProcess;
    private double eventProcess;
    private double m_PropertyProcess;
    private double _AccountProcess;
    private double _SingletonProcess;
    private double _TemplateProcess;
    private double paramsProcess;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public ContainerErrorPool(List<Interceptor> param)
    {
      ManagerParamsID.NewExpression();
      // ISSUE: explicit constructor call
      this.\u002Ector(param, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public ContainerErrorPool(List<Interceptor> asset, bool outputmap)
    {
      ManagerParamsID.NewExpression();
      this._AccountProcess = 0.0;
      // ISSUE: explicit constructor call
      base.\u002Ector(asset, outputmap);
      this.Name = "Albers_Conic_Equal_Area";
      Interceptor interceptor1 = this.VisitConfiguration("longitude_of_center");
      Interceptor interceptor2 = this.VisitConfiguration("latitude_of_center");
      Interceptor interceptor3 = this.VisitConfiguration("standard_parallel_1");
      Interceptor interceptor4 = this.VisitConfiguration("standard_parallel_2");
      Interceptor interceptor5 = this.VisitConfiguration("false_easting");
      Interceptor interceptor6 = this.VisitConfiguration("false_northing");
      if (interceptor1 == null)
      {
        interceptor1 = this.VisitConfiguration("central_meridian");
        if (interceptor1 == null)
          throw new ArgumentException("Missing projection parameter 'longitude_of_center'");
      }
      if (interceptor2 == null)
      {
        interceptor2 = this.VisitConfiguration("latitude_of_origin");
        if (interceptor2 == null)
          throw new ArgumentException("Missing projection parameter 'latitude_of_center'");
      }
      if (interceptor3 == null)
        throw new ArgumentException("Missing projection parameter 'standard_parallel_1'");
      if (interceptor4 == null)
        throw new ArgumentException("Missing projection parameter 'standard_parallel_2'");
      if (interceptor5 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (interceptor6 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      this.paramsProcess = StateProcess.PopConsumer(interceptor1.LoginProcess());
      double def = StateProcess.PopConsumer(interceptor2.LoginProcess());
      double num1 = StateProcess.PopConsumer(interceptor3.LoginProcess());
      double num2 = StateProcess.PopConsumer(interceptor4.LoginProcess());
      this.m_ConfigurationProcess = interceptor5.LoginProcess() * this.m_ServerProcess;
      this.m_TokenProcess = interceptor6.LoginProcess() * this.m_ServerProcess;
      if (Math.Abs(num1 + num2) < double.Epsilon)
        throw new ArgumentException("Equal latitudes for standard parallels on opposite sides of Equator.");
      this._AccountProcess = 1.0 - Math.Pow(this._AnnotationProcess / this.proxyProcess, 2.0);
      this.m_PropertyProcess = Math.Sqrt(this._AccountProcess);
      double num3 = this.CancelConsumer(num1);
      double num4 = this.CancelConsumer(num2);
      double x1 = Math.Cos(num1) / Math.Sqrt(1.0 - this._AccountProcess * Math.Pow(Math.Sin(num1), 2.0));
      double x2 = Math.Cos(num2) / Math.Sqrt(1.0 - this._AccountProcess * Math.Pow(Math.Sin(num2), 2.0));
      this._TemplateProcess = (Math.Pow(x1, 2.0) - Math.Pow(x2, 2.0)) / (num4 - num3);
      this.eventProcess = Math.Pow(x1, 2.0) + this._TemplateProcess * num3;
      this._SingletonProcess = this.DeleteConsumer(this.CancelConsumer(def));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] InvokeConfiguration(double[] item)
    {
      int num1 = 3;
      if (true)
        goto label_3;
label_1:
      double init;
      double num2 = this.DeleteConsumer(init);
      goto label_7;
label_2:
      int num3;
      num1 = num3;
label_3:
      double num4;
      while (true)
      {
        switch (num1)
        {
          case 0:
            goto label_7;
          case 1:
          case 5:
            goto label_5;
          case 2:
          case 6:
            goto label_1;
          case 3:
            num4 = StateProcess.PopConsumer(item[0]);
            if (!ContainerErrorPool.RunCreator())
            {
              num1 = 5;
              continue;
            }
            goto label_7;
          case 4:
          case 7:
            goto label_11;
          default:
            goto label_4;
        }
      }
label_4:
      num3 = 0;
      goto label_2;
label_5:
      init = this.CancelConsumer(StateProcess.PopConsumer(item[1]));
      num3 = 6;
      goto label_2;
label_7:
      double num5 = this._TemplateProcess * (num4 - this.paramsProcess);
      num4 = this.m_ConfigurationProcess + num2 * Math.Sin(num5);
      double num6 = this.m_TokenProcess + this._SingletonProcess - num2 * Math.Cos(num5);
      double[] numArray;
      if (item.Length == 2)
      {
        numArray = new double[2]
        {
          num4 / this.m_ServerProcess,
          num6 / this.m_ServerProcess
        };
        if (ContainerErrorPool.PublishCreator())
        {
          num1 = 4;
          goto label_3;
        }
      }
      else
      {
        numArray = new double[3]
        {
          num4 / this.m_ServerProcess,
          num6 / this.m_ServerProcess,
          item[2]
        };
        num3 = 7;
        goto label_2;
      }
label_11:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ReadConfiguration(double[] res)
    {
      int num1 = 4;
      if (!ContainerErrorPool.RunCreator())
        goto label_9;
label_1:
      double num2;
      double num3 = Math.Asin(num2 * 0.5);
      double num4 = double.MaxValue;
      int num5 = 8;
label_8:
      num1 = num5;
label_9:
      double num6;
      while (true)
      {
        switch (num1)
        {
          case 0:
          case 6:
          case 9:
            goto label_16;
          case 1:
            goto label_12;
          case 2:
            num2 = (this.eventProcess - Math.Pow(Math.Sqrt(Math.Pow(res[0] * this.m_ServerProcess - this.m_ConfigurationProcess, 2.0) + Math.Pow(this._SingletonProcess - (res[1] * this.m_ServerProcess - this.m_TokenProcess), 2.0)), 2.0) * Math.Pow(this._TemplateProcess, 2.0) / Math.Pow(this.proxyProcess, 2.0)) / this._TemplateProcess;
            Math.Sin(num2 / (1.0 - (1.0 - this._AccountProcess) / (2.0 * this.m_PropertyProcess) * Math.Log((1.0 - this.m_PropertyProcess) / (1.0 + this.m_PropertyProcess))));
            if (ContainerErrorPool.PublishCreator())
            {
              num1 = 5;
              continue;
            }
            goto label_15;
          case 3:
          case 8:
            goto label_3;
          case 4:
            num6 = Math.Atan((res[0] * this.m_ServerProcess - this.m_ConfigurationProcess) / (this._SingletonProcess - (res[1] * this.m_ServerProcess - this.m_TokenProcess)));
            if (ContainerErrorPool.PublishCreator())
            {
              num1 = 2;
              continue;
            }
            goto label_3;
          case 5:
            goto label_1;
          case 7:
            goto label_15;
          default:
            goto label_10;
        }
      }
label_3:
      int num7 = 0;
      while (Math.Abs(num3 - num4) > 1E-06)
      {
        num4 = num3;
        double x = Math.Sin(num3);
        double num8 = this._AccountProcess * Math.Pow(x, 2.0);
        num3 += Math.Pow(1.0 - num8, 2.0) / (2.0 * Math.Cos(num3)) * (num2 / (1.0 - this._AccountProcess) - x / (1.0 - num8) + 1.0 / (2.0 * this.m_PropertyProcess) * Math.Log((1.0 - this.m_PropertyProcess * x) / (1.0 + this.m_PropertyProcess * x)));
        ++num7;
        if (num7 > 25)
          throw new ArgumentException("Transformation failed to converge in Albers backwards transformation");
      }
      goto label_15;
label_10:
      num5 = 7;
      goto label_8;
label_12:
      double instance;
      double[] numArray;
      if (res.Length != 2)
      {
        numArray = new double[3]
        {
          StateProcess.CheckConsumer(instance),
          StateProcess.CheckConsumer(num3),
          res[2]
        };
        num5 = 9;
        goto label_8;
      }
      else
      {
        numArray = new double[2]
        {
          StateProcess.CheckConsumer(instance),
          StateProcess.CheckConsumer(num3)
        };
        num5 = 0;
        goto label_8;
      }
label_15:
      instance = this.paramsProcess + num6 / this._TemplateProcess;
      num5 = 1;
      goto label_8;
label_16:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override RepositoryProcess CreateState()
    {
      int num = 4;
      bool flag;
      RepositoryProcess tagProcess;
      while (true)
      {
        switch (num)
        {
          case 0:
          case 4:
            flag = this.tagProcess == null;
            num = 2;
            continue;
          case 1:
          case 2:
            if (flag)
            {
              this.tagProcess = (StateProcess) new ContainerErrorPool(this._IteratorProcess, !this._ReaderProcess);
              goto case 3;
            }
            else
              goto case 3;
          case 3:
            tagProcess = (RepositoryProcess) this.tagProcess;
            num = 5;
            continue;
          case 5:
            goto label_7;
          default:
            num = 3;
            continue;
        }
      }
label_7:
      return tagProcess;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private double CancelConsumer(double def)
    {
      int num1 = 3;
      double x;
      double num2;
      double num3;
      while (true)
      {
        switch (num1)
        {
          case 0:
          case 3:
            x = Math.Sin(def);
            num1 = 4;
            continue;
          case 1:
          case 2:
            num3 = (1.0 - this._AccountProcess) * (x / (1.0 - this._AccountProcess * num2) - 1.0 / (2.0 * this.m_PropertyProcess) * Math.Log((1.0 - this.m_PropertyProcess * x) / (1.0 + this.m_PropertyProcess * x)));
            if (true)
            {
              num1 = 5;
              continue;
            }
            goto case 0;
          case 4:
            num2 = Math.Pow(x, 2.0);
            goto case 1;
          case 5:
            goto label_6;
          default:
            if (ContainerErrorPool.PublishCreator())
            {
              num1 = 1;
              continue;
            }
            goto label_6;
        }
      }
label_6:
      return num3;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private double DeleteConsumer(double init) => this.proxyProcess * Math.Sqrt(this.eventProcess - this._TemplateProcess * init) / this._TemplateProcess;

    internal static bool PublishCreator() => true;

    internal static bool RunCreator() => false;
  }
}
