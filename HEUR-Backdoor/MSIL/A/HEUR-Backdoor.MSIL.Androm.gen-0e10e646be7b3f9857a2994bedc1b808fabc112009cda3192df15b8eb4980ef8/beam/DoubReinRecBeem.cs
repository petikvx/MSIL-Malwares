// Decompiled with JetBrains decompiler
// Type: beam.DoubReinRecBeem
// Assembly: MuiResourceTypeIdIntEn, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2C7C9528-88C0-45FF-AB6A-2AC0C29EABCB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-0e10e646be7b3f9857a2994bedc1b808fabc112009cda3192df15b8eb4980ef8.exe

using beam.forms;
using beam.helper;
using beam.reinforcement;
using System;

namespace beam
{
  public class DoubReinRecBeem : RenforcedBeem
  {
    private double d;
    private double da;
    private double h;
    private double equivalentX;
    private double icr;
    private double muS;
    private double muSa;
    private double muSmax;
    private double mcr;
    private double y;
    private double x;
    private double asb;
    private double asMax;
    private double teta;
    private double rM;
    private double eRM;

    public DoubReinRecBeem(double h, double l, double b, double r, double ra, int n, int na)
      : this(30.0, 420.0, h, l, b, r, ra, n, na)
    {
    }

    public DoubReinRecBeem(
      double cP,
      double iF,
      double h,
      double l,
      double b,
      double r,
      double ra,
      int n,
      int na)
      : this(cP, iF, h, l, b, 210000.0, r, ra, n, na, 5.0, 5.0, (byte) 1)
    {
    }

    public DoubReinRecBeem(
      double cP,
      double iF,
      double h,
      double l,
      double b,
      double es,
      double r,
      double ra,
      int n,
      int na,
      double a,
      double aa,
      byte choese)
      : base(cP, iF, b, l, es)
    {
      this.H = h;
      this.Form = (Form) new Rectangle(h, l, b);
      this.Reinforcement = (Reinforcement) new DoubleReinforcement(r, n, ra, na);
      this.D = this.H - a;
      this.Da = aa;
      this.MuS = this.calcMuS(this.getSpaceTensileReinforcement(), this.D);
      this.MuSa = this.calcMuS(this.getSpaceCompressionReinforcement(), this.D);
      this.y = this.calcY();
      this.x = this.getX();
      this.asb = this.calcAsb(this.D);
      this.asMax = this.calcAsMax();
      this.muSmax = this.calcMuSmax();
      this.teta = this.getTeta(choese, this.X, this.D);
      this.rM = this.calcRM();
      this.eRM = this.RM * this.Teta;
      this.Mcr = this.calcMcr();
      this.equivalentX = this.depthNeutralAxisSectionEquivalent(this.getSpaceTensileReinforcement(), this.getSpaceCompressionReinforcement(), this.D, this.Da);
      this.icr = this.momentInertiaEquivalentCrackedSection(this.EquivalentX, this.getSpaceTensileReinforcement(), this.getSpaceCompressionReinforcement(), this.D, this.Da);
    }

    public double Da
    {
      get => this.da;
      private set => this.da = value < this.D ? value : throw new ArgumentException("Da can't be >= D");
    }

    public double H
    {
      get => this.h;
      private set => this.h = value > 0.0 ? value : throw new ArgumentException("H can't be <= 0 ");
    }

    public override double ERM => this.eRM;

    public override double Teta => this.teta;

    public override double AsMax => this.asMax;

    public double MuSmax => this.muSmax;

    public double Asb => this.asb;

    public double Y => this.y;

    public double MuS
    {
      get => this.muS;
      private set
      {
        if (value >= 1.0)
          throw new ArgumentException("As can't be <=  A");
        this.muS = value >= this.MuSmin ? value : throw new ArgumentException("Mus can't be < MusMin");
      }
    }

    public double MuSa
    {
      get => this.muSa;
      private set
      {
        if (value >= 1.0)
          throw new ArgumentException("Aas can't be <=  A");
        this.muSa = value + this.MuS < 1.0 ? value : throw new ArgumentException("Mus + MuSa can't be > 1");
      }
    }

    public double D
    {
      get => this.d;
      private set => this.d = value > 0.0 ? value : throw new ArgumentException("D can't be  <= 0 ");
    }

    public double EquivalentX => this.equivalentX;

    public double Icr => this.icr;

    public override double Mcr
    {
      get => this.mcr;
      protected set => this.mcr = value;
    }

    public double X => this.x;

    public double RM => this.rM;

    public override double getIe(double Ma) => this.Ie(Ma, this.Mcr, this.getMomentInertiaNonCrackedSection(), this.Icr);

    protected override double calcY()
    {
      double num = (this.getSpaceTensileReinforcement() - this.getSpaceCompressionReinforcement()) * this.IF / (0.85 * this.CP * this.B);
      if (this.MuS - this.MuSa <= this.MuSb && this.Da / num <= this.calcDaDivYLim())
        return num;
      if (this.MuS - this.MuSa >= this.MuSb & this.Da / num <= this.calcDaDivYLim())
        return MathHelper.sESDRP(0.85 * this.CP, -(this.getSpaceTensileReinforcement() * this.IF + this.B * this.Da * this.MuSa * this.Es * 0.003), this.B * this.MuSa * this.Es * this.B1 * 0.003 * Math.Pow(this.Da, 2.0));
      return this.Da / num >= this.calcDaDivYLim() & this.MuS - this.MuSa <= this.MuSb ? MathHelper.sESDRP(0.85 * this.CP, this.MuS * this.Es * 0.003 * this.D + this.getSpaceCompressionReinforcement() * this.IF, -(this.B1 * this.MuS * this.Es * 0.003 * Math.Pow(this.D, 2.0))) : MathHelper.sESDRP(0.85 * this.CP, this.MuS * this.Es * 0.003 * this.D - this.MuSa * this.Es * 0.003 * this.Da, -(this.B1 * this.MuS * this.Es * 0.003 * Math.Pow(this.D, 2.0)) + this.B1 * this.MuSa * this.Es * 0.003 * Math.Pow(this.Da, 2.0));
    }

    protected override double calcRM() => 0.85 * this.CP * this.B * this.Y * (this.D - this.y / 2.0) + this.getSpaceCompressionReinforcement() * this.IF * (this.D - this.Da);

    public double test() => 0.85 * this.CP * this.B * this.Y * (this.D - this.y / 2.0);

    public double tes1t() => this.getSpaceCompressionReinforcement() * this.IF * (this.D - this.Da);

    public override string getFailureWay() => this.MuS < this.MuSb ? "Ductile failure" : "Brittle faliure";

    private double calcDaDivYLim() => 1.0 / this.B1 - this.IF / (630.0 * this.B1);

    private double calcAsMax() => this.Asb * 0.75;

    private double calcMuSmax() => this.AsMax / (this.B * this.D);
  }
}
