// Decompiled with JetBrains decompiler
// Type: HeavyDuck.Eve.Resources
// Assembly: RemotingFieldCachedD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EDD4CF72-357A-47DC-BB8E-50FC31FC092E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-1095c007bb641be5c286e491a4f4ced026984a7767f930ee09c4d2995b5a76f2.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Web;

namespace HeavyDuck.Eve
{
  internal static class Resources
  {
    public const string USER_AGENT = "HeavyDuck.Eve";
    private static readonly string m_cacheRoot = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "HeavyDuck.Eve");
    private static readonly MD5 m_md5 = MD5.Create();
    private static readonly UTF8Encoding m_encoding = new UTF8Encoding(false);

    public static string CacheRoot => Resources.m_cacheRoot;

    public static MD5 MD5 => Resources.m_md5;

    public static UTF8Encoding UTF8 => Resources.m_encoding;

    public static CacheResult CacheFile(string url, string cachePath, TimeSpan ttl) => Resources.CacheFile(url, cachePath, ttl, (PostDownloadAction) null);

    public static CacheResult CacheFile(
      string url,
      string cachePath,
      TimeSpan ttl,
      PostDownloadAction action)
    {
      return Resources.CacheFileInternal(HttpMethod.Get, url, cachePath, (ICacheStrategy) new TtlCacheStrategy(ttl), (IEnumerable<KeyValuePair<string, string>>) null, action);
    }

    public static CacheResult CacheFile(
      string url,
      string cachePath,
      ICacheStrategy cacheStrategy,
      PostDownloadAction action)
    {
      return Resources.CacheFileInternal(HttpMethod.Get, url, cachePath, cacheStrategy, (IEnumerable<KeyValuePair<string, string>>) null, action);
    }

    public static CacheResult CacheFilePost(
      string url,
      string cachePath,
      TimeSpan ttl,
      IEnumerable<KeyValuePair<string, string>> parameters)
    {
      return Resources.CacheFilePost(url, cachePath, ttl, parameters, (PostDownloadAction) null);
    }

    public static CacheResult CacheFilePost(
      string url,
      string cachePath,
      TimeSpan ttl,
      IEnumerable<KeyValuePair<string, string>> parameters,
      PostDownloadAction action)
    {
      return Resources.CacheFileInternal(HttpMethod.Post, url, cachePath, (ICacheStrategy) new TtlCacheStrategy(ttl), parameters, action);
    }

    public static CacheResult CacheFilePost(
      string url,
      string cachePath,
      ICacheStrategy cacheStrategy,
      IEnumerable<KeyValuePair<string, string>> parameters,
      PostDownloadAction action)
    {
      return Resources.CacheFileInternal(HttpMethod.Post, url, cachePath, cacheStrategy, parameters, action);
    }

    private static CacheResult CacheFileInternal(
      HttpMethod method,
      string url,
      string cachePath,
      ICacheStrategy cacheStrategy,
      IEnumerable<KeyValuePair<string, string>> parameters,
      PostDownloadAction action)
    {
      string str = (string) null;
      if (method == HttpMethod.Get && parameters != null)
        throw new ArgumentException("GET method and parameters don't mix");
      CacheResult existing = Resources.IsFileCached(cachePath, cacheStrategy);
      if (existing.State == CacheState.Cached)
        return existing;
      try
      {
        switch (method)
        {
          case HttpMethod.Get:
            str = Resources.DownloadUrlGet(url);
            break;
          case HttpMethod.Post:
            str = Resources.DownloadUrlPost(url, parameters);
            break;
          default:
            throw new ArgumentException("Unknown HTTP method " + method.ToString());
        }
        if (action != null)
          action(str);
        System.IO.File.Copy(str, cachePath, true);
        return new CacheResult(cachePath, true, CacheState.Cached, cacheStrategy.GetCachedUntil(cachePath));
      }
      catch (Exception ex)
      {
        return existing.State != CacheState.Uncached ? CacheResult.FromExisting(existing, ex) : CacheResult.Uncached(ex);
      }
      finally
      {
        try
        {
          if (!string.IsNullOrEmpty(str))
            System.IO.File.Delete(str);
        }
        catch
        {
        }
      }
    }

    public static string DownloadUrlGet(string url)
    {
      HttpWebRequest httpWebRequest = (HttpWebRequest) WebRequest.Create(url);
      httpWebRequest.KeepAlive = false;
      httpWebRequest.Method = "GET";
      httpWebRequest.UserAgent = "HeavyDuck.Eve";
      WebResponse webResponse = (WebResponse) null;
      try
      {
        webResponse = httpWebRequest.GetResponse();
        using (Stream responseStream = webResponse.GetResponseStream())
          return Resources.DownloadStream(responseStream);
      }
      finally
      {
        webResponse?.Close();
      }
    }

    public static string DownloadUrlPost(
      string url,
      IEnumerable<KeyValuePair<string, string>> parameters)
    {
      HttpWebRequest httpWebRequest = (HttpWebRequest) WebRequest.Create(url);
      httpWebRequest.ContentType = "application/x-www-form-urlencoded";
      httpWebRequest.KeepAlive = false;
      httpWebRequest.Method = "POST";
      httpWebRequest.UserAgent = "HeavyDuck.Eve";
      httpWebRequest.ServicePoint.Expect100Continue = false;
      WebResponse webResponse = (WebResponse) null;
      try
      {
        using (Stream requestStream = httpWebRequest.GetRequestStream())
        {
          byte[] bytes = Resources.UTF8.GetBytes(Resources.GetEncodedParameters(parameters));
          requestStream.Write(bytes, 0, bytes.Length);
        }
        webResponse = httpWebRequest.GetResponse();
        using (Stream responseStream = webResponse.GetResponseStream())
          return Resources.DownloadStream(responseStream);
      }
      finally
      {
        webResponse?.Close();
      }
    }

    public static string DownloadStream(Stream input)
    {
      string path = (string) null;
      byte[] buffer = new byte[32768];
      int offset = 0;
      try
      {
        path = Path.GetTempFileName();
        using (FileStream fileStream = System.IO.File.Open(path, FileMode.Open, FileAccess.Write))
        {
          int count;
          while (0 < (count = input.Read(buffer, offset, buffer.Length)))
            fileStream.Write(buffer, 0, count);
        }
      }
      catch
      {
        try
        {
          if (!string.IsNullOrEmpty(path))
            System.IO.File.Delete(path);
        }
        catch
        {
        }
        throw;
      }
      return path;
    }

    public static CacheResult IsFileCached(string path, TimeSpan ttl) => Resources.IsFileCached(path, (ICacheStrategy) new TtlCacheStrategy(ttl));

    public static CacheResult IsFileCached(string path, ICacheStrategy cacheStrategy)
    {
      try
      {
        if (!new FileInfo(path).Exists)
          return CacheResult.Uncached(path);
        DateTime cachedUntil = cacheStrategy.GetCachedUntil(path);
        return DateTime.Now < cachedUntil ? new CacheResult(path, false, CacheState.Cached, cachedUntil) : new CacheResult(path, false, CacheState.CachedOutOfDate, cachedUntil);
      }
      catch (Exception ex)
      {
        return CacheResult.Uncached(path, ex);
      }
    }

    public static string GetEncodedParameters(
      IEnumerable<KeyValuePair<string, string>> parameters)
    {
      if (parameters == null)
        return "";
      List<KeyValuePair<string, string>> keyValuePairList = new List<KeyValuePair<string, string>>(parameters);
      keyValuePairList.Sort((Comparison<KeyValuePair<string, string>>) ((a, b) => a.Key == b.Key ? string.Compare(a.Value, b.Value) : string.Compare(a.Key, b.Key)));
      StringBuilder stringBuilder = new StringBuilder();
      foreach (KeyValuePair<string, string> keyValuePair in keyValuePairList)
      {
        stringBuilder.Append(HttpUtility.UrlEncode(keyValuePair.Key));
        stringBuilder.Append("=");
        stringBuilder.Append(HttpUtility.UrlEncode(keyValuePair.Value));
        stringBuilder.Append("&");
      }
      if (stringBuilder.Length > 0)
        stringBuilder.Remove(stringBuilder.Length - 1, 1);
      return stringBuilder.ToString();
    }

    public static string ComputeParameterHash(
      IEnumerable<KeyValuePair<string, string>> parameters)
    {
      return Resources.ComputeParameterHash(parameters, (Encoding) Resources.UTF8);
    }

    public static string ComputeParameterHash(
      IEnumerable<KeyValuePair<string, string>> parameters,
      Encoding encoding)
    {
      return BitConverter.ToString(Resources.MD5.ComputeHash(encoding.GetBytes(Resources.GetEncodedParameters(parameters)))).Replace("-", "");
    }
  }
}
