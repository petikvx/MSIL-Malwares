// Decompiled with JetBrains decompiler
// Type: HeavyDuck.AlternateDataStreamInfo
// Assembly: RemotingFieldCachedD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EDD4CF72-357A-47DC-BB8E-50FC31FC092E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-1095c007bb641be5c286e491a4f4ced026984a7767f930ee09c4d2995b5a76f2.exe

using Microsoft.Win32.SafeHandles;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Security.Permissions;

namespace HeavyDuck
{
  [DebuggerDisplay("{FullPath}")]
  public sealed class AlternateDataStreamInfo : IEquatable<AlternateDataStreamInfo>
  {
    private readonly string _fullPath;
    private readonly string _filePath;
    private readonly string _streamName;
    private readonly FileStreamType _streamType;
    private readonly FileStreamAttributes _attributes;
    private readonly long _size;
    private readonly bool _exists;

    internal AlternateDataStreamInfo(string filePath, SafeNativeMethods.Win32StreamInfo info)
    {
      this._filePath = filePath;
      this._streamName = info.StreamName;
      this._streamType = info.StreamType;
      this._attributes = info.StreamAttributes;
      this._size = info.StreamSize;
      this._exists = true;
      this._fullPath = SafeNativeMethods.BuildStreamPath(this._filePath, this._streamName);
    }

    internal AlternateDataStreamInfo(
      string filePath,
      string streamName,
      string fullPath,
      bool exists)
    {
      if (string.IsNullOrEmpty(fullPath))
        fullPath = SafeNativeMethods.BuildStreamPath(filePath, streamName);
      this._streamType = FileStreamType.AlternateDataStream;
      this._filePath = filePath;
      this._streamName = streamName;
      this._fullPath = fullPath;
      this._exists = exists;
      if (!this._exists)
        return;
      this._size = SafeNativeMethods.GetFileSize(this._fullPath);
    }

    public string FullPath => this._fullPath;

    public string FilePath => this._filePath;

    public string Name => this._streamName;

    public bool Exists => this._exists;

    public long Size => this._size;

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public FileStreamType StreamType => this._streamType;

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public FileStreamAttributes Attributes => this._attributes;

    public override string ToString() => this.FullPath;

    public override int GetHashCode()
    {
      StringComparer ordinalIgnoreCase = StringComparer.OrdinalIgnoreCase;
      return ordinalIgnoreCase.GetHashCode(this._filePath ?? string.Empty) ^ ordinalIgnoreCase.GetHashCode(this._streamName ?? string.Empty);
    }

    public override bool Equals(object obj)
    {
      if (obj == null)
        return false;
      if ((object) this == obj)
        return true;
      return obj is AlternateDataStreamInfo other && this.Equals(other);
    }

    public bool Equals(AlternateDataStreamInfo other)
    {
      if ((object) other == null)
        return false;
      if ((object) this == (object) other)
        return true;
      StringComparer ordinalIgnoreCase = StringComparer.OrdinalIgnoreCase;
      return ordinalIgnoreCase.Equals(this._filePath ?? string.Empty, other._filePath ?? string.Empty) && ordinalIgnoreCase.Equals(this._streamName ?? string.Empty, other._streamName ?? string.Empty);
    }

    public static bool operator ==(AlternateDataStreamInfo first, AlternateDataStreamInfo second)
    {
      if ((object) first == (object) second)
        return true;
      return (object) first != null && (object) second != null && first.Equals(second);
    }

    public static bool operator !=(AlternateDataStreamInfo first, AlternateDataStreamInfo second)
    {
      if ((object) first == (object) second)
        return false;
      return (object) first == null || (object) second == null || !first.Equals(second);
    }

    public bool Delete()
    {
      new FileIOPermission(FileIOPermissionAccess.Write, this._filePath).Demand();
      return SafeNativeMethods.SafeDeleteFile(this.FullPath);
    }

    private static FileIOPermissionAccess CalculateAccess(
      FileMode mode,
      FileAccess access)
    {
      FileIOPermissionAccess access1 = FileIOPermissionAccess.NoAccess;
      switch (mode)
      {
        case FileMode.CreateNew:
        case FileMode.Create:
        case FileMode.OpenOrCreate:
        case FileMode.Truncate:
          access1 = FileIOPermissionAccess.Write;
          break;
        case FileMode.Open:
          access1 = FileIOPermissionAccess.Read;
          break;
        case FileMode.Append:
          access1 = FileIOPermissionAccess.Append;
          break;
      }
      switch (access)
      {
        case FileAccess.Read:
          access1 |= FileIOPermissionAccess.Read;
          break;
        case FileAccess.Write:
          access1 |= FileIOPermissionAccess.Write;
          break;
        case FileAccess.ReadWrite:
          access1 = access1 | FileIOPermissionAccess.Write | FileIOPermissionAccess.Read;
          break;
      }
      return access1;
    }

    public FileStream Open(
      FileMode mode,
      FileAccess access,
      FileShare share,
      int bufferSize,
      bool useAsync)
    {
      if (0 >= bufferSize)
        throw new ArgumentOutOfRangeException(nameof (bufferSize), (object) bufferSize, (string) null);
      new FileIOPermission(AlternateDataStreamInfo.CalculateAccess(mode, access), this._filePath).Demand();
      SafeNativeMethods.NativeFileFlags flags = useAsync ? SafeNativeMethods.NativeFileFlags.Overlapped : (SafeNativeMethods.NativeFileFlags) 0;
      SafeFileHandle file = SafeNativeMethods.SafeCreateFile(this.FullPath, access.ToNative(), share, IntPtr.Zero, mode, flags, IntPtr.Zero);
      if (file.IsInvalid)
        SafeNativeMethods.ThrowLastIOError(this.FullPath);
      return new FileStream(file, access, bufferSize, useAsync);
    }

    public FileStream Open(
      FileMode mode,
      FileAccess access,
      FileShare share,
      int bufferSize)
    {
      return this.Open(mode, access, share, bufferSize, false);
    }

    public FileStream Open(FileMode mode, FileAccess access, FileShare share) => this.Open(mode, access, share, 4096, false);

    public FileStream Open(FileMode mode, FileAccess access) => this.Open(mode, access, FileShare.None, 4096, false);

    public FileStream Open(FileMode mode)
    {
      FileAccess access = FileMode.Append == mode ? FileAccess.Write : FileAccess.ReadWrite;
      return this.Open(mode, access, FileShare.None, 4096, false);
    }

    public FileStream OpenRead() => this.Open(FileMode.Open, FileAccess.Read, FileShare.Read);

    public FileStream OpenWrite() => this.Open(FileMode.OpenOrCreate, FileAccess.Write, FileShare.None);

    public StreamReader OpenText() => new StreamReader((Stream) this.Open(FileMode.Open, FileAccess.Read, FileShare.Read));
  }
}
