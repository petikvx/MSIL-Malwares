// Decompiled with JetBrains decompiler
// Type: ᭂ൱ễᯧ੻ಱាᮇᢑښᖡኞ׼ด.ݒ᡽ᰧᵅՐଆݶ˲Φ
// Assembly: trraaa, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 832C03EF-4027-4148-8669-9B38E84E6716
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Trojan.Win32.Scar.mtzz-552836309c43a6339ff0b708baff33dc65ab36ff3b98038d01dbd0c96ae605cc.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace \u1B42\u0D71ễᯧ\u0A7Bಱាᮇᢑښᖡኞ\u05FCด
{
  internal class ݒ\u187DᰧᵅՐଆݶ\u02F2Φ
  {
    public static byte[] \u1B43ྔᏃጄᷰ\u192Cםஉᥢᕟሽ(byte[] _param0, bool _param1)
    {
      try
      {
        int num = new Random().Next(-2000000000, 2000000000);
        for (int index = 0; index < _param0.Length; ++index)
          _param0[index] = (_param0[index] += (byte) num);
        List<byte> byteList = new List<byte>();
        byteList.AddRange((IEnumerable<byte>) _param0);
        byte[] bytes = BitConverter.GetBytes(num);
        byteList.InsertRange(byteList.Count / 2, (IEnumerable<byte>) bytes);
        byte[] array = byteList.ToArray();
        byteList.Clear();
        return _param1 ? Encoding.ASCII.GetBytes(Convert.ToBase64String(array)) : array;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public static byte[] ᘞϷ\u0AF7ᨡᴰ\u1774ੋ\u0BACߓᕲ\u008FẲУ͔ȴڊਸ਼\u0B5B(byte[] ቔᮘࣺኒ᭒ష, bool _param1)
    {
      try
      {
        List<byte> byteList1 = new List<byte>(_param1 ? (IEnumerable<byte>) Convert.FromBase64String(Encoding.ASCII.GetString(ቔᮘࣺኒ᭒ష)) : (IEnumerable<byte>) ቔᮘࣺኒ᭒ష);
        int int32 = BitConverter.ToInt32(byteList1.GetRange((byteList1.Count - 4) / 2, 4).ToArray(), 0);
        byteList1.RemoveRange((byteList1.Count - 4) / 2, 4);
        for (int index1 = 0; index1 < byteList1.Count; ++index1)
        {
          List<byte> byteList2;
          int index2;
          byteList1[index1] = (byteList2 = byteList1)[index2 = index1] = (byte) ((uint) byteList2[index2] - (uint) (byte) int32);
        }
        byte[] array = byteList1.ToArray();
        byteList1.Clear();
        return array;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public static string ڼᣖଧԎህừቀ\u1AF8\u17ED(string _param0, bool _param1)
    {
      try
      {
        int num = new Random().Next(-2000000000, 2000000000);
        byte[] bytes1 = Encoding.GetEncoding(1252).GetBytes(_param0);
        for (int index = 0; index < bytes1.Length; ++index)
          bytes1[index] += (byte) num;
        List<byte> byteList = new List<byte>();
        byteList.AddRange((IEnumerable<byte>) bytes1);
        byte[] bytes2 = BitConverter.GetBytes(num);
        byteList.InsertRange(byteList.Count / 2, (IEnumerable<byte>) bytes2);
        byte[] array = byteList.ToArray();
        byteList.Clear();
        return _param1 ? Convert.ToBase64String(array) : Encoding.GetEncoding(1252).GetString(array);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static string Ἶ᱃\u104DʝᦙƺᅴඛÙጯ᭓ᄔ\u03A2ᴼጎ(string _param0, bool _param1)
    {
      try
      {
        List<byte> byteList1 = new List<byte>(_param1 ? (IEnumerable<byte>) Convert.FromBase64String(_param0) : (IEnumerable<byte>) Encoding.GetEncoding(1252).GetBytes(_param0));
        int int32 = BitConverter.ToInt32(byteList1.GetRange((byteList1.Count - 4) / 2, 4).ToArray(), 0);
        byteList1.RemoveRange((byteList1.Count - 4) / 2, 4);
        for (int index1 = 0; index1 < byteList1.Count; ++index1)
        {
          List<byte> byteList2;
          int index2;
          byteList1[index1] = (byteList2 = byteList1)[index2 = index1] = (byte) ((uint) byteList2[index2] - (uint) (byte) int32);
        }
        byte[] array = byteList1.ToArray();
        byteList1.Clear();
        return Encoding.GetEncoding(1252).GetString(array);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static byte[] ϟᴓᬓథჾຼᆶᦊἩቤரጴ̂ۼ\u0D81ᚪగ(byte[] _param0)
    {
      MemoryStream memoryStream = new MemoryStream();
      using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Compress, true))
        gzipStream.Write(_param0, 0, _param0.Length);
      memoryStream.Position = 0L;
      byte[] numArray = new byte[memoryStream.Length];
      memoryStream.Read(numArray, 0, numArray.Length);
      byte[] dst = new byte[numArray.Length + 4];
      Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 4, numArray.Length);
      Buffer.BlockCopy((Array) BitConverter.GetBytes(_param0.Length), 0, (Array) dst, 0, 4);
      return dst;
    }

    public static byte[] \u0B8Dדᴚ᱙ЎقՔ\u0A7B\u1377\u0892ᬵၓ(byte[] _param0)
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        int int32 = BitConverter.ToInt32(_param0, 0);
        memoryStream.Write(_param0, 4, _param0.Length - 4);
        byte[] buffer = new byte[int32];
        memoryStream.Position = 0L;
        using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress))
          gzipStream.Read(buffer, 0, buffer.Length);
        return buffer;
      }
    }
  }
}
