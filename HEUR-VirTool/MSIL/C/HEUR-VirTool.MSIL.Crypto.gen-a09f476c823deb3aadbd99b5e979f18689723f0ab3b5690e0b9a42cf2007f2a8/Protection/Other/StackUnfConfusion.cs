// Decompiled with JetBrains decompiler
// Type: Aura.Protection.Other.StackUnfConfusion
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;

namespace Aura.Protection.Other
{
  internal class StackUnfConfusion
  {
    public static void Execute(ModuleDef mod)
    {
      foreach (TypeDef type in (IEnumerable<TypeDef>) mod.Types)
      {
        foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
        {
          if (method != null)
          {
            if (!method.HasBody)
              break;
          }
          CilBody body = method.Body;
          Instruction instruction1 = body.Instructions[0];
          Instruction instruction2 = Instruction.Create(OpCodes.Br_S, instruction1);
          Instruction instruction3 = Instruction.Create(OpCodes.Pop);
          Random random = new Random();
          Instruction instruction4;
          switch (random.Next(0, 5))
          {
            case 0:
              instruction4 = Instruction.Create(OpCodes.Ldnull);
              break;
            case 1:
              instruction4 = Instruction.Create(OpCodes.Ldc_I4_0);
              break;
            case 2:
              instruction4 = Instruction.Create(OpCodes.Ldstr, "Isolator");
              break;
            case 3:
              instruction4 = Instruction.Create(OpCodes.Ldc_I8, (long) (uint) random.Next());
              break;
            default:
              instruction4 = Instruction.Create(OpCodes.Ldc_I8, (long) random.Next());
              break;
          }
          body.Instructions.Insert(0, instruction4);
          body.Instructions.Insert(1, instruction3);
          body.Instructions.Insert(2, instruction2);
          foreach (ExceptionHandler exceptionHandler in (IEnumerable<ExceptionHandler>) body.ExceptionHandlers)
          {
            if (exceptionHandler.TryStart == instruction1)
              exceptionHandler.TryStart = instruction2;
            else if (exceptionHandler.HandlerStart == instruction1)
              exceptionHandler.HandlerStart = instruction2;
            else if (exceptionHandler.FilterStart == instruction1)
              exceptionHandler.FilterStart = instruction2;
          }
        }
      }
    }
  }
}
