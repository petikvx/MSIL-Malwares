// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: LifeCam, Version=3.60.253.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 16D47BC9-0FDC-492D-A953-35F25C3284AF
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Virus.Win32.Sality.l-1d0300b3fbc317f081315e8ae1353365d7d4fc5a3fe11643115b8664358e3aa1.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using ATL;
using HWSW;
using LifeCam;
using Microsoft.LifeCam;
using Microsoft.LifeCam.Framework;
using Microsoft.LifeCam.Interfaces;
using std;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13HADIAKP\u0040\u003F\u0024AAS\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13LHMFKAAD\u0040\u003F\u0024AAM\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13MKMNOPIJ\u0040\u003F\u0024AAD\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13OPKGLAFF\u0040\u003F\u0024AAB\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17LLMMEOJD\u0040\u003F\u0024AAV\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040JFAIJMHL\u0040\u003F\u0024AAF\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AAo\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040GCKHIPE\u0040\u003F\u0024AAN\u003F\u0024AAo\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AAo\u003F\u0024AAv\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040JDLOHAN\u0040\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static CAtlReleaseManagedClassFactories ATL\u002E_AtlReleaseManagedClassFactories;
  internal static __FnPtr<void ()> ATL\u002E\u003FA0x9ad1c3c2\u002E_AtlReleaseManagedClassFactories\u0024initializer\u0024;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_4 _CTA1\u003FAVCAtlException\u0040ATL\u0040\u0040;
  internal static _s__ThrowInfo _TI1\u003FAVCAtlException\u0040ATL\u0040\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVCAtlException\u0040ATL\u0040\u0040\u004084;
  internal static unsafe void* _pAtlReleaseManagedClassFactories;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszBinaryVal;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszStringVal;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszForceRemove;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszValToken;
  internal static unsafe _ATL_OBJMAP_ENTRY30* __pobjMapEntryLast;
  internal static unsafe _ATL_OBJMAP_ENTRY30* __pobjMapEntryFirst;
  internal static bool \u003Fm_bInitFailed\u0040CAtlBaseModule\u0040ATL\u0040\u00402_NA;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszNoRemove;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszDwordVal;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EmultiszStringVal;
  internal static unsafe char* ATL\u002E\u003FA0x9ad1c3c2\u002EszDelete;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAVCAtlException\u0040ATL\u0040\u0040\u00408;
  internal static int __\u0040\u0040_PchSym_\u004000\u0040UoxDFUkirezgvUhlfixvUoruvxznUoruvxznvcvUlyqUrDIGUhgwzucOlyq\u0040LifeCam;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GHFPNOJB\u0040bad\u003F5allocation\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040JGCFCPCG\u0040_vscprintf\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040NMHKHHHE\u0040vsprintf_s\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BE\u0040HCIKGJGE\u0040MultiByteToWideChar\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040HEIBIEOC\u0040\u003F\u0024AA_\u003F\u0024AAv\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAw\u003F\u0024AAp\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAf\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040KIIIEDBA\u0040\u003F\u0024AAv\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAp\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAf\u003F\u0024AA_\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08GBIGGCJG\u0040wWinMain\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DG\u0040JOPJNFEK\u0040c\u003F3\u003F2lc35\u003F2private\u003F2source\u003F2lifecam\u003F2l\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07LDDIIHCM\u0040RELEASE\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040HNBLOGNC\u00403\u003F460\u003F4253\u003F40\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BK\u0040COBJGHAO\u0040Launch\u003F5LifeCam\u003F4exe\u003F\u0024CI\u003F\u0024CFs\u003F\u0024CJ\u003F5\u003F\u0024CFs\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BB\u0040KMPPJFEH\u0040Microsoft\u003F4WebCam\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CB\u0040HKLFHONI\u0040Timing\u003F5\u003F9\u003F5LifeCam\u003F5Startup\u003F5\u003F9\u003F5Begin\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040KFDOFEBP\u0040\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AA2\u003F\u0024AA\u003F4\u003F\u0024AA0\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CE\u0040GKDNHDFN\u0040\u003F\u0024AAM\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DO\u0040FDCKCHIB\u0040\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AAW\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAM\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CG\u0040CBABNLNL\u0040WinMain\u003F5started\u003F5with\u003F5command\u003F5lin\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BB\u0040MMNDKHJ\u0040Microsoft\u003F4Webcam\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0N\u0040JEPACGJG\u0040WinMain\u003F5quit\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040DAGPJHDJ\u0040\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0ED\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0ED\u0040BBPNNCLM\u0040\u003F\u0024GAanonymous\u003F9namespace\u003F8\u003F3\u003F3ShowCantS\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BG\u0040NMJPHPGC\u0040Failed\u003F5to\u003F5load\u003F5iceres\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DM\u0040PILPPHEH\u0040Failed\u003F5to\u003F5load\u003F5IDS_LIFECAM_INSTA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EC\u0040GMENKHCJ\u0040\u003F\u0024AAS\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AAt\u003F\u0024AAw\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F2\u003F\u0024AAM\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AAt\u003F\u0024AA\u003F2\u003F\u0024AAW\u003F\u0024AAe\u003F\u0024AAb\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAo\u003F\u0024AAg\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAr\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CG\u0040HNKLEAAF\u0040\u003F\u0024GAanonymous\u003F9namespace\u003F8\u003F3\u003F3RunApplic\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EA\u0040DCLALHO\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAq\u003F\u0024AAu\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F6\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BM\u0040PAPJHAGI\u0040invalid\u003F5map\u003F1set\u003F\u0024DMT\u003F\u0024DO\u003F5iterator\u003F\u0024AA\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2SetupRebootRequestInfo\u0040LifeCam\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2out_of_range\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2length_error\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2logic_error\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040SetupRebootRequestInfo\u0040LifeCam\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040out_of_range\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040length_error\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040logic_error\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3SetupRebootRequestInfo\u0040LifeCam\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_37 \u003F\u003F_R0\u003FAVSetupRebootRequestInfo\u0040LifeCam\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3out_of_range\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3length_error\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3logic_error\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4SetupRebootRequestInfo\u0040LifeCam\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4out_of_range\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4length_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4logic_error\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_8 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVlength_error\u0040std\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7SetupRebootRequestInfo\u0040LifeCam\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W LifeCam\u002E\u003FA0x0a092d3c\u002EproductName_;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_12 _CTA3\u003FAVout_of_range\u0040std\u0040\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVlogic_error\u0040std\u0040\u0040\u00408\u003F\u003F0logic_error\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z40;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVout_of_range\u0040std\u0040\u0040\u00408\u003F\u003F0out_of_range\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z40;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAVlogic_error\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVout_of_range\u0040std\u0040\u0040\u00408;
  internal static _s__ThrowInfo _TI3\u003FAVout_of_range\u0040std\u0040\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408\u003F\u003F0exception\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0x0a092d3c\u002E_bad_alloc_Message;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xf084536d\u002E__xc_mp_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xf084536d\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xf084536d\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xf084536d\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xf084536d\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf084536d\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xf084536d\u002E__xc_mp_a;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static uint \u003FA0xc4f9df4a\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0xc4f9df4a\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0xc4f9df4a\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  internal static unsafe sbyte* std\u002E\u003FA0xebe6e0bc\u002E_bad_alloc_Message;
  internal static unsafe _Fac_node* std\u002E\u003FA0xebe6e0bc\u002E_Fac_head;
  public static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  public static CAtlComModule ATL\u002E_AtlComModule;
  public static nothrow_t std\u002Enothrow;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  public static volatile uint __native_vcclrit_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  public static volatile __enative_startup_state __native_startup_state;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  public static volatile unsafe void* __native_startup_lock;
  public static volatile uint __native_dllmain_reason;

  internal static unsafe void ATL\u002ECAtlComModule\u002ETerm([In] CAtlComModule* obj0)
  {
    if (*(int*) obj0 == 0)
      return;
    _ATL_OBJMAP_ENTRY30** atlObjmapEntrY30Ptr1 = (_ATL_OBJMAP_ENTRY30**) *(int*) ((IntPtr) obj0 + 8);
    if ((UIntPtr) atlObjmapEntrY30Ptr1 < (UIntPtr) *(int*) ((IntPtr) obj0 + 12))
    {
      do
      {
        uint num1 = (uint) *(int*) atlObjmapEntrY30Ptr1;
        if (num1 != 0U)
        {
          _ATL_OBJMAP_ENTRY30* atlObjmapEntrY30Ptr2 = (_ATL_OBJMAP_ENTRY30*) num1;
          uint num2 = (uint) *(int*) ((IntPtr) atlObjmapEntrY30Ptr2 + 16);
          if (num2 != 0U)
          {
            int num3 = (int) num2;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            int num4 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) num3 + 8))((IntPtr) num3);
          }
          *(int*) ((IntPtr) atlObjmapEntrY30Ptr2 + 16) = 0;
        }
        atlObjmapEntrY30Ptr1 += 4;
      }
      while ((UIntPtr) atlObjmapEntrY30Ptr1 < (UIntPtr) *(int*) ((IntPtr) obj0 + 12));
    }
    \u003CModule\u003E.DeleteCriticalSection((_RTL_CRITICAL_SECTION*) ((IntPtr) obj0 + 16));
    *(int*) obj0 = 0;
  }

  internal static void \u003FA0x9ad1c3c2\u002E\u003F\u003F__E_AtlReleaseManagedClassFactories\u0040ATL\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x9ad1c3c2\u002E\u003F\u003F__F_AtlReleaseManagedClassFactories\u0040ATL\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0x9ad1c3c2\u002E\u003F\u003F__F_AtlReleaseManagedClassFactories\u0040ATL\u0040\u0040YMXXZ() => \u003CModule\u003E.ATL\u002ECAtlComModule\u002ETerm(&\u003CModule\u003E.ATL\u002E_AtlComModule);

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Elogic_error\u002E\u007Bdtor\u007D([In] logic_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7logic_error\u0040std\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((exception*) obj0);
  }

  internal static unsafe void* std\u002Elogic_error\u002E__vecDelDtor(
    [In] logic_error* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      logic_error* logicErrorPtr = (logic_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) logicErrorPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elogic_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) logicErrorPtr);
      return (void*) logicErrorPtr;
    }
    \u003CModule\u003E.std\u002Elogic_error\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Elength_error\u002E\u007Bdtor\u007D([In] length_error* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Elogic_error\u002E\u007Bdtor\u007D((logic_error*) obj0);
  }

  internal static unsafe void* std\u002Elength_error\u002E__vecDelDtor(
    [In] length_error* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      length_error* lengthErrorPtr = (length_error*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) lengthErrorPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elength_error\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) lengthErrorPtr);
      return (void*) lengthErrorPtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7length_error\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Elogic_error\u002E\u007Bdtor\u007D((logic_error*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Eout_of_range\u002E\u007Bdtor\u007D([In] out_of_range* obj0)
  {
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Elogic_error\u002E\u007Bdtor\u007D((logic_error*) obj0);
  }

  internal static unsafe void* std\u002Eout_of_range\u002E__vecDelDtor(
    [In] out_of_range* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      out_of_range* outOfRangePtr = (out_of_range*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) outOfRangePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eout_of_range\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) outOfRangePtr);
      return (void*) outOfRangePtr;
    }
    *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_7out_of_range\u0040std\u0040\u00406B\u0040;
    \u003CModule\u003E.std\u002Elogic_error\u002E\u007Bdtor\u007D((logic_error*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe LogEvent* HWSW\u002ELogEvent\u002E\u007Bctor\u007D(
    [In] LogEvent* obj0,
    HWSW.LogLevel level,
    sbyte* file,
    int line,
    sbyte* function)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    *(int*) obj0 = (int) level;
    LogEvent* logEventPtr1 = (LogEvent*) ((IntPtr) obj0 + 4);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) logEventPtr1);
    // ISSUE: fault handler
    try
    {
      *(int*) ((IntPtr) obj0 + 32) = line;
      LogEvent* logEventPtr2 = (LogEvent*) ((IntPtr) obj0 + 36);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) logEventPtr2);
      // ISSUE: fault handler
      try
      {
        *(int*) ((IntPtr) obj0 + 64) = 0;
        // ISSUE: fault handler
        try
        {
          *(int*) ((IntPtr) obj0 + 68) = (int) \u003CModule\u003E.GetCurrentThreadId();
          *(int*) ((IntPtr) obj0 + 72) = (int) \u003CModule\u003E.GetCurrentProcessId();
          try
          {
            \u003CModule\u003E.GetLocalTime((_SYSTEMTIME*) ((IntPtr) obj0 + 76));
            if (*(int*) obj0 < 0)
              *(int*) obj0 = 0;
            if (*(int*) obj0 > 6)
              *(int*) obj0 = 6;
            sbyte* numPtr1 = (IntPtr) file == IntPtr.Zero ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040 : file;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) logEventPtr1, numPtr1);
            sbyte* numPtr2 = (IntPtr) function == IntPtr.Zero ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040 : function;
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) logEventPtr2, numPtr2);
          }
          catch (Exception ex1) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num2 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
            try
            {
              try
              {
              }
              catch (Exception ex2) when (
              {
                // ISSUE: unable to correctly present filter
                num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num2 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              goto label_20;
              if (num2 != 0U)
                throw;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
            }
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(ATL\u002ECAutoVectorPtr\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 64));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 36));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
label_20:
    return obj0;
  }

  [STAThread]
  internal static unsafe int wWinMain(
    HINSTANCE__* hInstance,
    HINSTANCE__* hPrevInstance,
    char* lpCmdLine,
    int nCmdShow)
  {
    \u003CModule\u003E.HeapSetInformation((void*) 0, (_HEAP_INFORMATION_CLASS) 1, (void*) 0, 0U);
    int num1 = (int) \u003CModule\u003E._set_abort_behavior(0U, 1U);
    \u003CModule\u003E.CoInitializeEx((void*) 0, 2U);
    \u003CModule\u003E.InitializeLoggingModule();
    LogEvent logEvent1;
    LogEvent* logEventPtr1 = \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bctor\u007D(&logEvent1, (HWSW.LogLevel) 4, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040JOPJNFEK\u0040c\u003F3\u003F2lc35\u003F2private\u003F2source\u003F2lifecam\u003F2l\u0040, 54, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_08GBIGGCJG\u0040wWinMain\u003F\u0024AA\u0040);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.HWSW\u002ELogEvent\u002ELog(logEventPtr1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040KMPPJFEH\u0040Microsoft\u003F4WebCam\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BK\u0040COBJGHAO\u0040Launch\u003F5LifeCam\u003F4exe\u003F\u0024CI\u003F\u0024CFs\u003F\u0024CJ\u003F5\u003F\u0024CFs\u003F\u0024AA\u0040, __arglist (out \u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040HNBLOGNC\u00403\u003F460\u003F4253\u003F40\u003F\u0024AA\u003F\u0024AA\u0040, out \u003CModule\u003E.\u003F\u003F_C\u0040_07LDDIIHCM\u0040RELEASE\u003F\u0024AA\u0040));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(HWSW\u002ELogEvent\u002E\u007Bdtor\u007D), (void*) &logEvent1);
    }
    \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bdtor\u007D(&logEvent1);
    LogEvent logEvent2;
    LogEvent* logEventPtr2 = \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bctor\u007D(&logEvent2, (HWSW.LogLevel) 4, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040JOPJNFEK\u0040c\u003F3\u003F2lc35\u003F2private\u003F2source\u003F2lifecam\u003F2l\u0040, 57, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_08GBIGGCJG\u0040wWinMain\u003F\u0024AA\u0040);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.HWSW\u002ELogEvent\u002ELog(logEventPtr2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040KMPPJFEH\u0040Microsoft\u003F4WebCam\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CB\u0040HKLFHONI\u0040Timing\u003F5\u003F9\u003F5LifeCam\u003F5Startup\u003F5\u003F9\u003F5Begin\u0040, __arglist ());
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(HWSW\u002ELogEvent\u002E\u007Bdtor\u007D), (void*) &logEvent2);
    }
    \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bdtor\u007D(&logEvent2);
    void* eventW = \u003CModule\u003E.CreateEventW((_SECURITY_ATTRIBUTES*) 0, 0, 0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040KFDOFEBP\u0040\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AA2\u003F\u0024AA\u003F4\u003F\u0024AA0\u003F\u0024AA\u003F\u0024AA\u0040);
    if (183U == \u003CModule\u003E.GetLastError())
    {
      HWND__* windowW = \u003CModule\u003E.FindWindowW((char*) 0, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1CE\u0040GKDNHDFN\u0040\u003F\u0024AAM\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAC\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040);
      if ((IntPtr) windowW != IntPtr.Zero)
      {
        uint num2 = \u003CModule\u003E.RegisterWindowMessageW((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1DO\u0040FDCKCHIB\u0040\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AAW\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAM\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AAs\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040);
        \u003CModule\u003E.PostMessageW(windowW, num2, 0U, 0);
      }
      \u003CModule\u003E.CloseHandle(eventW);
      return 1;
    }
    \u003CModule\u003E.HWSW\u002Ecompile_me_out((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040MMNDKHJ\u0040Microsoft\u003F4Webcam\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CG\u0040CBABNLNL\u0040WinMain\u003F5started\u003F5with\u003F5command\u003F5lin\u0040, __arglist ((IntPtr) lpCmdLine));
    SetupRebootRequestInfo rebootRequestInfo;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref rebootRequestInfo = (int) &\u003CModule\u003E.\u003F\u003F_7SetupRebootRequestInfo\u0040LifeCam\u0040\u00406B\u0040;
    int num3;
    if (\u003CModule\u003E.LifeCam\u002ESetupRebootRequestInfo\u002ESystemHasNotRebootedSinceSetupRebootRequest(&rebootRequestInfo))
    {
      \u003CModule\u003E.\u003FA0x0a092d3c\u002EShowCantStartLifeCamUntilAfterRebootMessage();
      num3 = 1;
    }
    else
    {
      // ISSUE: method pointer
      num3 = UncaughtExceptionHandler.CreateInstance(new RunFunction((object) null, __methodptr(\u003FA0x0a092d3c\u002ERunApplication)), \u003CModule\u003E.\u003FA0x0a092d3c\u002EShouldLogExceptions()).Run(new string(lpCmdLine));
    }
    \u003CModule\u003E.HWSW\u002Ecompile_me_out((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040MMNDKHJ\u0040Microsoft\u003F4Webcam\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0N\u0040JEPACGJG\u0040WinMain\u003F5quit\u003F\u0024AA\u0040, __arglist ());
    \u003CModule\u003E.ShutdownLoggingModule();
    \u003CModule\u003E.CoUninitialize();
    return num3;
  }

  internal static unsafe void HWSW\u002ELogEvent\u002E\u007Bdtor\u007D([In] LogEvent* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        CAutoVectorPtr\u003Cwchar_t\u003E* cautoVectorPtrWcharTPtr = (CAutoVectorPtr\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 64);
        \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) cautoVectorPtrWcharTPtr);
        *(int*) cautoVectorPtrWcharTPtr = 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 36));
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 36));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe void \u003FA0x0a092d3c\u002EShowCantStartLifeCamUntilAfterRebootMessage()
  {
    HINSTANCE__* hinstancePtr = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BG\u0040DAGPJHDJ\u0040\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAd\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040);
    if ((IntPtr) hinstancePtr == IntPtr.Zero)
    {
      LogEvent logEvent;
      LogEvent* logEventPtr = \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bctor\u007D(&logEvent, (HWSW.LogLevel) 2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040JOPJNFEK\u0040c\u003F3\u003F2lc35\u003F2private\u003F2source\u003F2lifecam\u003F2l\u0040, 112, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0ED\u0040BBPNNCLM\u0040\u003F\u0024GAanonymous\u003F9namespace\u003F8\u003F3\u003F3ShowCantS\u0040);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.HWSW\u002ELogEvent\u002ELog(logEventPtr, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040MMNDKHJ\u0040Microsoft\u003F4Webcam\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BG\u0040NMJPHPGC\u0040Failed\u003F5to\u003F5load\u003F5iceres\u003F\u0024AA\u0040, __arglist ());
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(HWSW\u002ELogEvent\u002E\u007Bdtor\u007D), (void*) &logEvent);
      }
      \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bdtor\u007D(&logEvent);
    }
    else
    {
      \u0024ArrayType\u0024\u0024\u0024BY0EAB\u0040_W arrayTypeBy0EabW;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(short&) ref arrayTypeBy0EabW = (short) 0;
      // ISSUE: cast to a reference type
      // ISSUE: initblk instruction
      __memset((\u0024ArrayType\u0024\u0024\u0024BY0EAB\u0040_W&) ((IntPtr) &arrayTypeBy0EabW + 2), 0, 2048);
      if (\u003CModule\u003E.LoadStringW(hinstancePtr, 9232U, (char*) &arrayTypeBy0EabW, 1024) > 0)
      {
        \u003CModule\u003E.MessageBoxW((HWND__*) 0, (char*) &arrayTypeBy0EabW, (char*) &\u003CModule\u003E.LifeCam\u002E\u003FA0x0a092d3c\u002EproductName_, 48U);
      }
      else
      {
        LogEvent logEvent;
        LogEvent* logEventPtr = \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bctor\u007D(&logEvent, (HWSW.LogLevel) 2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040JOPJNFEK\u0040c\u003F3\u003F2lc35\u003F2private\u003F2source\u003F2lifecam\u003F2l\u0040, 124, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0ED\u0040BBPNNCLM\u0040\u003F\u0024GAanonymous\u003F9namespace\u003F8\u003F3\u003F3ShowCantS\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.HWSW\u002ELogEvent\u002ELog(logEventPtr, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040MMNDKHJ\u0040Microsoft\u003F4Webcam\u003F\u0024AA\u0040, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DM\u0040PILPPHEH\u0040Failed\u003F5to\u003F5load\u003F5IDS_LIFECAM_INSTA\u0040, __arglist ((int) \u003CModule\u003E.GetLastError()));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(HWSW\u002ELogEvent\u002E\u007Bdtor\u007D), (void*) &logEvent);
        }
        \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bdtor\u007D(&logEvent);
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x0a092d3c\u002EShouldLogExceptions()
  {
    CRegKey cregKey;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref cregKey = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &cregKey + 4) = 0;
    bool flag;
    // ISSUE: fault handler
    try
    {
      flag = \u003CModule\u003E.ATL\u002ECRegKey\u002EOpen(&cregKey, (HKEY__*) -2147483646, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1EC\u0040GMENKHCJ\u0040\u003F\u0024AAS\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AAt\u003F\u0024AAw\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F2\u003F\u0024AAM\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAs\u003F\u0024AAo\u003F\u0024AAf\u003F\u0024AAt\u003F\u0024AA\u003F2\u003F\u0024AAW\u003F\u0024AAe\u003F\u0024AAb\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAo\u003F\u0024AAg\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAr\u0040, 131097U) == 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(ATL\u002ECRegKey\u002E\u007Bdtor\u007D), (void*) &cregKey);
    }
    \u003CModule\u003E.ATL\u002ECRegKey\u002EClose(&cregKey);
    return flag;
  }

  internal static unsafe int \u003FA0x0a092d3c\u002ERunApplication(string cmdLine)
  {
    int num = 0;
    try
    {
      StartupOptions startupOptions = new StartupOptions();
      startupOptions.ShowMainWindow = true;
      char[] chArray = new char[3]{ ' ', '\t', '\n' };
      string[] strArray = cmdLine.Split(chArray);
      startupOptions.Arguments = strArray;
      num = ApplicationManager.RunApplication(startupOptions, (IFactory<IApplication>) LifeCamApplication.Factory);
      ((IDisposable) ApplicationContext.Current)?.Dispose();
    }
    catch (InitializationRequirementsException ex)
    {
      fixed (char* chPtr = &\u003CModule\u003E.PtrToStringChars(((Exception) ex).ToString()))
      {
        // ISSUE: variable of a reference type
        char* local;
        // ISSUE: fault handler
        try
        {
          LogEvent logEvent;
          LogEvent* logEventPtr = \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bctor\u007D(&logEvent, (HWSW.LogLevel) 2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0DG\u0040JOPJNFEK\u0040c\u003F3\u003F2lc35\u003F2private\u003F2source\u003F2lifecam\u003F2l\u0040, 161, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CG\u0040HNKLEAAF\u0040\u003F\u0024GAanonymous\u003F9namespace\u003F8\u003F3\u003F3RunApplic\u0040);
          // ISSUE: fault handler
          try
          {
            // ISSUE: cast to a reference type
            \u003CModule\u003E.HWSW\u002ELogEvent\u002ELog(logEventPtr, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BB\u0040MMNDKHJ\u0040Microsoft\u003F4Webcam\u003F\u0024AA\u0040, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1EA\u0040DCLALHO\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAq\u003F\u0024AAu\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F6\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040, __arglist ((char*) chPtr));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(HWSW\u002ELogEvent\u002E\u007Bdtor\u007D), (void*) &logEvent);
          }
          \u003CModule\u003E.HWSW\u002ELogEvent\u002E\u007Bdtor\u007D(&logEvent);
        }
        __fault
        {
          // ISSUE: cast to a reference type
          local = (char*) 0;
        }
        // ISSUE: cast to a reference type
        local = (char*) 0;
      }
    }
    return num;
  }

  internal static char* PtrToStringChars(string s)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* stringChars = (byte*) s;
    if (stringChars != null)
    {
      // ISSUE: cast to a reference type
      stringChars = (byte*) (RuntimeHelpers.OffsetToStringData + (IntPtr) stringChars);
    }
    // ISSUE: cast to a reference type
    return (char&) stringChars;
  }

  internal static unsafe int ATL\u002ECRegKey\u002EOpen(
    [In] CRegKey* obj0,
    HKEY__* hKeyParent,
    char* lpszKeyName,
    uint samDesired)
  {
    HKEY__* hkeyPtr = (HKEY__*) 0;
    int num = \u003CModule\u003E.RegOpenKeyExW(hKeyParent, lpszKeyName, 0U, samDesired, &hkeyPtr);
    if (num == 0)
    {
      num = \u003CModule\u003E.ATL\u002ECRegKey\u002EClose(obj0);
      *(int*) obj0 = (int) hkeyPtr;
      *(int*) ((IntPtr) obj0 + 4) = (int) samDesired & 768;
    }
    return num;
  }

  internal static unsafe int ATL\u002ECRegKey\u002EClose([In] CRegKey* obj0)
  {
    int num1 = 0;
    uint num2 = (uint) *(int*) obj0;
    if (num2 != 0U)
    {
      int num3 = \u003CModule\u003E.RegCloseKey((HKEY__*) num2);
      *(int*) obj0 = 0;
      num1 = num3;
    }
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return num1;
  }

  internal static unsafe void ATL\u002ECRegKey\u002E\u007Bdtor\u007D([In] CRegKey* obj0) => \u003CModule\u003E.ATL\u002ECRegKey\u002EClose(obj0);

  internal static unsafe void ATL\u002ECAutoVectorPtr\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] CAutoVectorPtr\u003Cwchar_t\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) obj0);
    *(int*) obj0 = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0xf084536d\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0xf084536d\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0xf084536d\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0xf084536d\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xf084536d\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num4 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
        num3 = 1;
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num5 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num5);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [PrePrepareMethod]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA)) : (ValueType) null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      object obj = new object();
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(obj);
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0xc4f9df4a\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0xc4f9df4a\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0xc4f9df4a\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [DebuggerStepThrough]
  internal static void \u003FA0xc4f9df4a\u002E__dealloc_global_lock()
  {
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend_e,
    __FnPtr<void ()>** __ponexitbegin_e)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__global_lock())
    {
      try
      {
        __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitbegin_e);
        __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitend_e);
        __FnPtr<void ()>* local4 = (__FnPtr<void ()>*) ((IntPtr) local3 - (IntPtr) local2);
        if ((UIntPtr) ((int) *__pexit_list_size - 1) < (UIntPtr) local4 >> 2)
        {
          try
          {
            uint num2 = *__pexit_list_size * 4U;
            uint num3 = num2 >= 2048U ? 2048U : num2;
            IntPtr cb = new IntPtr((int) num2 + (int) num3);
            IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num4.ToPointer() + (IntPtr) local4);
            local2 = (__FnPtr<void ()>*) num4.ToPointer();
            uint num5 = *__pexit_list_size;
            uint num6 = 512U >= num5 ? num5 : 512U;
            *__pexit_list_size = num5 + num6;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num7 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num7.ToPointer() - (IntPtr) local2 + (IntPtr) local3);
            local2 = (__FnPtr<void ()>*) num7.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num8 = (int) *numPtr + 4;
            *numPtr = (uint) num8;
          }
        }
        *(int*) local3 = (int) func;
        __FnPtr<void ()>* local5 = (__FnPtr<void ()>*) ((IntPtr) local3 + 4);
        local1 = func;
        *(int*) __ponexitbegin_e = (int) \u003CModule\u003E._encode_pointer((void*) local2);
        *(int*) __ponexitend_e = (int) \u003CModule\u003E._encode_pointer((void*) local5);
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__exit_list_size == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitend_m);
    if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
            if (local2 < local1)
              goto label_7;
          }
          while ((IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
          *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__dealloc_global_lock();
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
    \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitend_m = \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__exit_list_size = 32U;
    return 1;
  }

  internal static unsafe int _atexit_m(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__exit_list_size, &\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitend_m, &\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__onexitbegin_m);

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0xc4f9df4a\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
          }
          while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
            *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_12;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_12:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0xc4f9df4a\u002E__dealloc_global_lock();
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0x978cd4c1\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(int*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0x978cd4c1\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [STAThread]
  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern uint _wWinMainCRTStartup();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void DeleteCriticalSection([In] _RTL_CRITICAL_SECTION* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void HWSW\u002Ecompile_me_out([In] sbyte* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void HWSW\u002ELogEvent\u002ELog(
    [In] LogEvent* obj0,
    [In] sbyte* obj1,
    [In] sbyte* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void HWSW\u002ELogEvent\u002ELog(
    [In] LogEvent* obj0,
    [In] sbyte* obj1,
    [In] char* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int RegOpenKeyExW(
    [In] HKEY__* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] HKEY__** obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int RegCloseKey([In] HKEY__* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int MessageBoxW([In] HWND__* obj0, [In] char* obj1, [In] char* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int LoadStringW([In] HINSTANCE__* obj0, [In] uint obj1, [In] char* obj2, [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* LoadLibraryW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void CoUninitialize();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void ShutdownLoggingModule();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool LifeCam\u002ESetupRebootRequestInfo\u002ESystemHasNotRebootedSinceSetupRebootRequest(
    [In] SetupRebootRequestInfo* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CloseHandle([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int PostMessageW([In] HWND__* obj0, [In] uint obj1, [In] uint obj2, [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint RegisterWindowMessageW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HWND__* FindWindowW([In] char* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateEventW(
    [In] _SECURITY_ATTRIBUTES* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern int InitializeLoggingModule();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoInitializeEx([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint _set_abort_behavior([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int HeapSetInformation(
    [In] void* obj0,
    [In] _HEAP_INFORMATION_CLASS obj1,
    [In] void* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* new\u005B\u005D([In] uint obj0, [In] nothrow_t* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void GetLocalTime([In] _SYSTEMTIME* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetCurrentProcessId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetCurrentThreadId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] exception* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.ThisCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    [In] Exception obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    [In] EventHandler obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    [In] __FnPtr<int (void*)> obj0,
    [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _decode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encoded_null();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void terminate();
}
