// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.FastZip
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using ICSharpCode.SharpZipLib.Core;
using System;
using System.Collections;
using System.IO;

namespace ICSharpCode.SharpZipLib.Zip
{
  public class FastZip
  {
    private bool \uE010;
    private byte[] \uE00F;
    private ZipOutputStream \uE00E;
    private ZipFile \uE00D;
    private string \uE00C;
    private NameFilter \uE00B;
    private NameFilter \uE00A;
    private FastZip.Overwrite \uE009;
    private FastZip.ConfirmOverwriteDelegate \uE008;
    private bool \uE007;
    private bool \uE006;
    private bool \uE005;
    private FastZipEvents \uE004;
    private IEntryFactory \uE003 = (IEntryFactory) new ZipEntryFactory();
    private INameTransform \uE002;
    private UseZip64 \uE001 = UseZip64.Dynamic;
    private string \uE000;

    public FastZip()
    {
    }

    public FastZip(FastZipEvents events) => this.\uE004 = events;

    public bool CreateEmptyDirectories
    {
      get => this.\uE005;
      set => this.\uE005 = value;
    }

    public string Password
    {
      get => this.\uE000;
      set => this.\uE000 = value;
    }

    public INameTransform NameTransform
    {
      get => this.\uE003.NameTransform;
      set => this.\uE003.NameTransform = value;
    }

    public IEntryFactory EntryFactory
    {
      get => this.\uE003;
      set
      {
        if (value == null)
          this.\uE003 = (IEntryFactory) new ZipEntryFactory();
        else
          this.\uE003 = value;
      }
    }

    public UseZip64 UseZip64
    {
      get => this.\uE001;
      set => this.\uE001 = value;
    }

    public bool RestoreDateTimeOnExtract
    {
      get => this.\uE007;
      set => this.\uE007 = value;
    }

    public bool RestoreAttributesOnExtract
    {
      get => this.\uE006;
      set => this.\uE006 = value;
    }

    public void CreateZip(
      string zipFileName,
      string sourceDirectory,
      bool recurse,
      string fileFilter,
      string directoryFilter)
    {
      this.CreateZip((Stream) File.Create(zipFileName), sourceDirectory, recurse, fileFilter, directoryFilter);
    }

    public void CreateZip(
      string zipFileName,
      string sourceDirectory,
      bool recurse,
      string fileFilter)
    {
      this.CreateZip((Stream) File.Create(zipFileName), sourceDirectory, recurse, fileFilter, (string) null);
    }

    public void CreateZip(
      Stream outputStream,
      string sourceDirectory,
      bool recurse,
      string fileFilter,
      string directoryFilter)
    {
      this.NameTransform = (INameTransform) new ZipNameTransform(sourceDirectory);
      this.\uE00C = sourceDirectory;
      using (this.\uE00E = new ZipOutputStream(outputStream))
      {
        if (this.\uE000 != null)
          this.\uE00E.Password = this.\uE000;
        this.\uE00E.UseZip64 = this.UseZip64;
        FileSystemScanner fileSystemScanner = new FileSystemScanner(fileFilter, directoryFilter);
        fileSystemScanner.ProcessFile += new ProcessFileHandler(this.\uE000);
        if (this.CreateEmptyDirectories)
          fileSystemScanner.ProcessDirectory += new ProcessDirectoryHandler(this.\uE000);
        if (this.\uE004 != null)
        {
          if (this.\uE004.FileFailure != null)
            fileSystemScanner.FileFailure += this.\uE004.FileFailure;
          if (this.\uE004.DirectoryFailure != null)
            fileSystemScanner.DirectoryFailure += this.\uE004.DirectoryFailure;
        }
        fileSystemScanner.Scan(sourceDirectory, recurse);
      }
    }

    public void ExtractZip(string zipFileName, string targetDirectory, string fileFilter) => this.ExtractZip(zipFileName, targetDirectory, FastZip.Overwrite.Always, (FastZip.ConfirmOverwriteDelegate) null, fileFilter, (string) null, this.\uE007);

    public void ExtractZip(
      string zipFileName,
      string targetDirectory,
      FastZip.Overwrite overwrite,
      FastZip.ConfirmOverwriteDelegate confirmDelegate,
      string fileFilter,
      string directoryFilter,
      bool restoreDateTime)
    {
      if (overwrite == FastZip.Overwrite.Prompt && confirmDelegate == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uE00D\uE001\uE000\uE008\uE007\uE01C\uE003\uE02A\uE00B\uE002\uE00B\uE009\uE00F\uE01A\uE00B", 57454));
      this.\uE010 = true;
      this.\uE009 = overwrite;
      this.\uE008 = confirmDelegate;
      this.\uE002 = (INameTransform) new WindowsNameTransform(targetDirectory);
      this.\uE00B = new NameFilter(fileFilter);
      this.\uE00A = new NameFilter(directoryFilter);
      this.\uE007 = restoreDateTime;
      using (this.\uE00D = new ZipFile(zipFileName))
      {
        if (this.\uE000 != null)
          this.\uE00D.Password = this.\uE000;
        IEnumerator enumerator = this.\uE00D.GetEnumerator();
        while (this.\uE010 && enumerator.MoveNext())
        {
          ZipEntry current = (ZipEntry) enumerator.Current;
          if (current.IsFile)
          {
            if (this.\uE00A.IsMatch(Path.GetDirectoryName(current.Name)) && this.\uE00B.IsMatch(current.Name))
              this.\uE000(current);
          }
          else if (current.IsDirectory && this.\uE00A.IsMatch(current.Name) && this.CreateEmptyDirectories)
            this.\uE000(current);
        }
      }
    }

    private void \uE000(object _param1, DirectoryEventArgs _param2)
    {
      if (_param2.HasMatchingFiles || !this.CreateEmptyDirectories)
        return;
      if (this.\uE004 != null)
        this.\uE004.OnProcessDirectory(_param2.Name, _param2.HasMatchingFiles);
      if (!_param2.ContinueRunning || !(_param2.Name != this.\uE00C))
        return;
      this.\uE00E.PutNextEntry(this.\uE003.MakeDirectoryEntry(_param2.Name));
    }

    private void \uE000(object _param1, ScanEventArgs _param2)
    {
      if (this.\uE004 != null && this.\uE004.ProcessFile != null)
        this.\uE004.ProcessFile(_param1, _param2);
      if (!_param2.ContinueRunning)
        return;
      using (FileStream fileStream = File.OpenRead(_param2.Name))
      {
        this.\uE00E.PutNextEntry(this.\uE003.MakeFileEntry(_param2.Name));
        this.\uE000(_param2.Name, (Stream) fileStream);
      }
    }

    private void \uE000(string _param1, Stream _param2)
    {
      if (_param2 == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uE71E\uE719\uE71F\uE708\uE70C\uE700", 59245));
      if (this.\uE00F == null)
        this.\uE00F = new byte[4096];
      if (this.\uE004 != null && this.\uE004.Progress != null)
        StreamUtils.Copy(_param2, (Stream) this.\uE00E, this.\uE00F, this.\uE004.Progress, this.\uE004.ProgressInterval, (object) this, _param1);
      else
        StreamUtils.Copy(_param2, (Stream) this.\uE00E, this.\uE00F);
      if (this.\uE004 == null)
        return;
      this.\uE010 = this.\uE004.OnCompletedFile(_param1);
    }

    private void \uE000(ZipEntry _param1, string _param2)
    {
      bool flag = true;
      if (this.\uE009 != FastZip.Overwrite.Always && File.Exists(_param2))
        flag = this.\uE009 == FastZip.Overwrite.Prompt && this.\uE008 != null && this.\uE008(_param2);
      if (!flag)
        return;
      if (this.\uE004 != null)
        this.\uE010 = this.\uE004.OnProcessFile(_param1.Name);
      if (!this.\uE010)
        return;
      try
      {
        using (FileStream destination = File.Create(_param2))
        {
          if (this.\uE00F == null)
            this.\uE00F = new byte[4096];
          if (this.\uE004 != null && this.\uE004.Progress != null)
            StreamUtils.Copy(this.\uE00D.GetInputStream(_param1), (Stream) destination, this.\uE00F, this.\uE004.Progress, this.\uE004.ProgressInterval, (object) this, _param1.Name, _param1.Size);
          else
            StreamUtils.Copy(this.\uE00D.GetInputStream(_param1), (Stream) destination, this.\uE00F);
          if (this.\uE004 != null)
            this.\uE010 = this.\uE004.OnCompletedFile(_param1.Name);
        }
        if (this.\uE007)
          File.SetLastWriteTime(_param2, _param1.DateTime);
        if (!this.RestoreAttributesOnExtract || !_param1.IsDOSEntry || _param1.ExternalFileAttributes == -1)
          return;
        FileAttributes fileAttributes = (FileAttributes) (_param1.ExternalFileAttributes & 163);
        File.SetAttributes(_param2, fileAttributes);
      }
      catch (Exception ex)
      {
        if (this.\uE004 != null)
        {
          this.\uE010 = this.\uE004.OnFileFailure(_param2, ex);
        }
        else
        {
          this.\uE010 = false;
          throw;
        }
      }
    }

    private void \uE000(ZipEntry _param1)
    {
      bool flag = _param1.IsCompressionMethodSupported();
      string str = _param1.Name;
      if (flag)
      {
        if (_param1.IsFile)
          str = this.\uE002.TransformFile(str);
        else if (_param1.IsDirectory)
          str = this.\uE002.TransformDirectory(str);
        flag = str != null && str.Length != 0;
      }
      string path = (string) null;
      if (flag)
        path = !_param1.IsDirectory ? Path.GetDirectoryName(Path.GetFullPath(str)) : str;
      if (flag && !Directory.Exists(path))
      {
        if (_param1.IsDirectory)
        {
          if (!this.CreateEmptyDirectories)
            goto label_16;
        }
        try
        {
          Directory.CreateDirectory(path);
        }
        catch (Exception ex)
        {
          flag = false;
          if (this.\uE004 != null)
          {
            this.\uE010 = !_param1.IsDirectory ? this.\uE004.OnFileFailure(str, ex) : this.\uE004.OnDirectoryFailure(str, ex);
          }
          else
          {
            this.\uE010 = false;
            throw;
          }
        }
      }
label_16:
      if (!flag || !_param1.IsFile)
        return;
      this.\uE000(_param1, str);
    }

    private static int \uE000(FileInfo _param0) => (int) _param0.Attributes;

    private static bool \uE000(string _param0)
    {
      switch (_param0)
      {
        case null:
          return false;
        default:
          if (_param0.Length > 0)
            return _param0.IndexOfAny(Path.GetInvalidPathChars()) < 0;
          goto case null;
      }
    }

    public enum Overwrite
    {
      Prompt,
      Never,
      Always,
    }

    public delegate bool ConfirmOverwriteDelegate(string fileName);
  }
}
