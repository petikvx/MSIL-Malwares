// Decompiled with JetBrains decompiler
// Type: Aura.Protection.Arithmetic.Arithmetic
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using Aura.Protection.Arithmetic.Functions;
using Aura.Protection.Arithmetic.Functions.Maths;
using Aura.Protection.Arithmetic.Utils;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Reflection;

namespace Aura.Protection.Arithmetic
{
  public class Arithmetic
  {
    public static ModuleDef moduleDef1;
    public static List<iFunction> Tasks = new List<iFunction>()
    {
      (iFunction) new Add(),
      (iFunction) new Sub(),
      (iFunction) new Div(),
      (iFunction) new Mul(),
      (iFunction) new Xor(),
      (iFunction) new Abs(),
      (iFunction) new Log(),
      (iFunction) new Log10(),
      (iFunction) new Sin(),
      (iFunction) new Cos(),
      (iFunction) new Floor(),
      (iFunction) new Round(),
      (iFunction) new Tan(),
      (iFunction) new Tanh(),
      (iFunction) new Sqrt(),
      (iFunction) new Ceiling(),
      (iFunction) new Truncate()
    };

    public static void Execute(ModuleDef moduleDef)
    {
      Aura.Protection.Arithmetic.Arithmetic.moduleDef1 = moduleDef;
      Aura.Protection.Arithmetic.Generator.Generator generator = new Aura.Protection.Arithmetic.Generator.Generator();
      foreach (TypeDef type in (IEnumerable<TypeDef>) moduleDef.Types)
      {
        foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
        {
          if (method.HasBody && !method.DeclaringType.IsGlobalModuleType)
          {
            for (int index = 0; index < ((ICollection<Instruction>) method.Body.Instructions).Count; ++index)
            {
              if (ArithmeticUtils.CheckArithmetic(method.Body.Instructions[index]))
              {
                if (method.Body.Instructions[index].GetLdcI4Value() < 0)
                {
                  List<Instruction> body = Aura.Protection.Arithmetic.Arithmetic.GenerateBody(Aura.Protection.Arithmetic.Arithmetic.Tasks[generator.Next(5)].Arithmetic(method.Body.Instructions[index], moduleDef));
                  if (body != null)
                  {
                    method.Body.Instructions[index].OpCode = OpCodes.Nop;
                    foreach (Instruction instruction in body)
                    {
                      method.Body.Instructions.Insert(index + 1, instruction);
                      ++index;
                    }
                  }
                }
                else
                {
                  List<Instruction> body = Aura.Protection.Arithmetic.Arithmetic.GenerateBody(Aura.Protection.Arithmetic.Arithmetic.Tasks[generator.Next(Aura.Protection.Arithmetic.Arithmetic.Tasks.Count)].Arithmetic(method.Body.Instructions[index], moduleDef));
                  if (body != null)
                  {
                    method.Body.Instructions[index].OpCode = OpCodes.Nop;
                    foreach (Instruction instruction in body)
                    {
                      method.Body.Instructions.Insert(index + 1, instruction);
                      ++index;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    private static List<Instruction> GenerateBody(ArithmeticVT arithmeticVTs)
    {
      List<Instruction> body = new List<Instruction>();
      if (Aura.Protection.Arithmetic.Arithmetic.IsArithmetic(arithmeticVTs.GetArithmetic()))
      {
        body.Add(new Instruction(OpCodes.Ldc_R8, (object) arithmeticVTs.GetValue().GetX()));
        body.Add(new Instruction(OpCodes.Ldc_R8, (object) arithmeticVTs.GetValue().GetY()));
        if (arithmeticVTs.GetToken().GetOperand() != null)
          body.Add(new Instruction(OpCodes.Call, arithmeticVTs.GetToken().GetOperand()));
        body.Add(new Instruction(arithmeticVTs.GetToken().GetOpCode()));
        body.Add(new Instruction(OpCodes.Call, (object) Aura.Protection.Arithmetic.Arithmetic.moduleDef1.Import((MethodBase) typeof (Convert).GetMethod("ToInt32", new Type[1]
        {
          typeof (double)
        }))));
      }
      else if (Aura.Protection.Arithmetic.Arithmetic.IsXor(arithmeticVTs.GetArithmetic()))
      {
        body.Add(new Instruction(OpCodes.Ldc_I4, (object) (int) arithmeticVTs.GetValue().GetX()));
        body.Add(new Instruction(OpCodes.Ldc_I4, (object) (int) arithmeticVTs.GetValue().GetY()));
        body.Add(new Instruction(arithmeticVTs.GetToken().GetOpCode()));
        body.Add(new Instruction(OpCodes.Conv_I4));
      }
      return body;
    }

    private static bool IsArithmetic(ArithmeticTypes arithmetic) => arithmetic == ArithmeticTypes.Add || arithmetic == ArithmeticTypes.Sub || arithmetic == ArithmeticTypes.Div || arithmetic == ArithmeticTypes.Mul || arithmetic == ArithmeticTypes.Abs || arithmetic == ArithmeticTypes.Log || arithmetic == ArithmeticTypes.Log10 || arithmetic == ArithmeticTypes.Truncate || arithmetic == ArithmeticTypes.Sin || arithmetic == ArithmeticTypes.Cos || arithmetic == ArithmeticTypes.Floor || arithmetic == ArithmeticTypes.Round || arithmetic == ArithmeticTypes.Tan || arithmetic == ArithmeticTypes.Tanh || arithmetic == ArithmeticTypes.Sqrt || arithmetic == ArithmeticTypes.Ceiling;

    private static bool IsXor(ArithmeticTypes arithmetic) => arithmetic == ArithmeticTypes.Xor;
  }
}
