// Decompiled with JetBrains decompiler
// Type: Diploma.methods.RungeKutta
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using Diploma.entity;
using System;

namespace Diploma.methods
{
  internal class RungeKutta
  {
    private static double h;

    public static Tuple<double, Quaternion> Run(
      PsiTime psitime,
      MainProblem callMain)
    {
      Console.Write("\n\t\t\t  ~~~ МЕТОД РУНГЕ КУТТЫ ПРИ ");
      RungeKutta.h = psitime.T / (double) callMain.N;
      Console.WriteLine(psitime.ToString() ?? "");
      Console.Write("\t\t\t  ~~~ n={0} h={1} ", (object) callMain.N, (object) RungeKutta.h);
      Quaternion quaternion1 = callMain.Lambda0;
      Quaternion quaternion2 = new Quaternion(psitime.psi);
      Quaternion quaternion3 = new Quaternion();
      for (int k = 0; k < callMain.N; ++k)
      {
        quaternion3[0] = 0.0;
        double num1 = 0.5 * (0.0 - quaternion2[0] * quaternion1[1] + quaternion2[1] * quaternion1[0] + quaternion2[2] * quaternion1[3] - quaternion2[3] * quaternion1[2]);
        quaternion3[1] = num1 >= 0.0 ? callMain.OmegaMax : callMain.OmegaMin;
        double num2 = 0.5 * (0.0 - quaternion2[0] * quaternion1[2] + quaternion2[2] * quaternion1[0] + quaternion2[3] * quaternion1[1] - quaternion2[1] * quaternion1[3]);
        quaternion3[2] = num2 >= 0.0 ? callMain.OmegaMax : callMain.OmegaMin;
        double num3 = 0.5 * (0.0 - quaternion2[0] * quaternion1[3] + quaternion2[1] * quaternion1[2] + quaternion2[3] * quaternion1[0] - quaternion2[2] * quaternion1[1]);
        quaternion3[3] = num3 >= 0.0 ? callMain.OmegaMax : callMain.OmegaMin;
        Quaternion quaternion4 = RungeKutta.сalcNext(quaternion2, quaternion3, k);
        Quaternion quaternion5 = RungeKutta.сalcNext(quaternion1, quaternion3, k);
        quaternion2 = quaternion4;
        quaternion1 = quaternion5;
      }
      Console.WriteLine("\n\t\t\t  ~~~ РЕЗУЛЬТАТЫ:\n\t\t\t  ~~~ НОРМА ПОСЛЕ: {0} НОРМА ДО: {1}", (object) quaternion1.getMagnitude(), (object) callMain.Lambda0.getMagnitude());
      Console.WriteLine("\t\t\t  ~~~ ПОЛУЧЕНО lambda(T) = {0}\n\t\t\t  ~~~ ЗАДАЧА lambda(T) = {1}", (object) quaternion1.ToString(), (object) callMain.LambdaT.ToString());
      return new Tuple<double, Quaternion>(RungeKutta.Hamiltonian(quaternion2, quaternion3, quaternion1), quaternion1);
    }

    private static Quaternion func(Quaternion x, Quaternion omeg) => 0.5 * (x % omeg);

    private static double Hamiltonian(Quaternion psi, Quaternion omegaopt, Quaternion lambda) => psi / (0.5 * (lambda % omegaopt)) - 1.0;

    private static Quaternion сalcNext(Quaternion x, Quaternion omeg, int k)
    {
      Quaternion quaternion1 = RungeKutta.h * RungeKutta.func(x, omeg);
      Quaternion quaternion2 = RungeKutta.h * RungeKutta.func(x + 0.5 * quaternion1, omeg);
      Quaternion quaternion3 = RungeKutta.h * RungeKutta.func(x + 0.5 * quaternion2, omeg);
      Quaternion quaternion4 = RungeKutta.h * RungeKutta.func(x + quaternion3, omeg);
      return x + 1.0 / 6.0 * (quaternion1 + 2.0 * quaternion2 + 2.0 * quaternion3 + quaternion4);
    }
  }
}
