// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
  public class StreamManipulator
  {
    private byte[] window;
    private int window_start = 0;
    private int window_end = 0;
    private uint buffer = 0;
    private int bits_in_buffer = 0;

    public int PeekBits(int n)
    {
      if (this.bits_in_buffer < n)
      {
        if (this.window_start == this.window_end)
          return -1;
        this.buffer |= (uint) (((int) this.window[this.window_start++] & (int) byte.MaxValue | ((int) this.window[this.window_start++] & (int) byte.MaxValue) << 8) << this.bits_in_buffer);
        this.bits_in_buffer += 16;
      }
      return (int) ((long) this.buffer & (long) ((1 << n) - 1));
    }

    public void DropBits(int n)
    {
      this.buffer >>= n;
      this.bits_in_buffer -= n;
    }

    public int GetBits(int n)
    {
      int bits = this.PeekBits(n);
      if (bits >= 0)
        this.DropBits(n);
      return bits;
    }

    public int AvailableBits => this.bits_in_buffer;

    public int AvailableBytes => this.window_end - this.window_start + (this.bits_in_buffer >> 3);

    public void SkipToByteBoundary()
    {
      this.buffer >>= this.bits_in_buffer & 7;
      this.bits_in_buffer &= -8;
    }

    public bool IsNeedingInput => this.window_start == this.window_end;

    public int CopyBytes(byte[] output, int offset, int length)
    {
      if (length < 0)
        throw new ArgumentOutOfRangeException("length negative");
      if ((this.bits_in_buffer & 7) != 0)
        throw new InvalidOperationException("Bit buffer is not aligned!");
      int num1 = 0;
      while (this.bits_in_buffer > 0 && length > 0)
      {
        output[offset++] = (byte) this.buffer;
        this.buffer >>= 8;
        this.bits_in_buffer -= 8;
        --length;
        ++num1;
      }
      if (length == 0)
        return num1;
      int num2 = this.window_end - this.window_start;
      if (length > num2)
        length = num2;
      Array.Copy((Array) this.window, this.window_start, (Array) output, offset, length);
      this.window_start += length;
      if ((this.window_start - this.window_end & 1) != 0)
      {
        this.buffer = (uint) this.window[this.window_start++] & (uint) byte.MaxValue;
        this.bits_in_buffer = 8;
      }
      return num1 + length;
    }

    public void Reset() => this.buffer = (uint) (this.window_start = this.window_end = this.bits_in_buffer = 0);

    public void SetInput(byte[] buf, int off, int len)
    {
      if (this.window_start < this.window_end)
        throw new InvalidOperationException("Old input was not completely processed");
      int num = off + len;
      if (0 > off || off > num || num > buf.Length)
        throw new ArgumentOutOfRangeException();
      if ((len & 1) != 0)
      {
        this.buffer |= (uint) (((int) buf[off++] & (int) byte.MaxValue) << this.bits_in_buffer);
        this.bits_in_buffer += 8;
      }
      this.window = buf;
      this.window_start = off;
      this.window_end = num;
    }
  }
}
