// Decompiled with JetBrains decompiler
// Type: 
// Assembly: another, Version=4.0.24.1356, Culture=neutral, PublicKeyToken=null
// MVID: ACF91E61-9A67-9F6D-6F49-83C0D7ACC19C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Bsymem.gen-140f30b079e31bbfda2e561f3a3e7af42291a167bdd5d8ebeee3a87bc3cc83e6.exe

using System;
using System.Security.Cryptography;

internal sealed class \uE009 : SymmetricAlgorithm, ICryptoTransform, IDisposable
{
  private Random \uE002;

  public \uE009()
  {
    this.\uE002 = new Random(DateTime.Now.Millisecond);
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.KeySize = 128;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.BlockSize = 128;
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override void GenerateIV()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.IV = buffer;
  }

  public override void GenerateKey()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.Key = buffer;
  }

  public int TransformBlock(
    byte[] _param1,
    int _param2,
    int _param3,
    byte[] _param4,
    int _param5)
  {
    int length1 = this.Key.Length;
    int length2 = this.IV.Length;
    for (int index = 0; index < _param3; ++index)
    {
      int num = (int) this.IV[index % length2];
      _param4[index + _param5] = (byte) ((uint) _param1[index + _param2] ^ (uint) this.Key[num % length1]);
    }
    return _param3;
  }

  public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
  {
    byte[] numArray = new byte[_param3];
    this.TransformBlock(_param1, _param2, _param3, numArray, 0);
    return numArray;
  }

  public bool CanReuseTransform => true;

  public bool CanTransformMultipleBlocks => true;

  public int InputBlockSize => 16;

  public int OutputBlockSize => 16;

  internal static int \uE004(int _param0)
  {
    switch (_param0 - (362239554 - 508318249 - -543845796 - 397766903 >> 1))
    {
      case 0:
        return (~-598853502 ^ 683224528) - 185133740;
      case 1:
        return ~711798082 - -711798072;
      case 2:
        return -~--546858482 - 546858484;
      case 4:
        return -(-200229885 - -200229889 << 2) >> 1;
      case 6:
        return --509236460 - 509236472;
      case 7:
        return ~(1338905331 - 713964327) + 521410194 - -103530796;
      case 8:
        return 296431294 - 296431312 >> 1;
      case 10:
        return ~(-444469004 - 70503211) - 71539052 ^ 443433164;
      case 14:
        return (~-929056515 ^ 580538311) - 368707781;
      case 15:
        return ~-216607137 ^ 216607167;
      case 17:
        return -7;
      default:
        return (-19242803 ^ 380547615) - -394997037;
    }
  }
}
