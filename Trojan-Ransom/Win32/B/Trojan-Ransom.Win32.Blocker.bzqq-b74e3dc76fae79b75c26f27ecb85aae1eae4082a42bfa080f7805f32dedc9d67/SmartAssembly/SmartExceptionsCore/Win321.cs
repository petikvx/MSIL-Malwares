// Decompiled with JetBrains decompiler
// Type: SmartAssembly.SmartExceptionsCore.Win321
// Assembly: o4tdggb3, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FA0844EB-EF82-404C-B76C-C092ABDB9392
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.bzqq-b74e3dc76fae79b75c26f27ecb85aae1eae4082a42bfa080f7805f32dedc9d67.exe

using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace SmartAssembly.SmartExceptionsCore
{
  public class Win321
  {
    private const int DT_WORDBREAK = 16;
    private const int DT_CALCRECT = 1024;
    private const int DT_NOPREFIX = 2048;
    private const int VER_NT_WORKSTATION = 1;
    private const int SM_SERVERR2 = 89;
    private const int PROCESSOR_ARCHITECTURE_AMD64 = 9;
    private static bool s_ReadVersionInfo;
    private static Win321.OSVERSIONINFO s_VersionInfo;

    [DllImport("shell32")]
    private static extern int ExtractIconEx(
      string lpszFile,
      int nIconIndex,
      ref int phiconLarge,
      ref int phiconSmall,
      int nIcons);

    [DllImport("user32", CharSet = CharSet.Unicode)]
    private static extern int DrawText(
      IntPtr hDC,
      string text,
      int textLength,
      ref Win321.RECT lpRect,
      int format);

    [DllImport("gdi32.dll")]
    private static extern IntPtr SelectObject(IntPtr hDC, IntPtr hGdiObj);

    [DllImport("kernel32.Dll")]
    private static extern short GetVersionEx(ref Win321.OSVERSIONINFO o);

    [DllImport("user32.dll")]
    private static extern int GetSystemMetrics(int smIndex);

    [DllImport("kernel32.dll")]
    private static extern void GetSystemInfo(ref Win321.SYSTEM_INFO lpSystemInfo);

    private static Win321.OSVERSIONINFO VersionInfo
    {
      get
      {
        if (!Win321.s_ReadVersionInfo)
        {
          Win321.s_VersionInfo = new Win321.OSVERSIONINFO();
          try
          {
            Win321.s_VersionInfo.dwOSVersionInfoSize = Marshal.SizeOf(typeof (Win321.OSVERSIONINFO));
            int versionEx = (int) Win321.GetVersionEx(ref Win321.s_VersionInfo);
            Win321.s_ReadVersionInfo = true;
          }
          catch
          {
          }
        }
        return Win321.s_VersionInfo;
      }
    }

    internal static bool IsX64
    {
      get
      {
        try
        {
          Win321.SYSTEM_INFO lpSystemInfo = new Win321.SYSTEM_INFO();
          Win321.GetSystemInfo(ref lpSystemInfo);
          return lpSystemInfo.wProcessorArchitecture == (ushort) 9;
        }
        catch
        {
          return false;
        }
      }
    }

    internal static bool IsServerR2
    {
      get
      {
        try
        {
          return Win321.GetSystemMetrics(89) != 0;
        }
        catch
        {
          return false;
        }
      }
    }

    internal static bool IsWorkstation => Win321.VersionInfo.wProductType == (byte) 1;

    internal static string ServicePack => Win321.VersionInfo.szCSDVersion;

    public static Icon GetApplicationIcon()
    {
      try
      {
        return Win321.GetApplicationIconInternal();
      }
      catch (Exception ex)
      {
        return Resources.GetIcon("default");
      }
    }

    private static Icon GetApplicationIconInternal()
    {
      int phiconLarge = 0;
      int num = 0;
      if (Win321.ExtractIconEx(Application.ExecutablePath, -1, ref num, ref num, 1) > 0)
      {
        Win321.ExtractIconEx(Application.ExecutablePath, 0, ref phiconLarge, ref num, 1);
        if (phiconLarge != 0)
          return Icon.FromHandle(new IntPtr(phiconLarge));
      }
      return (Icon) null;
    }

    internal static int GetTextHeight(Graphics graphics, string text, Font font, int width)
    {
      try
      {
        return Win321.GetTextHeightGDIInternal(graphics, text, font, width);
      }
      catch (Exception ex1)
      {
        try
        {
          return Convert.ToInt32((double) Win321.GetTextHeightGDIPlusInternal(graphics, text, font, width) * 1.1);
        }
        catch (Exception ex2)
        {
        }
      }
      return 0;
    }

    private static int GetTextHeightGDIPlusInternal(
      Graphics graphics,
      string text,
      Font font,
      int width)
    {
      return Size.Ceiling(graphics.MeasureString(text, font, width)).Height;
    }

    private static int GetTextHeightGDIInternal(
      Graphics graphics,
      string text,
      Font font,
      int width)
    {
      Win321.RECT lpRect = new Win321.RECT(new Rectangle(0, 0, width, 10000));
      int format = 3088;
      IntPtr hdc = graphics.GetHdc();
      IntPtr hfont = font.ToHfont();
      IntPtr hGdiObj = Win321.SelectObject(hdc, hfont);
      Win321.DrawText(hdc, text, -1, ref lpRect, format);
      Win321.SelectObject(hdc, hGdiObj);
      graphics.ReleaseHdc(hdc);
      return lpRect.Bottom - lpRect.Top;
    }

    private struct RECT
    {
      public int Left;
      public int Top;
      public int Right;
      public int Bottom;

      public RECT(Rectangle rectangle)
      {
        this.Left = rectangle.Left;
        this.Top = rectangle.Top;
        this.Bottom = rectangle.Bottom;
        this.Right = rectangle.Right;
      }
    }

    private struct OSVERSIONINFO
    {
      public int dwOSVersionInfoSize;
      public uint dwMajorVersion;
      public uint dwMinorVersion;
      public uint dwBuildNumber;
      public uint dwPlatformId;
      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 128)]
      public string szCSDVersion;
      public ushort wServicePackMajor;
      public ushort wServicePackMinor;
      public ushort wSuiteMask;
      public byte wProductType;
      private byte wReserved;
    }

    public struct SYSTEM_INFO
    {
      public ushort wProcessorArchitecture;
      private ushort wReserved;
      public uint dwPageSize;
      public IntPtr lpMinimumApplicationAddress;
      public IntPtr lpMaximumApplicationAddress;
      public IntPtr dwActiveProcessorMask;
      public uint dwNumberOfProcessors;
      public uint dwProcessorType;
      public uint dwAllocationGranularity;
      public ushort wProcessorLevel;
      public ushort wProcessorRevision;
    }
  }
}
