// Decompiled with JetBrains decompiler
// Type: ⁮‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮
// Assembly: ReadLineS0SAT, Version=2.0.8.1, Culture=neutral, PublicKeyToken=null
// MVID: 826822DE-6F21-4D67-9238-0DAF50EB618B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-9ec8f988ff41765b68c6a4d29d259fafb62e97ad2d3633c43fbe0ab0dd12518d.exe

using System;
using System.Globalization;

public class \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮
{
  public static bool \u200B‎​‮⁭‮‍⁬‎‫‬‌⁪‫​‭‍⁯‭‪‭⁬‍⁬‭⁪‬⁮‬‎‏‮‫⁭‭‎‍⁬⁭⁬‮(string _param0) => \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u200C‍‫​⁯​‪⁮⁯⁬‎‏‫‭‮‬‎⁮⁪⁪‮‮‏‭⁯‮⁫‫‌‭⁬‭‍​​‏​‏‏⁯‮(_param0) || \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u202E⁫⁬‫⁭⁫‫​‍‍‏⁬‪‮‭‎⁫‍‭‌⁪⁪‎⁯⁪‪‮⁮‪⁪‌‎⁬​‏⁭⁫⁮‬‏‮(_param0);

  public static bool \u206E⁬⁮⁬‭‌⁪‭‭‫⁫‍‎‎‫‌‬⁫​‎‭⁫‭‏‬‭‎‭‬‫‍⁯‌‪​⁪​‎⁮‫‮(string _param0) => \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u206E⁫‮‬⁬‎⁯‬‏‌‌‫⁭⁭⁭‏⁪⁯​‫‬‫‌⁭‬⁬⁫⁯⁪‪⁯‭‌‎⁮‬‌‮‮‭‮(_param0) || \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u200C⁬⁭​‫‫⁪‍‌⁭‏⁭⁬‎‍⁫‏‌‍⁫‫‬‬‭‏‪‌‫‏‭‪‍⁯‬⁮⁯‭‮⁬⁫‮(_param0);

  public static bool \u200C‍‫​⁯​‪⁮⁯⁬‎‏‫‭‮‬‎⁮⁪⁪‮‮‏‭⁯‮⁫‫‌‭⁬‭‍​​‏​‏‏⁯‮(string _param0)
  {
    try
    {
      return \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u202A⁬⁬‏⁫‬⁬⁫‏⁭‌⁫‌⁭‪‮‍​‍‮‏‎‏⁯⁯⁫‫‭‬‭⁪‭⁮⁭⁪‏⁫‏⁪‬‮(_param0);
    }
    catch (FormatException ex)
    {
    }
    catch (OverflowException ex)
    {
    }
    return false;
  }

  private static bool \u202A⁬⁬‏⁫‬⁬⁫‏⁭‌⁫‌⁭‪‮‍​‍‮‏‎‏⁯⁯⁫‫‭‬‭⁪‭⁮⁭⁪‏⁫‏⁪‬‮(string _param0)
  {
    if (_param0.Length == 0)
      return false;
    int num1 = 0;
    string str = _param0 + ".";
    int startIndex = 0;
    int num2;
    while (startIndex < str.Length && (num2 = str.IndexOf('.', startIndex)) > startIndex)
    {
      if (num1 == 4)
        return false;
      int num3 = int.Parse(str.Substring(startIndex, num2 - startIndex));
      if (num3 < 0 || num3 > (int) byte.MaxValue)
        return false;
      startIndex = num2 + 1;
      ++num1;
    }
    return num1 == 4;
  }

  public static bool \u206E⁫‮‬⁬‎⁯‬‏‌‌‫⁭⁭⁭‏⁪⁯​‫‬‫‌⁭‬⁬⁫⁯⁪‪⁯‭‌‎⁮‬‌‮‮‭‮(string _param0)
  {
    int length = _param0.IndexOf('/');
    string str = _param0.Substring(length + 1);
    if (length <= 0 || !\u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u200C‍‫​⁯​‪⁮⁯⁬‎‏‫‭‮‬‎⁮⁪⁪‮‮‏‭⁯‮⁫‫‌‭⁬‭‍​​‏​‏‏⁯‮(_param0.Substring(0, length)))
      return false;
    return \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u200C‍‫​⁯​‪⁮⁯⁬‎‏‫‭‮‬‎⁮⁪⁪‮‮‏‭⁯‮⁫‫‌‭⁬‭‍​​‏​‏‏⁯‮(str) || \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u206F⁫⁬⁭‭‍‬⁫‮‬‎‫‌⁪‫‏‮‏⁬⁭‪⁯‌⁪‮‭⁪⁬‏⁯⁬⁫⁬⁬‍⁮‎‍‎‬‮(str, 32);
  }

  public static bool \u200C⁬⁭​‫‫⁪‍‌⁭‏⁭⁬‎‍⁫‏‌‍⁫‫‬‬‭‏‪‌‫‏‭‪‍⁯‬⁮⁯‭‮⁬⁫‮(string _param0)
  {
    int length = _param0.IndexOf('/');
    string str = _param0.Substring(length + 1);
    if (length <= 0 || !\u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u202E⁫⁬‫⁭⁫‫​‍‍‏⁬‪‮‭‎⁫‍‭‌⁪⁪‎⁯⁪‪‮⁮‪⁪‌‎⁬​‏⁭⁫⁮‬‏‮(_param0.Substring(0, length)))
      return false;
    return \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u202E⁫⁬‫⁭⁫‫​‍‍‏⁬‪‮‭‎⁫‍‭‌⁪⁪‎⁯⁪‪‮⁮‪⁪‌‎⁬​‏⁭⁫⁮‬‏‮(str) || \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u206F⁫⁬⁭‭‍‬⁫‮‬‎‫‌⁪‫‏‮‏⁬⁭‪⁯‌⁪‮‭⁪⁬‏⁯⁬⁫⁬⁬‍⁮‎‍‎‬‮(str, 128);
  }

  private static bool \u206F⁫⁬⁭‭‍‬⁫‮‬‎‫‌⁪‫‏‮‏⁬⁭‪⁯‌⁪‮‭⁪⁬‏⁯⁬⁫⁬⁬‍⁮‎‍‎‬‮(string _param0, int _param1)
  {
    int num = int.Parse(_param0);
    try
    {
      return num >= 0 && num <= _param1;
    }
    catch (FormatException ex)
    {
    }
    catch (OverflowException ex)
    {
    }
    return false;
  }

  public static bool \u202E⁫⁬‫⁭⁫‫​‍‍‏⁬‪‮‭‎⁫‍‭‌⁪⁪‎⁯⁪‪‮⁮‪⁪‌‎⁬​‏⁭⁫⁮‬‏‮(string _param0)
  {
    try
    {
      return \u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u202B‍⁫⁮⁮‌‬⁭​⁮‍‫‏‫‪‎‎⁯⁯‬⁯⁯‬​⁯⁪‬⁮‬‪‏‭‬‬‌⁭‍‫⁪‎‮(_param0);
    }
    catch (FormatException ex)
    {
    }
    catch (OverflowException ex)
    {
    }
    return false;
  }

  private static bool \u202B‍⁫⁮⁮‌‬⁭​⁮‍‫‏‫‪‎‎⁯⁯‬⁯⁯‬​⁯⁪‬⁮‬‪‏‭‬‬‌⁭‍‫⁪‎‮(string _param0)
  {
    if (_param0.Length == 0)
      return false;
    int num1 = 0;
    string str1 = _param0 + ":";
    bool flag = false;
    int startIndex = 0;
    int num2;
    while (startIndex < str1.Length && (num2 = str1.IndexOf(':', startIndex)) >= startIndex)
    {
      if (num1 == 8)
        return false;
      if (startIndex != num2)
      {
        string str2 = str1.Substring(startIndex, num2 - startIndex);
        if (num2 == str1.Length - 1 && str2.IndexOf('.') > 0)
        {
          if (!\u206E‏‭⁬‮‭‪‪⁭⁭‏⁮⁪​⁯⁭​‎‏‏⁪⁮‭‎‫‫⁮‪⁭‪‭⁭​‮⁮⁪‮‭⁯‪‮.\u200C‍‫​⁯​‪⁮⁯⁬‎‏‫‭‮‬‎⁮⁪⁪‮‮‏‭⁯‮⁫‫‌‭⁬‭‍​​‏​‏‏⁯‮(str2))
            return false;
          ++num1;
        }
        else
        {
          int num3 = int.Parse(str1.Substring(startIndex, num2 - startIndex), NumberStyles.AllowHexSpecifier);
          if (num3 < 0 || num3 > (int) ushort.MaxValue)
            return false;
        }
      }
      else
      {
        if (((num2 == 1 ? 0 : (num2 != str1.Length - 1 ? 1 : 0)) & (flag ? 1 : 0)) != 0)
          return false;
        flag = true;
      }
      startIndex = num2 + 1;
      ++num1;
    }
    return num1 == 8 | flag;
  }
}
