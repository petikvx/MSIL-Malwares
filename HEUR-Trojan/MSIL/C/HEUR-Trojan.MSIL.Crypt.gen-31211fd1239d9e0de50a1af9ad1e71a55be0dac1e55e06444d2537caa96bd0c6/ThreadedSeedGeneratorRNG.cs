// Decompiled with JetBrains decompiler
// Type: ThreadedSeedGeneratorRNG
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using Org.BouncyCastle.Crypto.Prng;
using System;
using System.Security.Cryptography;
using System.Threading;

public sealed class ThreadedSeedGeneratorRNG : RandomNumberGenerator
{
  private const int TrueInt = 1;
  private const int FalseInt = 0;
  private ThreadedSeedGenerator myThreadedSeedGeneratorRNG = new ThreadedSeedGenerator();
  private object fifoStreamLock = new object();
  private FifoStream myFifoStream = new FifoStream(true);
  private Thread mainThread;
  private AutoResetEvent poolFullARE = new AutoResetEvent(false);
  private int disposed;
  private static ThreadedSeedGeneratorRNG staticThreadSchedulerRNG = new ThreadedSeedGeneratorRNG();

  public int MaxPoolSize { get; private set; }

  public ThreadedSeedGeneratorRNG()
  {
    this.MaxPoolSize = 4096;
    this.mainThread = new Thread(new ThreadStart(this.get_TradeBanStateadd_OnPluginUnloadingSend));
    this.mainThread.IsBackground = true;
    this.mainThread.Start();
  }

  public ThreadedSeedGeneratorRNG(int MaxPoolSize)
  {
    this.MaxPoolSize = MaxPoolSize;
    this.mainThread = new Thread(new ThreadStart(this.get_TradeBanStateadd_OnPluginUnloadingSend));
    this.mainThread.IsBackground = true;
    this.mainThread.Start();
  }

  private int get_PrivacyStateRemovePlayerFromGroupget_MostPlayedGames(
    byte[] buffer,
    int offset,
    int count)
  {
    try
    {
      int num1 = offset;
      lock (this.fifoStreamLock)
      {
        while (num1 < count)
        {
          long count1 = this.myFifoStream.Length;
          if ((long) num1 + count1 >= (long) count)
            count1 = (long) (count - num1);
          if (count1 > 0L)
          {
            int num2 = this.myFifoStream.Read(buffer, num1, (int) count1);
            num1 += num2;
          }
          if (num1 < count)
          {
            byte[] actiongetPermissions = ThreadedSeedGeneratorRNG.staticThreadSchedulerRNG.GetPermissionsRunActionget_Permissions(count - num1);
            Array.Copy((Array) actiongetPermissions, 0, (Array) buffer, num1, actiongetPermissions.Length);
            num1 += actiongetPermissions.Length;
            Array.Clear((Array) actiongetPermissions, 0, actiongetPermissions.Length);
            if (num1 < count)
              Thread.Sleep((count - num1) * 8 / 2);
          }
        }
        return count;
      }
    }
    finally
    {
      this.poolFullARE.Set();
    }
  }

  public byte[] GetPermissionsRunActionget_Permissions(int MaxLength)
  {
    lock (this.fifoStreamLock)
    {
      long length = this.myFifoStream.Length;
      byte[] buffer = length <= (long) MaxLength ? new byte[length] : new byte[MaxLength];
      if (length > 0L)
        this.get_PrivacyStateRemovePlayerFromGroupget_MostPlayedGames(buffer, 0, buffer.Length);
      return buffer;
    }
  }

  public override void GetBytes(byte[] data)
  {
    if (this.get_PrivacyStateRemovePlayerFromGroupget_MostPlayedGames(data, 0, data.Length) != data.Length)
      throw new CryptographicException("Failed to return requested number of bytes");
  }

  public override void GetNonZeroBytes(byte[] data)
  {
    int index1 = 0;
    while (index1 < data.Length)
    {
      byte[] buffer = new byte[data.Length - index1];
      if (this.get_PrivacyStateRemovePlayerFromGroupget_MostPlayedGames(buffer, 0, buffer.Length) != buffer.Length)
        throw new CryptographicException("Failed to return requested number of bytes");
      for (int index2 = 0; index2 < buffer.Length; ++index2)
      {
        if (buffer[index2] != (byte) 0)
        {
          data[index1] = buffer[index2];
          ++index1;
        }
      }
    }
  }

  protected override void Dispose(bool disposing)
  {
    if (Interlocked.Exchange(ref this.disposed, 1) == 1)
      return;
    this.poolFullARE.Set();
    this.poolFullARE.Dispose();
    this.myFifoStream.Dispose();
    base.Dispose(disposing);
  }

  private void get_TradeBanStateadd_OnPluginUnloadingSend()
  {
    try
    {
      int num = this.MaxPoolSize / 8;
      while (this.disposed == 0)
      {
        if (this.myFifoStream.Length < (long) this.MaxPoolSize)
        {
          byte[] seed = this.myThreadedSeedGeneratorRNG.GenerateSeed(num, false);
          this.myFifoStream.Write(seed, 0, seed.Length);
        }
        else
          this.poolFullARE.WaitOne();
      }
    }
    catch
    {
      if (this.disposed != 0)
        return;
      throw;
    }
  }

  ~ThreadedSeedGeneratorRNG() => this.Dispose(false);
}
