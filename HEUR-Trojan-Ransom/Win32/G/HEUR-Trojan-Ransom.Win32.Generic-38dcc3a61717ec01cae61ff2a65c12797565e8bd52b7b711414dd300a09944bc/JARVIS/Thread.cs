// Decompiled with JetBrains decompiler
// Type: JARVIS.Thread
// Assembly: VviXn, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 5A785479-4E75-4C54-4742-516F6E567A62
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\HEUR-Trojan-Ransom.Win32.Generic-38dcc3a61717ec01cae61ff2a65c12797565e8bd52b7b711414dd300a09944bc.exe

using std;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading;

namespace JARVIS
{
  internal class Thread : IDisposable
  {
    private System.Threading.Thread thread;
    private Thread.EntryPoint entryPoint;
    private List<object> arguments;
    private static Thread[] threadsList;

    private Thread(Thread.EntryPoint start, [MarshalAs(UnmanagedType.U1)] bool IsBackground)
    {
      this.entryPoint = start;
      this.arguments = new List<object>();
      System.Threading.Thread thread = new System.Threading.Thread(new ParameterizedThreadStart(this.startFunc));
      this.thread = thread;
      thread.IsBackground = IsBackground;
    }

    private void startFunc(object args) => this.entryPoint((List<object>) args);

    private void \u007EThread()
    {
    }

    public static unsafe Thread create(
      __FnPtr<void (List<object>)> callback,
      [MarshalAs(UnmanagedType.U1)] bool IsBackground)
    {
      if (Thread.threadsList == null)
        Thread.threadsList = new Thread[1000];
      int index = 0;
      if (0 < Thread.threadsList.Length)
      {
        while (Thread.threadsList[index] != null && Thread.threadsList[index].thread.IsAlive)
        {
          ++index;
          if (index >= Thread.threadsList.Length)
            goto label_5;
        }
        goto label_14;
      }
label_5:
      RuntimeException* pThis = (RuntimeException*) \u003CModule\u003E.@new(16U);
      RuntimeException* runtimeExceptionPtr;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) pThis != IntPtr.Zero)
        {
          \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((exception*) pThis);
          // ISSUE: fault handler
          try
          {
            *(int*) pThis = (int) &\u003CModule\u003E.\u003F\u003F_7RuntimeException\u0040JARVIS\u0040\u00406B\u0040;
            *(int*) ((IntPtr) pThis + 12) = (int) &\u003CModule\u003E.\u003F\u003F_C\u0040_0CD\u0040BPKKHFJE\u0040atingiu\u003F5o\u003F5limite\u003F5de\u003F5threads\u003F5ativ\u0040;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) pThis);
          }
          runtimeExceptionPtr = pThis;
        }
        else
          runtimeExceptionPtr = (RuntimeException*) 0;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) pThis);
      }
      \u003CModule\u003E._CxxThrowException((void*) &runtimeExceptionPtr, &\u003CModule\u003E._TI3PAVRuntimeException\u0040JARVIS\u0040\u0040);
label_14:
      Thread.threadsList[index] = new Thread(new Thread.EntryPoint((object) null, (IntPtr) callback), IsBackground);
      return Thread.threadsList[index];
    }

    public static double getThreadInterval()
    {
      double num = Math.Round((double) Thread.length() * 0.5);
      return num < 10.0 ? 10.0 : num;
    }

    public static int length()
    {
      int num = 0;
      int index = 0;
      if (0 < Thread.threadsList.Length)
      {
        do
        {
          if (Thread.threadsList[index] != null && Thread.threadsList[index].thread.IsAlive)
            ++num;
          ++index;
        }
        while (index < Thread.threadsList.Length);
      }
      return num;
    }

    public static int abortAll()
    {
      if (Thread.threadsList == null)
        return 0;
      int num = Thread.length();
      int index = 0;
      if (0 < num)
      {
        do
        {
          if (Thread.threadsList[index] != null)
          {
            Thread threads = Thread.threadsList[index];
            if (threads.thread.IsAlive)
              threads.thread.Abort();
            threads?.Dispose();
          }
          ++index;
        }
        while (index < num);
      }
      return 1;
    }

    public Thread addArgument(object obj)
    {
      this.arguments.Add(obj);
      return this;
    }

    public Thread start()
    {
      this.thread.Start((object) this.arguments);
      return this;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public bool isAlive() => this.thread.IsAlive;

    public void abort()
    {
      if (this.thread.IsAlive)
        this.thread.Abort();
      if (this == null)
        return;
      this.Dispose();
    }

    protected virtual void Dispose([MarshalAs(UnmanagedType.U1)] bool _param1)
    {
      if (_param1)
        return;
      // ISSUE: explicit finalizer call
      this.Finalize();
    }

    public virtual void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private delegate void EntryPoint(List<object> args);
  }
}
