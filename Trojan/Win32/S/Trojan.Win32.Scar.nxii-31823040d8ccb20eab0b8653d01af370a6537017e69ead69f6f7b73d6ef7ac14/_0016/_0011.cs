// Decompiled with JetBrains decompiler
// Type: .
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u0011;
using \u0012;
using \u0013;
using \u0014;
using \u0015;
using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace \u0016
{
  internal sealed class \u0011
  {
    internal static readonly Encoding \u0001;
    internal readonly BinaryWriter \u0001;
    internal byte[] \u0001;
    [NonSerialized]
    internal static GetString \u008A;

    [CompilerGenerated]
    [SpecialName]
    public DateTimeKind \u0001() => this.\u0001;

    internal unsafe void \u0001([In] \u0007 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      \u001A obj1;
      switch (obj0.\u0001())
      {
        case \u0010.\u0011.\u0001:
          \u0008.\u0011 obj2 = (\u0008.\u0011) obj0;
          \u0014\u0006.\u007E\u0013\u000F((object) this.\u0001, \u008B\u0002.\u0002\u0006(obj2.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        case \u0010.\u0011.\u0002:
          \u0004.\u0014 obj3 = (\u0004.\u0014) obj0;
          string str1 = (string) ((\u0008.\u0011) obj3).\u0001;
          *(int*) ((IntPtr) voidPtr + 16) = obj3.\u0002();
          int? nullable1 = new int?(((\u0007) obj3).\u0001() - 4);
          \u0006.\u0001(str1, *(int*) ((IntPtr) voidPtr + 16), nullable1, this);
          return;
        case \u0010.\u0011.\u0003:
          \u0004.\u0013 obj4 = (\u0004.\u0013) obj0;
          \u0018.\u007E\u0097\u0002((object) this.\u0001, ((\u0007) obj4).\u0001());
          IEnumerator<\u0013.\u0008> enumerator1 = obj4.\u0001();
          try
          {
            while (\u0015\u0002.\u007E\u009E\u0004((object) enumerator1))
            {
              \u0013.\u0008 current = enumerator1.Current;
              \u0012\u0006.\u007E\u0011\u000F((object) this.\u0001, (sbyte) current.\u0001().\u0001());
              string str2 = (string) ((\u0008.\u0011) current.\u0001()).\u0001;
              IntPtr num1 = (IntPtr) voidPtr + 16;
              int num2 = current.\u0001().\u0002();
              int? nullable2 = new int?();
              *(int*) num1 = num2;
              \u0006.\u0001(str2, *(int*) ((IntPtr) voidPtr + 16), nullable2, this);
              this.\u0001(current.\u0001());
            }
          }
          finally
          {
            if (enumerator1 != null)
              global::\u0011.\u007E\u0007\u0002((object) enumerator1);
          }
          \u0013\u0006.\u007E\u0012\u000F((object) this.\u0001, (byte) 0);
          return;
        case \u0010.\u0011.\u0004:
          obj1 = (\u001A) obj0;
          \u0018.\u007E\u0097\u0002((object) this.\u0001, ((\u0007) obj1).\u0001());
          *(long*) voidPtr = 0L;
          break;
        case \u0010.\u0011.\u0005:
          \u0019 obj5 = (\u0019) obj0;
          byte[] numArray1 = (byte[]) ((\u0008.\u0011) obj5).\u0001;
          \u0018.\u007E\u0097\u0002((object) this.\u0001, numArray1.Length);
          \u0013\u0006.\u007E\u0012\u000F((object) this.\u0001, (byte) obj5.\u0001());
          if (false)
            return;
          \u0096\u0002.\u007E\u001A\u0006((object) this.\u0001, numArray1);
          return;
        case \u0010.\u0011.\u0006:
          return;
        case \u0010.\u0011.\u0007:
          byte[] numArray2 = (byte[]) ((\u0008.\u0011) obj0).\u0001;
          \u0096\u0002.\u007E\u001A\u0006((object) this.\u0001, numArray2);
          return;
        case \u0010.\u0011.\u0008:
          \u0008.\u0011 obj6 = (\u0008.\u0011) obj0;
          global::\u0012.\u007E\u008A\u0002((object) this.\u0001, (bool) obj6.\u0001);
          return;
        case \u0010.\u0011.\u000E:
          \u0008.\u0011 obj7 = (\u0008.\u0011) obj0;
          *(long*) ((IntPtr) voidPtr + 8) = 0L;
          if (obj7.\u0001 is DateTime)
          {
            DateTime dateTime = (DateTime) obj7.\u0001;
            if (this.\u0001() == DateTimeKind.Utc)
              dateTime = dateTime.ToUniversalTime();
            else if (this.\u0001() == DateTimeKind.Local)
              dateTime = dateTime.ToLocalTime();
            *(long*) ((IntPtr) voidPtr + 8) = \u0006.\u0001(dateTime, false);
          }
          else
          {
            DateTimeOffset dateTimeOffset = (DateTimeOffset) obj7.\u0001;
            if (true)
            {
              DateTime utcDateTime = dateTimeOffset.UtcDateTime;
              TimeSpan offset = dateTimeOffset.Offset;
              *(long*) ((IntPtr) voidPtr + 8) = \u0006.\u0001(offset, utcDateTime);
            }
            else
              break;
          }
          \u009C\u0003.\u007E\u008F\u0007((object) this.\u0001, *(long*) ((IntPtr) voidPtr + 8));
          return;
        case \u0010.\u0011.\u000F:
          return;
        case \u0010.\u0011.\u0010:
          \u000F obj8 = (\u000F) obj0;
          string str3 = (string) ((\u0008.\u0011) obj8.\u0001()).\u0001;
          IntPtr num3 = (IntPtr) voidPtr + 16;
          int num4 = obj8.\u0001().\u0002();
          int? nullable3 = new int?();
          *(int*) num3 = num4;
          \u0006.\u0001(str3, *(int*) ((IntPtr) voidPtr + 16), nullable3, this);
          string str4 = (string) ((\u0008.\u0011) obj8.\u0002()).\u0001;
          IntPtr num5 = (IntPtr) voidPtr + 16;
          int num6 = obj8.\u0002().\u0002();
          int? nullable4 = new int?();
          *(int*) num5 = num6;
          \u0006.\u0001(str4, *(int*) ((IntPtr) voidPtr + 16), nullable4, this);
          return;
        case \u0010.\u0011.\u0015:
          \u0008.\u0011 obj9 = (\u0008.\u0011) obj0;
          \u0018.\u007E\u0097\u0002((object) this.\u0001, \u009A\u0004.\u0094\u0008(obj9.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        case \u0010.\u0011.\u0017:
          \u0008.\u0011 obj10 = (\u0008.\u0011) obj0;
          \u009C\u0003.\u007E\u008F\u0007((object) this.\u0001, \u0082\u0003.\u0014\u0007(obj10.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        default:
          throw new ArgumentOutOfRangeException(\u0016.\u0011.\u008A(8670), \u0002.\u0002.\u0001(\u0016.\u0011.\u008A(8675), (IFormatProvider) \u0098.\u0002\u0004(), (object) obj0.\u0001()));
      }
      IEnumerator<\u0007> enumerator2 = obj1.\u0001();
      try
      {
        while (\u0015\u0002.\u007E\u009E\u0004((object) enumerator2))
        {
          \u0007 current = enumerator2.Current;
          \u0012\u0006.\u007E\u0011\u000F((object) this.\u0001, (sbyte) current.\u0001());
          string str5 = ((ulong*) voidPtr)->ToString((IFormatProvider) \u0098.\u0002\u0004());
          IntPtr num7 = (IntPtr) voidPtr + 16;
          int num8 = \u0006.\u0001((ulong) *(long*) voidPtr);
          int? nullable5 = new int?();
          *(int*) num7 = num8;
          \u0006.\u0001(str5, *(int*) ((IntPtr) voidPtr + 16), nullable5, this);
          this.\u0001(current);
          *(long*) voidPtr = *(long*) voidPtr + 1L;
        }
      }
      finally
      {
        if (enumerator2 != null)
          global::\u0011.\u007E\u0007\u0002((object) enumerator2);
      }
      \u0013\u0006.\u007E\u0012\u000F((object) this.\u0001, (byte) 0);
    }

    static \u0011()
    {
      Strings.CreateGetStringDelegate(typeof (\u0016.\u0011));
      \u0016.\u0011.\u0001 = (Encoding) new UTF8Encoding(false);
    }
  }
}
