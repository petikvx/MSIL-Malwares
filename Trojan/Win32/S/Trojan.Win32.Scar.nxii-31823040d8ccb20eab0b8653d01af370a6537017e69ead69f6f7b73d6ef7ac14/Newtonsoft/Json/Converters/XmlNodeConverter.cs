// Decompiled with JetBrains decompiler
// Type: Newtonsoft.Json.Converters.XmlNodeConverter
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u0002;
using \u000F;
using \u0011;
using \u0012;
using \u0014;
using \u0016;
using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Xml;
using System.Xml.Linq;

namespace Newtonsoft.Json.Converters
{
  public sealed class XmlNodeConverter : \u0005.\u0005
  {
    [NonSerialized]
    internal static GetString \u0019;

    [CompilerGenerated]
    [SpecialName]
    public string \u0001() => this.\u0001;

    [CompilerGenerated]
    [SpecialName]
    public bool \u0003() => this.\u0001;

    [CompilerGenerated]
    [SpecialName]
    public bool \u0004() => this.\u0002;

    public override void \u0001([In] JsonWriter obj0, [In] object obj1, [In] \u0003 obj2)
    {
      IXmlNode xmlNode = \u0006.\u0001(this, obj1);
      XmlNamespaceManager namespaceManager = new XmlNamespaceManager((XmlNameTable) new NameTable());
      this.\u0001(xmlNode, namespaceManager);
      if (!this.\u0004())
        obj0.\u0002();
      \u0006.\u0001(this, obj0, xmlNode, namespaceManager, !this.\u0004());
      do
      {
        if (!this.\u0004())
          obj0.\u0011();
      }
      while (false);
    }

    private void \u0001([In] IXmlNode obj0, [In] XmlNamespaceManager obj1)
    {
      List<IXmlNode> xmlNodeList = (List<IXmlNode>) null;
      IXmlNode xmlNode1 = obj0;
      while ((xmlNode1 = xmlNode1.\u0001()) != null)
      {
        if (xmlNode1.\u0001() == XmlNodeType.Element)
        {
          if (xmlNodeList == null)
            xmlNodeList = new List<IXmlNode>();
          xmlNodeList.Add(xmlNode1);
        }
      }
      if (xmlNodeList == null)
        return;
      xmlNodeList.Reverse();
      foreach (IXmlNode xmlNode2 in xmlNodeList)
      {
        global::\u0011.\u007E\u0015\u0002((object) obj1);
        IEnumerator<IXmlNode> enumerator = xmlNode2.\u0002().GetEnumerator();
        try
        {
          while (\u0015\u0002.\u007E\u009E\u0004((object) enumerator))
          {
            IXmlNode current = enumerator.Current;
            if (\u0007\u0002.\u008C\u0004(current.\u0003(), XmlNodeConverter.\u0019(10139)) && \u0007\u0002.\u008B\u0004(current.\u0001(), XmlNodeConverter.\u0019(10180)))
              \u0017\u0003.\u007E\u0001\u0007((object) obj1, current.\u0001(), current.\u0002());
          }
        }
        finally
        {
          if (enumerator != null)
            global::\u0011.\u007E\u0007\u0002((object) enumerator);
        }
      }
    }

    internal unsafe void \u0001(
      [In] JsonWriter obj0,
      [In] IXmlNode obj1,
      [In] XmlNamespaceManager obj2,
      [In] bool obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
      Dictionary<string, List<IXmlNode>> dictionary = new Dictionary<string, List<IXmlNode>>();
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < obj1.\u0001().Count)
      {
        IXmlNode xmlNode = obj1.\u0001()[*(int*) voidPtr];
        string key = \u0006.\u0001(obj2, xmlNode, this);
        List<IXmlNode> xmlNodeList;
        if (!dictionary.TryGetValue(key, out xmlNodeList))
        {
          xmlNodeList = new List<IXmlNode>();
          dictionary.Add(key, xmlNodeList);
        }
        xmlNodeList.Add(xmlNode);
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      foreach (KeyValuePair<string, List<IXmlNode>> keyValuePair in dictionary)
      {
        List<IXmlNode> xmlNodeList = keyValuePair.Value;
        if (xmlNodeList.Count == 1)
          *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) \u0006.\u0001(this, xmlNodeList[0]);
        else
          *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr + 8) == (sbyte) 0)
        {
          \u0006.\u0001(this, obj0, xmlNodeList[0], obj2, obj3);
        }
        else
        {
          string key = keyValuePair.Key;
          if (obj3)
            obj0.\u0002(key);
          obj0.\u0003();
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          while (*(int*) ((IntPtr) voidPtr + 4) < xmlNodeList.Count)
          {
            \u0006.\u0001(this, obj0, xmlNodeList[*(int*) ((IntPtr) voidPtr + 4)], obj2, false);
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
          }
          obj0.\u000F();
        }
      }
    }

    public override object \u0001([In] \u0007 obj0, [In] Type obj1, [In] object obj2, [In] \u0003 obj3)
    {
      if (obj0.\u0001() == JsonToken.Null)
        return (object) null;
      XmlNamespaceManager namespaceManager = new XmlNamespaceManager((XmlNameTable) new NameTable());
      \u000E obj = (\u000E) null;
      IXmlNode xmlNode = (IXmlNode) null;
      // ISSUE: type reference
      if (\u0093\u0002.\u007E\u0012\u0006((object) \u0004\u0002.\u0084\u0004(__typeref (XObject)), obj1))
      {
        // ISSUE: type reference
        // ISSUE: type reference
        if ((object) obj1 != (object) \u0004\u0002.\u0084\u0004(__typeref (XDocument)) && (object) obj1 != (object) \u0004\u0002.\u0084\u0004(__typeref (XElement)))
          throw new JsonSerializationException(XmlNodeConverter.\u0019(28175));
        obj = (\u000E) new \u000E(new XDocument());
        xmlNode = (IXmlNode) obj;
      }
      // ISSUE: type reference
      if (\u0093\u0002.\u007E\u0012\u0006((object) \u0004\u0002.\u0084\u0004(__typeref (XmlNode)), obj1))
      {
        // ISSUE: type reference
        if ((object) obj1 != (object) \u0004\u0002.\u0084\u0004(__typeref (XmlDocument)))
          throw new JsonSerializationException(XmlNodeConverter.\u0019(28268));
        obj = (\u000E) new \u0005.\u000F(new XmlDocument()
        {
          XmlResolver = (XmlResolver) null
        });
        xmlNode = (IXmlNode) obj;
      }
      if (obj == null || xmlNode == null)
        throw new JsonSerializationException(\u0086.\u0086\u0003((object) XmlNodeConverter.\u0019(28345), (object) obj1));
      if (obj0.\u0001() != JsonToken.StartObject)
        throw new JsonSerializationException(XmlNodeConverter.\u0019(28398));
      if (!\u0007.\u009E(this.\u0001()))
      {
        \u0006.\u0001(this, obj0, obj, xmlNode, this.\u0001(), namespaceManager);
      }
      else
      {
        obj0.\u0001();
        \u0006.\u0001(namespaceManager, obj, this, obj0, xmlNode);
      }
      // ISSUE: type reference
      if ((object) obj1 != (object) \u0004\u0002.\u0084\u0004(__typeref (XElement)))
        return obj.\u0001();
      XElement xelement = (XElement) obj.\u0001().\u0001();
      xelement.Remove();
      return (object) xelement;
    }

    internal void \u0001(
      [In] \u0007 obj0,
      [In] \u000E obj1,
      [In] IXmlNode obj2,
      [In] string obj3,
      [In] XmlNamespaceManager obj4,
      [In] string obj5,
      [In] Dictionary<string, string> obj6)
    {
      \u0006 obj7 = \u0006.\u0001(obj1, this, obj4, obj5, obj3);
      \u0006 obj8;
      if (true)
        obj8 = obj7;
      obj2.\u0001((IXmlNode) obj8);
      foreach (KeyValuePair<string, string> keyValuePair in obj6)
      {
        string str = XmlConvert.EncodeName(keyValuePair.Key);
        string prefix = \u0006.\u0001(keyValuePair.Key);
        IXmlNode xmlNode = !string.IsNullOrEmpty(prefix) ? obj1.\u0002(str, obj4.LookupNamespace(prefix) ?? string.Empty, keyValuePair.Value) : obj1.\u0002(str, keyValuePair.Value);
        obj8.\u0001(xmlNode);
      }
      if (obj0.\u0001() == JsonToken.String || obj0.\u0001() == JsonToken.Integer || obj0.\u0001() == JsonToken.Float || obj0.\u0001() == JsonToken.Boolean || obj0.\u0001() == JsonToken.Date)
      {
        string str = \u0006.\u0001(this, obj0);
        if (str == null)
          return;
        obj8.\u0001(obj1.\u0002(str));
      }
      else
      {
        if (obj0.\u0001() == JsonToken.Null)
          return;
        if (obj0.\u0001() != JsonToken.EndObject)
        {
          obj4.PushScope();
          \u0006.\u0001(obj4, obj1, this, obj0, (IXmlNode) obj8);
          obj4.PopScope();
        }
        obj4.RemoveNamespace(string.Empty, obj4.DefaultNamespace);
      }
    }

    public override bool \u0001([In] Type obj0)
    {
      do
      {
        // ISSUE: type reference
        while (\u0093\u0002.\u007E\u0012\u0006((object) \u0004\u0002.\u0084\u0004(__typeref (XObject)), obj0))
        {
          if (true)
          {
            if (true)
              return true;
          }
          else
            goto label_7;
        }
        // ISSUE: type reference
        if (!\u0093\u0002.\u007E\u0012\u0006((object) \u0004\u0002.\u0084\u0004(__typeref (XmlNode)), obj0))
          goto label_7;
      }
      while (false);
      return true;
label_7:
      return false;
    }

    static XmlNodeConverter()
    {
      do
      {
        Strings.CreateGetStringDelegate(typeof (XmlNodeConverter));
        bool flag = false;
        Assembly assembly = \u0013.\u008B\u0002();
        if (\u0006.\u0001(\u0001.\u007E\u0002((object) assembly), true, out flag))
          goto label_7;
label_5:
        throw new SecurityException(XmlNodeConverter.\u0019(2885));
label_7:
        int num = flag ? 1 : 0;
        if (true)
        {
          if (num != 0)
            num = global::\u0014.\u007E\u008C\u0002((object) \u0001.\u007E\u0003((object) assembly), XmlNodeConverter.\u0019(2860)) ? 1 : 0;
          else
            goto label_5;
        }
        if (num == 0)
          goto label_5;
      }
      while (false);
    }
  }
}
