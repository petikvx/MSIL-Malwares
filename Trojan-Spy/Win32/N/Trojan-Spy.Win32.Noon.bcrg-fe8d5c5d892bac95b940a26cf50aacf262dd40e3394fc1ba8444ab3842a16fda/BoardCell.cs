// Decompiled with JetBrains decompiler
// Type: ChessBoard.BoardCell
// Assembly: IArraySortHel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B08900B5-C53F-4995-B311-D7E8DC4113C6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcrg-fe8d5c5d892bac95b940a26cf50aacf262dd40e3394fc1ba8444ab3842a16fda.exe

using ChessBoard.Chessmens;
using System;
using System.Runtime.InteropServices;

namespace ChessBoard
{
  public class BoardCell : Cell
  {
    public BaseChessman Chessman { get; set; }

    public BoardCell()
    {
label_1:
      int num1 = 401868369;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 2087962428)) % 3U)
        {
          case 0:
            goto label_3;
          case 1:
            num1 = (int) num2 * -344954672 ^ 541480981;
            continue;
          case 2:
            goto label_1;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }

    public BoardCell(int row, int column)
      : base(row, column)
    {
    }

    public BoardCell(int row, int column, BaseChessman chessman)
      : base(row, column)
    {
      this.Chessman = chessman;
    }

    public bool IsEmpty() => this.Chessman == null;

    public override bool Equals(object obj)
    {
      if (obj is BoardCell)
        goto label_15;
label_1:
      int num1 = 1437583970;
label_2:
      BoardCell boardCell;
      bool flag1;
      bool flag2;
      while (true)
      {
        uint num2;
        int num3;
        switch ((num2 = (uint) (num1 ^ 104736379)) % 12U)
        {
          case 0:
            if (BoardCell.\u202C‌⁯​‪‮‌‫‬⁪‎‬‫‭‏‍⁯‪⁪‭‮​‫⁮‌⁮⁭⁪⁭‍‮‍⁫‏‮‬⁯‍⁮‏‮((object) this.Chessman, (object) boardCell.Chessman))
            {
              num1 = 802676073;
              continue;
            }
            break;
          case 1:
            num1 = (int) num2 * -304278227 ^ -1407897420;
            continue;
          case 2:
            num1 = (int) num2 * 530332787 ^ 1190913531;
            continue;
          case 3:
            goto label_15;
          case 4:
            goto label_1;
          case 5:
            num3 = this.Column == boardCell.Column ? 1 : 0;
            goto label_5;
          case 6:
            if (this.Row == boardCell.Row)
            {
              num1 = (int) num2 * 1489230875 ^ -765412096;
              continue;
            }
            break;
          case 7:
            int num4 = flag2 ? 1491765867 : (num4 = 135937832);
            num1 = num4 ^ (int) num2 * -635840207;
            continue;
          case 8:
            num1 = (int) num2 * -1980970248 ^ -1727261895;
            continue;
          case 9:
            flag1 = false;
            num1 = (int) num2 * -740315093 ^ -1980745186;
            continue;
          case 11:
            flag1 = false;
            num1 = (int) num2 * 1314056690 ^ 788977561;
            continue;
          default:
            goto label_17;
        }
        num3 = 0;
label_5:
        flag1 = num3 != 0;
        num1 = 700955578;
      }
label_17:
      return flag1;
label_15:
      boardCell = (BoardCell) obj;
      flag2 = BoardCell.\u200D​⁫‫‍‭‏⁬‫​⁬‬⁭‍‬⁬‭‏⁫‏‎⁬⁬⁯‎‎‏‎‍‮⁫‭⁪⁫​‮‍​⁪‮(BoardCell.\u202A⁫⁫⁭⁭‎⁫‪‫‏⁬‭⁭‪‎‬‫⁭‌‎‮‪⁫⁯​⁫‫⁪⁮​‏⁪​⁪‭‎‬‭⁫‫‮((object) this.Chessman), BoardCell.\u202A⁫⁫⁭⁭‎⁫‪‫‏⁬‭⁭‪‎‬‫⁭‌‎‮‪⁫⁯​⁫‫⁪⁮​‏⁪​⁪‭‎‬‭⁫‫‮((object) boardCell.Chessman));
      num1 = 429860568;
      goto label_2;
    }

    public override int GetHashCode()
    {
label_1:
      int num1 = -199665588;
      int hashCode;
      while (true)
      {
        uint num2;
        int? nullable1;
        int num3;
        int num4;
        int num5;
        int? nullable2;
        switch ((num2 = (uint) (num1 ^ -872321079)) % 9U)
        {
          case 0:
            goto label_1;
          case 1:
            num3 = 17 * 23 + base.GetHashCode();
            num4 = num3 * 23;
            num1 = (int) num2 * 518340293 ^ -999282683;
            continue;
          case 2:
            hashCode = num3;
            num1 = (int) num2 * 1314687713 ^ 1522687285;
            continue;
          case 3:
            num5 = 1;
            break;
          case 4:
            nullable2 = nullable1;
            goto label_17;
          case 6:
            nullable1 = new int?();
            num1 = (int) num2 * -1909530894 ^ -890918174;
            continue;
          case 7:
            BaseChessman chessman = this.Chessman;
            int? nullable3;
            if (chessman == null)
            {
              nullable1 = new int?();
              nullable3 = nullable1;
            }
            else
              nullable3 = new int?(BoardCell.\u200C⁪‮​⁪‮⁬⁫​‮⁬‪⁯‮‪⁮‍⁯⁯‍‏⁪‪⁮‏‪‫‏​‫⁮‏⁫‪⁫‭⁭⁯‎⁯‮((object) chessman));
            int? nullable4 = nullable3;
            if (!nullable4.HasValue)
            {
              num1 = -1259451311;
              continue;
            }
            nullable2 = new int?(num4 + nullable4.GetValueOrDefault());
            goto label_17;
          case 8:
            num1 = (int) num2 * 350354405 ^ -1133278711;
            continue;
          default:
            goto label_19;
        }
label_6:
        num3 = num5;
        num1 = -1861445738;
        continue;
label_17:
        int? nullable5 = nullable2;
        if (nullable5.HasValue)
        {
          num5 = nullable5.GetValueOrDefault();
          goto label_6;
        }
        else
          num1 = -179891271;
      }
label_19:
      return hashCode;
    }

    static Type \u202A⁫⁫⁭⁭‎⁫‪‫‏⁬‭⁭‪‎‬‫⁭‌‎‮‪⁫⁯​⁫‫⁪⁮​‏⁪​⁪‭‎‬‭⁫‫‮([In] object obj0) => obj0.GetType();

    static bool \u200D​⁫‫‍‭‏⁬‫​⁬‬⁭‍‬⁬‭‏⁫‏‎⁬⁬⁯‎‎‏‎‍‮⁫‭⁪⁫​‮‍​⁪‮([In] Type obj0, [In] Type obj1) => obj0 != obj1;

    static bool \u202C‌⁯​‪‮‌‫‬⁪‎‬‫‭‏‍⁯‪⁪‭‮​‫⁮‌⁮⁭⁪⁭‍‮‍⁫‏‮‬⁯‍⁮‏‮([In] object obj0, [In] object obj1) => obj0.Equals(obj1);

    static int \u200C⁪‮​⁪‮⁬⁫​‮⁬‪⁯‮‪⁮‍⁯⁯‍‏⁪‪⁮‏‪‫‏​‫⁮‏⁫‪⁫‭⁭⁯‎⁯‮([In] object obj0) => obj0.GetHashCode();
  }
}
