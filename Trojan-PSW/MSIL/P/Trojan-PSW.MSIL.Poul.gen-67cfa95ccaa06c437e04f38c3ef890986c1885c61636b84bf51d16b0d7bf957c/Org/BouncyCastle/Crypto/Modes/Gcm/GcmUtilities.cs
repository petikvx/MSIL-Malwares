// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Crypto.Modes.Gcm.GcmUtilities
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using Org.BouncyCastle.Crypto.Utilities;

namespace Org.BouncyCastle.Crypto.Modes.Gcm
{
  internal abstract class GcmUtilities
  {
    private const uint E1 = 3774873600;
    private const ulong E1L = 16212958658533785600;
    private static readonly uint[] LOOKUP = GcmUtilities.GenerateLookup();

    private static uint[] GenerateLookup()
    {
      uint[] lookup = new uint[256];
      for (int index1 = 0; index1 < 256; ++index1)
      {
        uint num = 0;
        for (int index2 = 7; index2 >= 0; --index2)
        {
          if ((index1 & 1 << index2) != 0)
            num ^= 3774873600U >> 7 - index2;
        }
        lookup[index1] = num;
      }
      return lookup;
    }

    internal static uint[] OneAsUints() => new uint[4]
    {
      2147483648U,
      0U,
      0U,
      0U
    };

    internal static void AsBytes(uint[] x, byte[] z) => Pack.UInt32_To_BE(x, z, 0);

    internal static uint[] AsUints(byte[] bs)
    {
      uint[] ns = new uint[4];
      Pack.BE_To_UInt32(bs, 0, ns);
      return ns;
    }

    internal static void Multiply(byte[] x, byte[] y)
    {
      uint[] x1 = GcmUtilities.AsUints(x);
      GcmUtilities.Multiply(x1, GcmUtilities.AsUints(y));
      GcmUtilities.AsBytes(x1, x);
    }

    internal static void Multiply(uint[] x, uint[] y)
    {
      uint num1 = x[0];
      uint num2 = x[1];
      uint num3 = x[2];
      uint num4 = x[3];
      uint num5 = 0;
      uint num6 = 0;
      uint num7 = 0;
      uint num8 = 0;
      for (int index1 = 0; index1 < 4; ++index1)
      {
        int num9 = (int) y[index1];
        for (int index2 = 0; index2 < 32; ++index2)
        {
          uint num10 = (uint) (num9 >> 31);
          num9 <<= 1;
          num5 ^= num1 & num10;
          num6 ^= num2 & num10;
          num7 ^= num3 & num10;
          num8 ^= num4 & num10;
          uint num11 = (uint) ((int) num4 << 31 >> 8);
          num4 = num4 >> 1 | num3 << 31;
          num3 = num3 >> 1 | num2 << 31;
          num2 = num2 >> 1 | num1 << 31;
          num1 = num1 >> 1 ^ num11 & 3774873600U;
        }
      }
      x[0] = num5;
      x[1] = num6;
      x[2] = num7;
      x[3] = num8;
    }

    internal static void MultiplyP(uint[] x)
    {
      uint num = GcmUtilities.ShiftRight(x) >> 8;
      x[0] ^= num & 3774873600U;
    }

    internal static void MultiplyP8(uint[] x)
    {
      uint num = GcmUtilities.ShiftRightN(x, 8);
      x[0] ^= GcmUtilities.LOOKUP[(int) (num >> 24)];
    }

    internal static uint ShiftRight(uint[] x)
    {
      uint num1 = x[0];
      x[0] = num1 >> 1;
      uint num2 = num1 << 31;
      uint num3 = x[1];
      x[1] = num3 >> 1 | num2;
      uint num4 = num3 << 31;
      uint num5 = x[2];
      x[2] = num5 >> 1 | num4;
      uint num6 = num5 << 31;
      uint num7 = x[3];
      x[3] = num7 >> 1 | num6;
      return num7 << 31;
    }

    internal static uint ShiftRightN(uint[] x, int n)
    {
      uint num1 = x[0];
      int num2 = 32 - n;
      x[0] = num1 >> n;
      uint num3 = num1 << num2;
      uint num4 = x[1];
      x[1] = num4 >> n | num3;
      uint num5 = num4 << num2;
      uint num6 = x[2];
      x[2] = num6 >> n | num5;
      uint num7 = num6 << num2;
      uint num8 = x[3];
      x[3] = num8 >> n | num7;
      return num8 << num2;
    }

    internal static void Xor(byte[] x, byte[] y)
    {
      int index1 = 0;
      do
      {
        x[index1] ^= y[index1];
        int index2 = index1 + 1;
        x[index2] ^= y[index2];
        int index3 = index2 + 1;
        x[index3] ^= y[index3];
        int index4 = index3 + 1;
        x[index4] ^= y[index4];
        index1 = index4 + 1;
      }
      while (index1 < 16);
    }

    internal static void Xor(byte[] x, byte[] y, int yOff)
    {
      int index1 = 0;
      do
      {
        x[index1] ^= y[yOff + index1];
        int index2 = index1 + 1;
        x[index2] ^= y[yOff + index2];
        int index3 = index2 + 1;
        x[index3] ^= y[yOff + index3];
        int index4 = index3 + 1;
        x[index4] ^= y[yOff + index4];
        index1 = index4 + 1;
      }
      while (index1 < 16);
    }

    internal static void Xor(byte[] x, int xOff, byte[] y, int yOff, byte[] z, int zOff)
    {
      int num1 = 0;
      do
      {
        z[zOff + num1] = (byte) ((uint) x[xOff + num1] ^ (uint) y[yOff + num1]);
        int num2 = num1 + 1;
        z[zOff + num2] = (byte) ((uint) x[xOff + num2] ^ (uint) y[yOff + num2]);
        int num3 = num2 + 1;
        z[zOff + num3] = (byte) ((uint) x[xOff + num3] ^ (uint) y[yOff + num3]);
        int num4 = num3 + 1;
        z[zOff + num4] = (byte) ((uint) x[xOff + num4] ^ (uint) y[yOff + num4]);
        num1 = num4 + 1;
      }
      while (num1 < 16);
    }

    internal static void Xor(byte[] x, byte[] y, int yOff, int yLen)
    {
      while (--yLen >= 0)
        x[yLen] ^= y[yOff + yLen];
    }

    internal static void Xor(byte[] x, int xOff, byte[] y, int yOff, int len)
    {
      while (--len >= 0)
        x[xOff + len] ^= y[yOff + len];
    }

    internal static void Xor(uint[] x, uint[] y)
    {
      x[0] ^= y[0];
      x[1] ^= y[1];
      x[2] ^= y[2];
      x[3] ^= y[3];
    }
  }
}
