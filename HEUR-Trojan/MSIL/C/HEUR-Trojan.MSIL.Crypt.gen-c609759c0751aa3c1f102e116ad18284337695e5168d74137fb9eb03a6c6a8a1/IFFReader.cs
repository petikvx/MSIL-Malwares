// Decompiled with JetBrains decompiler
// Type: D3DHelper.IFFReader
// Assembly: focf, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DAF57287-295C-4A11-AD9D-F27944BDF68F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.Crypt.gen-c609759c0751aa3c1f102e116ad18284337695e5168d74137fb9eb03a6c6a8a1.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace D3DHelper
{
  public sealed class IFFReader : BinaryReader
  {
    private List<Chunk> m_ChunkList;
    private HandlerList m_Handlers;

    public IFFReader(Stream input)
      : base(input)
    {
      this.m_ChunkList = new List<Chunk>();
      this.m_Handlers = new HandlerList(this);
      this.m_Handlers.DefaultHandler = new ChunkHandler(IFFReader.__defaultChunkHandler);
    }

    public ChunkHandler DefaultHandler
    {
      get => this.m_Handlers.DefaultHandler;
      set => this.m_Handlers.DefaultHandler = value;
    }

    public static IFFReader Open(string Filename)
    {
      IFFReader iffReader1;
      IFFReader iffReader2;
      try
      {
        iffReader1 = new IFFReader((Stream) File.OpenRead(Filename));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        iffReader2 = (IFFReader) null;
        ProjectData.ClearProjectError();
        goto label_4;
      }
      iffReader2 = iffReader1;
label_4:
      return iffReader2;
    }

    public void AddHandler(string ID, ChunkType Type, ChunkHandler Handler, uint Version = 0) => this.m_Handlers.AddHandler(ID, Type, Handler, Version);

    internal ChunkHandler FindHandler(string ID, ChunkType Type, uint Version = 0) => this.m_Handlers.FindHandler(ID, Type, Version);

    public void Parse(bool FromBegining = false)
    {
      if (this.m_ChunkList.Count != 0)
        this.m_ChunkList.Clear();
      if (FromBegining && this.BaseStream.Position != 0L)
        this.BaseStream.Position = 0L;
      while (this.BaseStream.Position < this.BaseStream.Length)
      {
        Chunk chunk = new Chunk(this);
        chunk.StartPosition = this.BaseStream.Position;
        chunk.ID = this.ReadString(4);
        chunk.Size = (long) IFFReader.__swap(this.ReadUInt32());
        string id = chunk.ID;
        if (Operators.CompareString(id, "NRML", false) != 0)
        {
          if (Operators.CompareString(id, "FORM", false) == 0)
          {
            chunk.Type = ChunkType.Form;
            chunk.ID = this.ReadString(4);
            // ISSUE: variable of a reference type
            long& local;
            // ISSUE: explicit reference operation
            long num = checked (^(local = ref chunk.Size) - 4L);
            local = num;
          }
        }
        else
        {
          chunk.Type = ChunkType.Normal;
          chunk.ID = this.ReadString(4);
          chunk.Version = IFFReader.__swap(this.ReadUInt32());
          // ISSUE: variable of a reference type
          long& local;
          // ISSUE: explicit reference operation
          long num = checked (^(local = ref chunk.Size) - 8L);
          local = num;
        }
        if (checked (this.BaseStream.Position + chunk.Size) > this.BaseStream.Length)
        {
          Trace.TraceError("Input IFF file has an invalid chunk! (\"" + chunk.ID + "\")");
          break;
        }
        this.m_ChunkList.Add(chunk);
        chunk.Read();
      }
    }

    public string ReadString(int Length)
    {
      string str = "";
      byte[] numArray = this.ReadBytes(Length);
      if (Length != 0)
      {
        int num = checked (Length - 1);
        int index = 0;
        while (index <= num)
        {
          str += Conversions.ToString(Strings.Chr((int) numArray[index]));
          checked { ++index; }
        }
      }
      return str;
    }

    public override string ReadString()
    {
      int Length = this.ReadInt32();
      if (Length > 256)
        Trace.TraceWarning("Input string may be invalid.");
      return this.ReadString(Length);
    }

    private static uint __swap(uint v) => (uint) ((int) checked ((uint) (((long) v & -16777216L) >> 24)) | (int) checked ((uint) (((long) v & 16711680L) >> 16)) << 8 | (int) checked ((uint) (((long) v & 65280L) >> 8)) << 16 | (int) checked ((uint) ((long) v & (long) byte.MaxValue)) << 24);

    private static void __defaultChunkHandler(IFFReader Reader, ChunkAttributes ChunkAttributes) => Trace.TraceInformation("Skipping chunk:\r\n ID: \"" + ChunkAttributes.ID + "\"\r\n Type: '" + ChunkAttributes.Type.ToString() + "'\r\n" + Conversions.ToString(Interaction.IIf(ChunkAttributes.Type == ChunkType.Normal, (object) (" Version: " + Conversions.ToString(ChunkAttributes.Version)), (object) "")));
  }
}
