// Decompiled with JetBrains decompiler
// Type: Core.Infrastructure.Images.ImageMediaFormats
// Assembly: AnsiCharMarsha, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 45449883-CB33-464D-BFFF-85C1D8F95247
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-PSW.Win32.Stealer.aipl-731355759034e0ae5cff6011792f40d5154dccd99fac792da878777bbc532ce2.exe

using Core.Helpers;
using System;
using System.Collections.Generic;
using System.Drawing.Imaging;
using System.Linq;

namespace Core.Infrastructure.Images
{
  public class ImageMediaFormats : IImageMediaFormats
  {
    private readonly IDictionary<Guid, IImageFormatSpec> _specs;

    public ImageMediaFormats(IImageFormatSpec[] specs)
    {
      Checks.Argument.IsNotNull((object) specs, nameof (specs));
      Checks.Argument.IsNotEmpty<IImageFormatSpec>((ICollection<IImageFormatSpec>) specs, nameof (specs));
      try
      {
        string message = "ImageMediaFormats can only accept a mutually exclusive array of IImageFormatSpec.  The array provided has a duplicate property value.";
        int length = specs.Length;
        if (((IEnumerable<IImageFormatSpec>) specs).DistinctBy<IImageFormatSpec, int>((Func<IImageFormatSpec, int>) (s => s.GetHashCode())).Count<IImageFormatSpec>() != length)
          throw new ArgumentException(message);
        this._specs = (IDictionary<Guid, IImageFormatSpec>) ((IEnumerable<IImageFormatSpec>) specs).ToDictionary<IImageFormatSpec, Guid>((Func<IImageFormatSpec, Guid>) (x => x.Format.Guid));
      }
      catch (ArgumentNullException ex)
      {
        throw;
      }
      catch (ArgumentException ex)
      {
        throw;
      }
    }

    public bool HasExtension(string extension) => this._specs.Values.Any<IImageFormatSpec>((Func<IImageFormatSpec, bool>) (x => x.Extension.ToLower() == extension.ToLower()));

    public bool HasContentType(string contentType) => this._specs.Values.Any<IImageFormatSpec>((Func<IImageFormatSpec, bool>) (x => x.ContentType.ToLower() == contentType.ToLower()));

    public bool HasImageFormat(ImageFormat format) => this._specs.Values.Any<IImageFormatSpec>((Func<IImageFormatSpec, bool>) (x => x.Format.Equals((object) format)));

    public IImageFormatSpec GetSpecByExtension(string extension) => this._specs.Values.SingleOrDefault<IImageFormatSpec>((Func<IImageFormatSpec, bool>) (x => x.Extension.ToLower() == extension.ToLower()));

    public IImageFormatSpec GetSpecByContentType(string contentType) => this._specs.Values.SingleOrDefault<IImageFormatSpec>((Func<IImageFormatSpec, bool>) (x => x.ContentType.ToLower() == contentType.ToLower()));

    public IImageFormatSpec GetSpecByFormat(ImageFormat format) => this._specs.Values.SingleOrDefault<IImageFormatSpec>((Func<IImageFormatSpec, bool>) (x => x.Format.Equals((object) format)));

    public IList<IImageFormatSpec> ImageFormatSpecs => (IList<IImageFormatSpec>) this._specs.Values.ToList<IImageFormatSpec>().AsReadOnly();
  }
}
