// Decompiled with JetBrains decompiler
// Type: VenomRAT_HVNC.Server.Helper.RegistryKeyHelper
// Assembly: VenomRAT_HVNC, Version=5.0.4.0, Culture=neutral, PublicKeyToken=null
// MVID: 364FC72B-4DB8-403E-BB7F-732199A12380
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-666d190a7059c03b3572dd66e51b8232537a8650bbdcbfbe3f8335c830f3aeae.exe

using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Linq;

namespace VenomRAT_HVNC.Server.Helper
{
  public static class RegistryKeyHelper
  {
    private static string DEFAULT_VALUE = string.Empty;

    public static bool AddRegistryKeyValue(
      RegistryHive hive,
      string path,
      string name,
      string value,
      bool addQuotes = false)
    {
      bool flag;
      try
      {
        using (RegistryKey registryKey = RegistryKey.OpenBaseKey(hive, RegistryView.Registry64).OpenWritableSubKeySafe(path))
        {
          if (registryKey == null)
          {
            flag = false;
          }
          else
          {
            if (addQuotes && !value.StartsWith("\"") && !value.EndsWith("\""))
              value = "\"" + value + "\"";
            registryKey.SetValue(name, (object) value);
            flag = true;
          }
        }
      }
      catch (Exception ex)
      {
        flag = false;
      }
      return flag;
    }

    public static RegistryKey OpenReadonlySubKey(RegistryHive hive, string path)
    {
      RegistryKey registryKey;
      try
      {
        registryKey = RegistryKey.OpenBaseKey(hive, RegistryView.Registry64).OpenSubKey(path, false);
      }
      catch
      {
        registryKey = (RegistryKey) null;
      }
      return registryKey;
    }

    public static bool DeleteRegistryKeyValue(RegistryHive hive, string path, string name)
    {
      bool flag;
      try
      {
        using (RegistryKey registryKey = RegistryKey.OpenBaseKey(hive, RegistryView.Registry64).OpenWritableSubKeySafe(path))
        {
          if (registryKey == null)
          {
            flag = false;
          }
          else
          {
            registryKey.DeleteValue(name, true);
            flag = true;
          }
        }
      }
      catch (Exception ex)
      {
        flag = false;
      }
      return flag;
    }

    public static bool IsDefaultValue(string valueName) => string.IsNullOrEmpty(valueName);

    public static RegistrySeeker.RegValueData[] AddDefaultValue(
      List<RegistrySeeker.RegValueData> values)
    {
      if (!values.Any<RegistrySeeker.RegValueData>((Func<RegistrySeeker.RegValueData, bool>) (value => RegistryKeyHelper.IsDefaultValue(value.Name))))
        values.Add(RegistryKeyHelper.GetDefaultValue());
      return values.ToArray();
    }

    public static RegistrySeeker.RegValueData[] GetDefaultValues() => new RegistrySeeker.RegValueData[1]
    {
      RegistryKeyHelper.GetDefaultValue()
    };

    public static RegistrySeeker.RegValueData CreateRegValueData(
      string name,
      RegistryValueKind kind,
      object value = null)
    {
      RegistrySeeker.RegValueData regValueData = new RegistrySeeker.RegValueData()
      {
        Name = name,
        Kind = kind
      };
      if (value == null)
      {
        regValueData.Data = new byte[0];
      }
      else
      {
        switch (regValueData.Kind)
        {
          case RegistryValueKind.String:
          case RegistryValueKind.ExpandString:
            regValueData.Data = ByteConverter.GetBytes((string) value);
            break;
          case RegistryValueKind.Binary:
            regValueData.Data = (byte[]) value;
            break;
          case RegistryValueKind.DWord:
            regValueData.Data = ByteConverter.GetBytes((uint) (int) value);
            break;
          case RegistryValueKind.MultiString:
            regValueData.Data = ByteConverter.GetBytes((string[]) value);
            break;
          case RegistryValueKind.QWord:
            regValueData.Data = ByteConverter.GetBytes((ulong) (long) value);
            break;
        }
      }
      return regValueData;
    }

    private static RegistrySeeker.RegValueData GetDefaultValue() => RegistryKeyHelper.CreateRegValueData(RegistryKeyHelper.DEFAULT_VALUE, RegistryValueKind.String);
  }
}
