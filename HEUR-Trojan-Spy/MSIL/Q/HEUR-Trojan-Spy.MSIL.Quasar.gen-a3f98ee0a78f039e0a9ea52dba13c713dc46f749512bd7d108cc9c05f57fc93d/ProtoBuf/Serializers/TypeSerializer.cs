// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Serializers.TypeSerializer
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using ProtoBuf.Meta;
using System;
using System.Reflection;

namespace ProtoBuf.Serializers
{
  internal sealed class TypeSerializer : IProtoTypeSerializer, IProtoSerializer
  {
    private readonly Type forType;
    private readonly Type constructType;
    private readonly IProtoSerializer[] serializers;
    private readonly int[] fieldNumbers;
    private readonly bool isRootType;
    private readonly bool useConstructor;
    private readonly bool isExtensible;
    private readonly bool hasConstructor;
    private readonly CallbackSet callbacks;
    private readonly MethodInfo[] baseCtorCallbacks;
    private readonly MethodInfo factory;
    private static readonly Type iextensible = typeof (IExtensible);

    public bool HasCallbacks(TypeModel.CallbackType callbackType)
    {
      if (this.callbacks != null && (object) this.callbacks[callbackType] != null)
        return true;
      for (int index = 0; index < this.serializers.Length; ++index)
      {
        if ((object) this.serializers[index].ExpectedType != (object) this.forType && ((IProtoTypeSerializer) this.serializers[index]).HasCallbacks(callbackType))
          return true;
      }
      return false;
    }

    public Type ExpectedType => this.forType;

    public TypeSerializer(
      TypeModel model,
      Type forType,
      int[] fieldNumbers,
      IProtoSerializer[] serializers,
      MethodInfo[] baseCtorCallbacks,
      bool isRootType,
      bool useConstructor,
      CallbackSet callbacks,
      Type constructType,
      MethodInfo factory)
    {
      Helpers.Sort(fieldNumbers, (object[]) serializers);
      bool flag = false;
      for (int index = 1; index < fieldNumbers.Length; ++index)
      {
        if (fieldNumbers[index] == fieldNumbers[index - 1])
          throw new InvalidOperationException("Duplicate field-number detected; " + fieldNumbers[index].ToString() + " on: " + forType.FullName);
        if (!flag && (object) serializers[index].ExpectedType != (object) forType)
          flag = true;
      }
      this.forType = forType;
      this.factory = factory;
      if ((object) constructType == null)
        constructType = forType;
      else if (!forType.IsAssignableFrom(constructType))
        throw new InvalidOperationException(forType.FullName + " cannot be assigned from " + constructType.FullName);
      this.constructType = constructType;
      this.serializers = serializers;
      this.fieldNumbers = fieldNumbers;
      this.callbacks = callbacks;
      this.isRootType = isRootType;
      this.useConstructor = useConstructor;
      if (baseCtorCallbacks != null && baseCtorCallbacks.Length == 0)
        baseCtorCallbacks = (MethodInfo[]) null;
      this.baseCtorCallbacks = baseCtorCallbacks;
      if ((object) Helpers.GetUnderlyingType(forType) != null)
        throw new ArgumentException("Cannot create a TypeSerializer for nullable types", nameof (forType));
      if (model.MapType(TypeSerializer.iextensible).IsAssignableFrom(forType))
      {
        if (((forType.IsValueType ? 1 : (!isRootType ? 1 : 0)) | (flag ? 1 : 0)) != 0)
          throw new NotSupportedException("IExtensible is not supported in structs or classes with inheritance");
        this.isExtensible = true;
      }
      this.hasConstructor = !constructType.IsAbstract && Helpers.GetConstructor(constructType, Helpers.EmptyTypes, true) != null;
      if ((object) constructType != (object) forType & useConstructor && !this.hasConstructor)
        throw new ArgumentException("The supplied default implementation cannot be created: " + constructType.FullName, nameof (constructType));
    }

    private bool CanHaveInheritance => (this.forType.IsClass || this.forType.IsInterface) && !this.forType.IsSealed;

    bool IProtoTypeSerializer.CanCreateInstance() => true;

    object IProtoTypeSerializer.CreateInstance(ProtoReader source) => this.CreateInstance(source, false);

    public void Callback(
      object value,
      TypeModel.CallbackType callbackType,
      SerializationContext context)
    {
      if (this.callbacks != null)
        this.InvokeCallback(this.callbacks[callbackType], value, context);
      ((IProtoTypeSerializer) this.GetMoreSpecificSerializer(value))?.Callback(value, callbackType, context);
    }

    private IProtoSerializer GetMoreSpecificSerializer(object value)
    {
      if (!this.CanHaveInheritance)
        return (IProtoSerializer) null;
      Type type = value.GetType();
      if ((object) type == (object) this.forType)
        return (IProtoSerializer) null;
      for (int index = 0; index < this.serializers.Length; ++index)
      {
        IProtoSerializer serializer = this.serializers[index];
        if ((object) serializer.ExpectedType != (object) this.forType && Helpers.IsAssignableFrom(serializer.ExpectedType, type))
          return serializer;
      }
      if ((object) type == (object) this.constructType)
        return (IProtoSerializer) null;
      TypeModel.ThrowUnexpectedSubtype(this.forType, type);
      return (IProtoSerializer) null;
    }

    public void Write(object value, ProtoWriter dest)
    {
      if (this.isRootType)
        this.Callback(value, TypeModel.CallbackType.BeforeSerialize, dest.Context);
      this.GetMoreSpecificSerializer(value)?.Write(value, dest);
      for (int index = 0; index < this.serializers.Length; ++index)
      {
        IProtoSerializer serializer = this.serializers[index];
        if ((object) serializer.ExpectedType == (object) this.forType)
          serializer.Write(value, dest);
      }
      if (this.isExtensible)
        ProtoWriter.AppendExtensionData((IExtensible) value, dest);
      if (!this.isRootType)
        return;
      this.Callback(value, TypeModel.CallbackType.AfterSerialize, dest.Context);
    }

    public object Read(object value, ProtoReader source)
    {
      if (this.isRootType && value != null)
        this.Callback(value, TypeModel.CallbackType.BeforeDeserialize, source.Context);
      int num1 = 0;
      int num2 = 0;
      int num3;
      while ((num3 = source.ReadFieldHeader()) > 0)
      {
        bool flag = false;
        if (num3 < num1)
          num1 = num2 = 0;
        for (int index = num2; index < this.fieldNumbers.Length; ++index)
        {
          if (this.fieldNumbers[index] == num3)
          {
            IProtoSerializer serializer = this.serializers[index];
            Type expectedType = serializer.ExpectedType;
            if (value == null)
            {
              if ((object) expectedType == (object) this.forType)
                value = this.CreateInstance(source, true);
            }
            else if ((object) expectedType != (object) this.forType && ((IProtoTypeSerializer) serializer).CanCreateInstance() && expectedType.IsSubclassOf(value.GetType()))
              value = ProtoReader.Merge(source, value, ((IProtoTypeSerializer) serializer).CreateInstance(source));
            if (serializer.ReturnsValue)
              value = serializer.Read(value, source);
            else
              serializer.Read(value, source);
            num2 = index;
            num1 = num3;
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          if (value == null)
            value = this.CreateInstance(source, true);
          if (this.isExtensible)
            source.AppendExtensionData((IExtensible) value);
          else
            source.SkipField();
        }
      }
      if (value == null)
        value = this.CreateInstance(source, true);
      if (this.isRootType)
        this.Callback(value, TypeModel.CallbackType.AfterDeserialize, source.Context);
      return value;
    }

    private object InvokeCallback(MethodInfo method, object obj, SerializationContext context)
    {
      object obj1 = (object) null;
      if ((object) method != null)
      {
        ParameterInfo[] parameters1 = method.GetParameters();
        object[] parameters2;
        bool flag;
        if (parameters1.Length == 0)
        {
          parameters2 = (object[]) null;
          flag = true;
        }
        else
        {
          parameters2 = new object[parameters1.Length];
          flag = true;
          for (int index = 0; index < parameters2.Length; ++index)
          {
            Type parameterType = parameters1[index].ParameterType;
            object obj2;
            if ((object) parameterType == (object) typeof (SerializationContext))
              obj2 = (object) context;
            else if ((object) parameterType == (object) typeof (Type))
            {
              obj2 = (object) this.constructType;
            }
            else
            {
              obj2 = (object) null;
              flag = false;
            }
            parameters2[index] = obj2;
          }
        }
        if (!flag)
          throw CallbackSet.CreateInvalidCallbackSignature(method);
        obj1 = method.Invoke(obj, parameters2);
      }
      return obj1;
    }

    private object CreateInstance(ProtoReader source, bool includeLocalCallback)
    {
      object instance;
      if ((object) this.factory != null)
        instance = this.InvokeCallback(this.factory, (object) null, source.Context);
      else if (this.useConstructor)
      {
        if (!this.hasConstructor)
          TypeModel.ThrowCannotCreateInstance(this.constructType);
        instance = Activator.CreateInstance(this.constructType, true);
      }
      else
        instance = BclHelpers.GetUninitializedObject(this.constructType);
      ProtoReader.NoteObject(instance, source);
      if (this.baseCtorCallbacks != null)
      {
        for (int index = 0; index < this.baseCtorCallbacks.Length; ++index)
          this.InvokeCallback(this.baseCtorCallbacks[index], instance, source.Context);
      }
      if (includeLocalCallback && this.callbacks != null)
        this.InvokeCallback(this.callbacks.BeforeDeserialize, instance, source.Context);
      return instance;
    }

    bool IProtoSerializer.RequiresOldValue => true;

    bool IProtoSerializer.ReturnsValue => false;
  }
}
