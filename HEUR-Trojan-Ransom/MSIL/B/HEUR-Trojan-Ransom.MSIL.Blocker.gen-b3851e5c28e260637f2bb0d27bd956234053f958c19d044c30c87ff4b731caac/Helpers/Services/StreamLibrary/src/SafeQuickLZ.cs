// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Services.StreamLibrary.src.SafeQuickLZ
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;

namespace VanillaStub.Helpers.Services.StreamLibrary.src
{
  public class SafeQuickLZ
  {
    public const int QLZ_VERSION_MAJOR = 1;
    public const int QLZ_VERSION_MINOR = 5;
    public const int QLZ_VERSION_REVISION = 0;
    public const int QLZ_STREAMING_BUFFER = 0;
    public const int QLZ_MEMORY_SAFE = 0;
    private const int HASH_VALUES = 4096;
    private const int MINOFFSET = 2;
    private const int UNCONDITIONAL_MATCHLEN = 6;
    private const int UNCOMPRESSED_END = 4;
    private const int CWORD_LEN = 4;
    private const int DEFAULT_HEADERLEN = 9;
    private const int QLZ_POINTERS_1 = 1;
    private const int QLZ_POINTERS_3 = 16;

    private int headerLen(byte[] source, int offset) => ((int) source[offset] & 2) == 2 ? 9 : 3;

    public int sizeDecompressed(byte[] source, int offset) => this.headerLen(source, offset) == 9 ? (int) source[offset + 5] | (int) source[offset + 6] << 8 | (int) source[offset + 7] << 16 | (int) source[offset + 8] << 24 : (int) source[offset + 2];

    public int sizeCompressed(byte[] source, int offset) => this.headerLen(source, offset) == 9 ? (int) source[offset + 1] | (int) source[offset + 2] << 8 | (int) source[offset + 3] << 16 | (int) source[offset + 4] << 24 : (int) source[offset + 1];

    private void write_header(
      byte[] dst,
      int level,
      bool compressible,
      int size_compressed,
      int size_decompressed)
    {
      dst[0] = (byte) (2 | (compressible ? 1 : 0));
      dst[0] |= (byte) (level << 2);
      dst[0] |= (byte) 64;
      dst[0] |= (byte) 0;
      this.fast_write(dst, 1, size_decompressed, 4);
      this.fast_write(dst, 5, size_compressed, 4);
    }

    public byte[] compress(byte[] source, int Offset, int Length, int level)
    {
      int index1 = Offset;
      int length = 13;
      uint num1 = 2147483648;
      int i = 9;
      byte[] numArray1 = new byte[Length + 400];
      int[] numArray2 = new int[4096];
      byte[] numArray3 = new byte[4096];
      int num2 = 0;
      int num3 = Length - 6 - 4 - 1;
      int num4 = 0;
      if (level != 1 && level != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      int[,] numArray4 = level != 1 ? new int[4096, 16] : new int[4096, 1];
      if (Length == 0)
        return new byte[0];
      if (index1 <= num3)
        num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
      while (index1 <= num3)
      {
        if (((int) num1 & 1) == 1)
        {
          if (index1 > Length >> 1 && length > index1 - (index1 >> 5))
          {
            byte[] numArray5 = new byte[Length + 9];
            this.write_header(numArray5, level, false, Length, Length + 9);
            Array.Copy((Array) source, 0, (Array) numArray5, 9, Length);
            return numArray5;
          }
          this.fast_write(numArray1, i, (int) (num1 >> 1) | int.MinValue, 4);
          i = length;
          length += 4;
          num1 = 2147483648U;
        }
        if (level == 1)
        {
          int index2 = (num2 >> 12 ^ num2) & 4095;
          int num5 = numArray4[index2, 0];
          int num6 = numArray2[index2] ^ num2;
          numArray2[index2] = num2;
          numArray4[index2, 0] = index1;
          if (num6 == 0 && numArray3[index2] != (byte) 0 && (index1 - num5 > 2 || index1 == num5 + 1 && num4 >= 3 && index1 > 3 && (int) source[index1] == (int) source[index1 - 3] && (int) source[index1] == (int) source[index1 - 2] && (int) source[index1] == (int) source[index1 - 1] && (int) source[index1] == (int) source[index1 + 1] && (int) source[index1] == (int) source[index1 + 2]))
          {
            num1 = num1 >> 1 | 2147483648U;
            if ((int) source[num5 + 3] != (int) source[index1 + 3])
            {
              int num7 = 1 | index2 << 4;
              numArray1[length] = (byte) num7;
              numArray1[length + 1] = (byte) (num7 >> 8);
              index1 += 3;
              length += 2;
            }
            else
            {
              int num8 = index1;
              int num9 = Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : Length - 4 - index1 + 1 - 1;
              index1 += 4;
              if ((int) source[num5 + index1 - num8] == (int) source[index1])
              {
                ++index1;
                if ((int) source[num5 + index1 - num8] == (int) source[index1])
                {
                  ++index1;
                  while ((int) source[num5 + (index1 - num8)] == (int) source[index1] && index1 - num8 < num9)
                    ++index1;
                }
              }
              int num10 = index1 - num8;
              int num11 = index2 << 4;
              if (num10 < 18)
              {
                int num12 = num11 | num10 - 2;
                numArray1[length] = (byte) num12;
                numArray1[length + 1] = (byte) (num12 >> 8);
                length += 2;
              }
              else
              {
                this.fast_write(numArray1, length, num11 | num10 << 16, 3);
                length += 3;
              }
            }
            num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
            num4 = 0;
          }
          else
          {
            ++num4;
            numArray3[index2] = (byte) 1;
            numArray1[length] = source[index1];
            num1 >>= 1;
            ++index1;
            ++length;
            num2 = num2 >> 8 & (int) ushort.MaxValue | (int) source[index1 + 2] << 16;
          }
        }
        else
        {
          num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
          int num13 = 0;
          int num14 = Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : Length - 4 - index1 + 1 - 1;
          int index3 = (num2 >> 12 ^ num2) & 4095;
          byte num15 = numArray3[index3];
          int num16 = 0;
          int num17 = 0;
          for (int index4 = 0; index4 < 16 && (int) num15 > index4; ++index4)
          {
            int index5 = numArray4[index3, index4];
            if ((int) (byte) num2 == (int) source[index5] && (int) (byte) (num2 >> 8) == (int) source[index5 + 1] && (int) (byte) (num2 >> 16) == (int) source[index5 + 2] && index5 < index1 - 2)
            {
              int num18 = 3;
              while ((int) source[index5 + num18] == (int) source[index1 + num18] && num18 < num14)
                ++num18;
              if (num18 > num16 || num18 == num16 && index5 > num17)
              {
                num17 = index5;
                num16 = num18;
                num13 = index4;
              }
            }
          }
          int num19 = num17;
          numArray4[index3, (int) num15 & 15] = index1;
          byte num20 = (byte) ((uint) num15 + 1U);
          numArray3[index3] = num20;
          if (num16 >= 3 && index1 - num19 < 131071)
          {
            int num21 = index1 - num19;
            for (int index6 = 1; index6 < num16; ++index6)
            {
              num2 = (int) source[index1 + index6] | (int) source[index1 + index6 + 1] << 8 | (int) source[index1 + index6 + 2] << 16;
              int index7 = (num2 >> 12 ^ num2) & 4095;
              byte num22 = numArray3[index7]++;
              numArray4[index7, (int) num22 & 15] = index1 + index6;
            }
            index1 += num16;
            num1 = num1 >> 1 | 2147483648U;
            if (num16 == 3 && num21 <= 63)
            {
              this.fast_write(numArray1, length, num21 << 2, 1);
              ++length;
            }
            else if (num16 == 3 && num21 <= 16383)
            {
              this.fast_write(numArray1, length, num21 << 2 | 1, 2);
              length += 2;
            }
            else if (num16 <= 18 && num21 <= 1023)
            {
              this.fast_write(numArray1, length, num16 - 3 << 2 | num21 << 6 | 2, 2);
              length += 2;
            }
            else if (num16 <= 33)
            {
              this.fast_write(numArray1, length, num16 - 2 << 2 | num21 << 7 | 3, 3);
              length += 3;
            }
            else
            {
              this.fast_write(numArray1, length, num16 - 3 << 7 | num21 << 15 | 3, 4);
              length += 4;
            }
            num4 = 0;
          }
          else
          {
            numArray1[length] = source[index1];
            num1 >>= 1;
            ++index1;
            ++length;
          }
        }
      }
      while (index1 <= Length - 1)
      {
        if (((int) num1 & 1) == 1)
        {
          this.fast_write(numArray1, i, (int) (num1 >> 1) | int.MinValue, 4);
          i = length;
          length += 4;
          num1 = 2147483648U;
        }
        numArray1[length] = source[index1];
        ++index1;
        ++length;
        num1 >>= 1;
      }
      while (((int) num1 & 1) != 1)
        num1 >>= 1;
      this.fast_write(numArray1, i, (int) (num1 >> 1) | int.MinValue, 4);
      this.write_header(numArray1, level, true, Length, length);
      byte[] destinationArray = new byte[length];
      Array.Copy((Array) numArray1, (Array) destinationArray, length);
      return destinationArray;
    }

    private void fast_write(byte[] a, int i, int value, int numbytes)
    {
      for (int index = 0; index < numbytes; ++index)
        a[i + index] = (byte) (value >> index * 8);
    }

    public byte[] decompress(byte[] source, int Offset, int Length)
    {
      int length = this.sizeDecompressed(source, Offset);
      int index1 = this.headerLen(source, Offset) + Offset;
      int index2 = 0;
      uint num1 = 1;
      byte[] numArray1 = new byte[length];
      int[] numArray2 = new int[4096];
      byte[] numArray3 = new byte[4096];
      int num2 = length - 6 - 4 - 1;
      int index3 = -1;
      uint num3 = 0;
      int num4 = (int) source[Offset] >> 2 & 3;
      if (num4 != 1 && num4 != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      if (((int) source[Offset] & 1) != 1)
      {
        byte[] destinationArray = new byte[length];
        Array.Copy((Array) source, this.headerLen(source, Offset), (Array) destinationArray, Offset, length);
        return destinationArray;
      }
      while (true)
      {
        if (num1 == 1U)
        {
          num1 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
          index1 += 4;
          if (index2 <= num2)
            num3 = num4 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
        }
        if (((int) num1 & 1) == 1)
        {
          num1 >>= 1;
          uint index4;
          uint num5;
          if (num4 == 1)
          {
            int index5 = (int) num3 >> 4 & 4095;
            index4 = (uint) numArray2[index5];
            if ((num3 & 15U) > 0U)
            {
              num5 = (uint) (((int) num3 & 15) + 2);
              index1 += 2;
            }
            else
            {
              num5 = (uint) source[index1 + 2];
              index1 += 3;
            }
          }
          else
          {
            uint num6;
            if (((int) num3 & 3) == 0)
            {
              num6 = (num3 & (uint) byte.MaxValue) >> 2;
              num5 = 3U;
              ++index1;
            }
            else if (((int) num3 & 2) == 0)
            {
              num6 = (num3 & (uint) ushort.MaxValue) >> 2;
              num5 = 3U;
              index1 += 2;
            }
            else if (((int) num3 & 1) == 0)
            {
              num6 = (num3 & (uint) ushort.MaxValue) >> 6;
              num5 = (uint) (((int) (num3 >> 2) & 15) + 3);
              index1 += 2;
            }
            else if (((int) num3 & (int) sbyte.MaxValue) != 3)
            {
              num6 = num3 >> 7 & 131071U;
              num5 = (uint) (((int) (num3 >> 2) & 31) + 2);
              index1 += 3;
            }
            else
            {
              num6 = num3 >> 15;
              num5 = (uint) (((int) (num3 >> 7) & (int) byte.MaxValue) + 3);
              index1 += 4;
            }
            index4 = (uint) ((ulong) index2 - (ulong) num6);
          }
          numArray1[index2] = numArray1[(int) index4];
          numArray1[index2 + 1] = numArray1[(int) index4 + 1];
          numArray1[index2 + 2] = numArray1[(int) index4 + 2];
          for (int index6 = 3; (long) index6 < (long) num5; ++index6)
            numArray1[index2 + index6] = numArray1[(long) index4 + (long) index6];
          index2 += (int) num5;
          if (num4 == 1)
          {
            uint num7 = (uint) ((int) numArray1[index3 + 1] | (int) numArray1[index3 + 2] << 8 | (int) numArray1[index3 + 3] << 16);
            while ((long) index3 < (long) index2 - (long) num5)
            {
              ++index3;
              int index7 = ((int) (num7 >> 12) ^ (int) num7) & 4095;
              numArray2[index7] = index3;
              numArray3[index7] = (byte) 1;
              num7 = (uint) ((ulong) (num7 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) numArray1[index3 + 3] << 16));
            }
            num3 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
          }
          else
            num3 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
          index3 = index2 - 1;
        }
        else if (index2 <= num2)
        {
          numArray1[index2] = source[index1];
          ++index2;
          ++index1;
          num1 >>= 1;
          if (num4 == 1)
          {
            while (index3 < index2 - 3)
            {
              ++index3;
              int num8 = (int) numArray1[index3] | (int) numArray1[index3 + 1] << 8 | (int) numArray1[index3 + 2] << 16;
              int index8 = (num8 >> 12 ^ num8) & 4095;
              numArray2[index8] = index3;
              numArray3[index8] = (byte) 1;
            }
            num3 = (uint) ((ulong) (num3 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16));
          }
          else
            num3 = (uint) ((ulong) (num3 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16) | (ulong) ((int) source[index1 + 3] << 24));
        }
        else
          break;
      }
      while (index2 <= length - 1)
      {
        if (num1 == 1U)
        {
          index1 += 4;
          num1 = 2147483648U;
        }
        numArray1[index2] = source[index1];
        ++index2;
        ++index1;
        num1 >>= 1;
      }
      return numArray1;
    }
  }
}
