// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.InflaterHuffmanTree
// Assembly: Done, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EBE6DCED-6866-44D2-B309-A0C25849858B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Worm.MSIL.Autorun.jk-5bcc93e5d4639a5f95eb9ff6188099454019b185da8721fd79d0305ee3797532.exe

using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class InflaterHuffmanTree
  {
    private static int MAX_BITLEN = 15;
    private short[] tree;
    public static InflaterHuffmanTree defLitLenTree;
    public static InflaterHuffmanTree defDistTree;

    static InflaterHuffmanTree()
    {
      try
      {
        byte[] codeLengths1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          codeLengths1[num1++] = (byte) 8;
        while (num1 < 256)
          codeLengths1[num1++] = (byte) 9;
        while (num1 < 280)
          codeLengths1[num1++] = (byte) 7;
        while (num1 < 288)
          codeLengths1[num1++] = (byte) 8;
        InflaterHuffmanTree.defLitLenTree = new InflaterHuffmanTree(codeLengths1);
        byte[] codeLengths2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          codeLengths2[num2++] = (byte) 5;
        InflaterHuffmanTree.defDistTree = new InflaterHuffmanTree(codeLengths2);
      }
      catch (Exception ex)
      {
        throw new ApplicationException("InflaterHuffmanTree: static tree length illegal");
      }
    }

    public InflaterHuffmanTree(byte[] codeLengths) => this.BuildTree(codeLengths);

    private void BuildTree(byte[] codeLengths)
    {
      int[] numArray1 = new int[(int) checked ((uint) unchecked (InflaterHuffmanTree.MAX_BITLEN + 1))];
      int[] numArray2 = new int[(int) checked ((uint) unchecked (InflaterHuffmanTree.MAX_BITLEN + 1))];
      for (int index = 0; index < codeLengths.Length; ++index)
      {
        int codeLength = (int) codeLengths[index];
        if (codeLength > 0)
          ++numArray1[codeLength];
      }
      int num1 = 0;
      int length = 512;
      for (int index = 1; index <= InflaterHuffmanTree.MAX_BITLEN; ++index)
      {
        numArray2[index] = num1;
        num1 += numArray1[index] << 16 - index;
        if (index >= 10)
        {
          int num2 = numArray2[index] & 130944;
          int num3 = num1 & 130944;
          length += num3 - num2 >> 16 - index;
        }
      }
      if (num1 != 65536)
        throw new Exception("Code lengths don't add up properly.");
      this.tree = new short[(int) checked ((uint) length)];
      int num4 = 512;
      for (int maxBitlen = InflaterHuffmanTree.MAX_BITLEN; maxBitlen >= 10; --maxBitlen)
      {
        int num5 = num1 & 130944;
        num1 -= numArray1[maxBitlen] << 16 - maxBitlen;
        for (int index = num1 & 130944; index < num5; index += 128)
        {
          this.tree[(int) DeflaterHuffman.BitReverse(index)] = (short) (-num4 << 4 | maxBitlen);
          num4 += 1 << maxBitlen - 9;
        }
      }
      for (int index1 = 0; index1 < codeLengths.Length; ++index1)
      {
        int codeLength = (int) codeLengths[index1];
        if (codeLength != 0)
        {
          int num6 = numArray2[codeLength];
          int index2 = (int) DeflaterHuffman.BitReverse(num6);
          if (codeLength <= 9)
          {
            do
            {
              this.tree[index2] = (short) (index1 << 4 | codeLength);
              index2 += 1 << codeLength;
            }
            while (index2 < 512);
          }
          else
          {
            int num7 = (int) this.tree[index2 & 511];
            int num8 = 1 << (num7 & 15);
            int num9 = -(num7 >> 4);
            do
            {
              this.tree[num9 | index2 >> 9] = (short) (index1 << 4 | codeLength);
              index2 += 1 << codeLength;
            }
            while (index2 < num8);
          }
          numArray2[codeLength] = num6 + (1 << 16 - codeLength);
        }
      }
    }

    public int GetSymbol(StreamManipulator input)
    {
      int index;
      if ((index = input.PeekBits(9)) >= 0)
      {
        int num1;
        if ((num1 = (int) this.tree[index]) >= 0)
        {
          input.DropBits(num1 & 15);
          return num1 >> 4;
        }
        int num2 = -(num1 >> 4);
        int n = num1 & 15;
        int num3;
        if ((num3 = input.PeekBits(n)) >= 0)
        {
          int num4 = (int) this.tree[num2 | num3 >> 9];
          input.DropBits(num4 & 15);
          return num4 >> 4;
        }
        int availableBits = input.AvailableBits;
        int num5 = input.PeekBits(availableBits);
        int num6 = (int) this.tree[num2 | num5 >> 9];
        if ((num6 & 15) > availableBits)
          return -1;
        input.DropBits(num6 & 15);
        return num6 >> 4;
      }
      int availableBits1 = input.AvailableBits;
      int num = (int) this.tree[input.PeekBits(availableBits1)];
      if (num < 0 || (num & 15) > availableBits1)
        return -1;
      input.DropBits(num & 15);
      return num >> 4;
    }
  }
}
