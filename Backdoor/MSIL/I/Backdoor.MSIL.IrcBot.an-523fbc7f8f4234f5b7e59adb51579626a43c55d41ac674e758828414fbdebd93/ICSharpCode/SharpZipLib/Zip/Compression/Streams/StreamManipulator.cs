// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Streams.StreamManipulator
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
  public class StreamManipulator
  {
    private byte[] \uE004;
    private int \uE003;
    private int \uE002;
    private uint \uE001;
    private int \uE000;

    public int PeekBits(int bitCount)
    {
      if (this.\uE000 < bitCount)
      {
        if (this.\uE003 == this.\uE002)
          return -1;
        StreamManipulator streamManipulator1 = this;
        int num1 = (int) streamManipulator1.\uE001;
        byte[] numArray = this.\uE004;
        StreamManipulator streamManipulator2 = this;
        int num2;
        int num3 = num2 = streamManipulator2.\uE003;
        streamManipulator2.\uE003 = num2 + 1;
        int index = num3;
        int num4 = ((int) numArray[index] & (int) byte.MaxValue | ((int) this.\uE004[this.\uE003++] & (int) byte.MaxValue) << 8) << this.\uE000;
        streamManipulator1.\uE001 = (uint) (num1 | num4);
        this.\uE000 += 16;
      }
      return (int) ((long) this.\uE001 & (long) ((1 << bitCount) - 1));
    }

    public void DropBits(int bitCount)
    {
      this.\uE001 >>= bitCount;
      this.\uE000 -= bitCount;
    }

    public int GetBits(int bitCount)
    {
      int bits = this.PeekBits(bitCount);
      if (bits >= 0)
        this.DropBits(bitCount);
      return bits;
    }

    public int AvailableBits => this.\uE000;

    public int AvailableBytes => this.\uE002 - this.\uE003 + (this.\uE000 >> 3);

    public void SkipToByteBoundary()
    {
      this.\uE001 >>= this.\uE000 & 7;
      this.\uE000 &= -8;
    }

    public bool IsNeedingInput => this.\uE003 == this.\uE002;

    public int CopyBytes(byte[] output, int offset, int length)
    {
      if (length < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uF6B9\uF6B0\uF6BB\uF6B2\uF6A1\uF6BD", 63189));
      if ((this.\uE000 & 7) != 0)
        throw new InvalidOperationException(\uE01B.\uE000("\uF540\uF56B\uF576\uF522\uF560\uF577\uF564\uF564\uF567\uF570\uF522\uF56B\uF571\uF522\uF56C\uF56D\uF576\uF522\uF560\uF57B\uF576\uF567\uF522\uF563\uF56E\uF56B\uF565\uF56C\uF567\uF566\uF523", 62722));
      int num1 = 0;
      while (this.\uE000 > 0 && length > 0)
      {
        output[offset++] = (byte) this.\uE001;
        this.\uE001 >>= 8;
        this.\uE000 -= 8;
        --length;
        ++num1;
      }
      if (length == 0)
        return num1;
      int num2 = this.\uE002 - this.\uE003;
      if (length > num2)
        length = num2;
      Array.Copy((Array) this.\uE004, this.\uE003, (Array) output, offset, length);
      this.\uE003 += length;
      if ((this.\uE003 - this.\uE002 & 1) != 0)
      {
        this.\uE001 = (uint) this.\uE004[this.\uE003++] & (uint) byte.MaxValue;
        this.\uE000 = 8;
      }
      return num1 + length;
    }

    public void Reset()
    {
      this.\uE001 = 0U;
      this.\uE003 = this.\uE002 = this.\uE000 = 0;
    }

    public void SetInput(byte[] buffer, int offset, int count)
    {
      if (buffer == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uEDC8\uEDDF\uEDCC\uEDCC\uEDCF\uEDD8", 60842));
      if (offset < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uF201\uF208\uF208\uF21D\uF20B\uF21A", 62062), \uE01B.\uE000("\uF4AA\uF488\uF487\uF487\uF486\uF49D\uF4C9\uF48B\uF48C\uF4C9\uF487\uF48C\uF48E\uF488\uF49D\uF480\uF49F\uF48C", 62697));
      if (count < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uED5B\uED57\uED4D\uED56\uED4C", 60728), \uE01B.\uE000("\uF4AA\uF488\uF487\uF487\uF486\uF49D\uF4C9\uF48B\uF48C\uF4C9\uF487\uF48C\uF48E\uF488\uF49D\uF480\uF49F\uF48C", 62697));
      if (this.\uE003 < this.\uE002)
        throw new InvalidOperationException(\uE01B.\uE000("\uEC35\uEC16\uEC1E\uEC5A\uEC13\uEC14\uEC0A\uEC0F\uEC0E\uEC5A\uEC0D\uEC1B\uEC09\uEC5A\uEC14\uEC15\uEC0E\uEC5A\uEC19\uEC15\uEC17\uEC0A\uEC16\uEC1F\uEC0E\uEC1F\uEC16\uEC03\uEC5A\uEC0A\uEC08\uEC15\uEC19\uEC1F\uEC09\uEC09\uEC1F\uEC1E", 60538));
      int num = offset + count;
      if (offset > num || num > buffer.Length)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uED5B\uED57\uED4D\uED56\uED4C", 60728));
      if ((count & 1) != 0)
      {
        this.\uE001 |= (uint) (((int) buffer[offset++] & (int) byte.MaxValue) << this.\uE000);
        this.\uE000 += 8;
      }
      this.\uE004 = buffer;
      this.\uE003 = offset;
      this.\uE002 = num;
    }
  }
}
