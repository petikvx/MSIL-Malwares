// Decompiled with JetBrains decompiler
// Type: PCMightyMax2009.Core.Scan
// Assembly: Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3F47A863-2C3E-450E-BD40-DE96FBBFDAD1
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Trojan-FakeAV.MSIL.PCMightyMax.a-54ccacccf15d45ddcef8735bed4b4eef914134904670eb29390bfe43669a88fa.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading;

namespace PCMightyMax2009.Core
{
  public class Scan
  {
    private object RunningRootLock = new object();
    private static volatile Scan LocalInstance;
    private static object SyncLock = new object();

    public event Scan.SectionChangeEventHandler SectionChange;

    public string Name { get; set; }

    public List<ScanSection> Sections { get; set; }

    public ScanSection CurrentSection { get; set; }

    public ScanSection NextSection { get; set; }

    public ScanSection PreviousSection { get; set; }

    public bool Running { get; set; }

    public List<Error> Errors { get; set; }

    private Thread UnderlyingThread { get; set; }

    private Scan()
    {
      this.Name = "Regsitry Scan";
      this.CurrentSection = new ScanSection();
      this.PreviousSection = (ScanSection) null;
      this.NextSection = (ScanSection) null;
      this.Errors = new List<Error>();
      this.UnderlyingThread = new Thread(new ThreadStart(this.RunAsync));
    }

    public static Scan Instance
    {
      get
      {
        if (Scan.LocalInstance == null)
        {
          lock (Scan.SyncLock)
          {
            if (Scan.LocalInstance == null)
              Scan.LocalInstance = new Scan();
          }
        }
        return Scan.LocalInstance;
      }
    }

    private void Section_NewError(Error NewError)
    {
      lock (this.Errors)
        this.Errors.Add(NewError);
    }

    public void Run()
    {
      lock (this.RunningRootLock)
      {
        if (this.Running)
          return;
        this.Running = true;
        this.UnderlyingThread = new Thread(new ThreadStart(this.RunAsync));
        this.UnderlyingThread.Start();
      }
    }

    public void ForceStop()
    {
      lock (this.RunningRootLock)
      {
        this.UnderlyingThread.Abort();
        foreach (ScanSection section in this.Sections)
          section.Cancel = true;
        this.Running = false;
      }
    }

    private void RunAsync()
    {
      this.Errors = new List<Error>();
      foreach (ScanSection section in this.Sections)
        section.Errors = new List<Error>();
      foreach (ScanSection section in this.Sections)
        section.NewError += new ScanSection.NewErrorEventHandler(this.Section_NewError);
      lock (this.Errors)
        this.Errors = new List<Error>();
      Scan.SectionChangeEventArgs Args = new Scan.SectionChangeEventArgs();
      for (int index = 0; index < this.Sections.Count; ++index)
      {
        ScanSection section = this.Sections[index];
        Args.Current = section.Name;
        if (index > 0)
        {
          Args.Previous = this.Sections[index - 1].Name;
          this.PreviousSection = this.Sections[index - 1];
        }
        if (index < this.Sections.Count - 1)
        {
          Args.Next = this.Sections[index + 1].Name;
          this.NextSection = this.Sections[index + 1];
        }
        if (this.SectionChange != null)
          this.SectionChange(Args);
        section.Cancel = false;
        this.CurrentSection = section;
        Thread thread = new Thread(new ThreadStart(section.Run));
        thread.Priority = ThreadPriority.BelowNormal;
        thread.Start();
        DateTime now1 = DateTime.Now;
        while (thread.IsAlive)
        {
          Thread.Sleep(50);
          if ((DateTime.Now - now1).TotalSeconds > (double) this.CurrentSection.Timeout)
          {
            this.CurrentSection.Cancel = true;
            DateTime now2 = DateTime.Now;
            while (thread.IsAlive)
            {
              Thread.Sleep(50);
              if ((DateTime.Now - now2).TotalMilliseconds > 2000.0)
                thread.Abort();
            }
          }
        }
      }
      Stream serializationStream = (Stream) null;
      try
      {
        string str = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\PCMM2009\\diagnostic";
        if (!Directory.Exists(str))
          Directory.CreateDirectory(str);
        serializationStream = (Stream) new FileStream(Path.Combine(str, "last-scan"), FileMode.Create);
        new BinaryFormatter().Serialize(serializationStream, (object) this.Errors);
      }
      catch
      {
      }
      finally
      {
        serializationStream?.Close();
      }
      this.Running = false;
    }

    public delegate void SectionChangeEventHandler(Scan.SectionChangeEventArgs Args);

    public class SectionChangeEventArgs : EventArgs
    {
      public string Previous { get; set; }

      public string Current { get; set; }

      public string Next { get; set; }
    }
  }
}
