// Decompiled with JetBrains decompiler
// Type: 
// Assembly: honte, Version=1.3.1.2, Culture=neutral, PublicKeyToken=null
// MVID: 07496AF3-8F6C-A2E0-30EF-5C9917718EBE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.Witch.gen-8ccd2737842b65b2f0fd5418bbb2e17803cb1866860d679d6ef3b2b8acfc8b44.exe

using System;
using System.Security.Cryptography;

internal sealed class \uE009 : SymmetricAlgorithm, ICryptoTransform, IDisposable
{
  private Random \uE002;

  public \uE009()
  {
    this.\uE002 = new Random(DateTime.Now.Millisecond);
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.KeySize = 128;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.BlockSize = 128;
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override void GenerateIV()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.IV = buffer;
  }

  public override void GenerateKey()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.Key = buffer;
  }

  public int TransformBlock(
    byte[] _param1,
    int _param2,
    int _param3,
    byte[] _param4,
    int _param5)
  {
    int length1 = this.Key.Length;
    int length2 = this.IV.Length;
    for (int index = 0; index < _param3; ++index)
    {
      int num = (int) this.IV[index % length2];
      _param4[index + _param5] = (byte) ((uint) _param1[index + _param2] ^ (uint) this.Key[num % length1]);
    }
    return _param3;
  }

  public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
  {
    byte[] numArray = new byte[_param3];
    this.TransformBlock(_param1, _param2, _param3, numArray, 0);
    return numArray;
  }

  public bool CanReuseTransform => true;

  public bool CanTransformMultipleBlocks => true;

  public int InputBlockSize => 16;

  public int OutputBlockSize => 16;

  internal static int \uE004(int _param0)
  {
    int num = _param0;
    switch (num - -((-738280468 >> 2) + 184570088))
    {
      case 0:
        return 545670004 ^ 545669963;
      case 1:
      case 2:
label_10:
        return -(4 >> 2);
      case 3:
        return 271638017 - 189546025 - 82091992 >> 3;
      case 4:
        return ~-65 >> 5;
      default:
        switch (num - (420291928 - 420290680 >> 5))
        {
          case 0:
            return (438615053 - 85744261 >> 2) - 88217695;
          case 1:
            goto label_10;
          case 2:
            return -452823454 ^ 52395534 ^ 434304937;
          case 3:
            return -521983863 - -521984311 >> 4;
          default:
            if (num == -(17508846 - 17508894))
              return -(32652044 - 32652049);
            goto label_10;
        }
    }
  }
}
