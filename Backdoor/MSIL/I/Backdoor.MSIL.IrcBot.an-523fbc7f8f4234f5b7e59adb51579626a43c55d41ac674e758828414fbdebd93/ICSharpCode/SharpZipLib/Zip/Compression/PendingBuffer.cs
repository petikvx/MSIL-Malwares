// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.PendingBuffer
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class PendingBuffer
  {
    private byte[] \uE004;
    private int \uE003;
    private int \uE002;
    private uint \uE001;
    private int \uE000;

    public PendingBuffer()
      : this(4096)
    {
    }

    public PendingBuffer(int bufferSize) => this.\uE004 = new byte[bufferSize];

    public void Reset() => this.\uE003 = this.\uE002 = this.\uE000 = 0;

    public void WriteByte(int value)
    {
      byte[] numArray = this.\uE004;
      PendingBuffer pendingBuffer = this;
      int num1;
      int num2 = num1 = pendingBuffer.\uE002;
      pendingBuffer.\uE002 = num1 + 1;
      int index = num2;
      int num3 = (int) (byte) value;
      numArray[index] = (byte) num3;
    }

    public void WriteShort(int value)
    {
      byte[] numArray1 = this.\uE004;
      PendingBuffer pendingBuffer1 = this;
      int num1;
      int num2 = num1 = pendingBuffer1.\uE002;
      pendingBuffer1.\uE002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) value;
      numArray1[index1] = (byte) num3;
      byte[] numArray2 = this.\uE004;
      PendingBuffer pendingBuffer2 = this;
      int num4;
      int num5 = num4 = pendingBuffer2.\uE002;
      pendingBuffer2.\uE002 = num4 + 1;
      int index2 = num5;
      int num6 = (int) (byte) (value >> 8);
      numArray2[index2] = (byte) num6;
    }

    public void WriteInt(int value)
    {
      byte[] numArray1 = this.\uE004;
      PendingBuffer pendingBuffer1 = this;
      int num1;
      int num2 = num1 = pendingBuffer1.\uE002;
      pendingBuffer1.\uE002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) value;
      numArray1[index1] = (byte) num3;
      byte[] numArray2 = this.\uE004;
      PendingBuffer pendingBuffer2 = this;
      int num4;
      int num5 = num4 = pendingBuffer2.\uE002;
      pendingBuffer2.\uE002 = num4 + 1;
      int index2 = num5;
      int num6 = (int) (byte) (value >> 8);
      numArray2[index2] = (byte) num6;
      this.\uE004[this.\uE002++] = (byte) (value >> 16);
      this.\uE004[this.\uE002++] = (byte) (value >> 24);
    }

    public void WriteBlock(byte[] block, int offset, int length)
    {
      Array.Copy((Array) block, offset, (Array) this.\uE004, this.\uE002, length);
      this.\uE002 += length;
    }

    public int BitCount => this.\uE000;

    public void AlignToByte()
    {
      if (this.\uE000 > 0)
      {
        byte[] numArray = this.\uE004;
        PendingBuffer pendingBuffer = this;
        int num1;
        int num2 = num1 = pendingBuffer.\uE002;
        pendingBuffer.\uE002 = num1 + 1;
        int index = num2;
        int num3 = (int) (byte) this.\uE001;
        numArray[index] = (byte) num3;
        if (this.\uE000 > 8)
          this.\uE004[this.\uE002++] = (byte) (this.\uE001 >> 8);
      }
      this.\uE001 = 0U;
      this.\uE000 = 0;
    }

    public void WriteBits(int b, int count)
    {
      this.\uE001 |= (uint) (b << this.\uE000);
      this.\uE000 += count;
      if (this.\uE000 < 16)
        return;
      this.\uE004[this.\uE002++] = (byte) this.\uE001;
      this.\uE004[this.\uE002++] = (byte) (this.\uE001 >> 8);
      this.\uE001 >>= 16;
      this.\uE000 -= 16;
    }

    public void WriteShortMSB(int s)
    {
      byte[] numArray1 = this.\uE004;
      PendingBuffer pendingBuffer1 = this;
      int num1;
      int num2 = num1 = pendingBuffer1.\uE002;
      pendingBuffer1.\uE002 = num1 + 1;
      int index1 = num2;
      int num3 = (int) (byte) (s >> 8);
      numArray1[index1] = (byte) num3;
      byte[] numArray2 = this.\uE004;
      PendingBuffer pendingBuffer2 = this;
      int num4;
      int num5 = num4 = pendingBuffer2.\uE002;
      pendingBuffer2.\uE002 = num4 + 1;
      int index2 = num5;
      int num6 = (int) (byte) s;
      numArray2[index2] = (byte) num6;
    }

    public bool IsFlushed => this.\uE002 == 0;

    public int Flush(byte[] output, int offset, int length)
    {
      if (this.\uE000 >= 8)
      {
        byte[] numArray = this.\uE004;
        PendingBuffer pendingBuffer = this;
        int num1;
        int num2 = num1 = pendingBuffer.\uE002;
        pendingBuffer.\uE002 = num1 + 1;
        int index = num2;
        int num3 = (int) (byte) this.\uE001;
        numArray[index] = (byte) num3;
        this.\uE001 >>= 8;
        this.\uE000 -= 8;
      }
      if (length > this.\uE002 - this.\uE003)
      {
        length = this.\uE002 - this.\uE003;
        Array.Copy((Array) this.\uE004, this.\uE003, (Array) output, offset, length);
        this.\uE003 = 0;
        this.\uE002 = 0;
      }
      else
      {
        Array.Copy((Array) this.\uE004, this.\uE003, (Array) output, offset, length);
        this.\uE003 += length;
      }
      return length;
    }

    public byte[] ToByteArray()
    {
      byte[] destinationArray = new byte[this.\uE002 - this.\uE003];
      Array.Copy((Array) this.\uE004, this.\uE003, (Array) destinationArray, 0, destinationArray.Length);
      this.\uE003 = 0;
      this.\uE002 = 0;
      return destinationArray;
    }
  }
}
