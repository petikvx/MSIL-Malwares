// Decompiled with JetBrains decompiler
// Type:  
// Assembly: JapaneseLunisolarCalen, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E43E91C1-4CDC-4FD4-0BBD-3A99135401E0
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-7da585f221381494431723c3c35838c7e82c563f22e16fb806a5e63ed2fe7ce6.exe

using System;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;

public static class \u0008\u2006
{
  private static readonly Regex \u0002 = new Regex(\u0008\u200A.\u0002(-539151385), RegexOptions.Compiled | RegexOptions.Singleline);
  private static readonly Regex \u0003 = new Regex(\u0008\u200A.\u0002(-539151393), RegexOptions.Compiled | RegexOptions.Singleline);
  private static readonly Regex \u0005 = new Regex(\u0008\u200A.\u0002(-539152277), RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.CultureInvariant);
  private static readonly char[] \u0008 = new char[37]
  {
    ';',
    '/',
    '\\',
    '?',
    ':',
    '@',
    '&',
    '=',
    '+',
    '$',
    ',',
    '<',
    '>',
    '#',
    '%',
    '.',
    '!',
    '*',
    '\'',
    '"',
    '(',
    ')',
    '[',
    ']',
    '{',
    '}',
    '|',
    '^',
    '`',
    '~',
    '–',
    '‘',
    '’',
    '“',
    '”',
    '»',
    '«'
  };

  [DebuggerStepThrough]
  public static bool \u0002(this string _param0) => !string.IsNullOrEmpty(_param0) && \u0008\u2006.\u0002.IsMatch(_param0);

  [DebuggerStepThrough]
  public static bool \u0003(this string _param0) => !string.IsNullOrEmpty(_param0) && \u0008\u2006.\u0003.IsMatch(_param0);

  public static string \u0002(this string _param0)
  {
    try
    {
      return (_param0 ?? string.Empty).Trim();
    }
    catch
    {
      throw;
    }
  }

  [DebuggerStepThrough]
  public static string \u0002(this string _param0, object[] _param1)
  {
    \u0008\u2002.\u0002.\u0002(_param0, \u0008\u200A.\u0002(-539151539));
    return string.Format((IFormatProvider) \u0006\u2002.\u0002(), _param0, _param1);
  }

  [DebuggerStepThrough]
  public static string \u0003(this string _param0)
  {
    \u0008\u2002.\u0002.\u0002(_param0, \u0008\u200A.\u0002(-539151539));
    using (MD5 md5 = MD5.Create())
    {
      byte[] bytes = Encoding.Unicode.GetBytes(_param0);
      return Convert.ToBase64String(md5.ComputeHash(bytes));
    }
  }

  [DebuggerStepThrough]
  public static string \u0002(this string _param0, int _param1)
  {
    if (string.IsNullOrEmpty(_param0))
      return string.Empty;
    \u0008\u2002.\u0002.\u0003(_param1, \u0008\u200A.\u0002(-539152264));
    return _param0.Length > _param1 ? _param0.Substring(0, _param1 - 3) + new string('.', 3) : _param0;
  }

  [DebuggerStepThrough]
  public static string \u0005(this string _param0) => \u0008\u2006.\u0005.Replace(_param0, string.Empty);

  public static Guid \u0002(this string _param0)
  {
    Guid guid = Guid.Empty;
    if (!string.IsNullOrEmpty(_param0) && _param0.Trim().Length == 22)
    {
      string s = _param0.Trim().Replace('-', '+').Replace('_', '/') + \u0008\u200A.\u0002(-539152316);
      try
      {
        guid = new Guid(Convert.FromBase64String(s));
      }
      catch (FormatException ex)
      {
      }
    }
    else
    {
      try
      {
        guid = new Guid(_param0);
      }
      catch
      {
      }
    }
    return guid;
  }

  [DebuggerStepThrough]
  public static T \u0002<T>(this string _param0, T _param1) where T : IComparable, IFormattable
  {
    T obj = _param1;
    if (!string.IsNullOrEmpty(_param0))
    {
      try
      {
        obj = (T) Enum.Parse(typeof (T), _param0.Trim(), true);
      }
      catch (ArgumentException ex)
      {
      }
    }
    return obj;
  }

  [DebuggerStepThrough]
  public static string \u0008(this string _param0)
  {
    if (string.IsNullOrEmpty(_param0))
      return _param0;
    _param0 = _param0.Trim();
    if (_param0.IndexOfAny(\u0008\u2006.\u0008) > -1)
    {
      foreach (char ch in \u0008\u2006.\u0008)
        _param0 = _param0.Replace(ch.ToString((IFormatProvider) \u0006\u2002.\u0002()), string.Empty);
    }
    _param0 = _param0.Replace(' ', '-');
    while (_param0.Contains(\u0008\u200A.\u0002(-539152307)))
      _param0 = _param0.Replace(\u0008\u200A.\u0002(-539152307), \u0008\u200A.\u0002(-539152294));
    return _param0;
  }

  [DebuggerStepThrough]
  public static string \u0006(this string _param0) => HttpUtility.UrlEncode(_param0);

  [DebuggerStepThrough]
  public static string \u000E(this string _param0) => HttpUtility.UrlDecode(_param0);

  [DebuggerStepThrough]
  public static string \u000F(this string _param0) => HttpUtility.HtmlAttributeEncode(_param0);

  [DebuggerStepThrough]
  public static string \u0002\u2000(this string _param0) => HttpUtility.HtmlEncode(_param0);

  [DebuggerStepThrough]
  public static string \u0003\u2000(this string _param0) => HttpUtility.HtmlDecode(_param0);
}
