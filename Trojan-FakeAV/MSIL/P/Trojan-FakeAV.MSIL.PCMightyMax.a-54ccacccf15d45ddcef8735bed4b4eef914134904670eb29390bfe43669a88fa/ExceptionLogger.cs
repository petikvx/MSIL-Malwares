// Decompiled with JetBrains decompiler
// Type: PCMightyMax2009.Core.ExceptionLogger
// Assembly: Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3F47A863-2C3E-450E-BD40-DE96FBBFDAD1
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Trojan-FakeAV.MSIL.PCMightyMax.a-54ccacccf15d45ddcef8735bed4b4eef914134904670eb29390bfe43669a88fa.exe

using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows.Forms;

namespace PCMightyMax2009.Core
{
  public static class ExceptionLogger
  {
    private static bool __Enabled = false;

    public static int Count { get; set; }

    public static bool Enabled
    {
      get => ExceptionLogger.__Enabled;
      set
      {
        ExceptionLogger.__Enabled = value;
        if (ExceptionLogger.Enabled)
        {
          try
          {
            File.Delete("pcmm2009.error.log");
          }
          catch
          {
          }
          ExceptionLogger.Count = 0;
          Application.ThreadException += new ThreadExceptionEventHandler(ExceptionLogger.ThreadExceptionHandler);
          AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(ExceptionLogger.UnhandledExceptionHandler);
        }
        else
        {
          Application.ThreadException -= new ThreadExceptionEventHandler(ExceptionLogger.ThreadExceptionHandler);
          AppDomain.CurrentDomain.UnhandledException -= new UnhandledExceptionEventHandler(ExceptionLogger.UnhandledExceptionHandler);
        }
      }
    }

    private static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e) => ExceptionLogger.LogExceptionDetail((Exception) e.ExceptionObject);

    public static void ThreadExceptionHandler(object sender, ThreadExceptionEventArgs e) => ExceptionLogger.LogExceptionDetail(e.Exception);

    public static string LogExceptionDetail(Exception ex)
    {
      ++ExceptionLogger.Count;
      string str1 = "" + "An unhandled exception occurred at " + (object) DateTime.Now + Environment.NewLine + "Exception Type: " + (object) ex.GetType() + Environment.NewLine + Environment.NewLine;
      for (; ex != null; ex = ex.InnerException)
      {
        StackTrace stackTrace = new StackTrace(ex);
        for (int index1 = 0; index1 < stackTrace.FrameCount; ++index1)
        {
          StackFrame frame = stackTrace.GetFrame(index1);
          MethodBase method = frame.GetMethod();
          string str2 = "";
          if (method.IsPublic)
            str2 += "public ";
          if (method.IsPrivate)
            str2 += "private ";
          if (method.IsStatic)
            str2 += "static ";
          if (method.IsVirtual)
            str2 += "virtual ";
          if (method.IsAbstract)
            str2 += "abstract ";
          if (!method.IsConstructor)
            str2 = str2 + ExceptionLogger.FormatType(method.ReflectedType.ToString()) + " ";
          string str3 = str2 + method.Name + "(";
          ParameterInfo[] parameters = method.GetParameters();
          for (int index2 = 0; index2 < parameters.Length; ++index2)
          {
            if (parameters[index2].IsOut)
              str3 += "out ";
            if (parameters[index2].IsRetval)
              str3 += "ref ";
            str3 = str3 + ExceptionLogger.FormatType(parameters[index2].ParameterType.ToString()) + " " + parameters[index2].Name;
            if (index2 < parameters.Length - 1)
              str3 += ", ";
          }
          string str4 = str3 + ")";
          str1 = str1 + "ASSEMBLY: " + method.Module.Assembly.FullName + Environment.NewLine + "LINE:     " + (object) frame.GetFileLineNumber() + Environment.NewLine + "COL:      " + (object) frame.GetFileColumnNumber() + Environment.NewLine + "METHOD:   " + str4 + Environment.NewLine + Environment.NewLine;
        }
      }
      StreamWriter text = File.CreateText("pcmm2009.error.log");
      text.Write(str1 + Environment.NewLine + Environment.NewLine);
      text.Close();
      return str1;
    }

    private static string FormatType(string Type) => !Regex.IsMatch(Type.ToString(), ".*\\.(.+)") ? Type : Regex.Match(Type.ToString(), ".*\\.(.+)").Groups[1].Value;
  }
}
