// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: Mains, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 87A24014-4235-4CFD-B5E9-8BC1446D37FE
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Trojan.Win32.Llac.cnsu-4e1dc6093bc57a5c8b4925024069a0aece2ca0eeafeaa231cb005e4ab35d5025.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Text;

internal class \u003CModule\u003E
{
  static Dictionary<uint, object> \u29E5朗\u1A9F惵돀ួ\uEAE8鹣;
  static MemoryStream \uA63Aᭅ崱惫\uE203뱛\uF61C㕋;

  internal static object I\uFFFDK\uFFFDc\uFFFD\u0004\u002E\u001A\uFFFD̩29\uFFFD(uint id)
  {
    if (\u003CModule\u003E.\u29E5朗\u1A9F惵돀ួ\uEAE8鹣 == null)
    {
      \u003CModule\u003E.\u29E5朗\u1A9F惵돀ួ\uEAE8鹣 = new Dictionary<uint, object>();
      \u003CModule\u003E.\uA63Aᭅ崱惫\uE203뱛\uF61C㕋 = new MemoryStream();
      using (DeflateStream deflateStream = new DeflateStream(Assembly.GetCallingAssembly().GetManifestResourceStream("\u0013{b�\u0019\u007F;@��_��4A"), CompressionMode.Decompress))
      {
        byte[] buffer = new byte[4096];
        int count = deflateStream.Read(buffer, 0, 4096);
        do
        {
          \u003CModule\u003E.\uA63Aᭅ崱惫\uE203뱛\uF61C㕋.Write(buffer, 0, count);
          count = deflateStream.Read(buffer, 0, 4096);
        }
        while (count != 0);
      }
    }
    uint num1 = 896700533U ^ (uint) new StackFrame(1).GetMethod().MetadataToken;
    uint num2 = 1213026187;
    uint num3 = 1552324369;
    for (uint index = 1; index <= 64U; ++index)
    {
      num1 = (uint) (((int) num1 & 16777215) << 8) | (num1 & 4278190080U) >> 24;
      uint num4 = (num1 & (uint) byte.MaxValue) % 64U;
      if (num4 >= 0U && num4 < 16U)
      {
        num2 |= (uint) ((int) ((num1 & 65280U) >> 8) & (int) ((num1 & 16711680U) >> 16) ^ ~(int) num1 & (int) byte.MaxValue);
        num3 ^= (uint) ((int) num1 * (int) index + 1) % 16U;
        num1 += (uint) (((int) num2 | (int) num3) ^ 1782586712);
      }
      else if (num4 >= 16U && num4 < 32U)
      {
        num2 ^= (uint) (((int) num1 & 16711935) << 8 ^ ((int) ((num1 & 16776960U) >> 8) | ~(int) num1 & (int) ushort.MaxValue));
        num3 += num1 * index % 32U;
        num1 |= (uint) ((int) num2 + ~(int) num3 & 1782586712);
      }
      else if (num4 >= 32U && num4 < 48U)
      {
        num2 += (uint) (((int) num1 & (int) byte.MaxValue | (int) ((num1 & 16711680U) >> 16)) + (~(int) num1 & (int) byte.MaxValue));
        num3 -= (uint) ~((int) num1 + (int) num4) % 48U;
        num1 ^= num2 % num3 | 1782586712U;
      }
      else if (num4 >= 48U && num4 < 64U)
      {
        num2 ^= (uint) (((int) ((num1 & 16711680U) >> 16) | ~((int) num1 & (int) byte.MaxValue)) * (~(int) num1 & 16711680));
        num3 += (num1 ^ index - 1U) % num4;
        num1 -= (uint) (~((int) num2 ^ (int) num3) + 1782586712);
      }
    }
    uint num5 = num1 ^ id;
    object obj;
    if (!\u003CModule\u003E.\u29E5朗\u1A9F惵돀ួ\uEAE8鹣.TryGetValue(num5, out obj))
    {
      BinaryReader binaryReader = new BinaryReader((Stream) \u003CModule\u003E.\uA63Aᭅ崱惫\uE203뱛\uF61C㕋);
      binaryReader.BaseStream.Seek((long) num5, SeekOrigin.Begin);
      byte num6 = binaryReader.ReadByte();
      byte[] bytes = binaryReader.ReadBytes(binaryReader.ReadInt32());
      uint num7 = 1782586712U ^ num5;
      ushort num8 = (ushort) (num7 >> 16);
      ushort num9 = (ushort) (num7 & (uint) ushort.MaxValue);
      ushort num10 = num9;
      ushort num11 = num8;
      for (int index = 0; index < bytes.Length; ++index)
      {
        bytes[index] ^= (byte) ((num7 * (uint) num10 + (uint) num11) % 256U);
        num10 = (ushort) ((num7 * (uint) num10 + (uint) num8) % 65536U);
        num11 = (ushort) ((num7 * (uint) num11 + (uint) num9) % 65536U);
      }
      switch (num6)
      {
        case 37:
          obj = (object) Encoding.UTF8.GetString(bytes);
          break;
        case 141:
          obj = (object) BitConverter.ToDouble(bytes, 0);
          break;
        case 206:
          obj = (object) BitConverter.ToInt64(bytes, 0);
          break;
        case 235:
          obj = (object) BitConverter.ToSingle(bytes, 0);
          break;
        case byte.MaxValue:
          obj = (object) BitConverter.ToInt32(bytes, 0);
          break;
      }
      \u003CModule\u003E.\u29E5朗\u1A9F惵돀ួ\uEAE8鹣[num5] = obj;
    }
    return obj;
  }
}
