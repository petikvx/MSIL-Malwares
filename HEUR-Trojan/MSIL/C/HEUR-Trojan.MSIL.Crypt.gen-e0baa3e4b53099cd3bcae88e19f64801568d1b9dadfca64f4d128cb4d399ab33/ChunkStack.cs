// Decompiled with JetBrains decompiler
// Type: D3DHelper.ChunkStack
// Assembly: XOBK, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 44C15233-611E-47F9-925F-576321862E3D
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.Crypt.gen-e0baa3e4b53099cd3bcae88e19f64801568d1b9dadfca64f4d128cb4d399ab33.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;

namespace D3DHelper
{
  internal class ChunkStack
  {
    private Stack<ChunkMarker> m_Stack;
    private IFFWriter m_Writer;

    public ChunkStack(IFFWriter Writer)
    {
      if (Writer == null)
        throw new ArgumentNullException(nameof (Writer));
      this.m_Stack = new Stack<ChunkMarker>();
      this.m_Writer = Writer;
    }

    public void Push(string ID, ChunkType Type, uint Version = 0)
    {
      try
      {
        ChunkAttributes chunkAttributes = new ChunkAttributes(ID, 0, Type, Version);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        throw ex;
      }
      this.m_Stack.Push(new ChunkMarker()
      {
        ID = ID,
        Type = Type,
        StartPosition = checked (this.m_Writer.BaseStream.Position + 8L)
      });
      switch (Type)
      {
        case ChunkType.Normal:
          this.m_Writer.Write("NRML", 4);
          this.m_Writer.WriteUInt32<int>(0);
          this.m_Writer.Write(ID, 4);
          this.m_Writer.WriteUInt32<uint>(ChunkStack.__swap(Version));
          break;
        case ChunkType.Form:
          this.m_Writer.Write("FORM", 4);
          this.m_Writer.WriteUInt32<int>(0);
          this.m_Writer.Write(ID, 4);
          break;
        default:
          this.m_Writer.Write(ID, 4);
          this.m_Writer.WriteUInt32<int>(0);
          break;
      }
    }

    public ChunkMarker Pop()
    {
      ChunkMarker chunkMarker = this.m_Stack.Count != 0 ? this.m_Stack.Pop() : throw new Exception("No chunk to pop.");
      long position = this.m_Writer.BaseStream.Position;
      uint v = checked ((uint) (position - chunkMarker.StartPosition));
      this.m_Writer.BaseStream.Position = checked (chunkMarker.StartPosition - 4L);
      this.m_Writer.WriteUInt32<uint>(ChunkStack.__swap(v));
      this.m_Writer.BaseStream.Position = position;
      return chunkMarker;
    }

    private static uint __swap(uint v) => (uint) ((int) checked ((uint) (((long) v & -16777216L) >> 24)) | (int) checked ((uint) (((long) v & 16711680L) >> 16)) << 8 | (int) checked ((uint) (((long) v & 65280L) >> 8)) << 16 | (int) checked ((uint) ((long) v & (long) byte.MaxValue)) << 24);
  }
}
