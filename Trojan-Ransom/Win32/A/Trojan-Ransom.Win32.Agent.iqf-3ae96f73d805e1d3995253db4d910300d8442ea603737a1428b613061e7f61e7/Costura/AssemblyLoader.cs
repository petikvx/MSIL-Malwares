// Decompiled with JetBrains decompiler
// Type: Costura.AssemblyLoader
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 628485CE-1750-4702-9367-C5FFF8321F79
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\Trojan-Ransom.Win32.Agent.iqf-3ae96f73d805e1d3995253db4d910300d8442ea603737a1428b613061e7f61e7.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Costura
{
  [CompilerGenerated]
  internal static class AssemblyLoader
  {
    private static readonly Dictionary<string, bool> nullCache;
    private static readonly Dictionary<string, string> assemblyNames;
    private static readonly Dictionary<string, string> symbolNames;
    private static ResolveEventHandler CS\u0024\u003C\u003E9__CachedAnonymousMethodDelegate1;

    private static string CultureToString(CultureInfo culture)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Assembly ReadExistingAssembly(AssemblyName name)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void CopyTo(Stream source, Stream destination)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Stream LoadStream(string fullname)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Stream LoadStream(Dictionary<string, string> resourceNames, string name)
    {
      // ISSUE: unable to decompile the method.
    }

    private static byte[] ReadStream(Stream stream)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Assembly ReadFromEmbeddedResources(
      Dictionary<string, string> assemblyNames,
      Dictionary<string, string> symbolNames,
      AssemblyName requestedAssemblyName)
    {
      // ISSUE: unable to decompile the method.
    }

    public static Assembly ResolveAssembly(string assemblyName)
    {
      // ISSUE: unable to decompile the method.
    }

    static AssemblyLoader()
    {
      // ISSUE: unable to decompile the method.
    }

    private static Assembly \u003CAttach\u003Eb__0(object s, ResolveEventArgs e)
    {
      // ISSUE: unable to decompile the method.
    }

    public static void Attach()
    {
      // ISSUE: unable to decompile the method.
    }

    static string \u202C‪⁯‭⁭‬⁫‮‭‏‏‏⁯⁮⁮⁮‍⁬⁬‫‌‫​⁭‍‫⁫‍⁯⁭‌‫⁮‌‎‎⁯‪‏‌‮([In] CultureInfo obj0) => obj0.Name;

    static AppDomain \u206B‫‏​‭​⁬⁫‏‎‭⁯‌⁯‍‪⁮‭‏⁪‬‍⁪​‍‌⁬⁮⁫‏‎‭‎⁪‬⁭‪⁪‮‎‮() => AppDomain.CurrentDomain;

    static Assembly[] \u206E‬​‎​‫‬⁬⁪⁪‏‎⁫‪⁭‏‮⁪‬‪⁭‬‌‬‏‭‎‍‭⁯‎⁮‪‎⁬‭⁬⁮‬⁪‮([In] AppDomain obj0) => obj0.GetAssemblies();

    static AssemblyName \u200B⁯⁭⁪‪‬⁫‎‬​⁫‎‏⁮⁮⁭‏‫⁯‍⁫‌⁪⁪‏‏‍⁮​⁪‪​⁭⁭‬⁯⁬⁭​⁭‮([In] Assembly obj0) => obj0.GetName();

    static string \u202D‎⁫⁪‪⁯‮⁯‎‭⁭​⁫⁫‬‌​‪‬‍‍⁪‍‬⁪‪‬⁮‪‪⁭‎⁪⁪⁭⁬‮​⁫‪‮([In] AssemblyName obj0) => obj0.Name;

    static bool \u200F‭⁯‪⁪​​⁬‍‭​‏​‍‪‫‎⁯‭⁭‪‫⁭‭‎‫‌‪‎‌‮‭‌‬⁫‬⁫⁯‎‌‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return string.Equals(obj0, obj1, obj2);
    }

    static CultureInfo \u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮([In] AssemblyName obj0) => obj0.CultureInfo;

    static void \u206F‍‫‭⁭‪⁫‌‮‍‏‌‬‫‬‍‌‌‏‌⁯‬​‮‭‪⁮⁮‎⁯⁯⁬⁬‎⁬‍‭‭​⁯‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static int \u206B‮‫‪⁪‍⁭⁫‪‪​‌⁮‏‍‍‎‏⁬‪‬‌⁮‭⁮‪‏‮⁬‭‭⁮‍‪‫‫‪‌‫⁯‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static Assembly \u200B‮​⁮‍‏⁯⁭‪⁯‭​‌‎⁮‫‌​‍‌‫‏‬‭‪‮​‍⁪‏⁫⁯‎⁫‎⁯⁪⁮‮‬‮() => Assembly.GetExecutingAssembly();

    static bool \u200E⁫⁬‍‎‌⁫‫⁯⁯‌⁮‍‭⁪‫‭‪‏⁬‮⁪​⁬‭‍⁪‭‬⁬‮⁭⁯‭‭‌⁬​⁯⁮‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static Stream \u202C‭⁭‌‍‬‭⁫⁬⁪‪‭​‏‍‌‮⁯‬‌‪​‎⁭​⁮‏‪⁭⁯‍‪⁮⁪⁭⁯‪‎‫‪‮([In] Assembly obj0, [In] string obj1) => obj0.GetManifestResourceStream(obj1);

    static DeflateStream \u202B⁫​⁪‪‬‌‍⁮‎⁬‍‮⁮‫‫‏⁬​⁮​⁮‫⁮‭‌‏⁪‪‭⁮⁯⁬‍‮‏⁯⁮⁯⁮‮(
      [In] Stream obj0,
      [In] CompressionMode obj1)
    {
      return new DeflateStream(obj0, obj1);
    }

    static MemoryStream \u206B​⁮⁮⁫‫‎‌‮⁫⁯‍⁬‪⁫‫‬‍⁪⁯‌⁮⁮‬⁯‫⁮‪⁬‫​‮⁯⁪⁮⁭‎‎⁪‮‮() => new MemoryStream();

    static void \u206D⁪‪‫‭‎‮‏‌‌‫​‏‬⁫⁪‎‮‌‬⁫‎⁯⁬⁯‬‬⁬⁭⁬‌‌‬‬​‫‪‌‭‫‮([In] Stream obj0, [In] long obj1) => obj0.Position = obj1;

    static void \u206D⁯‬⁮​‎⁯‏⁬‏⁯⁪⁫⁬‬‭‎⁪‌‌⁮‎‭‌‪‫⁭‎‪‎‬​⁭​‍⁪⁫‬⁭‬‮([In] IDisposable obj0) => obj0.Dispose();

    static long \u206A‍⁫‮‎‏‌‍‪‌‌⁪‍‬⁭⁭‏⁪‌‭⁯⁬⁬‮‎‫⁫‭‌‏⁯‬⁭‮⁫‪​‎‎‌‮([In] Stream obj0) => obj0.Length;

    static string \u200B‭‬‎‪⁪⁯‮⁬⁯⁯⁪‮‫‭‪​‏⁮‌⁯‮‌‏⁮‫​‬‏⁭‪‭‏‫⁯‍‭⁯‪⁪‮([In] string obj0) => obj0.ToLowerInvariant();

    static bool \u206A‌⁮‮‏⁬​‫‌​‍‬‪‌​⁮​⁯⁯‫‭⁪‏‫‪‪⁯⁪⁮‪⁫​‏​‬‮⁬‌‪‫‮([In] string obj0) => string.IsNullOrEmpty(obj0);

    static string \u206C‭⁭⁯‬‎‎‎⁭‏⁭⁫‌‎‫‍‎⁫‪⁮‏‬⁯⁪‮⁫‫‪⁫⁫⁭‪⁪‫‏⁭⁯‎⁮⁯‮(
      [In] string obj0,
      [In] object obj1,
      [In] object obj2)
    {
      return string.Format(obj0, obj1, obj2);
    }

    static Assembly \u202C⁭⁬‎⁯‍‌⁮⁬‍‬⁮‎‍‍‏⁮⁮⁪‎‫‭‏⁬‮‌‌​‬‫‮‏‍‌‎‌‌‎⁮‪‮([In] byte[] obj0, [In] byte[] obj1) => Assembly.Load(obj0, obj1);

    static Assembly \u206B⁬‏⁪‫⁬‍‌‭‎‭‭⁬‬​⁯‪‭‮‍⁬⁫‌​‫⁯‬‭‮⁮‎‪⁭‬⁬‭‬‬⁭⁬‮([In] byte[] obj0) => Assembly.Load(obj0);

    static AssemblyName \u206C⁯⁬​​‪⁭​⁫⁪‭‫‫‭‌‫‍‎⁭⁭‫​⁮‮‎‍‎​‌⁫‎⁭‏⁫‮⁬⁭⁪⁭‫‮([In] string obj0) => new AssemblyName(obj0);

    static AssemblyNameFlags \u202A​‪‍⁮⁯‭‌‮⁮​‏‍‮‍⁮⁭‏‏‌‮‌⁭‌⁮⁭⁫⁬‍‏⁯⁮⁭‭‭‮⁫⁭‌‭‮(
      [In] AssemblyName obj0)
    {
      return obj0.Flags;
    }

    static Assembly \u202C‬‎‍‬‏⁪⁭‮​‎‬‪‏⁬‪‫‮⁮‬‏‎‮‍‭‮⁯‎⁮⁭‬‮⁮⁪‬‬⁯‎‏‍‮([In] AssemblyName obj0) => Assembly.Load(obj0);

    static string \u206F⁭⁭‭‭‮⁪‮‬⁬​‪‪⁪⁭‭⁬⁬⁯‪‬‮‎‬‏⁯‮⁬‎​‫‭‭⁪‮⁮‭‮‎⁫‮([In] ResolveEventArgs obj0) => obj0.Name;

    static void \u200C⁬⁭‪‮‎⁬​​⁬⁯‪​⁮‏‏⁬⁫‮⁮‬⁫‌⁫‮‍‪‏‫‫‍‪‏⁬‭⁯⁯‏‌‮‮(
      [In] AppDomain obj0,
      [In] ResolveEventHandler obj1)
    {
      obj0.AssemblyResolve += obj1;
    }
  }
}
