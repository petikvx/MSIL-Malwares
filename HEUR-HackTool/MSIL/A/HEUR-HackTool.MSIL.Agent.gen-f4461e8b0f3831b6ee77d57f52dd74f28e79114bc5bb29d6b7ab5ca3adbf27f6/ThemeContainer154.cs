// Decompiled with JetBrains decompiler
// Type: BlackNET_Builder.ThemeContainer154
// Assembly: BlackNET Builder, Version=3.7.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4B8A14F4-2444-48A4-BCEA-3077100A9E22
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Agent.gen-f4461e8b0f3831b6ee77d57f52dd74f28e79114bc5bb29d6b7ab5ca3adbf27f6.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Windows.Forms;

namespace BlackNET_Builder
{
  internal abstract class ThemeContainer154 : ContainerControl
  {
    protected Graphics G;
    protected Bitmap B;
    private bool DoneCreation;
    private bool HasShown;
    private Rectangle Frame;
    protected MouseState State;
    private bool WM_LMBUTTONDOWN;
    private Point GetIndexPoint;
    private bool B1;
    private bool B2;
    private bool B3;
    private bool B4;
    private int Current;
    private int Previous;
    private Message[] Messages;
    private bool _BackColor;
    private bool _SmartBounds;
    private bool _Movable;
    private bool _Sizable;
    private Color _TransparencyKey;
    private FormBorderStyle _BorderStyle;
    private FormStartPosition _StartPosition;
    private bool _NoRounding;
    private Image _Image;
    private Dictionary<string, Color> Items;
    private string _Customization;
    private bool _Transparent;
    private Size _ImageSize;
    private bool _IsParentForm;
    private int _LockWidth;
    private int _LockHeight;
    private int _Header;
    private bool _ControlMode;
    private bool _IsAnimated;
    private Rectangle OffsetReturnRectangle;
    private Size OffsetReturnSize;
    private Point OffsetReturnPoint;
    private Point CenterReturn;
    private Bitmap MeasureBitmap;
    private Graphics MeasureGraphics;
    private SolidBrush DrawPixelBrush;
    private SolidBrush DrawCornersBrush;
    private Point DrawTextPoint;
    private Size DrawTextSize;
    private Point DrawImagePoint;
    private LinearGradientBrush DrawGradientBrush;
    private Rectangle DrawGradientRectangle;
    private GraphicsPath DrawRadialPath;
    private PathGradientBrush DrawRadialBrush1;
    private LinearGradientBrush DrawRadialBrush2;
    private Rectangle DrawRadialRectangle;
    private GraphicsPath CreateRoundPath;
    private Rectangle CreateRoundRectangle;

    public ThemeContainer154()
    {
      this.Messages = new Message[9];
      this._SmartBounds = true;
      this._Movable = true;
      this._Sizable = true;
      this.Items = new Dictionary<string, Color>();
      this._Header = 24;
      this.SetStyle(ControlStyles.UserPaint | ControlStyles.Opaque | ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true);
      this._ImageSize = Size.Empty;
      this.Font = new Font("Verdana", 8f);
      this.MeasureBitmap = new Bitmap(1, 1);
      this.MeasureGraphics = Graphics.FromImage((Image) this.MeasureBitmap);
      this.DrawRadialPath = new GraphicsPath();
      this.InvalidateCustimization();
    }

    protected override sealed void OnHandleCreated(EventArgs e)
    {
      if (this.DoneCreation)
        this.InitializeMessages();
      this.InvalidateCustimization();
      this.ColorHook();
      if (this._LockWidth != 0)
        this.Width = this._LockWidth;
      if (this._LockHeight != 0)
        this.Height = this._LockHeight;
      if (!this._ControlMode)
        base.Dock = DockStyle.Fill;
      this.Transparent = this._Transparent;
      if (this._Transparent && this._BackColor)
        this.BackColor = Color.Transparent;
      base.OnHandleCreated(e);
    }

    protected override sealed void OnParentChanged(EventArgs e)
    {
      base.OnParentChanged(e);
      if (this.Parent == null)
        return;
      this._IsParentForm = this.Parent is Form;
      if (!this._ControlMode)
      {
        this.InitializeMessages();
        if (this._IsParentForm)
        {
          this.ParentForm.FormBorderStyle = this._BorderStyle;
          this.ParentForm.TransparencyKey = this._TransparencyKey;
          if (!this.DesignMode)
            this.ParentForm.Shown += new EventHandler(this.FormShown);
        }
        this.Parent.BackColor = this.BackColor;
      }
      this.OnCreation();
      this.DoneCreation = true;
      this.InvalidateTimer();
    }

    private void DoAnimation(bool i)
    {
      this.OnAnimation();
      if (!i)
        return;
      this.Invalidate();
    }

    protected override sealed void OnPaint(PaintEventArgs e)
    {
      if (this.Width == 0 || this.Height == 0)
        return;
      if (this._Transparent && this._ControlMode)
      {
        this.PaintHook();
        e.Graphics.DrawImage((Image) this.B, 0, 0);
      }
      else
      {
        this.G = e.Graphics;
        this.PaintHook();
      }
    }

    protected override void OnHandleDestroyed(EventArgs e)
    {
      ThemeShare.RemoveAnimationCallback(new ThemeShare.AnimationDelegate(this.DoAnimation));
      base.OnHandleDestroyed(e);
    }

    private void FormShown(object sender, EventArgs e)
    {
      if (this._ControlMode || this.HasShown)
        return;
      if (this._StartPosition == FormStartPosition.CenterParent || this._StartPosition == FormStartPosition.CenterScreen)
      {
        Rectangle bounds1 = Screen.PrimaryScreen.Bounds;
        Rectangle bounds2 = this.ParentForm.Bounds;
        this.ParentForm.Location = new Point(checked (unchecked (bounds1.Width / 2) - unchecked (bounds2.Width / 2)), checked (unchecked (bounds1.Height / 2) - unchecked (bounds2.Width / 2)));
      }
      this.HasShown = true;
    }

    protected override sealed void OnSizeChanged(EventArgs e)
    {
      if (this._Movable && !this._ControlMode)
        this.Frame = new Rectangle(7, 7, checked (this.Width - 14), checked (this._Header - 7));
      this.InvalidateBitmap();
      this.Invalidate();
      base.OnSizeChanged(e);
    }

    protected override void SetBoundsCore(
      int x,
      int y,
      int width,
      int height,
      BoundsSpecified specified)
    {
      if (this._LockWidth != 0)
        width = this._LockWidth;
      if (this._LockHeight != 0)
        height = this._LockHeight;
      base.SetBoundsCore(x, y, width, height, specified);
    }

    private void SetState(MouseState current)
    {
      this.State = current;
      this.Invalidate();
    }

    protected override void OnMouseMove(MouseEventArgs e)
    {
      if ((!this._IsParentForm || this.ParentForm.WindowState != FormWindowState.Maximized) && this._Sizable && !this._ControlMode)
        this.InvalidateMouse();
      base.OnMouseMove(e);
    }

    protected override void OnEnabledChanged(EventArgs e)
    {
      if (this.Enabled)
        this.SetState(MouseState.None);
      else
        this.SetState(MouseState.Block);
      base.OnEnabledChanged(e);
    }

    protected override void OnMouseEnter(EventArgs e)
    {
      this.SetState(MouseState.Over);
      base.OnMouseEnter(e);
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
      this.SetState(MouseState.Over);
      base.OnMouseUp(e);
    }

    protected override void OnMouseLeave(EventArgs e)
    {
      this.SetState(MouseState.None);
      if (this.GetChildAtPoint(this.PointToClient(Control.MousePosition)) != null && this._Sizable && !this._ControlMode)
      {
        this.Cursor = Cursors.Default;
        this.Previous = 0;
      }
      base.OnMouseLeave(e);
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
      if (e.Button == MouseButtons.Left)
        this.SetState(MouseState.Down);
      if ((!this._IsParentForm || this.ParentForm.WindowState != FormWindowState.Maximized) && !this._ControlMode)
      {
        if (this._Movable && this.Frame.Contains(e.Location))
        {
          this.Capture = false;
          this.WM_LMBUTTONDOWN = true;
          this.DefWndProc(ref this.Messages[0]);
        }
        else if (this._Sizable && this.Previous != 0)
        {
          this.Capture = false;
          this.WM_LMBUTTONDOWN = true;
          this.DefWndProc(ref this.Messages[this.Previous]);
        }
      }
      base.OnMouseDown(e);
    }

    protected override void WndProc(ref Message m)
    {
      base.WndProc(ref m);
      if (!this.WM_LMBUTTONDOWN || m.Msg != 513)
        return;
      this.WM_LMBUTTONDOWN = false;
      this.SetState(MouseState.Over);
      if (!this._SmartBounds)
        return;
      if (this.IsParentMdi)
        this.CorrectBounds(new Rectangle(Point.Empty, this.Parent.Parent.Size));
      else
        this.CorrectBounds(Screen.FromControl(this.Parent).WorkingArea);
    }

    private int GetIndex()
    {
      this.GetIndexPoint = this.PointToClient(Control.MousePosition);
      this.B1 = this.GetIndexPoint.X < 7;
      this.B2 = this.GetIndexPoint.X > checked (this.Width - 7);
      this.B3 = this.GetIndexPoint.Y < 7;
      this.B4 = this.GetIndexPoint.Y > checked (this.Height - 7);
      if (this.B1 && this.B3)
        return 4;
      if (this.B1 && this.B4)
        return 7;
      if (this.B2 && this.B3)
        return 5;
      if (this.B2 && this.B4)
        return 8;
      if (this.B1)
        return 1;
      if (this.B2)
        return 2;
      if (this.B3)
        return 3;
      return this.B4 ? 6 : 0;
    }

    private void InvalidateMouse()
    {
      this.Current = this.GetIndex();
      if (this.Current == this.Previous)
        return;
      this.Previous = this.Current;
      switch (this.Previous)
      {
        case 0:
          this.Cursor = Cursors.Default;
          break;
        case 1:
        case 2:
          this.Cursor = Cursors.SizeWE;
          break;
        case 3:
        case 6:
          this.Cursor = Cursors.SizeNS;
          break;
        case 4:
        case 8:
          this.Cursor = Cursors.SizeNWSE;
          break;
        case 5:
        case 7:
          this.Cursor = Cursors.SizeNESW;
          break;
      }
    }

    private void InitializeMessages()
    {
      ref Message local1 = ref this.Messages[0];
      IntPtr handle1 = this.Parent.Handle;
      IntPtr num = new IntPtr(2);
      IntPtr wparam1 = num;
      IntPtr zero1 = IntPtr.Zero;
      Message message1 = Message.Create(handle1, 161, wparam1, zero1);
      local1 = message1;
      int index = 1;
      do
      {
        ref Message local2 = ref this.Messages[index];
        IntPtr handle2 = this.Parent.Handle;
        num = new IntPtr(checked (index + 9));
        IntPtr wparam2 = num;
        IntPtr zero2 = IntPtr.Zero;
        Message message2 = Message.Create(handle2, 161, wparam2, zero2);
        local2 = message2;
        checked { ++index; }
      }
      while (index <= 8);
    }

    private void CorrectBounds(Rectangle bounds)
    {
      if (this.Parent.Width > bounds.Width)
        this.Parent.Width = bounds.Width;
      if (this.Parent.Height > bounds.Height)
        this.Parent.Height = bounds.Height;
      int x = this.Parent.Location.X;
      Point point1 = this.Parent.Location;
      int y = point1.Y;
      if (x < bounds.X)
        x = bounds.X;
      if (y < bounds.Y)
        y = bounds.Y;
      int num1 = checked (bounds.X + bounds.Width);
      int num2 = checked (bounds.Y + bounds.Height);
      if (checked (x + this.Parent.Width) > num1)
        x = checked (num1 - this.Parent.Width);
      if (checked (y + this.Parent.Height) > num2)
        y = checked (num2 - this.Parent.Height);
      Control parent = this.Parent;
      point1 = new Point(x, y);
      Point point2 = point1;
      parent.Location = point2;
    }

    public override DockStyle Dock
    {
      get => base.Dock;
      set
      {
        if (!this._ControlMode)
          return;
        base.Dock = value;
      }
    }

    [Category("Misc")]
    public override Color BackColor
    {
      get => base.BackColor;
      set
      {
        if (value == base.BackColor)
          return;
        if (!this.IsHandleCreated && this._ControlMode && value == Color.Transparent)
        {
          this._BackColor = true;
        }
        else
        {
          base.BackColor = value;
          if (this.Parent == null)
            return;
          if (!this._ControlMode)
            this.Parent.BackColor = value;
          this.ColorHook();
        }
      }
    }

    public override Size MinimumSize
    {
      get => base.MinimumSize;
      set
      {
        base.MinimumSize = value;
        if (this.Parent == null)
          return;
        this.Parent.MinimumSize = value;
      }
    }

    public override Size MaximumSize
    {
      get => base.MaximumSize;
      set
      {
        base.MaximumSize = value;
        if (this.Parent == null)
          return;
        this.Parent.MaximumSize = value;
      }
    }

    public override string Text
    {
      get => base.Text;
      set
      {
        base.Text = value;
        this.Invalidate();
      }
    }

    public override Font Font
    {
      get => base.Font;
      set
      {
        base.Font = value;
        this.Invalidate();
      }
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [EditorBrowsable(EditorBrowsableState.Never)]
    [Browsable(false)]
    public override Color ForeColor
    {
      get => Color.Empty;
      set
      {
      }
    }

    [EditorBrowsable(EditorBrowsableState.Never)]
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override Image BackgroundImage
    {
      get => (Image) null;
      set
      {
      }
    }

    [EditorBrowsable(EditorBrowsableState.Never)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public override ImageLayout BackgroundImageLayout
    {
      get => ImageLayout.None;
      set
      {
      }
    }

    public bool SmartBounds
    {
      get => this._SmartBounds;
      set => this._SmartBounds = value;
    }

    public bool Movable
    {
      get => this._Movable;
      set => this._Movable = value;
    }

    public bool Sizable
    {
      get => this._Sizable;
      set => this._Sizable = value;
    }

    public Color TransparencyKey
    {
      get => this._IsParentForm && !this._ControlMode ? this.ParentForm.TransparencyKey : this._TransparencyKey;
      set
      {
        if (value == this._TransparencyKey)
          return;
        this._TransparencyKey = value;
        if (!this._IsParentForm || this._ControlMode)
          return;
        this.ParentForm.TransparencyKey = value;
        this.ColorHook();
      }
    }

    public FormBorderStyle BorderStyle
    {
      get => this._IsParentForm && !this._ControlMode ? this.ParentForm.FormBorderStyle : this._BorderStyle;
      set
      {
        this._BorderStyle = value;
        if (!this._IsParentForm || this._ControlMode)
          return;
        this.ParentForm.FormBorderStyle = value;
        if (value == FormBorderStyle.None)
          return;
        this.Movable = false;
        this.Sizable = false;
      }
    }

    public FormStartPosition StartPosition
    {
      get => this._IsParentForm && !this._ControlMode ? this.ParentForm.StartPosition : this._StartPosition;
      set
      {
        this._StartPosition = value;
        if (!this._IsParentForm || this._ControlMode)
          return;
        this.ParentForm.StartPosition = value;
      }
    }

    public bool NoRounding
    {
      get => this._NoRounding;
      set
      {
        this._NoRounding = value;
        this.Invalidate();
      }
    }

    public Image Image
    {
      get => this._Image;
      set
      {
        this._ImageSize = value != null ? value.Size : Size.Empty;
        this._Image = value;
        this.Invalidate();
      }
    }

    public Bloom[] Colors
    {
      get
      {
        List<Bloom> bloomList = new List<Bloom>();
        Dictionary<string, Color>.Enumerator enumerator = this.Items.GetEnumerator();
        while (enumerator.MoveNext())
          bloomList.Add(new Bloom(enumerator.Current.Key, enumerator.Current.Value));
        return bloomList.ToArray();
      }
      set
      {
        Bloom[] bloomArray = value;
        int index = 0;
        while (index < bloomArray.Length)
        {
          Bloom bloom = bloomArray[index];
          if (this.Items.ContainsKey(bloom.Name))
            this.Items[bloom.Name] = bloom.Value;
          checked { ++index; }
        }
        this.InvalidateCustimization();
        this.ColorHook();
        this.Invalidate();
      }
    }

    public string Customization
    {
      get => this._Customization;
      set
      {
        if (Operators.CompareString(value, this._Customization, false) == 0)
          return;
        Bloom[] colors = this.Colors;
        try
        {
          byte[] numArray = Convert.FromBase64String(value);
          int num = checked (colors.Length - 1);
          int index = 0;
          while (index <= num)
          {
            colors[index].Value = Color.FromArgb(BitConverter.ToInt32(numArray, checked (index * 4)));
            checked { ++index; }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
          return;
        }
        this._Customization = value;
        this.Colors = colors;
        this.ColorHook();
        this.Invalidate();
      }
    }

    public bool Transparent
    {
      get => this._Transparent;
      set
      {
        this._Transparent = value;
        if (!this.IsHandleCreated && !this._ControlMode)
          return;
        if (!value && this.BackColor.A != byte.MaxValue)
          throw new Exception("Unable to change value to false while a transparent BackColor is in use.");
        this.SetStyle(ControlStyles.Opaque, !value);
        this.SetStyle(ControlStyles.SupportsTransparentBackColor, value);
        this.InvalidateBitmap();
        this.Invalidate();
      }
    }

    protected Size ImageSize => this._ImageSize;

    protected bool IsParentForm => this._IsParentForm;

    protected bool IsParentMdi => this.Parent != null && this.Parent.Parent != null;

    protected int LockWidth
    {
      get => this._LockWidth;
      set
      {
        this._LockWidth = value;
        if (this.LockWidth == 0 || !this.IsHandleCreated)
          return;
        this.Width = this.LockWidth;
      }
    }

    protected int LockHeight
    {
      get => this._LockHeight;
      set
      {
        this._LockHeight = value;
        if (this.LockHeight == 0 || !this.IsHandleCreated)
          return;
        this.Height = this.LockHeight;
      }
    }

    protected int Header
    {
      get => this._Header;
      set
      {
        this._Header = value;
        if (this._ControlMode)
          return;
        this.Frame = new Rectangle(7, 7, checked (this.Width - 14), checked (value - 7));
        this.Invalidate();
      }
    }

    protected bool ControlMode
    {
      get => this._ControlMode;
      set
      {
        this._ControlMode = value;
        this.Transparent = this._Transparent;
        if (this._Transparent && this._BackColor)
          this.BackColor = Color.Transparent;
        this.InvalidateBitmap();
        this.Invalidate();
      }
    }

    protected bool IsAnimated
    {
      get => this._IsAnimated;
      set
      {
        this._IsAnimated = value;
        this.InvalidateTimer();
      }
    }

    protected Pen GetPen(string name) => new Pen(this.Items[name]);

    protected Pen GetPen(string name, float width) => new Pen(this.Items[name], width);

    protected SolidBrush GetBrush(string name) => new SolidBrush(this.Items[name]);

    protected Color GetColor(string name) => this.Items[name];

    protected void SetColor(string name, Color value)
    {
      if (this.Items.ContainsKey(name))
        this.Items[name] = value;
      else
        this.Items.Add(name, value);
    }

    protected void SetColor(string name, byte r, byte g, byte b) => this.SetColor(name, Color.FromArgb((int) r, (int) g, (int) b));

    protected void SetColor(string name, byte a, byte r, byte g, byte b) => this.SetColor(name, Color.FromArgb((int) a, (int) r, (int) g, (int) b));

    protected void SetColor(string name, byte a, Color value) => this.SetColor(name, Color.FromArgb((int) a, value));

    private void InvalidateBitmap()
    {
      if (this._Transparent && this._ControlMode)
      {
        if (this.Width == 0 || this.Height == 0)
          return;
        this.B = new Bitmap(this.Width, this.Height, PixelFormat.Format32bppPArgb);
        this.G = Graphics.FromImage((Image) this.B);
      }
      else
      {
        this.G = (Graphics) null;
        this.B = (Bitmap) null;
      }
    }

    private void InvalidateCustimization()
    {
      MemoryStream memoryStream = new MemoryStream(checked (this.Items.Count * 4));
      Bloom[] colors = this.Colors;
      int index = 0;
      while (index < colors.Length)
      {
        Bloom bloom = colors[index];
        memoryStream.Write(BitConverter.GetBytes(bloom.Value.ToArgb()), 0, 4);
        checked { ++index; }
      }
      memoryStream.Close();
      this._Customization = Convert.ToBase64String(memoryStream.ToArray());
    }

    private void InvalidateTimer()
    {
      if (this.DesignMode || !this.DoneCreation)
        return;
      if (this._IsAnimated)
        ThemeShare.AddAnimationCallback(new ThemeShare.AnimationDelegate(this.DoAnimation));
      else
        ThemeShare.RemoveAnimationCallback(new ThemeShare.AnimationDelegate(this.DoAnimation));
    }

    protected abstract void ColorHook();

    protected abstract void PaintHook();

    protected virtual void OnCreation()
    {
    }

    protected virtual void OnAnimation()
    {
    }

    protected Rectangle Offset(Rectangle r, int amount)
    {
      this.OffsetReturnRectangle = new Rectangle(checked (r.X + amount), checked (r.Y + amount), checked (r.Width - amount * 2), checked (r.Height - amount * 2));
      return this.OffsetReturnRectangle;
    }

    protected Size Offset(Size s, int amount)
    {
      this.OffsetReturnSize = new Size(checked (s.Width + amount), checked (s.Height + amount));
      return this.OffsetReturnSize;
    }

    protected Point Offset(Point p, int amount)
    {
      this.OffsetReturnPoint = new Point(checked (p.X + amount), checked (p.Y + amount));
      return this.OffsetReturnPoint;
    }

    protected Point Center(Rectangle p, Rectangle c)
    {
      this.CenterReturn = new Point(checked (unchecked (p.Width / 2) - unchecked (c.Width / 2) + p.X + c.X), checked (unchecked (p.Height / 2) - unchecked (c.Height / 2) + p.Y + c.Y));
      return this.CenterReturn;
    }

    protected Point Center(Rectangle p, Size c)
    {
      this.CenterReturn = new Point(checked (unchecked (p.Width / 2) - unchecked (c.Width / 2) + p.X), checked (unchecked (p.Height / 2) - unchecked (c.Height / 2) + p.Y));
      return this.CenterReturn;
    }

    protected Point Center(Rectangle child) => this.Center(this.Width, this.Height, child.Width, child.Height);

    protected Point Center(Size child) => this.Center(this.Width, this.Height, child.Width, child.Height);

    protected Point Center(int childWidth, int childHeight) => this.Center(this.Width, this.Height, childWidth, childHeight);

    protected Point Center(Size p, Size c) => this.Center(p.Width, p.Height, c.Width, c.Height);

    protected Point Center(int pWidth, int pHeight, int cWidth, int cHeight)
    {
      this.CenterReturn = new Point(checked (unchecked (pWidth / 2) - unchecked (cWidth / 2)), checked (unchecked (pHeight / 2) - unchecked (cHeight / 2)));
      return this.CenterReturn;
    }

    protected Size Measure()
    {
      lock (this.MeasureGraphics)
        return this.MeasureGraphics.MeasureString(this.Text, this.Font, this.Width).ToSize();
    }

    protected Size Measure(string text)
    {
      lock (this.MeasureGraphics)
        return this.MeasureGraphics.MeasureString(text, this.Font, this.Width).ToSize();
    }

    protected void DrawPixel(Color c1, int x, int y)
    {
      if (this._Transparent)
      {
        this.B.SetPixel(x, y, c1);
      }
      else
      {
        this.DrawPixelBrush = new SolidBrush(c1);
        this.G.FillRectangle((Brush) this.DrawPixelBrush, x, y, 1, 1);
      }
    }

    protected void DrawCorners(Color c1, int offset) => this.DrawCorners(c1, 0, 0, this.Width, this.Height, offset);

    protected void DrawCorners(Color c1, Rectangle r1, int offset) => this.DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height, offset);

    protected void DrawCorners(Color c1, int x, int y, int width, int height, int offset) => this.DrawCorners(c1, checked (x + offset), checked (y + offset), checked (width - offset * 2), checked (height - offset * 2));

    protected void DrawCorners(Color c1) => this.DrawCorners(c1, 0, 0, this.Width, this.Height);

    protected void DrawCorners(Color c1, Rectangle r1) => this.DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height);

    protected void DrawCorners(Color c1, int x, int y, int width, int height)
    {
      if (this._NoRounding)
        return;
      if (this._Transparent)
      {
        this.B.SetPixel(x, y, c1);
        this.B.SetPixel(checked (x + width - 1), y, c1);
        this.B.SetPixel(x, checked (y + height - 1), c1);
        this.B.SetPixel(checked (x + width - 1), checked (y + height - 1), c1);
      }
      else
      {
        this.DrawCornersBrush = new SolidBrush(c1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, x, y, 1, 1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, checked (x + width - 1), y, 1, 1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, x, checked (y + height - 1), 1, 1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, checked (x + width - 1), checked (y + height - 1), 1, 1);
      }
    }

    protected void DrawBorders(Pen p1, int offset) => this.DrawBorders(p1, 0, 0, this.Width, this.Height, offset);

    protected void DrawBorders(Pen p1, Rectangle r, int offset) => this.DrawBorders(p1, r.X, r.Y, r.Width, r.Height, offset);

    protected void DrawBorders(Pen p1, int x, int y, int width, int height, int offset) => this.DrawBorders(p1, checked (x + offset), checked (y + offset), checked (width - offset * 2), checked (height - offset * 2));

    protected void DrawBorders(Pen p1) => this.DrawBorders(p1, 0, 0, this.Width, this.Height);

    protected void DrawBorders(Pen p1, Rectangle r) => this.DrawBorders(p1, r.X, r.Y, r.Width, r.Height);

    protected void DrawBorders(Pen p1, int x, int y, int width, int height) => this.G.DrawRectangle(p1, x, y, checked (width - 1), checked (height - 1));

    protected void DrawText(Brush b1, HorizontalAlignment a, int x, int y) => this.DrawText(b1, this.Text, a, x, y);

    protected void DrawText(Brush b1, string text, HorizontalAlignment a, int x, int y)
    {
      if (text.Length == 0)
        return;
      this.DrawTextSize = this.Measure(text);
      this.DrawTextPoint = new Point(checked (unchecked (this.Width / 2) - unchecked (this.DrawTextSize.Width / 2)), checked (unchecked (this.Header / 2) - unchecked (this.DrawTextSize.Height / 2)));
      switch (a)
      {
        case HorizontalAlignment.Left:
          this.G.DrawString(text, this.Font, b1, (float) x, (float) checked (this.DrawTextPoint.Y + y));
          break;
        case HorizontalAlignment.Right:
          this.G.DrawString(text, this.Font, b1, (float) checked (this.Width - this.DrawTextSize.Width - x), (float) checked (this.DrawTextPoint.Y + y));
          break;
        case HorizontalAlignment.Center:
          this.G.DrawString(text, this.Font, b1, (float) checked (this.DrawTextPoint.X + x), (float) checked (this.DrawTextPoint.Y + y));
          break;
      }
    }

    protected void DrawText(Brush b1, Point p1)
    {
      if (this.Text.Length == 0)
        return;
      this.G.DrawString(this.Text, this.Font, b1, (PointF) p1);
    }

    protected void DrawText(Brush b1, int x, int y)
    {
      if (this.Text.Length == 0)
        return;
      this.G.DrawString(this.Text, this.Font, b1, (float) x, (float) y);
    }

    protected void DrawImage(HorizontalAlignment a, int x, int y) => this.DrawImage(this._Image, a, x, y);

    protected void DrawImage(Image image, HorizontalAlignment a, int x, int y)
    {
      if (image == null)
        return;
      this.DrawImagePoint = new Point(checked (unchecked (this.Width / 2) - unchecked (image.Width / 2)), checked (unchecked (this.Header / 2) - unchecked (image.Height / 2)));
      switch (a)
      {
        case HorizontalAlignment.Left:
          this.G.DrawImage(image, x, checked (this.DrawImagePoint.Y + y), image.Width, image.Height);
          break;
        case HorizontalAlignment.Right:
          this.G.DrawImage(image, checked (this.Width - image.Width - x), checked (this.DrawImagePoint.Y + y), image.Width, image.Height);
          break;
        case HorizontalAlignment.Center:
          this.G.DrawImage(image, checked (this.DrawImagePoint.X + x), checked (this.DrawImagePoint.Y + y), image.Width, image.Height);
          break;
      }
    }

    protected void DrawImage(Point p1) => this.DrawImage(this._Image, p1.X, p1.Y);

    protected void DrawImage(int x, int y) => this.DrawImage(this._Image, x, y);

    protected void DrawImage(Image image, Point p1) => this.DrawImage(image, p1.X, p1.Y);

    protected void DrawImage(Image image, int x, int y)
    {
      if (image == null)
        return;
      this.G.DrawImage(image, x, y, image.Width, image.Height);
    }

    protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(blend, this.DrawGradientRectangle);
    }

    protected void DrawGradient(
      ColorBlend blend,
      int x,
      int y,
      int width,
      int height,
      float angle)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(blend, this.DrawGradientRectangle, angle);
    }

    protected void DrawGradient(ColorBlend blend, Rectangle r)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, 90f);
      this.DrawGradientBrush.InterpolationColors = blend;
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawGradient(ColorBlend blend, Rectangle r, float angle)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, angle);
      this.DrawGradientBrush.InterpolationColors = blend;
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(c1, c2, this.DrawGradientRectangle);
    }

    protected void DrawGradient(
      Color c1,
      Color c2,
      int x,
      int y,
      int width,
      int height,
      float angle)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(c1, c2, this.DrawGradientRectangle, angle);
    }

    protected void DrawGradient(Color c1, Color c2, Rectangle r)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, c1, c2, 90f);
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawGradient(Color c1, Color c2, Rectangle r, float angle)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, c1, c2, angle);
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(blend, this.DrawRadialRectangle, width / 2, height / 2);
    }

    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, Point center)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(blend, this.DrawRadialRectangle, center.X, center.Y);
    }

    public void DrawRadial(
      ColorBlend blend,
      int x,
      int y,
      int width,
      int height,
      int cx,
      int cy)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(blend, this.DrawRadialRectangle, cx, cy);
    }

    public void DrawRadial(ColorBlend blend, Rectangle r) => this.DrawRadial(blend, r, r.Width / 2, r.Height / 2);

    public void DrawRadial(ColorBlend blend, Rectangle r, Point center) => this.DrawRadial(blend, r, center.X, center.Y);

    public void DrawRadial(ColorBlend blend, Rectangle r, int cx, int cy)
    {
      this.DrawRadialPath.Reset();
      this.DrawRadialPath.AddEllipse(r.X, r.Y, checked (r.Width - 1), checked (r.Height - 1));
      this.DrawRadialBrush1 = new PathGradientBrush(this.DrawRadialPath);
      this.DrawRadialBrush1.CenterPoint = (PointF) new Point(checked (r.X + cx), checked (r.Y + cy));
      this.DrawRadialBrush1.InterpolationColors = blend;
      if (this.G.SmoothingMode == SmoothingMode.AntiAlias)
        this.G.FillEllipse((Brush) this.DrawRadialBrush1, checked (r.X + 1), checked (r.Y + 1), checked (r.Width - 3), checked (r.Height - 3));
      else
        this.G.FillEllipse((Brush) this.DrawRadialBrush1, r);
    }

    protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(c1, c2, this.DrawGradientRectangle);
    }

    protected void DrawRadial(
      Color c1,
      Color c2,
      int x,
      int y,
      int width,
      int height,
      float angle)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(c1, c2, this.DrawGradientRectangle, angle);
    }

    protected void DrawRadial(Color c1, Color c2, Rectangle r)
    {
      this.DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, 90f);
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawRadial(Color c1, Color c2, Rectangle r, float angle)
    {
      this.DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, angle);
      this.G.FillEllipse((Brush) this.DrawGradientBrush, r);
    }

    public GraphicsPath CreateRound(int x, int y, int width, int height, int slope)
    {
      this.CreateRoundRectangle = new Rectangle(x, y, width, height);
      return this.CreateRound(this.CreateRoundRectangle, slope);
    }

    public GraphicsPath CreateRound(Rectangle r, int slope)
    {
      this.CreateRoundPath = new GraphicsPath(FillMode.Winding);
      this.CreateRoundPath.AddArc(r.X, r.Y, slope, slope, 180f, 90f);
      this.CreateRoundPath.AddArc(checked (r.Right - slope), r.Y, slope, slope, 270f, 90f);
      this.CreateRoundPath.AddArc(checked (r.Right - slope), checked (r.Bottom - slope), slope, slope, 0.0f, 90f);
      this.CreateRoundPath.AddArc(r.X, checked (r.Bottom - slope), slope, slope, 90f, 90f);
      this.CreateRoundPath.CloseFigure();
      return this.CreateRoundPath;
    }
  }
}
