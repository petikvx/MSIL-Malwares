// Decompiled with JetBrains decompiler
// Type: BlackNET_Builder.IconChanger
// Assembly: BlackNET Builder, Version=3.7.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4B8A14F4-2444-48A4-BCEA-3077100A9E22
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Agent.gen-f4461e8b0f3831b6ee77d57f52dd74f28e79114bc5bb29d6b7ab5ca3adbf27f6.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;

namespace BlackNET_Builder
{
  public class IconChanger
  {
    public static void InjectIcon(string exeFileName, string iconFileName) => IconChanger.InjectIcon(exeFileName, iconFileName, 1U, 1U);

    public static void InjectIcon(
      string exeFileName,
      string iconFileName,
      uint iconGroupID,
      uint iconBaseID)
    {
      IconChanger.IconFile iconFile = IconChanger.IconFile.FromFile(iconFileName);
      IntPtr hUpdate1 = IconChanger.NativeMethods.BeginUpdateResource(exeFileName, false);
      byte[] iconGroupData = iconFile.CreateIconGroupData(iconBaseID);
      IntPtr hUpdate2 = hUpdate1;
      IntPtr num1 = new IntPtr(14L);
      IntPtr type1 = num1;
      IntPtr num2 = new IntPtr((long) iconGroupID);
      IntPtr name1 = num2;
      byte[] data1 = iconGroupData;
      int length1 = iconGroupData.Length;
      IconChanger.NativeMethods.UpdateResource(hUpdate2, type1, name1, (short) 0, data1, length1);
      int num3 = checked (iconFile.ImageCount - 1);
      int index = 0;
      while (index <= num3)
      {
        byte[] numArray = iconFile.get_ImageData(index);
        IntPtr hUpdate3 = hUpdate1;
        num2 = new IntPtr(3L);
        IntPtr type2 = num2;
        num1 = new IntPtr(checked ((long) iconBaseID + (long) index));
        IntPtr name2 = num1;
        byte[] data2 = numArray;
        int length2 = numArray.Length;
        IconChanger.NativeMethods.UpdateResource(hUpdate3, type2, name2, (short) 0, data2, length2);
        checked { ++index; }
      }
      IconChanger.NativeMethods.EndUpdateResource(hUpdate1, false);
    }

    [SuppressUnmanagedCodeSecurity]
    private class NativeMethods
    {
      [DllImport("kernel32")]
      public static extern IntPtr BeginUpdateResource(
        string fileName,
        [MarshalAs(UnmanagedType.Bool)] bool deleteExistingResources);

      [DllImport("kernel32")]
      [return: MarshalAs(UnmanagedType.Bool)]
      public static extern bool UpdateResource(
        IntPtr hUpdate,
        IntPtr type,
        IntPtr name,
        short language,
        [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 5)] byte[] data,
        int dataSize);

      [DllImport("kernel32")]
      [return: MarshalAs(UnmanagedType.Bool)]
      public static extern bool EndUpdateResource(IntPtr hUpdate, [MarshalAs(UnmanagedType.Bool)] bool discard);
    }

    private struct ICONDIR
    {
      public ushort Reserved;
      public ushort Type;
      public ushort Count;
    }

    private struct ICONDIRENTRY
    {
      public byte Width;
      public byte Height;
      public byte ColorCount;
      public byte Reserved;
      public ushort Planes;
      public ushort BitCount;
      public int BytesInRes;
      public int ImageOffset;
    }

    private struct BITMAPINFOHEADER
    {
      public uint Size;
      public int Width;
      public int Height;
      public ushort Planes;
      public ushort BitCount;
      public uint Compression;
      public uint SizeImage;
      public int XPelsPerMeter;
      public int YPelsPerMeter;
      public uint ClrUsed;
      public uint ClrImportant;
    }

    [StructLayout(LayoutKind.Sequential, Pack = 2)]
    private struct GRPICONDIRENTRY
    {
      public byte Width;
      public byte Height;
      public byte ColorCount;
      public byte Reserved;
      public ushort Planes;
      public ushort BitCount;
      public int BytesInRes;
      public ushort ID;
    }

    private class IconFile
    {
      private IconChanger.ICONDIR iconDir;
      private IconChanger.ICONDIRENTRY[] iconEntry;
      private byte[][] iconImage;

      public int ImageCount => (int) this.iconDir.Count;

      public byte[] get_ImageData(int index) => this.iconImage[index];

      private IconFile() => this.iconDir = new IconChanger.ICONDIR();

      public static IconChanger.IconFile FromFile(string filename)
      {
        IconChanger.IconFile iconFile = new IconChanger.IconFile();
        byte[] src = File.ReadAllBytes(filename);
        GCHandle gcHandle = GCHandle.Alloc((object) src, GCHandleType.Pinned);
        iconFile.iconDir = (IconChanger.ICONDIR) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (IconChanger.ICONDIR));
        iconFile.iconEntry = new IconChanger.ICONDIRENTRY[checked ((int) iconFile.iconDir.Count - 1 + 1)];
        iconFile.iconImage = new byte[checked ((int) iconFile.iconDir.Count - 1 + 1)][];
        int num1 = Marshal.SizeOf((object) iconFile.iconDir);
        Type type = typeof (IconChanger.ICONDIRENTRY);
        int num2 = Marshal.SizeOf(type);
        int num3 = checked ((int) iconFile.iconDir.Count - 1);
        int index = 0;
        while (index <= num3)
        {
          IconChanger.ICONDIRENTRY structure = (IconChanger.ICONDIRENTRY) Marshal.PtrToStructure(new IntPtr(checked (gcHandle.AddrOfPinnedObject().ToInt64() + (long) num1)), type);
          iconFile.iconEntry[index] = structure;
          iconFile.iconImage[index] = new byte[checked (structure.BytesInRes - 1 + 1)];
          Buffer.BlockCopy((Array) src, structure.ImageOffset, (Array) iconFile.iconImage[index], 0, structure.BytesInRes);
          checked { num1 += num2; }
          checked { ++index; }
        }
        gcHandle.Free();
        return iconFile;
      }

      public byte[] CreateIconGroupData(uint iconBaseID)
      {
        byte[] iconGroupData = new byte[checked (Marshal.SizeOf(typeof (IconChanger.ICONDIR)) + Marshal.SizeOf(typeof (IconChanger.GRPICONDIRENTRY)) * this.ImageCount - 1 + 1)];
        GCHandle gcHandle1 = GCHandle.Alloc((object) iconGroupData, GCHandleType.Pinned);
        Marshal.StructureToPtr((object) this.iconDir, gcHandle1.AddrOfPinnedObject(), false);
        int num1 = Marshal.SizeOf((object) this.iconDir);
        int num2 = checked (this.ImageCount - 1);
        int index = 0;
        while (index <= num2)
        {
          IconChanger.GRPICONDIRENTRY structure = new IconChanger.GRPICONDIRENTRY();
          IconChanger.BITMAPINFOHEADER bitmapinfoheader = new IconChanger.BITMAPINFOHEADER();
          GCHandle gcHandle2 = GCHandle.Alloc((object) bitmapinfoheader, GCHandleType.Pinned);
          Marshal.Copy(this.get_ImageData(index), 0, gcHandle2.AddrOfPinnedObject(), Marshal.SizeOf(typeof (IconChanger.BITMAPINFOHEADER)));
          gcHandle2.Free();
          structure.Width = this.iconEntry[index].Width;
          structure.Height = this.iconEntry[index].Height;
          structure.ColorCount = this.iconEntry[index].ColorCount;
          structure.Reserved = this.iconEntry[index].Reserved;
          structure.Planes = bitmapinfoheader.Planes;
          structure.BitCount = bitmapinfoheader.BitCount;
          structure.BytesInRes = this.iconEntry[index].BytesInRes;
          structure.ID = checked ((ushort) ((long) iconBaseID + (long) index));
          Marshal.StructureToPtr((object) structure, new IntPtr(checked (gcHandle1.AddrOfPinnedObject().ToInt64() + (long) num1)), false);
          checked { num1 += Marshal.SizeOf(typeof (IconChanger.GRPICONDIRENTRY)); }
          checked { ++index; }
        }
        gcHandle1.Free();
        return iconGroupData;
      }
    }
  }
}
