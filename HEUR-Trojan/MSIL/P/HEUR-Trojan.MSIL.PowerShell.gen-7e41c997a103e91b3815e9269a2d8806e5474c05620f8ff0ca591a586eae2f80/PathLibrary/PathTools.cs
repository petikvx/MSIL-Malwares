// Decompiled with JetBrains decompiler
// Type: PathLibrary.PathTools
// Assembly: LeaseMana, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 529A6AA6-AEB5-47F3-B86B-C5E3C5F9FA62
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-7e41c997a103e91b3815e9269a2d8806e5474c05620f8ff0ca591a586eae2f80.exe

using MyExtensions;
using System;
using System.Collections.Generic;
using System.Linq;

namespace PathLibrary
{
  public static class PathTools
  {
    private static string RemoveBrackets(string attributePart)
    {
      attributePart = attributePart.Replace("[", "");
      attributePart = attributePart.Replace("]", "");
      return attributePart;
    }

    public static string GetAttributes(string pathPart)
    {
      int startIndex = pathPart.IndexOf('[');
      return startIndex != -1 ? pathPart.Substring(startIndex, pathPart.Length - startIndex) : (string) null;
    }

    public static PathAttributeValueGroup[] GetAttributeValue(
      string attributePart)
    {
      attributePart = PathTools.RemoveBrackets(attributePart);
      List<PathAttributeValueGroup> attributeValueGroupList = new List<PathAttributeValueGroup>();
      foreach (string str in ((IEnumerable<string>) attributePart.Split(';')).Where<string>((Func<string, bool>) (x => x.IsNotEmptyOrNull())))
      {
        string[] strArray = str.Split('=');
        if (strArray.Length == 2)
          attributeValueGroupList.Add(new PathAttributeValueGroup()
          {
            Attribute = strArray[0],
            Value = strArray[1]
          });
      }
      return attributeValueGroupList.ToArray();
    }

    public static string RemoveAttributes(string pathPart)
    {
      int length = pathPart.IndexOf('[');
      return length != -1 ? pathPart.Substring(0, length) : pathPart;
    }

    public static string[] FilterNotCommonParent(string commonParent, string[] pathsToParse)
    {
      for (int index = 0; index < pathsToParse.Length; ++index)
        pathsToParse[index] = pathsToParse[index].Substring(commonParent.Length + 1);
      return pathsToParse;
    }

    public static string GetCommonParent(string[] restPathToParse)
    {
      string commonParent = "";
      foreach (string str in ((IEnumerable<string>) restPathToParse[0].Split('/')).Where<string>((Func<string, bool>) (x => x.IsNotEmptyOrNull())))
      {
        if (PathTools.CheckCommonParent(commonParent + "/" + str, restPathToParse))
          commonParent = commonParent + "/" + str;
        else
          break;
      }
      return commonParent;
    }

    public static bool CheckCommonParent(string commonParrent, string[] restPathToParse)
    {
      bool flag = true;
      foreach (string str in restPathToParse)
      {
        flag = str.StartsWith(commonParrent);
        if (!flag)
          break;
      }
      return flag;
    }
  }
}
