// Decompiled with JetBrains decompiler
// Type: RiskManagement.Game
// Assembly: IRefle, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 09188B70-FC90-4B10-A900-838DE205A659
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.02-msil\Backdoor.MSIL.Crysan.drn-7517431630373a1eec83586fad357154d832851724f8aa57ce6561d87ee8f8f1.exe

using SimpleJSON;
using System;
using System.Collections.Generic;
using System.Text;

namespace RiskManagement
{
  public class Game
  {
    public readonly Rules Rules;
    public readonly Player[] Players;
    private readonly PlayerState[] _playerStates;
    private readonly Dice _dice;
    private List<Card> _deck;
    public readonly List<int> Winners = new List<int>();
    public readonly List<int> Losers = new List<int>();
    private int _currentPlayer = 2147483645;
    private int _currentTurn;
    private List<float> _chances;
    private readonly Random _random;
    private readonly StringBuilder _buffer;
    private bool _finished;
    private int _currentChanceIndex;

    public Game(JSONNode json, StringBuilder buffer)
    {
      this._buffer = buffer;
      this._random = new Random((int) DateTime.Now.Ticks);
      this.Rules = Rules.Deserialize(json["rules"]);
      this._dice = new Dice();
      JSONNode jsonNode = json["players"];
      int count = jsonNode.Count;
      this.Players = new Player[count];
      for (int aIndex = 0; aIndex < count; ++aIndex)
        this.Players[aIndex] = Player.Deserialize(jsonNode[aIndex]);
      this._playerStates = new PlayerState[count];
      for (int index = 0; index < count; ++index)
        this._playerStates[index] = new PlayerState();
    }

    public bool Finished
    {
      get
      {
        if (this._finished)
          return true;
        foreach (PlayerState playerState in this._playerStates)
        {
          if (playerState.State == State.Playing)
            return false;
        }
        return true;
      }
    }

    public void ShuffleCards() => this._deck = new List<Card>((IEnumerable<Card>) this.Rules.Cards);

    public void StartNew()
    {
      this.ShuffleCards();
      this.Winners.Clear();
      this.Losers.Clear();
      this._currentPlayer = this.Players.Length;
      this._currentTurn = 0;
      this._finished = false;
      this._currentChanceIndex = -1;
      this._chances = new List<float>((IEnumerable<float>) this.Rules.RiskChances);
    }

    public void PlanningState()
    {
      for (int index = 0; index < this.Players.Length; ++index)
      {
        Player player = this.Players[index];
        PlayerState playerState = this._playerStates[index];
        playerState.Sprint = 0;
        playerState.Resources = this.Rules.InitialResources;
        playerState.State = State.Playing;
        int planningCardsCount = player.PlanningCardsCount;
        int num = 0;
        if (planningCardsCount == 0)
        {
          playerState.Sprint = 1;
        }
        else
        {
          num = planningCardsCount - this.Rules.NormalPlanningCount;
          if (player.UseOneMorePlanningSprint)
          {
            playerState.Sprint = -1;
            playerState.Resources -= num * this.Rules.NormalPlanningCost;
          }
          else if (num > 0)
            playerState.Resources -= num * this.Rules.OverPlanningCost;
          else
            num = 0;
        }
        playerState.Resources -= (planningCardsCount - num) * this.Rules.NormalPlanningCost;
      }
    }

    public void TurnState()
    {
      ++this._currentPlayer;
      if (this._currentPlayer >= this.Players.Length)
      {
        this._currentPlayer = 0;
        if (this._currentTurn > 0)
          this.Print((object) "\n\nGAME STATE\n{0}\n\n-- END OF TURN {1} --\n\n", (object) this, (object) this._currentTurn);
        this.Print((object) ("-- BEGINNING OF TURN " + (++this._currentTurn).ToString() + " --"));
        this._currentChanceIndex = (this._currentChanceIndex + 1) % this._chances.Count;
        this.Print((object) ("RISK CHANCE: " + this.Rules.RiskChances[this._currentChanceIndex].ToString()));
      }
      this.PlayerTurn(this._currentPlayer);
    }

    private void PlayerTurn(int playerIndex)
    {
      Player player = this.Players[playerIndex];
      PlayerState playerState1 = this._playerStates[playerIndex];
      this.Print((object) ("\nPLAYER " + playerIndex.ToString()));
      if (playerState1.State != State.Playing)
        this.Print((object) playerState1.State);
      else if (playerState1.Sprint < 0)
      {
        ++playerState1.Sprint;
        this.Print((object) "Still planning");
      }
      else
      {
        bool flag1;
        if (!this._dice.Roll(this._chances[this._currentChanceIndex]))
        {
          flag1 = true;
          this.Print((object) "CARD: none, advance");
        }
        else
        {
          Card card = this.DrawCard();
          bool flag2 = card.Impact < 0;
          bool flag3 = this.Rules.EconomicsAffectsAll && card.Type == 4;
          int num;
          if (!flag2)
          {
            int val2 = card.Impact - player.PlannedForCard(card.Type);
            flag1 = val2 < this.Rules.StayOnSprintMinDiff;
            num = Math.Max(0, val2);
          }
          else
          {
            flag1 = true;
            num = card.Impact;
          }
          this.Print((object) "CARD: {0}, {1}{2} {3} and {4}", (object) card, flag3 ? (object) "ALL " : (object) "", flag2 ? (object) "receives" : (object) "pays", (object) Math.Abs(num), flag1 ? (object) "advance" : (object) "stay");
          if (!flag3)
          {
            playerState1.Resources -= num;
            if (playerState1.Resources < 0)
            {
              playerState1.State = State.Lose;
              if (!this.Losers.Contains(playerIndex))
                this.Losers.Add(playerIndex);
              flag1 = false;
            }
          }
          else
          {
            for (int index = 0; index < this._playerStates.Length; ++index)
            {
              PlayerState playerState2 = this._playerStates[index];
              playerState2.Resources -= Math.Max(0, num - this.Players[index].PlannedForCard(card.Type));
              if (playerState2.Resources < 0)
              {
                playerState2.State = State.Lose;
                if (!this.Losers.Contains(index))
                  this.Losers.Add(index);
              }
            }
          }
        }
        if (flag1)
          ++playerState1.Sprint;
        if (playerState1.Sprint > this.Rules.SprintCount)
        {
          playerState1.State = State.Won;
          this.Winners.Add(playerIndex);
          if (this.Rules.OnlyOneWinner)
          {
            this._finished = true;
            for (int index = 0; index < this._playerStates.Length; ++index)
            {
              if (index != playerIndex && !this.Losers.Contains(index))
                this.Losers.Add(index);
            }
          }
        }
        this.Print((object) ("\t" + playerState1?.ToString()));
      }
    }

    private Card DrawCard()
    {
      if (this._deck.Count <= 0)
        this.ShuffleCards();
      Card card = this._deck[0];
      this._deck.RemoveAt(0);
      return card;
    }

    public string ToString(bool initial)
    {
      string str = "";
      for (int index = 0; index < this._playerStates.Length; ++index)
        str = str + index.ToString() + ": " + this._playerStates[index]?.ToString() + "\n";
      return str;
    }

    public override string ToString() => this.ToString(false);

    private void Print(object text, params object[] more) => this._buffer.AppendLine(string.Format(text.ToString(), more));
  }
}
