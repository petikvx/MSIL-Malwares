// Decompiled with JetBrains decompiler
// Type: Borland.Delphi.System.TMethodMap
// Assembly: Project1, Version=1.0.1859.4414, Culture=neutral, PublicKeyToken=null
// MVID: 387A0727-86C4-4744-A694-CF2F2E0F060B
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.MSIL.WMC.10-fd5e584bd80ce552c9df6b54aeb5b165ab53ae3852db7b074873a0872cf5dc56.exe

using Borland.Delphi.System.;
using System;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Borland.Delphi.System
{
  internal class TMethodMap
  {
    internal Hashtable FMethods;
    internal MethodInfo FDefault;

    internal MethodInfo GetItems(int Index) => (MethodInfo) this.FMethods[(object) Index];

    public TMethodMap(Type ClassType)
    {
      this.FMethods = new Hashtable();
      MethodInfo[] methods = ClassType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
      int num1 = (methods != null ? methods.Length : 0) - 1;
      int index1 = 0;
      if (num1 >= index1)
      {
        int num2 = num1 + 1;
        do
        {
          MethodInfo methodInfo = methods[index1];
          object[] customAttributes = methodInfo.GetCustomAttributes(typeof (MessageMethodAttribute), false);
          if ((customAttributes != null ? customAttributes.Length : 0) > 0)
          {
            ParameterInfo[] parameters = methodInfo.GetParameters();
            if ((parameters != null ? parameters.Length : 0) == 1)
            {
              int num3 = (customAttributes != null ? customAttributes.Length : 0) - 1;
              int index2 = 0;
              if (num3 >= index2)
              {
                int num4 = num3 + 1;
                do
                {
                  this.FMethods[(object) ((MessageMethodAttribute) customAttributes[index2]).ID] = (object) methodInfo;
                  ++index2;
                }
                while (index2 != num4);
              }
            }
          }
          ++index1;
        }
        while (index1 != num2);
      }
      this.FDefault = ClassType.GetMethod("DefaultHandler", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public);
      if ((object) this.FDefault == null)
        return;
      ParameterInfo[] parameters1 = this.FDefault.GetParameters();
      if ((parameters1 != null ? parameters1.Length : 0) == 1)
        return;
      this.FDefault = (MethodInfo) null;
    }

    [Browsable(false)]
    [IndexerName("Items")]
    public MethodInfo this[int Index] => this.GetItems(Index);

    [Browsable(false)]
    public MethodInfo Default => this.FDefault;

    public void Free() => TObjectHelper.Free((object) this);

    [return: TAliasType(typeof (TClass))]
    public \u0040TClass ClassType() => TObjectHelper.ClassType((object) this);

    public static string ClassName([TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self) => TObjectHelper.ClassName((\u0040TClass) Self);

    public static bool ClassNameIs([TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self, [In] string Name) => TObjectHelper.ClassNameIs((\u0040TClass) Self, Name);

    [return: TAliasType(typeof (TClass))]
    public static \u0040TClass ClassParent([TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self) => TObjectHelper.ClassParent((\u0040TClass) Self);

    public static Type ClassInfo([TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self) => TObjectHelper.ClassInfo((\u0040TClass) Self);

    public static bool InheritsFrom([TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self, \u0040TClass AClass) => TObjectHelper.InheritsFrom((\u0040TClass) Self, AClass);

    public static MemberInfo MethodAddress(
      [TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self,
      [In] string AName)
    {
      return TObjectHelper.MethodAddress((\u0040TClass) Self, AName);
    }

    public static string MethodName([TAliasType(typeof (TMethodMap))] TMethodMap.\u0040MetaTMethodMap Self, MemberInfo ACode) => TObjectHelper.MethodName((\u0040TClass) Self, ACode);

    public object FieldAddress([In] string AName) => TObjectHelper.FieldAddress((object) this, AName);

    public void Dispatch(ref object Message) => TObjectHelper.Dispatch((object) this, ref Message);

    static TMethodMap() => RuntimeHelpers.RunClassConstructor(__typeref (Unit));

    [ComVisible(false)]
    [CLSCompliant(false)]
    protected internal class \u0040MetaTMethodMap : \u0040TClass
    {
      public static TMethodMap.\u0040MetaTMethodMap \u0040Instance = new TMethodMap.\u0040MetaTMethodMap();

      public \u0040MetaTMethodMap() => this.FInstanceTypeHandle = __typeref (TMethodMap);

      static \u0040MetaTMethodMap() => RuntimeHelpers.RunClassConstructor(__typeref (TMethodMap));

      public virtual object \u0040Create(Type ClassType) => (object) new TMethodMap(ClassType);
    }
  }
}
