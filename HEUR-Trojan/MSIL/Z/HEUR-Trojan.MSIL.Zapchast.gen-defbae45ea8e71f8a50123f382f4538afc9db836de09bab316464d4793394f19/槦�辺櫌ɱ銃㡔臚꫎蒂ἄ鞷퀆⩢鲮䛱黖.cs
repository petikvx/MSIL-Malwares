// Decompiled with JetBrains decompiler
// Type: 槦�辺櫌ɱ銃㡔臚꫎蒂ἄ鞷퀆⩢鲮䛱黖
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan.MSIL.Zapchast.gen-defbae45ea8e71f8a50123f382f4538afc9db836de09bab316464d4793394f19.exe

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public static class 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖
{
  private const int ꂠﯸ캛ꇸ及㛘觋告纻ᷯ쿑䧕䈎\uE7FB\u09BB燷厃ꝿ穧逌 = 16;
  private const int 걔畨\u2A06暟쇭\uF8A9ه\uFFFD蓿꽳\uF099\uFFFD瞹覄茝祼됛瘵ꄬ\uF228 = 32;
  private static byte[] ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡;
  private static byte[] ꜱ䠷\uFFFD藬眕쐅뷢\uFFFDጼ褘\u0EBF뫹榘欶梎㭫ﶽ并嫥䄫;
  public static readonly byte[] \u2578纕ᦌ\uFFFD\u2E15洍\uFFFD\u2FE6둼\u23E2揱塺ꭂ뽨ꈰ\u2A1Cᴿ뺧䜽\u0EE2 = new byte[32]
  {
    (byte) 191,
    (byte) 235,
    (byte) 30,
    (byte) 86,
    (byte) 251,
    (byte) 205,
    (byte) 151,
    (byte) 59,
    (byte) 178,
    (byte) 25,
    (byte) 2,
    (byte) 36,
    (byte) 48,
    (byte) 165,
    (byte) 120,
    (byte) 67,
    (byte) 0,
    (byte) 61,
    (byte) 86,
    (byte) 68,
    (byte) 210,
    (byte) 30,
    (byte) 98,
    (byte) 185,
    (byte) 212,
    (byte) 241,
    (byte) 128,
    (byte) 231,
    (byte) 230,
    (byte) 195,
    (byte) 57,
    (byte) 65
  };

  public static void ᘥ๕ꎙ씘\u2A3A䏈府\uE5E1毋蝤\uF0D3폨祲硚팛灻\uF04B飅㸻肥(string key)
  {
    using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.\u2578纕ᦌ\uFFFD\u2E15洍\uFFFD\u2FE6둼\u23E2揱塺ꭂ뽨ꈰ\u2A1Cᴿ뺧䜽\u0EE2, 50000))
    {
      槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡 = rfc2898DeriveBytes.GetBytes(16);
      槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ꜱ䠷\uFFFD藬眕쐅뷢\uFFFDጼ褘\u0EBF뫹榘欶梎㭫ﶽ并嫥䄫 = rfc2898DeriveBytes.GetBytes(64);
    }
  }

  public static void 鶙磵噇曁\u9FFF讆갈䕡\uE9DC縓\uF224偅彺ﺍꡇȖ賋\uFFFD퉮륈(string key, string authKey)
  {
    槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡 = Convert.FromBase64String(key);
    槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ꜱ䠷\uFFFD藬眕쐅뷢\uFFFDጼ褘\u0EBF뫹榘欶梎㭫ﶽ并嫥䄫 = Convert.FromBase64String(authKey);
  }

  public static string 됀纺ྐྵ竦᷂᠋쵳\uE273\uFFFD蕻쬔衋㘼\uE4BC异矱\uE0A3郠䤦助(string input, string key) => Convert.ToBase64String(槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.詍\u055A\u1AA4뱲ᓸ陟숒\u3197㭓੨뫎䁄ꌃ镮\u28D5창\uFBC6諸兦\u2EFA(Encoding.UTF8.GetBytes(input), Encoding.UTF8.GetBytes(key)));

  public static string 鑝\u2E9Eު倪豕揥\u09F2\u29AA뿲塳흶仒㟀漺ѷ\u242A\uEB68㗙㖣\u3008(string input) => Convert.ToBase64String(槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.\uF34A痚\uFFFD\uF033樔䖍뤲秖恑\uFFFD正绫裘\uEC68\uE055\uF412탣뛚銸宅(Encoding.UTF8.GetBytes(input)));

  public static byte[] \uF34A痚\uFFFD\uF033樔䖍뤲秖恑\uFFFD正绫裘\uEC68\uE055\uF412탣뛚銸宅(byte[] input)
  {
    if (槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡 == null || 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡.Length == 0)
      throw new Exception("Key can not be empty.");
    byte[] buffer = input != null && input.Length != 0 ? input : throw new ArgumentException("Input can not be empty.");
    byte[] numArray = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        memoryStream.Position = 32L;
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡;
          cryptoServiceProvider.GenerateIV();
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
          {
            memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
            using (HMACSHA256 hmacshA256 = new HMACSHA256(槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ꜱ䠷\uFFFD藬眕쐅뷢\uFFFDጼ褘\u0EBF뫹榘欶梎㭫ﶽ并嫥䄫))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              memoryStream.Position = 0L;
              memoryStream.Write(hash, 0, hash.Length);
            }
          }
        }
        numArray = memoryStream.ToArray();
      }
    }
    catch
    {
    }
    return numArray;
  }

  public static byte[] 詍\u055A\u1AA4뱲ᓸ陟숒\u3197㭓੨뫎䁄ꌃ镮\u28D5창\uFBC6諸兦\u2EFA(byte[] input, byte[] key)
  {
    if (key == null || key.Length == 0)
      throw new Exception("Key can not be empty.");
    byte[] bytes;
    using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.\u2578纕ᦌ\uFFFD\u2E15洍\uFFFD\u2FE6둼\u23E2揱塺ꭂ뽨ꈰ\u2A1Cᴿ뺧䜽\u0EE2, 50000))
    {
      key = rfc2898DeriveBytes.GetBytes(16);
      bytes = rfc2898DeriveBytes.GetBytes(64);
    }
    byte[] buffer = input;
    byte[] numArray = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        memoryStream.Position = 32L;
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = key;
          cryptoServiceProvider.GenerateIV();
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
          {
            memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
            using (HMACSHA256 hmacshA256 = new HMACSHA256(bytes))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              memoryStream.Position = 0L;
              memoryStream.Write(hash, 0, hash.Length);
            }
          }
        }
        numArray = memoryStream.ToArray();
      }
    }
    catch
    {
    }
    return numArray;
  }

  public static string \u0B68繰㱳8\uF891肬ꔶ륪\u2759飘ɇ\u31E1\u005B\uEE04넗沷ꮝ듬홹榾(string input) => Encoding.UTF8.GetString(槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.\uFFFD빚ꍮレ叼侽钲狷徸\u32E8ᕈꣽ絨蜞\u32DF從䩃댛枘顏(Convert.FromBase64String(input)));

  public static byte[] \uFFFD빚ꍮレ叼侽钲狷徸\u32E8ᕈꣽ絨蜞\u32DF從䩃댛枘顏(byte[] input)
  {
    if (槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡 == null || 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡.Length == 0)
      throw new Exception("Key can not be empty.");
    if (input == null || input.Length == 0)
      throw new ArgumentException("Input can not be empty.");
    byte[] dst = new byte[0];
    try
    {
      using (MemoryStream memoryStream = new MemoryStream(input))
      {
        using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        {
          cryptoServiceProvider.KeySize = 128;
          cryptoServiceProvider.BlockSize = 128;
          cryptoServiceProvider.Mode = CipherMode.CBC;
          cryptoServiceProvider.Padding = PaddingMode.PKCS7;
          cryptoServiceProvider.Key = 槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ʔↁ\u2943鷨ଙ씘û婈ᢪᾒ겢\uFFFD늂卄\uFFFD楪\u2A1E酺ﲲ疡;
          using (HMACSHA256 hmacshA256 = new HMACSHA256(槦\uFFFD辺櫌\uEA69ɱ\uE127\uE010銃㡔臚\uAACE蒂ἄ鞷퀆\u2A62鲮䛱黖.ꜱ䠷\uFFFD藬眕쐅뷢\uFFFDጼ褘\u0EBF뫹榘欶梎㭫ﶽ并嫥䄫))
          {
            byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
            byte[] buffer = new byte[32];
            memoryStream.Read(buffer, 0, buffer.Length);
            byte[] a2 = buffer;
            if (!獫ꞏ\uEC6E系鷾棼\uFFFD溯ꚭ\u2B0B鶄訶璾ꂓ녃饓\uFFFDⶆ츬㦦.\uFFFD玧㓠ᖳ뚉緳\u007C飣ƿ\u2975휳蠳䀗\uF4E6㡜呿Ḋ搨幧쵈(hash, a2))
              return dst;
          }
          byte[] buffer1 = new byte[16];
          memoryStream.Read(buffer1, 0, 16);
          cryptoServiceProvider.IV = buffer1;
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateDecryptor(), CryptoStreamMode.Read))
          {
            byte[] numArray = new byte[memoryStream.Length - 16L + 1L];
            dst = new byte[cryptoStream.Read(numArray, 0, numArray.Length)];
            Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 0, dst.Length);
          }
        }
      }
    }
    catch
    {
    }
    return dst;
  }
}
