// Decompiled with JetBrains decompiler
// Type: SimpleVideoCutter.VideoCutterTimeline
// Assembly: SimpleVideoCutter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EC3F1699-ABA1-43FB-A799-9F64138760E7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f61a916b55390990f502b60b4e78cb70d9da9416954b3cb35908cf3498ac3ead.exe

using SimpleVideoCutter.Properties;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Windows.Forms;

namespace SimpleVideoCutter
{
  public class VideoCutterTimeline : UserControl
  {
    private Brush brushBackground = (Brush) new SolidBrush(Color.FromArgb(173, 181, 189));
    private Brush brushBackgroundInfoArea = (Brush) new SolidBrush(Color.FromArgb(173, 181, 189));
    private Brush brushBackgroundInfoAreaOffset = (Brush) new SolidBrush(Color.FromArgb(108, 117, 125));
    private Brush brushTicksArea = (Brush) new SolidBrush(Color.FromArgb(73, 80, 87));
    private Brush brushSelectionArea = (Brush) new SolidBrush(Color.FromArgb(108, 117, 125));
    private Brush brushBackgroundSelected = (Brush) new HatchBrush(HatchStyle.DarkDownwardDiagonal, Color.FromArgb(248, 249, 250), Color.FromArgb(128, 248, 249, 250));
    private Brush brushInfoAreaText = (Brush) new SolidBrush(Color.FromArgb(248, 249, 250));
    private Pen penBigTicks = new Pen(Color.FromArgb(233, 236, 239));
    private Pen penSmallTicks = new Pen(Color.FromArgb(173, 181, 189));
    private Brush brushHoverPosition = (Brush) new SolidBrush(Color.FromArgb(200, 23, 23));
    private Brush brushPosition = (Brush) new SolidBrush(Color.FromArgb(0, 92, 158));
    private Brush brushKeyFrames = (Brush) new SolidBrush(Color.FromArgb(135, 146, 155));
    private Brush brushSelectionMarker = (Brush) new SolidBrush(Color.FromArgb(33, 37, 41));
    private Pen penSelectionMarker = new Pen(Color.FromArgb(33, 37, 41));
    private SelectionsMoveController selectionsMoveController;
    private long position = 0;
    private long? hoverPosition = new long?();
    private Selections selections = new Selections();
    private long? newSelectionStart = new long?();
    private float scale = 1f;
    private long offset = 0;
    private long length = 0;
    private IContainer components = (IContainer) null;

    public event EventHandler<TimelineHoverEventArgs> TimelineHover;

    public event EventHandler<SelectionChangedEventArgs> SelectionChanged;

    public event EventHandler<PositionChangeRequestEventArgs> PositionChangeRequest;

    public event EventHandler<KeyframesRequestEventArgs> KeyframesRequest;

    public bool NewSelectionStartRegistered => this.newSelectionStart.HasValue;

    public long Length
    {
      get => this.length;
      set
      {
        this.length = value;
        this.offset = 0L;
        this.scale = 1f;
        this.Refresh();
      }
    }

    public long Position
    {
      get => this.position;
      set
      {
        this.position = value;
        if (this.PositionToPixel(new long?(this.position)) > this.ClientRectangle.Width)
        {
          long num = this.position;
          if ((double) num + (double) this.ClientRectangle.Width * (double) this.MillisecondsPerPixels() > (double) this.Length)
            num = this.Length - (long) ((double) this.ClientRectangle.Width * (double) this.MillisecondsPerPixels());
          this.offset = num;
          this.EnsureOffsetInBounds();
        }
        this.Refresh();
      }
    }

    public long? HoverPosition
    {
      get => this.hoverPosition;
      set
      {
        long? hoverPosition = this.hoverPosition;
        long? nullable = value;
        if (hoverPosition.GetValueOrDefault() == nullable.GetValueOrDefault() && hoverPosition.HasValue == nullable.HasValue)
          return;
        this.hoverPosition = value;
        this.Invalidate();
        EventHandler<TimelineHoverEventArgs> timelineHover = this.TimelineHover;
        if (timelineHover == null)
          return;
        timelineHover((object) this, new TimelineHoverEventArgs());
      }
    }

    public VideoCutterTimeline()
    {
      this.InitializeComponent();
      this.selectionsMoveController = new SelectionsMoveController(this, this.selections);
      this.selections.SelectionsChanged += (EventHandler<EventArgs>) ((s, e) =>
      {
        this.Invalidate();
        this.OnSelectionChanged();
      });
    }

    protected override void OnMouseWheel(MouseEventArgs e)
    {
      base.OnMouseWheel(e);
      int num1 = e.Delta * (Control.ModifierKeys.HasFlag((Enum) Keys.Shift) ? 10 : 1);
      long? hoverPosition = this.HoverPosition;
      this.HoverPosition = new long?();
      if (Control.ModifierKeys.HasFlag((Enum) Keys.Control))
      {
        float num2 = this.scale + (float) (num1 / SystemInformation.MouseWheelScrollDelta) * 0.25f;
        if ((double) num2 < 1.0)
          num2 = 1f;
        if ((double) num2 > (double) this.scale)
        {
          float x = (float) this.ClientRectangle.Width / 2f;
          if (hoverPosition.HasValue)
            x = (float) this.PositionToPixel(hoverPosition);
          this.offset += this.PixelToPosition(x) - this.PixelToPosition(x, new float?(num2));
          this.offset = Math.Max(this.offset, 0L);
        }
        else if ((double) num2 < (double) this.scale)
        {
          float x = (float) this.ClientRectangle.Width / 2f;
          if (hoverPosition.HasValue)
            x = (float) this.PositionToPixel(hoverPosition);
          this.offset += this.PixelToPosition(x) - this.PixelToPosition(x, new float?(num2));
          this.offset = Math.Max(this.offset, 0L);
        }
        this.scale = num2;
      }
      else
      {
        float num3 = (float) ((double) this.ClientRectangle.Width * (double) this.MillisecondsPerPixels() / 10.0);
        this.offset = Math.Max(this.offset - (long) (int) ((double) (num1 / SystemInformation.MouseWheelScrollDelta) * (double) num3), 0L);
      }
      this.EnsureOffsetInBounds();
      this.Refresh();
    }

    private void EnsureOffsetInBounds()
    {
      if ((double) this.offset + (double) this.ClientRectangle.Width * (double) this.MillisecondsPerPixels() > (double) this.Length)
        this.offset = this.Length - (long) ((double) this.ClientRectangle.Width * (double) this.MillisecondsPerPixels());
      this.offset = Math.Max(this.offset, 0L);
    }

    private KeyframesRequestEventArgs GetKeyframesData()
    {
      if (this.KeyframesRequest == null)
        return (KeyframesRequestEventArgs) null;
      KeyframesRequestEventArgs e = new KeyframesRequestEventArgs();
      this.KeyframesRequest((object) this, e);
      return e;
    }

    private long LocateNearestKeyFrame(long position)
    {
      KeyframesRequestEventArgs keyframesData = this.GetKeyframesData();
      if (keyframesData == null || keyframesData.Keyframes == null || keyframesData.Keyframes.Count == 0)
        return position;
      List<long> keyframes = keyframesData.Keyframes;
      int num1 = keyframes.BinarySearch(position);
      if (num1 >= 0)
        return position;
      int index = ~num1;
      long? nullable1 = new long?(index < keyframes.Count ? keyframes[index] : this.Length - 1L);
      long? nullable2 = index > 0 ? new long?(keyframes[index - 1]) : new long?();
      long num2 = position;
      long? nullable3 = nullable1;
      long? nullable4 = nullable3.HasValue ? new long?(num2 - nullable3.GetValueOrDefault()) : new long?();
      long num3 = Math.Abs(nullable4 ?? position + long.MaxValue);
      long num4 = position;
      nullable3 = nullable2;
      nullable4 = nullable3.HasValue ? new long?(num4 - nullable3.GetValueOrDefault()) : new long?();
      long num5 = Math.Abs(nullable4 ?? position + long.MaxValue);
      return num3 < num5 ? nullable1.Value : nullable2.Value;
    }

    private long FindNearestAcceptableKeyFrame(long position)
    {
      long num1 = this.LocateNearestKeyFrame(position);
      long num2 = (long) (5.0 / (double) this.PixelsPerMilliseconds());
      return Math.Abs(position - num1) > num2 ? position : num1;
    }

    private void VideoCutterTimeline_Paint(object sender, PaintEventArgs e)
    {
      e.Graphics.FillRectangle(this.brushBackground, this.ClientRectangle);
      if (this.Length == 0L)
        return;
      VideoCutterTimeline.TimelineTooltip timelineTooltip = (VideoCutterTimeline.TimelineTooltip) null;
      int num1 = 22;
      Rectangle rectangle;
      ref Rectangle local1 = ref rectangle;
      Rectangle clientRectangle = this.ClientRectangle;
      int x1 = clientRectangle.X;
      clientRectangle = this.ClientRectangle;
      int y1 = clientRectangle.Y;
      clientRectangle = this.ClientRectangle;
      int width1 = clientRectangle.Width;
      int height1 = num1;
      local1 = new Rectangle(x1, y1, width1, height1);
      e.Graphics.FillRectangle(this.brushBackgroundInfoArea, rectangle);
      double num2 = (double) this.offset / (double) this.Length;
      clientRectangle = this.ClientRectangle;
      double width2 = (double) clientRectangle.Width;
      float x2 = (float) (num2 * width2);
      clientRectangle = this.ClientRectangle;
      double num3 = (double) this.PixelToPosition((float) clientRectangle.Width) / (double) this.Length;
      clientRectangle = this.ClientRectangle;
      double width3 = (double) clientRectangle.Width;
      float num4 = (float) (num3 * width3);
      e.Graphics.FillRectangle(this.brushBackgroundInfoAreaOffset, x2, 0.0f, num4 - x2, (float) num1);
      string str1 = string.Format(string.Format("{0}: {1:hh\\:mm\\:ss\\:fff} ", (object) GlobalStrings.VideoCutterTimeline_Time, (object) TimeSpan.FromMilliseconds((double) this.Position)));
      long? hoverPosition = this.HoverPosition;
      if (hoverPosition.HasValue)
      {
        hoverPosition = this.HoverPosition;
        TimeSpan timeSpan = TimeSpan.FromMilliseconds((double) hoverPosition.Value);
        str1 += string.Format(string.Format(" {0}: {1:hh\\:mm\\:ss\\:fff} ", (object) GlobalStrings.VideoCutterTimeline_HoveredTime, (object) timeSpan));
      }
      this.PaintStringInBox(e.Graphics, (Brush) null, this.brushInfoAreaText, str1, rectangle, 12);
      e.Graphics.TranslateTransform(0.0f, (float) num1);
      int num5 = 30;
      int height2 = 30;
      Rectangle rect1;
      ref Rectangle local2 = ref rect1;
      clientRectangle = this.ClientRectangle;
      int x3 = clientRectangle.X;
      clientRectangle = this.ClientRectangle;
      int y2 = clientRectangle.Y;
      clientRectangle = this.ClientRectangle;
      int width4 = clientRectangle.Width;
      int height3 = num5 + height2;
      local2 = new Rectangle(x3, y2, width4, height3);
      e.Graphics.FillRectangle(this.brushSelectionArea, rect1);
      Rectangle rect2;
      ref Rectangle local3 = ref rect2;
      clientRectangle = this.ClientRectangle;
      int x4 = clientRectangle.X;
      clientRectangle = this.ClientRectangle;
      int y3 = clientRectangle.Y;
      clientRectangle = this.ClientRectangle;
      int width5 = clientRectangle.Width;
      int height4 = num5;
      local3 = new Rectangle(x4, y3, width5, height4);
      e.Graphics.FillRectangle(this.brushTicksArea, rect2);
      float num6 = this.PixelsPerMilliseconds() * 1000f;
      for (long index = 0; index <= this.Length; index += 1000L)
      {
        TimeSpan timeSpan = TimeSpan.FromMilliseconds((double) index);
        float num7 = (float) (index - this.offset) * this.PixelsPerMilliseconds();
        double num8 = (double) num7;
        clientRectangle = this.ClientRectangle;
        double num9 = (double) -clientRectangle.Width;
        int num10;
        if (num8 >= num9)
        {
          double num11 = (double) num7;
          clientRectangle = this.ClientRectangle;
          double width6 = (double) clientRectangle.Width;
          num10 = num11 <= width6 ? 1 : 0;
        }
        else
          num10 = 0;
        if (num10 != 0)
        {
          string str2 = timeSpan.TotalHours <= 1.0 ? string.Format(string.Format("{0:mm\\:ss}", (object) timeSpan)) : string.Format(string.Format("{0:hh\\:mm\\:ss}", (object) timeSpan));
          double num12 = Math.Ceiling((double) e.Graphics.MeasureString(str2, this.Font).Width * 2.0 / (double) num6);
          bool flag = timeSpan.TotalSeconds % num12 == 0.0;
          if (flag)
          {
            Rectangle layoutRectangle = new Rectangle((int) num7 + 2, 0, 100, num5);
            e.Graphics.DrawString(str2, this.Font, this.penBigTicks.Brush, (RectangleF) layoutRectangle, StringFormat.GenericDefault);
          }
          if (flag)
            e.Graphics.DrawLine(this.penBigTicks, (int) num7, num5 / 2, (int) num7, num5 + height2);
          else
            e.Graphics.DrawLine(this.penSmallTicks, (int) num7, 3 * (num5 / 4), (int) num7, num5);
        }
      }
      e.Graphics.TranslateTransform(0.0f, (float) num5);
      KeyframesRequestEventArgs keyframesData = this.GetKeyframesData();
      List<long> keyframes = keyframesData?.Keyframes;
      if (keyframes != null)
      {
        int num13 = keyframesData.InProgress ? keyframes.Count - 1 : keyframes.Count;
        for (int index = 1; index <= num13; index += 2)
        {
          long num14 = index == keyframes.Count ? this.Length : keyframes[index];
          float x5 = (float) (keyframes[index - 1] - this.offset) * this.PixelsPerMilliseconds();
          float num15 = (float) (num14 - this.offset) * this.PixelsPerMilliseconds();
          e.Graphics.FillRectangle(this.brushKeyFrames, x5, 0.0f, num15 - x5, (float) height2);
        }
      }
      for (int i = 0; i < this.selections.Count; ++i)
      {
        Selection selection = this.selections[i];
        int pixel1 = this.PositionToPixel(new long?(selection.Start));
        int pixel2 = this.PositionToPixel(new long?(selection.End));
        Rectangle rect3 = new Rectangle(pixel1, 0, pixel2 - pixel1, height2);
        e.Graphics.FillRectangle(this.brushBackgroundSelected, rect3);
        int pixel3 = this.PositionToPixel(new long?(selection.Start));
        GraphicsUtils.DrawSolidRectangle(e.Graphics, this.brushSelectionMarker, this.penSelectionMarker, pixel3 - 1, 0, 2, height2);
        int pixel4 = this.PositionToPixel(new long?(selection.End));
        GraphicsUtils.DrawSolidRectangle(e.Graphics, this.brushSelectionMarker, this.penSelectionMarker, pixel4 - 1, 0, 2, height2);
      }
      if (this.newSelectionStart.HasValue)
      {
        int pixel = this.PositionToPixel(new long?(this.newSelectionStart.Value));
        GraphicsUtils.DrawSolidRectangle(e.Graphics, this.brushSelectionMarker, this.penSelectionMarker, pixel - 1, 0, 2, height2);
      }
      e.Graphics.ResetTransform();
      e.Graphics.TranslateTransform(0.0f, (float) num1);
      int pixel5 = this.PositionToPixel(new long?(this.Position));
      e.Graphics.FillRectangle(this.brushPosition, pixel5, 0, 3, num5 + height2);
      hoverPosition = this.HoverPosition;
      if (hoverPosition.HasValue)
      {
        hoverPosition = this.HoverPosition;
        long frame1 = hoverPosition.Value;
        int pixel6 = this.PositionToPixel(new long?(frame1));
        if (this.selectionsMoveController.IsDragStartPossibleFrame(frame1))
          timelineTooltip = new VideoCutterTimeline.TimelineTooltip()
          {
            X = pixel6,
            Text = GlobalStrings.VideoCutterTimeline_MoveClipStart
          };
        if (this.selectionsMoveController.IsDragEndPossibleFrame(frame1))
          timelineTooltip = new VideoCutterTimeline.TimelineTooltip()
          {
            X = pixel6,
            Text = GlobalStrings.VideoCutterTimeline_MoveClipEnd
          };
        e.Graphics.FillRectangle(this.brushHoverPosition, pixel6, 0, 3, num5 + height2);
        this.PaintTriangle(e.Graphics, this.brushHoverPosition, this.PositionToPixel(new long?(frame1)) + 1, 8, 8);
        string str3 = (string) null;
        switch (Control.ModifierKeys)
        {
          case Keys.Shift:
            str3 = GlobalStrings.VideoCutterTimeline_SetClipFromHereTillEnd;
            break;
          case Keys.Control:
            str3 = GlobalStrings.VideoCutterTimeline_SetClipFromStartTillHere;
            break;
        }
        int num16;
        if (!this.newSelectionStart.HasValue)
        {
          Selections selections = this.selections;
          hoverPosition = this.HoverPosition;
          long frame2 = hoverPosition.Value;
          num16 = selections.CanStartSelectionAtFrame(frame2) ? 1 : 0;
        }
        else
          num16 = 0;
        if (num16 != 0)
        {
          timelineTooltip = new VideoCutterTimeline.TimelineTooltip()
          {
            X = pixel6,
            Text = str3 ?? GlobalStrings.VideoCutterTimeline_SetClipStartHere
          };
        }
        else
        {
          int num17;
          if (this.newSelectionStart.HasValue && frame1 > this.newSelectionStart.Value)
          {
            Selections selections = this.selections;
            long start = this.newSelectionStart.Value;
            hoverPosition = this.HoverPosition;
            long end = hoverPosition.Value;
            num17 = selections.CanAddSelection(start, end) ? 1 : 0;
          }
          else
            num17 = 0;
          if (num17 != 0)
            timelineTooltip = new VideoCutterTimeline.TimelineTooltip()
            {
              X = pixel6,
              Text = str3 ?? GlobalStrings.VideoCutterTimeline_SetClipEndHere
            };
        }
      }
      e.Graphics.ResetTransform();
      if (timelineTooltip == null)
        return;
      this.PaintStringInBox(e.Graphics, Brushes.LightYellow, Brushes.Gray, timelineTooltip.Text, rectangle, timelineTooltip.X);
    }

    private void PaintStringInBox(
      Graphics gr,
      Brush background,
      Brush textBrush,
      string str,
      Rectangle parentRectangle,
      int location)
    {
      Font font = this.Font;
      SizeF sizeF = gr.MeasureString(str, font);
      RectangleF rectangleF1 = new RectangleF((float) location, 0.0f, sizeF.Width, sizeF.Height);
      rectangleF1.Inflate(2f, 2f);
      RectangleF rectangleF2 = new RectangleF(Math.Max(0.0f, rectangleF1.X - rectangleF1.Width / 2f), rectangleF1.Y + (float) (((double) parentRectangle.Height - (double) sizeF.Height) / 2.0), rectangleF1.Width, rectangleF1.Height);
      if (background != null)
        gr.FillRectangle(background, rectangleF2);
      gr.DrawString(str, font, textBrush, rectangleF2, new StringFormat()
      {
        Alignment = StringAlignment.Center,
        LineAlignment = StringAlignment.Center
      });
    }

    private void PaintTriangle(Graphics gr, Brush brush, int location, int width, int height) => gr.FillPolygon(brush, new PointF[3]
    {
      new PointF((float) location - (float) width / 2f, 0.0f),
      new PointF((float) location + (float) width / 2f, 0.0f),
      new PointF((float) location, (float) height)
    });

    private float PixelsPerMilliseconds(float? givenScale = null) => (float) ((double) this.ClientRectangle.Width / (double) this.Length * ((double) givenScale ?? (double) this.scale));

    private float MillisecondsPerPixels(float? givenScale = null) => (float) ((double) this.Length / (double) this.ClientRectangle.Width / ((double) givenScale ?? (double) this.scale));

    public int PositionToPixel(long? position, float? givenScale = null) => !position.HasValue || this.Length == 0L ? 0 : (int) ((double) (position.Value - this.offset) * (double) this.PixelsPerMilliseconds(givenScale));

    public long PixelToPosition(float x, float? givenScale = null)
    {
      if (this.Length == 0L)
        return 0;
      long position = (long) ((double) this.offset + (double) x * (double) this.MillisecondsPerPixels(givenScale));
      if (position < 0L)
        position = 0L;
      if (position > this.Length)
        position = this.Length;
      return position;
    }

    public void ZoomOut()
    {
      this.scale = 1f;
      this.offset = 0L;
      this.InvokeIfRequired((Action) (() => this.Refresh()));
    }

    public void ZoomAuto()
    {
      this.offset = 0L;
      this.scale = 1f;
      if (this.Length != 0L)
      {
        this.scale = 0.05f / ((float) this.ClientRectangle.Width / (float) this.length);
        this.scale = Math.Max(this.scale, 1f);
        this.GoToCurrentPosition();
      }
      this.InvokeIfRequired((Action) (() => this.Refresh()));
    }

    public void GoToCurrentPosition() => this.GoToPosition(this.Position);

    public void GoToPosition(long position)
    {
      if (this.Length > 0L)
      {
        this.offset = position - (long) this.MillisecondsPerPixels() * (long) (this.ClientSize.Width / 2);
        this.EnsureOffsetInBounds();
      }
      this.InvokeIfRequired((Action) (() => this.Refresh()));
    }

    private void VideoCutterTimeline_Resize(object sender, EventArgs e) => this.Invalidate();

    private void VideoCutterTimeline_MouseMove(object sender, MouseEventArgs e)
    {
      this.Cursor = Cursors.Default;
      int x = this.NormalizeMouseEventX(e.Location.X);
      this.HoverPosition = new long?(this.PixelToPosition((float) x));
      this.selectionsMoveController.ProcessMouseMoveFrame(this.FindNearestAcceptableKeyFrame(this.PixelToPosition((float) x)));
    }

    private void VideoCutterTimeline_MouseLeave(object sender, EventArgs e)
    {
      this.HoverPosition = new long?();
      this.selectionsMoveController.ProcessMouseLeaveFrame();
      this.Cursor = Cursors.Default;
    }

    private void OnSelectionChanged()
    {
      EventHandler<SelectionChangedEventArgs> selectionChanged = this.SelectionChanged;
      if (selectionChanged == null)
        return;
      selectionChanged((object) this, new SelectionChangedEventArgs());
    }

    internal void OnPositionChangeRequest(long frame)
    {
      EventHandler<PositionChangeRequestEventArgs> positionChangeRequest = this.PositionChangeRequest;
      if (positionChangeRequest == null)
        return;
      positionChangeRequest((object) this, new PositionChangeRequestEventArgs()
      {
        Position = frame
      });
    }

    public void RegisterNewSelectionStart(long frame)
    {
      this.newSelectionStart = new long?(frame);
      this.OnSelectionChanged();
      this.Refresh();
    }

    public void RegisterNewSelectionEnd(long frame)
    {
      if (!this.newSelectionStart.HasValue)
        return;
      long start = this.newSelectionStart.Value;
      this.newSelectionStart = new long?();
      this.selections.AddSelection(start, frame);
      this.OnSelectionChanged();
    }

    private int NormalizeMouseEventX(int x)
    {
      long position = this.PixelToPosition((float) x);
      long num = Control.ModifierKeys == Keys.Shift ? position : this.FindNearestAcceptableKeyFrame(position);
      return position != num ? this.PositionToPixel(new long?(num)) : x;
    }

    private void VideoCutterTimeline_MouseDown(object sender, MouseEventArgs e) => this.selectionsMoveController.ProcessMouseDownFrame(this.FindNearestAcceptableKeyFrame(this.PixelToPosition((float) e.X)), e.Button, e.Clicks);

    private void VideoCutterTimeline_MouseUp(object sender, MouseEventArgs e)
    {
      long acceptableKeyFrame = this.FindNearestAcceptableKeyFrame(this.PixelToPosition((float) e.X));
      if (!this.selectionsMoveController.IsDragInProgress())
      {
        if (e.Button == MouseButtons.Middle && e.Clicks == 1)
        {
          if (!this.newSelectionStart.HasValue && this.selections.CanStartSelectionAtFrame(acceptableKeyFrame))
          {
            this.RegisterNewSelectionStart(acceptableKeyFrame);
          }
          else
          {
            if (!this.newSelectionStart.HasValue || !this.selections.CanAddSelection(this.newSelectionStart.Value, acceptableKeyFrame))
              return;
            this.RegisterNewSelectionEnd(acceptableKeyFrame);
          }
        }
        else
        {
          if (e.Button != MouseButtons.Left || e.Clicks != 1)
            return;
          this.OnPositionChangeRequest(acceptableKeyFrame);
        }
      }
      else
        this.selectionsMoveController.ProcessMouseUpFrame(acceptableKeyFrame);
    }

    protected override void Dispose(bool disposing)
    {
      if (disposing && this.components != null)
        this.components.Dispose();
      base.Dispose(disposing);
    }

    private void InitializeComponent()
    {
      this.SuspendLayout();
      this.AutoScaleDimensions = new SizeF(6f, 13f);
      this.AutoScaleMode = AutoScaleMode.Font;
      this.DoubleBuffered = true;
      this.Font = new Font("Segoe UI", 8.25f, FontStyle.Regular, GraphicsUnit.Point, (byte) 238);
      this.Name = nameof (VideoCutterTimeline);
      this.Size = new Size(981, 64);
      this.Paint += new PaintEventHandler(this.VideoCutterTimeline_Paint);
      this.MouseDown += new MouseEventHandler(this.VideoCutterTimeline_MouseDown);
      this.MouseLeave += new EventHandler(this.VideoCutterTimeline_MouseLeave);
      this.MouseMove += new MouseEventHandler(this.VideoCutterTimeline_MouseMove);
      this.MouseUp += new MouseEventHandler(this.VideoCutterTimeline_MouseUp);
      this.Resize += new EventHandler(this.VideoCutterTimeline_Resize);
      this.ResumeLayout(false);
    }

    private class TimelineTooltip
    {
      public int X { get; set; }

      public string Text { get; set; }
    }
  }
}
