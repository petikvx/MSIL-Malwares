// Decompiled with JetBrains decompiler
// Type: ProjNet.Candidates.SystemMerchantCandidate
// Assembly: IRefl, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A29A65F6-B7ED-422C-83D4-B9EFD61E5F13
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-8e89881e34371e10b7f9cb943183a061aab9b22853cb7192e1ac09401f4cc545.exe

using IRefl.Pools;
using IRefl.Watchers;
using ProjNet.Structs;
using ProjNet.Templates;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace ProjNet.Candidates
{
  internal class SystemMerchantCandidate : ServiceObserverWatcher
  {
    private double m_AuthenticationRegistry;
    private double _TokenRegistry;
    private double _EventRegistry;
    private double m_ProxyRegistry;
    private double _RegRegistry;
    private double issuerRegistry;
    private double m_PageRegistry;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public SystemMerchantCandidate(List<Config> ident)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      this.\u002Ector(ident, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public SystemMerchantCandidate(List<Config> last, bool evaluatecol)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      base.\u002Ector(last, evaluatecol);
      this.MapAdvisor("EPSG");
      Config config1 = this.PushMerchant("central_meridian");
      Config config2 = this.PushMerchant("latitude_of_origin");
      Config config3 = this.PushMerchant("scale_factor");
      Config config4 = this.PushMerchant("false_easting");
      Config config5 = this.PushMerchant("false_northing");
      if (config1 == null)
        throw new ArgumentException("Missing projection parameter 'central_meridian'");
      if (config2 == null)
        throw new ArgumentException("Missing projection parameter 'latitude_of_origin'");
      if (config4 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (config5 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      this._EventRegistry = ValueObserverWatcher.PopAdvisor(config1.CountRegistry());
      this.m_ProxyRegistry = ValueObserverWatcher.PopAdvisor(config2.CountRegistry());
      this.m_AuthenticationRegistry = config4.CountRegistry() * this.refRegistry;
      this._TokenRegistry = config5.CountRegistry() * this.refRegistry;
      double num = this._ConfigurationRegistry / this._InterpreterRegistry;
      this.issuerRegistry = 1.0 - num * num;
      this._RegRegistry = Math.Sqrt(this.issuerRegistry);
      if (config3 == null)
      {
        this.m_PageRegistry = Math.Cos(this.m_ProxyRegistry) / Math.Sqrt(1.0 - this.issuerRegistry * Math.Sin(this.m_ProxyRegistry) * Math.Sin(this.m_ProxyRegistry));
        this.PrintAdvisor(9805L);
        this.Name = "Mercator_2SP";
      }
      else
      {
        this.m_PageRegistry = config3.CountRegistry();
        this.Name = "Mercator_1SP";
      }
      this.MapAdvisor("EPSG");
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ComputeMerchant(double[] item)
    {
      int num1 = 2;
      if (true)
        goto label_3;
label_1:
      bool flag1;
      double a;
      double num2;
      double num3;
      double num4;
      bool flag2;
      if (!flag1)
      {
        double num5 = this._RegRegistry * Math.Sin(a);
        num3 = this.m_AuthenticationRegistry + this._InterpreterRegistry * this.m_PageRegistry * (num2 - this._EventRegistry);
        num4 = this._TokenRegistry + this._InterpreterRegistry * this.m_PageRegistry * Math.Log(Math.Tan(Math.PI / 4.0 + a * 0.5) * Math.Pow((1.0 - num5) / (1.0 + num5), this._RegRegistry * 0.5));
        flag2 = item.Length < 3;
        if (SystemMerchantCandidate.SetupModel())
        {
          num1 = 4;
          goto label_3;
        }
        else
          goto label_7;
      }
      else
        goto label_5;
label_2:
      int num6;
      num1 = num6;
label_3:
      double[] merchant;
      int num7;
      switch (num1)
      {
        case 0:
        case 8:
          return merchant;
        case 1:
          break;
        case 2:
          goto label_7;
        case 3:
        case 7:
          goto label_1;
        case 4:
        case 5:
          if (flag2)
          {
            merchant = new double[2]
            {
              num3 / this.refRegistry,
              num4 / this.refRegistry
            };
            goto case 0;
          }
          else
          {
            merchant = new double[3]
            {
              num3 / this.refRegistry,
              num4 / this.refRegistry,
              item[2]
            };
            num6 = 8;
            goto label_2;
          }
        case 6:
          num7 = double.IsNaN(item[1]) ? 1 : 0;
          goto label_11;
        default:
          num6 = 1;
          goto label_2;
      }
label_5:
      throw new ArgumentException("Transformation cannot be computed at the poles.");
label_7:
      if (!double.IsNaN(item[0]))
      {
        num6 = 6;
        goto label_2;
      }
      else
        num7 = 1;
label_11:
      if (num7 != 0)
      {
        merchant = new double[2]{ double.NaN, double.NaN };
        num6 = 0;
        goto label_2;
      }
      else
      {
        num2 = ValueObserverWatcher.PopAdvisor(item[0]);
        a = ValueObserverWatcher.PopAdvisor(item[1]);
        flag1 = Math.Abs(Math.Abs(a) - Math.PI / 2.0) <= 1E-10;
        num6 = 7;
        goto label_2;
      }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ConcatMerchant(double[] instance)
    {
      int num1 = 0;
      double key1;
      double key2;
      double[] numArray;
      while (true)
      {
        int num2 = num1;
        double d;
        double num3;
        double num4;
        while (true)
        {
          switch (num2)
          {
            case 0:
              goto label_6;
            case 1:
            case 4:
              key2 = double.NaN;
              num4 = instance[0] * this.refRegistry - this.m_AuthenticationRegistry;
              d = Math.Exp(-(instance[1] * this.refRegistry - this._TokenRegistry) / (this._InterpreterRegistry * this.m_PageRegistry));
              num2 = 6;
              continue;
            case 2:
            case 6:
              num3 = Math.PI / 2.0 - 2.0 * Math.Atan(d);
              int num5 = 3;
              num2 = SystemMerchantCandidate.ValidateModel() ? num5 : num5;
              continue;
            case 3:
              goto label_7;
            case 5:
              goto label_5;
            case 7:
              goto label_2;
            case 8:
              goto label_12;
            default:
              if (true)
              {
                num2 = 5;
                continue;
              }
              goto case 1;
          }
        }
label_2:
        bool flag;
        if (!flag)
        {
          numArray = new double[3]
          {
            ValueObserverWatcher.SetAdvisor(key1),
            ValueObserverWatcher.SetAdvisor(key2),
            instance[2]
          };
          num1 = 8;
          continue;
        }
        break;
label_5:
        key1 = num4 / (this._InterpreterRegistry * this.m_PageRegistry) + this._EventRegistry;
        flag = instance.Length < 3;
        num1 = 7;
        continue;
label_6:
        key1 = double.NaN;
        num1 = 4;
        continue;
label_7:
        double num6 = Math.Pow(this._RegRegistry, 4.0);
        double num7 = Math.Pow(this._RegRegistry, 6.0);
        double num8 = Math.Pow(this._RegRegistry, 8.0);
        key2 = num3 + (this.issuerRegistry * 0.5 + 5.0 * num6 / 24.0 + num7 / 12.0 + 13.0 * num8 / 360.0) * Math.Sin(2.0 * num3) + (7.0 * num6 / 48.0 + 29.0 * num7 / 240.0 + 811.0 * num8 / 11520.0) * Math.Sin(4.0 * num3) + (7.0 * num7 / 120.0 + 81.0 * num8 / 1120.0) * Math.Sin(6.0 * num3) + 4279.0 * num8 / 161280.0 * Math.Sin(8.0 * num3);
        goto label_5;
      }
      numArray = new double[2]
      {
        ValueObserverWatcher.SetAdvisor(key1),
        ValueObserverWatcher.SetAdvisor(key2)
      };
label_12:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override OrderValuePool ManageItem()
    {
      int num1 = 3;
      OrderValuePool interceptorRegistry;
      while (true)
      {
        int num2;
        bool flag;
        switch (num1)
        {
          case 0:
          case 3:
            flag = this.m_InterceptorRegistry == null;
            num1 = 4;
            continue;
          case 1:
          case 2:
            interceptorRegistry = (OrderValuePool) this.m_InterceptorRegistry;
            num2 = 5;
            break;
          case 4:
            if (flag)
            {
              this.m_InterceptorRegistry = (ValueObserverWatcher) new SystemMerchantCandidate(this.globalRegistry, !this._PropertyRegistry);
              goto case 1;
            }
            else
              goto case 1;
          case 5:
            goto label_8;
          default:
            num2 = 1;
            break;
        }
        num1 = num2;
      }
label_8:
      return interceptorRegistry;
    }

    internal static bool SetupModel() => true;

    internal static bool ValidateModel() => false;
  }
}
