// Decompiled with JetBrains decompiler
// Type: .
// Assembly: w, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8101C3F8-A792-4EB9-952B-26F7AB9A4B5A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\HEUR-Trojan-Ransom.Win32.Blocker.vho-f4229a3d3ef208e7112de152afe7852c75984f871ec47bb2704ac9b52dba3316.exe

using \u0004;
using \u0006;
using \u000E;
using System;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

namespace \u0006
{
  internal abstract class \u0006
  {
    private static readonly bool \u0001;
    internal static readonly string \u0001;
    internal static \u0006.\u0006 \u0001;
    private IWebProxy \u0001;
    internal EventHandler \u0001;
    internal \u0004.\u0006 \u0001;
    [NonSerialized]
    internal static \u0001 \u001D;

    protected abstract void \u0001([In] \u0003.\u0005 obj0);

    protected abstract void \u0001([In] \u0004.\u0004 obj0);

    protected abstract void \u0001([In] \u0001 obj0);

    internal void \u0001([In] object obj0, [In] ThreadExceptionEventArgs obj1)
    {
      try
      {
        Exception exception;
        if (true)
          exception = \u0002\u0004.\u007E\u008D\u0006((object) obj1);
        else
          goto label_4;
label_2:
        Type type = \u0094\u0002.\u007E\u0013\u0005((object) exception);
label_4:
        if (\u0095.\u0017\u0003(\u001E.\u007E\u0010\u0002((object) type), \u0006.\u0006.\u001D(5831)) && \u0095.\u0017\u0003(\u001E.\u007E\u0014\u0002((object) type), \u0006.\u0006.\u001D(5856)))
          exception = (Exception) \u0090.\u007E\u000F\u0003((object) \u0003\u0004.\u007E\u008E\u0006((object) type, \u0006.\u0006.\u001D(5901)), (object) exception);
        if (exception is SecurityException)
        {
          if (true)
          {
            int num = \u0095.\u0017\u0003(\u0006.\u0006.\u0001, \u0006.\u0006.\u001D(2491)) ? 1 : 0;
            if (true)
            {
              if (num != 0)
                num = this.\u0001(exception as SecurityException) ? 1 : 0;
              else
                goto label_12;
            }
            if (num != 0)
              return;
          }
          else
            goto label_2;
        }
label_12:
        this.\u0001(exception, true, false);
      }
      catch
      {
      }
    }

    internal void \u0001([In] object obj0, [In] UnhandledExceptionEventArgs obj1)
    {
      try
      {
        int num1;
        if (\u001B\u0002.\u007E\u008F\u0004((object) obj1) is SecurityException)
        {
          if (false)
            return;
          int num2 = \u0095.\u0017\u0003(\u0006.\u0006.\u0001, \u0006.\u0006.\u001D(2491)) ? 1 : 0;
          if (true)
          {
            if (num2 == 0)
              goto label_9;
            else
              goto label_12;
          }
          else
            num1 = num2;
        }
        else
          goto label_9;
label_7:
        if (num1 != 0)
          return;
label_9:
        if (true)
        {
          if (!(\u001B\u0002.\u007E\u008F\u0004((object) obj1) is Exception))
            return;
          this.\u0001((Exception) \u001B\u0002.\u007E\u008F\u0004((object) obj1), !\u0087.\u007E\u0093\u0002((object) obj1), false);
          return;
        }
label_12:
        num1 = this.\u0001(\u001B\u0002.\u007E\u008F\u0004((object) obj1) as SecurityException) ? 1 : 0;
        goto label_7;
      }
      catch
      {
      }
    }

    protected virtual Guid \u0001() => Guid.Empty;

    internal bool \u0001([In] SecurityException obj0)
    {
      if (true)
        goto label_6;
label_5:
      int num = 1;
      return num == 0 ? num != 0 : num != 0;
label_6:
      \u0001 obj = new \u0001(obj0);
      if (true)
      {
        this.\u0001(obj);
        if (obj.\u0002)
          return false;
        if (!obj.\u0001)
        {
          global::\u0006.\u000E();
          goto label_5;
        }
        else
          goto label_5;
      }
      else
        goto label_5;
    }

    internal unsafe void \u0001([In] Exception obj0, [In] bool obj1, [In] bool obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      Type type = \u0094\u0002.\u007E\u0013\u0005((object) obj0);
      if (\u0095.\u0017\u0003(\u001E.\u007E\u0010\u0002((object) type), \u0006.\u0006.\u001D(5831)) && \u0095.\u0017\u0003(\u001E.\u007E\u0014\u0002((object) type), \u0006.\u0006.\u001D(5856)))
        obj0 = (Exception) \u0090.\u007E\u000F\u0003((object) \u0003\u0004.\u007E\u008E\u0006((object) type, \u0006.\u0006.\u001D(5901)), (object) obj0);
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
      if (obj0 == null)
        return;
      if (obj0 is ThreadAbortException)
        return;
      try
      {
        \u0002.\u0003 obj3 = new \u0002.\u0003(this.\u0001(), obj0, this.\u0001);
        \u0007.\u0001((\u0005.\u0002) obj3, new \u0004.\u0006(this.\u0001));
        \u0007.\u0001(new EventHandler(this.\u0001), obj3);
        \u0007.\u0001(obj3, new \u0008.\u0003(this.\u0001));
        \u0003.\u0005 obj4 = new \u0003.\u0005(obj3, obj0);
        if (\u0007.\u0001() != null)
          obj4.\u0001 = true;
        if (!obj1)
        {
          obj4.\u0003 = false;
          obj4.\u0004 = false;
        }
        else if (obj2 || \u0006.\u0006.\u0001)
        {
          obj4.\u0003 = false;
          obj4.\u0004 = true;
        }
        this.\u0001(obj4);
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) !obj4.\u0004;
      }
      catch (ThreadAbortException ex)
      {
      }
      catch (Exception ex)
      {
        this.\u0001(new \u0004.\u0004(ex));
      }
      if (*(sbyte*) ((IntPtr) voidPtr + 4) == (sbyte) 0)
        return;
      Assembly[] assemblyArray = \u0080\u0003.\u007E\u0004\u0006((object) \u007F\u0003.\u0003\u0006());
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < assemblyArray.Length)
      {
        Assembly assembly = assemblyArray[*(int*) voidPtr];
        try
        {
          string str = \u001E.\u007E\u0012\u0002((object) assembly);
          if (\u0015.\u007E\u001F((object) str, \u0006.\u0006.\u001D(5926)))
          {
            if (\u0015.\u007E\u0080((object) str, \u0006.\u0006.\u001D(5951)))
            {
              object obj5 = \u001D\u0004.\u007E\u000E\u0007((object) \u001C\u0004.\u007E\u0008\u0007((object) \u001B\u0004.\u007E\u0007\u0007((object) \u0098\u0003.\u007E\u0082\u0006((object) assembly, \u0006.\u0006.\u001D(5984)), \u0006.\u0006.\u001D(6021))), (object) null, (object[]) null);
              object obj6 = \u001D\u0004.\u007E\u000E\u0007((object) \u001E\u0004.\u007E\u000F\u0007((object) \u0094\u0002.\u007E\u0017\u0005(obj5), \u0006.\u0006.\u001D(6034), new Type[0]), obj5, (object[]) null);
            }
          }
        }
        catch
        {
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      try
      {
        global::\u0006.\u000E();
      }
      catch
      {
        try
        {
          \u001A.\u0096(0);
        }
        catch
        {
        }
      }
    }

    private void \u0001([In] object obj0, [In] \u0004.\u0004 obj1) => this.\u0001(obj1);

    private void \u0001([In] object obj0, [In] EventArgs obj1)
    {
label_0:
      EventHandler eventHandler;
      if (true)
        eventHandler = this.\u0001;
      do
      {
        if (eventHandler != null)
        {
          if (true)
          {
            if (true)
              \u001E\u0002.\u007E\u0092\u0004((object) eventHandler, obj0, obj1);
          }
          else
            goto label_0;
        }
      }
      while (false);
    }

    private void \u0001([In] object obj0, [In] \u0007 obj1)
    {
      \u0004.\u0006 obj = this.\u0001;
      if (obj == null)
        return;
      obj(obj0, obj1);
    }

    static \u0006()
    {
      if (false)
        return;
      \u0004.\u0002.\u0001(typeof (\u0006.\u0006));
      \u0006.\u0006.\u0001 = \u008A.\u009C\u0002(\u0006.\u0006.\u001D(612));
      \u0006.\u0006.\u0001 = \u0006.\u0006.\u001D(2491);
    }
  }
}
