// Decompiled with JetBrains decompiler
// Type: ChessBoard.Chessmens.Knight
// Assembly: IArraySortHel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B08900B5-C53F-4995-B311-D7E8DC4113C6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcrg-fe8d5c5d892bac95b940a26cf50aacf262dd40e3394fc1ba8444ab3842a16fda.exe

using System.Collections.Generic;

namespace ChessBoard.Chessmens
{
  public class Knight : BaseChessman
  {
    public override ChessmenType Type => ChessmenType.Knight;

    public Knight()
    {
    }

    public Knight(Colorz color)
      : base(color)
    {
label_1:
      int num1 = 2019792362;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1979364785)) % 3U)
        {
          case 0:
            goto label_1;
          case 1:
            num1 = (int) num2 * 914313543 ^ 1167663666;
            continue;
          case 2:
            goto label_3;
          default:
            goto label_5;
        }
      }
label_3:
      return;
label_5:;
    }

    public override bool Equals(object obj)
    {
label_1:
      int num1 = -1544278437;
      bool flag1;
      bool flag2;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1817101123)) % 6U)
        {
          case 1:
            flag2 = base.Equals(obj);
            num1 = -325950535;
            continue;
          case 2:
            flag1 = !(obj is Knight);
            num1 = (int) num2 * -1384224535 ^ 1308699065;
            continue;
          case 3:
            goto label_1;
          case 4:
            int num3 = flag1 ? 1186119672 : (num3 = 1751873898);
            num1 = num3 ^ (int) num2 * 1982263959;
            continue;
          case 5:
            flag2 = false;
            num1 = (int) num2 * 1747082442 ^ 1674012919;
            continue;
          default:
            goto label_7;
        }
      }
label_7:
      return flag2;
    }

    public override int GetHashCode()
    {
label_1:
      int num1 = -2009991183;
      int hashCode;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1652607837)) % 3U)
        {
          case 1:
            hashCode = base.GetHashCode();
            num1 = (int) num2 * 1657071362 ^ -999682036;
            continue;
          case 2:
            goto label_1;
          default:
            goto label_4;
        }
      }
label_4:
      return hashCode;
    }

    public override List<Cell> GetAcceptableCells(
      BoardCell[,] boardCells,
      Cell currentCell,
      bool needToCheckShah = true)
    {
label_1:
      int num1 = 1428846036;
      List<Cell> acceptableCells1;
      List<Cell> acceptableCells2;
      bool flag1;
      int index;
      Movement[] movementArray1;
      bool flag2;
      Cell cell;
      int num2;
      int num3;
      Movement movement1;
      Movement[] movementArray2;
      while (true)
      {
        uint num4;
        switch ((num4 = (uint) (num1 ^ 930025391)) % 24U)
        {
          case 0:
            num1 = (int) num4 * 1261886393 ^ 1659677822;
            continue;
          case 1:
            int num5;
            num1 = num5 = this.IfEmptyOrEnemy(boardCells, num2, num3) ? 1272346861 : (num5 = 1442424342);
            continue;
          case 2:
            acceptableCells1.Add(cell);
            num1 = (int) num4 * -902221491 ^ -235688227;
            continue;
          case 3:
            num3 = currentCell.Column + movement1.Column;
            cell = new Cell(num2, num3);
            flag2 = !this.IsCellInBounds(cell);
            num1 = (int) num4 * -1245669033 ^ -510701563;
            continue;
          case 4:
            num1 = (int) num4 * -364448497 ^ -1294357148;
            continue;
          case 5:
            this.AdjustAcceptableCellsInCaseShah(boardCells, acceptableCells1, currentCell);
            num1 = (int) num4 * 1152099207 ^ -1034357582;
            continue;
          case 6:
            num1 = (int) num4 * 473783731 ^ 414520427;
            continue;
          case 7:
            int num6 = !flag1 ? 2047831149 : (num6 = 473261398);
            num1 = num6 ^ (int) num4 * 2051536428;
            continue;
          case 8:
            goto label_1;
          case 9:
            movement1 = movementArray1[index];
            num1 = 2075846106;
            continue;
          case 11:
            ++index;
            num1 = 677946683;
            continue;
          case 12:
            flag1 = needToCheckShah;
            num1 = (int) num4 * -1373417763 ^ -1496333524;
            continue;
          case 13:
            num2 = currentCell.Row + movement1.Row;
            num1 = (int) num4 * 1712147296 ^ 2080798276;
            continue;
          case 14:
            acceptableCells2 = acceptableCells1;
            num1 = 2000212349;
            continue;
          case 15:
            movementArray1 = movementArray2;
            num1 = (int) num4 * -1044221861 ^ 263477202;
            continue;
          case 16:
            index = 0;
            num1 = (int) num4 * -715233948 ^ -522837731;
            continue;
          case 17:
            num1 = 139758900;
            continue;
          case 18:
            num1 = (int) num4 * 393580923 ^ 630250109;
            continue;
          case 19:
            acceptableCells1 = new List<Cell>();
            num1 = (int) num4 * -1562777071 ^ -1860795966;
            continue;
          case 20:
            int num7;
            num1 = num7 = index < movementArray1.Length ? 1435037342 : (num7 = 801184187);
            continue;
          case 21:
            num1 = (int) num4 * 1592303821 ^ 1593788181;
            continue;
          case 22:
            Movement[] movementArray3 = new Movement[8];
            Movement movement2 = new Movement();
            movement2.Row = -1;
            movement2.Column = -2;
            movementArray3[0] = movement2;
            Movement movement3 = new Movement();
            movement3.Row = -1;
            movement3.Column = 2;
            movementArray3[1] = movement3;
            Movement movement4 = new Movement();
            movement4.Row = 1;
            movement4.Column = -2;
            movementArray3[2] = movement4;
            Movement movement5 = new Movement();
            movement5.Row = 1;
            movement5.Column = 2;
            movementArray3[3] = movement5;
            Movement movement6 = new Movement();
            movement6.Row = -2;
            movement6.Column = -1;
            movementArray3[4] = movement6;
            Movement movement7 = new Movement();
            movement7.Row = -2;
            movement7.Column = 1;
            movementArray3[5] = movement7;
            Movement movement8 = new Movement();
            movement8.Row = 2;
            movement8.Column = -1;
            movementArray3[6] = movement8;
            Movement movement9 = new Movement();
            movement9.Row = 2;
            movement9.Column = 1;
            movementArray3[7] = movement9;
            movementArray2 = movementArray3;
            num1 = (int) num4 * 2126395048 ^ 1609695675;
            continue;
          case 23:
            int num8 = flag2 ? -1927064817 : (num8 = -976838565);
            num1 = num8 ^ (int) num4 * -2033792957;
            continue;
          default:
            goto label_25;
        }
      }
label_25:
      return acceptableCells2;
    }
  }
}
