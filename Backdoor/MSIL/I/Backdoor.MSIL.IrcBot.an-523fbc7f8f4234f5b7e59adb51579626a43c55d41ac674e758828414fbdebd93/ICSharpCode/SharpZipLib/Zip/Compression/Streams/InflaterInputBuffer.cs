// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;
using System.IO;
using System.Security.Cryptography;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
  public class InflaterInputBuffer
  {
    private int \uE007;
    private byte[] \uE006;
    private int \uE005;
    private byte[] \uE004;
    private byte[] \uE003;
    private int \uE002;
    private ICryptoTransform \uE001;
    private Stream \uE000;

    public InflaterInputBuffer(Stream stream)
      : this(stream, 4096)
    {
    }

    public InflaterInputBuffer(Stream stream, int bufferSize)
    {
      this.\uE000 = stream;
      if (bufferSize < 1024)
        bufferSize = 1024;
      this.\uE006 = new byte[bufferSize];
      this.\uE004 = this.\uE006;
    }

    public int RawLength => this.\uE007;

    public byte[] RawData => this.\uE006;

    public int ClearTextLength => this.\uE005;

    public byte[] ClearText => this.\uE004;

    public int Available
    {
      get => this.\uE002;
      set => this.\uE002 = value;
    }

    public void SetInflaterInput(Inflater inflater)
    {
      if (this.\uE002 <= 0)
        return;
      inflater.SetInput(this.\uE004, this.\uE005 - this.\uE002, this.\uE002);
      this.\uE002 = 0;
    }

    public void Fill()
    {
      this.\uE007 = 0;
      int num;
      for (int length = this.\uE006.Length; length > 0; length -= num)
      {
        num = this.\uE000.Read(this.\uE006, this.\uE007, length);
        if (num <= 0)
        {
          if (this.\uE007 == 0)
            throw new SharpZipBaseException(\uE01B.\uE000("\uF2B3\uF288\uF283\uF29E\uF296\uF283\uF285\uF292\uF283\uF282\uF2C6\uF2A3\uF2A9\uF2A0", 62182));
          break;
        }
        this.\uE007 += num;
      }
      this.\uE005 = this.\uE001 == null ? this.\uE007 : this.\uE001.TransformBlock(this.\uE006, 0, this.\uE007, this.\uE004, 0);
      this.\uE002 = this.\uE005;
    }

    public int ReadRawBuffer(byte[] buffer) => this.ReadRawBuffer(buffer, 0, buffer.Length);

    public int ReadRawBuffer(byte[] outBuffer, int offset, int length)
    {
      if (length < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uF6B9\uF6B0\uF6BB\uF6B2\uF6A1\uF6BD", 63189));
      int destinationIndex = offset;
      int val1 = length;
      while (val1 > 0)
      {
        if (this.\uE002 <= 0)
        {
          this.Fill();
          if (this.\uE002 <= 0)
            return 0;
        }
        int length1 = Math.Min(val1, this.\uE002);
        Array.Copy((Array) this.\uE006, this.\uE007 - this.\uE002, (Array) outBuffer, destinationIndex, length1);
        destinationIndex += length1;
        val1 -= length1;
        this.\uE002 -= length1;
      }
      return length;
    }

    public int ReadClearTextBuffer(byte[] outBuffer, int offset, int length)
    {
      if (length < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uF6B9\uF6B0\uF6BB\uF6B2\uF6A1\uF6BD", 63189));
      int destinationIndex = offset;
      int val1 = length;
      while (val1 > 0)
      {
        if (this.\uE002 <= 0)
        {
          this.Fill();
          if (this.\uE002 <= 0)
            return 0;
        }
        int length1 = Math.Min(val1, this.\uE002);
        Array.Copy((Array) this.\uE004, this.\uE005 - this.\uE002, (Array) outBuffer, destinationIndex, length1);
        destinationIndex += length1;
        val1 -= length1;
        this.\uE002 -= length1;
      }
      return length;
    }

    public int ReadLeByte()
    {
      if (this.\uE002 <= 0)
      {
        this.Fill();
        if (this.\uE002 <= 0)
          throw new ZipException(\uE01B.\uE000("\uEFA7\uEFAD\uEFA4\uEFC2\uEF8B\uEF8C\uEFC2\uEF8A\uEF87\uEF83\uEF86\uEF87\uEF90", 61410));
      }
      byte num = this.\uE006[this.\uE007 - this.\uE002];
      --this.\uE002;
      return (int) num;
    }

    public int ReadLeShort() => this.ReadLeByte() | this.ReadLeByte() << 8;

    public int ReadLeInt() => this.ReadLeShort() | this.ReadLeShort() << 16;

    public long ReadLeLong() => (long) (uint) this.ReadLeInt() | (long) this.ReadLeInt() << 32;

    public ICryptoTransform CryptoTransform
    {
      set
      {
        this.\uE001 = value;
        if (this.\uE001 != null)
        {
          if (this.\uE006 == this.\uE004)
          {
            if (this.\uE003 == null)
              this.\uE003 = new byte[this.\uE006.Length];
            this.\uE004 = this.\uE003;
          }
          this.\uE005 = this.\uE007;
          if (this.\uE002 <= 0)
            return;
          this.\uE001.TransformBlock(this.\uE006, this.\uE007 - this.\uE002, this.\uE002, this.\uE004, this.\uE007 - this.\uE002);
        }
        else
        {
          this.\uE004 = this.\uE006;
          this.\uE005 = this.\uE007;
        }
      }
    }
  }
}
