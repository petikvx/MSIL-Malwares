// Decompiled with JetBrains decompiler
// Type:  
// Assembly: ProgIdRedirectionEn, Version=1.7.3.0, Culture=neutral, PublicKeyToken=null
// MVID: B81F1514-ABAD-442F-0D6D-30821B04B8DB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcqy-84d399a3116d4038d5730fdbae6857142c0141f042dbba9a42e8a21e1ce6448b.exe

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Media.Media3D;

internal sealed class \u000F\u2003
{
  [MethodImpl(MethodImplOptions.NoInlining)]
  public \u000F\u2003()
  {
    \u0003\u2004.\u0002();
    // ISSUE: explicit constructor call
    base.\u002Ector();
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static void \u0002()
  {
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Vector _param0, Vector _param1) => _param0.X * _param1.X + _param0.Y * _param1.Y;

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Point _param0, Vector _param1, Point _param2)
  {
    Vector vector = new Vector(_param2.X - _param0.X, _param2.Y - _param0.Y);
    return \u000F\u2003.\u0002(_param1, vector);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Vector3D _param0, Vector3D _param1) => _param0.X * _param1.X + _param0.Y * _param1.Y + _param0.Z * _param1.Z;

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Point3D _param0, Vector3D _param1, Point3D _param2)
  {
    Vector3D vector3D = new Vector3D(_param2.X - _param0.X, _param2.Y - _param0.Y, _param2.Z - _param0.Z);
    return \u000F\u2003.\u0002(_param1, vector3D);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(RayHitTestParameters _param0, Point3D _param1)
  {
    Vector3D vector3D = new Vector3D(_param1.X - _param0.Origin.X, _param1.Y - _param0.Origin.Y, _param1.Z - _param0.Origin.Z);
    return \u000F\u2003.\u0002(_param0.Direction, vector3D);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Vector _param0) => Math.Sqrt(\u000F\u2003.\u0002(_param0, _param0));

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Point _param0, Point _param1)
  {
    Vector vector = new Vector(_param1.X - _param0.X, _param1.Y - _param0.Y);
    return Math.Sqrt(\u000F\u2003.\u0002(vector, vector));
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0003(RayHitTestParameters _param0, Point3D _param1)
  {
    Vector3D vector3D = new Vector3D(_param1.X - _param0.Origin.X, _param1.Y - _param0.Origin.Y, _param1.Z - _param0.Origin.Z);
    return Math.Sqrt(\u000F\u2003.\u0002(vector3D, vector3D));
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static double \u0002(Point3D _param0, Point3D _param1)
  {
    Vector3D vector3D = new Vector3D(_param1.X - _param0.X, _param1.Y - _param0.Y, _param1.Z - _param0.Z);
    return Math.Sqrt(\u000F\u2003.\u0002(vector3D, vector3D));
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static bool \u0002(RayHitTestParameters _param0, Rect3D _param1)
  {
    int num1 = 6;
label_11:
    double num2;
    bool flag1;
    double num3;
    bool flag2;
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 6:
          num2 = 0.0;
          if (\u000F\u2003.\u0002())
          {
            num1 = 2;
            continue;
          }
          goto case 4;
        case 1:
        case 2:
          while (num2 > _param1.SizeX)
          {
            if (\u000F\u2003.\u0002())
            {
              num1 = 3;
              goto label_11;
            }
          }
          num3 = 0.0;
          goto case 5;
        case 3:
          flag2 = false;
          num1 = 7;
          continue;
        case 4:
          if (!flag1)
          {
            num2 += _param1.SizeX;
            goto case 1;
          }
          else
          {
            num3 += _param1.SizeY;
            num1 = 5;
            continue;
          }
        case 5:
          flag1 = num3 <= _param1.SizeY;
          goto case 4;
        case 7:
          goto label_13;
        default:
          if (\u000F\u2003.\u0002())
          {
            num1 = 4;
            continue;
          }
          goto label_13;
      }
    }
label_13:
    return flag2;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static bool \u0002(RayHitTestParameters _param0, Rect3D _param1, double _param2)
  {
    int num1 = 4;
    bool flag;
    while (true)
    {
      Vector3D vector3D1;
      Vector3D vector3D2;
      Point3D origin;
      int num2;
      switch (num1)
      {
        case 0:
          goto label_8;
        case 1:
          ref Vector3D local1 = ref vector3D1;
          double num3 = _param1.X + _param1.SizeX;
          origin = _param0.Origin;
          double x1 = origin.X;
          double x2 = num3 - x1;
          double num4 = _param1.Y + _param1.SizeY;
          origin = _param0.Origin;
          double y1 = origin.Y;
          double y2 = num4 - y1;
          double num5 = _param1.Z + _param1.SizeZ;
          origin = _param0.Origin;
          double z1 = origin.Z;
          double z2 = num5 - z1;
          local1 = new Vector3D(x2, y2, z2);
          if (vector3D2.X <= _param2 || vector3D1.X <= _param2)
            goto label_11;
          else
            goto label_16;
label_5:
          int num6;
          num1 = num6;
          continue;
label_11:
          if (vector3D2.Y <= _param2 || vector3D1.Y <= _param2)
          {
            if (vector3D2.Z <= _param2)
            {
              num2 = 0;
              break;
            }
            num6 = 6;
            goto label_5;
          }
          else
            goto label_12;
label_16:
          num6 = 5;
          goto label_5;
        case 2:
        case 5:
          goto label_10;
        case 3:
        case 6:
          num2 = vector3D1.Z > _param2 ? 1 : 0;
          break;
        case 4:
          ref Vector3D local2 = ref vector3D2;
          double x3 = _param1.X;
          origin = _param0.Origin;
          double x4 = origin.X;
          double x5 = x3 - x4;
          double y3 = _param1.Y;
          origin = _param0.Origin;
          double y4 = origin.Y;
          double y5 = y3 - y4;
          double z3 = _param1.Z;
          origin = _param0.Origin;
          double z4 = origin.Z;
          double z5 = z3 - z4;
          local2 = new Vector3D(x5, y5, z5);
          num1 = 1;
          continue;
        case 7:
        case 8:
          goto label_20;
        default:
          num1 = 7;
          continue;
      }
      if (num2 == 0)
      {
        if (\u000F\u2003.\u0003(_param0, new Point3D((vector3D2.X + vector3D1.X) / 2.0, (vector3D2.Y + vector3D1.Y) / 2.0, (vector3D2.Z + vector3D1.Z) / 2.0)) <= _param2 + 0.56)
        {
          flag = false;
          num1 = 8;
        }
        else
          num1 = 0;
      }
      else
        break;
    }
    flag = true;
    goto label_20;
label_8:
    flag = true;
    goto label_20;
label_10:
    flag = true;
    goto label_20;
label_12:
    flag = true;
label_20:
    return flag;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static bool \u0002(
    RayHitTestParameters _param0,
    Rect3D _param1,
    ref List<Point3D> _param2,
    \u0006\u2000 _param3)
  {
    int num1 = 0;
    Vector3D vector3D1;
    Vector3D vector3D2;
    bool flag1;
    while (true)
    {
      int num2 = num1;
      double num3;
      double num4;
      Point3D origin;
      int num5;
      int num6;
      int num7;
      Vector3D direction;
      double num8;
      double num9;
      double num10;
      Vector3D vector3D3;
      double num11;
      while (true)
      {
        switch (num2)
        {
          case 0:
            direction = _param0.Direction;
            num2 = 11;
            continue;
          case 1:
            origin = _param0.Origin;
            num4 = Math.Abs(origin.X - _param1.X);
            num2 = 13;
            continue;
          case 2:
            vector3D3 = _param0.Direction * num9 * num10;
            if (vector3D1.Y < _param1.Y + _param1.SizeY || vector3D1.Z > _param1.Z + _param1.SizeZ)
            {
              if (vector3D2.Y < _param1.X + _param1.SizeX || vector3D2.Z > _param1.Z + _param1.SizeZ)
              {
                if (vector3D3.Y >= _param1.X + _param1.SizeX && vector3D3.Y <= _param1.Y + _param1.SizeY)
                {
                  _param2.Add(new Point3D(vector3D3.X, vector3D3.Y, vector3D3.Z));
                  num2 = 8;
                  continue;
                }
                goto label_10;
              }
              else
                goto label_22;
            }
            else
              goto label_20;
          case 3:
          case 4:
            \u000F\u2003.\u0002(_param0.Origin, new Point3D(_param1.X + _param1.SizeX * (double) num5, _param1.Y + _param1.SizeY * (double) num6, _param1.Z + _param1.SizeZ * (double) num7));
            direction = _param0.Direction;
            num3 = Math.Abs(direction.X);
            direction = _param0.Direction;
            num8 = Math.Abs(direction.Y);
            direction = _param0.Direction;
            num2 = 9;
            continue;
          case 5:
            goto label_15;
          case 6:
            vector3D1 = _param0.Direction * num3 * num4;
            vector3D2 = new Vector3D();
            if (\u000F\u2003.\u0002())
            {
              num2 = 14;
              continue;
            }
            goto label_2;
          case 7:
            goto label_4;
          case 8:
          case 12:
            goto label_9;
          case 9:
            num9 = Math.Abs(direction.Z);
            num2 = 1;
            continue;
          case 10:
            num11 = Math.Abs(origin.Y - _param1.Y);
            origin = _param0.Origin;
            num10 = Math.Abs(origin.Z - _param1.Z);
            goto case 15;
          case 11:
            direction.Normalize();
            Vector3D vector3D4;
            ref Vector3D local = ref vector3D4;
            double x1 = _param1.X;
            origin = _param0.Origin;
            double x2 = origin.X;
            double x3 = x1 - x2;
            double y1 = _param1.Y;
            origin = _param0.Origin;
            double y2 = origin.Y;
            double y3 = y1 - y2;
            double z1 = _param1.Z;
            origin = _param0.Origin;
            double z2 = origin.Z;
            double z3 = z1 - z2;
            local = new Vector3D(x3, y3, z3);
            vector3D4.Normalize();
            num2 = 7;
            continue;
          case 13:
            goto label_2;
          case 14:
            goto label_33;
          case 15:
            vector3D1 = new Vector3D();
            num2 = 6;
            continue;
          case 16:
            goto label_34;
          default:
            goto label_30;
        }
      }
label_2:
      origin = _param0.Origin;
      num1 = 10;
      continue;
label_4:
      num5 = 0;
      goto label_17;
label_10:
      ++num7;
label_11:
      if (num7 <= 1)
      {
        if (\u000F\u2003.\u0002(_param0, new Point3D(_param1.X + _param1.SizeX * (double) num5, _param1.Y + _param1.SizeY * (double) num6, _param1.Z + _param1.SizeZ * (double) num7)) > 0.0)
        {
          num1 = 4;
          continue;
        }
        goto label_10;
      }
      else
        ++num6;
label_13:
      bool flag2 = num6 <= 1;
      num1 = 5;
      continue;
label_15:
      if (flag2)
      {
        num7 = 0;
        goto label_11;
      }
      else
        ++num5;
label_17:
      if (num5 <= 1)
      {
        num6 = 0;
        goto label_13;
      }
      else
      {
        flag1 = false;
        num1 = 16;
        continue;
      }
label_30:
      num1 = 15;
      continue;
label_33:
      vector3D2 = _param0.Direction * num8 * num11;
      vector3D3 = new Vector3D();
      num1 = 2;
    }
label_9:
    flag1 = true;
    goto label_34;
label_20:
    _param2.Add(new Point3D(vector3D1.X, vector3D1.Y, vector3D1.Z));
    flag1 = true;
    goto label_34;
label_22:
    _param2.Add(new Point3D(vector3D2.X, vector3D2.Y, vector3D2.Z));
    flag1 = true;
label_34:
    return flag1;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static bool \u0003(RayHitTestParameters _param0, Rect3D _param1)
  {
    int num1 = 6;
    bool flag1;
    while (true)
    {
      int num2 = num1;
      bool flag2;
      Point3D origin;
      bool flag3;
      int num3;
      int num4;
      int num5;
      while (true)
      {
        switch (num2)
        {
          case 0:
            if (!flag3)
            {
              ++num4;
              num2 = 2;
              continue;
            }
            goto label_15;
          case 1:
            if (num3 <= 1)
            {
              num5 = 0;
              goto case 9;
            }
            else
              goto label_10;
          case 2:
            if (num4 > 1)
            {
              ++num5;
              num2 = 9;
              continue;
            }
            origin = _param0.Origin;
            if (\u000F\u2003.\u0002())
            {
              num2 = 8;
              continue;
            }
            goto label_15;
          case 3:
          case 7:
            if (!flag2)
            {
              origin = _param0.Origin;
              flag3 = \u000F\u2003.\u0002(origin.Z, _param1.Z + _param1.SizeZ);
              num2 = 0;
              continue;
            }
            goto label_2;
          case 4:
          case 5:
            goto label_15;
          case 6:
            goto label_4;
          case 8:
            goto label_21;
          case 9:
            if (num5 > 1)
            {
              ++num3;
              goto case 1;
            }
            else
            {
              num4 = 0;
              goto case 2;
            }
          case 10:
            goto label_24;
          default:
            if (!\u000F\u2003.\u0003())
            {
              num2 = 4;
              continue;
            }
            goto label_21;
        }
      }
label_4:
      num3 = 0;
      num1 = 1;
      continue;
label_10:
      flag1 = false;
      num1 = 10;
      continue;
label_21:
      if (!\u000F\u2003.\u0002(origin.X, _param1.X + _param1.SizeX))
      {
        origin = _param0.Origin;
        flag2 = \u000F\u2003.\u0002(origin.Y, _param1.Y + _param1.SizeY);
        num1 = 7;
      }
      else
        goto label_22;
    }
label_2:
    flag1 = true;
    goto label_24;
label_15:
    flag1 = true;
    goto label_24;
label_22:
    flag1 = true;
label_24:
    return flag1;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static bool \u0005(RayHitTestParameters _param0, Rect3D _param1)
  {
    int num1 = 5;
    bool flag1;
    while (true)
    {
      int num2 = num1;
      int num3;
      int num4;
      bool flag2;
      while (true)
      {
        int num5;
        bool flag3;
        switch (num2)
        {
          case 0:
          case 5:
            num4 = 0;
            num2 = 3;
            continue;
          case 1:
          case 3:
            goto label_6;
          case 2:
            goto label_5;
          case 4:
            if (flag3)
            {
              if (\u000F\u2003.\u0002(_param0, new Point3D(_param1.X + _param1.SizeX * (double) num4, _param1.Y + _param1.SizeY * (double) num3, _param1.Z + _param1.SizeZ * (double) num5)) <= 0.0)
              {
                ++num5;
                break;
              }
              goto label_10;
            }
            else
              goto label_17;
          case 6:
            if (num3 <= 1)
            {
              num5 = 0;
              break;
            }
            goto label_5;
          case 7:
            if (flag2)
            {
              num3 = 0;
              goto case 6;
            }
            else
              goto label_14;
          case 8:
            goto label_18;
          default:
            if (\u000F\u2003.\u0002())
            {
              num2 = 2;
              continue;
            }
            goto label_5;
        }
        flag3 = num5 <= 1;
        int num6 = 4;
        num2 = \u000F\u2003.\u0003() ? num6 : num6;
      }
label_5:
      ++num4;
label_6:
      flag2 = num4 <= 1;
      num1 = 7;
      continue;
label_14:
      flag1 = false;
      num1 = 8;
      continue;
label_17:
      ++num3;
      num1 = 6;
    }
label_10:
    flag1 = true;
label_18:
    return flag1;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static bool \u0002(double _param0, double _param1)
  {
    int num = 5;
    bool flag1;
    bool flag2;
    while (true)
    {
      switch (num)
      {
        case 0:
        case 5:
          flag1 = _param0 == 0.0;
          num = 4;
          continue;
        case 1:
        case 2:
          goto label_6;
        case 3:
          goto label_2;
        case 4:
          if (flag1)
          {
            num = 1;
            continue;
          }
          if (_param0 / Math.Abs(_param0) != _param1 / Math.Abs(_param1))
          {
            flag2 = false;
            num = 6;
            continue;
          }
          goto label_2;
        case 6:
          goto label_10;
        default:
          num = 3;
          continue;
      }
    }
label_2:
    flag2 = true;
    goto label_10;
label_6:
    flag2 = false;
label_10:
    return flag2;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static bool \u0002(
    double _param0,
    double _param1,
    double _param2,
    double _param3,
    double _param4,
    double _param5)
  {
    int num1 = 1;
    bool flag;
    while (true)
    {
      int num2 = num1;
      while (true)
      {
        switch (num2)
        {
          case 0:
          case 2:
            goto label_10;
          case 1:
            goto label_8;
          case 3:
          case 5:
            goto label_6;
          case 4:
            goto label_1;
          case 6:
            goto label_16;
          default:
            if (!\u000F\u2003.\u0003())
            {
              num2 = 5;
              continue;
            }
            goto label_16;
        }
      }
label_1:
      int num3 = _param0 <= _param2 + _param4 ? 1 : 0;
label_3:
      int num4;
      if (num3 != 0)
      {
        if (_param1 >= _param3)
        {
          num1 = 0;
          continue;
        }
        num4 = 0;
        goto label_12;
      }
label_7:
      flag = false;
      num1 = 6;
      continue;
label_8:
      if (_param0 < _param2)
      {
        num3 = 0;
        goto label_3;
      }
      else
      {
        num1 = 4;
        continue;
      }
label_10:
      num4 = _param1 <= _param3 + _param5 ? 1 : 0;
label_12:
      if (num4 == 0)
        goto label_7;
      else
        break;
    }
label_6:
    flag = true;
label_16:
    return flag;
  }

  internal static bool \u0002() => true;

  internal static bool \u0003() => false;
}
