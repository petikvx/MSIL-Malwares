// Decompiled with JetBrains decompiler
// Type: AstroMath.Planar
// Assembly: IUnionSemanticCodeGr, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 54936E77-57E9-4A01-8A40-CDD9C21A9B24
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4a11f3ee9b7abe32546655a9f702013b42b9f162a262dca3052e2761c20ed447.exe

using System;
using System.Drawing;

namespace AstroMath
{
  public class Planar
  {
    public static Planar.QuadRoot Quad(double yminus, double yzero, double yplus)
    {
      Planar.QuadRoot quadRoot = new Planar.QuadRoot();
      quadRoot.nz = 0;
      double num1 = 0.5 * (yminus + yplus) - yzero;
      double x = 0.5 * (yplus - yminus);
      double num2 = yzero;
      quadRoot.xe = -x / (2.0 * num1);
      quadRoot.ye = (num1 * quadRoot.xe + x) * quadRoot.xe + num2;
      double d = Math.Pow(x, 2.0) - 4.0 * num1 * num2;
      if (d >= 0.0)
      {
        double num3 = 0.5 * Math.Sqrt(d) / Math.Abs(num1);
        quadRoot.zero1 = quadRoot.xe - num3;
        quadRoot.zero2 = quadRoot.xe + num3;
        if (Math.Abs(quadRoot.zero1) <= 1.0)
          ++quadRoot.nz;
        if (Math.Abs(quadRoot.zero2) <= 1.0)
          ++quadRoot.nz;
        if (quadRoot.zero1 < -1.0)
          quadRoot.zero1 = quadRoot.zero2;
      }
      return quadRoot;
    }

    public static double Frac(double x)
    {
      if (x < 0.0)
        x = Math.Abs(x - (double) (int) x);
      else
        x -= (double) (int) x;
      return x < 0.0 ? x + 1.0 : x;
    }

    public static Point ThirdPoint(Point C, double circleradius, double Alpha, double ht)
    {
      double num1 = Math.Sqrt(Math.Pow(ht, 2.0) + Math.Pow(circleradius / 2.0, 2.0));
      double num2 = Math.Sin(ht / num1);
      return new Point((int) ((double) C.X + num1 * Math.Cos(Alpha + num2)), (int) ((double) C.Y + num1 * Math.Sin(Alpha + num2)));
    }

    public static double DotProduct(double[] a, double[] b)
    {
      if (a.Length != b.Length)
        return 0.0;
      double num = 0.0;
      for (int index = 0; index < a.Length; ++index)
        num += a[index] * b[index];
      return num;
    }

    public class QuadRoot
    {
      public int nz;
      public double xe;
      public double ye;
      public double zero1;
      public double zero2;

      public QuadRoot()
      {
        this.nz = 0;
        this.xe = 0.0;
        this.ye = 0.0;
        this.zero1 = 0.0;
        this.zero2 = 0.0;
      }
    }
  }
}
