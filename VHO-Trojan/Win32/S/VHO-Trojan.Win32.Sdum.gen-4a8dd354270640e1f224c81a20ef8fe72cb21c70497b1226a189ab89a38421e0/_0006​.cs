// Decompiled with JetBrains decompiler
// Type: ​
// Assembly: Ugyzlkqxhz, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 36C42683-5959-4132-14CD-452F458D436C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\VHO-Trojan.Win32.Sdum.gen-4a8dd354270640e1f224c81a20ef8fe72cb21c70497b1226a189ab89a38421e0.exe

using System;
using System.IO;
using System.Security.Cryptography;

internal static class \u0006​
{
  public static byte[] \u0002(
    object _param0,
    ulong _param1,
    \u0006 _param2,
    RandomNumberGenerator _param3)
  {
    object obj1 = _param0;
    if (true)
      ;
    byte[] numArray1 = \u0006​.\u0002(obj1);
    long num = (long) _param1;
    if (true)
      ;
    byte[] numArray2 = \u0006​.\u0002((ulong) num);
    \u0006 obj2 = _param2;
    if (true)
      ;
    RandomNumberGenerator randomNumberGenerator = _param3;
    return \u0006​.\u0002(numArray1, numArray2, obj2, randomNumberGenerator);
  }

  public static byte[] \u0002(
    byte[] _param0,
    byte[] _param1,
    \u0006 _param2,
    RandomNumberGenerator _param3)
  {
    int length = _param0.Length;
    if (true)
      goto label_2;
label_1:
    int count;
    if (count == 0)
      throw new ArgumentException();
    int num1 = _param2.\u0006\u2009\u2005\u2008\u0002();
    if (true)
      goto label_7;
label_5:
    int num2 = _param2.\u0006\u2009\u2005\u2008\u0003();
    if (true)
      goto label_8;
label_6:
    int num3;
    int num4 = count % num3;
    int num5 = (count + (num3 - 1)) / num3;
    byte[] dst;
    if (num4 == 0)
    {
      dst = new byte[count];
      Buffer.BlockCopy((Array) _param0, 0, (Array) dst, 0, count);
    }
    else
    {
      int num6 = \u0006​.\u0002(num4);
      byte[] bytes = new \u0002\u2001(_param0, _param1, num6).GetBytes(num3);
      if (num5 == 1)
      {
        dst = bytes;
      }
      else
      {
        dst = new byte[num3 * num5];
        Buffer.BlockCopy((Array) bytes, 0, (Array) dst, num3 * (num5 - 1), num3);
      }
      Buffer.BlockCopy((Array) _param0, 0, (Array) dst, 0, _param0.Length);
    }
    \u000F\u2001.\u0002(dst, 0, dst.Length / 4 * 4, _param1);
    byte[] numArray = new byte[_param2.\u0006\u2009\u2005\u2008\u0003() * num5];
    int num7;
    for (int index = 0; index < num5; ++index)
      _param2.\u0006\u2009\u2005\u2008\u0002(dst, num3 * index, num3, numArray, num7 * index, _param3);
    return numArray;
label_8:
    num7 = num2;
    goto label_6;
label_7:
    num3 = num1;
    goto label_5;
label_2:
    count = length;
    goto label_1;
  }

  private static int \u0002(int _param0)
  {
    int num = _param0;
    if (true)
      ;
    return num < 8 ? 200 : 1;
  }

  public static byte[] \u0002(object _param0)
  {
    switch (_param0)
    {
      case sbyte num6:
        int num1 = (int) num6;
        sbyte num2;
        if (true)
          num2 = (sbyte) num1;
        return new byte[1]{ (byte) num2 };
      case byte num7:
        int num3 = (int) num7;
        byte num4;
        if (true)
          num4 = (byte) num3;
        return new byte[1]{ num4 };
      case int num8:
        int num5;
        if (true)
          num5 = num8;
        return \u0006​.\u0002(num5);
      case uint num9:
        return \u0006​.\u0002(num9);
      case long num10:
        return \u0006​.\u0002(num10);
      case ulong num11:
        return \u0006​.\u0002(num11);
      case byte[] numArray:
        return numArray;
      case Array array:
        MemoryStream memoryStream = new MemoryStream();
        foreach (object obj in array)
        {
          byte[] buffer = \u0006​.\u0002(obj);
          memoryStream.Write(buffer, 0, buffer.Length);
        }
        return memoryStream.ToArray();
      default:
        throw new InvalidOperationException();
    }
  }

  private static byte[] \u0002(int _param0)
  {
    byte[] numArray = new byte[4];
    int num1 = _param0;
    if (true)
      ;
    numArray[3] = (byte) num1;
    int num2 = _param0;
    if (true)
      ;
    numArray[2] = (byte) (num2 >> 8);
    int num3 = _param0;
    if (true)
      ;
    numArray[1] = (byte) (num3 >> 16);
    numArray[0] = (byte) (_param0 >> 24);
    return numArray;
  }

  private static byte[] \u0002(uint _param0)
  {
    byte[] numArray = new byte[4];
    int num1 = (int) _param0;
    if (true)
      ;
    numArray[3] = (byte) num1;
    int num2 = (int) _param0;
    if (true)
      ;
    numArray[2] = (byte) ((uint) num2 >> 8);
    int num3 = (int) _param0;
    if (true)
      ;
    numArray[1] = (byte) ((uint) num3 >> 16);
    numArray[0] = (byte) (_param0 >> 24);
    return numArray;
  }

  private static byte[] \u0002(long _param0)
  {
    byte[] numArray = new byte[8];
    long num1 = _param0;
    if (true)
      ;
    numArray[7] = (byte) num1;
    long num2 = _param0;
    if (true)
      ;
    numArray[6] = (byte) (num2 >> 8);
    long num3 = _param0;
    if (true)
      ;
    numArray[5] = (byte) (num3 >> 16);
    numArray[4] = (byte) (_param0 >> 24);
    numArray[3] = (byte) (_param0 >> 32);
    numArray[2] = (byte) (_param0 >> 40);
    numArray[1] = (byte) (_param0 >> 48);
    numArray[0] = (byte) (_param0 >> 56);
    return numArray;
  }

  private static byte[] \u0002(ulong _param0)
  {
    byte[] numArray = new byte[8];
    long num1 = (long) _param0;
    if (true)
      ;
    numArray[7] = (byte) num1;
    long num2 = (long) _param0;
    if (true)
      ;
    numArray[6] = (byte) ((ulong) num2 >> 8);
    long num3 = (long) _param0;
    if (true)
      ;
    numArray[5] = (byte) ((ulong) num3 >> 16);
    numArray[4] = (byte) (_param0 >> 24);
    numArray[3] = (byte) (_param0 >> 32);
    numArray[2] = (byte) (_param0 >> 40);
    numArray[1] = (byte) (_param0 >> 48);
    numArray[0] = (byte) (_param0 >> 56);
    return numArray;
  }
}
