// Decompiled with JetBrains decompiler
// Type: SmartAssembly.AssemblyResolver.AssemblyResolverHelper
// Assembly: Microsoft Agent, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C1EE5016-57A9-47ED-B119-39E2E5AC9F12
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00028-msil\Trojan-Ransom.Win32.Blocker.aeqx-b1f983bddffbf954382415d75e15f1874e2eba7c8ad931f8ccdb2d4c798cea56.exe

using SmartAssembly.Zip;
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace SmartAssembly.AssemblyResolver
{
  internal class AssemblyResolverHelper
  {
    internal const string BindList = "{71461f04-2faa-4bb9-a0dd-28a79101b599}";
    private const int MOVEFILE_DELAY_UNTIL_REBOOT = 4;
    private static Hashtable hashtable = new Hashtable();

    [DllImport("kernel32")]
    private static extern bool MoveFileEx(string existingFileName, string newFileName, int flags);

    internal static bool IsWebApplication
    {
      get
      {
        bool flag;
        try
        {
          string lower = Process.GetCurrentProcess().MainModule.ModuleName.ToLower();
          if (true)
          {
            int num = lower == "w3wp.exe" ? 1 : 0;
            if (true)
            {
              if (num != 0)
              {
                if (true)
                {
                  flag = true;
                  goto label_12;
                }
                else
                  goto label_12;
              }
              else
                num = lower == "aspnet_wp.exe" ? 1 : 0;
            }
            if (num != 0)
            {
              flag = true;
              goto label_12;
            }
          }
        }
        catch
        {
        }
label_10:
        return false;
label_12:
        if (true)
        {
          int num = flag ? 1 : 0;
          return false ? num != 0 : num != 0;
        }
        goto label_10;
      }
    }

    internal static void Attach()
    {
      try
      {
        AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(AssemblyResolverHelper.ResolveAssembly);
      }
      catch
      {
      }
    }

    internal static unsafe Assembly ResolveAssembly(object sender, ResolveEventArgs e)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(18);
      AssemblyResolverHelper.AssemblyInfo assemblyInfo = new AssemblyResolverHelper.AssemblyInfo(e.Name);
      string base64String1 = Convert.ToBase64String(Encoding.UTF8.GetBytes(assemblyInfo.GetAssemblyFullName(false)));
      string[] strArray = "ezZhYzk4NzRjLTJjZmUtNDkxYi1hMzEzLTkzYTMyZDZkNmE0OX0sIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49M2U1NjM1MDY5M2Y3MzU1ZQ==,[z]{72a002d9-415a-4c16-bcd9-60703011dad9},ezZhYzk4NzRjLTJjZmUtNDkxYi1hMzEzLTkzYTMyZDZkNmE0OX0=,[z]{72a002d9-415a-4c16-bcd9-60703011dad9}".Split(',');
      string str1 = string.Empty;
      *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) 0;
      *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 0;
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < strArray.Length - 1)
      {
        if (strArray[*(int*) voidPtr] == base64String1)
        {
          str1 = strArray[*(int*) voidPtr + 1];
          break;
        }
        *(int*) voidPtr = *(int*) voidPtr + 2;
      }
      if (str1.Length == 0 && assemblyInfo.PublicKeyToken.Length == 0)
      {
        string base64String2 = Convert.ToBase64String(Encoding.UTF8.GetBytes(assemblyInfo.Name));
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < strArray.Length - 1)
        {
          if (strArray[*(int*) ((IntPtr) voidPtr + 4)] == base64String2)
          {
            str1 = strArray[*(int*) ((IntPtr) voidPtr + 4) + 1];
            break;
          }
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 2;
        }
      }
      if (str1.Length > 0)
      {
        if (str1[0] == '[')
        {
          *(int*) ((IntPtr) voidPtr + 8) = str1.IndexOf(']');
          string str2 = str1.Substring(1, *(int*) ((IntPtr) voidPtr + 8) - 1);
          *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) (str2.IndexOf('z') >= 0);
          *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) (str2.IndexOf('t') >= 0);
          str1 = str1.Substring(*(int*) ((IntPtr) voidPtr + 8) + 1);
        }
        lock (AssemblyResolverHelper.hashtable)
        {
          if (AssemblyResolverHelper.hashtable.ContainsKey((object) str1))
            return (Assembly) AssemblyResolverHelper.hashtable[(object) str1];
          Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(str1);
          if (manifestResourceStream != null)
          {
            *(int*) ((IntPtr) voidPtr + 12) = (int) manifestResourceStream.Length;
            byte[] numArray = new byte[*(int*) ((IntPtr) voidPtr + 12)];
            manifestResourceStream.Read(numArray, 0, *(int*) ((IntPtr) voidPtr + 12));
            if (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0)
              numArray = SimpleZip.Unzip(numArray);
            Assembly assembly = (Assembly) null;
            if (*(sbyte*) ((IntPtr) voidPtr + 17) == (sbyte) 0)
            {
              try
              {
                assembly = Assembly.Load(numArray);
              }
              catch (FileLoadException ex)
              {
                *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
              }
              catch (BadImageFormatException ex)
              {
                *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
              }
            }
            if (*(sbyte*) ((IntPtr) voidPtr + 17) != (sbyte) 0)
            {
              try
              {
                string str3 = string.Format("{0}{1}\\", (object) Path.GetTempPath(), (object) str1);
                Directory.CreateDirectory(str3);
                string str4 = str3 + assemblyInfo.Name + ".dll";
                if (!File.Exists(str4))
                {
                  FileStream fileStream = File.OpenWrite(str4);
                  fileStream.Write(numArray, 0, numArray.Length);
                  fileStream.Close();
                  AssemblyResolverHelper.MoveFileEx(str4, (string) null, 4);
                  AssemblyResolverHelper.MoveFileEx(str3, (string) null, 4);
                }
                assembly = Assembly.LoadFile(str4);
              }
              catch
              {
              }
            }
            AssemblyResolverHelper.hashtable[(object) str1] = (object) assembly;
            return assembly;
          }
        }
      }
      return (Assembly) null;
    }

    internal struct AssemblyInfo
    {
      public string Name;
      public Version Version;
      public string Culture;
      public string PublicKeyToken;

      public string GetAssemblyFullName(bool includeVersion)
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(this.Name);
        if (true)
          goto label_8;
label_5:
        if (true)
        {
          stringBuilder.Append(this.Culture.Length == 0 ? "neutral" : this.Culture);
          stringBuilder.Append(", PublicKeyToken=");
          stringBuilder.Append(this.PublicKeyToken.Length == 0 ? "null" : this.PublicKeyToken);
        }
        return stringBuilder.ToString();
label_8:
        int num;
        for (int index = includeVersion ? 1 : 0; index != 0; index = num)
        {
          num = this.Version != (Version) null ? 1 : 0;
          if (true)
          {
            if (num != 0)
            {
              stringBuilder.Append(", Version=");
              stringBuilder.Append((object) this.Version);
              break;
            }
            break;
          }
        }
        stringBuilder.Append(", Culture=");
        goto label_5;
      }

      public AssemblyInfo(string assemblyFullName)
      {
        this.Version = (Version) null;
        this.Culture = string.Empty;
        this.PublicKeyToken = string.Empty;
        this.Name = string.Empty;
        string str1 = assemblyFullName;
        char[] chArray = new char[1]{ ',' };
        foreach (string str2 in str1.Split(chArray))
        {
          string str3 = str2.Trim();
          if (str3.StartsWith("Version="))
            this.Version = new Version(str3.Substring(8));
          else if (str3.StartsWith("Culture="))
          {
            this.Culture = str3.Substring(8);
            if (this.Culture == "neutral")
              this.Culture = string.Empty;
          }
          else if (str3.StartsWith("PublicKeyToken="))
          {
            this.PublicKeyToken = str3.Substring(15);
            if (this.PublicKeyToken == "null")
              this.PublicKeyToken = string.Empty;
          }
          else
            this.Name = str3;
        }
      }
    }
  }
}
