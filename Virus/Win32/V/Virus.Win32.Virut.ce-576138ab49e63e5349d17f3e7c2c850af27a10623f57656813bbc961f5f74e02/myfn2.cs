// Decompiled with JetBrains decompiler
// Type: hotfile_link_generator.myfn2
// Assembly: hotfile link generator, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 493A96F2-70F7-4A1D-A2D2-B76427A45AE1
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Virut.ce-576138ab49e63e5349d17f3e7c2c850af27a10623f57656813bbc961f5f74e02.exe

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;

namespace hotfile_link_generator
{
  internal class myfn2
  {
    public static int findinarry(string[,] searched, string targed)
    {
      try
      {
        int length1 = searched.GetLength(0);
        int length2 = searched.GetLength(1);
        for (int index1 = 0; index1 < length1; ++index1)
        {
          for (int index2 = 0; index2 < length2; ++index2)
          {
            if (searched[index1, index2] == targed)
              return index1;
          }
        }
        return -1;
      }
      catch
      {
        return -1;
      }
    }

    public static int findinarry(string[] searched, string targed)
    {
      for (int index = 0; index < searched.Length; ++index)
      {
        if (searched[index] == targed)
          return index;
      }
      return -1;
    }

    public static string DownloadWebPage(string strURL)
    {
      WebResponse response = WebRequest.Create(strURL).GetResponse();
      StreamReader streamReader = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding("utf-8"));
      string end = streamReader.ReadToEnd();
      streamReader.Close();
      response.Close();
      return end;
    }

    public static string stringpart(string main, string search_Start, string search_end)
    {
      if (main.Contains(search_Start))
      {
        main = main.Substring(main.IndexOf(search_Start) + search_Start.Length);
        if (main.Contains(search_end))
        {
          main = main.Substring(0, main.IndexOf(search_end));
          return main;
        }
      }
      return "";
    }

    public static string cut_this(ref string mainstring, string separate)
    {
      string str1 = mainstring;
      string str2;
      try
      {
        str2 = mainstring.Substring(0, mainstring.IndexOf(separate));
        mainstring = mainstring.Substring(mainstring.IndexOf(separate) + separate.Length);
      }
      catch
      {
        return (string) null;
      }
      return str2;
    }

    public static int string_count(string mainstrig, string ch)
    {
      int num = 0;
      for (int index = mainstrig.IndexOf(ch); index != -1; index = mainstrig.IndexOf(ch))
      {
        ++num;
        mainstrig = mainstrig.Substring(index + 1);
      }
      return num;
    }

    public static bool vaildip(string ip)
    {
      if (myfn2.string_count(ip, ".") != 3 || ip[ip.Length - 1] == '.')
        return false;
      for (int index = 0; index < 3; ++index)
      {
        try
        {
          Convert.ToInt32(myfn2.cut_this(ref ip, "."));
        }
        catch
        {
          return false;
        }
      }
      return true;
    }

    public static bool vaildno(string number)
    {
      try
      {
        Convert.ToInt32(number);
      }
      catch
      {
        return false;
      }
      return true;
    }

    public static bool vaildmib(string mib)
    {
      if (mib[mib.Length - 1] == '.')
        return false;
      int num = myfn2.string_count(mib, ".");
      for (int index = 0; index < num; ++index)
      {
        try
        {
          Convert.ToInt32(myfn2.cut_this(ref mib, "."));
        }
        catch
        {
          return false;
        }
      }
      return true;
    }

    public static int findinarraylist(ArrayList serachedarray, string targed)
    {
      if (!serachedarray.Contains((object) targed))
        return -1;
      for (int index = 0; index < serachedarray.Count; ++index)
      {
        if (serachedarray[index].ToString() == targed)
          return index;
      }
      return -1;
    }

    private static string intarr_to_ip(int[] ip_int) => ip_int[0].ToString() + (object) '.' + ip_int[1].ToString() + (object) '.' + ip_int[2].ToString() + (object) '.' + ip_int[3].ToString();

    public static string incrementIP(string ip)
    {
      int[] ip_int = myfn2.ipIntoArray(ip);
      string[] strArray = new string[3];
      if (ip_int[3] >= (int) byte.MaxValue)
      {
        ip_int[3] = 1;
        ++ip_int[2];
        if (ip_int[2] >= (int) byte.MaxValue)
        {
          ip_int[2] = 1;
          ++ip_int[1];
          if (ip_int[1] >= (int) byte.MaxValue)
          {
            ip_int[1] = 1;
            ++ip_int[0];
          }
        }
      }
      else
        ++ip_int[3];
      return myfn2.intarr_to_ip(ip_int);
    }

    private static int[] ipIntoArray(string ip)
    {
      ip += (string) (object) '.';
      int[] numArray = new int[4];
      int length = ip.IndexOf('.');
      for (int index = 0; index < 4; ++index)
      {
        numArray[index] = Convert.ToInt32(ip.Substring(0, length));
        ip = ip.Substring(length + 1);
        length = ip.IndexOf('.');
      }
      return numArray;
    }

    public static bool FindAndKillProcess(string name)
    {
      foreach (Process process in Process.GetProcesses())
      {
        if (process.ProcessName.StartsWith(name))
        {
          process.Kill();
          return true;
        }
      }
      return false;
    }

    public static bool FindAndKillProcess2(string name)
    {
      bool andKillProcess2 = false;
      foreach (Process process in Process.GetProcessesByName(name))
      {
        process.Kill();
        andKillProcess2 = true;
      }
      return andKillProcess2;
    }

    public static bool isWorkingProcess(string name)
    {
      Process[] processesByName = Process.GetProcessesByName(name);
      int index = 0;
      if (index >= processesByName.Length)
        return false;
      Process process = processesByName[index];
      return true;
    }

    public static string findFileNameFromPath(string path)
    {
      int num = path.LastIndexOf('\\');
      if (num == -1)
        return path;
      path = path.Substring(num + 1);
      if (path[path.Length - 4] == '.')
        path = path.Substring(0, path.Length - 4);
      return path;
    }
  }
}
