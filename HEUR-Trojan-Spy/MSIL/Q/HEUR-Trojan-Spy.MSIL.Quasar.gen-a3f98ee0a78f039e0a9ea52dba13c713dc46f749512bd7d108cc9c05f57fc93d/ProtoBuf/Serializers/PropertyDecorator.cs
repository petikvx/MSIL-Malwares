// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Serializers.PropertyDecorator
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using ProtoBuf.Meta;
using System;
using System.Reflection;

namespace ProtoBuf.Serializers
{
  internal sealed class PropertyDecorator : ProtoDecoratorBase
  {
    private readonly PropertyInfo property;
    private readonly Type forType;
    private readonly bool readOptionsWriteValue;
    private readonly MethodInfo shadowSetter;

    public override Type ExpectedType => this.forType;

    public override bool RequiresOldValue => true;

    public override bool ReturnsValue => false;

    public PropertyDecorator(
      TypeModel model,
      Type forType,
      PropertyInfo property,
      IProtoSerializer tail)
      : base(tail)
    {
      this.forType = forType;
      this.property = property;
      PropertyDecorator.SanityCheck(model, property, tail, out this.readOptionsWriteValue, true, true);
      this.shadowSetter = PropertyDecorator.GetShadowSetter(model, property);
    }

    private static void SanityCheck(
      TypeModel model,
      PropertyInfo property,
      IProtoSerializer tail,
      out bool writeValue,
      bool nonPublic,
      bool allowInternal)
    {
      if ((object) property == null)
        throw new ArgumentNullException(nameof (property));
      writeValue = tail.ReturnsValue && ((object) PropertyDecorator.GetShadowSetter(model, property) != null || property.CanWrite && Helpers.GetSetMethod(property, nonPublic, allowInternal) != null);
      if (!property.CanRead || (object) Helpers.GetGetMethod(property, nonPublic, allowInternal) == null)
        throw new InvalidOperationException("Cannot serialize property without a get accessor");
      if (!writeValue && (!tail.RequiresOldValue || Helpers.IsValueType(tail.ExpectedType)))
        throw new InvalidOperationException("Cannot apply changes to property " + property.DeclaringType.FullName + "." + property.Name);
    }

    private static MethodInfo GetShadowSetter(TypeModel model, PropertyInfo property)
    {
      MethodInfo instanceMethod = Helpers.GetInstanceMethod(property.ReflectedType, "Set" + property.Name, new Type[1]
      {
        property.PropertyType
      });
      return (object) instanceMethod == null || !instanceMethod.IsPublic || (object) instanceMethod.ReturnType != (object) model.MapType(typeof (void)) ? (MethodInfo) null : instanceMethod;
    }

    public override void Write(object value, ProtoWriter dest)
    {
      value = this.property.GetValue(value, (object[]) null);
      if (value == null)
        return;
      this.Tail.Write(value, dest);
    }

    public override object Read(object value, ProtoReader source)
    {
      object obj = this.Tail.Read(this.Tail.RequiresOldValue ? this.property.GetValue(value, (object[]) null) : (object) null, source);
      if (this.readOptionsWriteValue && obj != null)
      {
        if ((object) this.shadowSetter == null)
          this.property.SetValue(value, obj, (object[]) null);
        else
          this.shadowSetter.Invoke(value, new object[1]
          {
            obj
          });
      }
      return (object) null;
    }

    internal static bool CanWrite(TypeModel model, MemberInfo member)
    {
      PropertyInfo property = (object) member != null ? member as PropertyInfo : throw new ArgumentNullException(nameof (member));
      if ((object) property == null)
        return member is FieldInfo;
      return property.CanWrite || PropertyDecorator.GetShadowSetter(model, property) != null;
    }
  }
}
