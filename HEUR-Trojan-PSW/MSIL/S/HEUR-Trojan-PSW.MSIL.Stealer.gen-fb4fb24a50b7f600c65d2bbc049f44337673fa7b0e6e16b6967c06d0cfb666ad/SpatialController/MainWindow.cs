// Decompiled with JetBrains decompiler
// Type: SpatialController.MainWindow
// Assembly: Rea, Version=1.2.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 014AEBFB-7EE8-4B39-A7D6-AE7A18313427
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-fb4fb24a50b7f600c65d2bbc049f44337673fa7b0e6e16b6967c06d0cfb666ad.exe

using OpenNI;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Threading;

namespace SpatialController
{
  public class MainWindow : Window, IComponentConnector
  {
    private const bool DRAW_SKELETON = true;
    private const string SKELETON_CALIBRATION_FILE = "skeleton.cal";
    private bool trackingUser;
    private int trackingUserId;
    private readonly string CONFIG_FILE = "User.xml";
    private readonly int DPI_X = 96;
    private readonly int DPI_Y = 96;
    private Console console;
    private UserPrompt prompt;
    private Context context;
    private DepthGenerator depthGenerator;
    private ImageGenerator imageGenerator;
    private UserGenerator userGenerator;
    private WriteableBitmap depthBitmap;
    private WriteableBitmap imageBitmap;
    private DepthMetaData depthData;
    private ImageMetaData imageData;
    private PoseDetectionCapability poseDetectionCapability;
    private SkeletonCapability skeletonCapability;
    private SpatialController.SpatialController spatialController;
    private SkeletonDraw skeletonDraw;
    private Thread kinectDataThread;
    private Thread checkGesturesThread;
    private DispatcherTimer imageTimer;
    private bool stop;
    internal Image imgDepth;
    private bool _contentLoaded;

    private int[] Histogram { get; set; }

    public MainWindow()
    {
      this.InitializeComponent();
      this.trackingUser = false;
      this.trackingUserId = 0;
      this.stop = false;
      this.console = new Console();
      this.console.Show();
      this.console.Top = 10.0;
      this.console.Left = 10.0;
      this.prompt = new UserPrompt();
      this.prompt.Show();
      this.prompt.Top = 10.0;
      this.prompt.Left = 550.0;
      this.Top = 250.0;
      this.Left = 550.0;
      this.context = new Context(this.CONFIG_FILE);
      this.imageGenerator = new ImageGenerator(this.context);
      this.userGenerator = new UserGenerator(this.context);
      this.depthGenerator = new DepthGenerator(this.context);
      this.depthBitmap = new WriteableBitmap(640, 480, (double) this.DPI_X, (double) this.DPI_Y, PixelFormats.Rgb24, (BitmapPalette) null);
      this.depthData = new DepthMetaData();
      this.Histogram = new int[this.depthGenerator.DeviceMaxDepth];
      this.skeletonDraw = new SkeletonDraw();
      this.poseDetectionCapability = this.userGenerator.PoseDetectionCapability;
      this.skeletonCapability = this.userGenerator.SkeletonCapability;
      this.imageBitmap = new WriteableBitmap(640, 480, (double) this.DPI_X, (double) this.DPI_Y, PixelFormats.Rgb24, (BitmapPalette) null);
      this.imageData = new ImageMetaData();
      Device.SetUp();
      this.spatialController = !File.Exists("calibration.txt") ? new SpatialController.SpatialController(ControllerStartup.Calibrate, this.userGenerator) : new SpatialController.SpatialController(ControllerStartup.FromFile, this.userGenerator);
      this.spatialController.RecalibrateCommand += new RecalibrateEventHandler(this.RecalibrateCommand);
      this.userGenerator.NewUser += new EventHandler<NewUserEventArgs>(this.NewUser);
      this.userGenerator.LostUser += new EventHandler<UserLostEventArgs>(this.LostUser);
      this.skeletonCapability.CalibrationStart += new EventHandler<CalibrationStartEventArgs>(this.CalibrationStart);
      this.skeletonCapability.CalibrationEnd += new EventHandler<CalibrationEndEventArgs>(this.CalibrationEnd);
      this.skeletonCapability.SetSkeletonProfile((SkeletonProfile) 2);
      this.poseDetectionCapability.PoseDetected += new EventHandler<PoseDetectedEventArgs>(this.PoseDetected);
      this.poseDetectionCapability.PoseEnded += new EventHandler<PoseEndedEventArgs>(this.PoseEnded);
      this.kinectDataThread = new Thread(new ThreadStart(this.ReadKinectData));
      this.kinectDataThread.IsBackground = true;
      this.checkGesturesThread = new Thread(new ThreadStart(this.CheckGestures));
      this.checkGesturesThread.IsBackground = true;
      this.imageTimer = new DispatcherTimer();
      this.imageTimer.Tick += new EventHandler(this.ImageTick);
      this.imageTimer.Interval = new TimeSpan(0, 0, 0, 0, 100);
      this.kinectDataThread.Start();
      this.checkGesturesThread.Start();
      this.imageTimer.Start();
      UserPrompt.Write("Finished loading window.");
      Console.Write("Finished loading window");
      UserPrompt.Write("Please assume the Psi pose and hold it until you see a skeleton overlaid on the streaming video.");
    }

    private void NewUser(object sender, NewUserEventArgs e)
    {
      if (File.Exists("skeleton.cal") && !this.trackingUser)
      {
        this.userGenerator.SkeletonCapability.LoadCalibrationDataFromFile(((UserEventArgs) e).ID, "skeleton.cal");
        this.userGenerator.SkeletonCapability.StartTracking(((UserEventArgs) e).ID);
        this.trackingUser = true;
        this.trackingUserId = ((UserEventArgs) e).ID;
      }
      else
        this.userGenerator.PoseDetectionCapability.StartPoseDetection(this.userGenerator.SkeletonCapability.CalibrationPose, ((UserEventArgs) e).ID);
      Console.Write(((UserEventArgs) e).ID.ToString() + " Found new user");
    }

    private void LostUser(object sender, UserLostEventArgs e)
    {
      if (this.trackingUserId == ((UserEventArgs) e).ID)
        this.trackingUser = false;
      Console.Write(((UserEventArgs) e).ID.ToString() + " Lost user");
    }

    private void PoseDetected(object sender, PoseDetectedEventArgs e)
    {
      Console.Write(e.ID.ToString() + " Detected pose " + e.Pose);
      this.userGenerator.PoseDetectionCapability.StopPoseDetection(e.ID);
      this.userGenerator.SkeletonCapability.RequestCalibration(e.ID, true);
    }

    private void PoseEnded(object sender, PoseEndedEventArgs e) => Console.Write(e.ID.ToString() + " Lost Pose " + e.Pose);

    private void CalibrationStart(object sender, CalibrationStartEventArgs e) => Console.Write(((UserEventArgs) e).ID.ToString() + " Calibration start");

    private void CalibrationEnd(object sender, CalibrationEndEventArgs e)
    {
      Console.Write(((UserEventArgs) e).ID.ToString() + " Calibration ended " + (e.Success ? "successfully" : "unsuccessfully"));
      if (e.Success)
      {
        if (this.trackingUser)
          this.userGenerator.SkeletonCapability.StopTracking(this.trackingUserId);
        this.userGenerator.SkeletonCapability.StartTracking(((UserEventArgs) e).ID);
        this.trackingUser = true;
        this.trackingUserId = ((UserEventArgs) e).ID;
        this.userGenerator.SkeletonCapability.SaveCalibrationDataToFile(this.trackingUserId, "skeleton.cal");
      }
      else
        this.userGenerator.PoseDetectionCapability.StartPoseDetection(this.userGenerator.SkeletonCapability.CalibrationPose, ((UserEventArgs) e).ID);
    }

    private void RecalibrateCommand(object sender, EventArgs e)
    {
      Console.Write("Recalibration requested--stopping current skeletal tracking.");
      if (this.userGenerator.SkeletonCapability.IsTracking(this.trackingUserId))
        this.userGenerator.SkeletonCapability.StopTracking(this.trackingUserId);
      this.trackingUser = false;
    }

    private void ReadKinectData()
    {
      while (!this.stop)
      {
        try
        {
          this.context.WaitAndUpdateAll();
          this.imageGenerator.GetMetaData(this.imageData);
        }
        catch (Exception ex)
        {
        }
      }
    }

    private void CheckGestures()
    {
      while (!this.stop)
      {
        this.spatialController.checkGestures();
        Thread.Sleep(100);
      }
    }

    private void ImageTick(object sender, EventArgs e)
    {
      if (this.imageData == null || ((OutputMetaData) this.imageData).DataSize <= 1)
        return;
      this.imgDepth.Source = this.RawImageSource;
    }

    private void MainWindow_Closing(object sender, CancelEventArgs e)
    {
      this.stop = true;
      this.console.Close();
      this.prompt.Close();
    }

    public unsafe void UpdateHistogram(DepthMetaData depthMD)
    {
      for (int index = 0; index < this.Histogram.Length; ++index)
        this.Histogram[index] = 0;
      ushort* pointer = (ushort*) depthMD.DepthMapPtr.ToPointer();
      int num1 = 0;
      for (int index1 = 0; index1 < ((MapMetaData) depthMD).YRes; ++index1)
      {
        int num2 = 0;
        while (num2 < ((MapMetaData) depthMD).XRes)
        {
          ushort index2 = *pointer;
          if (index2 > (ushort) 0)
          {
            ++this.Histogram[(int) index2];
            ++num1;
          }
          ++num2;
          ++pointer;
        }
      }
      for (int index = 1; index < this.Histogram.Length; ++index)
        this.Histogram[index] += this.Histogram[index - 1];
      if (num1 <= 0)
        return;
      for (int index = 1; index < this.Histogram.Length; ++index)
        this.Histogram[index] = (int) (256.0 * (1.0 - (double) this.Histogram[index] / (double) num1));
    }

    public ImageSource RawImageSource
    {
      get
      {
        if (this.imageBitmap != null)
        {
          this.imageBitmap.Lock();
          this.imageBitmap.WritePixels(new Int32Rect(0, 0, ((MapMetaData) this.imageData).XRes, ((MapMetaData) this.imageData).YRes), this.imageData.ImageMapPtr, ((OutputMetaData) this.imageData).DataSize, this.imageBitmap.BackBufferStride);
          this.imageBitmap.Unlock();
        }
        this.skeletonDraw.DrawStickFigure(ref this.imageBitmap, this.depthGenerator, this.depthData, this.userGenerator, this.spatialController.RaysToBeAnimated);
        return (ImageSource) this.imageBitmap;
      }
    }

    public unsafe ImageSource DepthImageSource
    {
      get
      {
        if (this.depthBitmap != null)
        {
          this.UpdateHistogram(this.depthData);
          this.depthBitmap.Lock();
          ushort* pointer = (ushort*) this.depthGenerator.DepthMapPtr.ToPointer();
          for (int index = 0; index < ((MapMetaData) this.depthData).YRes; ++index)
          {
            byte* numPtr = (byte*) ((IntPtr) this.depthBitmap.BackBuffer.ToPointer() + index * this.depthBitmap.BackBufferStride);
            int num1 = 0;
            while (num1 < ((MapMetaData) this.depthData).XRes)
            {
              byte num2 = (byte) this.Histogram[(int) *pointer];
              *numPtr = num2;
              numPtr[1] = num2;
              numPtr[2] = num2;
              ++num1;
              ++pointer;
              numPtr += 3;
            }
          }
          this.depthBitmap.AddDirtyRect(new Int32Rect(0, 0, ((MapMetaData) this.depthData).XRes, ((MapMetaData) this.depthData).YRes));
          this.depthBitmap.Unlock();
        }
        DepthCorrection.Fix(ref this.depthBitmap, ((MapMetaData) this.depthData).XRes, ((MapMetaData) this.depthData).YRes);
        this.skeletonDraw.DrawStickFigure(ref this.depthBitmap, this.depthGenerator, this.depthData, this.userGenerator, this.spatialController.RaysToBeAnimated);
        return (ImageSource) this.depthBitmap;
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/Rea;component/mainwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      if (connectionId == 1)
        this.imgDepth = (Image) target;
      else
        this._contentLoaded = true;
    }
  }
}
