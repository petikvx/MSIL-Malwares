// Decompiled with JetBrains decompiler
// Type:  
// Assembly: Server.packed, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 712FD340-1A8D-4ADA-8620-0D072E5BB482
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Blocker.bipa-183abe361833d2ddb4e38325acbbb19715b5270dec52a0eb9bb6b99cfb8f1470.exe

using \u0003;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;

public sealed class \u0005\u2000
{
  private \u0005\u2000.\u0001 \u0001;
  private \u0005\u2000.\u0001 \u0002;
  private \u0005\u2000.Ⴐ \u0001;
  private \u0003.\u0003.\u0001 \u0001;

  public \u0005\u2000()
  {
    this.\u0001.\u0001 = new \u000E();
    this.\u0001.\u0001 = new \u0003.\u0003();
    this.\u0001.\u0001 = new Ⴈ.Ⴐ[new IntPtr(192)];
    this.\u0001.\u0002 = new Ⴈ.Ⴐ[new IntPtr(12)];
    this.\u0001.\u0003 = new Ⴈ.Ⴐ[new IntPtr(12)];
    this.\u0001.\u0004 = new Ⴈ.Ⴐ[new IntPtr(12)];
    this.\u0001.\u0005 = new Ⴈ.Ⴐ[new IntPtr(12)];
    this.\u0001.\u0006 = new Ⴈ.Ⴐ[new IntPtr(192)];
    this.\u0001.\u0001 = new \u0002[new IntPtr(4)];
    this.\u0001.\u0007 = new Ⴈ.Ⴐ[new IntPtr(114)];
    this.\u0001.\u0001 = new \u0002(4);
    this.\u0001 = new \u0005\u2000.\u0001();
    this.\u0002 = new \u0005\u2000.\u0001();
    this.\u0001 = new \u0005\u2000.Ⴐ();
    // ISSUE: explicit constructor call
    base.\u002Ector();
    this.\u0001.\u0001 = uint.MaxValue;
    for (int index = 0; index < 4; ++index)
      this.\u0001.\u0001[index] = new \u0002(6);
  }

  private unsafe void \u0001([In] uint obj0)
  {
    void* voidPtr;
    do
    {
      // ISSUE: untyped stack allocation
      voidPtr = (void*) __untypedstackalloc(12);
    }
    while (false);
    int num1 = 2;
    int num2;
    if (num1 != 0)
      num2 = num1;
    else
      goto label_16;
label_14:
    while (true)
    {
      do
      {
        switch (num2)
        {
          case 0:
            num2 = 6;
            continue;
          case 1:
          case 4:
            if (true)
            {
              *(int*) voidPtr = (int) global::\u0003.Ⴄ(this.\u0001.\u0002, 4096U, 819, 868);
              goto case 0;
            }
            else
              goto label_5;
          case 3:
          case 7:
            if (false)
              goto case 0;
            else
              goto label_17;
          case 5:
            goto label_10;
          case 6:
            goto label_11;
          default:
            goto label_15;
        }
      }
      while (true);
label_6:
      *(int*) ((IntPtr) voidPtr + 8) = (int) global::\u0003.Ⴄ(this.\u0001.\u0001, 1U, 517, 594);
      this.\u0001.\u0002 = *(uint*) ((IntPtr) voidPtr + 8);
      num2 = 4;
      continue;
label_17:
      *(int*) ((IntPtr) voidPtr + 4) = (int) obj0;
      this.\u0001.\u0001 = *(uint*) ((IntPtr) voidPtr + 4);
      goto label_6;
    }
label_10:
    return;
label_2:
    num1 = 3;
    goto label_16;
label_5:
    return;
label_11:
    if (true)
    {
      this.\u0001.\u0001.\u0002(*(uint*) voidPtr);
      return;
    }
    goto label_2;
label_15:
    if ((int) this.\u0001.\u0001 == (int) obj0)
      num1 = 5;
    else
      goto label_2;
label_16:
    num2 = num1;
    goto label_14;
  }

  private void \u0001([In] int obj0, [In] int obj1)
  {
    int num1 = 7;
    while (true)
    {
      int num2;
      int num3;
      do
      {
        switch (num1)
        {
          case 1:
            goto label_13;
          case 2:
          case 3:
            goto label_17;
          case 4:
            goto label_10;
          case 5:
            goto label_16;
          case 6:
            num2 = obj1;
            int num4;
            while (true)
            {
              num3 = 8;
              if (num3 != 0)
              {
                if (num2 <= num3)
                {
                  num4 = 3;
                  if (num4 == 0)
                    num2 = num4;
                  else
                    goto label_7;
                }
                else
                  break;
              }
              else
                goto label_3;
            }
            num4 = 5;
label_7:
            if (true)
              goto label_15;
label_8:
            continue;
label_15:
            num1 = num4;
            goto label_8;
          default:
            goto label_12;
        }
      }
      while (false);
      continue;
label_1:
      int num5;
      int num6;
      num1 = num5 <= num6 ? 6 : 1;
      continue;
label_3:
      num6 = num3;
      num5 = num2;
      goto label_1;
label_12:
      num5 = obj0;
      num6 = 8;
      goto label_1;
    }
label_10:
    return;
label_13:
    throw new \u0001.\u0003();
label_16:
    throw new \u0001.\u0003();
label_17:
    this.\u0001.\u0001(obj0, obj1);
  }

  private unsafe void \u0001([In] int obj0)
  {
label_0:
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(8);
    int num = 4;
    while (true)
    {
      switch (num)
      {
        case 0:
          if (true)
          {
            this.\u0001.\u0001(*(uint*) voidPtr);
            if (true)
            {
              num = 2;
              continue;
            }
            goto case 0;
          }
          else
            goto label_0;
        case 1:
          goto label_3;
        case 2:
          goto label_5;
        case 3:
          *(int*) voidPtr = 1 << obj0;
          goto case 0;
        case 5:
          goto label_6;
        case 6:
          goto label_1;
        default:
          num = obj0 <= 4 ? 3 : 6;
          continue;
      }
    }
label_3:
    return;
label_1:
    if (false)
      return;
    throw new \u0001.\u0003();
label_5:
    this.\u0002.\u0001(*(uint*) voidPtr);
label_6:
    *(int*) ((IntPtr) voidPtr + 4) = (int) *(uint*) voidPtr - 1;
    this.\u0001.\u0003 = *(uint*) ((IntPtr) voidPtr + 4);
  }

  private unsafe void \u0001([In] Stream obj0, [In] Stream obj1)
  {
    // ISSUE: untyped stack allocation
    void* voidPtr = (void*) __untypedstackalloc(12);
    int num;
    if (true)
      num = 10;
    while (true)
    {
      switch (num)
      {
        case 0:
          num = *(uint*) voidPtr < 4U ? 16 : 1;
          continue;
        case 1:
          *(int*) voidPtr = 0;
          num = 17;
          continue;
        case 2:
          *(int*) voidPtr = (int) *(uint*) voidPtr + 1;
          num = 11;
          continue;
        case 3:
          *(int*) voidPtr = 0;
          num = 11;
          continue;
        case 4:
          goto label_18;
        case 5:
          this.\u0001.\u0004[(IntPtr) *(uint*) voidPtr].\u0001();
          this.\u0001.\u0005[(IntPtr) *(uint*) voidPtr].\u0001();
          num = 2;
          continue;
        case 6:
          this.\u0001.\u0006[(IntPtr) *(uint*) ((IntPtr) voidPtr + 8)].\u0001();
          *(int*) ((IntPtr) voidPtr + 4) = (int) *(uint*) ((IntPtr) voidPtr + 4) + 1;
          num = 15;
          continue;
        case 7:
          this.\u0001.\u0007[(IntPtr) *(uint*) voidPtr].\u0001();
          *(int*) voidPtr = (int) *(uint*) voidPtr + 1;
          num = 17;
          continue;
        case 8:
          this.\u0001.\u0002[(IntPtr) *(uint*) voidPtr].\u0001();
          this.\u0001.\u0003[(IntPtr) *(uint*) voidPtr].\u0001();
          num = 5;
          continue;
        case 9:
          num = 3;
          continue;
        case 11:
          num = *(uint*) voidPtr < 12U ? 14 : 13;
          continue;
        case 12:
        case 17:
          num = *(uint*) voidPtr < 114U ? 7 : 4;
          continue;
        case 13:
          this.\u0001.\u0001();
          *(int*) voidPtr = 0;
          num = 0;
          continue;
        case 14:
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          num = 15;
          continue;
        case 15:
          num = *(uint*) ((IntPtr) voidPtr + 4) <= this.\u0001.\u0003 ? 18 : 8;
          continue;
        case 16:
          this.\u0001.\u0001[(IntPtr) *(uint*) voidPtr].\u0001();
          *(int*) voidPtr = (int) *(uint*) voidPtr + 1;
          num = 0;
          continue;
        case 18:
          *(int*) ((IntPtr) voidPtr + 8) = ((int) *(uint*) voidPtr << 4) + (int) *(uint*) ((IntPtr) voidPtr + 4);
          this.\u0001.\u0001[(IntPtr) *(uint*) ((IntPtr) voidPtr + 8)].\u0001();
          goto case 19;
        case 19:
          num = 6;
          continue;
        default:
          this.\u0001.\u0001.\u0001(obj0);
          this.\u0001.\u0001.\u0002(obj1);
          goto case 9;
      }
    }
label_18:
    this.\u0001.\u0001();
    this.\u0002.\u0001();
    this.\u0001.\u0001.\u0001();
  }

  public unsafe void \u0001([In] Stream obj0, [In] Stream obj1, [In] long obj2, [In] long obj3, [In] \u0007.\u0001 obj4)
  {
    // ISSUE: untyped stack allocation
    IntPtr num1 = __untypedstackalloc(55);
    if (true)
      goto label_54;
label_1:
    int num2 = 12;
    void* voidPtr;
    while (true)
    {
      int num3;
      do
      {
        int num4 = num2;
        while (true)
        {
          switch (num4)
          {
            case 0:
              goto label_53;
            case 1:
              goto label_19;
            case 2:
              goto label_29;
            case 3:
              goto label_18;
            case 4:
              goto label_48;
            case 5:
              goto label_15;
            case 6:
              goto label_20;
            case 7:
            case 11:
              goto label_28;
            case 8:
              goto label_34;
            case 9:
              goto label_51;
            case 10:
              goto label_46;
            case 13:
              goto label_41;
            case 14:
              goto label_39;
            case 15:
              goto label_8;
            case 16:
              goto label_4;
            case 17:
              goto label_24;
            case 18:
              goto label_33;
            case 19:
              goto label_42;
            case 20:
              goto label_9;
            case 21:
              goto label_36;
            case 22:
              goto label_32;
            case 23:
              goto label_44;
            case 24:
              goto label_23;
            case 25:
              goto label_50;
            case 26:
              goto label_16;
            case 27:
              goto label_12;
            case 28:
              goto label_37;
            case 29:
              goto label_31;
            case 30:
              goto label_10;
            case 31:
              goto label_38;
            case 32:
              goto label_21;
            case 33:
              goto label_5;
            case 34:
              goto label_7;
            case 35:
              goto label_49;
            case 36:
              goto label_40;
            case 37:
              goto label_25;
            case 38:
              goto label_43;
            case 39:
              goto label_6;
            case 40:
              goto label_11;
            case 41:
              goto label_45;
            case 42:
              goto label_26;
            case 43:
              goto label_27;
            case 44:
              *(sbyte*) ((IntPtr) voidPtr + 53) = (sbyte) this.\u0001.\u0001(this.\u0001.\u0001, (uint) *(long*) voidPtr, *(byte*) ((IntPtr) voidPtr + 54), this.\u0001.\u0001.\u0002(*(uint*) ((IntPtr) voidPtr + 16)));
              num3 = 26;
              if (num3 == 0)
              {
                num4 = num3;
                continue;
              }
              goto label_14;
            case 45:
              goto label_35;
            default:
              goto label_56;
          }
        }
label_51:
        this.\u0001.\u0001.\u0003();
      }
      while (false);
      goto label_52;
label_4:
      *(int*) ((IntPtr) voidPtr + 20) = 0;
      *(int*) ((IntPtr) voidPtr + 24) = 0;
      *(int*) ((IntPtr) voidPtr + 28) = 0;
label_5:
      *(long*) voidPtr = 0L;
      *(long*) ((IntPtr) voidPtr + 8) = obj3;
      num2 = 39;
      continue;
label_6:
      num2 = (ulong) *(long*) voidPtr >= (ulong) *(long*) ((IntPtr) voidPtr + 8) ? 25 : 34;
      continue;
label_7:
      \u0004.\u0001.\u0001 obj;
      num2 = this.\u0001.\u0001[(IntPtr) (obj.\u0001 << 4)].\u0001(this.\u0001.\u0001) == 0U ? 20 : 15;
      continue;
label_9:
      obj.\u0002();
      *(sbyte*) ((IntPtr) voidPtr + 52) = (sbyte) this.\u0001.\u0001(this.\u0001.\u0001, 0U, (byte) 0);
      num2 = 30;
      continue;
label_10:
      this.\u0001.\u0001.\u0002(*(byte*) ((IntPtr) voidPtr + 52));
      *(long*) voidPtr = *(long*) voidPtr + 1L;
      num2 = 25;
      continue;
label_11:
      *(int*) ((IntPtr) voidPtr + 32) = (int) (uint) *(long*) voidPtr & (int) this.\u0001.\u0003;
      num2 = this.\u0001.\u0001[(IntPtr) ((obj.\u0001 << 4) + *(uint*) ((IntPtr) voidPtr + 32))].\u0001(this.\u0001.\u0001) != 0U ? 1 : 27;
      continue;
label_12:
      *(sbyte*) ((IntPtr) voidPtr + 54) = (sbyte) this.\u0001.\u0001.\u0002(0U);
      num2 = obj.\u0001() ? 5 : 44;
      continue;
label_14:
      num2 = num3;
      continue;
label_15:
      *(sbyte*) ((IntPtr) voidPtr + 53) = (sbyte) this.\u0001.\u0001(this.\u0001.\u0001, (uint) *(long*) voidPtr, *(byte*) ((IntPtr) voidPtr + 54));
      num2 = 26;
      continue;
label_16:
      this.\u0001.\u0001.\u0002(*(byte*) ((IntPtr) voidPtr + 53));
      if (true)
      {
        obj.\u0002();
        *(long*) voidPtr = *(long*) voidPtr + 1L;
      }
      else
        goto label_32;
label_18:
      num2 = 25;
      continue;
label_19:
      num2 = this.\u0001.\u0002[(IntPtr) obj.\u0001].\u0001(this.\u0001.\u0001) != 1U ? 45 : 6;
      continue;
label_20:
      num2 = this.\u0001.\u0003[(IntPtr) obj.\u0001].\u0001(this.\u0001.\u0001) != 0U ? 37 : 32;
      continue;
label_21:
      int num5 = this.\u0001.\u0006[(IntPtr) ((obj.\u0001 << 4) + *(uint*) ((IntPtr) voidPtr + 32))].\u0001(this.\u0001.\u0001) != 0U ? 18 : 24;
label_22:
      num2 = num5;
      continue;
label_23:
      obj.\u0005();
      this.\u0001.\u0001.\u0002(this.\u0001.\u0001.\u0002(*(uint*) ((IntPtr) voidPtr + 16)));
      num2 = 17;
      continue;
label_24:
      *(long*) voidPtr = *(long*) voidPtr + 1L;
      num2 = 25;
      continue;
label_25:
      num2 = this.\u0001.\u0004[(IntPtr) obj.\u0001].\u0001(this.\u0001.\u0001) != 0U ? 43 : 42;
      continue;
label_26:
      *(int*) ((IntPtr) voidPtr + 40) = (int) *(uint*) ((IntPtr) voidPtr + 20);
      num2 = 22;
      continue;
label_27:
      num2 = this.\u0001.\u0005[(IntPtr) obj.\u0001].\u0001(this.\u0001.\u0001) != 0U ? 2 : 11;
      continue;
label_28:
      *(int*) ((IntPtr) voidPtr + 40) = (int) *(uint*) ((IntPtr) voidPtr + 24);
      num2 = 29;
      continue;
label_29:
      *(int*) ((IntPtr) voidPtr + 40) = (int) *(uint*) ((IntPtr) voidPtr + 28);
      *(int*) ((IntPtr) voidPtr + 28) = (int) *(uint*) ((IntPtr) voidPtr + 24);
      int num6 = 29;
label_30:
      num2 = num6;
      continue;
label_31:
      *(int*) ((IntPtr) voidPtr + 24) = (int) *(uint*) ((IntPtr) voidPtr + 20);
      num2 = 22;
      continue;
label_32:
      *(int*) ((IntPtr) voidPtr + 20) = (int) *(uint*) ((IntPtr) voidPtr + 16);
      *(int*) ((IntPtr) voidPtr + 16) = (int) *(uint*) ((IntPtr) voidPtr + 40);
      num2 = 18;
      continue;
label_33:
      *(int*) ((IntPtr) voidPtr + 36) = (int) this.\u0002.\u0001(this.\u0001.\u0001, *(uint*) ((IntPtr) voidPtr + 32)) + 2;
      num2 = 8;
      continue;
label_34:
      obj.\u0004();
      num2 = 23;
      continue;
label_35:
      *(int*) ((IntPtr) voidPtr + 28) = (int) *(uint*) ((IntPtr) voidPtr + 24);
      *(int*) ((IntPtr) voidPtr + 24) = (int) *(uint*) ((IntPtr) voidPtr + 20);
      *(int*) ((IntPtr) voidPtr + 20) = (int) *(uint*) ((IntPtr) voidPtr + 16);
      *(int*) ((IntPtr) voidPtr + 36) = 2 + (int) this.\u0001.\u0001(this.\u0001.\u0001, *(uint*) ((IntPtr) voidPtr + 32));
      num2 = 21;
      continue;
label_36:
      obj.\u0003();
      *(int*) ((IntPtr) voidPtr + 44) = (int) this.\u0001.\u0001[(IntPtr) \u0004.\u0001.\u0001(*(uint*) ((IntPtr) voidPtr + 36))].\u0001(this.\u0001.\u0001);
      num2 = 28;
      continue;
label_37:
      num2 = *(uint*) ((IntPtr) voidPtr + 44) < 4U ? 38 : 31;
      continue;
label_38:
      *(int*) ((IntPtr) voidPtr + 48) = (int) (*(uint*) ((IntPtr) voidPtr + 44) >> 1) - 1;
      *(int*) ((IntPtr) voidPtr + 16) = (2 | (int) *(uint*) ((IntPtr) voidPtr + 44) & 1) << *(int*) ((IntPtr) voidPtr + 48);
      num2 = 14;
      continue;
label_39:
      num2 = *(uint*) ((IntPtr) voidPtr + 44) >= 14U ? 13 : 36;
      continue;
label_40:
      *(int*) ((IntPtr) voidPtr + 16) = (int) *(uint*) ((IntPtr) voidPtr + 16) + (int) \u0002.\u0001(this.\u0001.\u0007, (uint) ((int) *(uint*) ((IntPtr) voidPtr + 16) - (int) *(uint*) ((IntPtr) voidPtr + 44) - 1), this.\u0001.\u0001, *(int*) ((IntPtr) voidPtr + 48));
      num2 = 23;
      continue;
label_41:
      *(int*) ((IntPtr) voidPtr + 16) = (int) *(uint*) ((IntPtr) voidPtr + 16) + ((int) this.\u0001.\u0001.\u0001(*(int*) ((IntPtr) voidPtr + 48) - 4) << 4);
      num2 = 19;
      continue;
label_42:
      *(int*) ((IntPtr) voidPtr + 16) = (int) *(uint*) ((IntPtr) voidPtr + 16) + (int) this.\u0001.\u0001.\u0002(this.\u0001.\u0001);
      num2 = 23;
      continue;
label_43:
      *(int*) ((IntPtr) voidPtr + 16) = (int) *(uint*) ((IntPtr) voidPtr + 44);
      num2 = 23;
      continue;
label_44:
      num2 = (ulong) *(uint*) ((IntPtr) voidPtr + 16) >= (ulong) *(long*) voidPtr ? 10 : 41;
      continue;
label_45:
      num2 = *(uint*) ((IntPtr) voidPtr + 16) < this.\u0001.\u0002 ? 35 : 10;
      continue;
label_46:
      int num7 = (int) *(uint*) ((IntPtr) voidPtr + 16);
      if (false)
      {
        num6 = num7;
        goto label_30;
      }
      else
      {
        num2 = num7 == -1 ? 9 : 4;
        continue;
      }
label_49:
      this.\u0001.\u0001.\u0002(*(uint*) ((IntPtr) voidPtr + 16), *(uint*) ((IntPtr) voidPtr + 36));
      *(long*) voidPtr = *(long*) voidPtr + (long) *(uint*) ((IntPtr) voidPtr + 36);
      num2 = 25;
      continue;
label_50:
      num2 = (ulong) *(long*) voidPtr < (ulong) *(long*) ((IntPtr) voidPtr + 8) ? 40 : 9;
      continue;
label_52:
      this.\u0001.\u0001.\u0002();
      num2 = 0;
      continue;
label_56:
      this.\u0001(obj0, obj1);
      obj = new \u0004.\u0001.\u0001();
      obj.\u0001();
      *(int*) ((IntPtr) voidPtr + 16) = 0;
      num5 = 16;
      if (num5 != 0)
        num2 = num5;
      else
        goto label_22;
    }
label_8:
    throw new \u0005.\u0001();
label_48:
    throw new \u0005.\u0001();
label_53:
    this.\u0001.\u0001.\u0001();
    return;
label_54:
    voidPtr = (void*) num1;
    goto label_1;
  }

  public unsafe void \u0001([In] byte[] obj0)
  {
    int num1;
    void* voidPtr;
    int num2;
    if (true)
    {
      int num3 = 24;
      if (num3 != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num3);
        num1 = 0;
        goto label_18;
      }
      else
      {
        num2 = num3;
        goto label_11;
      }
    }
    else
      goto label_5;
label_4:
    int num4;
    if (true)
    {
      num1 = num4;
      goto label_18;
    }
    else
      goto label_18;
label_5:
    num4 = 2;
    goto label_4;
label_11:
    num1 = num2;
label_18:
    while (true)
    {
      do
      {
        switch (num1)
        {
          case 1:
            continue;
          case 2:
            goto label_22;
          case 3:
            goto label_13;
          case 4:
            goto label_15;
          case 5:
          case 6:
            goto label_10;
          case 7:
          case 8:
            goto label_21;
          case 9:
            goto label_12;
          case 10:
            goto label_14;
          case 11:
            goto label_16;
          case 12:
            goto label_7;
          default:
            goto label_19;
        }
      }
      while (false);
      break;
label_7:
      *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 4) % 5;
      *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4) / 5;
      num1 = *(int*) ((IntPtr) voidPtr + 12) <= 4 ? 6 : 1;
      continue;
label_12:
      *(int*) ((IntPtr) voidPtr + 16) = (int) *(uint*) ((IntPtr) voidPtr + 16) + ((int) obj0[1 + *(int*) ((IntPtr) voidPtr + 20)] << *(int*) ((IntPtr) voidPtr + 20) * 8);
label_13:
      num1 = 10;
      continue;
label_14:
      *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
      num1 = 4;
      continue;
label_15:
      num1 = *(int*) ((IntPtr) voidPtr + 20) < 4 ? 9 : 11;
      continue;
label_22:
      *(int*) voidPtr = (int) obj0[0] % 9;
      *(int*) ((IntPtr) voidPtr + 4) = (int) obj0[0] / 9;
      num1 = 12;
    }
    throw new \u0001.\u0003();
label_10:
    *(int*) ((IntPtr) voidPtr + 16) = 0;
    *(int*) ((IntPtr) voidPtr + 20) = 0;
    num2 = 4;
    goto label_11;
label_16:
    this.\u0001(*(uint*) ((IntPtr) voidPtr + 16));
    this.\u0001(*(int*) ((IntPtr) voidPtr + 8), *(int*) voidPtr);
    if (false)
      return;
    this.\u0001(*(int*) ((IntPtr) voidPtr + 12));
    return;
label_19:
    if (obj0.Length < 5)
    {
      num4 = 8;
      goto label_4;
    }
    else
      goto label_5;
label_21:
    throw new \u0001.\u0003();
  }

  static \u0005\u2000() => \u0004.\u0001.\u0001();

  internal static Assembly \u0001([In] Type obj0, [In] int obj1, [In] int obj2)
  {
    if (false)
      goto label_6;
    else
      goto label_12;
label_1:
    int num1;
    int num2;
    if (true)
      num2 = num1;
    else
      goto label_7;
label_2:
    switch (num2)
    {
      case 0:
      case 3:
        num1 = 4;
        goto label_1;
      case 1:
      case 4:
        goto label_12;
      case 5:
        goto label_10;
      case 7:
        return obj0.Assembly;
      default:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.\u0001);
        num1 = 4;
        goto label_1;
    }
label_6:
    int num3 = 3;
    goto label_14;
label_7:
    num3 = 7;
    goto label_14;
label_10:
    num1 = 4;
    goto label_1;
label_12:
    int num4 = obj2;
    if (false)
    {
      num2 = num4;
      goto label_2;
    }
    else
    {
      if (true)
        goto label_13;
label_5:
      switch (num4)
      {
        case 0:
          goto label_7;
        default:
          goto label_6;
      }
label_13:
      int num5 = obj1;
      num4 = (num4 ^ num5) - 111;
      goto label_5;
    }
label_14:
    num1 = num3;
    if (false)
      goto label_10;
    else
      goto label_1;
  }

  internal static string \u0001([In] string obj0, [In] string obj1, [In] int obj2, [In] int obj3)
  {
label_11:
    int num1 = obj3;
    if (true)
      goto label_12;
label_1:
    int num2;
    switch (num1)
    {
      case 0:
        num2 = 6;
        goto label_10;
      case 1:
      case 4:
      case 7:
        if (true)
        {
          num2 = 6;
          if (true)
          {
            if (false)
              goto label_4;
            else
              goto label_10;
          }
          else
            goto label_5;
        }
        else
          goto case 5;
      case 5:
        return obj0 + obj1;
      case 6:
        goto label_11;
      default:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.\u0001);
        break;
    }
label_3:
    num2 = 6;
    goto label_10;
label_4:
    int num3 = 0;
    goto label_13;
label_5:
    num3 = 5;
    goto label_13;
label_10:
    num1 = num2;
    goto label_1;
label_12:
    int num4 = obj2;
    switch (num1 ^ num4)
    {
      case 101:
        goto label_5;
      default:
        goto label_4;
    }
label_13:
    num2 = num3;
    if (false)
      goto label_3;
    else
      goto label_10;
  }

  internal static string \u0001([In] string obj0, [In] string obj1, [In] string obj2, [In] int obj3, [In] int obj4)
  {
label_13:
    int num1 = obj4;
    while (true)
    {
      int num2 = obj3;
      int num3 = num1 ^ num2;
      int num4;
      if (true)
      {
        if (true)
        {
          switch (num3 - 15)
          {
            case 0:
              num3 = 4;
              goto label_15;
            default:
              num3 = 1;
              goto label_15;
          }
        }
        else
        {
          num4 = num3;
          goto label_10;
        }
      }
      else
        goto label_15;
label_7:
      int num5 = 7;
      if (num5 == 0)
      {
        num1 = num5;
        continue;
      }
      int num6 = num5;
      goto label_12;
label_10:
      num6 = num4;
      if (false)
        goto label_7;
label_12:
      while (true)
      {
        do
        {
          switch (num6)
          {
            case 0:
            case 1:
            case 3:
              goto label_7;
            case 4:
              continue;
            case 5:
              goto label_9;
            case 7:
              goto label_13;
            default:
              goto label_2;
          }
        }
        while (false);
        goto label_17;
label_2:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.\u0001);
        num6 = 7;
      }
label_9:
      num4 = 7;
      goto label_10;
label_15:
      num6 = num3;
      goto label_12;
    }
label_17:
    return obj0.Replace(obj1, obj2);
  }

  internal static string[] \u0001([In] string obj0, [In] char[] obj1, [In] int obj2, [In] int obj3)
  {
label_11:
    int num1 = obj3;
    if (true)
      goto label_12;
label_1:
    int num2;
    switch (num1)
    {
      case 0:
      case 5:
      case 6:
        if (true)
        {
          num2 = 3;
          if (true)
          {
            if (false)
              goto label_4;
            else
              goto label_10;
          }
          else
            goto label_5;
        }
        else
          goto case 7;
      case 2:
        num2 = 3;
        goto label_10;
      case 3:
        goto label_11;
      case 7:
        return obj0.Split(obj1);
      default:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.\u0001);
        break;
    }
label_3:
    num2 = 3;
    goto label_10;
label_4:
    int num3 = 2;
    goto label_13;
label_5:
    num3 = 7;
    goto label_13;
label_10:
    num1 = num2;
    goto label_1;
label_12:
    int num4 = obj2;
    switch (num1 ^ num4)
    {
      case 61:
        goto label_5;
      default:
        goto label_4;
    }
label_13:
    num2 = num3;
    if (false)
      goto label_3;
    else
      goto label_10;
  }

  internal static void \u0001([In] Thread obj0, [In] int obj1, [In] int obj2)
  {
label_0:
    int num1 = 2;
    while (true)
    {
      int num2 = num1;
      if (true)
      {
        switch (num2)
        {
          case 0:
          case 5:
            goto label_12;
          case 1:
          case 4:
            num1 = 2;
            continue;
          default:
            if (true)
            {
              int num3 = obj2;
              int num4 = obj1;
              int num5;
              int num6;
              while (true)
              {
                num5 = num3 ^ num4;
                num6 = 24;
                if (num6 == 0)
                {
                  num4 = num6;
                  num3 = num5;
                }
                else
                  break;
              }
              switch (num5 - num6)
              {
                case 0:
                  num2 = 0;
                  break;
                default:
                  num2 = 4;
                  break;
              }
            }
            else
              goto label_0;
            break;
        }
      }
      num1 = num2;
    }
label_12:
    obj0.Start();
  }

  private sealed class \u0001
  {
    private \u0001.\u0003.\u0002 \u0001;

    public \u0001()
    {
      this.\u0001.\u0001 = new Ⴈ.Ⴐ();
      this.\u0001.\u0002 = new Ⴈ.Ⴐ();
      this.\u0001.\u0001 = new \u0002[new IntPtr(16)];
      this.\u0001.\u0002 = new \u0002[new IntPtr(16)];
      this.\u0001.\u0001 = new \u0002(8);
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    public unsafe void \u0001([In] uint obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int num = 2;
      while (true)
      {
        do
        {
          switch (num)
          {
            case 0:
              goto label_9;
            case 1:
              goto label_7;
            case 3:
              goto label_3;
            case 4:
              goto label_6;
            case 5:
            case 6:
              goto label_14;
            case 7:
              goto label_4;
            case 8:
              goto label_5;
            default:
              if (true)
                continue;
              goto label_11;
          }
        }
        while (false);
        goto label_13;
label_3:
        num = 7;
        continue;
label_4:
        this.\u0001.\u0002[(IntPtr) *(uint*) voidPtr] = new \u0002(3);
label_5:
        num = 4;
        continue;
label_6:
        *(int*) voidPtr = (int) *(uint*) voidPtr + 1;
        num = 1;
        continue;
label_7:
        num = *(uint*) voidPtr < obj0 ? 5 : 0;
        continue;
label_9:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj0;
          this.\u0001.\u0001 = *(uint*) ((IntPtr) voidPtr + 4);
        }
label_11:
        if (false)
          goto label_6;
        else
          break;
label_13:
        *(int*) voidPtr = (int) this.\u0001.\u0001;
        num = 1;
        continue;
label_14:
        this.\u0001.\u0001[(IntPtr) *(uint*) voidPtr] = new \u0002(3);
        goto label_3;
      }
    }

    public void \u0001()
    {
label_0:
      int num1;
      if (true)
      {
        num1 = 2;
        goto label_14;
      }
label_3:
      num1 = 6;
label_14:
      uint index;
      int num2;
      while (true)
      {
        int num3;
        int num4;
        do
        {
          int num5;
          int num6;
          switch (num1)
          {
            case 0:
              this.\u0001.\u0002.\u0001();
              if (false)
                goto case 6;
              else
                goto label_13;
            case 1:
            case 4:
            case 5:
              goto label_4;
            case 3:
              num3 = (int) index;
              num4 = 1;
              if (num4 == 0)
              {
                num6 = num4;
                num5 = num3;
                break;
              }
              goto label_7;
            case 6:
              num5 = (int) index;
              num6 = (int) this.\u0001.\u0001;
              break;
            case 7:
              goto label_17;
            default:
              goto label_15;
          }
          num1 = (uint) num5 < (uint) num6 ? 7 : 0;
        }
        while (true);
        goto label_8;
label_4:
        if (true)
        {
          this.\u0001.\u0002[(IntPtr) index].\u0001();
          num1 = 3;
          continue;
        }
        goto label_0;
label_7:
        index = (uint) (num3 + num4);
label_8:
        int num7 = 6;
label_9:
        num1 = num7;
        continue;
label_15:
        this.\u0001.\u0001.\u0001();
        num2 = 0;
        if (num2 != 0)
        {
          num7 = num2;
          goto label_9;
        }
        else
          goto label_16;
label_17:
        this.\u0001.\u0001[(IntPtr) index].\u0001();
        goto label_4;
      }
label_13:
      this.\u0001.\u0001.\u0001();
      return;
label_16:
      index = (uint) num2;
      goto label_3;
    }

    public uint \u0001([In] \u0003.\u0003 obj0, [In] uint obj1)
    {
label_20:
      int num1 = (int) this.\u0001.\u0001.\u0001(obj0);
      if (false)
        goto label_7;
      else
        goto label_2;
label_1:
      // ISSUE: method reference
      RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.\u0001.\u0001);
      int num2 = 8;
      goto label_19;
label_2:
      int num3;
      if (true)
      {
        num2 = num1 != 0 ? 0 : 4;
        goto label_19;
      }
      else
      {
        num3 = num1;
        goto label_13;
      }
label_5:
      int num4;
      uint num5 = (uint) num4;
label_6:
      num1 = (int) this.\u0001.\u0002.\u0001(obj0);
label_7:
      if (num1 == 0)
        num4 = 2;
      else
        goto label_10;
label_9:
      num2 = num4;
      goto label_19;
label_10:
      num4 = 7;
      if (num4 == 0)
        goto label_15;
      else
        goto label_9;
label_13:
      num5 = (uint) num3;
      if (true)
        num4 = (int) num5 + (int) this.\u0001.\u0001.\u0001(obj0);
      else
        goto label_19;
label_15:
      if (true)
      {
        num5 = (uint) num4;
        if (true)
          num2 = 5;
        else
          goto label_1;
      }
      else
        goto label_5;
label_19:
      while (true)
      {
        switch (num2)
        {
          case 0:
            goto label_4;
          case 1:
          case 7:
            goto label_12;
          case 2:
          case 9:
            num5 += this.\u0001.\u0002[(IntPtr) obj1].\u0001(obj0);
            num2 = 5;
            continue;
          case 3:
            goto label_6;
          case 4:
            goto label_21;
          case 5:
            goto label_18;
          case 8:
            goto label_20;
          default:
            goto label_1;
        }
      }
label_4:
      num4 = 8;
      goto label_5;
label_12:
      num3 = (int) num5 + 8;
      goto label_13;
label_18:
      return num5;
label_21:
      return this.\u0001.\u0001[(IntPtr) obj1].\u0001(obj0);
    }

    static \u0001() => \u0004.\u0001.\u0001();
  }

  private sealed class Ⴐ
  {
    private \u0006.Ⴓ \u0001;

    public unsafe void \u0001([In] int obj0, [In] int obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(24);
      *(int*) ((IntPtr) voidPtr + 20) = 1;
      while (true)
      {
        do
        {
          switch (*(int*) ((IntPtr) voidPtr + 20))
          {
            case 0:
              goto label_2;
            case 2:
            case 4:
            case 5:
            case 6:
              goto label_19;
            case 3:
              goto label_17;
            default:
              if (this.\u0001.Ⴈ != null)
                continue;
              goto label_7;
          }
        }
        while (false);
        *(int*) ((IntPtr) voidPtr + 20) = 3;
        continue;
label_17:
        if (this.\u0001.Ⴅ == obj1)
        {
          *(int*) ((IntPtr) voidPtr + 20) = 4;
          continue;
        }
        goto label_7;
label_19:
        if (this.\u0001.Ⴃ == obj0)
          *(int*) ((IntPtr) voidPtr + 20) = 0;
        else
          goto label_7;
      }
label_2:
      return;
label_7:
      *(int*) ((IntPtr) voidPtr + 8) = obj0;
      this.\u0001.Ⴃ = *(int*) ((IntPtr) voidPtr + 8);
      *(int*) ((IntPtr) voidPtr + 12) = (1 << obj0) - 1;
      this.\u0001.Ⴍ = *(uint*) ((IntPtr) voidPtr + 12);
label_8:
      int num = 2;
      while (true)
      {
        switch (num)
        {
          case 0:
            goto label_4;
          case 1:
          case 4:
            *(int*) ((IntPtr) voidPtr + 4) = 0;
            num = 8;
            continue;
          case 2:
            *(int*) ((IntPtr) voidPtr + 16) = obj1;
            this.\u0001.Ⴅ = *(int*) ((IntPtr) voidPtr + 16);
            *(int*) voidPtr = 1 << this.\u0001.Ⴅ + this.\u0001.Ⴃ;
            num = 9;
            continue;
          case 3:
            goto label_8;
          case 5:
            this.\u0001.Ⴈ[(IntPtr) *(uint*) ((IntPtr) voidPtr + 4)].\u0001();
            *(int*) ((IntPtr) voidPtr + 4) = (int) *(uint*) ((IntPtr) voidPtr + 4) + 1;
            num = 8;
            continue;
          case 7:
            goto label_7;
          case 8:
            num = *(uint*) ((IntPtr) voidPtr + 4) < *(uint*) voidPtr ? 5 : 0;
            continue;
          case 9:
            this.\u0001.Ⴈ = new \u0005\u2000.Ⴐ.Ⴗ[(IntPtr) *(uint*) voidPtr];
            goto case 1;
          default:
            goto label_6;
        }
      }
label_4:
      return;
label_6:
      // ISSUE: method reference
      RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.Ⴐ.\u0001);
    }

    public unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int num = 7;
      while (true)
      {
        do
        {
          switch (num)
          {
            case 0:
            case 1:
              goto label_5;
            case 2:
              goto label_3;
            case 3:
              *(int*) ((IntPtr) voidPtr + 4) = 0;
              continue;
            case 4:
              goto label_4;
            case 5:
              goto label_2;
            case 6:
              goto label_1;
            default:
              *(int*) voidPtr = 1 << this.\u0001.Ⴅ + this.\u0001.Ⴃ;
              num = 3;
              continue;
          }
        }
        while (false);
        goto label_9;
label_4:
        this.\u0001.Ⴈ[(IntPtr) *(uint*) ((IntPtr) voidPtr + 4)].\u0002();
        *(int*) ((IntPtr) voidPtr + 4) = (int) *(uint*) ((IntPtr) voidPtr + 4) + 1;
        num = 1;
        continue;
label_5:
        num = *(uint*) ((IntPtr) voidPtr + 4) < *(uint*) voidPtr ? 4 : 6;
        continue;
label_9:
        num = 1;
      }
label_3:
      return;
label_2:
      return;
label_1:;
    }

    private uint \u0001([In] uint obj0, [In] byte obj1)
    {
      int num1 = (int) obj0 & (int) this.\u0001.Ⴍ;
      int num2 = this.\u0001.Ⴅ;
      int num3;
      int num4;
      while (true)
      {
        num3 = 31;
        if (num3 != 0)
        {
          num4 = num2 & num3;
          if (true)
          {
            int num5 = num1 << num4;
            num4 = (int) obj1;
            num1 = num5;
          }
          if (false)
            num2 = num4;
          else
            break;
        }
        else
          goto label_8;
      }
      num3 = 8 - this.\u0001.Ⴅ;
      num2 = num4;
label_8:
      int num6;
      while (true)
      {
        num6 = num3 & 31;
        if (false)
          num3 = num6;
        else
          break;
      }
      int num7 = num2 >> num6;
      return (uint) (num1 + num7);
    }

    public byte \u0001([In] \u0003.\u0003 obj0, [In] uint obj1, [In] byte obj2)
    {
      if (true)
        goto label_6;
label_4:
      int num1;
      do
      {
        switch (num1)
        {
          case 0:
          case 2:
            goto label_6;
          default:
            continue;
        }
      }
      while (false);
      // ISSUE: method reference
      RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.Ⴐ.\u0001);
      int num2 = 2;
label_5:
      num1 = num2;
      goto label_4;
label_6:
      num2 = (int) this.\u0001.Ⴈ[(IntPtr) this.\u0001(obj1, obj2)].\u0001(obj0);
      if (true)
        return (byte) num2;
      goto label_5;
    }

    public byte \u0001([In] \u0003.\u0003 obj0, [In] uint obj1, [In] byte obj2, [In] byte obj3)
    {
      if (false)
        goto label_9;
      else
        goto label_5;
label_1:
      int num1;
      switch (num1)
      {
        case 0:
        case 1:
        case 3:
          goto label_5;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.Ⴐ.\u0001);
          break;
      }
label_3:
      int num2 = 0;
      int num3;
      if (num2 == 0)
      {
        if (true)
        {
          num3 = num2;
          goto label_9;
        }
        else
          goto label_9;
      }
      else
        goto label_7;
label_5:
      if (true)
        num2 = (int) this.\u0001.Ⴈ[(IntPtr) this.\u0001(obj1, obj2)].\u0001(obj0, obj3);
      else
        goto label_3;
label_7:
      if (true)
        return (byte) num2;
      num1 = num2;
      goto label_1;
label_9:
      num1 = num3;
      goto label_1;
    }

    static Ⴐ() => \u0004.\u0001.\u0001();

    private struct Ⴗ
    {
      private \u0006.Ⴈ \u0001;

      public void \u0001()
      {
        if (true)
        {
          if (false)
            return;
          this.\u0001.Ⴍ = new Ⴈ.Ⴐ[768];
        }
        else
        {
          if (true)
          {
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.Ⴐ.Ⴗ.\u0001);
          }
          if (false)
            ;
        }
      }

      public void \u0002()
      {
        int num1;
        if (true)
        {
          num1 = 3;
          goto label_12;
        }
label_4:
        if (false)
          return;
        int num2 = 1;
        goto label_13;
label_12:
        num2 = num1;
label_13:
        int index;
        while (true)
        {
          int num3;
          switch (num2)
          {
            case 0:
              this.\u0001.Ⴍ[index].\u0001();
              goto case 2;
            case 1:
              num3 = index < 768 ? 0 : 5;
              break;
            case 2:
              num3 = index;
              if (true)
              {
                num1 = num3 + 1;
                if (true)
                {
                  index = num1;
                  num2 = 1;
                  continue;
                }
                goto label_3;
              }
              else
                break;
            case 4:
              goto label_4;
            case 5:
              goto label_9;
            case 6:
              goto label_7;
            default:
              goto label_2;
          }
          num2 = num3;
        }
label_9:
        return;
label_7:
        return;
label_2:
        num1 = 0;
label_3:
        if (num1 == 0)
        {
          index = num1;
          goto label_4;
        }
        else
          goto label_12;
      }

      public byte \u0001([In] \u0003.\u0003 obj0)
      {
        uint index;
        do
        {
label_3:
          index = 1U;
          int num1;
          if (true)
          {
            num1 = 1;
            goto label_12;
          }
          else
            goto label_13;
label_8:
          int num2;
          int num3;
          int num4 = (uint) num2 < (uint) num3 ? 1 : 6;
label_9:
          num1 = num4;
label_12:
          while (true)
          {
            switch (num1)
            {
              case 0:
              case 3:
                goto label_3;
              case 1:
              case 4:
                goto label_13;
              case 2:
              case 5:
                goto label_7;
              case 6:
                goto label_10;
              default:
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.Ⴐ.Ⴗ.\u0001);
                if (true)
                {
                  num1 = 3;
                  continue;
                }
                goto label_3;
            }
          }
label_7:
          int num5 = (int) index;
          num3 = 256;
          num2 = num5;
          goto label_8;
label_10:
          continue;
label_13:
          num2 = (int) index << 1;
          num3 = (int) this.\u0001.Ⴍ[(IntPtr) index].\u0001(obj0);
          if (true)
          {
            index = (uint) (num2 | num3);
            int num6 = 2;
            if (num6 != 0)
            {
              num1 = num6;
              goto label_12;
            }
            else
            {
              num4 = num6;
              goto label_9;
            }
          }
          else
            goto label_8;
        }
        while (false);
        return (byte) index;
      }

      public unsafe byte \u0001([In] \u0003.\u0003 obj0, [In] byte obj1)
      {
        void* voidPtr;
        if (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(12);
          if (false)
            goto label_14;
          else
            goto label_21;
        }
label_7:
        int num1 = 2;
        goto label_20;
label_14:
        int num2 = 10;
label_15:
        num1 = num2;
label_20:
        int num3;
        int num4;
        while (true)
        {
          do
          {
            num2 = num1;
            if (true)
            {
              switch (num2)
              {
                case 0:
                  goto label_11;
                case 1:
                  goto label_10;
                case 2:
                  *(int*) voidPtr = (int) *(uint*) voidPtr << 1 | (int) *(uint*) ((IntPtr) voidPtr + 8);
                  continue;
                case 3:
                case 9:
                  goto label_19;
                case 4:
                  goto label_21;
                case 5:
                case 12:
                  goto label_6;
                case 6:
                  goto label_18;
                case 7:
                case 13:
                  goto label_12;
                case 10:
                  goto label_17;
                case 11:
                  goto label_22;
                default:
                  goto label_3;
              }
            }
            else
              goto label_15;
          }
          while (false);
          goto label_9;
label_3:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0005\u2000.Ⴐ.Ⴗ.\u0001);
          num1 = 4;
          continue;
label_4:
          int num5 = num3 << num4;
          if (true)
          {
            obj1 = (byte) num5;
            num5 = 5;
          }
          num1 = num5;
          continue;
label_9:
          num1 = (int) *(uint*) ((IntPtr) voidPtr + 4) == (int) *(uint*) ((IntPtr) voidPtr + 8) ? 6 : 1;
          continue;
label_10:
          num1 = 13;
          continue;
label_11:
          *(int*) voidPtr = (int) *(uint*) voidPtr << 1 | (int) this.\u0001.Ⴍ[(IntPtr) *(uint*) voidPtr].\u0001(obj0);
          num1 = 13;
          continue;
label_12:
          num3 = (int) *(uint*) voidPtr;
          num4 = 256;
          if (num4 == 0)
            goto label_4;
          else
            goto label_13;
label_17:
          num1 = 3;
          continue;
label_18:
          num1 = *(uint*) voidPtr < 256U ? 11 : 3;
          continue;
label_22:
          *(int*) ((IntPtr) voidPtr + 4) = (int) obj1 >> 7 & 1;
          int num6 = (int) obj1;
          num4 = 1;
          num3 = num6;
          goto label_4;
        }
label_6:
        *(int*) ((IntPtr) voidPtr + 8) = (int) this.\u0001.Ⴍ[(IntPtr) ((uint) (1 + (int) *(uint*) ((IntPtr) voidPtr + 4) << 8) + *(uint*) voidPtr)].\u0001(obj0);
        goto label_7;
label_13:
        if ((uint) num3 < (uint) num4)
        {
          num2 = 0;
          goto label_15;
        }
        else
          goto label_14;
label_19:
        return (byte) *(uint*) voidPtr;
label_21:
        *(int*) voidPtr = 1;
        num1 = 11;
        goto label_20;
      }

      static Ⴗ() => \u0004.\u0001.\u0001();
    }
  }

  [StructLayout(LayoutKind.Auto)]
  internal struct ႳႰ
  {
    internal byte[] \u0001;
    internal uint \u0001;
    internal uint \u0002;
    internal uint \u0003;
    internal Stream \u0001;
  }
}
