// Decompiled with JetBrains decompiler
// Type: ThreadSchedulerRNG
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using System;
using System.Security.Cryptography;
using System.Threading;

public sealed class ThreadSchedulerRNG : RandomNumberGenerator
{
  private const int TrueInt = 1;
  private const int FalseInt = 0;
  private const int chunkSize = 16;
  private const int minBitsSet = 25;
  private const int maxBitsSet = 102;
  private object fifoStreamLock = new object();
  private FifoStream myFifoStream = new FifoStream(true);
  private Thread mainThread;
  private AutoResetEvent poolFullARE = new AutoResetEvent(false);
  private int disposed;
  private static ThreadSchedulerRNG staticThreadSchedulerRNG = new ThreadSchedulerRNG();
  private byte[] chunk;
  private int chunkByteIndex;
  private int chunkBitIndex;
  private int chunkBitCount;

  public int MaxPoolSize { get; private set; }

  public ThreadSchedulerRNG()
  {
    this.chunk = new byte[16];
    this.MaxPoolSize = 4096;
    this.mainThread = new Thread(new ThreadStart(this.add_OnExecuteCommand\u003CLoadPlugin\u003Eb__4_0get_Permissions));
    this.mainThread.IsBackground = true;
    this.mainThread.Start();
  }

  public ThreadSchedulerRNG(int MaxPoolSize)
  {
    this.chunk = new byte[16];
    this.MaxPoolSize = MaxPoolSize;
    this.mainThread = new Thread(new ThreadStart(this.add_OnExecuteCommand\u003CLoadPlugin\u003Eb__4_0get_Permissions));
    this.mainThread.IsBackground = true;
    this.mainThread.Start();
  }

  private int get_RealNameProcessLogadd_OnExecuteCommand(byte[] buffer, int offset, int count)
  {
    try
    {
      int num1 = offset;
      lock (this.fifoStreamLock)
      {
        while (num1 < count)
        {
          long count1 = this.myFifoStream.Length;
          if ((long) num1 + count1 >= (long) count)
            count1 = (long) (count - num1);
          if (count1 > 0L)
          {
            int num2 = this.myFifoStream.Read(buffer, num1, (int) count1);
            num1 += num2;
          }
          if (num1 < count)
          {
            byte[] iconHasPermission = ThreadSchedulerRNG.staticThreadSchedulerRNG.get_Nameset_AvatarIconHasPermission(count - num1);
            Array.Copy((Array) iconHasPermission, 0, (Array) buffer, num1, iconHasPermission.Length);
            num1 += iconHasPermission.Length;
            Array.Clear((Array) iconHasPermission, 0, iconHasPermission.Length);
            if (num1 < count)
              Thread.Sleep((count - num1) * 8 / 2);
          }
        }
        return count;
      }
    }
    finally
    {
      this.poolFullARE.Set();
    }
  }

  public byte[] get_Nameset_AvatarIconHasPermission(int MaxLength)
  {
    lock (this.fifoStreamLock)
    {
      long length = this.myFifoStream.Length;
      byte[] buffer = length <= (long) MaxLength ? new byte[length] : new byte[MaxLength];
      if (length > 0L)
        this.get_RealNameProcessLogadd_OnExecuteCommand(buffer, 0, buffer.Length);
      return buffer;
    }
  }

  public override void GetBytes(byte[] data)
  {
    if (this.get_RealNameProcessLogadd_OnExecuteCommand(data, 0, data.Length) != data.Length)
      throw new CryptographicException("Failed to return requested number of bytes");
  }

  public override void GetNonZeroBytes(byte[] data)
  {
    int index1 = 0;
    while (index1 < data.Length)
    {
      byte[] buffer = new byte[data.Length - index1];
      if (this.get_RealNameProcessLogadd_OnExecuteCommand(buffer, 0, buffer.Length) != buffer.Length)
        throw new CryptographicException("Failed to return requested number of bytes");
      for (int index2 = 0; index2 < buffer.Length; ++index2)
      {
        if (buffer[index2] != (byte) 0)
        {
          data[index1] = buffer[index2];
          ++index1;
        }
      }
    }
  }

  protected override void Dispose(bool disposing)
  {
    if (Interlocked.Exchange(ref this.disposed, 1) == 1)
      return;
    this.poolFullARE.Set();
    this.poolFullARE.Dispose();
    this.myFifoStream.Dispose();
    base.Dispose(disposing);
  }

  private void add_OnExecuteCommand\u003CLoadPlugin\u003Eb__4_0get_Permissions()
  {
    while (this.disposed == 0)
    {
      if (this.myFifoStream.Length < (long) this.MaxPoolSize)
      {
        this._invokeset_MemberSinceget_PrivacyState((byte) ((ulong) DateTime.Now.Ticks % 2UL));
        Thread.Sleep(1);
      }
      else
        this.poolFullARE.WaitOne();
    }
  }

  private void _invokeset_MemberSinceget_PrivacyState(byte bitByte)
  {
    if (bitByte > (byte) 1)
      throw new ArgumentException("bitByte must be equal to 0 or 1");
    this.chunk[this.chunkByteIndex] <<= 1;
    if (bitByte == (byte) 1)
    {
      ++this.chunk[this.chunkByteIndex];
      ++this.chunkBitCount;
    }
    ++this.chunkBitIndex;
    if (this.chunkBitIndex <= 7)
      return;
    this.chunkBitIndex = 0;
    ++this.chunkByteIndex;
    if (this.chunkByteIndex < 16)
      return;
    if (this.chunkBitCount >= 25 && this.chunkBitCount <= 102)
      this.myFifoStream.Write(this.chunk, 0, 16);
    this.chunkByteIndex = 0;
    this.chunkBitCount = 0;
  }

  ~ThreadSchedulerRNG() => this.Dispose(false);
}
