// Decompiled with JetBrains decompiler
// Type: AstroMath.Celestial
// Assembly: IUnionSemanticCodeGr, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 54936E77-57E9-4A01-8A40-CDD9C21A9B24
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4a11f3ee9b7abe32546655a9f702013b42b9f162a262dca3052e2761c20ed447.exe

using System;

namespace AstroMath
{
  public class Celestial
  {
    public const double FIRST_GREGORIAN_YEAR = 1583.0;
    public const double JULIAN_BIAS = 2200000.0;
    public const double SIDEREAL_A = 0.0657098;
    public const double PI = 3.1415926535897931;
    public const double TWOPI = 6.2831853071795862;
    public const double EPOCH2000 = 2451545.0;
    public const double EPOCHMJD = 2400000.5;
    public const double COSEPS = 0.91748;
    public const double SINEPS = 0.39778;
    public const double ARC = 206264.8062;

    public static double DateToJulian(DateTime civilDate)
    {
      double num = (double) civilDate.Hour + (double) civilDate.Minute / 60.0 + (double) civilDate.Second / 3600.0;
      return 367.0 * (double) civilDate.Year - (double) (int) (7.0 * (double) (civilDate.Year + (int) (((double) civilDate.Month + 9.0) / 12.0)) / 4.0) + (double) (275 * civilDate.Month / 9) + (double) civilDate.Day + 1721013.5 + num / 24.0 - 0.5 * (double) Math.Sign(100.0 * (double) civilDate.Year + (double) civilDate.Month - 190002.5) + 0.5;
    }

    public static double DateToMJD(DateTime civilDate)
    {
      int year = civilDate.Year;
      int month = civilDate.Month;
      int day = civilDate.Day;
      int num1 = (int) ((double) civilDate.Hour + (double) civilDate.Minute / 60.0 + (double) civilDate.Second / 3600.0);
      double num2 = (double) (10000 * year + 100 * month + day);
      if (month < 2)
      {
        month += 12;
        --year;
      }
      int num3 = num2 > 15821004.1 ? (int) ((double) year / 400.0) - (int) ((double) year / 100.0) + (int) ((double) year / 4.0) : (int) ((double) (year + 4716) / 4.0) - 2 - 1179;
      return (double) (365 * year - 679004) + (double) num3 + (double) (int) (30.6001 * (double) (month + 1)) + (double) day + (double) num1 / 24.0;
    }

    public static double DateToJ2kD(DateTime civilDate) => Celestial.JulianToJ2kD(Celestial.DateToJulian(civilDate));

    public static double DateToJ2kC(DateTime civilDate) => Celestial.DateToJ2kD(civilDate) / 36525.0;

    public static DateTime JulianToDate(double julianDays)
    {
      double num1 = (double) (int) (julianDays + 0.5);
      double num2;
      if (num1 < 2299161.0)
      {
        num2 = num1 + 1524.0;
      }
      else
      {
        int num3 = (int) ((num1 - 1867216.25) / 36524.25);
        num2 = num1 + (double) (num3 - (int) ((double) num3 / 4.0)) + 1525.0;
      }
      int num4 = (int) ((num2 - 122.1) / 365.25);
      double num5 = 365.0 * (double) num4 + (double) (int) ((double) num4 / 4.0);
      int num6 = (int) ((num2 - num5) / 30.6001);
      int day = (int) (num2 - num5 + 0.5) - (int) (30.6001 * (double) num6);
      int month = (int) ((double) num6 - 1.0 - 12.0 * (double) (int) ((double) num6 / 14.0));
      return new DateTime(num4 - 4715 - (int) ((7.0 + (double) month) / 10.0), month, day).AddHours(24.0 * (julianDays + 0.5 - num1));
    }

    public static double JulianToJ2kD(double julianDays) => julianDays - 2451545.0;

    public static double JulianToJ2KC(double julianDays) => (julianDays - 2451545.0) / 36525.0;

    public static double JulianToMJD(double julianDays) => julianDays - 2400000.5;

    public static DateTime J2kDToDate(double j2k)
    {
      double num1 = Celestial.J2kDToJulian(j2k);
      double num2 = (double) (int) (num1 + 0.5);
      double num3;
      if (num2 < 2299161.0)
      {
        num3 = num2 + 1524.0;
      }
      else
      {
        int num4 = (int) ((num2 - 1867216.25) / 36524.25);
        num3 = num2 + (double) (num4 - (int) ((double) num4 / 4.0)) + 1525.0;
      }
      int num5 = (int) ((num3 - 122.1) / 365.25);
      double num6 = 365.0 * (double) num5 + (double) (num5 / 4);
      int num7 = (int) ((num3 - num6) / 30.6001);
      int day = (int) (num3 - num6 + 0.5) - (int) (30.6001 * (double) num7);
      int month = (int) ((double) num7 - 1.0 - 12.0 * (double) (int) ((double) num7 / 14.0));
      DateTime dateTime = new DateTime(num5 - 4715 - (int) ((7.0 + (double) month) / 10.0), month, day);
      dateTime = dateTime.AddHours(24.0 * (num1 + 0.5 - num2));
      return dateTime;
    }

    public static double J2kDToJulian(double j2k) => 2451545.0 + j2k;

    public static DateTime J2kCToDate(double j2kc) => Celestial.JulianToDate(Celestial.J2kCToJulian(j2kc));

    public static double J2kCToJulian(double j2kc) => 2451545.0 + j2kc * 36525.0;

    public static DateTime MJDToDate(double mjd)
    {
      double num1 = mjd + 2400000.5;
      double num2 = (double) (int) (num1 + 0.5);
      double num3;
      if (num2 < 2299161.0)
      {
        num3 = num2 + 1524.0;
      }
      else
      {
        int num4 = (int) ((num2 - 1867216.25) / 36524.25);
        num3 = num2 + (double) (num4 - num4 / 4) + 1525.0;
      }
      int num5 = (int) ((num3 - 122.1) / 365.25);
      double num6 = 365.0 * (double) num5 + (double) (int) ((double) num5 / 4.0);
      int num7 = (int) ((num3 - num6) / 30.6001);
      int day = (int) (num3 - num6 + 0.5) - (int) (30.6001 * (double) num7);
      int month = num7 - 1 - 12 * (int) ((double) num7 / 14.0);
      return new DateTime(num5 - 4715 - (int) ((double) (7 + month) / 10.0), month, day).AddHours(24.0 * (num1 + 0.5 - num2));
    }

    public static double MJDToJulian(double mjd) => mjd + 2400000.5;

    public static double MJDToJ2kD(double mjd) => Celestial.JulianToJ2kD(mjd + 2400000.5);

    public static double J2kDToLMST(double j2k, double longR) => Celestial.GSTToLST(Celestial.DateUTCToGST(Celestial.J2kDToDate(j2k)), longR);

    public static double MJDtoLMST(double mjd, double longR)
    {
      double num1 = (double) (int) mjd;
      double num2 = (mjd - num1) * 24.0;
      double num3 = (num1 - 51544.5) / 36525.0;
      return 24.0 * Planar.Frac((6.697374558 + 1.0027379093 * num2 + (8640184.812866 + (0.093104 - 6.2E-06 * num3) * num3) * num3 / 360.0 - Transform.RadiansToHours(longR)) / 24.0);
    }

    public static double DateUTCToGST(DateTime utcDate) => Transform.DegreesToHours((280.6061837 + 360.98564736629 * Celestial.DateToJ2kD(utcDate)) % 360.0);

    public static double LSTToLocalTimeHours(double lst, double longitudeD)
    {
      double num1 = (double) (int) Celestial.DateToJulian(DateTime.UtcNow) + 0.5;
      double num2 = 6.656306 + 0.0657098242 * (num1 - 2445700.5);
      DateTime utcNow = DateTime.UtcNow;
      double hour = (double) utcNow.Hour;
      utcNow = DateTime.UtcNow;
      double num3 = (double) utcNow.Minute / 60.0;
      double num4 = 1.0027379093 * (hour + num3);
      double num5 = num2 + num4;
      double num6 = Planar.Frac((Transform.NormalizeHours(lst - longitudeD / 15.0) - 6.697374558 - 0.0657098242 * (num1 - 2445700.5)) / 1.0027379093) * 24.0;
      if (num6 < 0.0)
        num6 += 24.0;
      TimeSpan timeSpan = DateTime.Now - DateTime.UtcNow;
      return Transform.NormalizeHours(num6 + timeSpan.TotalHours);
    }

    public static double GSTToLST(double gst, double longitudeR) => gst + Transform.RadiansToHours(longitudeR);

    public static double LSTToGST(double lst, Celestial.LatLon location) => (lst + Transform.RadiansToHours(location.Lon) + 24.0) % 24.0;

    public static DateTime DayPlusHours(DateTime thisdate, double someHours) => new DateTime(thisdate.Year, thisdate.Month, thisdate.Day).AddHours(someHours);

    public static bool TimeInBetween(DateTime earliestTime, DateTime latestTime, DateTime thisTime) => earliestTime <= thisTime && thisTime <= latestTime;

    public static double IntervalOverlap(
      DateTime iDusk,
      DateTime iDawn,
      DateTime iRise,
      DateTime iSet)
    {
      DateTime dateTime1 = new DateTime(1, 1, 1, iDusk.Hour, iDusk.Minute, iDusk.Second);
      DateTime dateTime2 = new DateTime(1, 1, 1, iDawn.Hour, iDawn.Minute, iDawn.Second);
      DateTime dateTime3 = new DateTime(1, 1, 1, iRise.Hour, iRise.Minute, iRise.Second);
      DateTime dateTime4 = new DateTime(1, 1, 1, iSet.Hour, iSet.Minute, iSet.Second);
      DateTime dateTime5 = new DateTime(1, 1, 1, 23, 59, 59);
      DateTime dateTime6 = new DateTime(1, 1, 1, 0, 0, 0);
      double num1 = Transform.NormalizeHours(dateTime2 - dateTime1);
      Transform.NormalizeHours(dateTime4 - dateTime3);
      double num2;
      if (dateTime3 == dateTime4)
      {
        num2 = num1;
      }
      else
      {
        double num3;
        TimeSpan timeSpan1;
        if (dateTime3 < dateTime4)
        {
          if (dateTime3 < dateTime1)
          {
            if (dateTime4 < dateTime1)
            {
              num3 = 0.0;
            }
            else
            {
              timeSpan1 = dateTime4 - dateTime1;
              num3 = timeSpan1.TotalHours;
            }
          }
          else
          {
            timeSpan1 = dateTime4 - dateTime3;
            num3 = timeSpan1.TotalHours;
          }
        }
        else if (dateTime4 < dateTime1)
        {
          if (dateTime3 < dateTime1)
          {
            timeSpan1 = dateTime5 - dateTime1;
            num3 = timeSpan1.TotalHours;
          }
          else
          {
            timeSpan1 = dateTime5 - dateTime3;
            num3 = timeSpan1.TotalHours;
          }
        }
        else
        {
          TimeSpan timeSpan2 = dateTime4 - dateTime1;
          double totalHours1 = timeSpan2.TotalHours;
          timeSpan2 = dateTime5 - dateTime3;
          double totalHours2 = timeSpan2.TotalHours;
          num3 = totalHours1 + totalHours2;
        }
        if (dateTime3 < dateTime4)
        {
          if (dateTime3 < dateTime2)
          {
            if (dateTime4 < dateTime2)
            {
              double num4 = num3;
              timeSpan1 = dateTime4 - dateTime3;
              double totalHours = timeSpan1.TotalHours;
              num2 = num4 + totalHours;
            }
            else
            {
              double num5 = num3;
              timeSpan1 = dateTime2 - dateTime3;
              double totalHours = timeSpan1.TotalHours;
              num2 = num5 + totalHours;
            }
          }
          else
            num2 = num3 + 0.0;
        }
        else if (dateTime4 < dateTime2)
        {
          if (dateTime3 < dateTime2)
          {
            double num6 = num3;
            timeSpan1 = dateTime4 - dateTime6;
            double totalHours3 = timeSpan1.TotalHours;
            timeSpan1 = dateTime2 - dateTime3;
            double totalHours4 = timeSpan1.TotalHours;
            double num7 = totalHours3 + totalHours4;
            num2 = num6 + num7;
          }
          else
          {
            double num8 = num3;
            timeSpan1 = dateTime4 - dateTime6;
            double totalHours = timeSpan1.TotalHours;
            num2 = num8 + totalHours;
          }
        }
        else
        {
          double num9 = num3;
          timeSpan1 = dateTime2 - dateTime6;
          double totalHours = timeSpan1.TotalHours;
          num2 = num9 + totalHours;
        }
      }
      return num2;
    }

    public static int TimeMachine(
      DateTime u,
      DateTime d,
      DateTime r1,
      DateTime s1,
      DateTime r2,
      DateTime s2,
      DateTime r3,
      DateTime s3)
    {
      int num = 0;
      if (u < r1)
      {
        if (d < r1)
          num = 1;
        else if (r1 <= d && d <= s1)
          num = 2;
        else if (s1 <= d && d <= r2)
          num = 3;
        else if (r2 <= d && d <= s2)
          num = 4;
        else if (s2 <= d && d <= r3)
          num = 5;
        else if (r3 <= d && d <= s3)
          num = 6;
        else if (d > s3)
          num = 7;
      }
      else if (r1 <= u && u <= s1)
      {
        if (u <= d && d <= s1)
          num = 8;
        else if (s1 <= d && d <= r2)
          num = 9;
        else if (r2 <= d && d <= s2)
          num = 10;
        else if (s2 <= d && d <= r3)
          num = 11;
        else if (r3 <= d && d <= s3)
          num = 12;
        else if (d > s3)
          num = 13;
      }
      else if (s1 <= u && u <= r2)
      {
        if (u <= d && d <= r2)
          num = 14;
        else if (r2 <= d && d <= s2)
          num = 15;
        else if (s2 <= d && d <= r3)
          num = 16;
        else if (r3 <= d && d <= s3)
          num = 17;
        else if (d > s3)
          num = 18;
      }
      else if (r2 <= u && u <= s2)
      {
        if (u <= d && d <= s2)
          num = 19;
        else if (s2 <= d && d <= r3)
          num = 20;
        else if (r3 <= d && d <= s3)
          num = 21;
        else if (d > s3)
          num = 22;
      }
      else if (s2 <= u && u <= r3)
      {
        if (u <= d && d <= r3)
          num = 23;
        else if (r3 <= d && d <= s3)
          num = 24;
        else if (d > s3)
          num = 25;
      }
      else if (r3 <= u && u <= s3)
      {
        if (u <= d && d <= s3)
          num = 26;
        else if (d > s3)
          num = 27;
      }
      else if (s3 < u)
        num = 28;
      return num;
    }

    public static int LongestPeriod(TimeSpan a, TimeSpan b, TimeSpan c)
    {
      if (a >= b && a >= c)
        return 1;
      return b >= a && b >= c ? 2 : 3;
    }

    public static TimeSpan LongestInterval(TimeSpan i1, TimeSpan i2) => i1.TotalHours > i2.TotalHours ? i1 : i2;

    public static double HourAngleToRA(double ha, DateTime ut, double longitude) => (Celestial.GSTToLST(Celestial.DateUTCToGST(ut), longitude) - ha) % (2.0 * Math.PI);

    public static Celestial.RADec ComputePositionFromBearingAndRange(
      Celestial.RADec initialPosition,
      double bearingRadians,
      double rangeRadians)
    {
      Celestial.RADec fromBearingAndRange = new Celestial.RADec()
      {
        Dec = Math.Asin(Math.Sin(initialPosition.Dec) * Math.Cos(rangeRadians) + Math.Cos(initialPosition.Dec) * Math.Sin(rangeRadians) * Math.Cos(bearingRadians))
      };
      fromBearingAndRange.RA = initialPosition.RA + Math.Atan2(Math.Sin(bearingRadians) * Math.Sin(rangeRadians) * Math.Cos(initialPosition.Dec), Math.Cos(rangeRadians) - Math.Sin(initialPosition.Dec) * Math.Sin(fromBearingAndRange.Dec));
      return fromBearingAndRange;
    }

    public class RADec
    {
      private double dr_RA;
      private double dr_Dec;

      public RADec()
      {
        this.dr_RA = 0.0;
        this.dr_Dec = 0.0;
      }

      public RADec(double RA, double Dec)
      {
        this.dr_RA = Math.Abs(RA) % (2.0 * Math.PI);
        this.dr_Dec = Dec % Math.PI;
      }

      public double RA
      {
        get => this.dr_RA;
        set => this.dr_RA = Math.Abs(value) % (2.0 * Math.PI);
      }

      public double Dec
      {
        get => this.dr_Dec;
        set => this.dr_Dec = value % Math.PI;
      }

      public Celestial.AltAz MakeAltAz(double haR, Celestial.LatLon loc)
      {
        double alt = this.Altitude(haR, loc);
        double num = this.Azimuth(haR, loc);
        return Math.Sin(haR) < 0.0 ? new Celestial.AltAz(alt, num) : new Celestial.AltAz(alt, 2.0 * Math.PI - Math.Acos(num));
      }

      public double Altitude(double haR, Celestial.LatLon location) => Math.Asin(Math.Sin(this.dr_Dec) * Math.Sin(location.Lat) + Math.Cos(this.dr_Dec) * Math.Cos(location.Lat) * Math.Cos(haR));

      public double Azimuth(double haR, Celestial.LatLon loc)
      {
        double num1 = this.Altitude(haR, loc);
        double num2 = Math.Acos((Math.Sin(this.dr_Dec) - Math.Sin(num1) * Math.Sin(loc.Lat)) / (Math.Cos(num1) * Math.Cos(loc.Lat)));
        return Math.Sin(haR) < 0.0 ? num2 : 2.0 * Math.PI - num2;
      }

      public double HourAngle(DateTime utcdate, Celestial.LatLon location) => Transform.HoursToRadians(Celestial.GSTToLST(Celestial.DateUTCToGST(utcdate), location.Lon)) - this.dr_RA;

      public double HourAngle(double altitude, Celestial.LatLon location)
      {
        double d = (Math.Sin(altitude) - Math.Sin(this.dr_Dec) * Math.Sin(location.Lat)) / (Math.Cos(this.dr_Dec) * Math.Cos(location.Lat));
        if (d > 1.0)
          --d;
        if (d < 0.0)
          ++d;
        return Math.Acos(d);
      }

      public double TransitTime(DateTime UTCDate, Celestial.LatLon location)
      {
        double hours = Transform.RadiansToHours(this.HourAngle(UTCDate, location));
        DateTime dateTime = UTCDate.ToLocalTime() - TimeSpan.FromHours(hours);
        return (double) dateTime.Hour + (double) dateTime.Minute / 60.0;
      }
    }

    public class AltAz
    {
      private double r_alt;
      private double r_azm;

      public AltAz()
      {
        this.r_alt = 0.0;
        this.r_azm = 0.0;
      }

      public AltAz(double alt, double az)
      {
        this.r_alt = alt % Math.PI;
        this.r_azm = Math.Abs(az) % (2.0 * Math.PI);
      }

      public double Alt
      {
        get => this.r_alt;
        set => this.r_alt = value % Math.PI;
      }

      public double Azm
      {
        get => this.r_azm;
        set => this.r_azm = Math.Abs(value) % (2.0 * Math.PI);
      }

      public Celestial.RADec MakeRaDec(double haR, Celestial.LatLon loc) => new Celestial.RADec(this.RightAscension(haR, loc), this.Declination(haR, loc));

      public double RightAscension(double ha, Celestial.LatLon loc)
      {
        double num1 = Math.Cos(this.r_alt) * Math.Sin(loc.Lat) * Math.Cos(this.r_azm) + Math.Sin(this.r_alt) * Math.Cos(this.r_azm);
        double num2 = Math.Cos(this.r_alt) * Math.Sin(this.r_azm);
        double num3 = Math.Sin(this.r_alt) * Math.Sin(loc.Lat) * Math.Sin(loc.Lat) * Math.Cos(this.r_azm);
        return num1;
      }

      public double Declination(double ha, Celestial.LatLon loc)
      {
        double num1 = Math.Cos(this.r_alt) * Math.Sin(loc.Lat) * Math.Cos(this.r_azm) + Math.Sin(this.r_alt) * Math.Cos(this.r_azm);
        double num2 = Math.Cos(this.r_alt) * Math.Sin(this.r_azm);
        double num3 = Math.Sin(this.r_alt) * Math.Sin(loc.Lat) * Math.Sin(loc.Lat) * Math.Cos(this.r_azm);
        return num2;
      }
    }

    public class LatLon
    {
      private double r_lat;
      private double r_lat_deg;
      private string r_lat_dir;
      private double r_lon;
      private double r_lon_deg;
      private string r_lon_dir;

      public LatLon()
      {
        this.r_lat = 0.0;
        this.r_lat_deg = 0.0;
        this.r_lat_dir = "N";
        this.r_lon = 0.0;
        this.r_lon_deg = 0.0;
        this.r_lon_dir = "E";
      }

      public LatLon(double latitude, double longitude)
      {
        this.r_lat = latitude % Math.PI;
        this.r_lon = longitude % (2.0 * Math.PI);
        if (this.r_lat < 0.0)
        {
          this.r_lat_dir = "S";
          this.r_lat_deg = -(360.0 * this.r_lat / (2.0 * Math.PI));
        }
        else
        {
          this.r_lat_dir = "N";
          this.r_lat_deg = 360.0 * this.r_lat / (2.0 * Math.PI);
        }
        if (longitude >= Math.PI)
        {
          this.r_lon_dir = "E";
          this.r_lon_deg = Transform.RadiansToDegrees(Math.PI - this.r_lon);
        }
        else
        {
          this.r_lon_dir = "W";
          this.r_lon_deg = Transform.RadiansToDegrees(this.r_lon);
        }
      }

      public double Lat => this.r_lat;

      public double Lon => this.r_lon;

      public string GetLatitudeString() => this.r_lat_deg.ToString() + " " + this.r_lat_dir;

      public string GetLongitudeString() => this.r_lon_deg.ToString() + " " + this.r_lon_dir;
    }
  }
}
