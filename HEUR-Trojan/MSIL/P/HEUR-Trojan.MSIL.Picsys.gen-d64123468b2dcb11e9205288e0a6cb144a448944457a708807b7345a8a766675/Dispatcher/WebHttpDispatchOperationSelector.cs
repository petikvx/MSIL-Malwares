// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Dispatcher.WebHttpDispatchOperationSelector
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Net;
using System.Runtime.InteropServices;
using System.ServiceModel.Activation;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.ServiceModel.Diagnostics;

namespace System.ServiceModel.Dispatcher
{
  [ComVisible(false)]
  public class WebHttpDispatchOperationSelector : IDispatchOperationSelector
  {
    public const string HttpOperationSelectorUriMatchedPropertyName = "UriMatched";
    internal const string HttpOperationSelectorDataPropertyName = "HttpOperationSelectorData";
    public const string HttpOperationNamePropertyName = "HttpOperationName";
    internal const string redirectOperationName = "";
    internal const string RedirectPropertyName = "WebHttpRedirect";
    private string catchAllOperationName = "";
    private Dictionary<string, UriTemplateTable> methodSpecificTables;
    private UriTemplateTable wildcardTable;
    private Dictionary<string, UriTemplate> templates;
    private UriTemplateTable helpUriTable;

    public WebHttpDispatchOperationSelector(ServiceEndpoint endpoint)
    {
      if (endpoint == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (endpoint));
      if (endpoint.Address == (EndpointAddress) null)
      {
        // ISSUE: reference to a compiler-generated method
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.GetString(SR2.EndpointAddressCannotBeNull)));
      }
      Uri uri = endpoint.Address.Uri;
      this.methodSpecificTables = new Dictionary<string, UriTemplateTable>();
      this.templates = new Dictionary<string, UriTemplate>();
      WebHttpBehavior webHttpBehavior = endpoint.Behaviors.Find<WebHttpBehavior>();
      if (webHttpBehavior != null && webHttpBehavior.HelpEnabled)
        this.helpUriTable = new UriTemplateTable(endpoint.ListenUri, HelpPage.GetOperationTemplatePairs());
      Dictionary<WebHttpDispatchOperationSelector.WCFKey, string> dictionary = new Dictionary<WebHttpDispatchOperationSelector.WCFKey, string>();
      foreach (OperationDescription operation in (Collection<OperationDescription>) endpoint.Contract.Operations)
      {
        if (operation.Messages[0].Direction == MessageDirection.Input)
        {
          string webMethod = WebHttpBehavior.GetWebMethod(operation);
          string utStringOrDefault = UriTemplateClientFormatter.GetUTStringOrDefault(operation);
          if (UriTemplateHelpers.IsWildcardPath(utStringOrDefault) && webMethod == "*")
          {
            // ISSUE: reference to a compiler-generated method
            this.catchAllOperationName = !(this.catchAllOperationName != "") ? operation.Name : throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.GetString(SR2.MultipleOperationsInContractWithPathMethod, (object) endpoint.Contract.Name, (object) utStringOrDefault, (object) webMethod)));
          }
          UriTemplate uriTemplate = new UriTemplate(utStringOrDefault);
          WebHttpDispatchOperationSelector.WCFKey key = new WebHttpDispatchOperationSelector.WCFKey(uriTemplate, webMethod);
          if (dictionary.ContainsKey(key))
          {
            // ISSUE: reference to a compiler-generated method
            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.GetString(SR2.MultipleOperationsInContractWithPathMethod, (object) endpoint.Contract.Name, (object) utStringOrDefault, (object) webMethod)));
          }
          dictionary.Add(key, operation.Name);
          UriTemplateTable uriTemplateTable;
          if (!this.methodSpecificTables.TryGetValue(webMethod, out uriTemplateTable))
          {
            uriTemplateTable = new UriTemplateTable(uri);
            this.methodSpecificTables.Add(webMethod, uriTemplateTable);
          }
          uriTemplateTable.KeyValuePairs.Add(new KeyValuePair<UriTemplate, object>(uriTemplate, (object) operation.Name));
          this.templates.Add(operation.Name, uriTemplate);
        }
      }
      if (this.methodSpecificTables.Count == 0)
      {
        this.methodSpecificTables = (Dictionary<string, UriTemplateTable>) null;
      }
      else
      {
        foreach (UriTemplateTable uriTemplateTable in this.methodSpecificTables.Values)
          uriTemplateTable.MakeReadOnly(true);
        if (this.methodSpecificTables.TryGetValue("*", out this.wildcardTable))
          return;
        this.wildcardTable = (UriTemplateTable) null;
      }
    }

    protected WebHttpDispatchOperationSelector()
    {
    }

    public virtual UriTemplate GetUriTemplate(string operationName)
    {
      if (operationName == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (operationName));
      UriTemplate uriTemplate;
      return !this.templates.TryGetValue(operationName, out uriTemplate) ? (UriTemplate) null : uriTemplate;
    }

    public string SelectOperation(ref Message message)
    {
      bool uriMatched;
      string property = message != null ? this.SelectOperation(ref message, out uriMatched) : throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (message));
      message.Properties.Add("UriMatched", (object) uriMatched);
      if (property != null)
      {
        message.Properties.Add("HttpOperationName", (object) property);
        if (DiagnosticUtility.ShouldTraceInformation)
        {
          // ISSUE: reference to a compiler-generated method
          TraceUtility.TraceEvent(TraceEventType.Information, 983077, SR2.GetString(SR2.TraceCodeWebRequestMatchesOperation, (object) message.Headers.To, (object) property));
        }
      }
      return property;
    }

    protected virtual string SelectOperation(ref Message message, out bool uriMatched)
    {
      if (message == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (message));
      uriMatched = false;
      if (this.methodSpecificTables == null || !message.Properties.ContainsKey(HttpRequestMessageProperty.Name) || !(message.Properties[HttpRequestMessageProperty.Name] is HttpRequestMessageProperty property))
        return this.catchAllOperationName;
      string method = property.Method;
      Uri to = message.Headers.To;
      if (to == (Uri) null)
        return this.catchAllOperationName;
      if (this.helpUriTable != null)
      {
        UriTemplateMatch match = this.helpUriTable.MatchSingle(to);
        if (match != null)
        {
          uriMatched = true;
          this.AddUriTemplateMatch(match, property, message);
          if (method == "GET")
            return "HelpPageInvoke";
          message.Properties.Add("HttpOperationSelectorData", (object) new WebHttpDispatchOperationSelectorData()
          {
            AllowedMethods = new List<string>() { "GET" }
          });
          return this.catchAllOperationName;
        }
      }
      UriTemplateTable methodSpecificTable1;
      if (this.methodSpecificTables.TryGetValue(method, out methodSpecificTable1))
      {
        string operationName;
        uriMatched = this.CanUriMatch(methodSpecificTable1, to, property, message, out operationName);
        if (uriMatched)
          return operationName;
      }
      if (this.wildcardTable != null)
      {
        string operationName;
        uriMatched = this.CanUriMatch(this.wildcardTable, to, property, message, out operationName);
        if (uriMatched)
          return operationName;
      }
      if (this.ShouldRedirectToUriWithSlashAtTheEnd(methodSpecificTable1, message, to))
        return "";
      List<string> stringList = (List<string>) null;
      foreach (KeyValuePair<string, UriTemplateTable> methodSpecificTable2 in this.methodSpecificTables)
      {
        if (!(methodSpecificTable2.Key == method) && !(methodSpecificTable2.Key == "*") && methodSpecificTable2.Value.MatchSingle(to) != null)
        {
          if (stringList == null)
            stringList = new List<string>();
          if (!stringList.Contains(methodSpecificTable2.Key))
            stringList.Add(methodSpecificTable2.Key);
        }
      }
      if (stringList != null)
      {
        uriMatched = true;
        message.Properties.Add("HttpOperationSelectorData", (object) new WebHttpDispatchOperationSelectorData()
        {
          AllowedMethods = stringList
        });
      }
      return this.catchAllOperationName;
    }

    private bool CanUriMatch(
      UriTemplateTable methodSpecificTable,
      Uri to,
      HttpRequestMessageProperty prop,
      Message message,
      out string operationName)
    {
      operationName = (string) null;
      UriTemplateMatch match = methodSpecificTable.MatchSingle(to);
      if (match == null)
        return false;
      operationName = match.Data as string;
      this.AddUriTemplateMatch(match, prop, message);
      return true;
    }

    private void AddUriTemplateMatch(
      UriTemplateMatch match,
      HttpRequestMessageProperty requestProp,
      Message message)
    {
      match.SetBaseUri(match.BaseUri, requestProp);
      message.Properties.Add("UriTemplateMatchResults", (object) match);
    }

    private bool ShouldRedirectToUriWithSlashAtTheEnd(
      UriTemplateTable methodSpecificTable,
      Message message,
      Uri to)
    {
      UriBuilder uriBuilder = new UriBuilder(to);
      if (uriBuilder.Path.EndsWith("/", StringComparison.Ordinal))
        return false;
      uriBuilder.Path += "/";
      Uri uri = uriBuilder.Uri;
      bool withSlashAtTheEnd = false;
      if (methodSpecificTable != null && methodSpecificTable.MatchSingle(uri) != null)
      {
        withSlashAtTheEnd = true;
      }
      else
      {
        foreach (KeyValuePair<string, UriTemplateTable> methodSpecificTable1 in this.methodSpecificTables)
        {
          UriTemplateTable uriTemplateTable = methodSpecificTable1.Value;
          if (uriTemplateTable != methodSpecificTable && uriTemplateTable.MatchSingle(uri) != null)
          {
            withSlashAtTheEnd = true;
            break;
          }
        }
      }
      if (withSlashAtTheEnd)
      {
        string authority = WebHttpDispatchOperationSelector.GetAuthority(message);
        Uri property = UriTemplate.RewriteUri(uriBuilder.Uri, authority);
        message.Properties.Add("WebHttpRedirect", (object) property);
      }
      return withSlashAtTheEnd;
    }

    private static string GetAuthority(Message message)
    {
      string authority = (string) null;
      HttpRequestMessageProperty property;
      if (message.Properties.TryGetValue<HttpRequestMessageProperty>(HttpRequestMessageProperty.Name, out property))
      {
        authority = property.Headers[HttpRequestHeader.Host];
        if (!string.IsNullOrEmpty(authority))
          return authority;
      }
      IAspNetMessageProperty hostingProperty = AspNetEnvironment.Current.GetHostingProperty(message);
      if (hostingProperty != null)
        authority = hostingProperty.OriginalRequestUri.Authority;
      return authority;
    }

    private class WCFKey
    {
      private string method;
      private UriTemplate uriTemplate;

      public WCFKey(UriTemplate uriTemplate, string method)
      {
        this.uriTemplate = uriTemplate;
        this.method = method;
      }

      public override bool Equals(object obj) => obj is WebHttpDispatchOperationSelector.WCFKey wcfKey && this.uriTemplate.IsEquivalentTo(wcfKey.uriTemplate) && this.method == wcfKey.method;

      public override int GetHashCode() => UriTemplateEquivalenceComparer.Instance.GetHashCode(this.uriTemplate);
    }
  }
}
