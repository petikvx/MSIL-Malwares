// Decompiled with JetBrains decompiler
// Type: ProjNet.Adapter.WrapperConsumerAdapter
// Assembly: TYPELIBA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 97BB50BA-9882-4DFE-999C-7A4E4B448F1C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-080eff3ceefca287dc59d176676559ae1aa3f1faec807805114bae214a11f586.exe

using ProjNet.Roles;
using ProjNet.Rules;
using ProjNet.Shared;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TYPELIBA.Identifiers;
using TYPELIBA.Importers;

namespace ProjNet.Adapter
{
  internal class WrapperConsumerAdapter : MerchantEventRole
  {
    private double _PolicyProcess;
    private double refProcess;
    protected double m_RegProcess;
    protected double m_ConnectionProcess;
    private double _ParserProcess;
    private double _StatusProcess;
    private double bridgeProcess;
    private double m_ItemProcess;
    private double _DecoratorProcess;
    private double m_ContextProcess;
    private double m_ComparatorProcess;
    private double m_IdentifierProcess;
    private double m_ManagerProcess;
    private double m_IndexerProcess;
    protected double m_VisitorProcess;
    protected double _WriterProcess;
    protected double _ObserverProcess;
    protected double _TaskProcess;
    protected double _ReponseProcess;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public WrapperConsumerAdapter(List<Interceptor> value)
    {
      ManagerParamsID.NewExpression();
      // ISSUE: explicit constructor call
      this.\u002Ector(value, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public WrapperConsumerAdapter(List<Interceptor> value, bool isb)
    {
      ManagerParamsID.NewExpression();
      // ISSUE: explicit constructor call
      base.\u002Ector(value, isb);
      this.Name = "Krovak";
      this.ConnectConsumer("EPSG");
      this.CountConsumer(9819L);
      Interceptor interceptor1 = this.VisitConfiguration("latitude_of_center");
      Interceptor interceptor2 = this.VisitConfiguration("longitude_of_center");
      Interceptor interceptor3 = this.VisitConfiguration("azimuth");
      Interceptor interceptor4 = this.VisitConfiguration("pseudo_standard_parallel_1");
      Interceptor interceptor5 = this.VisitConfiguration("scale_factor");
      Interceptor interceptor6 = this.VisitConfiguration("false_easting");
      Interceptor interceptor7 = this.VisitConfiguration("false_northing");
      if (interceptor1 == null)
        throw new ArgumentException("Missing projection parameter 'latitude_of_center'");
      if (interceptor2 == null)
        throw new ArgumentException("Missing projection parameter 'longitude_of_center'");
      if (interceptor3 == null)
        throw new ArgumentException("Missing projection parameter 'azimuth'");
      if (interceptor4 == null)
        throw new ArgumentException("Missing projection parameter 'pseudo_standard_parallel_1'");
      if (interceptor6 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (interceptor7 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      this._WriterProcess = StateProcess.PopConsumer(interceptor1.LoginProcess());
      this.m_VisitorProcess = StateProcess.PopConsumer(149.0 / 6.0);
      this.m_RegProcess = StateProcess.PopConsumer(interceptor3.LoginProcess());
      this.m_ConnectionProcess = StateProcess.PopConsumer(interceptor4.LoginProcess());
      this._ObserverProcess = interceptor5.LoginProcess();
      this._PolicyProcess = interceptor6.LoginProcess() * this.m_ServerProcess;
      this.refProcess = interceptor7.LoginProcess() * this.m_ServerProcess;
      this._TaskProcess = 1.0 - this._AnnotationProcess * this._AnnotationProcess / (this.proxyProcess * this.proxyProcess);
      this._ReponseProcess = Math.Sqrt(this._TaskProcess);
      this._ParserProcess = Math.Sin(this.m_RegProcess);
      this._StatusProcess = Math.Cos(this.m_RegProcess);
      this.bridgeProcess = Math.Sin(this.m_ConnectionProcess);
      this.m_ItemProcess = Math.Tan(this.m_ConnectionProcess / 2.0 + Math.PI / 4.0);
      double num1 = Math.Sin(this._WriterProcess);
      double num2 = Math.Cos(this._WriterProcess);
      double num3 = num2 * num2;
      this._DecoratorProcess = Math.Sqrt(1.0 + this._TaskProcess * (num3 * num3) / (1.0 - this._TaskProcess));
      this.m_ContextProcess = this._DecoratorProcess * this._ReponseProcess / 2.0;
      double num4 = Math.Asin(num1 / this._DecoratorProcess);
      double num5 = this._ReponseProcess * num1;
      double num6 = Math.Pow((1.0 - num5) / (1.0 + num5), this._DecoratorProcess * this._ReponseProcess / 2.0);
      this.m_ComparatorProcess = Math.Pow(Math.Tan(this._WriterProcess / 2.0 + Math.PI / 4.0), this._DecoratorProcess) * num6 / Math.Tan(num4 / 2.0 + Math.PI / 4.0);
      this.m_IdentifierProcess = Math.Pow(1.0 / this.m_ComparatorProcess, -1.0 / this._DecoratorProcess);
      this.m_ManagerProcess = this._ObserverProcess * (Math.Sqrt(1.0 - this._TaskProcess) / (1.0 - this._TaskProcess * (num1 * num1))) / Math.Tan(this.m_ConnectionProcess);
      this.m_IndexerProcess = this.m_ManagerProcess * Math.Pow(this.m_ItemProcess, this.bridgeProcess);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] InvokeConfiguration(double[] def)
    {
      int num1 = 3;
      if (WrapperConsumerAdapter.CollectCreator())
        goto label_8;
label_1:
      double a;
      double num2 = this._ReponseProcess * Math.Sin(a);
      double num3 = Math.Pow((1.0 - num2) / (1.0 + num2), this.m_ContextProcess);
      if (WrapperConsumerAdapter.CollectCreator())
      {
        num1 = 0;
        goto label_8;
      }
label_2:
      double num4;
      double num5;
      double num6;
      double[] numArray = new double[2]
      {
        -(num4 * Math.Sin(num5)) * this.proxyProcess,
        num6
      };
      int num7 = 8;
label_7:
      num1 = num7;
label_8:
      double num8;
      double num9;
      double num10;
      while (true)
      {
        switch (num1)
        {
          case 0:
            num8 = 2.0 * (Math.Atan(Math.Pow(Math.Tan(a / 2.0 + Math.PI / 4.0), this._DecoratorProcess) / this.m_ComparatorProcess * num3) - Math.PI / 4.0);
            num9 = -num10 * this._DecoratorProcess;
            goto case 4;
          case 1:
          case 6:
            goto label_4;
          case 2:
          case 5:
            goto label_1;
          case 3:
            goto label_5;
          case 4:
            double num11 = Math.Cos(num8);
            double d = Math.Asin(this._StatusProcess * Math.Sin(num8) + this._ParserProcess * num11 * Math.Cos(num9));
            num5 = this.bridgeProcess * Math.Asin(num11 * Math.Sin(num9) / Math.Cos(d));
            num4 = this.m_IndexerProcess / Math.Pow(Math.Tan(d / 2.0 + Math.PI / 4.0), this.bridgeProcess);
            num6 = -(num4 * Math.Cos(num5)) * this.proxyProcess;
            if (!WrapperConsumerAdapter.ListCreator())
            {
              num1 = 7;
              continue;
            }
            goto label_4;
          case 7:
            goto label_2;
          case 8:
            goto label_11;
          default:
            if (WrapperConsumerAdapter.CollectCreator())
            {
              num1 = 4;
              continue;
            }
            goto label_11;
        }
      }
label_4:
      a = StateProcess.PopConsumer(def[1]);
      num7 = 5;
      goto label_7;
label_5:
      num10 = StateProcess.PopConsumer(def[0]) - this.m_VisitorProcess;
      num7 = 6;
      goto label_7;
label_11:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ReadConfiguration(double[] reference)
    {
      int num1 = 7;
      double[] numArray;
      while (true)
      {
        double num2;
        double d;
        double num3;
        double num4;
        double num5;
        double num6;
        double instance;
        double num7;
        double a;
        int num8;
        double num9;
        switch (num1)
        {
          case 0:
            num8 = 15;
            break;
          case 1:
            instance = 2.0 * (Math.Atan(num3 * Math.Pow((1.0 + num7) / (1.0 - num7), this._ReponseProcess / 2.0)) - Math.PI / 4.0);
            if (Math.Abs(a - instance) <= 1E-11 || --num8 < 0)
            {
              numArray = new double[2]
              {
                StateProcess.CheckConsumer(num6 + this.m_VisitorProcess),
                StateProcess.CheckConsumer(instance)
              };
              int num10 = 9;
              num1 = WrapperConsumerAdapter.ListCreator() ? num10 : num10;
              continue;
            }
            break;
          case 2:
            num9 = reference[1] / this.proxyProcess;
            if (!WrapperConsumerAdapter.ListCreator())
            {
              num1 = 6;
              continue;
            }
            goto case 4;
          case 3:
          case 8:
            num3 = this.m_IdentifierProcess * Math.Pow(Math.Tan(d / 2.0 + Math.PI / 4.0), 1.0 / this._DecoratorProcess);
            num6 = -Math.Asin(num4 * Math.Sin(num5) / Math.Cos(d)) / this._DecoratorProcess;
            instance = 0.0;
            goto case 0;
          case 4:
          case 5:
            num7 = this._ReponseProcess * Math.Sin(a);
            if (WrapperConsumerAdapter.CollectCreator())
            {
              num1 = 1;
              continue;
            }
            goto case 0;
          case 6:
            double num11 = Math.Sqrt(num2 * num2 + num9 * num9);
            num5 = Math.Atan2(-num2, -num9) / this.bridgeProcess;
            double num12 = 2.0 * (Math.Atan(Math.Pow(this.m_ManagerProcess / num11, 1.0 / this.bridgeProcess) * this.m_ItemProcess) - Math.PI / 4.0);
            num4 = Math.Cos(num12);
            d = Math.Asin(this._StatusProcess * Math.Sin(num12) - this._ParserProcess * num4 * Math.Cos(num5));
            num1 = 8;
            continue;
          case 7:
            num2 = reference[0] / this.proxyProcess;
            if (true)
            {
              num1 = 2;
              continue;
            }
            goto case 3;
          case 9:
            goto label_12;
          default:
            num1 = 0;
            continue;
        }
        a = instance;
        num1 = 4;
      }
label_12:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override RepositoryProcess CreateState()
    {
      int num = 4;
      if (true)
        goto label_2;
label_1:
      bool flag;
      if (!flag)
        goto label_6;
      else
        goto label_5;
label_2:
      while (true)
      {
        switch (num)
        {
          case 0:
          case 4:
            flag = this.tagProcess == null;
            num = 3;
            continue;
          case 1:
          case 3:
            goto label_1;
          case 2:
            goto label_5;
          case 5:
            goto label_7;
          default:
            if (WrapperConsumerAdapter.CollectCreator())
            {
              num = 2;
              continue;
            }
            goto case 0;
        }
      }
label_7:
      RepositoryProcess tagProcess;
      return tagProcess;
label_5:
      this.tagProcess = (StateProcess) new WrapperConsumerAdapter(this._IteratorProcess, !this._ReaderProcess);
label_6:
      tagProcess = (RepositoryProcess) this.tagProcess;
      num = 5;
      goto label_2;
    }

    internal static bool CollectCreator() => true;

    internal static bool ListCreator() => false;
  }
}
