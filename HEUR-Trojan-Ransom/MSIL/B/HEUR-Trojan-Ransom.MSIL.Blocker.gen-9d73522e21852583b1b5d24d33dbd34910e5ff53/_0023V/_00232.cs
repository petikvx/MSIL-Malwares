// Decompiled with JetBrains decompiler
// Type: #V.#2
// Assembly: XtremeLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FF5C2739-BB51-401B-85EA-0335ADE5C685
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-9d73522e21852583b1b5d24d33dbd34910e5ff53.exe

using \u0023tc;
using \u0023V;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace \u0023V
{
  internal sealed class \u00232
  {
    private static bool \u00230([In] Assembly obj0, [In] Assembly obj1)
    {
      byte[] publicKey1 = obj0.GetName().GetPublicKey();
      byte[] publicKey2 = obj1.GetName().GetPublicKey();
      if (publicKey2 == null != (publicKey1 == null))
        return false;
      if (publicKey2 != null)
      {
        for (int index = 0; index < publicKey2.Length; ++index)
        {
          if ((int) publicKey2[index] != (int) publicKey1[index])
            return false;
        }
      }
      return true;
    }

    public static byte[] \u00231([In] byte[] obj0)
    {
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u00232.\u00230(executingAssembly, callingAssembly))
        return (byte[]) null;
      \u00232.\u0023ec ec = new \u00232.\u0023ec(obj0);
      byte[] numArray1 = new byte[0];
      int num1 = ec.\u0023dc();
      if (num1 == 67324752)
      {
        short num2 = (short) ec.\u0023cc();
        int num3 = ec.\u0023cc();
        int num4 = ec.\u0023cc();
        if (num1 != 67324752 || num2 != (short) 20 || num3 != 0 || num4 != 8)
          throw new FormatException("Wrong Header Signature");
        ec.\u0023dc();
        ec.\u0023dc();
        ec.\u0023dc();
        int length = ec.\u0023dc();
        int count1 = ec.\u0023cc();
        int count2 = ec.\u0023cc();
        if (count1 > 0)
        {
          byte[] buffer = new byte[count1];
          ec.Read(buffer, 0, count1);
        }
        if (count2 > 0)
        {
          byte[] buffer = new byte[count2];
          ec.Read(buffer, 0, count2);
        }
        byte[] buffer1 = new byte[ec.Length - ec.Position];
        ec.Read(buffer1, 0, buffer1.Length);
        \u00232.\u0023lb lb = new \u00232.\u0023lb(buffer1);
        numArray1 = new byte[length];
        lb.\u0023kb(numArray1, 0, numArray1.Length);
      }
      else
      {
        int num5 = num1 >> 24;
        if (num1 - (num5 << 24) != 8223355)
          throw new FormatException("Unknown Header");
        if (num5 == 1)
        {
          int length1 = ec.\u0023dc();
          numArray1 = new byte[length1];
          int num6;
          for (int index = 0; index < length1; index += num6)
          {
            int length2 = ec.\u0023dc();
            num6 = ec.\u0023dc();
            byte[] buffer = new byte[length2];
            ec.Read(buffer, 0, buffer.Length);
            new \u00232.\u0023lb(buffer).\u0023kb(numArray1, index, num6);
          }
        }
        if (num5 == 2)
        {
          byte[] numArray2 = new byte[8]
          {
            (byte) 166,
            (byte) 17,
            (byte) 157,
            (byte) 41,
            (byte) 53,
            (byte) 170,
            (byte) 234,
            (byte) 252
          };
          byte[] numArray3 = new byte[8]
          {
            (byte) 28,
            (byte) 19,
            (byte) 181,
            (byte) 152,
            (byte) 127,
            (byte) 111,
            (byte) 72,
            (byte) 170
          };
          using (\u0023Z z = new \u0023Z())
          {
            using (ICryptoTransform cryptoTransform = z.\u0023Y(numArray2, numArray3, true))
              numArray1 = \u00232.\u00231(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
        if (num5 == 3)
        {
          byte[] numArray4 = new byte[16]
          {
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1,
            (byte) 1
          };
          byte[] numArray5 = new byte[16]
          {
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2,
            (byte) 2
          };
          using (\u0023U u = new \u0023U())
          {
            using (ICryptoTransform cryptoTransform = u.\u0023R(numArray4, numArray5, true))
              numArray1 = \u00232.\u00231(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
      }
      ec.Close();
      return numArray1;
    }

    internal sealed class \u0023lb
    {
      private static readonly int[] \u00233 = new int[29]
      {
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258
      };
      private static readonly int[] \u00234 = new int[29]
      {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
      };
      private static readonly int[] \u00235 = new int[30]
      {
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577
      };
      private static readonly int[] \u00236 = new int[30]
      {
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
      };
      private int \u00237;
      private int \u00238;
      private int \u00239;
      private int \u0023ab;
      private int \u0023bb;
      private bool \u0023cb;
      private \u00232.\u0023zb \u0023db;
      private \u00232.\u0023eb \u0023eb;
      private \u00232.\u00234b \u0023fb;
      private \u00232.\u0023Ob \u0023gb;
      private \u00232.\u0023Ob \u0023hb;

      public \u0023lb([In] byte[] obj0)
      {
        this.\u0023db = new \u00232.\u0023zb();
        this.\u0023eb = new \u00232.\u0023eb();
        this.\u00237 = 2;
        this.\u0023db.\u0023yb(obj0, 0, obj0.Length);
      }

      private bool \u0023ib()
      {
        int num1 = this.\u0023eb.\u0023Gb();
        if (true)
          goto label_25;
label_23:
        int num2;
        while (num2 >= 258)
        {
          switch (this.\u00237)
          {
            case 7:
              int num3;
              while (((num3 = this.\u0023gb.\u0023Nb(this.\u0023db)) & -256) == 0)
              {
                this.\u0023eb.\u0023Cb(num3);
                if (--num2 < 258)
                  return true;
              }
              if (num3 < 257)
              {
                if (num3 < 0)
                  return false;
                this.\u0023hb = (\u00232.\u0023Ob) null;
                this.\u0023gb = (\u00232.\u0023Ob) null;
                this.\u00237 = 2;
                return true;
              }
              this.\u00239 = \u00232.\u0023lb.\u00233[num3 - 257];
              this.\u00238 = \u00232.\u0023lb.\u00234[num3 - 257];
              goto case 8;
            case 8:
              if (this.\u00238 > 0)
              {
                this.\u00237 = 8;
                int num4 = this.\u0023db.\u0023rb(this.\u00238);
                if (num4 < 0)
                  return false;
                this.\u0023db.\u0023sb(this.\u00238);
                this.\u00239 += num4;
              }
              this.\u00237 = 9;
              goto case 9;
            case 9:
              int index = this.\u0023hb.\u0023Nb(this.\u0023db);
              if (index < 0)
                return false;
              this.\u0023ab = \u00232.\u0023lb.\u00235[index];
              this.\u00238 = \u00232.\u0023lb.\u00236[index];
              goto case 10;
            case 10:
              if (this.\u00238 > 0)
              {
                this.\u00237 = 10;
                int num5 = this.\u0023db.\u0023rb(this.\u00238);
                if (num5 < 0)
                  return false;
                this.\u0023db.\u0023sb(this.\u00238);
                this.\u0023ab += num5;
              }
              this.\u0023eb.\u0023Eb(this.\u00239, this.\u0023ab);
              num2 -= this.\u00239;
              this.\u00237 = 7;
              continue;
            default:
              continue;
          }
        }
        return true;
label_25:
        num2 = num1;
        goto label_23;
      }

      private bool \u0023jb()
      {
        switch (this.\u00237)
        {
          case 2:
            if (this.\u0023cb)
            {
              this.\u00237 = 12;
              return false;
            }
            int num = this.\u0023db.\u0023rb(3);
            if (num < 0)
              return false;
            this.\u0023db.\u0023sb(3);
            if ((num & 1) != 0)
              this.\u0023cb = true;
            switch (num >> 1)
            {
              case 0:
                this.\u0023db.\u0023vb();
                this.\u00237 = 3;
                break;
              case 1:
                this.\u0023gb = \u00232.\u0023Ob.\u0023Kb;
                this.\u0023hb = \u00232.\u0023Ob.\u0023Lb;
                this.\u00237 = 7;
                break;
              case 2:
                this.\u0023fb = new \u00232.\u00234b();
                this.\u00237 = 6;
                break;
            }
            return true;
          case 3:
            if ((this.\u0023bb = this.\u0023db.\u0023rb(16)) < 0)
              return false;
            this.\u0023db.\u0023sb(16);
            this.\u00237 = 4;
            goto case 4;
          case 4:
            if (this.\u0023db.\u0023rb(16) < 0)
              return false;
            this.\u0023db.\u0023sb(16);
            this.\u00237 = 5;
            goto case 5;
          case 5:
            this.\u0023bb -= this.\u0023eb.\u0023Fb(this.\u0023db, this.\u0023bb);
            if (this.\u0023bb != 0)
              return !this.\u0023db.\u0023wb();
            this.\u00237 = 2;
            return true;
          case 6:
            if (!this.\u0023fb.\u0023jb(this.\u0023db))
              return false;
            this.\u0023gb = this.\u0023fb.\u00232b();
            this.\u0023hb = this.\u0023fb.\u00233b();
            this.\u00237 = 7;
            goto case 7;
          case 7:
          case 8:
          case 9:
          case 10:
            return this.\u0023ib();
          case 12:
            return false;
          default:
            return false;
        }
      }

      public int \u0023kb([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        int num1 = 0;
        do
        {
          if (this.\u00237 != 11)
            goto label_5;
label_2:
          continue;
label_5:
          int num2 = this.\u0023eb.\u0023Ib(obj0, obj1, obj2);
          obj1 += num2;
          num1 += num2;
          obj2 -= num2;
          if (obj2 != 0)
            goto label_2;
          else
            goto label_1;
        }
        while (this.\u0023jb() || this.\u0023eb.\u0023Hb() > 0 && this.\u00237 != 11);
        goto label_3;
label_1:
        return num1;
label_3:
        return num1;
      }
    }

    internal sealed class \u0023zb
    {
      private byte[] \u0023mb;
      private int \u0023nb = 0;
      private int \u0023ob = 0;
      private uint \u0023pb = 0;
      private int \u0023qb = 0;

      public int \u0023rb([In] int obj0)
      {
        if (this.\u0023qb < obj0)
          goto label_4;
label_3:
        return (int) ((long) this.\u0023pb & (long) ((1 << obj0) - 1));
label_4:
        if (this.\u0023nb == this.\u0023ob)
          return -1;
        this.\u0023pb |= (uint) (((int) this.\u0023mb[this.\u0023nb++] & (int) byte.MaxValue | ((int) this.\u0023mb[this.\u0023nb++] & (int) byte.MaxValue) << 8) << this.\u0023qb);
        this.\u0023qb += 16;
        goto label_3;
      }

      public void \u0023sb([In] int obj0)
      {
        this.\u0023pb >>= obj0;
        this.\u0023qb -= obj0;
      }

      [SpecialName]
      public int \u0023tb() => this.\u0023qb;

      [SpecialName]
      public int \u0023ub() => this.\u0023ob - this.\u0023nb + (this.\u0023qb >> 3);

      public void \u0023vb()
      {
        this.\u0023pb >>= this.\u0023qb & 7;
        this.\u0023qb &= -8;
      }

      [SpecialName]
      public bool \u0023wb() => this.\u0023nb == this.\u0023ob;

      public int \u0023xb([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        int num1 = 0;
        while (this.\u0023qb > 0 && obj2 > 0)
        {
          obj0[obj1++] = (byte) this.\u0023pb;
          this.\u0023pb >>= 8;
          this.\u0023qb -= 8;
          --obj2;
          ++num1;
        }
        if (obj2 == 0)
          return num1;
        int num2 = this.\u0023ob - this.\u0023nb;
        if (obj2 > num2)
          obj2 = num2;
        Array.Copy((Array) this.\u0023mb, this.\u0023nb, (Array) obj0, obj1, obj2);
        this.\u0023nb += obj2;
        if ((this.\u0023nb - this.\u0023ob & 1) != 0)
        {
          this.\u0023pb = (uint) this.\u0023mb[this.\u0023nb++] & (uint) byte.MaxValue;
          this.\u0023qb = 8;
        }
        return num1 + obj2;
      }

      public void \u0023yb([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        if (this.\u0023nb < this.\u0023ob)
          throw new InvalidOperationException();
        int num = obj1 + obj2;
        if (0 > obj1 || obj1 > num || num > obj0.Length)
          throw new ArgumentOutOfRangeException();
        if ((obj2 & 1) != 0)
        {
          this.\u0023pb |= (uint) (((int) obj0[obj1++] & (int) byte.MaxValue) << this.\u0023qb);
          this.\u0023qb += 8;
        }
        this.\u0023mb = obj0;
        this.\u0023nb = obj1;
        this.\u0023ob = num;
      }
    }

    internal sealed class \u0023eb
    {
      private byte[] \u0023mb = new byte[32768];
      private int \u0023Ab = 0;
      private int \u0023Bb = 0;

      public void \u0023Cb([In] int obj0)
      {
        \u00232.\u0023eb eb = this;
        int bb;
        int num = bb = eb.\u0023Bb;
        eb.\u0023Bb = bb + 1;
        if (num == 32768)
          throw new InvalidOperationException();
        this.\u0023mb[this.\u0023Ab++] = (byte) obj0;
        this.\u0023Ab &= (int) short.MaxValue;
      }

      private void \u0023Db([In] int obj0, [In] int obj1, [In] int obj2)
      {
        while (obj1-- > 0)
        {
          byte[] mb = this.\u0023mb;
          \u00232.\u0023eb eb = this;
          int ab;
          int num1 = ab = eb.\u0023Ab;
          eb.\u0023Ab = ab + 1;
          int index = num1;
          int num2 = (int) this.\u0023mb[obj0++];
          mb[index] = (byte) num2;
          this.\u0023Ab &= (int) short.MaxValue;
          obj0 &= (int) short.MaxValue;
        }
      }

      public void \u0023Eb([In] int obj0, [In] int obj1)
      {
        if ((this.\u0023Bb += obj0) > 32768)
          throw new InvalidOperationException();
        int sourceIndex = this.\u0023Ab - obj1 & (int) short.MaxValue;
        int num = 32768 - obj0;
        if (sourceIndex <= num && this.\u0023Ab < num)
        {
          if (obj0 <= obj1)
          {
            Array.Copy((Array) this.\u0023mb, sourceIndex, (Array) this.\u0023mb, this.\u0023Ab, obj0);
            this.\u0023Ab += obj0;
          }
          else
          {
            while (obj0-- > 0)
              this.\u0023mb[this.\u0023Ab++] = this.\u0023mb[sourceIndex++];
          }
        }
        else
          this.\u0023Db(sourceIndex, obj0, obj1);
      }

      public int \u0023Fb([In] \u00232.\u0023zb obj0, [In] int obj1)
      {
        obj1 = Math.Min(Math.Min(obj1, 32768 - this.\u0023Bb), obj0.\u0023ub());
        int num1 = 32768 - this.\u0023Ab;
        int num2;
        if (obj1 > num1)
        {
          num2 = obj0.\u0023xb(this.\u0023mb, this.\u0023Ab, num1);
          if (num2 == num1)
            num2 += obj0.\u0023xb(this.\u0023mb, 0, obj1 - num1);
        }
        else
          num2 = obj0.\u0023xb(this.\u0023mb, this.\u0023Ab, obj1);
        this.\u0023Ab = this.\u0023Ab + num2 & (int) short.MaxValue;
        this.\u0023Bb += num2;
        return num2;
      }

      public int \u0023Gb() => 32768 - this.\u0023Bb;

      public int \u0023Hb() => this.\u0023Bb;

      public int \u0023Ib([In] byte[] obj0, [In] int obj1, [In] int obj2)
      {
        int num1 = this.\u0023Ab;
        if (obj2 > this.\u0023Bb)
          obj2 = this.\u0023Bb;
        else
          num1 = this.\u0023Ab - this.\u0023Bb + obj2 & (int) short.MaxValue;
        int num2 = obj2;
        int length = obj2 - num1;
        if (length > 0)
        {
          Array.Copy((Array) this.\u0023mb, 32768 - length, (Array) obj0, obj1, length);
          obj1 += length;
          obj2 = num1;
        }
        Array.Copy((Array) this.\u0023mb, num1 - obj2, (Array) obj0, obj1, obj2);
        this.\u0023Bb -= num2;
        if (this.\u0023Bb < 0)
          throw new InvalidOperationException();
        return num2;
      }
    }

    internal sealed class \u0023Ob
    {
      private short[] \u0023Jb;
      public static readonly \u00232.\u0023Ob \u0023Kb;
      public static readonly \u00232.\u0023Ob \u0023Lb;

      static \u0023Ob()
      {
        byte[] numArray1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          numArray1[num1++] = (byte) 8;
        while (num1 < 256)
          numArray1[num1++] = (byte) 9;
        while (num1 < 280)
          numArray1[num1++] = (byte) 7;
        while (num1 < 288)
          numArray1[num1++] = (byte) 8;
        \u00232.\u0023Ob.\u0023Kb = new \u00232.\u0023Ob(numArray1);
        byte[] numArray2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          numArray2[num2++] = (byte) 5;
        \u00232.\u0023Ob.\u0023Lb = new \u00232.\u0023Ob(numArray2);
      }

      public \u0023Ob([In] byte[] obj0) => this.\u0023Mb(obj0);

      private void \u0023Mb([In] byte[] obj0)
      {
        int[] numArray1 = new int[16];
        int[] numArray2 = new int[16];
        if (true)
          goto label_26;
label_4:
        int index1;
        for (; index1 < obj0.Length; ++index1)
        {
          int index2 = (int) obj0[index1];
          if (index2 > 0)
            ++numArray1[index2];
        }
        int num1 = 0;
        int length = 512;
        for (int index3 = 1; index3 <= 15; ++index3)
        {
          numArray2[index3] = num1;
          num1 += numArray1[index3] << 16 - index3;
          if (index3 >= 10)
          {
            int num2 = numArray2[index3] & 130944;
            int num3 = num1 & 130944;
            length += num3 - num2 >> 16 - index3;
          }
        }
        this.\u0023Jb = new short[length];
        int num4 = 512;
        for (int index4 = 15; index4 >= 10; --index4)
        {
          int num5 = num1 & 130944;
          num1 -= numArray1[index4] << 16 - index4;
          for (int index5 = num1 & 130944; index5 < num5; index5 += 128)
          {
            this.\u0023Jb[(int) \u00232.\u0023bc.\u0023ac(index5)] = (short) (-num4 << 4 | index4);
            num4 += 1 << index4 - 9;
          }
        }
        for (int index6 = 0; index6 < obj0.Length; ++index6)
        {
          int index7 = (int) obj0[index6];
          if (index7 != 0)
          {
            int num6 = numArray2[index7];
            int index8 = (int) \u00232.\u0023bc.\u0023ac(num6);
            if (index7 <= 9)
            {
              do
              {
                this.\u0023Jb[index8] = (short) (index6 << 4 | index7);
                index8 += 1 << index7;
              }
              while (index8 < 512);
            }
            else
            {
              int num7 = (int) this.\u0023Jb[index8 & 511];
              int num8 = 1 << (num7 & 15);
              int num9 = -(num7 >> 4);
              do
              {
                this.\u0023Jb[num9 | index8 >> 9] = (short) (index6 << 4 | index7);
                index8 += 1 << index7;
              }
              while (index8 < num8);
            }
            numArray2[index7] = num6 + (1 << 16 - index7);
          }
        }
        return;
label_26:
        index1 = 0;
        goto label_4;
      }

      public int \u0023Nb([In] \u00232.\u0023zb obj0)
      {
        int index;
        if ((index = obj0.\u0023rb(9)) < 0)
        {
          int num1 = obj0.\u0023tb();
          int num2 = (int) this.\u0023Jb[obj0.\u0023rb(num1)];
          if (num2 < 0 || (num2 & 15) > num1)
            return -1;
          obj0.\u0023sb(num2 & 15);
          return num2 >> 4;
        }
        int num3;
        if ((num3 = (int) this.\u0023Jb[index]) >= 0)
        {
          obj0.\u0023sb(num3 & 15);
          return num3 >> 4;
        }
        int num4 = -(num3 >> 4);
        int num5 = num3 & 15;
        int num6;
        if ((num6 = obj0.\u0023rb(num5)) >= 0)
        {
          int num7 = (int) this.\u0023Jb[num4 | num6 >> 9];
          obj0.\u0023sb(num7 & 15);
          return num7 >> 4;
        }
        int num8 = obj0.\u0023tb();
        int num9 = obj0.\u0023rb(num8);
        int num10 = (int) this.\u0023Jb[num4 | num9 >> 9];
        if ((num10 & 15) > num8)
          return -1;
        obj0.\u0023sb(num10 & 15);
        return num10 >> 4;
      }
    }

    internal sealed class \u00234b
    {
      private static readonly int[] \u0023Pb = new int[3]
      {
        3,
        3,
        11
      };
      private static readonly int[] \u0023Qb = new int[3]
      {
        2,
        3,
        7
      };
      private byte[] \u0023Rb;
      private byte[] \u0023Sb;
      private \u00232.\u0023Ob \u0023Tb;
      private int \u00237;
      private int \u0023Ub;
      private int \u0023Vb;
      private int \u0023Wb;
      private int \u0023Xb;
      private int \u0023Yb;
      private byte \u0023Zb;
      private int \u00230b;
      private static readonly int[] \u00231b;

      public bool \u0023jb([In] \u00232.\u0023zb obj0)
      {
        while (true)
        {
          switch (this.\u00237)
          {
            case 0:
              this.\u0023Ub = obj0.\u0023rb(5);
              if (this.\u0023Ub >= 0)
              {
                this.\u0023Ub += 257;
                obj0.\u0023sb(5);
                this.\u00237 = 1;
                goto case 1;
              }
              else
                goto label_2;
            case 1:
              this.\u0023Vb = obj0.\u0023rb(5);
              if (this.\u0023Vb >= 0)
              {
                ++this.\u0023Vb;
                obj0.\u0023sb(5);
                this.\u0023Xb = this.\u0023Ub + this.\u0023Vb;
                this.\u0023Sb = new byte[this.\u0023Xb];
                this.\u00237 = 2;
                goto case 2;
              }
              else
                goto label_5;
            case 2:
              this.\u0023Wb = obj0.\u0023rb(4);
              if (this.\u0023Wb >= 0)
              {
                this.\u0023Wb += 4;
                obj0.\u0023sb(4);
                this.\u0023Rb = new byte[19];
                this.\u00230b = 0;
                this.\u00237 = 3;
                goto case 3;
              }
              else
                goto label_8;
            case 3:
              for (; this.\u00230b < this.\u0023Wb; ++this.\u00230b)
              {
                int num = obj0.\u0023rb(3);
                if (num < 0)
                  return false;
                obj0.\u0023sb(3);
                this.\u0023Rb[\u00232.\u00234b.\u00231b[this.\u00230b]] = (byte) num;
              }
              this.\u0023Tb = new \u00232.\u0023Ob(this.\u0023Rb);
              this.\u0023Rb = (byte[]) null;
              this.\u00230b = 0;
              this.\u00237 = 4;
              goto case 4;
            case 4:
              int num1;
              while (((num1 = this.\u0023Tb.\u0023Nb(obj0)) & -16) == 0)
              {
                this.\u0023Sb[this.\u00230b++] = this.\u0023Zb = (byte) num1;
                if (this.\u00230b == this.\u0023Xb)
                  return true;
              }
              if (num1 >= 0)
              {
                if (num1 >= 17)
                  this.\u0023Zb = (byte) 0;
                this.\u0023Yb = num1 - 16;
                this.\u00237 = 5;
                goto case 5;
              }
              else
                goto label_19;
            case 5:
              int num2 = \u00232.\u00234b.\u0023Qb[this.\u0023Yb];
              int num3 = obj0.\u0023rb(num2);
              if (num3 >= 0)
              {
                obj0.\u0023sb(num2);
                int num4 = num3 + \u00232.\u00234b.\u0023Pb[this.\u0023Yb];
                while (num4-- > 0)
                  this.\u0023Sb[this.\u00230b++] = this.\u0023Zb;
                if (this.\u00230b != this.\u0023Xb)
                {
                  this.\u00237 = 4;
                  continue;
                }
                goto label_29;
              }
              else
                goto label_24;
            default:
              continue;
          }
        }
label_2:
        return false;
label_5:
        return false;
label_8:
        return false;
label_19:
        return false;
label_24:
        return false;
label_29:
        return true;
      }

      public \u00232.\u0023Ob \u00232b()
      {
        byte[] destinationArray = new byte[this.\u0023Ub];
        Array.Copy((Array) this.\u0023Sb, 0, (Array) destinationArray, 0, this.\u0023Ub);
        return new \u00232.\u0023Ob(destinationArray);
      }

      public \u00232.\u0023Ob \u00233b()
      {
        byte[] numArray = new byte[this.\u0023Vb];
        byte[] destinationArray;
        if (true)
          destinationArray = numArray;
        Array.Copy((Array) this.\u0023Sb, this.\u0023Ub, (Array) destinationArray, 0, this.\u0023Vb);
        return new \u00232.\u0023Ob(destinationArray);
      }

      static \u00234b()
      {
        int[] numArray = new int[19];
        // ISSUE: field reference
        RuntimeFieldHandle fldHandle = __fieldref (\u0023sc.\u0023pc);
        if (true)
          goto label_2;
label_1:
        \u00232.\u00234b.\u00231b = numArray;
        return;
label_2:
        RuntimeHelpers.InitializeArray((Array) numArray, fldHandle);
        goto label_1;
      }
    }

    internal sealed class \u0023bc
    {
      private static readonly int[] \u00231b = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };
      private static readonly byte[] \u00235b = new byte[16]
      {
        (byte) 0,
        (byte) 8,
        (byte) 4,
        (byte) 12,
        (byte) 2,
        (byte) 10,
        (byte) 6,
        (byte) 14,
        (byte) 1,
        (byte) 9,
        (byte) 5,
        (byte) 13,
        (byte) 3,
        (byte) 11,
        (byte) 7,
        (byte) 15
      };
      private static readonly short[] \u00236b = new short[286];
      private static readonly byte[] \u00237b = new byte[286];
      private static readonly short[] \u00238b;
      private static readonly byte[] \u00239b;

      public static short \u0023ac([In] int obj0) => (short) ((int) \u00232.\u0023bc.\u00235b[obj0 & 15] << 12 | (int) \u00232.\u0023bc.\u00235b[obj0 >> 4 & 15] << 8 | (int) \u00232.\u0023bc.\u00235b[obj0 >> 8 & 15] << 4 | (int) \u00232.\u0023bc.\u00235b[obj0 >> 12]);

      static \u0023bc()
      {
        if (true)
          goto label_13;
label_2:
        int index1;
        for (; index1 < 144; \u00232.\u0023bc.\u00237b[index1++] = (byte) 8)
          \u00232.\u0023bc.\u00236b[index1] = \u00232.\u0023bc.\u0023ac(48 + index1 << 8);
        for (; index1 < 256; \u00232.\u0023bc.\u00237b[index1++] = (byte) 9)
          \u00232.\u0023bc.\u00236b[index1] = \u00232.\u0023bc.\u0023ac(256 + index1 << 7);
        for (; index1 < 280; \u00232.\u0023bc.\u00237b[index1++] = (byte) 7)
          \u00232.\u0023bc.\u00236b[index1] = \u00232.\u0023bc.\u0023ac(index1 - 256 << 9);
        for (; index1 < 286; \u00232.\u0023bc.\u00237b[index1++] = (byte) 8)
          \u00232.\u0023bc.\u00236b[index1] = \u00232.\u0023bc.\u0023ac(index1 - 88 << 8);
        \u00232.\u0023bc.\u00238b = new short[30];
        \u00232.\u0023bc.\u00239b = new byte[30];
        for (int index2 = 0; index2 < 30; ++index2)
        {
          \u00232.\u0023bc.\u00238b[index2] = \u00232.\u0023bc.\u0023ac(index2 << 11);
          \u00232.\u0023bc.\u00239b[index2] = (byte) 5;
        }
        return;
label_13:
        index1 = 0;
        goto label_2;
      }
    }

    internal sealed class \u0023ec : MemoryStream
    {
      public int \u0023cc() => this.ReadByte() | this.ReadByte() << 8;

      public int \u0023dc() => this.\u0023cc() | this.\u0023cc() << 16;

      public \u0023ec([In] byte[] obj0)
        : base(obj0, false)
      {
      }
    }
  }
}
