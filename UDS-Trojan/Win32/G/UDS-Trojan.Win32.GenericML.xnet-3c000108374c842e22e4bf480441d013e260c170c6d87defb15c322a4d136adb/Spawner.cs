// Decompiled with JetBrains decompiler
// Type: MiniGames_Team9.Spawner
// Assembly: DependentHan, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A86A1B94-F21E-4DD9-9B87-E146CFB070D9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-3c000108374c842e22e4bf480441d013e260c170c6d87defb15c322a4d136adb.exe

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using System.Windows.Forms.Layout;

namespace MiniGames_Team9
{
  internal class Spawner
  {
    private PictureBox map;
    private Random rd = new Random();
    private Point portA = new Point(28, 52);
    private Point portB = new Point(378, 52);
    private Point portC = new Point(718, 52);
    private int level;
    private Direction direction;
    private Point vt;

    public Spawner()
    {
    }

    public Spawner(PictureBox map) => this.map = map;

    public void InitAttacker(Point vt, Direction direc, List<Attacker> attackerList)
    {
      Attacker att = (Attacker) new BroneAttacker(this.map, vt, direc);
      attackerList.Add(att);
      this.SetTransparent(att.Avatar);
      Animation animation = new Animation(this.map, (Figure) att);
      att.locked = true;
      animation.MakeSpawn(vt);
    }

    public void SpawnAttacker(List<Attacker> attackerList, int level, PictureBox MAP)
    {
      this.map = MAP;
      if (this.CheckPort(this.portA) || this.CheckPort(this.portB) || this.CheckPort(this.portC))
      {
        do
        {
          int num = this.rd.Next(0, 100);
          this.vt = num % 3 != 0 ? (num % 3 != 2 ? new Point(this.portC.X, this.portC.Y) : new Point(this.portB.X, this.portB.Y)) : new Point(this.portA.X, this.portA.Y);
        }
        while (!this.CheckPort(this.vt));
      }
      else
      {
        do
        {
          this.vt = new Point(this.rd.Next(70, 700), 50);
        }
        while (!this.CheckPort(this.vt));
      }
      this.level = level;
      switch (this.rd.Next(0, 3))
      {
        case 0:
          this.direction = Direction.left;
          break;
        case 1:
          this.direction = Direction.right;
          break;
        case 2:
          this.direction = Direction.down;
          break;
        default:
          this.direction = Direction.down;
          break;
      }
      int num1 = this.rd.Next(0, 100);
      Attacker att;
      int num2;
      switch (level)
      {
        case 1:
          att = num1 >= 80 ? (Attacker) new RedAttacker(this.map, this.vt, this.direction) : (Attacker) new BroneAttacker(this.map, this.vt, this.direction);
          goto label_13;
        case 2:
          num2 = 1;
          break;
        default:
          num2 = level == 3 ? 1 : 0;
          break;
      }
      att = num2 == 0 ? (level != 4 && level != 5 ? (Attacker) new DiamondAttacker(this.map, this.vt, this.direction) : (num1 >= 70 ? (Attacker) new DiamondAttacker(this.map, this.vt, this.direction) : (Attacker) new RedAttacker(this.map, this.vt, this.direction))) : (num1 >= 60 ? (num1 >= 90 ? (Attacker) new DiamondAttacker(this.map, this.vt, this.direction) : (Attacker) new RedAttacker(this.map, this.vt, this.direction)) : (Attacker) new BroneAttacker(this.map, this.vt, this.direction));
label_13:
      attackerList.Add(att);
      this.SetTransparent(att.Avatar);
      Animation animation = new Animation(this.map, (Figure) att);
      att.locked = true;
      animation.MakeSpawn(this.vt);
    }

    public void RemoveAttacker(List<Attacker> attacker, Attacker att)
    {
      att.skin.imleft.Dispose();
      att.skin.imright.Dispose();
      att.skin.imup.Dispose();
      att.skin.imdown.Dispose();
      att.skin.imleft = (Image) null;
      att.skin.imright = (Image) null;
      att.skin.imup = (Image) null;
      att.skin.imdown = (Image) null;
      attacker.Remove(att);
    }

    public void SetTransparent(PictureBox sender)
    {
      sender.BringToFront();
      sender.BackColor = Color.Transparent;
      sender.Parent = (Control) this.map;
    }

    public bool CheckPort(Point port)
    {
      PictureBox pictureBox = new PictureBox();
      pictureBox.Height = 40;
      pictureBox.Width = 40;
      pictureBox.Location = new Point(port.X, port.Y);
      foreach (Control control in (ArrangedElementCollection) this.map.Controls)
      {
        if (control is PictureBox && control.Bounds.IntersectsWith(pictureBox.Bounds))
          return false;
      }
      return true;
    }
  }
}
