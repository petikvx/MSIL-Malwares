// Decompiled with JetBrains decompiler
// Type: NChanges.AssemblyInfo
// Assembly: CryptoAPITransf, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3C6B9EE6-9C07-49E4-80B0-30EE0F446F3E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\HEUR-Trojan-Ransom.Win32.Convagent.gen-2c751eac7d8b2b4131c0622a8b5234b05661d29d6f5d49745e4bea13c6c01648.exe

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;

namespace NChanges
{
  public class AssemblyInfo
  {
    private readonly List<TypeInfo> _types = new List<TypeInfo>();

    public string Name { get; set; }

    public string Version { get; set; }

    public ICollection<TypeInfo> Types => (ICollection<TypeInfo>) this._types;

    public void ReadAssembly(Assembly assembly, string excludePattern = null)
    {
      this.Name = assembly.GetName().Name;
      this.Version = assembly.GetName().Version.ToString();
      Regex excludeRegex = (Regex) null;
      if (!string.IsNullOrEmpty(excludePattern))
        excludeRegex = new Regex(excludePattern);
      foreach (Type type in assembly.GetTypes())
      {
        if (type.IsPublic && this.TypeIsNotExcluded(type, excludeRegex))
        {
          TypeInfo typeInfo = new TypeInfo();
          typeInfo.ReadType(type);
          this._types.Add(typeInfo);
        }
      }
    }

    private bool TypeIsNotExcluded(Type type, Regex excludeRegex) => excludeRegex == null || !excludeRegex.IsMatch(type.FullName);

    public void WriteXml(XmlWriter xmlWriter)
    {
      xmlWriter.WriteStartElement("assembly");
      xmlWriter.WriteAttributeString("name", this.Name);
      xmlWriter.WriteAttributeString("version", this.Version);
      foreach (TypeInfo type in (IEnumerable<TypeInfo>) this.Types)
        type.WriteXml(xmlWriter);
      xmlWriter.WriteEndElement();
      xmlWriter.Flush();
    }

    public void ReadXml(XmlReader xmlReader)
    {
      while (xmlReader.ReadToFollowing("assembly"))
      {
        this.Name = xmlReader.GetAttribute("name");
        this.Version = xmlReader.GetAttribute("version");
        if (!xmlReader.IsEmptyElement)
        {
          XmlReader xmlReader1 = xmlReader.ReadSubtree();
          while (xmlReader1.Read())
          {
            if (xmlReader1.NodeType == XmlNodeType.Element && xmlReader1.Name == "type")
            {
              TypeInfo typeInfo = new TypeInfo();
              typeInfo.ReadXml(xmlReader);
              this.Types.Add(typeInfo);
            }
          }
        }
      }
    }

    public bool HasChanges()
    {
      foreach (TypeInfo type in (IEnumerable<TypeInfo>) this.Types)
      {
        if (type.Changes.Count > 0)
          return true;
        foreach (MemberInfo member in (IEnumerable<MemberInfo>) type.Members)
        {
          if (member.Changes.Count > 0)
            return true;
        }
      }
      return false;
    }
  }
}
