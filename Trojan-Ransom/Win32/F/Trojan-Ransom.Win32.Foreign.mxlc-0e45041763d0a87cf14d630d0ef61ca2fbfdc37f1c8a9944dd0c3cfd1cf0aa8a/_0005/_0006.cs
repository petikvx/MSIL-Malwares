// Decompiled with JetBrains decompiler
// Type: .
// Assembly: 1, Version=8.93.47.49, Culture=neutral, PublicKeyToken=null
// MVID: DFA8ED2E-5616-44FF-892B-A77949B35FF3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Foreign.mxlc-0e45041763d0a87cf14d630d0ef61ca2fbfdc37f1c8a9944dd0c3cfd1cf0aa8a.exe

using \u0002;
using \u0005;
using \u0006;
using \u000E;
using System;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;
using System.Windows.Forms;

namespace \u0005
{
  internal abstract class \u0006
  {
    private static readonly bool \u0001 = Convert.ToBoolean(\u0003.\u0001(55));
    internal static readonly string \u0001 = \u0003.\u0001(6758);
    internal static \u0005.\u0006 \u0001;
    private IWebProxy \u0001;
    private EventHandler \u0001;
    private \u0001.\u0001 \u0001;

    protected abstract void \u0001([In] \u0004.\u0002 obj0);

    protected abstract void \u0001([In] \u0003 obj0);

    protected abstract void \u0001([In] \u0005.\u0004 obj0);

    internal void \u0001([In] object obj0, [In] ThreadExceptionEventArgs obj1)
    {
      try
      {
        Exception exception;
        if (true)
          exception = obj1.Exception;
        System.Type type = exception.GetType();
        if (type.Name == \u0003.\u0001(8836) && type.Namespace == \u0003.\u0001(8861))
          exception = (Exception) type.GetField(\u0003.\u0001(8906)).GetValue((object) exception);
        if (exception is SecurityException && \u0005.\u0006.\u0001 == \u0003.\u0001(6758) && this.\u0001(exception as SecurityException))
          return;
        this.\u0001(exception, true, false);
      }
      catch
      {
      }
    }

    internal void \u0001([In] object obj0, [In] UnhandledExceptionEventArgs obj1)
    {
label_0:
      try
      {
        int num;
        if (obj1.ExceptionObject is SecurityException)
        {
          num = \u0005.\u0006.\u0001 == \u0003.\u0001(6758) ? 1 : 0;
          if (true)
          {
            if (num == 0)
              goto label_6;
          }
          else
            goto label_4;
        }
        else
          goto label_6;
label_3:
        if (true)
          num = this.\u0001(obj1.ExceptionObject as SecurityException) ? 1 : 0;
        else
          goto label_0;
label_4:
        if (num != 0)
          return;
label_6:
        if (true)
        {
          if (true)
          {
            if (!(obj1.ExceptionObject is Exception))
              return;
          }
          else
            goto label_3;
        }
        this.\u0001((Exception) obj1.ExceptionObject, !obj1.IsTerminating, false);
      }
      catch
      {
      }
    }

    protected virtual Guid \u0001() => Guid.Empty;

    internal bool \u0001([In] SecurityException obj0)
    {
      \u0005.\u0004 obj = new \u0005.\u0004(obj0);
      int num1;
      do
      {
        this.\u0001(obj);
        num1 = obj.\u0002 ? 1 : 0;
        if (true)
        {
          if (num1 != 0)
            goto label_4;
        }
        else
          goto label_5;
      }
      while (false);
      goto label_11;
label_5:
      return num1 != 0;
label_4:
      int num2 = 0;
      return num2 != 0 ? num2 != 0 : num2 != 0;
label_11:
      int num3 = obj.\u0001 ? 1 : 0;
      if (false)
        return num3 != 0;
      if (num3 == 0)
        goto label_12;
label_9:
      return true;
label_12:
      Application.Exit();
      goto label_9;
    }

    internal unsafe void \u0001([In] Exception obj0, [In] bool obj1, [In] bool obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      System.Type type = obj0.GetType();
      if (type.Name == \u0003.\u0001(8836) && type.Namespace == \u0003.\u0001(8861))
        obj0 = (Exception) type.GetField(\u0003.\u0001(8906)).GetValue((object) obj0);
      *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) 1;
      if (obj0 == null)
        return;
      if (obj0 is ThreadAbortException)
        return;
      try
      {
        \u0003 obj3 = new \u0003(this.\u0001(), obj0, this.\u0001);
        \u0007.\u0001((\u000E.\u0004) obj3, new \u0001.\u0001(this.\u0001));
        \u0007.\u0001(new EventHandler(this.\u0001), obj3);
        \u0007.\u0001(obj3, new \u0004.\u0001(this.\u0001));
        \u0004.\u0002 obj4 = new \u0004.\u0002(obj3, obj0);
        if (\u0007.\u0001() != null)
          obj4.\u0001 = true;
        if (!obj1)
        {
          obj4.\u0003 = false;
          obj4.\u0004 = false;
        }
        else if (obj2 || \u0005.\u0006.\u0001)
        {
          obj4.\u0003 = false;
          obj4.\u0004 = true;
        }
        this.\u0001(obj4);
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) !obj4.\u0004;
      }
      catch (ThreadAbortException ex)
      {
      }
      catch (Exception ex)
      {
        this.\u0001(new \u0003(ex));
      }
      if (*(sbyte*) ((IntPtr) voidPtr + 4) == (sbyte) 0)
        return;
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < assemblies.Length)
      {
        Assembly assembly = assemblies[*(int*) voidPtr];
        try
        {
          string fullName = assembly.FullName;
          if (fullName.EndsWith(\u0003.\u0001(8931)))
          {
            if (fullName.StartsWith(\u0003.\u0001(8956)))
            {
              object obj = assembly.GetType(\u0003.\u0001(8989)).GetProperty(\u0003.\u0001(9026)).GetGetMethod().Invoke((object) null, (object[]) null);
              obj.GetType().GetMethod(\u0003.\u0001(9039), new System.Type[0]).Invoke(obj, (object[]) null);
            }
          }
        }
        catch
        {
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      try
      {
        Application.Exit();
      }
      catch
      {
        try
        {
          Environment.Exit(0);
        }
        catch
        {
        }
      }
    }

    private void \u0001([In] object obj0, [In] \u0003 obj1) => this.\u0001(obj1);

    private void \u0001([In] object obj0, [In] EventArgs obj1)
    {
      EventHandler eventHandler = this.\u0001;
      if (eventHandler == null)
        return;
      eventHandler(obj0, obj1);
    }

    private void \u0001([In] object obj0, [In] \u0005.\u0005 obj1)
    {
      \u0001.\u0001 obj = this.\u0001;
      if (obj == null)
        return;
      obj(obj0, obj1);
    }
  }
}
