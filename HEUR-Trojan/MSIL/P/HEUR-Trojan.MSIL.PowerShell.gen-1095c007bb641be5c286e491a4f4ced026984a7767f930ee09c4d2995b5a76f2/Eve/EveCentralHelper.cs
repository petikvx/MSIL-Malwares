// Decompiled with JetBrains decompiler
// Type: HeavyDuck.Eve.EveCentralHelper
// Assembly: RemotingFieldCachedD, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EDD4CF72-357A-47DC-BB8E-50FC31FC092E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-1095c007bb641be5c286e491a4f4ced026984a7767f930ee09c4d2995b5a76f2.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;
using System.Xml.XPath;

namespace HeavyDuck.Eve
{
  public class EveCentralHelper : IPriceProvider
  {
    private const string EVECENTRAL_MARKETSTAT_URL = "http://api.eve-central.com/api/marketstat";
    private const string EVECENTRAL_MINERAL_URL = "http://api.eve-central.com/api/evemon";
    private const int MAX_TYPES_PER_QUERY = 100;
    private const int CACHE_VERSION = 2;
    private static readonly Dictionary<int, Dictionary<int, EveCentralHelper.MarketStat>> m_cache = new Dictionary<int, Dictionary<int, EveCentralHelper.MarketStat>>();
    private static readonly string m_cachePath = Path.Combine(Resources.CacheRoot, "eve-central");
    private static readonly string m_cacheFilePath = Path.Combine(EveCentralHelper.m_cachePath, "cache");
    private static readonly string m_cacheVersionPath = Path.Combine(EveCentralHelper.m_cachePath, "version");
    private static readonly TimeSpan m_cacheDuration = TimeSpan.FromHours(23.0);
    private static readonly TimeSpan m_rateLimit = TimeSpan.FromMilliseconds(100.0);
    private static readonly object m_rateLock = new object();
    private static readonly UTF8Encoding m_encoding = new UTF8Encoding(false);
    private static DateTime m_lastQuery = DateTime.MinValue;
    private static bool m_cacheDirty = false;
    public static readonly EveCentralHelper Instance = new EveCentralHelper();

    private EveCentralHelper()
    {
    }

    private static bool TryGetCachedMarketStat(
      int typeID,
      int regionID,
      out EveCentralHelper.MarketStat value)
    {
      lock (EveCentralHelper.m_cache)
      {
        Dictionary<int, EveCentralHelper.MarketStat> dictionary;
        if (EveCentralHelper.m_cache.TryGetValue(regionID, out dictionary) && dictionary.TryGetValue(typeID, out value) && DateTime.Now.Subtract(value.TimeStamp) < EveCentralHelper.m_cacheDuration)
          return true;
      }
      value = new EveCentralHelper.MarketStat();
      return false;
    }

    private static void CacheMarketStat(
      int typeID,
      int regionID,
      EveCentralHelper.MarketStat value)
    {
      lock (EveCentralHelper.m_cache)
      {
        Dictionary<int, EveCentralHelper.MarketStat> dictionary;
        if (!EveCentralHelper.m_cache.TryGetValue(regionID, out dictionary))
        {
          dictionary = new Dictionary<int, EveCentralHelper.MarketStat>();
          EveCentralHelper.m_cache[regionID] = dictionary;
        }
        dictionary[typeID] = value;
        EveCentralHelper.m_cacheDirty = true;
      }
    }

    private void OnUpdateProgress(int progress, int max)
    {
      EventHandler<ProgressEventArgs> updateProgress = this.UpdateProgress;
      if (updateProgress == null)
        return;
      updateProgress((object) this, new ProgressEventArgs(progress, max));
    }

    private Dictionary<int, Decimal> GetPriceHelper(
      IEnumerable<int> typeIDs,
      int regionID,
      PriceStat stat)
    {
      Dictionary<int, EveCentralHelper.MarketStat> dictionary = new Dictionary<int, EveCentralHelper.MarketStat>();
      List<int> intList = new List<int>();
      string path = (string) null;
      foreach (int typeId in typeIDs)
      {
        EveCentralHelper.MarketStat marketStat;
        if (EveCentralHelper.TryGetCachedMarketStat(typeId, regionID, out marketStat))
          dictionary[typeId] = marketStat;
        else
          intList.Add(typeId);
      }
      try
      {
        for (int index1 = 0; index1 * 100 < intList.Count; ++index1)
        {
          this.OnUpdateProgress(index1 * 100, intList.Count);
          lock (EveCentralHelper.m_rateLock)
          {
            TimeSpan ts = DateTime.Now.Subtract(EveCentralHelper.m_lastQuery);
            if (ts < EveCentralHelper.m_rateLimit)
              Thread.Sleep(EveCentralHelper.m_rateLimit.Subtract(ts));
            EveCentralHelper.m_lastQuery = DateTime.Now;
          }
          List<KeyValuePair<string, string>> parameters = new List<KeyValuePair<string, string>>();
          for (int index2 = index1 * 100; index2 < intList.Count && index2 < (index1 + 1) * 100; ++index2)
            parameters.Add(new KeyValuePair<string, string>("typeid", intList[index2].ToString()));
          if (regionID > 0)
            parameters.Add(new KeyValuePair<string, string>("regionlimit", regionID.ToString()));
          Dictionary<int, EveCentralHelper.MarketStat> marketStat;
          try
          {
            path = Resources.DownloadUrlPost("http://api.eve-central.com/api/marketstat", (IEnumerable<KeyValuePair<string, string>>) parameters);
            marketStat = EveCentralHelper.ParseMarketStat(path);
          }
          finally
          {
            if (path != null)
            {
              try
              {
                File.Delete(path);
              }
              catch
              {
              }
            }
          }
          foreach (KeyValuePair<int, EveCentralHelper.MarketStat> keyValuePair in marketStat)
          {
            EveCentralHelper.CacheMarketStat(keyValuePair.Key, regionID, keyValuePair.Value);
            dictionary[keyValuePair.Key] = keyValuePair.Value;
          }
        }
        this.OnUpdateProgress(intList.Count, intList.Count);
        Dictionary<int, Decimal> priceHelper = new Dictionary<int, Decimal>(dictionary.Count);
        foreach (KeyValuePair<int, EveCentralHelper.MarketStat> keyValuePair in dictionary)
        {
          Decimal num;
          switch (stat)
          {
            case PriceStat.Mean:
              num = keyValuePair.Value.All.Avg;
              break;
            case PriceStat.Median:
              num = keyValuePair.Value.All.Median;
              break;
            case PriceStat.High:
              num = keyValuePair.Value.All.Max;
              break;
            case PriceStat.Low:
              num = keyValuePair.Value.All.Min;
              break;
            default:
              throw new ArgumentException("Don't know how to process PriceStat " + stat.ToString());
          }
          priceHelper[keyValuePair.Key] = num;
        }
        return priceHelper;
      }
      catch (Exception ex)
      {
        throw new PriceProviderException(PriceProviderFailureReason.UnexpectedError, "Unexpected error while querying EVE-Central prices", ex);
      }
    }

    private static Dictionary<int, EveCentralHelper.MarketStat> ParseMarketStat(
      string path)
    {
      Dictionary<int, EveCentralHelper.MarketStat> marketStat = new Dictionary<int, EveCentralHelper.MarketStat>();
      DateTime now = DateTime.Now;
      using (FileStream fileStream = File.Open(path, FileMode.Open, FileAccess.Read))
      {
        XPathNodeIterator xpathNodeIterator = new XPathDocument((Stream) fileStream).CreateNavigator().Select("//marketstat/type");
        while (xpathNodeIterator.MoveNext())
        {
          try
          {
            int valueAsInt = xpathNodeIterator.Current.SelectSingleNode("@id").ValueAsInt;
            marketStat[valueAsInt] = new EveCentralHelper.MarketStat()
            {
              TimeStamp = now,
              All = EveCentralHelper.ParseMarketStatEntry(xpathNodeIterator.Current.SelectSingleNode("all")),
              Buy = EveCentralHelper.ParseMarketStatEntry(xpathNodeIterator.Current.SelectSingleNode("buy")),
              Sell = EveCentralHelper.ParseMarketStatEntry(xpathNodeIterator.Current.SelectSingleNode("sell"))
            };
          }
          catch (Exception ex)
          {
          }
        }
      }
      return marketStat;
    }

    private static EveCentralHelper.MarketStatEntry ParseMarketStatEntry(
      XPathNavigator root)
    {
      return new EveCentralHelper.MarketStatEntry()
      {
        Volume = Convert.ToInt64(root.SelectSingleNode("volume").Value, (IFormatProvider) CultureInfo.InvariantCulture),
        Avg = Convert.ToDecimal(root.SelectSingleNode("avg").Value, (IFormatProvider) CultureInfo.InvariantCulture),
        Max = Convert.ToDecimal(root.SelectSingleNode("max").Value, (IFormatProvider) CultureInfo.InvariantCulture),
        Min = Convert.ToDecimal(root.SelectSingleNode("min").Value, (IFormatProvider) CultureInfo.InvariantCulture),
        StdDev = Convert.ToDecimal(root.SelectSingleNode("stddev").Value, (IFormatProvider) CultureInfo.InvariantCulture),
        Median = Convert.ToDecimal(root.SelectSingleNode("median").Value, (IFormatProvider) CultureInfo.InvariantCulture)
      };
    }

    public event EventHandler<ProgressEventArgs> UpdateProgress;

    public void LoadCache()
    {
      BinaryFormatter binaryFormatter = new BinaryFormatter();
      try
      {
        int num;
        using (StreamReader streamReader = new StreamReader((Stream) File.OpenRead(EveCentralHelper.m_cacheVersionPath)))
          num = int.Parse(streamReader.ReadToEnd());
        if (num != 2)
          throw new ApplicationException("Invalid EveCentralHelper cache version");
      }
      catch (Exception ex)
      {
        try
        {
          Directory.Delete(EveCentralHelper.m_cachePath, true);
          return;
        }
        catch
        {
          return;
        }
      }
      lock (EveCentralHelper.m_cache)
      {
        try
        {
          Dictionary<int, Dictionary<int, EveCentralHelper.MarketStat>> dictionary1;
          using (FileStream serializationStream = File.OpenRead(EveCentralHelper.m_cacheFilePath))
            dictionary1 = (Dictionary<int, Dictionary<int, EveCentralHelper.MarketStat>>) binaryFormatter.Deserialize((Stream) serializationStream);
          foreach (KeyValuePair<int, Dictionary<int, EveCentralHelper.MarketStat>> keyValuePair1 in dictionary1)
          {
            Dictionary<int, EveCentralHelper.MarketStat> dictionary2;
            if (!EveCentralHelper.m_cache.TryGetValue(keyValuePair1.Key, out dictionary2))
            {
              dictionary2 = new Dictionary<int, EveCentralHelper.MarketStat>();
              EveCentralHelper.m_cache[keyValuePair1.Key] = dictionary2;
            }
            foreach (KeyValuePair<int, EveCentralHelper.MarketStat> keyValuePair2 in keyValuePair1.Value)
              dictionary2[keyValuePair2.Key] = keyValuePair2.Value;
          }
        }
        catch (Exception ex)
        {
        }
      }
    }

    public void SaveCache()
    {
      BinaryFormatter binaryFormatter = new BinaryFormatter();
      lock (EveCentralHelper.m_cache)
      {
        if (!EveCentralHelper.m_cacheDirty)
          return;
      }
      try
      {
        Directory.CreateDirectory(EveCentralHelper.m_cachePath);
        using (StreamWriter streamWriter = new StreamWriter((Stream) File.OpenWrite(EveCentralHelper.m_cacheVersionPath), (Encoding) EveCentralHelper.m_encoding))
          streamWriter.Write(2);
        lock (EveCentralHelper.m_cache)
        {
          using (FileStream serializationStream = File.OpenWrite(EveCentralHelper.m_cacheFilePath))
            binaryFormatter.Serialize((Stream) serializationStream, (object) EveCentralHelper.m_cache);
          EveCentralHelper.m_cacheDirty = false;
        }
      }
      catch
      {
        try
        {
          File.Delete(EveCentralHelper.m_cacheVersionPath);
        }
        catch
        {
        }
        throw;
      }
    }

    public Decimal GetPrice(int typeID, PriceStat stat) => this.GetPriceByRegion(typeID, -1, stat);

    public Decimal GetPriceHighSec(int typeID, PriceStat stat) => throw new NotImplementedException();

    public Decimal GetPriceByRegion(int typeID, int regionID, PriceStat stat)
    {
      Decimal priceByRegion;
      if (this.GetPriceHelper((IEnumerable<int>) new int[1]
      {
        typeID
      }, regionID, stat).TryGetValue(typeID, out priceByRegion))
        return priceByRegion;
      throw new PriceProviderException(PriceProviderFailureReason.PriceMissing, "Answer did not contain the requested price");
    }

    public Dictionary<int, Decimal> GetPrices(
      IEnumerable<int> typeIDs,
      PriceStat stat)
    {
      return this.GetPricesByRegion(typeIDs, -1, stat);
    }

    public Dictionary<int, Decimal> GetPricesHighSec(
      IEnumerable<int> typeIDs,
      PriceStat stat)
    {
      throw new NotImplementedException();
    }

    public Dictionary<int, Decimal> GetPricesByRegion(
      IEnumerable<int> typeIDs,
      int regionID,
      PriceStat stat)
    {
      Dictionary<int, Decimal> priceHelper = this.GetPriceHelper(typeIDs, regionID, stat);
      this.SaveCache();
      return priceHelper;
    }

    [Serializable]
    private class MarketStat
    {
      public DateTime TimeStamp;
      public EveCentralHelper.MarketStatEntry All;
      public EveCentralHelper.MarketStatEntry Buy;
      public EveCentralHelper.MarketStatEntry Sell;
    }

    [Serializable]
    private class MarketStatEntry
    {
      public long Volume;
      public Decimal Avg;
      public Decimal Max;
      public Decimal Min;
      public Decimal StdDev;
      public Decimal Median;
    }
  }
}
