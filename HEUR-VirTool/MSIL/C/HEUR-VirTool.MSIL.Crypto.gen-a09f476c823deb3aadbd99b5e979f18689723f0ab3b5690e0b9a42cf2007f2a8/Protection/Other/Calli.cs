// Decompiled with JetBrains decompiler
// Type: Aura.Protection.Other.Calli
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.Other
{
  internal class Calli
  {
    public static void Execute(ModuleDef module)
    {
      foreach (TypeDef typeDef in ((IEnumerable<TypeDef>) module.Types).ToArray<TypeDef>())
      {
        foreach (MethodDef methodDef in ((IEnumerable<MethodDef>) typeDef.Methods).ToArray<MethodDef>())
        {
          if (methodDef.HasBody && methodDef.Body.HasInstructions && !methodDef.FullName.Contains("My.") && !methodDef.FullName.Contains(".My") && !methodDef.FullName.Contains("Costura") && !methodDef.IsConstructor && !methodDef.DeclaringType.IsGlobalModuleType)
          {
            for (int index = 0; index < ((ICollection<Instruction>) methodDef.Body.Instructions).Count - 1; ++index)
            {
              try
              {
                if (!((object) methodDef.Body.Instructions[index]).ToString().Contains("ISupportInitialize"))
                {
                  if (methodDef.Body.Instructions[index].OpCode != OpCodes.Call && methodDef.Body.Instructions[index].OpCode != OpCodes.Callvirt)
                  {
                    if (methodDef.Body.Instructions[index].OpCode != OpCodes.Ldloc_S)
                      continue;
                  }
                  if (!((object) methodDef.Body.Instructions[index]).ToString().Contains("Object"))
                  {
                    if (methodDef.Body.Instructions[index].OpCode != OpCodes.Call && methodDef.Body.Instructions[index].OpCode != OpCodes.Callvirt)
                    {
                      if (methodDef.Body.Instructions[index].OpCode != OpCodes.Ldloc_S)
                        continue;
                    }
                    try
                    {
                      MemberRef operand = (MemberRef) methodDef.Body.Instructions[index].Operand;
                      methodDef.Body.Instructions[index].OpCode = OpCodes.Calli;
                      methodDef.Body.Instructions[index].Operand = (object) operand.MethodSig;
                      methodDef.Body.Instructions.Insert(index, Instruction.Create(OpCodes.Ldftn, operand));
                    }
                    catch (Exception ex)
                    {
                    }
                  }
                }
              }
              catch (Exception ex)
              {
              }
            }
          }
        }
        foreach (MethodDef method in (IEnumerable<MethodDef>) module.GlobalType.Methods)
        {
          if (!UTF8String.op_Inequality(method.Name, ".ctor"))
          {
            module.GlobalType.Remove(method);
            break;
          }
        }
      }
    }
  }
}
