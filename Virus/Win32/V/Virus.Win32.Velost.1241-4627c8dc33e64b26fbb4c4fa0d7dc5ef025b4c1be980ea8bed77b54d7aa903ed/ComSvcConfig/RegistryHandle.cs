// Decompiled with JetBrains decompiler
// Type: Microsoft.Tools.ServiceModel.ComSvcConfig.RegistryHandle
// Assembly: ComSvcConfig, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 502D58B8-8905-498F-84D2-67D5F99987D4
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00009-msil\Virus.Win32.Velost.1241-4627c8dc33e64b26fbb4c4fa0d7dc5ef025b4c1be980ea8bed77b54d7aa903ed.exe

using Microsoft.Win32.SafeHandles;
using System;
using System.Text;

namespace Microsoft.Tools.ServiceModel.ComSvcConfig
{
  internal class RegistryHandle : SafeHandleZeroOrMinusOneIsInvalid
  {
    internal static readonly RegistryHandle HKEY_CLASSES_ROOT = new RegistryHandle(new IntPtr(int.MinValue), false);
    internal static readonly RegistryHandle HKEY_CURRENT_USER = new RegistryHandle(new IntPtr(-2147483647), false);
    internal static readonly RegistryHandle HKEY_LOCAL_MACHINE = new RegistryHandle(new IntPtr(-2147483646), false);
    internal static readonly RegistryHandle HKEY_USERS = new RegistryHandle(new IntPtr(-2147483645), false);
    internal static readonly RegistryHandle HKEY_PERFORMANCE_DATA = new RegistryHandle(new IntPtr(-2147483644), false);
    internal static readonly RegistryHandle HKEY_CURRENT_CONFIG = new RegistryHandle(new IntPtr(-2147483643), false);
    internal static readonly RegistryHandle HKEY_DYN_DATA = new RegistryHandle(new IntPtr(-2147483642), false);

    private static RegistryHandle GetHKCR()
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, "Software\\Classes", 0, 131103, out hkResult) != 0 || hkResult == null || hkResult.IsInvalid)
        throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToOpenRegistryKey", (object) ""), (Exception) null);
      return hkResult;
    }

    private static RegistryHandle Get64bitHKCR()
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, "Software\\Classes", 0, 131359, out hkResult) != 0 || hkResult == null || hkResult.IsInvalid)
        throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToOpenRegistryKey", (object) ""), (Exception) null);
      return hkResult;
    }

    private static RegistryHandle Get32bitHKCR()
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, "Software\\Classes", 0, 131615, out hkResult) != 0 || hkResult == null || hkResult.IsInvalid)
        throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToOpenRegistryKey", (object) ""), (Exception) null);
      return hkResult;
    }

    private static RegistryHandle GetCorrectBitnessHive(bool is64bit)
    {
      if (is64bit && IntPtr.Size == 8)
        return RegistryHandle.GetHKCR();
      if (is64bit && IntPtr.Size == 4)
        return RegistryHandle.Get64bitHKCR();
      if (!is64bit && IntPtr.Size == 8)
        return RegistryHandle.Get32bitHKCR();
      if (!is64bit && IntPtr.Size == 4)
        return RegistryHandle.GetHKCR();
      throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("UnableToDetermineHiveBitness"), (Exception) null);
    }

    public static RegistryHandle GetBitnessHKCR(bool is64bit) => RegistryHandle.GetCorrectBitnessHive(is64bit);

    public static RegistryHandle GetCorrectBitnessHKLMSubkey(bool is64bit, string key)
    {
      if (is64bit && IntPtr.Size == 8)
        return RegistryHandle.GetHKLMSubkey(key);
      if (is64bit && IntPtr.Size == 4)
        return RegistryHandle.Get64bitHKLMSubkey(key);
      if (!is64bit && IntPtr.Size == 8)
        return RegistryHandle.Get32bitHKLMSubkey(key);
      if (!is64bit && IntPtr.Size == 4)
        return RegistryHandle.GetHKLMSubkey(key);
      throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("UnableToDetermineHiveBitness"), (Exception) null);
    }

    public static int TryGetCorrectBitnessHKLMSubkey(
      bool is64bit,
      string key,
      out RegistryHandle regHandle)
    {
      if (is64bit && IntPtr.Size == 8)
        return SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131103, out regHandle);
      if (is64bit && IntPtr.Size == 4)
        return SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131359, out regHandle);
      if (!is64bit && IntPtr.Size == 8)
        return SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131615, out regHandle);
      if (!is64bit && IntPtr.Size == 4)
        return SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131103, out regHandle);
      throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("UnableToDetermineHiveBitness"), (Exception) null);
    }

    private static RegistryHandle GetHKLMSubkey(string key)
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131103, out hkResult) != 0 || hkResult == null || hkResult.IsInvalid)
        throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToOpenRegistryKey", (object) ""), (Exception) null);
      return hkResult;
    }

    private static RegistryHandle Get64bitHKLMSubkey(string key)
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131359, out hkResult) != 0 || hkResult == null || hkResult.IsInvalid)
        throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToOpenRegistryKey", (object) ""), (Exception) null);
      return hkResult;
    }

    private static RegistryHandle Get32bitHKLMSubkey(string key)
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegOpenKeyEx(RegistryHandle.HKEY_LOCAL_MACHINE, key, 0, 131615, out hkResult) != 0 || hkResult == null || hkResult.IsInvalid)
        throw Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToOpenRegistryKey", (object) ""), (Exception) null);
      return hkResult;
    }

    public RegistryHandle(IntPtr hKey, bool ownHandle)
      : base(ownHandle)
    {
      this.handle = hKey;
    }

    public RegistryHandle()
      : base(true)
    {
    }

    public bool DeleteKey(string key) => SafeNativeMethods.RegDeleteKey(this, key) == 0;

    public RegistryHandle CreateSubKey(string subKey)
    {
      RegistryHandle hkResult = (RegistryHandle) null;
      if (SafeNativeMethods.RegCreateKeyEx(this, subKey, 0, (string) null, 0, 131103, IntPtr.Zero, out hkResult, out int _) != 0 || hkResult == null || hkResult.IsInvalid)
        Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToCreateSubKey", (object) subKey), (Exception) null);
      return hkResult;
    }

    public void SetValue(string valName, string value)
    {
      if (SafeNativeMethods.RegSetValueEx(this, valName, 0, 1, value, value.Length * 2 + 2) == 0)
        return;
      Tool.CreateException(Microsoft.Tools.ServiceModel.SR.GetString("FailedToSetValue", (object) valName), (Exception) null);
    }

    public string GetStringValue(string valName)
    {
      int lpType = 0;
      int lpcbData = 0;
      if (SafeNativeMethods.RegQueryValueEx(this, valName, (int[]) null, ref lpType, (byte[]) null, ref lpcbData) != 0 || lpType != 1)
        return (string) null;
      byte[] numArray = new byte[lpcbData];
      SafeNativeMethods.RegQueryValueEx(this, valName, (int[]) null, ref lpType, numArray, ref lpcbData);
      return new UnicodeEncoding().GetString(numArray);
    }

    protected override bool ReleaseHandle() => SafeNativeMethods.RegCloseKey(this.handle) == 0;
  }
}
