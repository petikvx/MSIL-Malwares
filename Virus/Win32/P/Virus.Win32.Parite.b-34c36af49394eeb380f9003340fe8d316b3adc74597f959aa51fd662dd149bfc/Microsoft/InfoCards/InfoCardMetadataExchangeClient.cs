// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.InfoCardMetadataExchangeClient
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: ADE0A079-11DB-4A46-8BDE-D2A592CA8DEA
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Parite.b-34c36af49394eeb380f9003340fe8d316b3adc74597f959aa51fd662dd149bfc.exe

using Microsoft.InfoCards.Diagnostics;
using System;
using System.Net;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;

namespace Microsoft.InfoCards
{
  internal class InfoCardMetadataExchangeClient : MetadataExchangeClient
  {
    private HttpWebRequest m_currentHttpGetRequest;
    private object m_abortSync;
    private bool m_aborted;
    private IWebProxy m_proxy;

    public static CustomBinding CreateBindingForMex()
    {
      HttpsTransportBindingElement transportBindingElement = new HttpsTransportBindingElement();
      InfoCardTrace.Assert(AuthenticationSchemes.Anonymous == transportBindingElement.AuthenticationScheme, "AuthenticationScheme must be Anonymous and not NTLM/Negotiate");
      return new CustomBinding(new BindingElement[2]
      {
        (BindingElement) new TextMessageEncodingBindingElement(),
        (BindingElement) transportBindingElement
      });
    }

    public InfoCardMetadataExchangeClient()
      : base((Binding) InfoCardMetadataExchangeClient.CreateBindingForMex())
    {
      this.m_abortSync = new object();
    }

    public IWebProxy Proxy
    {
      set => this.m_proxy = value;
    }

    public void Abort()
    {
      lock (this.m_abortSync)
      {
        if (this.m_currentHttpGetRequest != null)
          this.m_currentHttpGetRequest.Abort();
        else
          base.GetChannelFactory((EndpointAddress) null, (string) null, (string) null)?.Abort();
        this.m_aborted = true;
      }
    }

    protected internal override HttpWebRequest GetWebRequest(
      Uri location,
      string dialect,
      string identifier)
    {
      if (string.Compare(location.Scheme, "https", StringComparison.OrdinalIgnoreCase) != 0)
        throw InfoCardTrace.ThrowHelperError((Exception) new TrustExchangeException(SR.GetString("NonHttpsURIFound", (object) location.AbsoluteUri)));
      HttpWebRequest webRequest = base.GetWebRequest(location, dialect, identifier);
      InfoCardTrace.Assert(null == webRequest.Credentials, "No creds should be set");
      InfoCardTrace.Assert(null != this.m_proxy, "Set the proxy value before creating a WebRequest");
      webRequest.Proxy = this.m_proxy;
      lock (this.m_abortSync)
      {
        if (this.m_aborted)
          webRequest.Abort();
        return this.m_currentHttpGetRequest = webRequest;
      }
    }

    protected internal override ChannelFactory<IMetadataExchange> GetChannelFactory(
      EndpointAddress metadataAddress,
      string dialect,
      string identifier)
    {
      if ((EndpointAddress) null != metadataAddress && string.Compare(metadataAddress.Uri.Scheme, "https", StringComparison.OrdinalIgnoreCase) != 0)
        throw InfoCardTrace.ThrowHelperError((Exception) new TrustExchangeException(SR.GetString("NonHttpsURIFound", (object) metadataAddress.Uri.AbsoluteUri)));
      InfoCardTrace.Assert(null != this.m_proxy, "Set the proxy value before creating a WebRequest");
      ChannelFactory<IMetadataExchange> channelFactory = base.GetChannelFactory(metadataAddress, dialect, identifier);
      channelFactory.Endpoint.Binding = (Binding) new CustomBinding(Utility.UpdateProxyForHttpAndRestrictTransportBinding(channelFactory.Endpoint.Binding.CreateBindingElements(), this.m_proxy, true));
      lock (this.m_abortSync)
      {
        if (this.m_aborted)
          channelFactory.Abort();
      }
      return channelFactory;
    }
  }
}
