// Decompiled with JetBrains decompiler
// Type: Microsoft.Build.Shared.TypeLoader
// Assembly: MSBuild, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: E42BAB90-704E-4C03-B5C0-D4E3A6B884E3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Nimnul.c-d5c6463b93131b3c485115414cf5809e01323986e3d4274a4868222cbb54aa43.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;

namespace Microsoft.Build.Shared
{
  internal class TypeLoader
  {
    private Dictionary<AssemblyLoadInfo, List<Type>> cacheOfAllDesiredTypesInAnAssembly = new Dictionary<AssemblyLoadInfo, List<Type>>();
    private TypeFilter isDesiredType;

    internal TypeLoader(TypeFilter isDesiredType)
    {
      ErrorUtilities.VerifyThrow(isDesiredType != null, "need a type filter");
      this.isDesiredType = isDesiredType;
    }

    internal LoadedType Load(string typeName, AssemblyLoadInfo assembly)
    {
      Type type1 = (Type) null;
      List<Type> typeList = (List<Type>) null;
      this.cacheOfAllDesiredTypesInAnAssembly.TryGetValue(assembly, out typeList);
      if (assembly.AssemblyName != null && typeName.Length > 0)
      {
        if (typeList == null)
        {
          try
          {
            type1 = Type.GetType(typeName + "," + assembly.AssemblyName, false, true);
          }
          catch (ArgumentException ex)
          {
          }
        }
      }
      if ((object) type1 != null)
      {
        if (!this.isDesiredType(type1, (object) null))
          return (LoadedType) null;
      }
      else
      {
        if (typeList == null)
        {
          Assembly assembly1;
          try
          {
            assembly1 = assembly.AssemblyName == null ? Assembly.LoadFrom(assembly.AssemblyFile) : Assembly.Load(assembly.AssemblyName);
          }
          catch (ArgumentException ex)
          {
            throw new FileNotFoundException((string) null, assembly.ToString(), (Exception) ex);
          }
          Type[] exportedTypes = assembly1.GetExportedTypes();
          typeList = new List<Type>();
          foreach (Type m in exportedTypes)
          {
            if (this.isDesiredType(m, (object) null))
              typeList.Add(m);
          }
          this.cacheOfAllDesiredTypesInAnAssembly[assembly] = typeList;
        }
        foreach (Type type2 in typeList)
        {
          if (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(type2.FullName, typeName))
          {
            type1 = type2;
            break;
          }
        }
      }
      return (object) type1 != null ? new LoadedType(type1, assembly) : (LoadedType) null;
    }

    internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
    {
      bool flag = false;
      if (typeName1.Length != typeName2.Length)
      {
        string str1;
        string str2;
        if (typeName1.Length > typeName2.Length)
        {
          str1 = typeName1;
          str2 = typeName2;
        }
        else
        {
          str1 = typeName2;
          str2 = typeName1;
        }
        if (str1.EndsWith(str2, StringComparison.OrdinalIgnoreCase))
        {
          int num1 = str1.Length - str2.Length;
          if (str1[num1 - 1] == '.' || str1[num1 - 1] == '+')
          {
            int num2 = 0;
            for (int index = num1 - 2; index >= 0 && str1[index] == '\\'; --index)
              ++num2;
            if (num2 % 2 == 0)
              flag = true;
          }
        }
      }
      else
        flag = string.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0;
      return flag;
    }
  }
}
