// Decompiled with JetBrains decompiler
// Type: mmxAH.MonsterIndivid
// Assembly: PermissionTokenFact, Version=1.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: 0E8B010F-DA1B-42FA-9C31-C1DCAF557A03
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcqm-2f77bf5e4f961cc5be052ad8dc7fd08c90151230df1a0324df453d4e1d3a2056.exe

using System;
using System.Collections.Generic;
using System.IO;

namespace mmxAH
{
  public class MonsterIndivid : Card
  {
    private short locnum = -1;
    private GameEngine en;
    public bool isEncountred = false;
    private Func RPAfterEncounter;
    private MonsterPrototype prot;
    private byte itemModif;
    private bool isFirstEvade;

    public MonsterIndivid(GameEngine eng, MonsterPrototype pr, short pID)
    {
      this.en = eng;
      this.prot = pr;
      this.ID = pID;
    }

    public void AddToMap(short StartLocathion)
    {
      this.locnum = StartLocathion;
      this.en.ActiveMonsters.Add(this);
      ((ArchemArea) this.en.locs[(int) StartLocathion]).AddMonster(this);
      this.isEncountred = false;
    }

    public void Discard(bool isPrint = false)
    {
      if (isPrint)
      {
        this.en.io.PrintToLog(this.prot.GetTitle(), isBold: true, isItalic: true);
        this.en.io.PrintToLog("  " + this.en.sysstr.GetString(SSType.From) + "  ");
        if (this.locnum == (short) 0)
          this.en.io.PrintToLog(this.en.sysstr.GetString(SSType.Scy), isItalic: true);
        else
          this.en.io.PrintToLog(this.en.locs[(int) this.locnum].GetMoveToTitle(), isItalic: true);
        this.en.io.PrintToLog("  " + this.en.sysstr.GetString(SSType.ReturnToTheCup) + Environment.NewLine);
      }
      if (this.locnum != (short) -1)
      {
        if (this.locnum == (short) 0)
          this.en.Scy.Remove(this);
        else
          ((ArchemArea) this.en.locs[(int) this.locnum]).RemoveMonster(this);
        this.en.ActiveMonsters.Remove(this);
        this.en.status.RemoveMonsterInArchem();
      }
      this.locnum = (short) -1;
      this.en.MonstersCup.Add(this);
    }

    public void SetRPAfterEncounter(Func f) => this.RPAfterEncounter = f;

    public void SetLocathion(short newLoc)
    {
      if (this.locnum == (short) 0)
        this.en.Scy.Remove(this);
      else
        ((ArchemArea) this.en.locs[(int) this.locnum]).RemoveMonster(this);
      this.locnum = newLoc;
      if (newLoc == (short) 0)
        this.en.Scy.Add(this);
      else
        ((ArchemArea) this.en.locs[(int) this.locnum]).AddMonster(this);
      this.en.io.PrintToLog(this.prot.GetTitle(), isBold: true);
      this.en.io.PrintToLog("  " + this.en.sysstr.GetString(SSType.MoveToFact) + "  ");
      if (this.locnum == (short) 0)
        this.en.io.PrintToLog("  " + this.en.sysstr.GetString(SSType.Scy) + " ." + Environment.NewLine, isItalic: true);
      else
        this.en.io.PrintToLog(this.en.locs[(int) newLoc].GetMoveToTitle() + " ." + Environment.NewLine, isItalic: true);
    }

    public void BeginEncounter()
    {
      this.isEncountred = true;
      this.en.curs.curFight = this;
      this.isFirstEvade = false;
      this.en.io.SetFormMode(FormMode.Log);
      this.en.io.PrintToLog("===" + this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].GetTitle() + "  " + this.en.sysstr.GetString(SSType.MonsterEncounterVerb) + "  " + this.prot.GetTitle() + " ===" + Environment.NewLine, isBold: true);
      this.prot.Print();
      this.en.io.YesNoStart(this.en.sysstr.GetString(SSType.EvadeOrFight1) + "  " + this.prot.GetEvadeTitle() + " " + this.en.sysstr.GetString(SSType.EvadeOrFight2) + " " + this.prot.GetFightTitle(), this.en.sysstr.GetString(SSType.EvadeButton), this.en.sysstr.GetString(SSType.FightButton), new Func(this.EvadeCheck), new Func(this.HorrorCheck));
    }

    private void EvadeCheck()
    {
      this.isFirstEvade = true;
      this.en.io.PrintToLog(Environment.NewLine);
      SkillTest skillTest = new SkillTest(this.en, SkillTestType.Evade, this.prot.GetEvadeModif(), new FuncWithParam(this.AfterEvadeCheck), isSecondType: true, type2: SkillTestType.Sneak);
    }

    private void AfterEvadeCheck(short suc)
    {
      if (suc > (short) 0)
        this.EndEncounter();
      else
        this.prot.DoDemage(new Func(this.HorrorCheck), this);
    }

    private void HorrorCheck()
    {
      this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].isCanMove = false;
      this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].MovementPoints = (byte) 0;
      this.en.io.PrintToLog(Environment.NewLine);
      if (this.prot.GetIsHorror())
      {
        SkillTest skillTest = new SkillTest(this.en, SkillTestType.Horror, this.prot.GetHorrorModif(), new FuncWithParam(this.AfterHorrorCheck), isSecondType: true, type2: SkillTestType.Will);
      }
      else if (this.isFirstEvade)
        this.FleeOrFight();
      else
        this.CombatCheck();
    }

    private void AfterHorrorCheck(short suc)
    {
      this.en.io.SetFormMode(FormMode.Log);
      if (suc == (short) 0)
      {
        EffSanityLose effSanityLose = new EffSanityLose(this.en);
        effSanityLose.ChangeDemageCount((short) this.prot.GetSanityDemage());
        effSanityLose.Execute(new Func(this.FleeOrFight), (byte) 40);
      }
      else if (this.prot.GetExtraSanity() > (byte) 0)
      {
        this.en.io.PrintToLog(Environment.NewLine + "(" + this.en.sysstr.GetString(SSType.ExtraHorror) + ")", isBold: true);
        EffSanityLose effSanityLose = new EffSanityLose(this.en);
        effSanityLose.ChangeDemageCount((short) this.prot.GetExtraSanity());
        effSanityLose.Execute(new Func(this.FleeOrFight), (byte) 40);
      }
      else
        this.FleeOrFight();
    }

    private void CombatCheck()
    {
      this.itemModif = (byte) 0;
      this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].BeforeCombatCheck();
    }

    public void DoCombatCheck()
    {
      this.en.io.PrintToLog(Environment.NewLine);
      SkillTest skillTest = new SkillTest(this.en, SkillTestType.Combat, this.prot.GetCombatModif(), new FuncWithParam(this.AfterCombatCheck), this.prot.GetTougness(), true, SkillTestType.Fight, this.itemModif);
    }

    private void AfterCombatCheck(short suc)
    {
      if ((int) suc >= (int) this.prot.GetTougness())
      {
        if (this.prot.GetExtraCombat() > (byte) 0)
        {
          this.MakeATrofy();
          this.en.io.PrintToLog(Environment.NewLine + "(" + this.en.sysstr.GetString(SSType.ExtraCombat) + ")", isBold: true);
          EffStaminaLose effStaminaLose = new EffStaminaLose(this.en);
          effStaminaLose.ChangeDemageCount((short) this.prot.GetExtraCombat());
          effStaminaLose.Execute(new Func(this.EndEncounter), (byte) 40);
        }
        else
        {
          this.MakeATrofy();
          this.EndEncounter();
        }
      }
      else
        this.prot.DoDemage(new Func(this.FleeOrFight), this);
    }

    private void FleeOrFight()
    {
      if (this.prot.GetAmbush())
        this.CombatCheck();
      else
        this.en.io.YesNoStart(this.en.sysstr.GetString(SSType.EvadeOrFight1) + "  " + this.prot.GetEvadeTitle() + " " + this.en.sysstr.GetString(SSType.EvadeOrFight2) + " " + this.prot.GetFightTitle(), this.en.sysstr.GetString(SSType.EvadeButton), this.en.sysstr.GetString(SSType.FightButton), new Func(this.FleeCheck), new Func(this.CombatCheck));
    }

    private void FleeCheck()
    {
      this.en.io.PrintToLog(Environment.NewLine);
      SkillTest skillTest = new SkillTest(this.en, SkillTestType.Evade, this.prot.GetEvadeModif(), new FuncWithParam(this.AfterFleeCheck), isSecondType: true, type2: SkillTestType.Sneak);
    }

    private void AfterFleeCheck(short suc)
    {
      if (suc > (short) 0)
        this.EndEncounter();
      else
        this.prot.DoDemage(new Func(this.FleeOrFight), this);
    }

    public void EndEncounter()
    {
      this.en.io.PrintToLog(Environment.NewLine);
      this.en.io.PrintToLog(Environment.NewLine);
      this.RPAfterEncounter();
    }

    public string GetTitle() => this.prot.GetTitle();

    public void PrintToMap(byte label) => this.en.io.Print(this.prot.GetTitle(), isBold: true, isItalic: true, label: label);

    public override void ReadFromSave(BinaryReader rd)
    {
      this.locnum = rd.ReadInt16();
      if (this.locnum == (short) 0)
        this.en.Scy.Add(this);
      else
        ((ArchemArea) this.en.locs[(int) this.locnum]).AddMonster(this);
      this.isEncountred = false;
    }

    public override void WriteToSave(BinaryWriter wr)
    {
      base.WriteToSave(wr);
      wr.Write(this.locnum);
    }

    public void Print() => this.prot.Print();

    public void MakeATrofy()
    {
      if (this.locnum != (short) -1)
      {
        if (this.locnum == (short) 0)
          this.en.Scy.Remove(this);
        else
          ((ArchemArea) this.en.locs[(int) this.locnum]).RemoveMonster(this);
        this.en.ActiveMonsters.Remove(this);
      }
      if (this.prot.GetEndless())
        return;
      this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].AddTrophy(this);
    }

    public void PrintAsTrofy() => this.en.io.Print(this.prot.GetTitle() + "  (" + this.prot.GetTougness().ToString() + ")");

    public void AddItemModif(byte modifChange, bool isPhysical = false, bool isMagic = false) => this.itemModif += this.prot.AddItemModif(modifChange, isPhysical, isMagic);

    public void Move(bool isWhite)
    {
      if (this.locnum != (short) 0 && this.en.locs[(int) this.locnum].GetInvestCount() > (byte) 0)
      {
        this.en.curs.resolvingMythos.Step3Circle();
      }
      else
      {
        switch (this.prot.GetMoveType())
        {
          case MonsterMovementType.Normal:
            this.SetLocathion(!isWhite ? ((ArchemArea) this.en.locs[(int) this.locnum]).GetBlackArrow() : ((ArchemArea) this.en.locs[(int) this.locnum]).GetWhiteArrow());
            this.en.curs.resolvingMythos.Step3Circle();
            break;
          case MonsterMovementType.Fly:
            this.MovementFly();
            break;
          case MonsterMovementType.Fast:
            this.SetLocathion(!isWhite ? ((ArchemArea) this.en.locs[(int) ((ArchemArea) this.en.locs[(int) this.locnum]).GetBlackArrow()]).GetBlackArrow() : ((ArchemArea) this.en.locs[(int) ((ArchemArea) this.en.locs[(int) this.locnum]).GetWhiteArrow()]).GetWhiteArrow());
            this.en.curs.resolvingMythos.Step3Circle();
            break;
          case MonsterMovementType.Special:
            this.prot.ExecuteMoveEffect();
            break;
          case MonsterMovementType.Inmobile:
            this.en.curs.resolvingMythos.Step3Circle();
            break;
        }
      }
    }

    private void MovementFly()
    {
      List<short> shortList = new List<short>();
      byte num1 = 100;
      if (this.locnum == (short) 0)
      {
        for (int index = 0; index < this.en.locs.Count; ++index)
        {
          Locathion loc = this.en.locs[index];
          if (loc.GetLocType() == LocathionType.ArchamStreet && (int) loc.GetMinSneak() <= (int) num1)
          {
            shortList.Add((short) index);
            num1 = loc.GetMinSneak();
          }
        }
      }
      else if (this.en.locs[(int) this.locnum].GetLocType() != LocathionType.ArchamStreet)
      {
        short whiteArrow = ((ArchemArea) this.en.locs[(int) this.locnum]).GetWhiteArrow();
        if (this.en.locs[(int) whiteArrow].GetInvestCount() > (byte) 0)
          shortList.Add(whiteArrow);
      }
      else
      {
        List<short> linkStreets = ((ArchemStreet) this.en.locs[(int) this.locnum]).GetLinkStreets();
        for (int index = 0; index < linkStreets.Count; ++index)
        {
          if ((int) this.en.locs[(int) linkStreets[index]].GetMinSneak() <= (int) num1)
            shortList.Add(linkStreets[index]);
        }
      }
      if (shortList.Count == 0)
      {
        if (this.locnum != (short) 0)
          this.SetLocathion((short) 0);
        this.en.curs.resolvingMythos.Step3Circle();
      }
      else if (shortList.Count == 1)
      {
        this.SetLocathion(shortList[0]);
        this.en.curs.resolvingMythos.Step3Circle();
      }
      else
      {
        List<IOOption> opts = new List<IOOption>();
        foreach (short num2 in shortList)
          opts.Add((IOOption) new IOOptionWithParam(this.en.locs[(int) num2].GetTitle(), new FuncWithParam(this.FlyMove2), num2));
        this.en.io.StartChoose(opts, this.prot.GetTitle() + "  " + this.en.sysstr.GetString(SSType.MonsterMovePromt1) + "  " + this.en.sysstr.GetString(SSType.it) + "  " + this.en.sysstr.GetString(SSType.MonsterMovePromt2), this.en.sysstr.GetString(SSType.Confirm));
      }
    }

    private void FlyMove2(short locind)
    {
      this.SetLocathion(locind);
      this.en.curs.resolvingMythos.Step3Circle();
    }

    public byte GetDs() => this.prot.GetDs();
  }
}
