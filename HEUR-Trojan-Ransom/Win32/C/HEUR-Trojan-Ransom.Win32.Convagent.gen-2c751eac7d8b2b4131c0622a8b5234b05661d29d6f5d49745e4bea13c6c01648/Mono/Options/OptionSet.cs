// Decompiled with JetBrains decompiler
// Type: Mono.Options.OptionSet
// Assembly: CryptoAPITransf, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3C6B9EE6-9C07-49E4-80B0-30EE0F446F3E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\HEUR-Trojan-Ransom.Win32.Convagent.gen-2c751eac7d8b2b4131c0622a8b5234b05661d29d6f5d49745e4bea13c6c01648.exe

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace Mono.Options
{
  public class OptionSet : KeyedCollection<string, Option>
  {
    private Converter<string, string> localizer;
    private readonly Regex ValueOption = new Regex("^(?<flag>--|-|/)(?<name>[^:=]+)((?<sep>[:=])(?<value>.*))?$");
    private const int OptionWidth = 29;

    public OptionSet()
      : this((Converter<string, string>) (f => f))
    {
    }

    public OptionSet(Converter<string, string> localizer) => this.localizer = localizer;

    public Converter<string, string> MessageLocalizer => this.localizer;

    protected override string GetKeyForItem(Option item)
    {
      if (item == null)
        throw new ArgumentNullException("option");
      if (item.Names != null && item.Names.Length != 0)
        return item.Names[0];
      throw new InvalidOperationException("Option has no names!");
    }

    [Obsolete("Use KeyedCollection.this[string]")]
    protected Option GetOptionForName(string option)
    {
      if (option == null)
        throw new ArgumentNullException(nameof (option));
      try
      {
        return this[option];
      }
      catch (KeyNotFoundException ex)
      {
        return (Option) null;
      }
    }

    protected override void InsertItem(int index, Option item)
    {
      base.InsertItem(index, item);
      this.AddImpl(item);
    }

    protected override void RemoveItem(int index)
    {
      Option option = this.Items[index];
      base.RemoveItem(index);
      for (int index1 = 1; index1 < option.Names.Length; ++index1)
        this.Dictionary.Remove(option.Names[index1]);
    }

    protected override void SetItem(int index, Option item)
    {
      base.SetItem(index, item);
      this.AddImpl(item);
    }

    private void AddImpl(Option option)
    {
      if (option == null)
        throw new ArgumentNullException(nameof (option));
      List<string> stringList = new List<string>(option.Names.Length);
      try
      {
        for (int index = 1; index < option.Names.Length; ++index)
        {
          this.Dictionary.Add(option.Names[index], option);
          stringList.Add(option.Names[index]);
        }
      }
      catch (Exception ex)
      {
        foreach (string key in stringList)
          this.Dictionary.Remove(key);
        throw;
      }
    }

    public OptionSet Add(Option option)
    {
      base.Add(option);
      return this;
    }

    public OptionSet Add(string prototype, Action<string> action) => this.Add(prototype, (string) null, action);

    public OptionSet Add(string prototype, string description, Action<string> action)
    {
      if (action == null)
        throw new ArgumentNullException(nameof (action));
      base.Add((Option) new OptionSet.ActionOption(prototype, description, 1, (Action<OptionValueCollection>) (v => action(v[0]))));
      return this;
    }

    public OptionSet Add(string prototype, OptionAction<string, string> action) => this.Add(prototype, (string) null, action);

    public OptionSet Add(
      string prototype,
      string description,
      OptionAction<string, string> action)
    {
      if (action == null)
        throw new ArgumentNullException(nameof (action));
      base.Add((Option) new OptionSet.ActionOption(prototype, description, 2, (Action<OptionValueCollection>) (v => action(v[0], v[1]))));
      return this;
    }

    public OptionSet Add<T>(string prototype, Action<T> action) => this.Add<T>(prototype, (string) null, action);

    public OptionSet Add<T>(string prototype, string description, Action<T> action) => this.Add((Option) new OptionSet.ActionOption<T>(prototype, description, action));

    public OptionSet Add<TKey, TValue>(string prototype, OptionAction<TKey, TValue> action) => this.Add<TKey, TValue>(prototype, (string) null, action);

    public OptionSet Add<TKey, TValue>(
      string prototype,
      string description,
      OptionAction<TKey, TValue> action)
    {
      return this.Add((Option) new OptionSet.ActionOption<TKey, TValue>(prototype, description, action));
    }

    protected virtual OptionContext CreateOptionContext() => new OptionContext(this);

    public List<string> Parse(IEnumerable<string> arguments)
    {
      OptionContext optionContext = this.CreateOptionContext();
      optionContext.OptionIndex = -1;
      bool flag = true;
      List<string> extra = new List<string>();
      Option def = this.Contains("<>") ? this["<>"] : (Option) null;
      foreach (string str in arguments)
      {
        ++optionContext.OptionIndex;
        if (str == "--")
          flag = false;
        else if (!flag)
          OptionSet.Unprocessed((ICollection<string>) extra, def, optionContext, str);
        else if (!this.Parse(str, optionContext))
          OptionSet.Unprocessed((ICollection<string>) extra, def, optionContext, str);
      }
      if (optionContext.Option != null)
        optionContext.Option.Invoke(optionContext);
      return extra;
    }

    private static bool Unprocessed(
      ICollection<string> extra,
      Option def,
      OptionContext c,
      string argument)
    {
      if (def == null)
      {
        extra.Add(argument);
        return false;
      }
      c.OptionValues.Add(argument);
      c.Option = def;
      c.Option.Invoke(c);
      return false;
    }

    protected bool GetOptionParts(
      string argument,
      out string flag,
      out string name,
      out string sep,
      out string value)
    {
      if (argument == null)
        throw new ArgumentNullException(nameof (argument));
      flag = name = sep = value = (string) null;
      Match match = this.ValueOption.Match(argument);
      if (!match.Success)
        return false;
      flag = match.Groups[nameof (flag)].Value;
      name = match.Groups[nameof (name)].Value;
      if (match.Groups[nameof (sep)].Success && match.Groups[nameof (value)].Success)
      {
        sep = match.Groups[nameof (sep)].Value;
        value = match.Groups[nameof (value)].Value;
      }
      return true;
    }

    protected virtual bool Parse(string argument, OptionContext c)
    {
      if (c.Option != null)
      {
        this.ParseValue(argument, c);
        return true;
      }
      string flag;
      string name;
      string sep;
      string option1;
      if (!this.GetOptionParts(argument, out flag, out name, out sep, out option1))
        return false;
      if (this.Contains(name))
      {
        Option option2 = this[name];
        c.OptionName = flag + name;
        c.Option = option2;
        switch (option2.OptionValueType)
        {
          case OptionValueType.None:
            c.OptionValues.Add(name);
            c.Option.Invoke(c);
            break;
          case OptionValueType.Optional:
          case OptionValueType.Required:
            this.ParseValue(option1, c);
            break;
        }
        return true;
      }
      if (this.ParseBool(argument, name, c))
        return true;
      return this.ParseBundledValue(flag, name + sep + option1, c);
    }

    private void ParseValue(string option, OptionContext c)
    {
      if (option != null)
      {
        string[] strArray;
        if (c.Option.ValueSeparators == null)
          strArray = new string[1]{ option };
        else
          strArray = option.Split(c.Option.ValueSeparators, c.Option.MaxValueCount - c.OptionValues.Count, StringSplitOptions.None);
        foreach (string str in strArray)
          c.OptionValues.Add(str);
      }
      if (c.OptionValues.Count == c.Option.MaxValueCount || c.Option.OptionValueType == OptionValueType.Optional)
        c.Option.Invoke(c);
      else if (c.OptionValues.Count > c.Option.MaxValueCount)
        throw new OptionException(this.localizer(string.Format("Error: Found {0} option values when expecting {1}.", (object) c.OptionValues.Count, (object) c.Option.MaxValueCount)), c.OptionName);
    }

    private bool ParseBool(string option, string n, OptionContext c)
    {
      string key;
      if (n.Length < 1 || n[n.Length - 1] != '+' && n[n.Length - 1] != '-' || !this.Contains(key = n.Substring(0, n.Length - 1)))
        return false;
      Option option1 = this[key];
      string str = n[n.Length - 1] == '+' ? option : (string) null;
      c.OptionName = option;
      c.Option = option1;
      c.OptionValues.Add(str);
      option1.Invoke(c);
      return true;
    }

    private bool ParseBundledValue(string f, string n, OptionContext c)
    {
      if (f != "-")
        return false;
      for (int index = 0; index < n.Length; ++index)
      {
        string str1 = f;
        char ch = n[index];
        string str2 = ch.ToString();
        string str3 = str1 + str2;
        ch = n[index];
        string key = ch.ToString();
        if (!this.Contains(key))
        {
          if (index == 0)
            return false;
          throw new OptionException(string.Format(this.localizer("Cannot bundle unregistered option '{0}'."), (object) str3), str3);
        }
        Option option = this[key];
        switch (option.OptionValueType)
        {
          case OptionValueType.None:
            OptionSet.Invoke(c, str3, n, option);
            continue;
          case OptionValueType.Optional:
          case OptionValueType.Required:
            string str4 = n.Substring(index + 1);
            c.Option = option;
            c.OptionName = str3;
            this.ParseValue(str4.Length != 0 ? str4 : (string) null, c);
            return true;
          default:
            throw new InvalidOperationException("Unknown OptionValueType: " + option.OptionValueType.ToString());
        }
      }
      return true;
    }

    private static void Invoke(OptionContext c, string name, string value, Option option)
    {
      c.OptionName = name;
      c.Option = option;
      c.OptionValues.Add(value);
      option.Invoke(c);
    }

    public void WriteOptionDescriptions(TextWriter o)
    {
      foreach (Option p in (Collection<Option>) this)
      {
        int written = 0;
        if (this.WriteOptionPrototype(o, p, ref written))
        {
          if (written < 29)
          {
            o.Write(new string(' ', 29 - written));
          }
          else
          {
            o.WriteLine();
            o.Write(new string(' ', 29));
          }
          bool flag = false;
          string str = new string(' ', 31);
          foreach (string line in OptionSet.GetLines(this.localizer(OptionSet.GetDescription(p.Description))))
          {
            if (flag)
              o.Write(str);
            o.WriteLine(line);
            flag = true;
          }
        }
      }
    }

    private bool WriteOptionPrototype(TextWriter o, Option p, ref int written)
    {
      string[] names = p.Names;
      int nextOptionIndex1 = OptionSet.GetNextOptionIndex(names, 0);
      if (nextOptionIndex1 == names.Length)
        return false;
      if (names[nextOptionIndex1].Length == 1)
      {
        OptionSet.Write(o, ref written, "  -");
        OptionSet.Write(o, ref written, names[0]);
      }
      else
      {
        OptionSet.Write(o, ref written, "      --");
        OptionSet.Write(o, ref written, names[0]);
      }
      for (int nextOptionIndex2 = OptionSet.GetNextOptionIndex(names, nextOptionIndex1 + 1); nextOptionIndex2 < names.Length; nextOptionIndex2 = OptionSet.GetNextOptionIndex(names, nextOptionIndex2 + 1))
      {
        OptionSet.Write(o, ref written, ", ");
        OptionSet.Write(o, ref written, names[nextOptionIndex2].Length == 1 ? "-" : "--");
        OptionSet.Write(o, ref written, names[nextOptionIndex2]);
      }
      if (p.OptionValueType == OptionValueType.Optional || p.OptionValueType == OptionValueType.Required)
      {
        if (p.OptionValueType == OptionValueType.Optional)
          OptionSet.Write(o, ref written, this.localizer("["));
        OptionSet.Write(o, ref written, this.localizer("=" + OptionSet.GetArgumentName(0, p.MaxValueCount, p.Description)));
        string str = p.ValueSeparators == null || p.ValueSeparators.Length == 0 ? " " : p.ValueSeparators[0];
        for (int index = 1; index < p.MaxValueCount; ++index)
          OptionSet.Write(o, ref written, this.localizer(str + OptionSet.GetArgumentName(index, p.MaxValueCount, p.Description)));
        if (p.OptionValueType == OptionValueType.Optional)
          OptionSet.Write(o, ref written, this.localizer("]"));
      }
      return true;
    }

    private static int GetNextOptionIndex(string[] names, int i)
    {
      while (i < names.Length && names[i] == "<>")
        ++i;
      return i;
    }

    private static void Write(TextWriter o, ref int n, string s)
    {
      n += s.Length;
      o.Write(s);
    }

    private static string GetArgumentName(int index, int maxIndex, string description)
    {
      if (description == null)
        return maxIndex != 1 ? "VALUE" + (index + 1).ToString() : "VALUE";
      string[] strArray;
      if (maxIndex == 1)
        strArray = new string[2]{ "{0:", "{" };
      else
        strArray = new string[1]
        {
          "{" + index.ToString() + ":"
        };
      for (int index1 = 0; index1 < strArray.Length; ++index1)
      {
        int startIndex1 = 0;
        int startIndex2;
        do
        {
          startIndex2 = description.IndexOf(strArray[index1], startIndex1);
        }
        while ((startIndex2 < 0 || startIndex1 == 0 ? 0 : (description[startIndex1++ - 1] == '{' ? 1 : 0)) != 0);
        if (startIndex2 != -1)
        {
          int num = description.IndexOf("}", startIndex2);
          if (num != -1)
            return description.Substring(startIndex2 + strArray[index1].Length, num - startIndex2 - strArray[index1].Length);
        }
      }
      return maxIndex != 1 ? "VALUE" + (index + 1).ToString() : "VALUE";
    }

    private static string GetDescription(string description)
    {
      if (description == null)
        return string.Empty;
      StringBuilder stringBuilder = new StringBuilder(description.Length);
      int startIndex = -1;
      for (int index = 0; index < description.Length; ++index)
      {
        switch (description[index])
        {
          case ':':
            if (startIndex >= 0)
            {
              startIndex = index + 1;
              break;
            }
            goto default;
          case '{':
            if (index == startIndex)
            {
              stringBuilder.Append('{');
              startIndex = -1;
              break;
            }
            if (startIndex < 0)
            {
              startIndex = index + 1;
              break;
            }
            break;
          case '}':
            if (startIndex < 0)
            {
              if (index + 1 == description.Length || description[index + 1] != '}')
                throw new InvalidOperationException("Invalid option description: " + description);
              ++index;
              stringBuilder.Append("}");
              break;
            }
            stringBuilder.Append(description.Substring(startIndex, index - startIndex));
            startIndex = -1;
            break;
          default:
            if (startIndex < 0)
            {
              stringBuilder.Append(description[index]);
              break;
            }
            break;
        }
      }
      return stringBuilder.ToString();
    }

    private static IEnumerable<string> GetLines(string description) => StringCoda.WrappedLines(description, 51, 49);

    private sealed class ActionOption : Option
    {
      private Action<OptionValueCollection> action;

      public ActionOption(
        string prototype,
        string description,
        int count,
        Action<OptionValueCollection> action)
        : base(prototype, description, count)
      {
        this.action = action != null ? action : throw new ArgumentNullException(nameof (action));
      }

      protected override void OnParseComplete(OptionContext c) => this.action(c.OptionValues);
    }

    private sealed class ActionOption<T> : Option
    {
      private Action<T> action;

      public ActionOption(string prototype, string description, Action<T> action)
        : base(prototype, description, 1)
      {
        this.action = action != null ? action : throw new ArgumentNullException(nameof (action));
      }

      protected override void OnParseComplete(OptionContext c) => this.action(Option.Parse<T>(c.OptionValues[0], c));
    }

    private sealed class ActionOption<TKey, TValue> : Option
    {
      private OptionAction<TKey, TValue> action;

      public ActionOption(string prototype, string description, OptionAction<TKey, TValue> action)
        : base(prototype, description, 2)
      {
        this.action = action != null ? action : throw new ArgumentNullException(nameof (action));
      }

      protected override void OnParseComplete(OptionContext c) => this.action(Option.Parse<TKey>(c.OptionValues[0], c), Option.Parse<TValue>(c.OptionValues[1], c));
    }
  }
}
