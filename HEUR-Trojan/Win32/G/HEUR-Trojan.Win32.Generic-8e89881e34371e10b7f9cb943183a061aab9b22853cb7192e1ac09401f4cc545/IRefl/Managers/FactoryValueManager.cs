// Decompiled with JetBrains decompiler
// Type: IRefl.Managers.FactoryValueManager
// Assembly: IRefl, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A29A65F6-B7ED-422C-83D4-B9EFD61E5F13
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-8e89881e34371e10b7f9cb943183a061aab9b22853cb7192e1ac09401f4cc545.exe

using IRefl.Pools;
using IRefl.Watchers;
using ProjNet.Structs;
using ProjNet.Templates;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace IRefl.Managers
{
  internal class FactoryValueManager : ServiceObserverWatcher
  {
    private double _ServiceRegistry;
    private double _PrototypeRegistry;
    private double m_TokenizerRegistry;
    private double threadRegistry;
    private double m_ContainerRegistry;
    private double _InfoRegistry;
    private double publisherRegistry;
    private double m_IndexerRegistry;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public FactoryValueManager(List<Config> v)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      this.\u002Ector(v, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public FactoryValueManager(List<Config> reference, bool includeattr)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      this.m_ContainerRegistry = 0.0;
      // ISSUE: explicit constructor call
      base.\u002Ector(reference, includeattr);
      this.Name = "Albers_Conic_Equal_Area";
      Config config1 = this.PushMerchant("longitude_of_center");
      Config config2 = this.PushMerchant("latitude_of_center");
      Config config3 = this.PushMerchant("standard_parallel_1");
      Config config4 = this.PushMerchant("standard_parallel_2");
      Config config5 = this.PushMerchant("false_easting");
      Config config6 = this.PushMerchant("false_northing");
      if (config1 == null)
      {
        config1 = this.PushMerchant("central_meridian");
        if (config1 == null)
          throw new ArgumentException("Missing projection parameter 'longitude_of_center'");
      }
      if (config2 == null)
      {
        config2 = this.PushMerchant("latitude_of_origin");
        if (config2 == null)
          throw new ArgumentException("Missing projection parameter 'latitude_of_center'");
      }
      if (config3 == null)
        throw new ArgumentException("Missing projection parameter 'standard_parallel_1'");
      if (config4 == null)
        throw new ArgumentException("Missing projection parameter 'standard_parallel_2'");
      if (config5 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (config6 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      this.m_IndexerRegistry = ValueObserverWatcher.PopAdvisor(config1.CountRegistry());
      double asset = ValueObserverWatcher.PopAdvisor(config2.CountRegistry());
      double num1 = ValueObserverWatcher.PopAdvisor(config3.CountRegistry());
      double num2 = ValueObserverWatcher.PopAdvisor(config4.CountRegistry());
      this._ServiceRegistry = config5.CountRegistry() * this.refRegistry;
      this._PrototypeRegistry = config6.CountRegistry() * this.refRegistry;
      if (Math.Abs(num1 + num2) < double.Epsilon)
        throw new ArgumentException("Equal latitudes for standard parallels on opposite sides of Equator.");
      this.m_ContainerRegistry = 1.0 - Math.Pow(this._ConfigurationRegistry / this._InterpreterRegistry, 2.0);
      this.threadRegistry = Math.Sqrt(this.m_ContainerRegistry);
      double num3 = this.PrepareAdvisor(num1);
      double num4 = this.PrepareAdvisor(num2);
      double x1 = Math.Cos(num1) / Math.Sqrt(1.0 - this.m_ContainerRegistry * Math.Pow(Math.Sin(num1), 2.0));
      double x2 = Math.Cos(num2) / Math.Sqrt(1.0 - this.m_ContainerRegistry * Math.Pow(Math.Sin(num2), 2.0));
      this.publisherRegistry = (Math.Pow(x1, 2.0) - Math.Pow(x2, 2.0)) / (num4 - num3);
      this.m_TokenizerRegistry = Math.Pow(x1, 2.0) + this.publisherRegistry * num3;
      this._InfoRegistry = this.CancelAdvisor(this.PrepareAdvisor(asset));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ComputeMerchant(double[] setup)
    {
      int num1 = 6;
      double asset;
      double num2;
      double[] merchant;
      while (true)
      {
        double num3;
        int num4;
        bool flag;
        switch (num1)
        {
          case 0:
            num3 = this.CancelAdvisor(this.PrepareAdvisor(asset));
            goto case 3;
          case 1:
          case 5:
            asset = ValueObserverWatcher.PopAdvisor(setup[1]);
            if (true)
            {
              num1 = 0;
              continue;
            }
            goto label_11;
          case 2:
            if (!flag)
            {
              merchant = new double[3]
              {
                num2 / this.refRegistry,
                asset / this.refRegistry,
                setup[2]
              };
              num4 = 7;
              break;
            }
            goto label_7;
          case 3:
          case 4:
            double num5 = this.publisherRegistry * (num2 - this.m_IndexerRegistry);
            num2 = this._ServiceRegistry + num3 * Math.Sin(num5);
            asset = this._PrototypeRegistry + this._InfoRegistry - num3 * Math.Cos(num5);
            flag = setup.Length == 2;
            num4 = 2;
            break;
          case 6:
            num2 = ValueObserverWatcher.PopAdvisor(setup[0]);
            num4 = 5;
            break;
          case 7:
            goto label_11;
          default:
            if (FactoryValueManager.RateModel())
            {
              num1 = 4;
              continue;
            }
            goto case 3;
        }
        num1 = num4;
      }
label_7:
      merchant = new double[2]
      {
        num2 / this.refRegistry,
        asset / this.refRegistry
      };
label_11:
      return merchant;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ConcatMerchant(double[] info)
    {
      int num1 = 0;
      double num2;
      double key;
      double[] numArray;
      while (true)
      {
        double num3;
        bool flag;
        int num4;
        int num5;
        double num6;
        double num7;
        double x;
        double num8;
        switch (num1)
        {
          case 0:
            num6 = Math.Atan((info[0] * this.refRegistry - this._ServiceRegistry) / (this._InfoRegistry - (info[1] * this.refRegistry - this._PrototypeRegistry)));
            num5 = 5;
            goto label_4;
          case 1:
          case 5:
            num7 = (this.m_TokenizerRegistry - Math.Pow(Math.Sqrt(Math.Pow(info[0] * this.refRegistry - this._ServiceRegistry, 2.0) + Math.Pow(this._InfoRegistry - (info[1] * this.refRegistry - this._PrototypeRegistry), 2.0)), 2.0) * Math.Pow(this.publisherRegistry, 2.0) / Math.Pow(this._InterpreterRegistry, 2.0)) / this.publisherRegistry;
            Math.Sin(num7 / (1.0 - (1.0 - this.m_ContainerRegistry) / (2.0 * this.threadRegistry) * Math.Log((1.0 - this.threadRegistry) / (1.0 + this.threadRegistry))));
            num2 = Math.Asin(num7 * 0.5);
            num3 = double.MaxValue;
            num4 = 0;
            break;
          case 2:
label_3:
            ++num4;
            goto case 3;
          case 3:
            if (num4 > 25)
            {
              num5 = 4;
              goto label_4;
            }
            else
              break;
          case 4:
            goto label_1;
          case 6:
          case 8:
            if (!flag)
            {
              key = this.m_IndexerRegistry + num6 / this.publisherRegistry;
              if (info.Length != 2)
              {
                numArray = new double[3]
                {
                  ValueObserverWatcher.SetAdvisor(key),
                  ValueObserverWatcher.SetAdvisor(num2),
                  info[2]
                };
                if (true)
                {
                  num1 = 9;
                  continue;
                }
                goto case 1;
              }
              else
                goto label_9;
            }
            else
            {
              num3 = num2;
              x = Math.Sin(num2);
              num8 = this.m_ContainerRegistry * Math.Pow(x, 2.0);
              num5 = 7;
              goto label_4;
            }
          case 7:
            num2 += Math.Pow(1.0 - num8, 2.0) / (2.0 * Math.Cos(num2)) * (num7 / (1.0 - this.m_ContainerRegistry) - x / (1.0 - num8) + 1.0 / (2.0 * this.threadRegistry) * Math.Log((1.0 - this.threadRegistry * x) / (1.0 + this.threadRegistry * x)));
            num5 = 2;
            goto label_4;
          case 9:
            goto label_17;
          default:
            num5 = 3;
            goto label_4;
        }
        flag = Math.Abs(num2 - num3) > 1E-06;
        if (!FactoryValueManager.MapModel())
        {
          num1 = 8;
          continue;
        }
        goto label_3;
label_4:
        num1 = num5;
      }
label_1:
      throw new ArgumentException("Transformation failed to converge in Albers backwards transformation");
label_9:
      numArray = new double[2]
      {
        ValueObserverWatcher.SetAdvisor(key),
        ValueObserverWatcher.SetAdvisor(num2)
      };
label_17:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override OrderValuePool ManageItem()
    {
      int num1 = 2;
      OrderValuePool interceptorRegistry;
      while (true)
      {
        int num2 = num1;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 2:
              flag = this.m_InterceptorRegistry == null;
              if (FactoryValueManager.RateModel())
              {
                num2 = 4;
                continue;
              }
              goto label_2;
            case 1:
            case 4:
              goto label_2;
            case 3:
              goto label_6;
            case 5:
              goto label_9;
            default:
              goto label_5;
          }
        }
label_2:
        if (!flag)
          goto label_7;
        else
          goto label_6;
label_5:
        num1 = 3;
        continue;
label_6:
        this.m_InterceptorRegistry = (ValueObserverWatcher) new FactoryValueManager(this.globalRegistry, !this._PropertyRegistry);
label_7:
        interceptorRegistry = (OrderValuePool) this.m_InterceptorRegistry;
        num1 = 5;
      }
label_9:
      return interceptorRegistry;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private double PrepareAdvisor(double asset)
    {
      int num1 = 3;
      double num2;
      while (true)
      {
        int num3 = num1;
        double x;
        double num4;
        while (true)
        {
          switch (num3)
          {
            case 0:
            case 2:
              num2 = (1.0 - this.m_ContainerRegistry) * (x / (1.0 - this.m_ContainerRegistry * num4) - 1.0 / (2.0 * this.threadRegistry) * Math.Log((1.0 - this.threadRegistry * x) / (1.0 + this.threadRegistry * x)));
              num3 = 5;
              continue;
            case 1:
            case 4:
              num4 = Math.Pow(x, 2.0);
              goto case 0;
            case 3:
              goto label_2;
            case 5:
              goto label_7;
            default:
              goto label_6;
          }
        }
label_2:
        x = Math.Sin(asset);
        num1 = 4;
        continue;
label_6:
        num1 = 0;
      }
label_7:
      return num2;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private double CancelAdvisor(double task) => this._InterpreterRegistry * Math.Sqrt(this.m_TokenizerRegistry - this.publisherRegistry * task) / this.publisherRegistry;

    internal static bool RateModel() => true;

    internal static bool MapModel() => false;
  }
}
