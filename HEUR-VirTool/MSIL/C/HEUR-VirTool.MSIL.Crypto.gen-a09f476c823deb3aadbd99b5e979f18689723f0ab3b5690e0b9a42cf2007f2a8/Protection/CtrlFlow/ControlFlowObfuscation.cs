// Decompiled with JetBrains decompiler
// Type: Aura.Protection.CtrlFlow.ControlFlowObfuscation
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.CtrlFlow
{
  internal class ControlFlowObfuscation
  {
    public static Random rnd = new Random();

    public static void Execute(ModuleDefMD md)
    {
      foreach (TypeDef type in (IEnumerable<TypeDef>) ((ModuleDef) md).Types)
      {
        if (type != ((ModuleDef) md).GlobalType)
        {
          foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
          {
            if (!method.Name.StartsWith("get_") && !method.Name.StartsWith("set_") && method.HasBody && !method.IsConstructor)
            {
              method.Body.SimplifyBranches();
              ControlFlowObfuscation.ExecuteMethod(method);
            }
          }
        }
      }
    }

    public static void ExecuteMethod(MethodDef method)
    {
      method.Body.SimplifyMacros((IList<Parameter>) method.Parameters);
      List<Block> blocks = BlockParser.ParseMethod(method);
      blocks = ControlFlowObfuscation.Randomize(blocks);
      ((ICollection<Instruction>) method.Body.Instructions).Clear();
      Local local = new Local((TypeSig) method.Module.CorLibTypes.Int32);
      method.Body.Variables.Add(local);
      Instruction instruction1 = Instruction.Create(OpCodes.Nop);
      Instruction instruction2 = Instruction.Create(OpCodes.Br, instruction1);
      foreach (Instruction instruction3 in ControlFlowObfuscation.Calc(0))
        ((ICollection<Instruction>) method.Body.Instructions).Add(instruction3);
      ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Stloc, local));
      ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Br, instruction2));
      ((ICollection<Instruction>) method.Body.Instructions).Add(instruction1);
      foreach (Block block in blocks.Where<Block>((Func<Block, bool>) (block => block != blocks.Single<Block>((Func<Block, bool>) (x => x.Number == blocks.Count - 1)))))
      {
        ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Ldloc, local));
        foreach (Instruction instruction4 in ControlFlowObfuscation.Calc(block.Number))
          ((ICollection<Instruction>) method.Body.Instructions).Add(instruction4);
        ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Ceq));
        Instruction instruction5 = Instruction.Create(OpCodes.Nop);
        ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Brfalse, instruction5));
        foreach (Instruction instruction6 in block.Instructions)
          ((ICollection<Instruction>) method.Body.Instructions).Add(instruction6);
        foreach (Instruction instruction7 in ControlFlowObfuscation.Calc(block.Number + 1))
          ((ICollection<Instruction>) method.Body.Instructions).Add(instruction7);
        ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Stloc, local));
        ((ICollection<Instruction>) method.Body.Instructions).Add(instruction5);
      }
      ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Ldloc, local));
      foreach (Instruction instruction8 in ControlFlowObfuscation.Calc(blocks.Count - 1))
        ((ICollection<Instruction>) method.Body.Instructions).Add(instruction8);
      ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Ceq));
      ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Brfalse, instruction2));
      ((ICollection<Instruction>) method.Body.Instructions).Add(Instruction.Create(OpCodes.Br, blocks.Single<Block>((Func<Block, bool>) (x => x.Number == blocks.Count - 1)).Instructions[0]));
      ((ICollection<Instruction>) method.Body.Instructions).Add(instruction2);
      foreach (Instruction instruction9 in blocks.Single<Block>((Func<Block, bool>) (x => x.Number == blocks.Count - 1)).Instructions)
        ((ICollection<Instruction>) method.Body.Instructions).Add(instruction9);
    }

    public static List<Block> Randomize(List<Block> input)
    {
      List<Block> blockList = new List<Block>();
      foreach (Block block in input)
        blockList.Insert(ControlFlowObfuscation.rnd.Next(0, blockList.Count), block);
      return blockList;
    }

    public static List<Instruction> Calc(int value)
    {
      List<Instruction> instructionList = new List<Instruction>();
      instructionList.Add(Instruction.Create(OpCodes.Ldc_I4, value));
      return instructionList;
    }

    public void AddJump(IList<Instruction> instrs, Instruction target) => ((ICollection<Instruction>) instrs).Add(Instruction.Create(OpCodes.Br, target));
  }
}
