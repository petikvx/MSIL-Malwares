// Decompiled with JetBrains decompiler
// Type: Costura.AssemblyLoader
// Assembly: BitcoinBlackmailer, Version=4.2.6.0, Culture=neutral, PublicKeyToken=null
// MVID: AC84B79B-C968-45A3-8FB8-BD1F97D1C9EF
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Trojan.Win32.Generic-7934625ee2b46883d287d31cb3d1d0b2eb3a0ac2a59a22d434b16513af3d1b11.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Costura
{
  [CompilerGenerated]
  internal static class AssemblyLoader
  {
    private static readonly Dictionary<string, bool> nullCache = new Dictionary<string, bool>();
    private static readonly Dictionary<string, string> assemblyNames = new Dictionary<string, string>();
    private static readonly Dictionary<string, string> symbolNames = new Dictionary<string, string>();
    private static ResolveEventHandler CS\u0024\u003C\u003E9__CachedAnonymousMethodDelegate1;

    private static string CultureToString(CultureInfo culture) => culture == null ? "" : AssemblyLoader.\u202E⁭‬‭‏⁬‌‪‏‪‫‎‌​⁬‎⁫‫⁪⁭​‏⁭‭‭‭‫‬‮‪⁮⁬‌‏‭⁯⁫⁪‫‎‮(culture);

    private static Assembly ReadExistingAssembly(AssemblyName name)
    {
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      foreach (Assembly assembly in AssemblyLoader.\u200F‮⁭‌⁪⁬⁬‭‪⁬‬‫‬⁪⁬​‪‪‏‮‏⁫⁭‭‭‬⁭⁫⁮‮‎‬‬‌‪⁫‌‬⁪‮‮(AssemblyLoader.\u200E‍‍‮‎⁪⁮⁭‬⁮⁬⁯⁫‎⁯⁯‏⁭‮‌⁬‬‍⁪⁪‬‏⁬‎‎‮‪‫⁪⁬⁫‌‍⁫‍‮()))
      {
        // ISSUE: reference to a compiler-generated method
        AssemblyName assemblyName = AssemblyLoader.\u200F⁪​‮⁫⁮‬‪‍‫‪‮‍‮⁯⁫‏⁯‎‏⁮‭‌⁭‬‪⁯⁫‏⁯‫​‎⁮⁪⁯​⁫‍‏‮(assembly);
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        if (AssemblyLoader.\u206E‎‭⁭​​‎‫‮‍‍‪⁪‫⁮‍‫⁫‎⁫⁮‮⁯‏⁯⁭‏‎⁪⁪​⁫‮⁮‏‫⁪‮‮⁫‮(AssemblyLoader.\u200C⁬⁭‫‭‎‬⁭‪⁭⁮‍‎‬‫‌‭‫‌‏‮⁮⁫‮‫⁫‭⁬​⁪‌​‪‫‏⁭‏‍⁬⁭‮(assemblyName), AssemblyLoader.\u200C⁬⁭‫‭‎‬⁭‪⁭⁮‍‎‬‫‌‭‫‌‏‮⁮⁫‮‫⁫‭⁬​⁪‌​‪‫‏⁭‏‍⁬⁭‮(name), StringComparison.InvariantCultureIgnoreCase) && AssemblyLoader.\u206E‎‭⁭​​‎‫‮‍‍‪⁪‫⁮‍‫⁫‎⁫⁮‮⁯‏⁯⁭‏‎⁪⁪​⁫‮⁮‏‫⁪‮‮⁫‮(AssemblyLoader.CultureToString(AssemblyLoader.\u202C⁯⁬‪⁫​⁫⁭‎‏‮​⁮‏⁯⁭​⁫⁯‎‭⁪‬‭⁭​⁬‏⁭‬⁫⁫‏‮‮‬‫​⁯‭‮(assemblyName)), AssemblyLoader.CultureToString(AssemblyLoader.\u202C⁯⁬‪⁫​⁫⁭‎‏‮​⁮‏⁯⁭​⁫⁯‎‭⁪‬‭⁭​⁬‏⁭‬⁫⁫‏‮‮‬‫​⁯‭‮(name)), StringComparison.InvariantCultureIgnoreCase))
          return assembly;
      }
      return (Assembly) null;
    }

    private static void CopyTo(Stream source, Stream destination)
    {
      byte[] numArray = new byte[81920];
      int num;
      // ISSUE: reference to a compiler-generated method
      while ((num = AssemblyLoader.\u206E‎​⁪⁬⁮‬⁮‎‪‍⁭⁯‪⁮‫‬⁪⁬‍⁫‍‭‭‮‪⁪⁪‪‫⁬‪‎⁮⁮⁮‌⁮‍‎‮(source, numArray, 0, numArray.Length)) != 0)
      {
        // ISSUE: reference to a compiler-generated method
        AssemblyLoader.\u200B⁬​​‎‍‍‮⁫⁮‮⁪⁯⁪⁮‫​⁫‮‮⁪‍‮‌‍‎‌⁮⁯⁯‬‪⁭‭‮⁯⁮‪⁫‎‮(destination, numArray, 0, num);
      }
    }

    private static Stream LoadStream(string fullname)
    {
      // ISSUE: reference to a compiler-generated method
      Assembly assembly = AssemblyLoader.\u202A​‍‍‍‏‭‬​‮‎‏​⁯⁪⁬‫‬‫‌⁮⁮⁮⁪⁭​‎⁫‬‫‬‬⁮‭‏⁪⁮⁫‌‭‮();
      // ISSUE: reference to a compiler-generated method
      if (!AssemblyLoader.\u202C‬‏​⁮‎‍⁫⁮‍​⁮‪‬​⁬‭‭‍‏⁭⁮‮⁮⁭⁯⁫‏‌⁯⁬‫​⁭​⁬⁯‬⁫⁮‮(fullname, ".zip"))
      {
        // ISSUE: reference to a compiler-generated method
        return AssemblyLoader.\u200B‌‫⁬⁯‮⁯‫‍‬​‮‭‌‫⁯⁫‪⁬⁮⁮​‍‫‭‍​⁮‌⁪⁪‏⁪‬⁯⁪‬‍‍⁫‮(assembly, fullname);
      }
      // ISSUE: reference to a compiler-generated method
      Stream stream = AssemblyLoader.\u200B‌‫⁬⁯‮⁯‫‍‬​‮‭‌‫⁯⁫‪⁬⁮⁮​‍‫‭‍​⁮‌⁪⁪‏⁪‬⁯⁪‬‍‍⁫‮(assembly, fullname);
      try
      {
        // ISSUE: reference to a compiler-generated method
        DeflateStream source = AssemblyLoader.\u202E⁬‬‮‎​‏‪‮‭‬‭‌⁬‭‍‍‫‭⁬‭‎⁪⁫⁫‎⁫‌⁬‎⁮⁮⁫​​‫⁬‎‎⁪‮(stream, CompressionMode.Decompress);
        try
        {
          // ISSUE: reference to a compiler-generated method
          MemoryStream destination = AssemblyLoader.\u202C‮‌‬​⁭‫‪‬‍⁮‌⁮⁮⁯⁪‏‏⁪‫‬‍‏‎⁯⁫⁯‮‏‫‌‪‫⁮⁯‌‮⁫⁭‍‮();
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.CopyTo((Stream) source, (Stream) destination);
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u202C⁫⁪‏⁬⁬⁬⁪‪⁭‬⁬‬‬⁬⁪​‏‎⁬‪‍⁭‪‍⁭​‌‮⁭⁬⁪‬⁭‮‌‪​‫‪‮((Stream) destination, 0L);
          return (Stream) destination;
        }
        finally
        {
          if (source != null)
          {
            // ISSUE: reference to a compiler-generated method
            AssemblyLoader.\u206E‏​‮‮‏‏​‍‍‍‭⁪⁬‪‮​‍⁪‫⁪‬⁫‌‮‪⁬⁬‭‫⁬‍⁭⁪‪‭⁮⁯‎‮‮((IDisposable) source);
          }
        }
      }
      finally
      {
        if (stream != null)
        {
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206E‏​‮‮‏‏​‍‍‍‭⁪⁬‪‮​‍⁪‫⁪‬⁫‌‮‪⁬⁬‭‫⁬‍⁭⁪‪‭⁮⁯‎‮‮((IDisposable) stream);
        }
      }
    }

    private static Stream LoadStream(Dictionary<string, string> resourceNames, string name)
    {
      string fullname;
      // ISSUE: reference to a compiler-generated method
      return resourceNames.TryGetValue(name, out fullname) ? AssemblyLoader.LoadStream(fullname) : (Stream) null;
    }

    private static byte[] ReadStream(Stream stream)
    {
      // ISSUE: reference to a compiler-generated method
      byte[] numArray = new byte[AssemblyLoader.\u202B‮‏‮⁬‮⁪⁯⁭⁯‫⁮‫‭⁭‬‎‪‪‍⁫‮‍‮‌⁮⁯‏‭⁬​​⁯‎⁮⁬‫‭‪‮(stream)];
      // ISSUE: reference to a compiler-generated method
      AssemblyLoader.\u206E‎​⁪⁬⁮‬⁮‎‪‍⁭⁯‪⁮‫‬⁪⁬‍⁫‍‭‭‮‪⁪⁪‪‫⁬‪‎⁮⁮⁮‌⁮‍‎‮(stream, numArray, 0, numArray.Length);
      return numArray;
    }

    private static Assembly ReadFromEmbeddedResources(
      Dictionary<string, string> assemblyNames,
      Dictionary<string, string> symbolNames,
      AssemblyName requestedAssemblyName)
    {
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      string name = AssemblyLoader.\u206A‬​‌​⁭‍⁬​‬‌‮‏‭‬‮‍‫‎⁪‎⁫‌‪⁫‌‍‪‏‏‏⁫​⁪​‍‎‫⁭‎‮(AssemblyLoader.\u200C⁬⁭‫‭‎‬⁭‪⁭⁮‍‎‬‫‌‭‫‌‏‮⁮⁫‮‫⁫‭⁬​⁪‌​‪‫‏⁭‏‍⁬⁭‮(requestedAssemblyName));
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      if (AssemblyLoader.\u202C⁯⁬‪⁫​⁫⁭‎‏‮​⁮‏⁯⁭​⁫⁯‎‭⁪‬‭⁭​⁬‏⁭‬⁫⁫‏‮‮‬‫​⁯‭‮(requestedAssemblyName) != null && !AssemblyLoader.\u202B‍‮⁭‮‮‫‭‏​⁬​​‭‎⁫‭‫‎⁪⁫⁮‍⁪‏‮​⁫‌‎‏‎⁪‏‭‍‌‮⁪‮‮(AssemblyLoader.\u202E⁭‬‭‏⁬‌‪‏‪‫‎‌​⁬‎⁫‫⁪⁭​‏⁭‭‭‭‫‬‮‪⁮⁬‌‏‭⁯⁫⁪‫‎‮(AssemblyLoader.\u202C⁯⁬‪⁫​⁫⁭‎‏‮​⁮‏⁯⁭​⁫⁯‎‭⁪‬‭⁭​⁬‏⁭‬⁫⁫‏‮‮‬‫​⁯‭‮(requestedAssemblyName))))
      {
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        name = AssemblyLoader.\u202A⁯‍⁭‬‏‭‎⁯‮‏‎‫‏⁯‪⁪‫⁮⁭‬‬‭‭‬‍⁮‪‪‬⁫⁮‍⁯‏⁫⁫‬‬‬‮("{0}.{1}", (object) AssemblyLoader.\u202E⁭‬‭‏⁬‌‪‏‪‫‎‌​⁬‎⁫‫⁪⁭​‏⁭‭‭‭‫‬‮‪⁮⁬‌‏‭⁯⁫⁪‫‎‮(AssemblyLoader.\u202C⁯⁬‪⁫​⁫⁭‎‏‮​⁮‏⁯⁭​⁫⁯‎‭⁪‬‭⁭​⁬‏⁭‬⁫⁫‏‮‮‬‫​⁯‭‮(requestedAssemblyName)), (object) name);
      }
      // ISSUE: reference to a compiler-generated method
      Stream stream1 = AssemblyLoader.LoadStream(assemblyNames, name);
      byte[] numArray1;
      try
      {
        if (stream1 == null)
          return (Assembly) null;
        // ISSUE: reference to a compiler-generated method
        numArray1 = AssemblyLoader.ReadStream(stream1);
      }
      finally
      {
        if (stream1 != null)
        {
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206E‏​‮‮‏‏​‍‍‍‭⁪⁬‪‮​‍⁪‫⁪‬⁫‌‮‪⁬⁬‭‫⁬‍⁭⁪‪‭⁮⁯‎‮‮((IDisposable) stream1);
        }
      }
      // ISSUE: reference to a compiler-generated method
      Stream stream2 = AssemblyLoader.LoadStream(symbolNames, name);
      try
      {
        if (stream2 != null)
        {
          // ISSUE: reference to a compiler-generated method
          byte[] numArray2 = AssemblyLoader.ReadStream(stream2);
          // ISSUE: reference to a compiler-generated method
          return AssemblyLoader.\u206B‎⁯‎⁭‎‎⁪‍‪⁭‎‏⁮‮‫⁫‪⁭‎‍⁭⁬‎⁭‌⁫⁫‭⁮⁯⁭⁯⁭‬‮⁪‬‏‫‮(numArray1, numArray2);
        }
      }
      finally
      {
        if (stream2 != null)
        {
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206E‏​‮‮‏‏​‍‍‍‭⁪⁬‪‮​‍⁪‫⁪‬⁫‌‮‪⁬⁬‭‫⁬‍⁭⁪‪‭⁮⁯‎‮‮((IDisposable) stream2);
        }
      }
      // ISSUE: reference to a compiler-generated method
      return AssemblyLoader.\u206B‎⁫‏‫‮‮⁪⁪‌‏‫⁬‮⁫⁪⁯⁬⁬⁬‭​‪​‏​⁫‏⁮⁭⁫‌⁪‮‎‮‏‪⁭⁬‮(numArray1);
    }

    public static Assembly ResolveAssembly(string assemblyName)
    {
      // ISSUE: reference to a compiler-generated field
      if (AssemblyLoader.nullCache.ContainsKey(assemblyName))
        return (Assembly) null;
      // ISSUE: reference to a compiler-generated method
      AssemblyName assemblyName1 = AssemblyLoader.\u202D⁮‎‪‮​⁫⁮‍‏‬⁮⁫‍‭⁭⁪‏‍⁪⁯‫‌⁯​‌⁬‎‫⁪‫⁮⁮‎⁮​​⁪⁫⁯‮(assemblyName);
      // ISSUE: reference to a compiler-generated method
      Assembly assembly1 = AssemblyLoader.ReadExistingAssembly(assemblyName1);
      if ((object) assembly1 != null)
        return assembly1;
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated method
      Assembly assembly2 = AssemblyLoader.ReadFromEmbeddedResources(AssemblyLoader.assemblyNames, AssemblyLoader.symbolNames, assemblyName1);
      if ((object) assembly2 == null)
      {
        // ISSUE: reference to a compiler-generated field
        AssemblyLoader.nullCache.Add(assemblyName, true);
        // ISSUE: reference to a compiler-generated method
        if (AssemblyLoader.\u202B⁭⁯‮‫‪⁬‍⁬⁮‪⁯⁪​⁯⁮⁫‏‍⁯‌‭⁫⁭⁪‮⁮⁫‏‭‬‮‎‍⁫⁯‬​‍‮(assemblyName1) == AssemblyNameFlags.Retargetable)
        {
          // ISSUE: reference to a compiler-generated method
          assembly2 = AssemblyLoader.\u206F⁪‏⁭‏⁫‫‪‍⁭⁫‍⁬‪⁮‎⁯​‬⁮‭⁮​⁬‭‮‌‌⁫​⁬‭⁬‬⁯⁬‫⁪‭‭‮(assemblyName1);
        }
      }
      return assembly2;
    }

    static AssemblyLoader() => AssemblyLoader.assemblyNames.Add("newtonsoft.json", "costura.newtonsoft.json.dll.zip");

    private static Assembly \u003CAttach\u003Eb__0(object s, ResolveEventArgs e) => AssemblyLoader.ResolveAssembly(AssemblyLoader.\u202E⁬​‌⁮‭‍⁮‬⁫‪‫‍⁯‭‮⁪‭‌‌‮‎⁫⁭‬⁫‍‬⁭‎‮⁬⁮‏⁫‪‌⁮⁪‌‮(e));

    public static void Attach() => AssemblyLoader.\u200E‮‍‎⁮⁬‪⁭⁫⁭‎⁫‮‫⁫⁫‫⁪‪‌⁭‌‎⁮​‌‪‬⁮⁬‭⁭​⁫‎‍⁯‎‏‮‮(AssemblyLoader.\u200E‍‍‮‎⁪⁮⁭‬⁮⁬⁯⁫‎⁯⁯‏⁭‮‌⁬‬‍⁪⁪‬‏⁬‎‎‮‪‫⁪⁬⁫‌‍⁫‍‮(), (ResolveEventHandler) ((s, e) => AssemblyLoader.ResolveAssembly(AssemblyLoader.\u202E⁬​‌⁮‭‍⁮‬⁫‪‫‍⁯‭‮⁪‭‌‌‮‎⁫⁭‬⁫‍‬⁭‎‮⁬⁮‏⁫‪‌⁮⁪‌‮(e))));

    static string \u202E⁭‬‭‏⁬‌‪‏‪‫‎‌​⁬‎⁫‫⁪⁭​‏⁭‭‭‭‫‬‮‪⁮⁬‌‏‭⁯⁫⁪‫‎‮([In] CultureInfo obj0) => obj0.Name;

    static AppDomain \u200E‍‍‮‎⁪⁮⁭‬⁮⁬⁯⁫‎⁯⁯‏⁭‮‌⁬‬‍⁪⁪‬‏⁬‎‎‮‪‫⁪⁬⁫‌‍⁫‍‮() => AppDomain.CurrentDomain;

    static Assembly[] \u200F‮⁭‌⁪⁬⁬‭‪⁬‬‫‬⁪⁬​‪‪‏‮‏⁫⁭‭‭‬⁭⁫⁮‮‎‬‬‌‪⁫‌‬⁪‮‮([In] AppDomain obj0) => obj0.GetAssemblies();

    static AssemblyName \u200F⁪​‮⁫⁮‬‪‍‫‪‮‍‮⁯⁫‏⁯‎‏⁮‭‌⁭‬‪⁯⁫‏⁯‫​‎⁮⁪⁯​⁫‍‏‮([In] Assembly obj0) => obj0.GetName();

    static string \u200C⁬⁭‫‭‎‬⁭‪⁭⁮‍‎‬‫‌‭‫‌‏‮⁮⁫‮‫⁫‭⁬​⁪‌​‪‫‏⁭‏‍⁬⁭‮([In] AssemblyName obj0) => obj0.Name;

    static bool \u206E‎‭⁭​​‎‫‮‍‍‪⁪‫⁮‍‫⁫‎⁫⁮‮⁯‏⁯⁭‏‎⁪⁪​⁫‮⁮‏‫⁪‮‮⁫‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return string.Equals(obj0, obj1, obj2);
    }

    static CultureInfo \u202C⁯⁬‪⁫​⁫⁭‎‏‮​⁮‏⁯⁭​⁫⁯‎‭⁪‬‭⁭​⁬‏⁭‬⁫⁫‏‮‮‬‫​⁯‭‮([In] AssemblyName obj0) => obj0.CultureInfo;

    static void \u200B⁬​​‎‍‍‮⁫⁮‮⁪⁯⁪⁮‫​⁫‮‮⁪‍‮‌‍‎‌⁮⁯⁯‬‪⁭‭‮⁯⁮‪⁫‎‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static int \u206E‎​⁪⁬⁮‬⁮‎‪‍⁭⁯‪⁮‫‬⁪⁬‍⁫‍‭‭‮‪⁪⁪‪‫⁬‪‎⁮⁮⁮‌⁮‍‎‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static Assembly \u202A​‍‍‍‏‭‬​‮‎‏​⁯⁪⁬‫‬‫‌⁮⁮⁮⁪⁭​‎⁫‬‫‬‬⁮‭‏⁪⁮⁫‌‭‮() => Assembly.GetExecutingAssembly();

    static bool \u202C‬‏​⁮‎‍⁫⁮‍​⁮‪‬​⁬‭‭‍‏⁭⁮‮⁮⁭⁯⁫‏‌⁯⁬‫​⁭​⁬⁯‬⁫⁮‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static Stream \u200B‌‫⁬⁯‮⁯‫‍‬​‮‭‌‫⁯⁫‪⁬⁮⁮​‍‫‭‍​⁮‌⁪⁪‏⁪‬⁯⁪‬‍‍⁫‮([In] Assembly obj0, [In] string obj1) => obj0.GetManifestResourceStream(obj1);

    static DeflateStream \u202E⁬‬‮‎​‏‪‮‭‬‭‌⁬‭‍‍‫‭⁬‭‎⁪⁫⁫‎⁫‌⁬‎⁮⁮⁫​​‫⁬‎‎⁪‮(
      [In] Stream obj0,
      [In] CompressionMode obj1)
    {
      return new DeflateStream(obj0, obj1);
    }

    static MemoryStream \u202C‮‌‬​⁭‫‪‬‍⁮‌⁮⁮⁯⁪‏‏⁪‫‬‍‏‎⁯⁫⁯‮‏‫‌‪‫⁮⁯‌‮⁫⁭‍‮() => new MemoryStream();

    static void \u202C⁫⁪‏⁬⁬⁬⁪‪⁭‬⁬‬‬⁬⁪​‏‎⁬‪‍⁭‪‍⁭​‌‮⁭⁬⁪‬⁭‮‌‪​‫‪‮([In] Stream obj0, [In] long obj1) => obj0.Position = obj1;

    static void \u206E‏​‮‮‏‏​‍‍‍‭⁪⁬‪‮​‍⁪‫⁪‬⁫‌‮‪⁬⁬‭‫⁬‍⁭⁪‪‭⁮⁯‎‮‮([In] IDisposable obj0) => obj0.Dispose();

    static long \u202B‮‏‮⁬‮⁪⁯⁭⁯‫⁮‫‭⁭‬‎‪‪‍⁫‮‍‮‌⁮⁯‏‭⁬​​⁯‎⁮⁬‫‭‪‮([In] Stream obj0) => obj0.Length;

    static string \u206A‬​‌​⁭‍⁬​‬‌‮‏‭‬‮‍‫‎⁪‎⁫‌‪⁫‌‍‪‏‏‏⁫​⁪​‍‎‫⁭‎‮([In] string obj0) => obj0.ToLowerInvariant();

    static bool \u202B‍‮⁭‮‮‫‭‏​⁬​​‭‎⁫‭‫‎⁪⁫⁮‍⁪‏‮​⁫‌‎‏‎⁪‏‭‍‌‮⁪‮‮([In] string obj0) => string.IsNullOrEmpty(obj0);

    static string \u202A⁯‍⁭‬‏‭‎⁯‮‏‎‫‏⁯‪⁪‫⁮⁭‬‬‭‭‬‍⁮‪‪‬⁫⁮‍⁯‏⁫⁫‬‬‬‮(
      [In] string obj0,
      [In] object obj1,
      [In] object obj2)
    {
      return string.Format(obj0, obj1, obj2);
    }

    static Assembly \u206B‎⁯‎⁭‎‎⁪‍‪⁭‎‏⁮‮‫⁫‪⁭‎‍⁭⁬‎⁭‌⁫⁫‭⁮⁯⁭⁯⁭‬‮⁪‬‏‫‮([In] byte[] obj0, [In] byte[] obj1) => Assembly.Load(obj0, obj1);

    static Assembly \u206B‎⁫‏‫‮‮⁪⁪‌‏‫⁬‮⁫⁪⁯⁬⁬⁬‭​‪​‏​⁫‏⁮⁭⁫‌⁪‮‎‮‏‪⁭⁬‮([In] byte[] obj0) => Assembly.Load(obj0);

    static AssemblyName \u202D⁮‎‪‮​⁫⁮‍‏‬⁮⁫‍‭⁭⁪‏‍⁪⁯‫‌⁯​‌⁬‎‫⁪‫⁮⁮‎⁮​​⁪⁫⁯‮([In] string obj0) => new AssemblyName(obj0);

    static AssemblyNameFlags \u202B⁭⁯‮‫‪⁬‍⁬⁮‪⁯⁪​⁯⁮⁫‏‍⁯‌‭⁫⁭⁪‮⁮⁫‏‭‬‮‎‍⁫⁯‬​‍‮(
      [In] AssemblyName obj0)
    {
      return obj0.Flags;
    }

    static Assembly \u206F⁪‏⁭‏⁫‫‪‍⁭⁫‍⁬‪⁮‎⁯​‬⁮‭⁮​⁬‭‮‌‌⁫​⁬‭⁬‬⁯⁬‫⁪‭‭‮([In] AssemblyName obj0) => Assembly.Load(obj0);

    static string \u202E⁬​‌⁮‭‍⁮‬⁫‪‫‍⁯‭‮⁪‭‌‌‮‎⁫⁭‬⁫‍‬⁭‎‮⁬⁮‏⁫‪‌⁮⁪‌‮([In] ResolveEventArgs obj0) => obj0.Name;

    static void \u200E‮‍‎⁮⁬‪⁭⁫⁭‎⁫‮‫⁫⁫‫⁪‪‌⁭‌‎⁮​‌‪‬⁮⁬‭⁭​⁫‎‍⁯‎‏‮‮(
      [In] AppDomain obj0,
      [In] ResolveEventHandler obj1)
    {
      obj0.AssemblyResolve += obj1;
    }
  }
}
