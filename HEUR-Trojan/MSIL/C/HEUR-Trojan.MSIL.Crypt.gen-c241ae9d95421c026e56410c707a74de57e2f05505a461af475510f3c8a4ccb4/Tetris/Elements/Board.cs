// Decompiled with JetBrains decompiler
// Type: Tetris.Elements.Board
// Assembly: IPropertyVa, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C23A2FEC-DAFF-46A7-87BE-130D61523A70
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-c241ae9d95421c026e56410c707a74de57e2f05505a461af475510f3c8a4ccb4.exe

using Game.Elements;
using System.Drawing;

namespace Tetris.Elements
{
  public class Board : Sprite
  {
    private Image[] _blocks;

    public Board(Resources resources)
      : base((Image) null, Point.Empty)
    {
      this.Block_Size = new Size(40, 40);
      this.Grid_Size = new Size(10, 15);
      Size gridSize = this.Grid_Size;
      int width = gridSize.Width;
      gridSize = this.Grid_Size;
      int height = gridSize.Height;
      this.Matrix = new int[width, height];
      this._blocks = new Image[7]
      {
        resources.Block_Blue,
        resources.Block_Cyan,
        resources.Block_Green,
        resources.Block_Orange,
        resources.Block_Red,
        resources.Block_Violet,
        resources.Block_Yellow
      };
    }

    public Size Block_Size { get; private set; }

    public Size Grid_Size { get; private set; }

    private int[,] Matrix { get; set; }

    public int Lines { get; set; }

    public bool HasBlock(Point location)
    {
label_1:
      int num1 = 1094162408;
      bool flag1;
      while (true)
      {
        uint num2;
        bool flag2;
        Size gridSize;
        int num3;
        switch ((num2 = (uint) (num1 ^ 1314522207)) % 9U)
        {
          case 0:
            flag1 = true;
            num1 = (int) num2 * 594576767 ^ -219022009;
            continue;
          case 1:
            int y = location.Y;
            gridSize = this.Grid_Size;
            int height = gridSize.Height;
            if (y < height)
            {
              num1 = (int) num2 * 79756650 ^ 2134102062;
              continue;
            }
            num3 = 1;
            break;
          case 3:
            num1 = (int) num2 * 804044146 ^ -738802190;
            continue;
          case 4:
            flag1 = this.Matrix[location.X, location.Y] > 0;
            num1 = 794721256;
            continue;
          case 5:
            int num4 = flag2 ? -980499037 : (num4 = -2002603824);
            num1 = num4 ^ (int) num2 * 1918037369;
            continue;
          case 6:
            num1 = (int) num2 * -658489878 ^ -1354252210;
            continue;
          case 7:
            goto label_1;
          case 8:
            int x = location.X;
            gridSize = this.Grid_Size;
            int width = gridSize.Width;
            num3 = x >= width ? 1 : 0;
            break;
          default:
            goto label_13;
        }
        flag2 = num3 != 0;
        num1 = 221001320;
      }
label_13:
      return flag1;
    }

    public void Add_Block(Block block)
    {
label_1:
      int num1 = -393108618;
      int index1;
      bool flag1;
      int index2;
      bool flag2;
      Point point;
      int num2;
      bool flag3;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num1 ^ -1574547332)) % 19U)
        {
          case 0:
            num1 = -1628508169;
            continue;
          case 1:
            flag2 = block == null;
            num1 = (int) num3 * -1879101363 ^ 2050387179;
            continue;
          case 2:
            num2 = block.Matrix[index2, index1];
            int num4 = num2 > 0 ? -375128346 : (num4 = -1329537704);
            num1 = num4 ^ (int) num3 * -1959471127;
            continue;
          case 3:
            goto label_1;
          case 4:
            index1 = 0;
            num1 = -1491410079;
            continue;
          case 5:
            point = new Point(index1 + block.Location.X, index2 + block.Location.Y);
            num1 = (int) num3 * 607290576 ^ -180865008;
            continue;
          case 6:
            flag3 = index2 < block.Matrix_Size.Height;
            num1 = -1254739313;
            continue;
          case 7:
            int num5 = !flag2 ? 1441921591 : (num5 = 736569749);
            num1 = num5 ^ (int) num3 * 874201788;
            continue;
          case 8:
            num1 = -920068466;
            continue;
          case 9:
            int num6 = !flag1 ? 1037226438 : (num6 = 1260120606);
            num1 = num6 ^ (int) num3 * -771241735;
            continue;
          case 10:
            ++index1;
            num1 = (int) num3 * 795111893 ^ 1269801630;
            continue;
          case 11:
            this.Matrix[point.X, point.Y] = num2;
            num1 = (int) num3 * -305116064 ^ -2061988454;
            continue;
          case 12:
            goto label_3;
          case 13:
            flag1 = index1 < block.Matrix_Size.Width;
            num1 = -1787029388;
            continue;
          case 14:
            ++index2;
            num1 = (int) num3 * -525548141 ^ 1700941706;
            continue;
          case 15:
            index2 = 0;
            num1 = -304608516;
            continue;
          case 16:
            num1 = (int) num3 * -1270133753 ^ -1948596535;
            continue;
          case 17:
            int num7 = !flag3 ? 623614233 : (num7 = 2084540451);
            num1 = num7 ^ (int) num3 * 2111028865;
            continue;
          case 18:
            num1 = (int) num3 * 327865421 ^ 1095235712;
            continue;
          default:
            goto label_21;
        }
      }
label_3:
      return;
label_21:;
    }

    public void Rotate(Block block, int value)
    {
      if (block != null)
        goto label_7;
label_1:
      int num1 = 83214214;
label_2:
      Point location1;
      Size matrixSize1;
      Size matrixSize2;
      bool flag1;
      bool flag2;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 416683708)) % 19U)
        {
          case 0:
            flag2 = this.BlockCollition(block, Point.Empty);
            num1 = (int) num2 * -133699057 ^ -1002854533;
            continue;
          case 1:
            matrixSize1 = block.Matrix_Size;
            num1 = (int) num2 * -352988066 ^ -1360789617;
            continue;
          case 2:
            num1 = 1941454897;
            continue;
          case 3:
            block.Rotate(value * -1);
            num1 = (int) num2 * 1022030518 ^ -1601727655;
            continue;
          case 4:
            num1 = (int) num2 * -479726756 ^ 1175080295;
            continue;
          case 5:
            num1 = (int) num2 * 1299890628 ^ 1421937504;
            continue;
          case 6:
            flag1 = this.BlockCollition(block, Point.Empty);
            num1 = (int) num2 * -639549186 ^ 743298340;
            continue;
          case 7:
            goto label_7;
          case 8:
            block.Location = location1;
            num1 = (int) num2 * 500728453 ^ -775302437;
            continue;
          case 9:
            num1 = (int) num2 * 1799209348 ^ 1787066451;
            continue;
          case 10:
            goto label_3;
          case 11:
            matrixSize2 = block.Matrix_Size;
            block.Rotate(value);
            num1 = (int) num2 * 386433163 ^ -2116740481;
            continue;
          case 12:
            num1 = (int) num2 * -140414391 ^ 951670203;
            continue;
          case 13:
            int num3 = flag1 ? -1098982719 : (num3 = -593260645);
            num1 = num3 ^ (int) num2 * 1718610588;
            continue;
          case 14:
            num1 = (int) num2 * 1737097124 ^ 1876700486;
            continue;
          case 15:
            Block block1 = block;
            Point location2 = block.Location;
            int x = location2.X - (matrixSize1.Width - matrixSize2.Width);
            location2 = block.Location;
            int y = location2.Y;
            Point point = new Point(x, y);
            block1.Location = point;
            num1 = (int) num2 * 152951509 ^ 1917095382;
            continue;
          case 16:
            goto label_1;
          case 17:
            int num4 = flag2 ? -878756309 : (num4 = -1903540969);
            num1 = num4 ^ (int) num2 * -1255713413;
            continue;
          case 18:
            num1 = (int) num2 * 1350154701 ^ 1066550377;
            continue;
          default:
            goto label_21;
        }
      }
label_3:
      return;
label_21:
      return;
label_7:
      location1 = block.Location;
      num1 = 673206644;
      goto label_2;
    }

    public bool BlockCollition(Block block, Point locationAdjust)
    {
label_1:
      int num1 = 94798321;
      bool flag1;
      Point location1;
      int index1;
      int index2;
      bool flag2;
      bool flag3;
      int num2;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num1 ^ 1250832972)) % 24U)
        {
          case 0:
            flag2 = num2 > 0;
            num1 = (int) num3 * -970563596 ^ 1563251763;
            continue;
          case 1:
            num1 = (int) num3 * -511120827 ^ -2065972431;
            continue;
          case 2:
            flag1 = true;
            num1 = (int) num3 * 394794013 ^ 339385121;
            continue;
          case 3:
            flag1 = false;
            num1 = (int) num3 * -286003138 ^ 1845294416;
            continue;
          case 4:
            goto label_1;
          case 5:
            index2 = 0;
            num1 = 772351497;
            continue;
          case 6:
            num2 = block.Matrix[index2, index1];
            num1 = 943251012;
            continue;
          case 7:
            int num4 = flag3 ? -1301389115 : (num4 = -1018043198);
            num1 = num4 ^ (int) num3 * -1251165215;
            continue;
          case 9:
            index1 = 0;
            num1 = 123904306;
            continue;
          case 10:
            int num5 = !this.HasBlock(location1) ? 125369135 : (num5 = 616381390);
            num1 = num5 ^ (int) num3 * 1929767264;
            continue;
          case 11:
            num1 = (int) num3 * 1426994999 ^ -1657104339;
            continue;
          case 12:
            ref Point local = ref location1;
            Point location2 = block.Location;
            int x = location2.X + index1 + locationAdjust.X;
            location2 = block.Location;
            int y = location2.Y + index2 + locationAdjust.Y;
            local = new Point(x, y);
            num1 = (int) num3 * 1503171772 ^ 191957838;
            continue;
          case 13:
            int num6 = block == null ? -1028298378 : (num6 = -523617431);
            num1 = num6 ^ (int) num3 * -535770272;
            continue;
          case 14:
            num1 = (int) num3 * 1784583514 ^ 1073666248;
            continue;
          case 15:
            num1 = (int) num3 * 150098794 ^ 830241762;
            continue;
          case 16:
            flag3 = index1 < block.Matrix_Size.Width;
            num1 = 886448339;
            continue;
          case 17:
            ++index2;
            num1 = (int) num3 * -1710811345 ^ 1523908086;
            continue;
          case 18:
            flag1 = true;
            num1 = (int) num3 * -1507895426 ^ -669912463;
            continue;
          case 19:
            num1 = 108744472;
            continue;
          case 20:
            ++index1;
            num1 = 1115349228;
            continue;
          case 21:
            int num7;
            num1 = num7 = index2 >= block.Matrix_Size.Height ? 1313021223 : (num7 = 1831181733);
            continue;
          case 22:
            num1 = (int) num3 * 576908467 ^ -2065323530;
            continue;
          case 23:
            int num8 = flag2 ? -1366817884 : (num8 = -503312085);
            num1 = num8 ^ (int) num3 * -693035475;
            continue;
          default:
            goto label_25;
        }
      }
label_25:
      return flag1;
    }

    public void CheckLines()
    {
label_1:
      int num1 = 625634471;
      int index1;
      int index2;
      int index3;
      int index4;
      int num2;
      int lines;
      bool flag1;
      int num3;
      bool flag2;
      while (true)
      {
        uint num4;
        switch ((num4 = (uint) (num1 ^ 366403644)) % 37U)
        {
          case 0:
            num3 += num2 > 0 ? 1 : 0;
            num1 = 646232780;
            continue;
          case 1:
            ++index4;
            num1 = (int) num4 * -559639791 ^ 2103739637;
            continue;
          case 2:
            num1 = (int) num4 * 613897040 ^ 162728360;
            continue;
          case 3:
            num1 = 361727379;
            continue;
          case 4:
            ++index1;
            num1 = (int) num4 * 364381559 ^ 498875633;
            continue;
          case 5:
            num1 = 1976349167;
            continue;
          case 6:
            goto label_1;
          case 7:
            num2 = this.Matrix[index3, index4];
            num1 = (int) num4 * -391136950 ^ -991330924;
            continue;
          case 8:
            --index2;
            num1 = (int) num4 * 852783080 ^ -697862774;
            continue;
          case 9:
            this.Matrix[index1, index2] = 0;
            num1 = 453124671;
            continue;
          case 10:
            num1 = (int) num4 * -1509665934 ^ -1380985603;
            continue;
          case 11:
            int num5;
            num1 = num5 = index3 >= this.Grid_Size.Width ? 1373735783 : (num5 = 673968629);
            continue;
          case 12:
            index2 = index4;
            num1 = (int) num4 * -1273778262 ^ -1049817428;
            continue;
          case 13:
            num1 = (int) num4 * 891335367 ^ -1420082001;
            continue;
          case 14:
            num3 = 0;
            num1 = (int) num4 * -1346195419 ^ -2037500063;
            continue;
          case 15:
            flag1 = index2 > 0;
            num1 = (int) num4 * 1108543633 ^ -1557177329;
            continue;
          case 16:
            this.Matrix[index1, index2] = this.Matrix[index1, index2 - 1];
            num1 = (int) num4 * 885651062 ^ -1557392890;
            continue;
          case 17:
            int num6 = !flag2 ? -1583784861 : (num6 = -674018975);
            num1 = num6 ^ (int) num4 * -482718359;
            continue;
          case 18:
            int num7;
            num1 = num7 = index4 < this.Grid_Size.Height ? 1242257006 : (num7 = 1262401507);
            continue;
          case 19:
            flag2 = index1 < this.Grid_Size.Width;
            num1 = 275208618;
            continue;
          case 20:
            int num8 = num3 == this.Grid_Size.Width ? -1864641401 : (num8 = -1587962050);
            num1 = num8 ^ (int) num4 * 1113443103;
            continue;
          case 21:
            index3 = 0;
            num1 = (int) num4 * -1451224752 ^ -1835198281;
            continue;
          case 22:
            num1 = (int) num4 * -962405205 ^ 1548120998;
            continue;
          case 23:
            int num9;
            num1 = num9 = index2 >= 0 ? 737657733 : (num9 = 871318768);
            continue;
          case 24:
            lines = this.Lines;
            num1 = (int) num4 * -247432171 ^ 507754222;
            continue;
          case 25:
            this.Lines = lines + 1;
            num1 = (int) num4 * 275954407 ^ -505763401;
            continue;
          case 26:
            num1 = 1750282360;
            continue;
          case 27:
            num1 = (int) num4 * 1865025246 ^ 1548463083;
            continue;
          case 28:
            index4 = 0;
            num1 = (int) num4 * -1736712994 ^ 1914103011;
            continue;
          case 29:
            int num10 = flag1 ? -823710386 : (num10 = -1398393503);
            num1 = num10 ^ (int) num4 * -1255510272;
            continue;
          case 30:
            goto label_3;
          case 31:
            num1 = (int) num4 * -100487433 ^ 1976493244;
            continue;
          case 32:
            num1 = 939992001;
            continue;
          case 33:
            num1 = 1368502834;
            continue;
          case 34:
            ++index3;
            num1 = (int) num4 * -1317641090 ^ 1721353137;
            continue;
          case 35:
            index1 = 0;
            num1 = 1879806045;
            continue;
          case 36:
            num1 = (int) num4 * 875444988 ^ -454495290;
            continue;
          default:
            goto label_39;
        }
      }
label_3:
      return;
label_39:;
    }

    public override void Draw(DrawHandler drawHandler)
    {
      int index1 = 0;
label_13:
      int num1 = index1;
      Size size = this.Grid_Size;
      int width1 = size.Width;
      int num2 = num1 < width1 ? 1608278783 : (num2 = 1759093584);
      int index2;
      bool flag1;
      int num3;
      bool flag2;
      Image block;
      Point position;
      while (true)
      {
        uint num4;
        switch ((num4 = (uint) (num2 ^ 2128951190)) % 19U)
        {
          case 0:
            num3 = this.Matrix[index1, index2];
            num2 = (int) num4 * -581528333 ^ -256123659;
            continue;
          case 1:
            num2 = (int) num4 * 341067139 ^ -2041961068;
            continue;
          case 2:
            num2 = (int) num4 * 838354657 ^ 1777401245;
            continue;
          case 3:
            drawHandler.Draw(block, position);
            num2 = (int) num4 * -864082991 ^ 1337075980;
            continue;
          case 4:
            int num5 = flag2 ? -1779955625 : (num5 = -99552492);
            num2 = num5 ^ (int) num4 * 23646944;
            continue;
          case 5:
            int num6 = flag1 ? -1051271105 : (num6 = -467282050);
            num2 = num6 ^ (int) num4 * 63647065;
            continue;
          case 6:
            num2 = 366931224;
            continue;
          case 7:
            block = this._blocks[num3 - 1];
            num2 = (int) num4 * -46323636 ^ 870751092;
            continue;
          case 8:
            goto label_3;
          case 9:
            num2 = (int) num4 * 1571264493 ^ -1270096761;
            continue;
          case 10:
            num2 = 1585640391;
            continue;
          case 11:
            int num7 = index2;
            size = this.Grid_Size;
            int height1 = size.Height;
            flag1 = num7 < height1;
            num2 = 552365387;
            continue;
          case 12:
            num2 = 1608278783;
            continue;
          case 13:
            ++index2;
            num2 = (int) num4 * -677540603 ^ 2060649074;
            continue;
          case 14:
            ++index1;
            num2 = (int) num4 * -1561594982 ^ 863280732;
            continue;
          case 15:
            goto label_13;
          case 16:
            flag2 = num3 > 0;
            num2 = (int) num4 * 1728863825 ^ -263899877;
            continue;
          case 17:
            ref Point local = ref position;
            int num8 = index1;
            size = this.Block_Size;
            int width2 = size.Width;
            int x = num8 * width2;
            int num9 = index2;
            size = this.Block_Size;
            int height2 = size.Height;
            int y = num9 * height2;
            local = new Point(x, y);
            num2 = (int) num4 * 720515242 ^ -1615458236;
            continue;
          case 18:
            index2 = 0;
            num2 = 217454815;
            continue;
          default:
            goto label_21;
        }
      }
label_3:
      return;
label_21:;
    }
  }
}
