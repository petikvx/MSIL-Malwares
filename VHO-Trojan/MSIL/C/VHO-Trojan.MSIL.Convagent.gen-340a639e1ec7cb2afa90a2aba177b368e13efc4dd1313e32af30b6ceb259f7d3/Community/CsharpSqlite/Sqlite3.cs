// Decompiled with JetBrains decompiler
// Type: Community.CsharpSqlite.Sqlite3
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using System;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace Community.CsharpSqlite
{
  public class Sqlite3
  {
    private static Sqlite3.FuncDef[] aAlterTableFuncs;
    private static Sqlite3._aTable[] aTable = new Sqlite3._aTable[1]
    {
      new Sqlite3._aTable("sqlite_stat1", "tbl,idx,stat")
    };
    private static Sqlite3.FuncDef detach_func = new Sqlite3.FuncDef((short) 1, (byte) 1, (byte) 0, (object) null, (Sqlite3.FuncDef) null, new Sqlite3.dxFunc(Sqlite3.detachFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, "sqlite_detach", (Sqlite3.FuncDef) null, (Sqlite3.FuncDestructor) null);
    private static Sqlite3.FuncDef attach_func = new Sqlite3.FuncDef((short) 3, (byte) 1, (byte) 0, (object) null, (Sqlite3.FuncDef) null, new Sqlite3.dxFunc(Sqlite3.attachFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, "sqlite_attach", (Sqlite3.FuncDef) null, (Sqlite3.FuncDestructor) null);
    private static int BITVEC_SZ = 512;
    private static int BITVEC_USIZE = (Sqlite3.BITVEC_SZ - 12) / 4 * 4;
    private const int BITVEC_SZELEM = 8;
    private static int BITVEC_NELEM = Sqlite3.BITVEC_USIZE / 1;
    private static int BITVEC_NBIT = Sqlite3.BITVEC_NELEM * 8;
    private static uint BITVEC_NINT = (uint) (Sqlite3.BITVEC_USIZE / 4);
    private static int BITVEC_MXHASH = (int) (Sqlite3.BITVEC_NINT / 2U);
    private static int BITVEC_NPTR = Sqlite3.BITVEC_USIZE / 4;
    private const string SQLITE_FILE_HEADER = "SQLite format 3\0";
    private const byte PTF_INTKEY = 1;
    private const byte PTF_ZERODATA = 2;
    private const byte PTF_LEAFDATA = 4;
    private const byte PTF_LEAF = 8;
    private const int EXTRA_SIZE = 0;
    private const int READ_LOCK = 1;
    private const int WRITE_LOCK = 2;
    private const byte TRANS_NONE = 0;
    private const byte TRANS_READ = 1;
    private const byte TRANS_WRITE = 2;
    private const int BTCURSOR_MAX_DEPTH = 20;
    private const int CURSOR_INVALID = 0;
    private const int CURSOR_VALID = 1;
    private const int CURSOR_REQUIRESEEK = 2;
    private const int CURSOR_FAULT = 3;
    private const int PTRMAP_ROOTPAGE = 1;
    private const int PTRMAP_FREEPAGE = 2;
    private const int PTRMAP_OVERFLOW1 = 3;
    private const int PTRMAP_OVERFLOW2 = 4;
    private const int PTRMAP_BTREE = 5;
    private static byte[] zMagicHeader = Encoding.UTF8.GetBytes("SQLite format 3\0");
    private static int NN = 1;
    private static int NB = Sqlite3.NN * 2 + 1;
    private static byte[] aBalanceQuickSpace = new byte[13];
    private static long refNULL = 0;
    private const int SQLITE_N_BTREE_META = 10;
    private const int SQLITE_DEFAULT_AUTOVACUUM = 0;
    private const int BTREE_AUTOVACUUM_NONE = 0;
    private const int BTREE_AUTOVACUUM_FULL = 1;
    private const int BTREE_AUTOVACUUM_INCR = 2;
    private const int BTREE_OMIT_JOURNAL = 1;
    private const int BTREE_NO_READLOCK = 2;
    private const int BTREE_MEMORY = 4;
    private const int BTREE_SINGLE = 8;
    private const int BTREE_UNORDERED = 16;
    private const int BTREE_INTKEY = 1;
    private const int BTREE_BLOBKEY = 2;
    private const int BTREE_FREE_PAGE_COUNT = 0;
    private const int BTREE_SCHEMA_VERSION = 1;
    private const int BTREE_FILE_FORMAT = 2;
    private const int BTREE_DEFAULT_CACHE_SIZE = 3;
    private const int BTREE_LARGEST_ROOT_PAGE = 4;
    private const int BTREE_TEXT_ENCODING = 5;
    private const int BTREE_USER_VERSION = 6;
    private const int BTREE_INCR_VACUUM = 7;
    private static object nestingLock = new object();
    private const int tkSEMI = 0;
    private const int tkWS = 1;
    private const int tkOTHER = 2;
    private const int tkEXPLAIN = 3;
    private const int tkCREATE = 4;
    private const int tkTEMP = 5;
    private const int tkTRIGGER = 6;
    private const int tkEND = 7;
    private const int FILE_HEADER_SZ = 16;
    private const string CIPHER = "aes-256-cbc";
    private const int CIPHER_DECRYPT = 0;
    private const int CIPHER_ENCRYPT = 1;
    private static AesManaged Aes = new AesManaged();
    private const int SQLITE_ENCRYPT_WRITE_CTX = 6;
    private const int SQLITE_ENCRYPT_READ_CTX = 7;
    private const int SQLITE_DECRYPT = 3;
    private static string[] azCompileOpt = new string[13]
    {
      "DISABLE_LFS",
      "ENABLE_OVERSIZE_CELL_CHECK",
      "HAS_CODEC",
      "OMIT_AUTHORIZATION",
      "OMIT_DEPRECATED",
      "OMIT_GET_TABLE",
      "OMIT_INCRBLOB",
      "OMIT_LOOKASIDE",
      "OMIT_SHARED_CACHE",
      "OMIT_UTF16",
      "OMIT_VIRTUALTABLE",
      "TEMP_STORE=1",
      "THREADSAFE=0"
    };
    private static StringBuilder zdtTemp = new StringBuilder(100);
    private static StringBuilder zdtBuf = new StringBuilder(100);
    private static Sqlite3.BenignMallocHooks sqlite3Hooks = new Sqlite3.BenignMallocHooks((Sqlite3.void_function) null, (Sqlite3.void_function) null);
    private static Sqlite3.BenignMallocHooks wsdHooks = Sqlite3.sqlite3Hooks;
    private static Sqlite3.compareInfo globInfo = new Sqlite3.compareInfo('*', '?', '[', false);
    private static Sqlite3.compareInfo likeInfoNorm = new Sqlite3.compareInfo('%', '_', char.MinValue, true);
    private static Sqlite3.compareInfo likeInfoAlt = new Sqlite3.compareInfo('%', '_', char.MinValue, false);
    private static char[] hexdigits = new char[16]
    {
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F'
    };
    private static byte[] sqlite3CtypeMap = new byte[256]
    {
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 1,
      (byte) 1,
      (byte) 1,
      (byte) 1,
      (byte) 1,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 1,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 64,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 12,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 10,
      (byte) 10,
      (byte) 10,
      (byte) 10,
      (byte) 10,
      (byte) 10,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 2,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 64,
      (byte) 0,
      (byte) 42,
      (byte) 42,
      (byte) 42,
      (byte) 42,
      (byte) 42,
      (byte) 42,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 34,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64,
      (byte) 64
    };
    private const bool SQLITE_USE_URI = false;
    private static Sqlite3.Sqlite3Config sqlite3Config = new Sqlite3.Sqlite3Config(0, 1, true, false, 2147483646, 100, 500, new Sqlite3.sqlite3_mem_methods(), new Sqlite3.sqlite3_mutex_methods((Sqlite3.dxMutexInit) null, (Sqlite3.dxMutexEnd) null, (Sqlite3.dxMutexAlloc) null, (Sqlite3.dxMutexFree) null, (Sqlite3.dxMutexEnter) null, (Sqlite3.dxMutexTry) null, (Sqlite3.dxMutexLeave) null, (Sqlite3.dxMutexHeld) null, (Sqlite3.dxMutexNotheld) null), new Sqlite3.sqlite3_pcache_methods(), (byte[]) null, 0, 0, 0, (byte[][]) null, 0, 0, (Sqlite3.MemPage) null, 1024, 0, 0, false, 0, 0, 0, 0, 0, (Sqlite3.sqlite3_mutex) null, 0, (Sqlite3.dxLog) null, (object) 0, false);
    private static Sqlite3.FuncDefHash sqlite3GlobalFunctions;
    private static Sqlite3.Token[] sqlite3IntTokens = new Sqlite3.Token[2]
    {
      new Sqlite3.Token("0", 1),
      new Sqlite3.Token("1", 1)
    };
    private static int sqlite3PendingByte = 1073741824;
    public static int[] sqlite3OpcodeProperty;
    private static string zText = new string(new char[540]
    {
      'R',
      'E',
      'I',
      'N',
      'D',
      'E',
      'X',
      'E',
      'D',
      'E',
      'S',
      'C',
      'A',
      'P',
      'E',
      'A',
      'C',
      'H',
      'E',
      'C',
      'K',
      'E',
      'Y',
      'B',
      'E',
      'F',
      'O',
      'R',
      'E',
      'I',
      'G',
      'N',
      'O',
      'R',
      'E',
      'G',
      'E',
      'X',
      'P',
      'L',
      'A',
      'I',
      'N',
      'S',
      'T',
      'E',
      'A',
      'D',
      'D',
      'A',
      'T',
      'A',
      'B',
      'A',
      'S',
      'E',
      'L',
      'E',
      'C',
      'T',
      'A',
      'B',
      'L',
      'E',
      'F',
      'T',
      'H',
      'E',
      'N',
      'D',
      'E',
      'F',
      'E',
      'R',
      'R',
      'A',
      'B',
      'L',
      'E',
      'L',
      'S',
      'E',
      'X',
      'C',
      'E',
      'P',
      'T',
      'R',
      'A',
      'N',
      'S',
      'A',
      'C',
      'T',
      'I',
      'O',
      'N',
      'A',
      'T',
      'U',
      'R',
      'A',
      'L',
      'T',
      'E',
      'R',
      'A',
      'I',
      'S',
      'E',
      'X',
      'C',
      'L',
      'U',
      'S',
      'I',
      'V',
      'E',
      'X',
      'I',
      'S',
      'T',
      'S',
      'A',
      'V',
      'E',
      'P',
      'O',
      'I',
      'N',
      'T',
      'E',
      'R',
      'S',
      'E',
      'C',
      'T',
      'R',
      'I',
      'G',
      'G',
      'E',
      'R',
      'E',
      'F',
      'E',
      'R',
      'E',
      'N',
      'C',
      'E',
      'S',
      'C',
      'O',
      'N',
      'S',
      'T',
      'R',
      'A',
      'I',
      'N',
      'T',
      'O',
      'F',
      'F',
      'S',
      'E',
      'T',
      'E',
      'M',
      'P',
      'O',
      'R',
      'A',
      'R',
      'Y',
      'U',
      'N',
      'I',
      'Q',
      'U',
      'E',
      'R',
      'Y',
      'A',
      'T',
      'T',
      'A',
      'C',
      'H',
      'A',
      'V',
      'I',
      'N',
      'G',
      'R',
      'O',
      'U',
      'P',
      'D',
      'A',
      'T',
      'E',
      'B',
      'E',
      'G',
      'I',
      'N',
      'N',
      'E',
      'R',
      'E',
      'L',
      'E',
      'A',
      'S',
      'E',
      'B',
      'E',
      'T',
      'W',
      'E',
      'E',
      'N',
      'O',
      'T',
      'N',
      'U',
      'L',
      'L',
      'I',
      'K',
      'E',
      'C',
      'A',
      'S',
      'C',
      'A',
      'D',
      'E',
      'L',
      'E',
      'T',
      'E',
      'C',
      'A',
      'S',
      'E',
      'C',
      'O',
      'L',
      'L',
      'A',
      'T',
      'E',
      'C',
      'R',
      'E',
      'A',
      'T',
      'E',
      'C',
      'U',
      'R',
      'R',
      'E',
      'N',
      'T',
      '_',
      'D',
      'A',
      'T',
      'E',
      'D',
      'E',
      'T',
      'A',
      'C',
      'H',
      'I',
      'M',
      'M',
      'E',
      'D',
      'I',
      'A',
      'T',
      'E',
      'J',
      'O',
      'I',
      'N',
      'S',
      'E',
      'R',
      'T',
      'M',
      'A',
      'T',
      'C',
      'H',
      'P',
      'L',
      'A',
      'N',
      'A',
      'L',
      'Y',
      'Z',
      'E',
      'P',
      'R',
      'A',
      'G',
      'M',
      'A',
      'B',
      'O',
      'R',
      'T',
      'V',
      'A',
      'L',
      'U',
      'E',
      'S',
      'V',
      'I',
      'R',
      'T',
      'U',
      'A',
      'L',
      'I',
      'M',
      'I',
      'T',
      'W',
      'H',
      'E',
      'N',
      'W',
      'H',
      'E',
      'R',
      'E',
      'N',
      'A',
      'M',
      'E',
      'A',
      'F',
      'T',
      'E',
      'R',
      'E',
      'P',
      'L',
      'A',
      'C',
      'E',
      'A',
      'N',
      'D',
      'E',
      'F',
      'A',
      'U',
      'L',
      'T',
      'A',
      'U',
      'T',
      'O',
      'I',
      'N',
      'C',
      'R',
      'E',
      'M',
      'E',
      'N',
      'T',
      'C',
      'A',
      'S',
      'T',
      'C',
      'O',
      'L',
      'U',
      'M',
      'N',
      'C',
      'O',
      'M',
      'M',
      'I',
      'T',
      'C',
      'O',
      'N',
      'F',
      'L',
      'I',
      'C',
      'T',
      'C',
      'R',
      'O',
      'S',
      'S',
      'C',
      'U',
      'R',
      'R',
      'E',
      'N',
      'T',
      '_',
      'T',
      'I',
      'M',
      'E',
      'S',
      'T',
      'A',
      'M',
      'P',
      'R',
      'I',
      'M',
      'A',
      'R',
      'Y',
      'D',
      'E',
      'F',
      'E',
      'R',
      'R',
      'E',
      'D',
      'I',
      'S',
      'T',
      'I',
      'N',
      'C',
      'T',
      'D',
      'R',
      'O',
      'P',
      'F',
      'A',
      'I',
      'L',
      'F',
      'R',
      'O',
      'M',
      'F',
      'U',
      'L',
      'L',
      'G',
      'L',
      'O',
      'B',
      'Y',
      'I',
      'F',
      'I',
      'S',
      'N',
      'U',
      'L',
      'L',
      'O',
      'R',
      'D',
      'E',
      'R',
      'E',
      'S',
      'T',
      'R',
      'I',
      'C',
      'T',
      'O',
      'U',
      'T',
      'E',
      'R',
      'I',
      'G',
      'H',
      'T',
      'R',
      'O',
      'L',
      'L',
      'B',
      'A',
      'C',
      'K',
      'R',
      'O',
      'W',
      'U',
      'N',
      'I',
      'O',
      'N',
      'U',
      'S',
      'I',
      'N',
      'G',
      'V',
      'A',
      'C',
      'U',
      'U',
      'M',
      'V',
      'I',
      'E',
      'W',
      'I',
      'N',
      'I',
      'T',
      'I',
      'A',
      'L',
      'L',
      'Y'
    });
    private static byte[] aHash = new byte[(int) sbyte.MaxValue]
    {
      (byte) 72,
      (byte) 101,
      (byte) 114,
      (byte) 70,
      (byte) 0,
      (byte) 45,
      (byte) 0,
      (byte) 0,
      (byte) 78,
      (byte) 0,
      (byte) 73,
      (byte) 0,
      (byte) 0,
      (byte) 42,
      (byte) 12,
      (byte) 74,
      (byte) 15,
      (byte) 0,
      (byte) 113,
      (byte) 81,
      (byte) 50,
      (byte) 108,
      (byte) 0,
      (byte) 19,
      (byte) 0,
      (byte) 0,
      (byte) 118,
      (byte) 0,
      (byte) 116,
      (byte) 111,
      (byte) 0,
      (byte) 22,
      (byte) 89,
      (byte) 0,
      (byte) 9,
      (byte) 0,
      (byte) 0,
      (byte) 66,
      (byte) 67,
      (byte) 0,
      (byte) 65,
      (byte) 6,
      (byte) 0,
      (byte) 48,
      (byte) 86,
      (byte) 98,
      (byte) 0,
      (byte) 115,
      (byte) 97,
      (byte) 0,
      (byte) 0,
      (byte) 44,
      (byte) 0,
      (byte) 99,
      (byte) 24,
      (byte) 0,
      (byte) 17,
      (byte) 0,
      (byte) 119,
      (byte) 49,
      (byte) 23,
      (byte) 0,
      (byte) 5,
      (byte) 106,
      (byte) 25,
      (byte) 92,
      (byte) 0,
      (byte) 0,
      (byte) 121,
      (byte) 102,
      (byte) 56,
      (byte) 120,
      (byte) 53,
      (byte) 28,
      (byte) 51,
      (byte) 0,
      (byte) 87,
      (byte) 0,
      (byte) 96,
      (byte) 26,
      (byte) 0,
      (byte) 95,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 91,
      (byte) 88,
      (byte) 93,
      (byte) 84,
      (byte) 105,
      (byte) 14,
      (byte) 39,
      (byte) 104,
      (byte) 0,
      (byte) 77,
      (byte) 0,
      (byte) 18,
      (byte) 85,
      (byte) 107,
      (byte) 32,
      (byte) 0,
      (byte) 117,
      (byte) 76,
      (byte) 109,
      (byte) 58,
      (byte) 46,
      (byte) 80,
      (byte) 0,
      (byte) 0,
      (byte) 90,
      (byte) 40,
      (byte) 0,
      (byte) 112,
      (byte) 0,
      (byte) 36,
      (byte) 0,
      (byte) 0,
      (byte) 29,
      (byte) 0,
      (byte) 82,
      (byte) 59,
      (byte) 60,
      (byte) 0,
      (byte) 20,
      (byte) 57,
      (byte) 0,
      (byte) 52
    };
    private static byte[] aNext = new byte[121]
    {
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 4,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 2,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 13,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 7,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 33,
      (byte) 0,
      (byte) 21,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 43,
      (byte) 3,
      (byte) 47,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 30,
      (byte) 0,
      (byte) 54,
      (byte) 0,
      (byte) 38,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 1,
      (byte) 62,
      (byte) 0,
      (byte) 0,
      (byte) 63,
      (byte) 0,
      (byte) 41,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 61,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 31,
      (byte) 55,
      (byte) 16,
      (byte) 34,
      (byte) 10,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 11,
      (byte) 68,
      (byte) 75,
      (byte) 0,
      (byte) 8,
      (byte) 0,
      (byte) 100,
      (byte) 94,
      (byte) 0,
      (byte) 103,
      (byte) 0,
      (byte) 83,
      (byte) 0,
      (byte) 71,
      (byte) 0,
      (byte) 0,
      (byte) 110,
      (byte) 27,
      (byte) 37,
      (byte) 69,
      (byte) 79,
      (byte) 0,
      (byte) 35,
      (byte) 64,
      (byte) 0,
      (byte) 0
    };
    private static byte[] aLen = new byte[121]
    {
      (byte) 7,
      (byte) 7,
      (byte) 5,
      (byte) 4,
      (byte) 6,
      (byte) 4,
      (byte) 5,
      (byte) 3,
      (byte) 6,
      (byte) 7,
      (byte) 3,
      (byte) 6,
      (byte) 6,
      (byte) 7,
      (byte) 7,
      (byte) 3,
      (byte) 8,
      (byte) 2,
      (byte) 6,
      (byte) 5,
      (byte) 4,
      (byte) 4,
      (byte) 3,
      (byte) 10,
      (byte) 4,
      (byte) 6,
      (byte) 11,
      (byte) 6,
      (byte) 2,
      (byte) 7,
      (byte) 5,
      (byte) 5,
      (byte) 9,
      (byte) 6,
      (byte) 9,
      (byte) 9,
      (byte) 7,
      (byte) 10,
      (byte) 10,
      (byte) 4,
      (byte) 6,
      (byte) 2,
      (byte) 3,
      (byte) 9,
      (byte) 4,
      (byte) 2,
      (byte) 6,
      (byte) 5,
      (byte) 6,
      (byte) 6,
      (byte) 5,
      (byte) 6,
      (byte) 5,
      (byte) 5,
      (byte) 7,
      (byte) 7,
      (byte) 7,
      (byte) 3,
      (byte) 2,
      (byte) 4,
      (byte) 4,
      (byte) 7,
      (byte) 3,
      (byte) 6,
      (byte) 4,
      (byte) 7,
      (byte) 6,
      (byte) 12,
      (byte) 6,
      (byte) 9,
      (byte) 4,
      (byte) 6,
      (byte) 5,
      (byte) 4,
      (byte) 7,
      (byte) 6,
      (byte) 5,
      (byte) 6,
      (byte) 7,
      (byte) 5,
      (byte) 4,
      (byte) 5,
      (byte) 6,
      (byte) 5,
      (byte) 7,
      (byte) 3,
      (byte) 7,
      (byte) 13,
      (byte) 2,
      (byte) 2,
      (byte) 4,
      (byte) 6,
      (byte) 6,
      (byte) 8,
      (byte) 5,
      (byte) 17,
      (byte) 12,
      (byte) 7,
      (byte) 8,
      (byte) 8,
      (byte) 2,
      (byte) 4,
      (byte) 4,
      (byte) 4,
      (byte) 4,
      (byte) 4,
      (byte) 2,
      (byte) 2,
      (byte) 6,
      (byte) 5,
      (byte) 8,
      (byte) 5,
      (byte) 5,
      (byte) 8,
      (byte) 3,
      (byte) 5,
      (byte) 5,
      (byte) 6,
      (byte) 4,
      (byte) 9,
      (byte) 3
    };
    private static int[] aOffset = new int[121]
    {
      0,
      2,
      2,
      8,
      9,
      14,
      16,
      20,
      23,
      25,
      25,
      29,
      33,
      36,
      41,
      46,
      48,
      53,
      54,
      59,
      62,
      65,
      67,
      69,
      78,
      81,
      86,
      91,
      95,
      96,
      101,
      105,
      109,
      117,
      122,
      128,
      136,
      142,
      152,
      159,
      162,
      162,
      165,
      167,
      167,
      171,
      176,
      179,
      184,
      189,
      194,
      197,
      203,
      206,
      210,
      217,
      223,
      223,
      223,
      226,
      229,
      233,
      234,
      238,
      244,
      248,
      (int) byte.MaxValue,
      261,
      273,
      279,
      288,
      290,
      296,
      301,
      303,
      310,
      315,
      320,
      326,
      332,
      337,
      341,
      344,
      350,
      354,
      361,
      363,
      370,
      372,
      374,
      383,
      387,
      393,
      399,
      407,
      412,
      412,
      428,
      435,
      442,
      443,
      450,
      454,
      458,
      462,
      466,
      469,
      471,
      473,
      479,
      483,
      491,
      495,
      500,
      508,
      511,
      516,
      521,
      527,
      531,
      536
    };
    private static byte[] aCode = new byte[121]
    {
      (byte) 64,
      (byte) 27,
      (byte) 138,
      (byte) 41,
      (byte) 81,
      (byte) 43,
      (byte) 101,
      (byte) 52,
      (byte) 34,
      (byte) 110,
      (byte) 45,
      (byte) 46,
      (byte) 49,
      (byte) 2,
      (byte) 48,
      (byte) 140,
      (byte) 40,
      (byte) 24,
      (byte) 116,
      (byte) 16,
      (byte) 95,
      (byte) 136,
      (byte) 11,
      (byte) 109,
      (byte) 137,
      (byte) 114,
      (byte) 6,
      (byte) 29,
      (byte) 104,
      (byte) 95,
      (byte) 139,
      (byte) 56,
      (byte) 9,
      (byte) 20,
      (byte) 13,
      (byte) 115,
      (byte) 60,
      (byte) 102,
      (byte) 96,
      (byte) 127,
      (byte) 54,
      (byte) 53,
      (byte) 108,
      (byte) 21,
      (byte) 21,
      (byte) 68,
      (byte) 100,
      (byte) 3,
      (byte) 33,
      (byte) 124,
      (byte) 123,
      (byte) 107,
      (byte) 5,
      (byte) 95,
      (byte) 14,
      (byte) 71,
      (byte) 74,
      (byte) 19,
      (byte) 51,
      (byte) 98,
      (byte) 49,
      (byte) 36,
      (byte) 32,
      (byte) 106,
      (byte) 134,
      (byte) 92,
      (byte) 17,
      (byte) 66,
      (byte) 42,
      (byte) 8,
      (byte) 120,
      (byte) 105,
      (byte) 50,
      (byte) 4,
      (byte) 31,
      (byte) 55,
      (byte) 28,
      (byte) 128,
      (byte) 63,
      (byte) 125,
      (byte) 135,
      (byte) 126,
      (byte) 65,
      (byte) 30,
      (byte) 57,
      (byte) 69,
      (byte) 97,
      (byte) 103,
      (byte) 15,
      (byte) 72,
      (byte) 37,
      (byte) 38,
      (byte) 10,
      (byte) 39,
      (byte) 95,
      (byte) 66,
      (byte) 66,
      (byte) 99,
      (byte) 7,
      (byte) 117,
      (byte) 70,
      (byte) 111,
      (byte) 44,
      (byte) 119,
      (byte) 95,
      (byte) 49,
      (byte) 35,
      (byte) 18,
      (byte) 73,
      (byte) 122,
      (byte) 58,
      (byte) 95,
      (byte) 95,
      (byte) 12,
      (byte) 59,
      (byte) 112,
      (byte) 121,
      (byte) 61,
      (byte) 62,
      (byte) 47,
      (byte) 113
    };
    public const int SQLITE_N_KEYWORD = 121;
    private const int SQLITE_CORE = 1;
    private static Sqlite3.sqlite3_api_routines sqlite3Apis = new Sqlite3.sqlite3_api_routines();
    private static Sqlite3.sqlite3AutoExtList sqlite3Autoext = new Sqlite3.sqlite3AutoExtList(0, (Sqlite3.dxInit[]) null);
    private static Sqlite3.sqlite3AutoExtList wsdAutoext = Sqlite3.sqlite3Autoext;
    public static string sqlite3_version = "3.7.7(C#)";
    private static string sqlite3_temp_directory = "";
    private static int[] aHardLimit = new int[11]
    {
      1000000000,
      1000000000,
      2000,
      1000,
      250,
      25000,
      (int) sbyte.MaxValue,
      10,
      50000,
      999,
      101
    };
    private static Sqlite3.Mem0Global mem0 = new Sqlite3.Mem0Global();
    private const int JOURNAL_CHUNKSIZE = 4096;
    private static Sqlite3.sqlite3_io_methods MemJournalMethods = new Sqlite3.sqlite3_io_methods(1, new Sqlite3.dxClose(Sqlite3.memjrnlClose), new Sqlite3.dxRead(Sqlite3.memjrnlRead), new Sqlite3.dxWrite(Sqlite3.memjrnlWrite), new Sqlite3.dxTruncate(Sqlite3.memjrnlTruncate), new Sqlite3.dxSync(Sqlite3.memjrnlSync), new Sqlite3.dxFileSize(Sqlite3.memjrnlFileSize), (Sqlite3.dxLock) null, (Sqlite3.dxUnlock) null, (Sqlite3.dxCheckReservedLock) null, (Sqlite3.dxFileControl) null, (Sqlite3.dxSectorSize) null, (Sqlite3.dxDeviceCharacteristics) null, (Sqlite3.dxShmMap) null, (Sqlite3.dxShmLock) null, (Sqlite3.dxShmBarrier) null, (Sqlite3.dxShmUnmap) null);
    private static Sqlite3.sqlite3_mutex mutex = (Sqlite3.sqlite3_mutex) null;
    public const int OP_Goto = 1;
    public const int OP_Gosub = 2;
    public const int OP_Return = 3;
    public const int OP_Yield = 4;
    public const int OP_HaltIfNull = 5;
    public const int OP_Halt = 6;
    public const int OP_Integer = 7;
    public const int OP_Int64 = 8;
    public const int OP_Real = 130;
    public const int OP_String8 = 94;
    public const int OP_String = 9;
    public const int OP_Null = 10;
    public const int OP_Blob = 11;
    public const int OP_Variable = 12;
    public const int OP_Move = 13;
    public const int OP_Copy = 14;
    public const int OP_SCopy = 15;
    public const int OP_ResultRow = 16;
    public const int OP_Concat = 91;
    public const int OP_Add = 86;
    public const int OP_Subtract = 87;
    public const int OP_Multiply = 88;
    public const int OP_Divide = 89;
    public const int OP_Remainder = 90;
    public const int OP_CollSeq = 17;
    public const int OP_Function = 18;
    public const int OP_BitAnd = 82;
    public const int OP_BitOr = 83;
    public const int OP_ShiftLeft = 84;
    public const int OP_ShiftRight = 85;
    public const int OP_AddImm = 20;
    public const int OP_MustBeInt = 21;
    public const int OP_RealAffinity = 22;
    public const int OP_ToText = 141;
    public const int OP_ToBlob = 142;
    public const int OP_ToNumeric = 143;
    public const int OP_ToInt = 144;
    public const int OP_ToReal = 145;
    public const int OP_Eq = 76;
    public const int OP_Ne = 75;
    public const int OP_Lt = 79;
    public const int OP_Le = 78;
    public const int OP_Gt = 77;
    public const int OP_Ge = 80;
    public const int OP_Permutation = 23;
    public const int OP_Compare = 24;
    public const int OP_Jump = 25;
    public const int OP_And = 69;
    public const int OP_Or = 68;
    public const int OP_Not = 19;
    public const int OP_BitNot = 93;
    public const int OP_If = 26;
    public const int OP_IfNot = 27;
    public const int OP_IsNull = 73;
    public const int OP_NotNull = 74;
    public const int OP_Column = 28;
    public const int OP_Affinity = 29;
    public const int OP_MakeRecord = 30;
    public const int OP_Count = 31;
    public const int OP_Savepoint = 32;
    public const int OP_AutoCommit = 33;
    public const int OP_Transaction = 34;
    public const int OP_ReadCookie = 35;
    public const int OP_SetCookie = 36;
    public const int OP_VerifyCookie = 37;
    public const int OP_OpenRead = 38;
    public const int OP_OpenWrite = 39;
    public const int OP_OpenAutoindex = 40;
    public const int OP_OpenEphemeral = 41;
    public const int OP_OpenPseudo = 42;
    public const int OP_Close = 43;
    public const int OP_SeekLt = 44;
    public const int OP_SeekLe = 45;
    public const int OP_SeekGe = 46;
    public const int OP_SeekGt = 47;
    public const int OP_Seek = 48;
    public const int OP_NotFound = 49;
    public const int OP_Found = 50;
    public const int OP_IsUnique = 51;
    public const int OP_NotExists = 52;
    public const int OP_Sequence = 53;
    public const int OP_NewRowid = 54;
    public const int OP_Insert = 55;
    public const int OP_InsertInt = 56;
    public const int OP_Delete = 57;
    public const int OP_ResetCount = 58;
    public const int OP_RowKey = 59;
    public const int OP_RowData = 60;
    public const int OP_Rowid = 61;
    public const int OP_NullRow = 62;
    public const int OP_Last = 63;
    public const int OP_Sort = 64;
    public const int OP_Rewind = 65;
    public const int OP_Prev = 66;
    public const int OP_Next = 67;
    public const int OP_IdxInsert = 70;
    public const int OP_IdxDelete = 71;
    public const int OP_IdxRowid = 72;
    public const int OP_IdxLT = 81;
    public const int OP_IdxGE = 92;
    public const int OP_Destroy = 95;
    public const int OP_Clear = 96;
    public const int OP_CreateIndex = 97;
    public const int OP_CreateTable = 98;
    public const int OP_ParseSchema = 99;
    public const int OP_LoadAnalysis = 100;
    public const int OP_DropTable = 101;
    public const int OP_DropIndex = 102;
    public const int OP_DropTrigger = 103;
    public const int OP_IntegrityCk = 104;
    public const int OP_RowSetAdd = 105;
    public const int OP_RowSetRead = 106;
    public const int OP_RowSetTest = 107;
    public const int OP_Program = 108;
    public const int OP_Param = 109;
    public const int OP_FkCounter = 110;
    public const int OP_FkIfZero = 111;
    public const int OP_MemMax = 112;
    public const int OP_IfPos = 113;
    public const int OP_IfNeg = 114;
    public const int OP_IfZero = 115;
    public const int OP_AggStep = 116;
    public const int OP_AggFinal = 117;
    public const int OP_Checkpoint = 118;
    public const int OP_JournalMode = 119;
    public const int OP_Vacuum = 120;
    public const int OP_IncrVacuum = 121;
    public const int OP_Expire = 122;
    public const int OP_TableLock = 123;
    public const int OP_VBegin = 124;
    public const int OP_VCreate = 125;
    public const int OP_VDestroy = 126;
    public const int OP_VOpen = 127;
    public const int OP_VFilter = 128;
    public const int OP_VColumn = 129;
    public const int OP_VNext = 131;
    public const int OP_VRename = 132;
    public const int OP_VUpdate = 133;
    public const int OP_Pagecount = 134;
    public const int OP_MaxPgcnt = 135;
    public const int OP_Trace = 136;
    public const int OP_Noop = 137;
    public const int OP_Explain = 138;
    public const int OP_NotUsed_138 = 138;
    public const int OP_NotUsed_139 = 139;
    public const int OP_NotUsed_140 = 140;
    public const int OPFLG_JUMP = 1;
    public const int OPFLG_OUT2_PRERELEASE = 2;
    public const int OPFLG_IN1 = 4;
    public const int OPFLG_IN2 = 8;
    public const int OPFLG_IN3 = 16;
    public const int OPFLG_OUT2 = 32;
    public const int OPFLG_OUT3 = 64;
    public static int[] OPFLG_INITIALIZER = new int[146]
    {
      0,
      1,
      5,
      4,
      4,
      16,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      0,
      36,
      36,
      0,
      0,
      0,
      36,
      4,
      5,
      4,
      0,
      0,
      1,
      5,
      5,
      0,
      0,
      0,
      2,
      0,
      0,
      0,
      2,
      16,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      17,
      17,
      17,
      17,
      8,
      17,
      17,
      17,
      17,
      2,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      0,
      1,
      1,
      1,
      1,
      1,
      76,
      76,
      8,
      0,
      2,
      5,
      5,
      21,
      21,
      21,
      21,
      21,
      21,
      1,
      76,
      76,
      76,
      76,
      76,
      76,
      76,
      76,
      76,
      76,
      1,
      36,
      2,
      2,
      0,
      2,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      69,
      21,
      1,
      2,
      0,
      1,
      8,
      5,
      5,
      5,
      0,
      0,
      0,
      2,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      2,
      1,
      0,
      0,
      2,
      2,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      4,
      4,
      4
    };
    private static Sqlite3.sqlite3_vfs vfsList;
    private static bool isInit = false;
    private const int TIMER_START = 0;
    private const int TIMER_END = 0;
    private const int TIMER_ELAPSED = 0;
    private const bool SQLITE_OS_WIN = true;
    private const bool SQLITE_OS_UNIX = false;
    private const bool SQLITE_OS_OS2 = false;
    private const int MAX_PATH = 260;
    private const int SQLITE_TEMPNAME_SIZE = 310;
    private const int SQLITE_DEFAULT_SECTOR_SIZE = 512;
    private const string SQLITE_TEMP_FILE_PREFIX = "etilqs_";
    private const int NO_LOCK = 0;
    private const int SHARED_LOCK = 1;
    private const int RESERVED_LOCK = 2;
    private const int PENDING_LOCK = 3;
    private const int EXCLUSIVE_LOCK = 4;
    private static int PENDING_BYTE = 1073741824;
    private static int RESERVED_BYTE = Sqlite3.PENDING_BYTE + 1;
    private static int SHARED_FIRST = Sqlite3.PENDING_BYTE + 2;
    private static int SHARED_SIZE = 510;
    private const uint SQLITE_FCNTL_DB_UNCHANGED = 3389603744;
    private const int INVALID_FILE_ATTRIBUTES = -1;
    private static Sqlite3.LockingStrategy lockingStrategy = HelperMethods.IsRunningMediumTrust() ? (Sqlite3.LockingStrategy) new Sqlite3.MediumTrustLockingStrategy() : new Sqlite3.LockingStrategy();
    private static int sqlite3_os_type = 0;
    private const int INVALID_SET_FILE_POINTER = -1;
    public static int MX_CLOSE_ATTEMPT = 3;
    private static Sqlite3.sqlite3_io_methods winIoMethod = new Sqlite3.sqlite3_io_methods(2, new Sqlite3.dxClose(Sqlite3.winClose), new Sqlite3.dxRead(Sqlite3.winRead), new Sqlite3.dxWrite(Sqlite3.winWrite), new Sqlite3.dxTruncate(Sqlite3.winTruncate), new Sqlite3.dxSync(Sqlite3.winSync), new Sqlite3.dxFileSize(Sqlite3.winFileSize), new Sqlite3.dxLock(Sqlite3.winLock), new Sqlite3.dxUnlock(Sqlite3.winUnlock), new Sqlite3.dxCheckReservedLock(Sqlite3.winCheckReservedLock), new Sqlite3.dxFileControl(Sqlite3.winFileControl), new Sqlite3.dxSectorSize(Sqlite3.winSectorSize), new Sqlite3.dxDeviceCharacteristics(Sqlite3.winDeviceCharacteristics), new Sqlite3.dxShmMap(Sqlite3.winShmMap), new Sqlite3.dxShmLock(Sqlite3.winShmLock), new Sqlite3.dxShmBarrier(Sqlite3.winShmBarrier), new Sqlite3.dxShmUnmap(Sqlite3.winShmUnmap));
    private static int MX_DELETION_ATTEMPTS = 5;
    private static Sqlite3.sqlite3_vfs winVfs = new Sqlite3.sqlite3_vfs(3, -1, 260, (Sqlite3.sqlite3_vfs) null, "win32", (object) 0, new Sqlite3.dxOpen(Sqlite3.winOpen), new Sqlite3.dxDelete(Sqlite3.winDelete), new Sqlite3.dxAccess(Sqlite3.winAccess), new Sqlite3.dxFullPathname(Sqlite3.winFullPathname), new Sqlite3.dxDlOpen(Sqlite3.winDlOpen), new Sqlite3.dxDlError(Sqlite3.winDlError), new Sqlite3.dxDlSym(Sqlite3.winDlSym), new Sqlite3.dxDlClose(Sqlite3.winDlClose), new Sqlite3.dxRandomness(Sqlite3.winRandomness), new Sqlite3.dxSleep(Sqlite3.winSleep), new Sqlite3.dxCurrentTime(Sqlite3.winCurrentTime), new Sqlite3.dxGetLastError(Sqlite3.winGetLastError), new Sqlite3.dxCurrentTimeInt64(Sqlite3.winCurrentTimeInt64), (Sqlite3.dxSetSystemCall) null, (Sqlite3.dxGetSystemCall) null, (Sqlite3.dxNextSystemCall) null);
    private const int NO_ERROR = 0;
    private const int PAGER_OPEN = 0;
    private const int PAGER_READER = 1;
    private const int PAGER_WRITER_LOCKED = 2;
    private const int PAGER_WRITER_CACHEMOD = 3;
    private const int PAGER_WRITER_DBMOD = 4;
    private const int PAGER_WRITER_FINISHED = 5;
    private const int PAGER_ERROR = 6;
    private const int UNKNOWN_LOCK = 5;
    private const int MAX_SECTOR_SIZE = 65536;
    private static byte[] aJournalMagic = new byte[8]
    {
      (byte) 217,
      (byte) 213,
      (byte) 5,
      (byte) 249,
      (byte) 32,
      (byte) 161,
      (byte) 99,
      (byte) 215
    };
    private const int PAGER_MAX_PGNO = 2147483647;
    private const int SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT = -1;
    private const int PAGER_OMIT_JOURNAL = 1;
    private const int PAGER_NO_READLOCK = 2;
    private const int PAGER_MEMORY = 4;
    private static int PAGER_LOCKINGMODE_QUERY = -1;
    private static int PAGER_LOCKINGMODE_NORMAL = 0;
    private static int PAGER_LOCKINGMODE_EXCLUSIVE = 1;
    private const int PAGER_JOURNALMODE_QUERY = -1;
    private const int PAGER_JOURNALMODE_DELETE = 0;
    private const int PAGER_JOURNALMODE_PERSIST = 1;
    private const int PAGER_JOURNALMODE_OFF = 2;
    private const int PAGER_JOURNALMODE_TRUNCATE = 3;
    private const int PAGER_JOURNALMODE_MEMORY = 4;
    private const int PAGER_JOURNALMODE_WAL = 5;
    private const int YYNOERRORRECOVERY = 1;
    private const int YYNOCODE = 253;
    private const int YYWILDCARD = 67;
    private const int YYSTACKDEPTH = 100;
    private const int YYNSTATE = 630;
    private const int YYNRULE = 329;
    private const int YYFALLBACK = 1;
    private const int YY_NO_ACTION = 961;
    private const int YY_ACCEPT_ACTION = 960;
    private const int YY_ERROR_ACTION = 959;
    private Sqlite3.YYMINORTYPE yyzerominor = new Sqlite3.YYMINORTYPE();
    private const int YY_ACTTAB_COUNT = 1557;
    private static int[] yy_action = new int[1557]
    {
      313,
      960,
      186,
      419,
      2,
      172,
      627,
      597,
      55,
      55,
      55,
      55,
      48,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      302,
      283,
      623,
      622,
      516,
      515,
      590,
      584,
      55,
      55,
      55,
      55,
      282,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      6,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      608,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      597,
      409,
      330,
      579,
      579,
      32,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      330,
      217,
      620,
      619,
      166,
      411,
      624,
      382,
      379,
      378,
      7,
      491,
      590,
      584,
      200,
      199,
      198,
      58,
      377,
      300,
      414,
      621,
      481,
      66,
      623,
      622,
      621,
      580,
      254,
      601,
      94,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      671,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      532,
      226,
      506,
      507,
      133,
      177,
      139,
      284,
      385,
      279,
      384,
      169,
      197,
      342,
      398,
      251,
      226,
      253,
      275,
      388,
      167,
      139,
      284,
      385,
      279,
      384,
      169,
      570,
      236,
      590,
      584,
      672,
      240,
      275,
      157,
      620,
      619,
      554,
      437,
      51,
      51,
      51,
      50,
      238,
      343,
      439,
      553,
      438,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      465,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      390,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      391,
      166,
      491,
      566,
      382,
      379,
      378,
      409,
      440,
      579,
      579,
      252,
      440,
      607,
      66,
      377,
      513,
      621,
      49,
      46,
      147,
      590,
      584,
      621,
      16,
      466,
      189,
      621,
      441,
      442,
      673,
      526,
      441,
      340,
      577,
      595,
      64,
      194,
      482,
      434,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      30,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      593,
      593,
      593,
      387,
      578,
      606,
      493,
      259,
      351,
      258,
      411,
      1,
      623,
      622,
      496,
      623,
      622,
      65,
      240,
      623,
      622,
      597,
      443,
      237,
      239,
      414,
      341,
      237,
      602,
      590,
      584,
      18,
      603,
      166,
      601,
      87,
      382,
      379,
      378,
      67,
      623,
      622,
      38,
      623,
      622,
      176,
      270,
      377,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      175,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      396,
      233,
      411,
      531,
      565,
      317,
      620,
      619,
      44,
      620,
      619,
      240,
      206,
      620,
      619,
      597,
      266,
      414,
      268,
      409,
      597,
      579,
      579,
      352,
      184,
      505,
      601,
      73,
      533,
      590,
      584,
      466,
      548,
      190,
      620,
      619,
      576,
      620,
      619,
      547,
      383,
      551,
      35,
      332,
      575,
      574,
      600,
      504,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      567,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      411,
      561,
      561,
      528,
      364,
      259,
      351,
      258,
      183,
      361,
      549,
      524,
      374,
      411,
      597,
      414,
      240,
      560,
      560,
      409,
      604,
      579,
      579,
      328,
      601,
      93,
      623,
      622,
      414,
      590,
      584,
      237,
      564,
      559,
      559,
      520,
      402,
      601,
      87,
      409,
      210,
      579,
      579,
      168,
      421,
      950,
      519,
      950,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      192,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      600,
      293,
      563,
      511,
      234,
      357,
      146,
      475,
      475,
      367,
      411,
      562,
      411,
      358,
      542,
      425,
      171,
      411,
      215,
      144,
      620,
      619,
      544,
      318,
      353,
      414,
      203,
      414,
      275,
      590,
      584,
      549,
      414,
      174,
      601,
      94,
      601,
      79,
      558,
      471,
      61,
      601,
      79,
      421,
      949,
      350,
      949,
      34,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      535,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      307,
      424,
      394,
      272,
      49,
      46,
      147,
      349,
      322,
      4,
      411,
      491,
      312,
      321,
      425,
      568,
      492,
      216,
      264,
      407,
      575,
      574,
      429,
      66,
      549,
      414,
      621,
      540,
      602,
      590,
      584,
      13,
      603,
      621,
      601,
      72,
      12,
      618,
      617,
      616,
      202,
      210,
      621,
      546,
      469,
      422,
      319,
      148,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      338,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      600,
      600,
      411,
      39,
      21,
      37,
      170,
      237,
      875,
      411,
      572,
      572,
      201,
      144,
      473,
      538,
      331,
      414,
      474,
      143,
      146,
      630,
      628,
      334,
      414,
      353,
      601,
      68,
      168,
      590,
      584,
      132,
      365,
      601,
      96,
      307,
      423,
      530,
      336,
      49,
      46,
      147,
      568,
      406,
      216,
      549,
      360,
      529,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      411,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      411,
      605,
      414,
      484,
      510,
      172,
      422,
      597,
      318,
      496,
      485,
      601,
      99,
      411,
      142,
      414,
      411,
      231,
      411,
      540,
      411,
      359,
      629,
      2,
      601,
      97,
      426,
      308,
      414,
      590,
      584,
      414,
      20,
      414,
      621,
      414,
      621,
      601,
      106,
      503,
      601,
      105,
      601,
      108,
      601,
      109,
      204,
      28,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      411,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      411,
      597,
      414,
      411,
      276,
      214,
      600,
      411,
      366,
      213,
      381,
      601,
      134,
      274,
      500,
      414,
      167,
      130,
      414,
      621,
      411,
      354,
      414,
      376,
      601,
      135,
      129,
      601,
      100,
      590,
      584,
      601,
      104,
      522,
      521,
      414,
      621,
      224,
      273,
      600,
      167,
      327,
      282,
      600,
      601,
      103,
      468,
      521,
      56,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      411,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      411,
      27,
      414,
      411,
      375,
      276,
      167,
      359,
      544,
      50,
      238,
      601,
      95,
      128,
      223,
      414,
      411,
      165,
      414,
      411,
      621,
      411,
      621,
      612,
      601,
      102,
      372,
      601,
      76,
      590,
      584,
      414,
      570,
      236,
      414,
      470,
      414,
      167,
      621,
      188,
      601,
      98,
      225,
      601,
      138,
      601,
      137,
      232,
      56,
      45,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      411,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      276,
      276,
      414,
      411,
      276,
      544,
      459,
      359,
      171,
      209,
      479,
      601,
      136,
      628,
      334,
      621,
      621,
      125,
      414,
      621,
      368,
      411,
      621,
      257,
      540,
      589,
      588,
      601,
      75,
      590,
      584,
      458,
      446,
      23,
      23,
      124,
      414,
      326,
      325,
      621,
      427,
      324,
      309,
      600,
      288,
      601,
      92,
      586,
      585,
      57,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      411,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      313,
      587,
      411,
      414,
      411,
      207,
      611,
      476,
      171,
      472,
      160,
      123,
      601,
      91,
      323,
      261,
      15,
      414,
      464,
      414,
      411,
      621,
      411,
      354,
      222,
      411,
      601,
      74,
      601,
      90,
      590,
      584,
      159,
      264,
      158,
      414,
      461,
      414,
      621,
      600,
      414,
      121,
      120,
      25,
      601,
      89,
      601,
      101,
      621,
      601,
      88,
      47,
      582,
      581,
      583,
      583,
      54,
      54,
      55,
      55,
      55,
      55,
      544,
      53,
      53,
      53,
      53,
      52,
      52,
      51,
      51,
      51,
      50,
      238,
      43,
      405,
      263,
      3,
      610,
      264,
      140,
      415,
      622,
      24,
      410,
      11,
      456,
      594,
      118,
      155,
      219,
      452,
      408,
      621,
      621,
      621,
      156,
      43,
      405,
      621,
      3,
      286,
      621,
      113,
      415,
      622,
      111,
      445,
      411,
      400,
      557,
      403,
      545,
      10,
      411,
      408,
      264,
      110,
      205,
      436,
      541,
      566,
      453,
      414,
      621,
      621,
      63,
      621,
      435,
      414,
      411,
      621,
      601,
      94,
      403,
      621,
      411,
      337,
      601,
      86,
      150,
      40,
      41,
      534,
      566,
      414,
      242,
      264,
      42,
      413,
      412,
      414,
      600,
      595,
      601,
      85,
      191,
      333,
      107,
      451,
      601,
      84,
      621,
      539,
      40,
      41,
      420,
      230,
      411,
      149,
      316,
      42,
      413,
      412,
      398,
      (int) sbyte.MaxValue,
      595,
      315,
      621,
      399,
      278,
      625,
      181,
      414,
      593,
      593,
      593,
      592,
      591,
      14,
      450,
      411,
      601,
      71,
      240,
      621,
      43,
      405,
      264,
      3,
      615,
      180,
      264,
      415,
      622,
      614,
      414,
      593,
      593,
      593,
      592,
      591,
      14,
      621,
      408,
      601,
      70,
      621,
      417,
      33,
      405,
      613,
      3,
      411,
      264,
      411,
      415,
      622,
      418,
      626,
      178,
      509,
      8,
      403,
      241,
      416,
      126,
      408,
      414,
      621,
      414,
      449,
      208,
      566,
      240,
      221,
      621,
      601,
      83,
      601,
      82,
      599,
      297,
      277,
      296,
      30,
      403,
      31,
      395,
      264,
      295,
      397,
      489,
      40,
      41,
      411,
      566,
      220,
      621,
      294,
      42,
      413,
      412,
      271,
      621,
      595,
      600,
      621,
      59,
      60,
      414,
      269,
      267,
      623,
      622,
      36,
      40,
      41,
      621,
      601,
      81,
      598,
      235,
      42,
      413,
      412,
      621,
      621,
      595,
      265,
      344,
      411,
      248,
      556,
      173,
      185,
      593,
      593,
      593,
      592,
      591,
      14,
      218,
      29,
      621,
      543,
      414,
      305,
      304,
      303,
      179,
      301,
      411,
      566,
      454,
      601,
      80,
      289,
      335,
      593,
      593,
      593,
      592,
      591,
      14,
      411,
      287,
      414,
      151,
      392,
      246,
      260,
      411,
      196,
      195,
      523,
      601,
      69,
      411,
      245,
      414,
      526,
      537,
      285,
      389,
      595,
      621,
      414,
      536,
      601,
      17,
      362,
      153,
      414,
      466,
      463,
      601,
      78,
      154,
      414,
      462,
      152,
      601,
      77,
      355,
      (int) byte.MaxValue,
      621,
      455,
      601,
      9,
      621,
      386,
      444,
      517,
      247,
      621,
      593,
      593,
      593,
      621,
      621,
      244,
      621,
      243,
      430,
      518,
      292,
      621,
      329,
      621,
      145,
      393,
      280,
      513,
      291,
      131,
      621,
      514,
      621,
      621,
      311,
      621,
      259,
      346,
      249,
      621,
      621,
      229,
      314,
      621,
      228,
      512,
      227,
      240,
      494,
      488,
      310,
      164,
      487,
      486,
      373,
      480,
      163,
      262,
      369,
      371,
      162,
      26,
      212,
      478,
      477,
      161,
      141,
      363,
      467,
      122,
      339,
      187,
      119,
      348,
      347,
      117,
      116,
      115,
      114,
      112,
      182,
      457,
      320,
      22,
      433,
      432,
      448,
      19,
      609,
      431,
      428,
      62,
      193,
      596,
      573,
      298,
      555,
      552,
      571,
      404,
      290,
      380,
      498,
      510,
      495,
      306,
      281,
      499,
      250,
      5,
      497,
      460,
      345,
      447,
      569,
      550,
      238,
      299,
      527,
      525,
      508,
      961,
      502,
      501,
      961,
      401,
      961,
      211,
      490,
      356,
      256,
      961,
      483,
      961,
      961,
      961,
      961,
      961,
      961,
      961,
      961,
      961,
      961,
      961,
      370
    };
    private static int[] yy_lookahead = new int[1557]
    {
      19,
      142,
      143,
      144,
      145,
      24,
      1,
      26,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      15,
      98,
      26,
      27,
      7,
      8,
      49,
      50,
      77,
      78,
      79,
      80,
      109,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      22,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      23,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      94,
      112,
      19,
      114,
      115,
      25,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      22,
      94,
      95,
      96,
      150,
      150,
      99,
      100,
      101,
      76,
      150,
      49,
      50,
      105,
      106,
      107,
      54,
      110,
      158,
      165,
      165,
      161,
      162,
      26,
      27,
      165,
      113,
      16,
      174,
      175,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      118,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      23,
      92,
      97,
      98,
      24,
      96,
      97,
      98,
      99,
      100,
      101,
      102,
      25,
      97,
      216,
      60,
      92,
      62,
      109,
      221,
      25,
      97,
      98,
      99,
      100,
      101,
      102,
      86,
      87,
      49,
      50,
      118,
      116,
      109,
      25,
      94,
      95,
      32,
      97,
      88,
      89,
      90,
      91,
      92,
      128,
      104,
      41,
      106,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      11,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      19,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      27,
      96,
      150,
      66,
      99,
      100,
      101,
      112,
      150,
      114,
      115,
      138,
      150,
      161,
      162,
      110,
      103,
      165,
      222,
      223,
      224,
      49,
      50,
      165,
      22,
      57,
      24,
      165,
      170,
      171,
      118,
      94,
      170,
      171,
      23,
      98,
      25,
      185,
      186,
      243,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      126,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      129,
      130,
      131,
      88,
      23,
      172,
      173,
      105,
      106,
      107,
      150,
      22,
      26,
      27,
      181,
      26,
      27,
      22,
      116,
      26,
      27,
      26,
      230,
      231,
      197,
      165,
      230,
      231,
      113,
      49,
      50,
      204,
      117,
      96,
      174,
      175,
      99,
      100,
      101,
      22,
      26,
      27,
      136,
      26,
      27,
      118,
      16,
      110,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      118,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      214,
      215,
      150,
      23,
      23,
      155,
      94,
      95,
      22,
      94,
      95,
      116,
      160,
      94,
      95,
      94,
      60,
      165,
      62,
      112,
      26,
      114,
      115,
      128,
      23,
      36,
      174,
      175,
      88,
      49,
      50,
      57,
      120,
      22,
      94,
      95,
      23,
      94,
      95,
      120,
      51,
      25,
      136,
      169,
      170,
      171,
      194,
      58,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      23,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      150,
      12,
      12,
      23,
      228,
      105,
      106,
      107,
      23,
      233,
      25,
      165,
      19,
      150,
      94,
      165,
      116,
      28,
      28,
      112,
      174,
      114,
      115,
      108,
      174,
      175,
      26,
      27,
      165,
      49,
      50,
      231,
      11,
      44,
      44,
      46,
      46,
      174,
      175,
      112,
      160,
      114,
      115,
      50,
      22,
      23,
      57,
      25,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      119,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      194,
      225,
      23,
      23,
      215,
      19,
      95,
      105,
      106,
      107,
      150,
      23,
      150,
      27,
      23,
      67,
      25,
      150,
      206,
      207,
      94,
      95,
      166,
      104,
      218,
      165,
      22,
      165,
      109,
      49,
      50,
      120,
      165,
      25,
      174,
      175,
      174,
      175,
      23,
      21,
      234,
      174,
      175,
      22,
      23,
      239,
      25,
      25,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      205,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      22,
      23,
      216,
      23,
      222,
      223,
      224,
      63,
      220,
      35,
      150,
      150,
      163,
      220,
      67,
      166,
      167,
      168,
      150,
      169,
      170,
      171,
      161,
      162,
      25,
      165,
      165,
      150,
      113,
      49,
      50,
      25,
      117,
      165,
      174,
      175,
      35,
      7,
      8,
      9,
      160,
      160,
      165,
      120,
      100,
      67,
      247,
      248,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      193,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      194,
      194,
      150,
      135,
      24,
      137,
      35,
      231,
      138,
      150,
      129,
      130,
      206,
      207,
      30,
      27,
      213,
      165,
      34,
      118,
      95,
      0,
      1,
      2,
      165,
      218,
      174,
      175,
      50,
      49,
      50,
      22,
      48,
      174,
      175,
      22,
      23,
      23,
      244,
      222,
      223,
      224,
      166,
      167,
      168,
      120,
      239,
      23,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      150,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      150,
      173,
      165,
      181,
      182,
      24,
      67,
      26,
      104,
      181,
      188,
      174,
      175,
      150,
      39,
      165,
      150,
      52,
      150,
      150,
      150,
      150,
      144,
      145,
      174,
      175,
      249,
      250,
      165,
      49,
      50,
      165,
      52,
      165,
      165,
      165,
      165,
      174,
      175,
      29,
      174,
      175,
      174,
      175,
      174,
      175,
      160,
      22,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      150,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      150,
      94,
      165,
      150,
      150,
      160,
      194,
      150,
      213,
      160,
      52,
      174,
      175,
      23,
      23,
      165,
      25,
      22,
      165,
      165,
      150,
      150,
      165,
      52,
      174,
      175,
      22,
      174,
      175,
      49,
      50,
      174,
      175,
      190,
      191,
      165,
      165,
      240,
      23,
      194,
      25,
      187,
      109,
      194,
      174,
      175,
      190,
      191,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      150,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      150,
      22,
      165,
      150,
      23,
      150,
      25,
      150,
      166,
      91,
      92,
      174,
      175,
      22,
      217,
      165,
      150,
      102,
      165,
      150,
      165,
      150,
      165,
      150,
      174,
      175,
      19,
      174,
      175,
      49,
      50,
      165,
      86,
      87,
      165,
      23,
      165,
      25,
      165,
      24,
      174,
      175,
      187,
      174,
      175,
      174,
      175,
      205,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      150,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      150,
      150,
      165,
      150,
      150,
      166,
      23,
      150,
      25,
      160,
      20,
      174,
      175,
      1,
      2,
      165,
      165,
      104,
      165,
      165,
      43,
      150,
      165,
      240,
      150,
      49,
      50,
      174,
      175,
      49,
      50,
      23,
      23,
      25,
      25,
      53,
      165,
      187,
      187,
      165,
      23,
      187,
      25,
      194,
      205,
      174,
      175,
      71,
      72,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      150,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      98,
      150,
      165,
      150,
      160,
      150,
      59,
      25,
      53,
      104,
      22,
      174,
      175,
      213,
      138,
      5,
      165,
      1,
      165,
      150,
      165,
      150,
      150,
      240,
      150,
      174,
      175,
      174,
      175,
      49,
      50,
      118,
      150,
      35,
      165,
      27,
      165,
      165,
      194,
      165,
      108,
      (int) sbyte.MaxValue,
      76,
      174,
      175,
      174,
      175,
      165,
      174,
      175,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      166,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      19,
      20,
      193,
      22,
      150,
      150,
      150,
      26,
      27,
      76,
      150,
      22,
      1,
      150,
      119,
      121,
      217,
      20,
      37,
      165,
      165,
      165,
      16,
      19,
      20,
      165,
      22,
      205,
      165,
      119,
      26,
      27,
      108,
      128,
      150,
      150,
      150,
      56,
      150,
      22,
      150,
      37,
      150,
      (int) sbyte.MaxValue,
      160,
      23,
      150,
      66,
      193,
      165,
      165,
      165,
      16,
      165,
      23,
      165,
      150,
      165,
      174,
      175,
      56,
      165,
      150,
      65,
      174,
      175,
      15,
      86,
      87,
      88,
      66,
      165,
      140,
      150,
      93,
      94,
      95,
      165,
      194,
      98,
      174,
      175,
      22,
      3,
      164,
      193,
      174,
      175,
      165,
      150,
      86,
      87,
      4,
      180,
      150,
      248,
      251,
      93,
      94,
      95,
      216,
      180,
      98,
      251,
      165,
      221,
      150,
      149,
      6,
      165,
      129,
      130,
      131,
      132,
      133,
      134,
      193,
      150,
      174,
      175,
      116,
      165,
      19,
      20,
      150,
      22,
      149,
      151,
      150,
      26,
      27,
      149,
      165,
      129,
      130,
      131,
      132,
      133,
      134,
      165,
      37,
      174,
      175,
      165,
      149,
      19,
      20,
      13,
      22,
      150,
      150,
      150,
      26,
      27,
      146,
      147,
      151,
      150,
      25,
      56,
      152,
      159,
      154,
      37,
      165,
      165,
      165,
      193,
      160,
      66,
      116,
      193,
      165,
      174,
      175,
      174,
      175,
      194,
      199,
      150,
      200,
      126,
      56,
      124,
      123,
      150,
      201,
      122,
      150,
      86,
      87,
      150,
      66,
      193,
      165,
      202,
      93,
      94,
      95,
      150,
      165,
      98,
      194,
      165,
      125,
      22,
      165,
      150,
      150,
      26,
      27,
      135,
      86,
      87,
      165,
      174,
      175,
      203,
      226,
      93,
      94,
      95,
      165,
      165,
      98,
      150,
      218,
      150,
      193,
      157,
      118,
      157,
      129,
      130,
      131,
      132,
      133,
      134,
      5,
      104,
      165,
      211,
      165,
      10,
      11,
      12,
      13,
      14,
      150,
      66,
      17,
      174,
      175,
      210,
      246,
      129,
      130,
      131,
      132,
      133,
      134,
      150,
      210,
      165,
      31,
      121,
      33,
      150,
      150,
      86,
      87,
      176,
      174,
      175,
      150,
      42,
      165,
      94,
      211,
      210,
      150,
      98,
      165,
      165,
      211,
      174,
      175,
      150,
      55,
      165,
      57,
      150,
      174,
      175,
      61,
      165,
      150,
      64,
      174,
      175,
      150,
      150,
      165,
      150,
      174,
      175,
      165,
      104,
      150,
      184,
      150,
      165,
      129,
      130,
      131,
      165,
      165,
      150,
      165,
      150,
      150,
      176,
      150,
      165,
      47,
      165,
      150,
      150,
      176,
      103,
      150,
      22,
      165,
      178,
      165,
      165,
      179,
      165,
      105,
      106,
      107,
      165,
      165,
      229,
      111,
      165,
      92,
      176,
      229,
      116,
      184,
      176,
      179,
      156,
      176,
      176,
      18,
      157,
      156,
      237,
      45,
      157,
      156,
      135,
      157,
      157,
      238,
      156,
      68,
      157,
      189,
      189,
      139,
      219,
      22,
      157,
      18,
      192,
      192,
      192,
      192,
      189,
      219,
      199,
      157,
      242,
      40,
      157,
      199,
      242,
      153,
      157,
      38,
      245,
      196,
      166,
      232,
      198,
      177,
      177,
      232,
      227,
      209,
      178,
      166,
      182,
      166,
      148,
      177,
      177,
      209,
      196,
      177,
      199,
      209,
      199,
      166,
      208,
      92,
      195,
      174,
      174,
      183,
      252,
      183,
      183,
      252,
      191,
      252,
      235,
      186,
      241,
      241,
      252,
      186,
      252,
      252,
      252,
      252,
      252,
      252,
      252,
      252,
      252,
      252,
      252,
      236
    };
    private const int YY_SHIFT_USE_DFLT = -74;
    private const int YY_SHIFT_COUNT = 418;
    private const int YY_SHIFT_MIN = -73;
    private const int YY_SHIFT_MAX = 1468;
    private static short[] yy_shift_ofst = new short[419]
    {
      (short) 975,
      (short) 1114,
      (short) 1343,
      (short) 1114,
      (short) 1213,
      (short) 1213,
      (short) 90,
      (short) 90,
      (short) 0,
      (short) -19,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 345,
      (short) 445,
      (short) 721,
      (short) 1091,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1236,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 1213,
      (short) 199,
      (short) 445,
      (short) 445,
      (short) 835,
      (short) 835,
      (short) 365,
      (short) 1164,
      (short) 55,
      (short) 647,
      (short) 573,
      (short) 499,
      (short) 425,
      (short) 351,
      (short) 277,
      (short) 203,
      (short) 129,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 795,
      (short) 869,
      (short) 795,
      (short) 943,
      (short) 1017,
      (short) 1017,
      (short) -69,
      (short) -45,
      (short) -45,
      (short) -45,
      (short) -45,
      (short) -45,
      (short) -1,
      (short) 58,
      (short) 138,
      (short) 100,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 537,
      (short) 438,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 365,
      (short) 807,
      (short) 1436,
      (short) -74,
      (short) -74,
      (short) -74,
      (short) 1293,
      (short) 73,
      (short) 434,
      (short) 434,
      (short) 311,
      (short) 314,
      (short) 290,
      (short) 283,
      (short) 286,
      (short) 540,
      (short) 467,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 445,
      (short) 65,
      (short) 722,
      (short) 722,
      (short) 722,
      (short) 688,
      (short) 266,
      (short) 1164,
      (short) 1164,
      (short) 1164,
      (short) -74,
      (short) -74,
      (short) -74,
      (short) 136,
      (short) 168,
      (short) 168,
      (short) 234,
      (short) 360,
      (short) 360,
      (short) 360,
      (short) 430,
      (short) 372,
      (short) 435,
      (short) 352,
      (short) 278,
      (short) 126,
      (short) -36,
      (short) -36,
      (short) -36,
      (short) -36,
      (short) 421,
      (short) 651,
      (short) -36,
      (short) -36,
      (short) 592,
      (short) 292,
      (short) 212,
      (short) 623,
      (short) 158,
      (short) 204,
      (short) 204,
      (short) 505,
      (short) 158,
      (short) 505,
      (short) 144,
      (short) 365,
      (short) 154,
      (short) 365,
      (short) 154,
      (short) 645,
      (short) 154,
      (short) 204,
      (short) 154,
      (short) 154,
      (short) 535,
      (short) 548,
      (short) 548,
      (short) 365,
      (short) 387,
      (short) 508,
      (short) 233,
      (short) 1464,
      (short) 1222,
      (short) 1222,
      (short) 1456,
      (short) 1456,
      (short) 1222,
      (short) 1462,
      (short) 1410,
      (short) 1165,
      (short) 1468,
      (short) 1468,
      (short) 1468,
      (short) 1468,
      (short) 1222,
      (short) 1165,
      (short) 1462,
      (short) 1410,
      (short) 1410,
      (short) 1222,
      (short) 1448,
      (short) 1338,
      (short) 1425,
      (short) 1222,
      (short) 1222,
      (short) 1448,
      (short) 1222,
      (short) 1448,
      (short) 1222,
      (short) 1448,
      (short) 1419,
      (short) 1313,
      (short) 1313,
      (short) 1313,
      (short) 1387,
      (short) 1364,
      (short) 1364,
      (short) 1419,
      (short) 1313,
      (short) 1336,
      (short) 1313,
      (short) 1387,
      (short) 1313,
      (short) 1313,
      (short) 1254,
      (short) 1245,
      (short) 1254,
      (short) 1245,
      (short) 1254,
      (short) 1245,
      (short) 1222,
      (short) 1222,
      (short) 1186,
      (short) 1189,
      (short) 1175,
      (short) 1169,
      (short) 1171,
      (short) 1165,
      (short) 1164,
      (short) 1243,
      (short) 1244,
      (short) 1244,
      (short) 1212,
      (short) 1212,
      (short) 1212,
      (short) 1212,
      (short) -74,
      (short) -74,
      (short) -74,
      (short) -74,
      (short) -74,
      (short) -74,
      (short) 939,
      (short) 104,
      (short) 680,
      (short) 571,
      (short) 327,
      (short) 1,
      (short) 980,
      (short) 26,
      (short) 972,
      (short) 971,
      (short) 946,
      (short) 901,
      (short) 870,
      (short) 830,
      (short) 806,
      (short) 54,
      (short) 21,
      (short) -73,
      (short) 510,
      (short) 242,
      (short) 1198,
      (short) 1190,
      (short) 1170,
      (short) 1042,
      (short) 1161,
      (short) 1108,
      (short) 1146,
      (short) 1141,
      (short) 1132,
      (short) 1015,
      (short) 1127,
      (short) 1026,
      (short) 1034,
      (short) 1020,
      (short) 1107,
      (short) 1004,
      (short) 1116,
      (short) 1121,
      (short) 1005,
      (short) 1099,
      (short) 951,
      (short) 1043,
      (short) 1003,
      (short) 969,
      (short) 1045,
      (short) 1035,
      (short) 950,
      (short) 1053,
      (short) 1047,
      (short) 1025,
      (short) 942,
      (short) 913,
      (short) 992,
      (short) 1019,
      (short) 945,
      (short) 984,
      (short) 940,
      (short) 876,
      (short) 904,
      (short) 953,
      (short) 896,
      (short) 748,
      (short) 804,
      (short) 880,
      (short) 786,
      (short) 868,
      (short) 819,
      (short) 805,
      (short) 810,
      (short) 773,
      (short) 751,
      (short) 766,
      (short) 706,
      (short) 716,
      (short) 691,
      (short) 681,
      (short) 568,
      (short) 655,
      (short) 638,
      (short) 676,
      (short) 516,
      (short) 541,
      (short) 594,
      (short) 599,
      (short) 567,
      (short) 541,
      (short) 534,
      (short) 507,
      (short) 527,
      (short) 498,
      (short) 523,
      (short) 466,
      (short) 382,
      (short) 409,
      (short) 384,
      (short) 357,
      (short) 6,
      (short) 240,
      (short) 224,
      (short) 143,
      (short) 62,
      (short) 18,
      (short) 71,
      (short) 39,
      (short) 9,
      (short) 5
    };
    private const int YY_REDUCE_USE_DFLT = -142;
    private const int YY_REDUCE_COUNT = 312;
    private const int YY_REDUCE_MIN = -141;
    private const int YY_REDUCE_MAX = 1369;
    private static short[] yy_reduce_ofst = new short[313]
    {
      (short) -141,
      (short) 994,
      (short) 1118,
      (short) 223,
      (short) 157,
      (short) -53,
      (short) 93,
      (short) 89,
      (short) 83,
      (short) 375,
      (short) 386,
      (short) 381,
      (short) 379,
      (short) 308,
      (short) 295,
      (short) 325,
      (short) -47,
      (short) 27,
      (short) 1240,
      (short) 1234,
      (short) 1228,
      (short) 1221,
      (short) 1208,
      (short) 1187,
      (short) 1151,
      (short) 1111,
      (short) 1109,
      (short) 1077,
      (short) 1054,
      (short) 1022,
      (short) 1016,
      (short) 1000,
      (short) 911,
      (short) 908,
      (short) 906,
      (short) 890,
      (short) 888,
      (short) 874,
      (short) 834,
      (short) 816,
      (short) 800,
      (short) 760,
      (short) 758,
      (short) 755,
      (short) 742,
      (short) 739,
      (short) 726,
      (short) 685,
      (short) 672,
      (short) 668,
      (short) 665,
      (short) 652,
      (short) 611,
      (short) 609,
      (short) 607,
      (short) 604,
      (short) 591,
      (short) 578,
      (short) 526,
      (short) 519,
      (short) 453,
      (short) 474,
      (short) 454,
      (short) 461,
      (short) 443,
      (short) 245,
      (short) 442,
      (short) 473,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 130,
      (short) 484,
      (short) 484,
      (short) 1145,
      (short) 909,
      (short) 1110,
      (short) 1088,
      (short) 1084,
      (short) 1033,
      (short) 1002,
      (short) 965,
      (short) 820,
      (short) 837,
      (short) 746,
      (short) 686,
      (short) 612,
      (short) 817,
      (short) 610,
      (short) 919,
      (short) 221,
      (short) 563,
      (short) 814,
      (short) 813,
      (short) 744,
      (short) 669,
      (short) 470,
      (short) 543,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 484,
      (short) 291,
      (short) 569,
      (short) 671,
      (short) 658,
      (short) 970,
      (short) 1290,
      (short) 1287,
      (short) 1286,
      (short) 1282,
      (short) 518,
      (short) 518,
      (short) 1280,
      (short) 1279,
      (short) 1277,
      (short) 1270,
      (short) 1268,
      (short) 1263,
      (short) 1261,
      (short) 1260,
      (short) 1256,
      (short) 1251,
      (short) 1247,
      (short) 1227,
      (short) 1185,
      (short) 1168,
      (short) 1167,
      (short) 1159,
      (short) 1148,
      (short) 1139,
      (short) 1117,
      (short) 1066,
      (short) 1049,
      (short) 1006,
      (short) 998,
      (short) 996,
      (short) 995,
      (short) 973,
      (short) 970,
      (short) 966,
      (short) 964,
      (short) 892,
      (short) 762,
      (short) -52,
      (short) 881,
      (short) 932,
      (short) 802,
      (short) 731,
      (short) 619,
      (short) 812,
      (short) 664,
      (short) 660,
      (short) 627,
      (short) 392,
      (short) 331,
      (short) 124,
      (short) 1358,
      (short) 1357,
      (short) 1356,
      (short) 1354,
      (short) 1352,
      (short) 1351,
      (short) 1349,
      (short) 1319,
      (short) 1334,
      (short) 1346,
      (short) 1334,
      (short) 1334,
      (short) 1334,
      (short) 1334,
      (short) 1334,
      (short) 1334,
      (short) 1334,
      (short) 1320,
      (short) 1304,
      (short) 1334,
      (short) 1334,
      (short) 1319,
      (short) 1360,
      (short) 1325,
      (short) 1369,
      (short) 1326,
      (short) 1315,
      (short) 1311,
      (short) 1301,
      (short) 1324,
      (short) 1300,
      (short) 1335,
      (short) 1350,
      (short) 1345,
      (short) 1348,
      (short) 1342,
      (short) 1333,
      (short) 1341,
      (short) 1303,
      (short) 1332,
      (short) 1331,
      (short) 1284,
      (short) 1278,
      (short) 1274,
      (short) 1339,
      (short) 1309,
      (short) 1308,
      (short) 1347,
      (short) 1258,
      (short) 1344,
      (short) 1340,
      (short) 1257,
      (short) 1253,
      (short) 1337,
      (short) 1273,
      (short) 1302,
      (short) 1299,
      (short) 1298,
      (short) 1297,
      (short) 1296,
      (short) 1295,
      (short) 1328,
      (short) 1294,
      (short) 1264,
      (short) 1292,
      (short) 1291,
      (short) 1322,
      (short) 1321,
      (short) 1238,
      (short) 1232,
      (short) 1318,
      (short) 1317,
      (short) 1316,
      (short) 1314,
      (short) 1312,
      (short) 1310,
      (short) 1307,
      (short) 1283,
      (short) 1289,
      (short) 1288,
      (short) 1285,
      (short) 1276,
      (short) 1229,
      (short) 1224,
      (short) 1267,
      (short) 1281,
      (short) 1265,
      (short) 1262,
      (short) 1235,
      (short) 1255,
      (short) 1205,
      (short) 1183,
      (short) 1179,
      (short) 1177,
      (short) 1162,
      (short) 1140,
      (short) 1153,
      (short) 1184,
      (short) 1182,
      (short) 1102,
      (short) 1124,
      (short) 1103,
      (short) 1095,
      (short) 1090,
      (short) 1089,
      (short) 1093,
      (short) 1112,
      (short) 1115,
      (short) 1086,
      (short) 1105,
      (short) 1092,
      (short) 1087,
      (short) 1068,
      (short) 962,
      (short) 955,
      (short) 957,
      (short) 1031,
      (short) 1023,
      (short) 1030
    };
    private static int[] yy_default = new int[630]
    {
      635,
      870,
      959,
      959,
      959,
      870,
      899,
      899,
      959,
      759,
      959,
      959,
      959,
      959,
      868,
      959,
      959,
      933,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      899,
      899,
      674,
      763,
      794,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      932,
      934,
      809,
      808,
      802,
      801,
      912,
      774,
      799,
      792,
      785,
      796,
      871,
      864,
      865,
      863,
      867,
      872,
      959,
      795,
      831,
      848,
      830,
      842,
      847,
      854,
      846,
      843,
      833,
      832,
      666,
      834,
      835,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      661,
      728,
      959,
      959,
      959,
      959,
      959,
      959,
      836,
      837,
      851,
      850,
      849,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      939,
      937,
      959,
      883,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      641,
      959,
      759,
      759,
      759,
      635,
      959,
      959,
      959,
      959,
      951,
      763,
      753,
      719,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      804,
      742,
      922,
      924,
      959,
      905,
      740,
      663,
      761,
      676,
      751,
      643,
      798,
      776,
      776,
      917,
      798,
      917,
      700,
      959,
      788,
      959,
      788,
      697,
      788,
      776,
      788,
      788,
      866,
      959,
      959,
      959,
      760,
      751,
      959,
      944,
      767,
      767,
      936,
      936,
      767,
      810,
      732,
      798,
      739,
      739,
      739,
      739,
      767,
      798,
      810,
      732,
      732,
      767,
      658,
      911,
      909,
      767,
      767,
      658,
      767,
      658,
      767,
      658,
      876,
      730,
      730,
      730,
      715,
      880,
      880,
      876,
      730,
      700,
      730,
      715,
      730,
      730,
      780,
      775,
      780,
      775,
      780,
      775,
      767,
      767,
      959,
      793,
      781,
      791,
      789,
      798,
      959,
      718,
      651,
      651,
      640,
      640,
      640,
      640,
      956,
      956,
      951,
      702,
      702,
      684,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      885,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      636,
      946,
      959,
      959,
      943,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      915,
      959,
      959,
      959,
      959,
      959,
      959,
      908,
      907,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      790,
      959,
      782,
      959,
      869,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      959,
      745,
      819,
      959,
      818,
      822,
      817,
      668,
      959,
      649,
      959,
      632,
      637,
      955,
      958,
      957,
      954,
      953,
      952,
      947,
      945,
      942,
      941,
      940,
      938,
      935,
      931,
      889,
      887,
      894,
      893,
      892,
      891,
      890,
      888,
      886,
      884,
      805,
      803,
      800,
      797,
      930,
      882,
      741,
      738,
      737,
      657,
      948,
      914,
      923,
      921,
      811,
      920,
      919,
      918,
      916,
      913,
      900,
      807,
      806,
      733,
      874,
      873,
      660,
      904,
      903,
      902,
      906,
      910,
      901,
      769,
      659,
      656,
      665,
      722,
      721,
      729,
      727,
      726,
      725,
      724,
      723,
      720,
      667,
      675,
      686,
      714,
      699,
      698,
      879,
      881,
      878,
      877,
      707,
      706,
      712,
      711,
      710,
      709,
      708,
      705,
      704,
      703,
      696,
      695,
      701,
      694,
      717,
      716,
      713,
      693,
      736,
      735,
      734,
      731,
      692,
      691,
      690,
      822,
      689,
      688,
      828,
      827,
      815,
      858,
      756,
      755,
      754,
      766,
      765,
      778,
      777,
      813,
      812,
      779,
      764,
      758,
      757,
      773,
      772,
      771,
      770,
      762,
      752,
      784,
      787,
      786,
      783,
      860,
      768,
      857,
      929,
      928,
      927,
      926,
      925,
      862,
      861,
      829,
      826,
      679,
      680,
      898,
      896,
      897,
      895,
      682,
      681,
      678,
      677,
      859,
      747,
      746,
      855,
      852,
      844,
      840,
      856,
      853,
      845,
      841,
      839,
      838,
      824,
      823,
      821,
      820,
      816,
      825,
      670,
      748,
      744,
      743,
      814,
      750,
      749,
      687,
      685,
      683,
      664,
      662,
      655,
      653,
      652,
      654,
      650,
      648,
      647,
      646,
      645,
      644,
      673,
      672,
      671,
      669,
      668,
      642,
      639,
      638,
      634,
      633,
      631
    };
    private static int[] yyFallback = new int[67]
    {
      0,
      0,
      26,
      26,
      26,
      26,
      0,
      26,
      26,
      26,
      0,
      26,
      26,
      26,
      26,
      0,
      0,
      0,
      26,
      0,
      0,
      26,
      0,
      0,
      0,
      0,
      0,
      0,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26,
      26
    };
    private static Sqlite3._yyRuleInfo[] yyRuleInfo = new Sqlite3._yyRuleInfo[329]
    {
      new Sqlite3._yyRuleInfo(142, (byte) 1),
      new Sqlite3._yyRuleInfo(143, (byte) 2),
      new Sqlite3._yyRuleInfo(143, (byte) 1),
      new Sqlite3._yyRuleInfo(144, (byte) 1),
      new Sqlite3._yyRuleInfo(144, (byte) 3),
      new Sqlite3._yyRuleInfo(145, (byte) 0),
      new Sqlite3._yyRuleInfo(145, (byte) 1),
      new Sqlite3._yyRuleInfo(145, (byte) 3),
      new Sqlite3._yyRuleInfo(146, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 3),
      new Sqlite3._yyRuleInfo(149, (byte) 0),
      new Sqlite3._yyRuleInfo(149, (byte) 1),
      new Sqlite3._yyRuleInfo(149, (byte) 2),
      new Sqlite3._yyRuleInfo(148, (byte) 0),
      new Sqlite3._yyRuleInfo(148, (byte) 1),
      new Sqlite3._yyRuleInfo(148, (byte) 1),
      new Sqlite3._yyRuleInfo(148, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 2),
      new Sqlite3._yyRuleInfo(147, (byte) 2),
      new Sqlite3._yyRuleInfo(147, (byte) 2),
      new Sqlite3._yyRuleInfo(151, (byte) 1),
      new Sqlite3._yyRuleInfo(151, (byte) 0),
      new Sqlite3._yyRuleInfo(147, (byte) 2),
      new Sqlite3._yyRuleInfo(147, (byte) 3),
      new Sqlite3._yyRuleInfo(147, (byte) 5),
      new Sqlite3._yyRuleInfo(147, (byte) 2),
      new Sqlite3._yyRuleInfo(152, (byte) 6),
      new Sqlite3._yyRuleInfo(154, (byte) 1),
      new Sqlite3._yyRuleInfo(156, (byte) 0),
      new Sqlite3._yyRuleInfo(156, (byte) 3),
      new Sqlite3._yyRuleInfo(155, (byte) 1),
      new Sqlite3._yyRuleInfo(155, (byte) 0),
      new Sqlite3._yyRuleInfo(153, (byte) 4),
      new Sqlite3._yyRuleInfo(153, (byte) 2),
      new Sqlite3._yyRuleInfo(158, (byte) 3),
      new Sqlite3._yyRuleInfo(158, (byte) 1),
      new Sqlite3._yyRuleInfo(161, (byte) 3),
      new Sqlite3._yyRuleInfo(162, (byte) 1),
      new Sqlite3._yyRuleInfo(165, (byte) 1),
      new Sqlite3._yyRuleInfo(165, (byte) 1),
      new Sqlite3._yyRuleInfo(166, (byte) 1),
      new Sqlite3._yyRuleInfo(150, (byte) 1),
      new Sqlite3._yyRuleInfo(150, (byte) 1),
      new Sqlite3._yyRuleInfo(150, (byte) 1),
      new Sqlite3._yyRuleInfo(163, (byte) 0),
      new Sqlite3._yyRuleInfo(163, (byte) 1),
      new Sqlite3._yyRuleInfo(167, (byte) 1),
      new Sqlite3._yyRuleInfo(167, (byte) 4),
      new Sqlite3._yyRuleInfo(167, (byte) 6),
      new Sqlite3._yyRuleInfo(168, (byte) 1),
      new Sqlite3._yyRuleInfo(168, (byte) 2),
      new Sqlite3._yyRuleInfo(169, (byte) 1),
      new Sqlite3._yyRuleInfo(169, (byte) 1),
      new Sqlite3._yyRuleInfo(164, (byte) 2),
      new Sqlite3._yyRuleInfo(164, (byte) 0),
      new Sqlite3._yyRuleInfo(172, (byte) 3),
      new Sqlite3._yyRuleInfo(172, (byte) 1),
      new Sqlite3._yyRuleInfo(173, (byte) 2),
      new Sqlite3._yyRuleInfo(173, (byte) 4),
      new Sqlite3._yyRuleInfo(173, (byte) 3),
      new Sqlite3._yyRuleInfo(173, (byte) 3),
      new Sqlite3._yyRuleInfo(173, (byte) 2),
      new Sqlite3._yyRuleInfo(173, (byte) 2),
      new Sqlite3._yyRuleInfo(173, (byte) 3),
      new Sqlite3._yyRuleInfo(173, (byte) 5),
      new Sqlite3._yyRuleInfo(173, (byte) 2),
      new Sqlite3._yyRuleInfo(173, (byte) 4),
      new Sqlite3._yyRuleInfo(173, (byte) 4),
      new Sqlite3._yyRuleInfo(173, (byte) 1),
      new Sqlite3._yyRuleInfo(173, (byte) 2),
      new Sqlite3._yyRuleInfo(178, (byte) 0),
      new Sqlite3._yyRuleInfo(178, (byte) 1),
      new Sqlite3._yyRuleInfo(180, (byte) 0),
      new Sqlite3._yyRuleInfo(180, (byte) 2),
      new Sqlite3._yyRuleInfo(182, (byte) 2),
      new Sqlite3._yyRuleInfo(182, (byte) 3),
      new Sqlite3._yyRuleInfo(182, (byte) 3),
      new Sqlite3._yyRuleInfo(182, (byte) 3),
      new Sqlite3._yyRuleInfo(183, (byte) 2),
      new Sqlite3._yyRuleInfo(183, (byte) 2),
      new Sqlite3._yyRuleInfo(183, (byte) 1),
      new Sqlite3._yyRuleInfo(183, (byte) 1),
      new Sqlite3._yyRuleInfo(183, (byte) 2),
      new Sqlite3._yyRuleInfo(181, (byte) 3),
      new Sqlite3._yyRuleInfo(181, (byte) 2),
      new Sqlite3._yyRuleInfo(184, (byte) 0),
      new Sqlite3._yyRuleInfo(184, (byte) 2),
      new Sqlite3._yyRuleInfo(184, (byte) 2),
      new Sqlite3._yyRuleInfo(159, (byte) 0),
      new Sqlite3._yyRuleInfo(159, (byte) 2),
      new Sqlite3._yyRuleInfo(185, (byte) 3),
      new Sqlite3._yyRuleInfo(185, (byte) 2),
      new Sqlite3._yyRuleInfo(185, (byte) 1),
      new Sqlite3._yyRuleInfo(186, (byte) 2),
      new Sqlite3._yyRuleInfo(186, (byte) 7),
      new Sqlite3._yyRuleInfo(186, (byte) 5),
      new Sqlite3._yyRuleInfo(186, (byte) 5),
      new Sqlite3._yyRuleInfo(186, (byte) 10),
      new Sqlite3._yyRuleInfo(188, (byte) 0),
      new Sqlite3._yyRuleInfo(188, (byte) 1),
      new Sqlite3._yyRuleInfo(176, (byte) 0),
      new Sqlite3._yyRuleInfo(176, (byte) 3),
      new Sqlite3._yyRuleInfo(189, (byte) 0),
      new Sqlite3._yyRuleInfo(189, (byte) 2),
      new Sqlite3._yyRuleInfo(190, (byte) 1),
      new Sqlite3._yyRuleInfo(190, (byte) 1),
      new Sqlite3._yyRuleInfo(190, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 4),
      new Sqlite3._yyRuleInfo(192, (byte) 2),
      new Sqlite3._yyRuleInfo(192, (byte) 0),
      new Sqlite3._yyRuleInfo(147, (byte) 8),
      new Sqlite3._yyRuleInfo(147, (byte) 4),
      new Sqlite3._yyRuleInfo(147, (byte) 1),
      new Sqlite3._yyRuleInfo(160, (byte) 1),
      new Sqlite3._yyRuleInfo(160, (byte) 3),
      new Sqlite3._yyRuleInfo(195, (byte) 1),
      new Sqlite3._yyRuleInfo(195, (byte) 2),
      new Sqlite3._yyRuleInfo(195, (byte) 1),
      new Sqlite3._yyRuleInfo(194, (byte) 9),
      new Sqlite3._yyRuleInfo(196, (byte) 1),
      new Sqlite3._yyRuleInfo(196, (byte) 1),
      new Sqlite3._yyRuleInfo(196, (byte) 0),
      new Sqlite3._yyRuleInfo(204, (byte) 2),
      new Sqlite3._yyRuleInfo(204, (byte) 0),
      new Sqlite3._yyRuleInfo(197, (byte) 3),
      new Sqlite3._yyRuleInfo(197, (byte) 2),
      new Sqlite3._yyRuleInfo(197, (byte) 4),
      new Sqlite3._yyRuleInfo(205, (byte) 2),
      new Sqlite3._yyRuleInfo(205, (byte) 1),
      new Sqlite3._yyRuleInfo(205, (byte) 0),
      new Sqlite3._yyRuleInfo(198, (byte) 0),
      new Sqlite3._yyRuleInfo(198, (byte) 2),
      new Sqlite3._yyRuleInfo(207, (byte) 2),
      new Sqlite3._yyRuleInfo(207, (byte) 0),
      new Sqlite3._yyRuleInfo(206, (byte) 7),
      new Sqlite3._yyRuleInfo(206, (byte) 7),
      new Sqlite3._yyRuleInfo(206, (byte) 7),
      new Sqlite3._yyRuleInfo(157, (byte) 0),
      new Sqlite3._yyRuleInfo(157, (byte) 2),
      new Sqlite3._yyRuleInfo(193, (byte) 2),
      new Sqlite3._yyRuleInfo(208, (byte) 1),
      new Sqlite3._yyRuleInfo(208, (byte) 2),
      new Sqlite3._yyRuleInfo(208, (byte) 3),
      new Sqlite3._yyRuleInfo(208, (byte) 4),
      new Sqlite3._yyRuleInfo(210, (byte) 2),
      new Sqlite3._yyRuleInfo(210, (byte) 0),
      new Sqlite3._yyRuleInfo(209, (byte) 0),
      new Sqlite3._yyRuleInfo(209, (byte) 3),
      new Sqlite3._yyRuleInfo(209, (byte) 2),
      new Sqlite3._yyRuleInfo(211, (byte) 4),
      new Sqlite3._yyRuleInfo(211, (byte) 0),
      new Sqlite3._yyRuleInfo(202, (byte) 0),
      new Sqlite3._yyRuleInfo(202, (byte) 3),
      new Sqlite3._yyRuleInfo(214, (byte) 4),
      new Sqlite3._yyRuleInfo(214, (byte) 2),
      new Sqlite3._yyRuleInfo(215, (byte) 1),
      new Sqlite3._yyRuleInfo(177, (byte) 1),
      new Sqlite3._yyRuleInfo(177, (byte) 1),
      new Sqlite3._yyRuleInfo(177, (byte) 0),
      new Sqlite3._yyRuleInfo(200, (byte) 0),
      new Sqlite3._yyRuleInfo(200, (byte) 3),
      new Sqlite3._yyRuleInfo(201, (byte) 0),
      new Sqlite3._yyRuleInfo(201, (byte) 2),
      new Sqlite3._yyRuleInfo(203, (byte) 0),
      new Sqlite3._yyRuleInfo(203, (byte) 2),
      new Sqlite3._yyRuleInfo(203, (byte) 4),
      new Sqlite3._yyRuleInfo(203, (byte) 4),
      new Sqlite3._yyRuleInfo(147, (byte) 5),
      new Sqlite3._yyRuleInfo(199, (byte) 0),
      new Sqlite3._yyRuleInfo(199, (byte) 2),
      new Sqlite3._yyRuleInfo(147, (byte) 7),
      new Sqlite3._yyRuleInfo(217, (byte) 5),
      new Sqlite3._yyRuleInfo(217, (byte) 3),
      new Sqlite3._yyRuleInfo(147, (byte) 8),
      new Sqlite3._yyRuleInfo(147, (byte) 5),
      new Sqlite3._yyRuleInfo(147, (byte) 6),
      new Sqlite3._yyRuleInfo(218, (byte) 2),
      new Sqlite3._yyRuleInfo(218, (byte) 1),
      new Sqlite3._yyRuleInfo(220, (byte) 3),
      new Sqlite3._yyRuleInfo(220, (byte) 1),
      new Sqlite3._yyRuleInfo(219, (byte) 0),
      new Sqlite3._yyRuleInfo(219, (byte) 3),
      new Sqlite3._yyRuleInfo(213, (byte) 3),
      new Sqlite3._yyRuleInfo(213, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(174, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(174, (byte) 1),
      new Sqlite3._yyRuleInfo(174, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 6),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(175, (byte) 4),
      new Sqlite3._yyRuleInfo(174, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(222, (byte) 1),
      new Sqlite3._yyRuleInfo(222, (byte) 2),
      new Sqlite3._yyRuleInfo(222, (byte) 1),
      new Sqlite3._yyRuleInfo(222, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(175, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 4),
      new Sqlite3._yyRuleInfo(175, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 2),
      new Sqlite3._yyRuleInfo(223, (byte) 1),
      new Sqlite3._yyRuleInfo(223, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(224, (byte) 1),
      new Sqlite3._yyRuleInfo(224, (byte) 2),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(175, (byte) 3),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(175, (byte) 4),
      new Sqlite3._yyRuleInfo(175, (byte) 4),
      new Sqlite3._yyRuleInfo(175, (byte) 5),
      new Sqlite3._yyRuleInfo(226, (byte) 5),
      new Sqlite3._yyRuleInfo(226, (byte) 4),
      new Sqlite3._yyRuleInfo(227, (byte) 2),
      new Sqlite3._yyRuleInfo(227, (byte) 0),
      new Sqlite3._yyRuleInfo(225, (byte) 1),
      new Sqlite3._yyRuleInfo(225, (byte) 0),
      new Sqlite3._yyRuleInfo(221, (byte) 1),
      new Sqlite3._yyRuleInfo(221, (byte) 0),
      new Sqlite3._yyRuleInfo(216, (byte) 3),
      new Sqlite3._yyRuleInfo(216, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 11),
      new Sqlite3._yyRuleInfo(228, (byte) 1),
      new Sqlite3._yyRuleInfo(228, (byte) 0),
      new Sqlite3._yyRuleInfo(179, (byte) 0),
      new Sqlite3._yyRuleInfo(179, (byte) 3),
      new Sqlite3._yyRuleInfo(187, (byte) 5),
      new Sqlite3._yyRuleInfo(187, (byte) 3),
      new Sqlite3._yyRuleInfo(229, (byte) 0),
      new Sqlite3._yyRuleInfo(229, (byte) 2),
      new Sqlite3._yyRuleInfo(147, (byte) 4),
      new Sqlite3._yyRuleInfo(147, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 2),
      new Sqlite3._yyRuleInfo(147, (byte) 3),
      new Sqlite3._yyRuleInfo(147, (byte) 5),
      new Sqlite3._yyRuleInfo(147, (byte) 6),
      new Sqlite3._yyRuleInfo(147, (byte) 5),
      new Sqlite3._yyRuleInfo(147, (byte) 6),
      new Sqlite3._yyRuleInfo(230, (byte) 1),
      new Sqlite3._yyRuleInfo(230, (byte) 1),
      new Sqlite3._yyRuleInfo(230, (byte) 1),
      new Sqlite3._yyRuleInfo(230, (byte) 1),
      new Sqlite3._yyRuleInfo(230, (byte) 1),
      new Sqlite3._yyRuleInfo(170, (byte) 2),
      new Sqlite3._yyRuleInfo(171, (byte) 2),
      new Sqlite3._yyRuleInfo(232, (byte) 1),
      new Sqlite3._yyRuleInfo(231, (byte) 1),
      new Sqlite3._yyRuleInfo(231, (byte) 0),
      new Sqlite3._yyRuleInfo(147, (byte) 5),
      new Sqlite3._yyRuleInfo(233, (byte) 11),
      new Sqlite3._yyRuleInfo(235, (byte) 1),
      new Sqlite3._yyRuleInfo(235, (byte) 1),
      new Sqlite3._yyRuleInfo(235, (byte) 2),
      new Sqlite3._yyRuleInfo(235, (byte) 0),
      new Sqlite3._yyRuleInfo(236, (byte) 1),
      new Sqlite3._yyRuleInfo(236, (byte) 1),
      new Sqlite3._yyRuleInfo(236, (byte) 3),
      new Sqlite3._yyRuleInfo(237, (byte) 0),
      new Sqlite3._yyRuleInfo(237, (byte) 3),
      new Sqlite3._yyRuleInfo(238, (byte) 0),
      new Sqlite3._yyRuleInfo(238, (byte) 2),
      new Sqlite3._yyRuleInfo(234, (byte) 3),
      new Sqlite3._yyRuleInfo(234, (byte) 2),
      new Sqlite3._yyRuleInfo(240, (byte) 1),
      new Sqlite3._yyRuleInfo(240, (byte) 3),
      new Sqlite3._yyRuleInfo(241, (byte) 0),
      new Sqlite3._yyRuleInfo(241, (byte) 3),
      new Sqlite3._yyRuleInfo(241, (byte) 2),
      new Sqlite3._yyRuleInfo(239, (byte) 7),
      new Sqlite3._yyRuleInfo(239, (byte) 8),
      new Sqlite3._yyRuleInfo(239, (byte) 5),
      new Sqlite3._yyRuleInfo(239, (byte) 5),
      new Sqlite3._yyRuleInfo(239, (byte) 1),
      new Sqlite3._yyRuleInfo(175, (byte) 4),
      new Sqlite3._yyRuleInfo(175, (byte) 6),
      new Sqlite3._yyRuleInfo(191, (byte) 1),
      new Sqlite3._yyRuleInfo(191, (byte) 1),
      new Sqlite3._yyRuleInfo(191, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 4),
      new Sqlite3._yyRuleInfo(147, (byte) 6),
      new Sqlite3._yyRuleInfo(147, (byte) 3),
      new Sqlite3._yyRuleInfo(243, (byte) 0),
      new Sqlite3._yyRuleInfo(243, (byte) 2),
      new Sqlite3._yyRuleInfo(242, (byte) 1),
      new Sqlite3._yyRuleInfo(242, (byte) 0),
      new Sqlite3._yyRuleInfo(147, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 3),
      new Sqlite3._yyRuleInfo(147, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 3),
      new Sqlite3._yyRuleInfo(147, (byte) 6),
      new Sqlite3._yyRuleInfo(147, (byte) 6),
      new Sqlite3._yyRuleInfo(244, (byte) 1),
      new Sqlite3._yyRuleInfo(245, (byte) 0),
      new Sqlite3._yyRuleInfo(245, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 1),
      new Sqlite3._yyRuleInfo(147, (byte) 4),
      new Sqlite3._yyRuleInfo(246, (byte) 7),
      new Sqlite3._yyRuleInfo(247, (byte) 1),
      new Sqlite3._yyRuleInfo(247, (byte) 3),
      new Sqlite3._yyRuleInfo(248, (byte) 0),
      new Sqlite3._yyRuleInfo(248, (byte) 2),
      new Sqlite3._yyRuleInfo(249, (byte) 1),
      new Sqlite3._yyRuleInfo(249, (byte) 3),
      new Sqlite3._yyRuleInfo(250, (byte) 1),
      new Sqlite3._yyRuleInfo(251, (byte) 0),
      new Sqlite3._yyRuleInfo(251, (byte) 4),
      new Sqlite3._yyRuleInfo(251, (byte) 2)
    };
    public const int TK_SEMI = 1;
    public const int TK_EXPLAIN = 2;
    public const int TK_QUERY = 3;
    public const int TK_PLAN = 4;
    public const int TK_BEGIN = 5;
    public const int TK_TRANSACTION = 6;
    public const int TK_DEFERRED = 7;
    public const int TK_IMMEDIATE = 8;
    public const int TK_EXCLUSIVE = 9;
    public const int TK_COMMIT = 10;
    public const int TK_END = 11;
    public const int TK_ROLLBACK = 12;
    public const int TK_SAVEPOINT = 13;
    public const int TK_RELEASE = 14;
    public const int TK_TO = 15;
    public const int TK_TABLE = 16;
    public const int TK_CREATE = 17;
    public const int TK_IF = 18;
    public const int TK_NOT = 19;
    public const int TK_EXISTS = 20;
    public const int TK_TEMP = 21;
    public const int TK_LP = 22;
    public const int TK_RP = 23;
    public const int TK_AS = 24;
    public const int TK_COMMA = 25;
    public const int TK_ID = 26;
    public const int TK_INDEXED = 27;
    public const int TK_ABORT = 28;
    public const int TK_ACTION = 29;
    public const int TK_AFTER = 30;
    public const int TK_ANALYZE = 31;
    public const int TK_ASC = 32;
    public const int TK_ATTACH = 33;
    public const int TK_BEFORE = 34;
    public const int TK_BY = 35;
    public const int TK_CASCADE = 36;
    public const int TK_CAST = 37;
    public const int TK_COLUMNKW = 38;
    public const int TK_CONFLICT = 39;
    public const int TK_DATABASE = 40;
    public const int TK_DESC = 41;
    public const int TK_DETACH = 42;
    public const int TK_EACH = 43;
    public const int TK_FAIL = 44;
    public const int TK_FOR = 45;
    public const int TK_IGNORE = 46;
    public const int TK_INITIALLY = 47;
    public const int TK_INSTEAD = 48;
    public const int TK_LIKE_KW = 49;
    public const int TK_MATCH = 50;
    public const int TK_NO = 51;
    public const int TK_KEY = 52;
    public const int TK_OF = 53;
    public const int TK_OFFSET = 54;
    public const int TK_PRAGMA = 55;
    public const int TK_RAISE = 56;
    public const int TK_REPLACE = 57;
    public const int TK_RESTRICT = 58;
    public const int TK_ROW = 59;
    public const int TK_TRIGGER = 60;
    public const int TK_VACUUM = 61;
    public const int TK_VIEW = 62;
    public const int TK_VIRTUAL = 63;
    public const int TK_REINDEX = 64;
    public const int TK_RENAME = 65;
    public const int TK_CTIME_KW = 66;
    public const int TK_ANY = 67;
    public const int TK_OR = 68;
    public const int TK_AND = 69;
    public const int TK_IS = 70;
    public const int TK_BETWEEN = 71;
    public const int TK_IN = 72;
    public const int TK_ISNULL = 73;
    public const int TK_NOTNULL = 74;
    public const int TK_NE = 75;
    public const int TK_EQ = 76;
    public const int TK_GT = 77;
    public const int TK_LE = 78;
    public const int TK_LT = 79;
    public const int TK_GE = 80;
    public const int TK_ESCAPE = 81;
    public const int TK_BITAND = 82;
    public const int TK_BITOR = 83;
    public const int TK_LSHIFT = 84;
    public const int TK_RSHIFT = 85;
    public const int TK_PLUS = 86;
    public const int TK_MINUS = 87;
    public const int TK_STAR = 88;
    public const int TK_SLASH = 89;
    public const int TK_REM = 90;
    public const int TK_CONCAT = 91;
    public const int TK_COLLATE = 92;
    public const int TK_BITNOT = 93;
    public const int TK_STRING = 94;
    public const int TK_JOIN_KW = 95;
    public const int TK_CONSTRAINT = 96;
    public const int TK_DEFAULT = 97;
    public const int TK_NULL = 98;
    public const int TK_PRIMARY = 99;
    public const int TK_UNIQUE = 100;
    public const int TK_CHECK = 101;
    public const int TK_REFERENCES = 102;
    public const int TK_AUTOINCR = 103;
    public const int TK_ON = 104;
    public const int TK_INSERT = 105;
    public const int TK_DELETE = 106;
    public const int TK_UPDATE = 107;
    public const int TK_SET = 108;
    public const int TK_DEFERRABLE = 109;
    public const int TK_FOREIGN = 110;
    public const int TK_DROP = 111;
    public const int TK_UNION = 112;
    public const int TK_ALL = 113;
    public const int TK_EXCEPT = 114;
    public const int TK_INTERSECT = 115;
    public const int TK_SELECT = 116;
    public const int TK_DISTINCT = 117;
    public const int TK_DOT = 118;
    public const int TK_FROM = 119;
    public const int TK_JOIN = 120;
    public const int TK_USING = 121;
    public const int TK_ORDER = 122;
    public const int TK_GROUP = 123;
    public const int TK_HAVING = 124;
    public const int TK_LIMIT = 125;
    public const int TK_WHERE = 126;
    public const int TK_INTO = 127;
    public const int TK_VALUES = 128;
    public const int TK_INTEGER = 129;
    public const int TK_FLOAT = 130;
    public const int TK_BLOB = 131;
    public const int TK_REGISTER = 132;
    public const int TK_VARIABLE = 133;
    public const int TK_CASE = 134;
    public const int TK_WHEN = 135;
    public const int TK_THEN = 136;
    public const int TK_ELSE = 137;
    public const int TK_INDEX = 138;
    public const int TK_ALTER = 139;
    public const int TK_ADD = 140;
    public const int TK_TO_TEXT = 141;
    public const int TK_TO_BLOB = 142;
    public const int TK_TO_NUMERIC = 143;
    public const int TK_TO_INT = 144;
    public const int TK_TO_REAL = 145;
    public const int TK_ISNOT = 146;
    public const int TK_END_OF_FILE = 147;
    public const int TK_ILLEGAL = 148;
    public const int TK_SPACE = 149;
    public const int TK_UNCLOSED_STRING = 150;
    public const int TK_FUNCTION = 151;
    public const int TK_COLUMN = 152;
    public const int TK_AGG_FUNCTION = 153;
    public const int TK_AGG_COLUMN = 154;
    public const int TK_CONST_FUNC = 155;
    public const int TK_UMINUS = 156;
    public const int TK_UPLUS = 157;
    private static Sqlite3.PCacheGlobal pcache = new Sqlite3.PCacheGlobal();
    private static Sqlite3.PCacheGlobal pcache1 = Sqlite3.pcache;
    private const int N_SORT_BUCKET = 32;
    private const int PGHDR_DIRTY = 2;
    private const int PGHDR_NEED_SYNC = 4;
    private const int PGHDR_NEED_READ = 8;
    private const int PGHDR_REUSE_UNLIKELY = 16;
    private const int PGHDR_DONT_WRITE = 32;
    private static Sqlite3.EncName[] encnames = new Sqlite3.EncName[9]
    {
      new Sqlite3.EncName("UTF8", (byte) 1),
      new Sqlite3.EncName("UTF-8", (byte) 1),
      new Sqlite3.EncName("UTF-16le (not supported)", (byte) 2),
      new Sqlite3.EncName("UTF-16be (not supported)", (byte) 3),
      new Sqlite3.EncName("UTF16le (not supported)", (byte) 2),
      new Sqlite3.EncName("UTF16be (not supported)", (byte) 3),
      new Sqlite3.EncName("UTF-16 (not supported)", (byte) 0),
      new Sqlite3.EncName("UTF16", (byte) 0),
      new Sqlite3.EncName((string) null, (byte) 0)
    };
    private const int etRADIX = 1;
    private const int etFLOAT = 2;
    private const int etEXP = 3;
    private const int etGENERIC = 4;
    private const int etSIZE = 5;
    private const int etSTRING = 6;
    private const int etDYNSTRING = 7;
    private const int etPERCENT = 8;
    private const int etCHARX = 9;
    private const int etSQLESCAPE = 10;
    private const int etSQLESCAPE2 = 11;
    private const int etTOKEN = 12;
    private const int etSRCLIST = 13;
    private const int etPOINTER = 14;
    private const int etSQLESCAPE3 = 15;
    private const int etORDINAL = 16;
    private const int etINVALID = 0;
    private const byte FLAG_SIGNED = 1;
    private const byte FLAG_INTERN = 2;
    private const byte FLAG_STRING = 4;
    private static string aDigits = "0123456789ABCDEF0123456789abcdef";
    private static string aPrefix = "-x0\000X0";
    private static Sqlite3.et_info[] fmtinfo = new Sqlite3.et_info[23]
    {
      new Sqlite3.et_info('d', (byte) 10, (byte) 1, (byte) 1, (byte) 0, (byte) 0),
      new Sqlite3.et_info('s', (byte) 0, (byte) 4, (byte) 6, (byte) 0, (byte) 0),
      new Sqlite3.et_info('g', (byte) 0, (byte) 1, (byte) 4, (byte) 30, (byte) 0),
      new Sqlite3.et_info('z', (byte) 0, (byte) 4, (byte) 7, (byte) 0, (byte) 0),
      new Sqlite3.et_info('q', (byte) 0, (byte) 4, (byte) 10, (byte) 0, (byte) 0),
      new Sqlite3.et_info('Q', (byte) 0, (byte) 4, (byte) 11, (byte) 0, (byte) 0),
      new Sqlite3.et_info('w', (byte) 0, (byte) 4, (byte) 15, (byte) 0, (byte) 0),
      new Sqlite3.et_info('c', (byte) 0, (byte) 0, (byte) 9, (byte) 0, (byte) 0),
      new Sqlite3.et_info('o', (byte) 8, (byte) 0, (byte) 1, (byte) 0, (byte) 2),
      new Sqlite3.et_info('u', (byte) 10, (byte) 0, (byte) 1, (byte) 0, (byte) 0),
      new Sqlite3.et_info('x', (byte) 16, (byte) 0, (byte) 1, (byte) 16, (byte) 1),
      new Sqlite3.et_info('X', (byte) 16, (byte) 0, (byte) 1, (byte) 0, (byte) 4),
      new Sqlite3.et_info('f', (byte) 0, (byte) 1, (byte) 2, (byte) 0, (byte) 0),
      new Sqlite3.et_info('e', (byte) 0, (byte) 1, (byte) 3, (byte) 30, (byte) 0),
      new Sqlite3.et_info('E', (byte) 0, (byte) 1, (byte) 3, (byte) 14, (byte) 0),
      new Sqlite3.et_info('G', (byte) 0, (byte) 1, (byte) 4, (byte) 14, (byte) 0),
      new Sqlite3.et_info('i', (byte) 10, (byte) 1, (byte) 1, (byte) 0, (byte) 0),
      new Sqlite3.et_info('n', (byte) 0, (byte) 0, (byte) 5, (byte) 0, (byte) 0),
      new Sqlite3.et_info('%', (byte) 0, (byte) 0, (byte) 8, (byte) 0, (byte) 0),
      new Sqlite3.et_info('p', (byte) 16, (byte) 0, (byte) 14, (byte) 0, (byte) 1),
      new Sqlite3.et_info('T', (byte) 0, (byte) 2, (byte) 12, (byte) 0, (byte) 0),
      new Sqlite3.et_info('S', (byte) 0, (byte) 2, (byte) 13, (byte) 0, (byte) 0),
      new Sqlite3.et_info('r', (byte) 10, (byte) 3, (byte) 16, (byte) 0, (byte) 0)
    };
    private const int SQLITE_PRINT_BUF_SIZE = 350;
    private const int etBUFSIZE = 350;
    private static char[] buf = new char[350];
    private static Sqlite3.StrAccum acc = new Sqlite3.StrAccum(350);
    public static Sqlite3.sqlite3PrngType sqlite3Prng = new Sqlite3.sqlite3PrngType();
    private static Sqlite3.sqlite3PrngType sqlite3SavedPrng = (Sqlite3.sqlite3PrngType) null;
    private const int ROWSET_ALLOCATION_SIZE = 1024;
    private const int ROWSET_ENTRY_PER_CHUNK = 63;
    private static Sqlite3.SelectDest sdDummy = (Sqlite3.SelectDest) null;
    private static bool bDummy = false;
    private const string SQLITE_VERSION = "3.7.7(C#)";
    private const int SQLITE_VERSION_NUMBER = 300700701;
    private const string SQLITE_SOURCE_ID = "Ported to C# from 2011-06-23 19:49:22 4374b7e83ea0a3fbc3691f9c0c936272862f32f2";
    public const int SQLITE_OK = 0;
    public const int SQLITE_ERROR = 1;
    public const int SQLITE_INTERNAL = 2;
    public const int SQLITE_PERM = 3;
    public const int SQLITE_ABORT = 4;
    public const int SQLITE_BUSY = 5;
    public const int SQLITE_LOCKED = 6;
    public const int SQLITE_NOMEM = 7;
    public const int SQLITE_READONLY = 8;
    public const int SQLITE_INTERRUPT = 9;
    public const int SQLITE_IOERR = 10;
    public const int SQLITE_CORRUPT = 11;
    public const int SQLITE_NOTFOUND = 12;
    public const int SQLITE_FULL = 13;
    public const int SQLITE_CANTOPEN = 14;
    public const int SQLITE_PROTOCOL = 15;
    public const int SQLITE_EMPTY = 16;
    public const int SQLITE_SCHEMA = 17;
    public const int SQLITE_TOOBIG = 18;
    public const int SQLITE_CONSTRAINT = 19;
    public const int SQLITE_MISMATCH = 20;
    public const int SQLITE_MISUSE = 21;
    public const int SQLITE_NOLFS = 22;
    public const int SQLITE_AUTH = 23;
    public const int SQLITE_FORMAT = 24;
    public const int SQLITE_RANGE = 25;
    public const int SQLITE_NOTADB = 26;
    public const int SQLITE_ROW = 100;
    public const int SQLITE_DONE = 101;
    private const int SQLITE_IOERR_READ = 266;
    private const int SQLITE_IOERR_SHORT_READ = 522;
    private const int SQLITE_IOERR_WRITE = 778;
    private const int SQLITE_IOERR_FSYNC = 1034;
    private const int SQLITE_IOERR_DIR_FSYNC = 1290;
    private const int SQLITE_IOERR_TRUNCATE = 1546;
    private const int SQLITE_IOERR_FSTAT = 1802;
    private const int SQLITE_IOERR_UNLOCK = 2058;
    private const int SQLITE_IOERR_RDLOCK = 2314;
    private const int SQLITE_IOERR_DELETE = 2570;
    private const int SQLITE_IOERR_BLOCKED = 2826;
    private const int SQLITE_IOERR_NOMEM = 3082;
    private const int SQLITE_IOERR_ACCESS = 3338;
    private const int SQLITE_IOERR_CHECKRESERVEDLOCK = 3594;
    private const int SQLITE_IOERR_LOCK = 3850;
    private const int SQLITE_IOERR_CLOSE = 4106;
    private const int SQLITE_IOERR_DIR_CLOSE = 4362;
    private const int SQLITE_IOERR_SHMOPEN = 4618;
    private const int SQLITE_IOERR_SHMSIZE = 4874;
    private const int SQLITE_IOERR_SHMLOCK = 5130;
    private const int SQLITE_IOERR_SHMMAP = 5386;
    private const int SQLITE_IOERR_SEEK = 5642;
    private const int SQLITE_LOCKED_SHAREDCACHE = 262;
    private const int SQLITE_BUSY_RECOVERY = 261;
    private const int SQLITE_CANTOPEN_NOTEMPDIR = 270;
    private const int SQLITE_CORRUPT_VTAB = 267;
    private const int SQLITE_READONLY_RECOVERY = 264;
    private const int SQLITE_READONLY_CANTLOCK = 520;
    public const int SQLITE_OPEN_READONLY = 1;
    public const int SQLITE_OPEN_READWRITE = 2;
    public const int SQLITE_OPEN_CREATE = 4;
    public const int SQLITE_OPEN_DELETEONCLOSE = 8;
    public const int SQLITE_OPEN_EXCLUSIVE = 16;
    public const int SQLITE_OPEN_AUTOPROXY = 32;
    public const int SQLITE_OPEN_URI = 64;
    public const int SQLITE_OPEN_MAIN_DB = 256;
    public const int SQLITE_OPEN_TEMP_DB = 512;
    public const int SQLITE_OPEN_TRANSIENT_DB = 1024;
    public const int SQLITE_OPEN_MAIN_JOURNAL = 2048;
    public const int SQLITE_OPEN_TEMP_JOURNAL = 4096;
    public const int SQLITE_OPEN_SUBJOURNAL = 8192;
    public const int SQLITE_OPEN_MASTER_JOURNAL = 16384;
    public const int SQLITE_OPEN_NOMUTEX = 32768;
    public const int SQLITE_OPEN_FULLMUTEX = 65536;
    public const int SQLITE_OPEN_SHAREDCACHE = 131072;
    public const int SQLITE_OPEN_PRIVATECACHE = 262144;
    public const int SQLITE_OPEN_WAL = 524288;
    private const int SQLITE_IOCAP_ATOMIC = 1;
    private const int SQLITE_IOCAP_ATOMIC512 = 2;
    private const int SQLITE_IOCAP_ATOMIC1K = 4;
    private const int SQLITE_IOCAP_ATOMIC2K = 8;
    private const int SQLITE_IOCAP_ATOMIC4K = 16;
    private const int SQLITE_IOCAP_ATOMIC8K = 32;
    private const int SQLITE_IOCAP_ATOMIC16K = 64;
    private const int SQLITE_IOCAP_ATOMIC32K = 128;
    private const int SQLITE_IOCAP_ATOMIC64K = 256;
    private const int SQLITE_IOCAP_SAFE_APPEND = 512;
    private const int SQLITE_IOCAP_SEQUENTIAL = 1024;
    private const int SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = 2048;
    private const int SQLITE_LOCK_NONE = 0;
    private const int SQLITE_LOCK_SHARED = 1;
    private const int SQLITE_LOCK_RESERVED = 2;
    private const int SQLITE_LOCK_PENDING = 3;
    private const int SQLITE_LOCK_EXCLUSIVE = 4;
    private const int SQLITE_SYNC_NORMAL = 2;
    private const int SQLITE_SYNC_FULL = 3;
    private const int SQLITE_SYNC_DATAONLY = 16;
    private const int SQLITE_FCNTL_LOCKSTATE = 1;
    private const int SQLITE_GET_LOCKPROXYFILE = 2;
    private const int SQLITE_SET_LOCKPROXYFILE = 3;
    private const int SQLITE_LAST_ERRNO = 4;
    private const int SQLITE_FCNTL_SIZE_HINT = 5;
    private const int SQLITE_FCNTL_CHUNK_SIZE = 6;
    private const int SQLITE_FCNTL_FILE_POINTER = 7;
    private const int SQLITE_FCNTL_SYNC_OMITTED = 8;
    private const int SQLITE_ACCESS_EXISTS = 0;
    private const int SQLITE_ACCESS_READWRITE = 1;
    private const int SQLITE_ACCESS_READ = 2;
    private const int SQLITE_SHM_UNLOCK = 1;
    private const int SQLITE_SHM_LOCK = 2;
    private const int SQLITE_SHM_SHARED = 4;
    private const int SQLITE_SHM_EXCLUSIVE = 8;
    private const int SQLITE_SHM_NLOCK = 8;
    private const int SQLITE_CONFIG_SINGLETHREAD = 1;
    private const int SQLITE_CONFIG_MULTITHREAD = 2;
    private const int SQLITE_CONFIG_SERIALIZED = 3;
    private const int SQLITE_CONFIG_MALLOC = 4;
    private const int SQLITE_CONFIG_GETMALLOC = 5;
    private const int SQLITE_CONFIG_SCRATCH = 6;
    private const int SQLITE_CONFIG_PAGECACHE = 7;
    private const int SQLITE_CONFIG_HEAP = 8;
    private const int SQLITE_CONFIG_MEMSTATUS = 9;
    private const int SQLITE_CONFIG_MUTEX = 10;
    private const int SQLITE_CONFIG_GETMUTEX = 11;
    private const int SQLITE_CONFIG_LOOKASIDE = 13;
    private const int SQLITE_CONFIG_PCACHE = 14;
    private const int SQLITE_CONFIG_GETPCACHE = 15;
    private const int SQLITE_CONFIG_LOG = 16;
    private const int SQLITE_CONFIG_URI = 17;
    private const int SQLITE_DBCONFIG_LOOKASIDE = 1001;
    private const int SQLITE_DBCONFIG_ENABLE_FKEY = 1002;
    private const int SQLITE_DBCONFIG_ENABLE_TRIGGER = 1003;
    private const int SQLITE_DENY = 1;
    private const int SQLITE_IGNORE = 2;
    private const int SQLITE_CREATE_INDEX = 1;
    private const int SQLITE_CREATE_TABLE = 2;
    private const int SQLITE_CREATE_TEMP_INDEX = 3;
    private const int SQLITE_CREATE_TEMP_TABLE = 4;
    private const int SQLITE_CREATE_TEMP_TRIGGER = 5;
    private const int SQLITE_CREATE_TEMP_VIEW = 6;
    private const int SQLITE_CREATE_TRIGGER = 7;
    private const int SQLITE_CREATE_VIEW = 8;
    private const int SQLITE_DELETE = 9;
    private const int SQLITE_DROP_INDEX = 10;
    private const int SQLITE_DROP_TABLE = 11;
    private const int SQLITE_DROP_TEMP_INDEX = 12;
    private const int SQLITE_DROP_TEMP_TABLE = 13;
    private const int SQLITE_DROP_TEMP_TRIGGER = 14;
    private const int SQLITE_DROP_TEMP_VIEW = 15;
    private const int SQLITE_DROP_TRIGGER = 16;
    private const int SQLITE_DROP_VIEW = 17;
    private const int SQLITE_INSERT = 18;
    private const int SQLITE_PRAGMA = 19;
    private const int SQLITE_READ = 20;
    private const int SQLITE_SELECT = 21;
    private const int SQLITE_TRANSACTION = 22;
    private const int SQLITE_UPDATE = 23;
    private const int SQLITE_ATTACH = 24;
    private const int SQLITE_DETACH = 25;
    private const int SQLITE_ALTER_TABLE = 26;
    private const int SQLITE_REINDEX = 27;
    private const int SQLITE_ANALYZE = 28;
    private const int SQLITE_CREATE_VTABLE = 29;
    private const int SQLITE_DROP_VTABLE = 30;
    private const int SQLITE_FUNCTION = 31;
    private const int SQLITE_SAVEPOINT = 32;
    private const int SQLITE_COPY = 0;
    private const int SQLITE_LIMIT_LENGTH = 0;
    private const int SQLITE_LIMIT_SQL_LENGTH = 1;
    private const int SQLITE_LIMIT_COLUMN = 2;
    private const int SQLITE_LIMIT_EXPR_DEPTH = 3;
    private const int SQLITE_LIMIT_COMPOUND_SELECT = 4;
    private const int SQLITE_LIMIT_VDBE_OP = 5;
    private const int SQLITE_LIMIT_FUNCTION_ARG = 6;
    private const int SQLITE_LIMIT_ATTACHED = 7;
    private const int SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8;
    private const int SQLITE_LIMIT_VARIABLE_NUMBER = 9;
    private const int SQLITE_LIMIT_TRIGGER_DEPTH = 10;
    public const byte SQLITE_INTEGER = 1;
    public const byte SQLITE_FLOAT = 2;
    public const byte SQLITE_BLOB = 4;
    public const byte SQLITE_NULL = 5;
    public const byte SQLITE_TEXT = 3;
    public const byte SQLITE3_TEXT = 3;
    public const byte SQLITE_UTF8 = 1;
    public const byte SQLITE_UTF16LE = 2;
    public const byte SQLITE_UTF16BE = 3;
    public const byte SQLITE_UTF16 = 4;
    public const byte SQLITE_ANY = 5;
    public const byte SQLITE_UTF16_ALIGNED = 8;
    public static Sqlite3.dxDel SQLITE_STATIC;
    public static Sqlite3.dxDel SQLITE_TRANSIENT;
    private const int SQLITE_INDEX_CONSTRAINT_EQ = 2;
    private const int SQLITE_INDEX_CONSTRAINT_GT = 4;
    private const int SQLITE_INDEX_CONSTRAINT_LE = 8;
    private const int SQLITE_INDEX_CONSTRAINT_LT = 16;
    private const int SQLITE_INDEX_CONSTRAINT_GE = 32;
    private const int SQLITE_INDEX_CONSTRAINT_MATCH = 64;
    private const int SQLITE_MUTEX_FAST = 0;
    private const int SQLITE_MUTEX_RECURSIVE = 1;
    private const int SQLITE_MUTEX_STATIC_MASTER = 2;
    private const int SQLITE_MUTEX_STATIC_MEM = 3;
    private const int SQLITE_MUTEX_STATIC_MEM2 = 4;
    private const int SQLITE_MUTEX_STATIC_OPEN = 4;
    private const int SQLITE_MUTEX_STATIC_PRNG = 5;
    private const int SQLITE_MUTEX_STATIC_LRU = 6;
    private const int SQLITE_MUTEX_STATIC_LRU2 = 7;
    private const int SQLITE_MUTEX_STATIC_PMEM = 7;
    private const int SQLITE_TESTCTRL_FIRST = 5;
    private const int SQLITE_TESTCTRL_PRNG_SAVE = 5;
    private const int SQLITE_TESTCTRL_PRNG_RESTORE = 6;
    private const int SQLITE_TESTCTRL_PRNG_RESET = 7;
    private const int SQLITE_TESTCTRL_BITVEC_TEST = 8;
    private const int SQLITE_TESTCTRL_FAULT_INSTALL = 9;
    private const int SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS = 10;
    private const int SQLITE_TESTCTRL_PENDING_BYTE = 11;
    private const int SQLITE_TESTCTRL_ASSERT = 12;
    private const int SQLITE_TESTCTRL_ALWAYS = 13;
    private const int SQLITE_TESTCTRL_RESERVE = 14;
    private const int SQLITE_TESTCTRL_OPTIMIZATIONS = 15;
    private const int SQLITE_TESTCTRL_ISKEYWORD = 16;
    private const int SQLITE_TESTCTRL_PGHDRSZ = 17;
    private const int SQLITE_TESTCTRL_SCRATCHMALLOC = 18;
    private const int SQLITE_TESTCTRL_LOCALTIME_FAULT = 19;
    private const int SQLITE_TESTCTRL_LAST = 19;
    private const int SQLITE_STATUS_MEMORY_USED = 0;
    private const int SQLITE_STATUS_PAGECACHE_USED = 1;
    private const int SQLITE_STATUS_PAGECACHE_OVERFLOW = 2;
    private const int SQLITE_STATUS_SCRATCH_USED = 3;
    private const int SQLITE_STATUS_SCRATCH_OVERFLOW = 4;
    private const int SQLITE_STATUS_MALLOC_SIZE = 5;
    private const int SQLITE_STATUS_PARSER_STACK = 6;
    private const int SQLITE_STATUS_PAGECACHE_SIZE = 7;
    private const int SQLITE_STATUS_SCRATCH_SIZE = 8;
    private const int SQLITE_STATUS_MALLOC_COUNT = 9;
    private const int SQLITE_DBSTATUS_LOOKASIDE_USED = 0;
    private const int SQLITE_DBSTATUS_CACHE_USED = 1;
    private const int SQLITE_DBSTATUS_SCHEMA_USED = 2;
    private const int SQLITE_DBSTATUS_STMT_USED = 3;
    private const int SQLITE_DBSTATUS_LOOKASIDE_HIT = 4;
    private const int SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE = 5;
    private const int SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL = 6;
    private const int SQLITE_DBSTATUS_MAX = 6;
    private const int SQLITE_STMTSTATUS_FULLSCAN_STEP = 1;
    private const int SQLITE_STMTSTATUS_SORT = 2;
    private const int SQLITE_STMTSTATUS_AUTOINDEX = 3;
    public static int SQLITE_CHECKPOINT_PASSIVE = 0;
    public static int SQLITE_CHECKPOINT_FULL = 1;
    public static int SQLITE_CHECKPOINT_RESTART = 2;
    public const int SQLITE_VTAB_CONSTRAINT_SUPPORT = 1;
    public const int SQLITE_ROLLBACK = 1;
    public const int SQLITE_FAIL = 3;
    public const int SQLITE_REPLACE = 5;
    public const int SQLITE_INDEX_SAMPLES = 10;
    private const int SQLITE_THREADSAFE = 2;
    private const int SQLITE_DEFAULT_MEMSTATUS = 0;
    private const int SQLITE_MALLOC_SOFT_LIMIT = 1024;
    private const double SQLITE_BIG_DBL = 1.15292150460685E+18;
    private static int OMIT_TEMPDB = 0;
    public static int SQLITE_MAX_FILE_FORMAT = 4;
    private static int SQLITE_DEFAULT_FILE_FORMAT = 1;
    public static bool SQLITE_DEFAULT_RECURSIVE_TRIGGERS = false;
    private static int SQLITE_TEMP_STORE = 1;
    private const int SQLITE_ASCII = 1;
    private const uint SQLITE_MAX_U32 = 4294967295;
    private const bool sqlite3one = true;
    private static byte SQLITE_BIGENDIAN = 0;
    private static byte SQLITE_LITTLEENDIAN = 1;
    private static byte SQLITE_UTF16NATIVE = Sqlite3.SQLITE_BIGENDIAN != (byte) 0 ? (byte) 3 : (byte) 2;
    private const long LARGEST_INT64 = 9223372036854775807;
    private const long SMALLEST_INT64 = -9223372036854775808;
    private const string MASTER_NAME = "sqlite_master";
    private const string TEMP_MASTER_NAME = "sqlite_temp_master";
    private const int MASTER_ROOT = 1;
    private static Sqlite3.dxDel SQLITE_DYNAMIC;
    private static Sqlite3.Sqlite3Config sqlite3GlobalConfig;
    private const ushort DB_SchemaLoaded = 1;
    private const ushort DB_UnresetViews = 2;
    private const ushort DB_Empty = 4;
    private const int SQLITE_N_LIMIT = 11;
    private const int SQLITE_VdbeTrace = 256;
    private const int SQLITE_InternChanges = 512;
    private const int SQLITE_FullColNames = 1024;
    private const int SQLITE_ShortColNames = 2048;
    private const int SQLITE_CountRows = 4096;
    private const int SQLITE_NullCallback = 8192;
    private const int SQLITE_SqlTrace = 16384;
    private const int SQLITE_VdbeListing = 32768;
    private const int SQLITE_WriteSchema = 65536;
    private const int SQLITE_NoReadlock = 131072;
    private const int SQLITE_IgnoreChecks = 262144;
    private const int SQLITE_ReadUncommitted = 524288;
    private const int SQLITE_LegacyFileFmt = 1048576;
    private const int SQLITE_FullFSync = 2097152;
    private const int SQLITE_CkptFullFSync = 4194304;
    private const int SQLITE_RecoveryMode = 8388608;
    private const int SQLITE_ReverseOrder = 16777216;
    private const int SQLITE_RecTriggers = 33554432;
    private const int SQLITE_ForeignKeys = 67108864;
    private const int SQLITE_AutoIndex = 134217728;
    private const int SQLITE_PreferBuiltin = 268435456;
    private const int SQLITE_LoadExtension = 536870912;
    private const int SQLITE_EnableTrigger = 1073741824;
    private const int SQLITE_QueryFlattener = 1;
    private const int SQLITE_ColumnCache = 2;
    private const int SQLITE_IndexSort = 4;
    private const int SQLITE_IndexSearch = 8;
    private const int SQLITE_IndexCover = 16;
    private const int SQLITE_GroupByOrder = 32;
    private const int SQLITE_FactorOutConst = 64;
    private const int SQLITE_IdxRealAsInt = 128;
    private const int SQLITE_OptMask = 255;
    private const int SQLITE_MAGIC_OPEN = 271165079;
    private const int SQLITE_MAGIC_CLOSED = 792472883;
    private const int SQLITE_MAGIC_SICK = 997659280;
    private const int SQLITE_MAGIC_BUSY = 1077639430;
    private const int SQLITE_MAGIC_ERROR = 1429567792;
    private const int SQLITE_FUNC_LIKE = 1;
    private const int SQLITE_FUNC_CASE = 2;
    private const int SQLITE_FUNC_EPHEM = 4;
    private const int SQLITE_FUNC_NEEDCOLL = 8;
    private const int SQLITE_FUNC_PRIVATE = 16;
    private const int SQLITE_FUNC_COUNT = 32;
    private const int SQLITE_FUNC_COALESCE = 64;
    private const int SAVEPOINT_BEGIN = 0;
    private const int SAVEPOINT_RELEASE = 1;
    private const int SAVEPOINT_ROLLBACK = 2;
    private const int SQLITE_COLL_BINARY = 1;
    private const int SQLITE_COLL_NOCASE = 2;
    private const int SQLITE_COLL_REVERSE = 3;
    private const int SQLITE_COLL_USER = 0;
    private const int SQLITE_SO_ASC = 0;
    private const int SQLITE_SO_DESC = 1;
    private const char SQLITE_AFF_TEXT = 'a';
    private const char SQLITE_AFF_NONE = 'b';
    private const char SQLITE_AFF_NUMERIC = 'c';
    private const char SQLITE_AFF_INTEGER = 'd';
    private const char SQLITE_AFF_REAL = 'e';
    private const int SQLITE_AFF_MASK = 103;
    private const int SQLITE_JUMPIFNULL = 8;
    private const int SQLITE_STOREP2 = 16;
    private const int SQLITE_NULLEQ = 128;
    private const int TF_Readonly = 1;
    private const int TF_Ephemeral = 2;
    private const int TF_HasPrimaryKey = 4;
    private const int TF_Autoincrement = 8;
    private const int TF_Virtual = 16;
    private const int TF_NeedMetadata = 32;
    private const int OE_None = 0;
    private const int OE_Rollback = 1;
    private const int OE_Abort = 2;
    private const int OE_Fail = 3;
    private const int OE_Ignore = 4;
    private const int OE_Replace = 5;
    private const int OE_Restrict = 6;
    private const int OE_SetNull = 7;
    private const int OE_SetDflt = 8;
    private const int OE_Cascade = 9;
    private const int OE_Default = 99;
    private const int UNPACKED_NEED_FREE = 1;
    private const int UNPACKED_NEED_DESTROY = 2;
    private const int UNPACKED_IGNORE_ROWID = 4;
    private const int UNPACKED_INCRKEY = 8;
    private const int UNPACKED_PREFIX_MATCH = 16;
    private const int UNPACKED_PREFIX_SEARCH = 32;
    private const ushort EP_FromJoin = 1;
    private const ushort EP_Agg = 2;
    private const ushort EP_Resolved = 4;
    private const ushort EP_Error = 8;
    private const ushort EP_Distinct = 16;
    private const ushort EP_VarSelect = 32;
    private const ushort EP_DblQuoted = 64;
    private const ushort EP_InfixFunc = 128;
    private const ushort EP_ExpCollate = 256;
    private const ushort EP_FixedDest = 512;
    private const ushort EP_IntValue = 1024;
    private const ushort EP_xIsSelect = 2048;
    private const ushort EP_Reduced = 4096;
    private const ushort EP_TokenOnly = 8192;
    private const ushort EP_Static = 16384;
    private const byte EP2_MallocedToken = 1;
    private const byte EP2_Irreducible = 2;
    private const int EXPR_FULLSIZE = 48;
    private const int EXPR_REDUCEDSIZE = 24;
    private const int EXPR_TOKENONLYSIZE = 8;
    private const int EXPRDUP_REDUCE = 1;
    private const int BMS = 64;
    private const int JT_INNER = 1;
    private const int JT_CROSS = 2;
    private const int JT_NATURAL = 4;
    private const int JT_LEFT = 8;
    private const int JT_RIGHT = 16;
    private const int JT_OUTER = 32;
    private const int JT_ERROR = 64;
    private const int WHERE_ORDERBY_NORMAL = 0;
    private const int WHERE_ORDERBY_MIN = 1;
    private const int WHERE_ORDERBY_MAX = 2;
    private const int WHERE_ONEPASS_DESIRED = 4;
    private const int WHERE_DUPLICATES_OK = 8;
    private const int WHERE_OMIT_OPEN = 16;
    private const int WHERE_OMIT_CLOSE = 32;
    private const int WHERE_FORCE_TABLE = 64;
    private const int WHERE_ONETABLE_ONLY = 128;
    private const int SF_Distinct = 1;
    private const int SF_Resolved = 2;
    private const int SF_Aggregate = 4;
    private const int SF_UsesEphemeral = 8;
    private const int SF_Expanded = 16;
    private const int SF_HasTypeInfo = 32;
    private const int SRT_Union = 1;
    private const int SRT_Except = 2;
    private const int SRT_Exists = 3;
    private const int SRT_Discard = 4;
    private const int SRT_Output = 5;
    private const int SRT_Mem = 6;
    private const int SRT_Set = 7;
    private const int SRT_Table = 8;
    private const int SRT_EphemTab = 9;
    private const int SRT_Coroutine = 10;
    private const int SQLITE_N_COLCACHE = 10;
    private const byte OPFLAG_NCHANGE = 1;
    private const byte OPFLAG_LASTROWID = 2;
    private const byte OPFLAG_ISUPDATE = 4;
    private const byte OPFLAG_APPEND = 8;
    private const byte OPFLAG_USESEEKRESULT = 16;
    private const byte OPFLAG_CLEARCACHE = 32;
    private const byte TRIGGER_BEFORE = 1;
    private const byte TRIGGER_AFTER = 2;
    private const int WRC_Continue = 0;
    private const int WRC_Prune = 1;
    private const int WRC_Abort = 2;
    private const int SQLITE_FAULTINJECTOR_MALLOC = 0;
    private const int SQLITE_FAULTINJECTOR_COUNT = 1;
    private const int IN_INDEX_ROWID = 1;
    private const int IN_INDEX_EPH = 2;
    private const int IN_INDEX_INDEX = 3;
    public const int MEMTYPE_HEAP = 1;
    public const int MEMTYPE_LOOKASIDE = 2;
    public const int MEMTYPE_SCRATCH = 4;
    public const int MEMTYPE_PCACHE = 8;
    public const int MEMTYPE_DB = 16;
    private const int SQLITE_MAX_LENGTH = 1000000000;
    private const int SQLITE_MAX_COLUMN = 2000;
    private const int SQLITE_MAX_SQL_LENGTH = 1000000000;
    private const int SQLITE_MAX_EXPR_DEPTH = 1000;
    private const int SQLITE_MAX_COMPOUND_SELECT = 250;
    private const int SQLITE_MAX_VDBE_OP = 25000;
    private const int SQLITE_MAX_FUNCTION_ARG = 127;
    private const int SQLITE_DEFAULT_CACHE_SIZE = 2000;
    private const int SQLITE_DEFAULT_TEMP_CACHE_SIZE = 500;
    private const int SQLITE_DEFAULT_WAL_AUTOCHECKPOINT = 1000;
    private const int SQLITE_MAX_ATTACHED = 10;
    private const int SQLITE_MAX_VARIABLE_NUMBER = 999;
    private const int SQLITE_MAX_PAGE_SIZE = 65535;
    private const int SQLITE_DEFAULT_PAGE_SIZE = 1024;
    private const int SQLITE_MAX_DEFAULT_PAGE_SIZE = 8192;
    private const int SQLITE_MAX_PAGE_COUNT = 1073741823;
    private const int SQLITE_MAX_LIKE_PATTERN_LENGTH = 50000;
    private const int SQLITE_MAX_TRIGGER_DEPTH = 101;
    public static Sqlite3.sqlite3StatType sqlite3Stat = new Sqlite3.sqlite3StatType();
    private static Sqlite3.sqlite3StatType wsdStat = Sqlite3.sqlite3Stat;
    private static byte[] sqlite3Utf8Trans1 = new byte[64]
    {
      (byte) 0,
      (byte) 1,
      (byte) 2,
      (byte) 3,
      (byte) 4,
      (byte) 5,
      (byte) 6,
      (byte) 7,
      (byte) 8,
      (byte) 9,
      (byte) 10,
      (byte) 11,
      (byte) 12,
      (byte) 13,
      (byte) 14,
      (byte) 15,
      (byte) 16,
      (byte) 17,
      (byte) 18,
      (byte) 19,
      (byte) 20,
      (byte) 21,
      (byte) 22,
      (byte) 23,
      (byte) 24,
      (byte) 25,
      (byte) 26,
      (byte) 27,
      (byte) 28,
      (byte) 29,
      (byte) 30,
      (byte) 31,
      (byte) 0,
      (byte) 1,
      (byte) 2,
      (byte) 3,
      (byte) 4,
      (byte) 5,
      (byte) 6,
      (byte) 7,
      (byte) 8,
      (byte) 9,
      (byte) 10,
      (byte) 11,
      (byte) 12,
      (byte) 13,
      (byte) 14,
      (byte) 15,
      (byte) 0,
      (byte) 1,
      (byte) 2,
      (byte) 3,
      (byte) 4,
      (byte) 5,
      (byte) 6,
      (byte) 7,
      (byte) 0,
      (byte) 1,
      (byte) 2,
      (byte) 3,
      (byte) 0,
      (byte) 1,
      (byte) 0,
      (byte) 0
    };
    private static byte[] pByte4 = new byte[4];
    private static byte[] bufByte10 = new byte[10];
    private const int SLOT_2_0 = 2080895;
    private const uint SLOT_4_2_0 = 4028612735;
    private const long TWOPOWER32 = 4294967296;
    private const long TWOPOWER31 = 2147483648;
    public const int SQLITE_MAX_SCHEMA_RETRY = 5;
    private const Sqlite3.VdbeOp dummy = null;
    private static StringBuilder zTemp = new StringBuilder(100);
    private static uint[] aSize = new uint[12]
    {
      0U,
      1U,
      2U,
      3U,
      4U,
      6U,
      8U,
      8U,
      0U,
      0U,
      0U,
      0U
    };
    private static Sqlite3.Mem mem1 = new Sqlite3.Mem();
    private const int CACHE_STALE = 0;
    private const int MEM_Null = 1;
    private const int MEM_Str = 2;
    private const int MEM_Int = 4;
    private const int MEM_Real = 8;
    private const int MEM_Blob = 16;
    private const int MEM_RowSet = 32;
    private const int MEM_Frame = 64;
    private const int MEM_Invalid = 128;
    private const int MEM_TypeMask = 255;
    private const int MEM_Term = 512;
    private const int MEM_Dyn = 1024;
    private const int MEM_Static = 2048;
    private const int MEM_Ephem = 4096;
    private const int MEM_Agg = 8192;
    private const int MEM_Zero = 0;
    private const uint VDBE_MAGIC_INIT = 649915045;
    private const uint VDBE_MAGIC_RUN = 3186757027;
    private const uint VDBE_MAGIC_HALT = 1369188723;
    private const uint VDBE_MAGIC_DEAD = 3053896648;
    private const int P4_NOTUSED = 0;
    private const int P4_DYNAMIC = -1;
    private const int P4_STATIC = -2;
    private const int P4_COLLSEQ = -4;
    private const int P4_FUNCDEF = -5;
    private const int P4_KEYINFO = -6;
    private const int P4_VDBEFUNC = -7;
    private const int P4_MEM = -8;
    private const int P4_TRANSIENT = 0;
    private const int P4_VTAB = -10;
    private const int P4_MPRINTF = -11;
    private const int P4_REAL = -12;
    private const int P4_INT64 = -13;
    private const int P4_INT32 = -14;
    private const int P4_INTARRAY = -15;
    private const int P4_SUBPROGRAM = -18;
    private const int P4_KEYINFO_HANDOFF = -16;
    private const int P4_KEYINFO_STATIC = -17;
    private const int COLNAME_NAME = 0;
    private const int COLNAME_DECLTYPE = 1;
    private const int COLNAME_DATABASE = 2;
    private const int COLNAME_TABLE = 3;
    private const int COLNAME_COLUMN = 4;
    private const int COLNAME_N = 2;
    private const int TERM_DYNAMIC = 1;
    private const int TERM_VIRTUAL = 2;
    private const int TERM_CODED = 4;
    private const int TERM_COPIED = 8;
    private const int TERM_ORINFO = 16;
    private const int TERM_ANDINFO = 32;
    private const int TERM_OR_OK = 64;
    private const int TERM_VNULL = 0;
    private const int WO_IN = 1;
    private const int WO_EQ = 2;
    private const int WO_LT = 16;
    private const int WO_LE = 8;
    private const int WO_GT = 4;
    private const int WO_GE = 32;
    private const int WO_MATCH = 64;
    private const int WO_ISNULL = 128;
    private const int WO_OR = 256;
    private const int WO_AND = 512;
    private const int WO_NOOP = 2048;
    private const int WO_ALL = 4095;
    private const int WO_SINGLE = 255;
    private const int WHERE_ROWID_EQ = 4096;
    private const int WHERE_ROWID_RANGE = 8192;
    private const int WHERE_COLUMN_EQ = 65536;
    private const int WHERE_COLUMN_RANGE = 131072;
    private const int WHERE_COLUMN_IN = 262144;
    private const int WHERE_COLUMN_NULL = 524288;
    private const int WHERE_INDEXED = 983040;
    private const int WHERE_IN_ABLE = 987136;
    private const int WHERE_NOT_FULLSCAN = 269430784;
    private const int WHERE_TOP_LIMIT = 1048576;
    private const int WHERE_BTM_LIMIT = 2097152;
    private const int WHERE_BOTH_LIMIT = 3145728;
    private const int WHERE_IDX_ONLY = 8388608;
    private const int WHERE_ORDERBY = 16777216;
    private const int WHERE_REVERSE = 33554432;
    private const int WHERE_UNIQUE = 67108864;
    private const int WHERE_VIRTUALTABLE = 134217728;
    private const int WHERE_MULTI_OR = 268435456;
    private const int WHERE_TEMP_INDEX = 536870912;
    private static Regex oRegex = (Regex) null;
    private static object lock_va_list = new object();
    private static string vaFORMAT;
    private static int vaNEXT;
    private const long ERROR_FILE_NOT_FOUND = 2;
    private const long ERROR_HANDLE_DISK_FULL = 39;
    private const long ERROR_NOT_SUPPORTED = 50;
    private const long ERROR_DISK_FULL = 112;
    private static Sqlite3.SQLite3UpperToLower sqlite3UpperToLower = new Sqlite3.SQLite3UpperToLower();
    private static Sqlite3.SQLite3UpperToLower UpperToLower = Sqlite3.sqlite3UpperToLower;

    private static void renameTableFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      string str1 = Sqlite3.sqlite3_value_text(argv[0]);
      string z1 = str1 == null ? "" : str1;
      string str2 = Sqlite3.sqlite3_value_text(argv[1]);
      int tokenType = 0;
      Sqlite3.Token token = new Sqlite3.Token();
      int num1 = 0;
      int num2 = 0;
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      if (!(z1 != ""))
        return;
      while (num1 != z1.Length)
      {
        int length = num1;
        token.z = z1.Substring(num1);
        token.n = num2;
label_4:
        num1 += num2;
        num2 = num1 == z1.Length ? 1 : Sqlite3.sqlite3GetToken(z1, num1, ref tokenType);
        switch (tokenType)
        {
          case 22:
          case 121:
            string z2 = Sqlite3.sqlite3MPrintf(db, "%.*s\"%w\"%s", (object) length, (object) z1.Substring(0, length), (object) str2, (object) z1.Substring(length + token.n));
            Sqlite3.sqlite3_result_text(context, z2, -1, Sqlite3.SQLITE_DYNAMIC);
            return;
          case 149:
            goto label_4;
          default:
            continue;
        }
      }
    }

    private static void renameParentFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      string pString = "";
      string z1 = Sqlite3.sqlite3_value_text(argv[0]);
      string str1 = Sqlite3.sqlite3_value_text(argv[1]);
      string str2 = Sqlite3.sqlite3_value_text(argv[2]);
      int startIndex = 0;
      int tokenType = 0;
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      int token;
      for (int index = 0; index < z1.Length; index += token)
      {
        token = Sqlite3.sqlite3GetToken(z1, index, ref tokenType);
        if (tokenType == 102)
        {
          do
          {
            index += token;
            token = Sqlite3.sqlite3GetToken(z1, index, ref tokenType);
          }
          while (tokenType == 149);
          string str3 = index + token < z1.Length ? z1.Substring(index, token) : "";
          if (!string.IsNullOrEmpty(str3))
          {
            Sqlite3.sqlite3Dequote(ref str3);
            if (str1.Equals(str3, StringComparison.InvariantCultureIgnoreCase))
            {
              string str4 = Sqlite3.sqlite3MPrintf(db, "%s%.*s\"%w\"", (object) pString, (object) (index - startIndex), (object) z1.Substring(startIndex), (object) str2);
              Sqlite3.sqlite3DbFree(db, ref pString);
              pString = str4;
              index += token;
              startIndex = index;
            }
            Sqlite3.sqlite3DbFree(db, ref str3);
          }
          else
            break;
        }
      }
      string z2 = Sqlite3.sqlite3MPrintf(db, "%s%s", (object) pString, (object) z1.Substring(startIndex));
      Sqlite3.sqlite3_result_text(context, z2, -1, Sqlite3.SQLITE_DYNAMIC);
      Sqlite3.sqlite3DbFree(db, ref pString);
    }

    private static void renameTriggerFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      string z1 = Sqlite3.sqlite3_value_text(argv[0]);
      string str = Sqlite3.sqlite3_value_text(argv[1]);
      int tokenType = 0;
      Sqlite3.Token token = new Sqlite3.Token();
      int num1 = 3;
      int num2 = 0;
      int length1 = 1;
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      if (z1 == null)
        return;
      while (num2 != z1.Length)
      {
        int length2 = num2;
        token.z = z1.Substring(num2, length1);
        token.n = length1;
        do
        {
          num2 += length1;
          length1 = num2 == z1.Length ? 1 : Sqlite3.sqlite3GetToken(z1, num2, ref tokenType);
        }
        while (tokenType == 149);
        ++num1;
        if (tokenType == 118 || tokenType == 104)
          num1 = 0;
        if (num1 == 2 && (tokenType == 135 || tokenType == 45 || tokenType == 5))
        {
          string z2 = Sqlite3.sqlite3MPrintf(db, "%.*s\"%w\"%s", (object) length2, (object) z1.Substring(0, length2), (object) str, (object) z1.Substring(length2 + token.n));
          Sqlite3.sqlite3_result_text(context, z2, -1, Sqlite3.SQLITE_DYNAMIC);
          break;
        }
      }
    }

    private static void sqlite3AlterFunctions()
    {
      Sqlite3.aAlterTableFuncs = new Sqlite3.FuncDef[3]
      {
        Sqlite3.FUNCTION("sqlite_rename_table", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.renameTableFunc)),
        Sqlite3.FUNCTION("sqlite_rename_trigger", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.renameTriggerFunc)),
        Sqlite3.FUNCTION("sqlite_rename_parent", (short) 3, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.renameParentFunc))
      };
      Sqlite3.FuncDefHash sqlite3GlobalFunctions = Sqlite3.sqlite3GlobalFunctions;
      Sqlite3.FuncDef[] aAlterTableFuncs = Sqlite3.aAlterTableFuncs;
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3.FuncDef>(Sqlite3.aAlterTableFuncs); ++index)
        Sqlite3.sqlite3FuncDefInsert(sqlite3GlobalFunctions, aAlterTableFuncs[index]);
    }

    private static string whereOrName(Sqlite3.sqlite3 db, string zWhere, string zConstant)
    {
      string str;
      if (string.IsNullOrEmpty(zWhere))
      {
        str = Sqlite3.sqlite3MPrintf(db, "name=%Q", (object) zConstant);
      }
      else
      {
        str = Sqlite3.sqlite3MPrintf(db, "%s OR name=%Q", (object) zWhere, (object) zConstant);
        Sqlite3.sqlite3DbFree(db, ref zWhere);
      }
      return str;
    }

    private static string whereForeignKeys(Sqlite3.Parse pParse, Sqlite3.Table pTab)
    {
      string zWhere = "";
      for (Sqlite3.FKey fkey = Sqlite3.sqlite3FkReferences(pTab); fkey != null; fkey = fkey.pNextTo)
        zWhere = Sqlite3.whereOrName(pParse.db, zWhere, fkey.pFrom.zName);
      return zWhere;
    }

    private static string whereTempTriggers(Sqlite3.Parse pParse, Sqlite3.Table pTab)
    {
      string zWhere = "";
      Sqlite3.Schema pSchema = pParse.db.aDb[1].pSchema;
      if (pTab.pSchema != pSchema)
      {
        Sqlite3.sqlite3 db = pParse.db;
        for (Sqlite3.Trigger trigger = Sqlite3.sqlite3TriggerList(pParse, pTab); trigger != null; trigger = trigger.pNext)
        {
          if (trigger.pSchema == pSchema)
            zWhere = Sqlite3.whereOrName(db, zWhere, trigger.zName);
        }
      }
      if (!string.IsNullOrEmpty(zWhere))
        zWhere = Sqlite3.sqlite3MPrintf(pParse.db, "type='trigger' AND (%s)", (object) zWhere);
      return zWhere;
    }

    private static void reloadTableSchema(Sqlite3.Parse pParse, Sqlite3.Table pTab, string zName)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (Sqlite3.NEVER(vdbe == null))
        return;
      int index1 = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
      for (Sqlite3.Trigger trigger = Sqlite3.sqlite3TriggerList(pParse, pTab); trigger != null; trigger = trigger.pNext)
      {
        int index2 = Sqlite3.sqlite3SchemaToIndex(pParse.db, trigger.pSchema);
        Sqlite3.sqlite3VdbeAddOp4(vdbe, 103, index2, 0, 0, trigger.zName, 0);
      }
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 101, index1, 0, 0, pTab.zName, 0);
      string zWhere1 = Sqlite3.sqlite3MPrintf(pParse.db, "tbl_name=%Q", (object) zName);
      if (zWhere1 == null)
        return;
      Sqlite3.sqlite3VdbeAddParseSchemaOp(vdbe, index1, zWhere1);
      string zWhere2;
      if (!((zWhere2 = Sqlite3.whereTempTriggers(pParse, pTab)) != ""))
        return;
      Sqlite3.sqlite3VdbeAddParseSchemaOp(vdbe, 1, zWhere2);
    }

    private static int isSystemTable(Sqlite3.Parse pParse, string zName)
    {
      if (!zName.StartsWith("sqlite_", StringComparison.InvariantCultureIgnoreCase))
        return 0;
      Sqlite3.sqlite3ErrorMsg(pParse, "table %s may not be altered", (object) zName);
      return 1;
    }

    private static void sqlite3AlterRenameTable(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pSrc,
      Sqlite3.Token pName)
    {
      string pString1 = (string) null;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.VTable vtable = (Sqlite3.VTable) null;
      int flags = db.flags;
      Sqlite3.Table table = Sqlite3.sqlite3LocateTable(pParse, 0, pSrc.a[0].zName, pSrc.a[0].zDatabase);
      if (table != null)
      {
        int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, table.pSchema);
        string zName1 = db.aDb[index].zName;
        db.flags |= 268435456;
        pString1 = Sqlite3.sqlite3NameFromToken(db, pName);
        if (pString1 != null)
        {
          if (Sqlite3.sqlite3FindTable(db, pString1, zName1) != null || Sqlite3.sqlite3FindIndex(db, pString1, zName1) != null)
            Sqlite3.sqlite3ErrorMsg(pParse, "there is already another table or index with this name: %s", (object) pString1);
          else if (Sqlite3.isSystemTable(pParse, table.zName) == 0 && Sqlite3.sqlite3CheckObjectName(pParse, pString1) == 0)
          {
            if (table.pSelect != null)
              Sqlite3.sqlite3ErrorMsg(pParse, "view %s may not be altered", (object) table.zName);
            else if (Sqlite3.sqlite3ViewGetColumnNames(pParse, table) == 0 && Sqlite3.sqlite3GetVdbe(pParse) != null)
            {
              Sqlite3.sqlite3BeginWriteOperation(pParse, vtable != null ? 1 : 0, index);
              Sqlite3.sqlite3ChangeCookie(pParse, index);
              string zName2 = table.zName;
              int num = Sqlite3.sqlite3Utf8CharLen(zName2, -1);
              string pString2;
              if ((db.flags & 67108864) != 0 && (pString2 = Sqlite3.whereForeignKeys(pParse, table)) != null)
              {
                Sqlite3.sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET sql = sqlite_rename_parent(sql, %Q, %Q) WHERE %s;", (object) zName1, (object) Sqlite3.SCHEMA_TABLE(index), (object) zName2, (object) pString1, (object) pString2);
                Sqlite3.sqlite3DbFree(db, ref pString2);
              }
              Sqlite3.sqlite3NestedParse(pParse, "UPDATE %Q.%s SET sql = CASE WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)ELSE sqlite_rename_table(sql, %Q) END, tbl_name = %Q, name = CASE WHEN type='table' THEN %Q WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN 'sqlite_autoindex_' || %Q || substr(name,%d+18) ELSE name END WHERE tbl_name=%Q AND (type='table' OR type='index' OR type='trigger');", (object) zName1, (object) Sqlite3.SCHEMA_TABLE(index), (object) pString1, (object) pString1, (object) pString1, (object) pString1, (object) pString1, (object) num, (object) zName2);
              if (Sqlite3.sqlite3FindTable(db, "sqlite_sequence", zName1) != null)
                Sqlite3.sqlite3NestedParse(pParse, "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q", (object) zName1, (object) pString1, (object) table.zName);
              if ((pString2 = Sqlite3.whereTempTriggers(pParse, table)) != "")
              {
                Sqlite3.sqlite3NestedParse(pParse, "UPDATE sqlite_temp_master SET sql = sqlite_rename_trigger(sql, %Q), tbl_name = %Q WHERE %s;", (object) pString1, (object) pString1, (object) pString2);
                Sqlite3.sqlite3DbFree(db, ref pString2);
              }
              if ((db.flags & 67108864) != 0)
              {
                for (Sqlite3.FKey fkey = Sqlite3.sqlite3FkReferences(table); fkey != null; fkey = fkey.pNextTo)
                {
                  Sqlite3.Table pFrom = fkey.pFrom;
                  if (pFrom != table)
                    Sqlite3.reloadTableSchema(pParse, fkey.pFrom, pFrom.zName);
                }
              }
              Sqlite3.reloadTableSchema(pParse, table, pString1);
            }
          }
        }
      }
      Sqlite3.sqlite3SrcListDelete(db, ref pSrc);
      Sqlite3.sqlite3DbFree(db, ref pString1);
      db.flags = flags;
    }

    private static void sqlite3MinimumFileFormat(Sqlite3.Parse pParse, int iDb, int minFormat)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (!Sqlite3.ALWAYS<Sqlite3.Vdbe>(vdbe))
        return;
      int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
      int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 35, iDb, tempReg1, 2);
      Sqlite3.sqlite3VdbeUsesBtree(vdbe, iDb);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, minFormat, tempReg2);
      int addr = Sqlite3.sqlite3VdbeAddOp3(vdbe, 80, tempReg2, 0, tempReg1);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 36, iDb, 2, tempReg2);
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
    }

    private static void sqlite3AlterFinishAddColumn(Sqlite3.Parse pParse, Sqlite3.Token pColDef)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.nErr != 0)
        return;
      Sqlite3.Table pNewTable = pParse.pNewTable;
      int index = Sqlite3.sqlite3SchemaToIndex(db, pNewTable.pSchema);
      string zName1 = db.aDb[index].zName;
      string zName2 = pNewTable.zName.Substring(16);
      Sqlite3.Column column = pNewTable.aCol[pNewTable.nCol - 1];
      Sqlite3.Expr pExpr = column.pDflt;
      Sqlite3.Table table = Sqlite3.sqlite3FindTable(db, zName2, zName1);
      if (pExpr != null && pExpr.op == (byte) 98)
        pExpr = (Sqlite3.Expr) null;
      if (column.isPrimKey != (byte) 0)
        Sqlite3.sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
      else if (pNewTable.pIndex != null)
        Sqlite3.sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
      else if ((db.flags & 67108864) != 0 && pNewTable.pFKey != null && pExpr != null)
        Sqlite3.sqlite3ErrorMsg(pParse, "Cannot add a REFERENCES column with non-NULL default value");
      else if (column.notNull != (byte) 0 && pExpr == null)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "Cannot add a NOT NULL column with default value NULL");
      }
      else
      {
        if (pExpr != null)
        {
          Sqlite3.Mem mem = (Sqlite3.Mem) null;
          if (Sqlite3.sqlite3ValueFromExpr(db, pExpr, 1, 'b', ref mem) != 0)
            return;
          if (mem == null)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default");
            return;
          }
          Sqlite3.sqlite3ValueFree(ref mem);
        }
        string pString = pColDef.z.Substring(0, pColDef.n).Replace(";", " ").Trim();
        if (pString != null)
        {
          int flags = db.flags;
          db.flags |= 268435456;
          Sqlite3.sqlite3NestedParse(pParse, "UPDATE \"%w\".%s SET sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) WHERE type = 'table' AND name = %Q", (object) zName1, (object) Sqlite3.SCHEMA_TABLE(index), (object) pNewTable.addColOffset, (object) pString, (object) (pNewTable.addColOffset + 1), (object) zName2);
          Sqlite3.sqlite3DbFree(db, ref pString);
          db.flags = flags;
        }
        Sqlite3.sqlite3MinimumFileFormat(pParse, index, pExpr != null ? 3 : 2);
        Sqlite3.reloadTableSchema(pParse, table, table.zName);
      }
    }

    private static void sqlite3AlterBeginAddColumn(Sqlite3.Parse pParse, Sqlite3.SrcList pSrc)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Table T = Sqlite3.sqlite3LocateTable(pParse, 0, pSrc.a[0].zName, pSrc.a[0].zDatabase);
      if (T != null)
      {
        if (Sqlite3.IsVirtual(T))
          Sqlite3.sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
        else if (T.pSelect != null)
          Sqlite3.sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
        else if (Sqlite3.isSystemTable(pParse, T.zName) == 0)
        {
          int index1 = Sqlite3.sqlite3SchemaToIndex(db, T.pSchema);
          Sqlite3.Table table = new Sqlite3.Table();
          if (table != null)
          {
            pParse.pNewTable = table;
            table.nRef = (ushort) 1;
            table.nCol = T.nCol;
            int length = (table.nCol - 1) / 8 * 8 + 8;
            table.aCol = new Sqlite3.Column[length];
            table.zName = Sqlite3.sqlite3MPrintf(db, "sqlite_altertab_%s", (object) T.zName);
            if (table.aCol != null && table.zName != null)
            {
              for (int index2 = 0; index2 < table.nCol; ++index2)
              {
                Sqlite3.Column column = T.aCol[index2].Copy();
                column.zColl = (string) null;
                column.zType = (string) null;
                column.pDflt = (Sqlite3.Expr) null;
                column.zDflt = (string) null;
                table.aCol[index2] = column;
              }
              table.pSchema = db.aDb[index1].pSchema;
              table.addColOffset = T.addColOffset;
              table.nRef = (ushort) 1;
              Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index1);
              if (Sqlite3.sqlite3GetVdbe(pParse) != null)
                Sqlite3.sqlite3ChangeCookie(pParse, index1);
            }
          }
        }
      }
      Sqlite3.sqlite3SrcListDelete(db, ref pSrc);
    }

    private static void openStatTable(
      Sqlite3.Parse pParse,
      int iDb,
      int iStatCur,
      string zWhere,
      string zWhereType)
    {
      int[] numArray1 = new int[2];
      byte[] numArray2 = new byte[2];
      Sqlite3.sqlite3 db1 = pParse.db;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      Sqlite3.Db db2 = db1.aDb[iDb];
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3._aTable>(Sqlite3.aTable); ++index)
      {
        string zName = Sqlite3.aTable[index].zName;
        Sqlite3.Table table;
        if ((table = Sqlite3.sqlite3FindTable(db1, zName, db2.zName)) == null)
        {
          Sqlite3.sqlite3NestedParse(pParse, "CREATE TABLE %Q.%s(%s)", (object) db2.zName, (object) zName, (object) Sqlite3.aTable[index].zCols);
          numArray1[index] = pParse.regRoot;
          numArray2[index] = (byte) 1;
        }
        else
        {
          numArray1[index] = table.tnum;
          Sqlite3.sqlite3TableLock(pParse, iDb, numArray1[index], (byte) 1, zName);
          if (!string.IsNullOrEmpty(zWhere))
            Sqlite3.sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE %s=%Q", (object) db2.zName, (object) zName, (object) zWhereType, (object) zWhere);
          else
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 96, numArray1[index], iDb);
        }
      }
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3._aTable>(Sqlite3.aTable); ++index)
      {
        Sqlite3.sqlite3VdbeAddOp3(vdbe, 39, iStatCur + index, numArray1[index], iDb);
        Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, 3, -14);
        Sqlite3.sqlite3VdbeChangeP5(vdbe, numArray2[index]);
      }
    }

    private static void analyzeOneTable(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      Sqlite3.Index pOnlyIdx,
      int iStatCur,
      int iMem)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int addr1 = -1;
      int num1 = iMem++;
      int p2_1 = iMem++;
      int num2 = iMem++;
      int num3 = iMem++;
      int num4 = iMem++;
      int num5 = iMem++;
      int num6 = iMem++;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null || Sqlite3.NEVER(pTab == null) || pTab.tnum == 0 || pTab.zName.StartsWith("sqlite_", StringComparison.InvariantCultureIgnoreCase))
        return;
      int index1 = Sqlite3.sqlite3SchemaToIndex(db, pTab.pSchema);
      Sqlite3.sqlite3TableLock(pParse, index1, pTab.tnum, (byte) 0, pTab.zName);
      int p1 = pParse.nTab++;
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, num1, 0, pTab.zName, 0);
      for (Sqlite3.Index pIdx = pTab.pIndex; pIdx != null; pIdx = pIdx.pNext)
      {
        if (pOnlyIdx == null || pOnlyIdx == pIdx)
        {
          int nColumn = pIdx.nColumn;
          Sqlite3.KeyInfo pP4_1 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
          if (iMem + 1 + nColumn * 2 > pParse.nMem)
            pParse.nMem = iMem + 1 + nColumn * 2;
          Sqlite3.sqlite3VdbeAddOp4(vdbe, 38, p1, pIdx.tnum, index1, pP4_1, -16);
          Sqlite3.VdbeComment(vdbe, "%s", (object) pIdx.zName);
          Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, p2_1, 0, pIdx.zName, 0);
          for (int index2 = 0; index2 <= nColumn; ++index2)
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, iMem + index2);
          for (int index3 = 0; index3 < nColumn; ++index3)
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, iMem + nColumn + index3 + 1);
          int num7 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, p1, num7);
          int p2_2 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 20, iMem, 1);
          for (int p2_3 = 0; p2_3 < nColumn; ++p2_3)
          {
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, p1, p2_3, num3);
            if (p2_3 == 0)
              Sqlite3.sqlite3VdbeAddOp1(vdbe, 27, iMem + 1);
            Sqlite3.CollSeq pP4_2 = Sqlite3.sqlite3LocateCollSeq(pParse, pIdx.azColl[p2_3]);
            Sqlite3.sqlite3VdbeAddOp4(vdbe, 75, num3, 0, iMem + nColumn + p2_3 + 1, pP4_2, -4);
            Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 128);
          }
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, num7);
          for (int p2_4 = 0; p2_4 < nColumn; ++p2_4)
          {
            int addr2 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe) - nColumn * 2;
            if (p2_4 == 0)
              Sqlite3.sqlite3VdbeJumpHere(vdbe, addr2 - 1);
            Sqlite3.sqlite3VdbeJumpHere(vdbe, addr2);
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 20, iMem + p2_4 + 1, 1);
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, p1, p2_4, iMem + nColumn + p2_4 + 1);
          }
          Sqlite3.sqlite3VdbeResolveLabel(vdbe, num7);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, p1, p2_2);
          Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, p1);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, iMem, num2);
          if (addr1 < 0)
            addr1 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 27, iMem);
          for (int index4 = 0; index4 < nColumn; ++index4)
          {
            Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, num5, 0, " ", 0);
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 91, num5, num2, num2);
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 86, iMem, iMem + index4 + 1, num5);
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 20, num5, -1);
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 89, iMem + index4 + 1, num5, num5);
            Sqlite3.sqlite3VdbeAddOp1(vdbe, 144, num5);
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 91, num5, num2, num2);
          }
          Sqlite3.sqlite3VdbeAddOp4(vdbe, 30, num1, 3, num4, "aaa", 0);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 54, iStatCur, num6);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, iStatCur, num4, num6);
          Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 8);
        }
      }
      int addr3;
      if (pTab.pIndex == null)
      {
        Sqlite3.sqlite3VdbeAddOp3(vdbe, 38, p1, pTab.tnum, index1);
        Sqlite3.VdbeComment(vdbe, "%s", (object) pTab.zName);
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 31, p1, num2);
        Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, p1);
        addr3 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 27, num2);
      }
      else
      {
        Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
        addr3 = Sqlite3.sqlite3VdbeAddOp0(vdbe, 1);
      }
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, p2_1);
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 30, num1, 3, num4, "aaa", 0);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 54, iStatCur, num6);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, iStatCur, num4, num6);
      Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 8);
      if (pParse.nMem < num4)
        pParse.nMem = num4;
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr3);
    }

    private static void loadAnalysis(Sqlite3.Parse pParse, int iDb)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      Sqlite3.sqlite3VdbeAddOp1(vdbe, 100, iDb);
    }

    private static void analyzeDatabase(Sqlite3.Parse pParse, int iDb)
    {
      Sqlite3.Schema pSchema = pParse.db.aDb[iDb].pSchema;
      Sqlite3.sqlite3BeginWriteOperation(pParse, 0, iDb);
      int nTab = pParse.nTab;
      pParse.nTab += 2;
      Sqlite3.openStatTable(pParse, iDb, nTab, (string) null, (string) null);
      int iMem = pParse.nMem + 1;
      for (Sqlite3.HashElem hashElem = pSchema.tblHash.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
        Sqlite3.analyzeOneTable(pParse, data, (Sqlite3.Index) null, nTab, iMem);
      }
      Sqlite3.loadAnalysis(pParse, iDb);
    }

    private static void analyzeTable(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      Sqlite3.Index pOnlyIdx)
    {
      int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
      Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index);
      int nTab = pParse.nTab;
      pParse.nTab += 2;
      if (pOnlyIdx != null)
        Sqlite3.openStatTable(pParse, index, nTab, pOnlyIdx.zName, "idx");
      else
        Sqlite3.openStatTable(pParse, index, nTab, pTab.zName, "tbl");
      Sqlite3.analyzeOneTable(pParse, pTab, pOnlyIdx, nTab, pParse.nMem + 1);
      Sqlite3.loadAnalysis(pParse, index);
    }

    private static void sqlite3Analyze(Sqlite3.Parse pParse, int null_2, int null_3) => Sqlite3.sqlite3Analyze(pParse, (Sqlite3.Token) null, (Sqlite3.Token) null);

    private static void sqlite3Analyze(
      Sqlite3.Parse pParse,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2)
    {
      Sqlite3.sqlite3 db1 = pParse.db;
      Sqlite3.Token pUnqual = (Sqlite3.Token) null;
      if (Sqlite3.sqlite3ReadSchema(pParse) != 0)
        return;
      string str;
      if (pName1 == null)
      {
        for (int iDb = 0; iDb < db1.nDb; ++iDb)
        {
          if (iDb != 1)
            Sqlite3.analyzeDatabase(pParse, iDb);
        }
      }
      else if (pName2.n == 0)
      {
        int db2 = Sqlite3.sqlite3FindDb(db1, pName1);
        if (db2 >= 0)
        {
          Sqlite3.analyzeDatabase(pParse, db2);
        }
        else
        {
          string zName = Sqlite3.sqlite3NameFromToken(db1, pName1);
          if (zName == null)
            return;
          Sqlite3.Index index;
          if ((index = Sqlite3.sqlite3FindIndex(db1, zName, (string) null)) != null)
          {
            Sqlite3.analyzeTable(pParse, index.pTable, index);
          }
          else
          {
            Sqlite3.Table pTab;
            if ((pTab = Sqlite3.sqlite3LocateTable(pParse, 0, zName, (string) null)) != null)
              Sqlite3.analyzeTable(pParse, pTab, (Sqlite3.Index) null);
          }
          str = (string) null;
        }
      }
      else
      {
        int index1 = Sqlite3.sqlite3TwoPartName(pParse, pName1, pName2, ref pUnqual);
        if (index1 < 0)
          return;
        string zName1 = db1.aDb[index1].zName;
        string zName2 = Sqlite3.sqlite3NameFromToken(db1, pUnqual);
        if (zName2 == null)
          return;
        Sqlite3.Index index2;
        if ((index2 = Sqlite3.sqlite3FindIndex(db1, zName2, zName1)) != null)
        {
          Sqlite3.analyzeTable(pParse, index2.pTable, index2);
        }
        else
        {
          Sqlite3.Table pTab;
          if ((pTab = Sqlite3.sqlite3LocateTable(pParse, 0, zName2, zName1)) != null)
            Sqlite3.analyzeTable(pParse, pTab, (Sqlite3.Index) null);
        }
        str = (string) null;
      }
    }

    private static int analysisLoader(object pData, long argc, object Oargv, object NotUsed)
    {
      string[] strArray = (string[]) Oargv;
      Sqlite3.analysisInfo analysisInfo = (Sqlite3.analysisInfo) pData;
      Sqlite3.UNUSED_PARAMETER2<object, long>(NotUsed, argc);
      if (strArray == null || strArray[0] == null || strArray[2] == null)
        return 0;
      Sqlite3.Table table = Sqlite3.sqlite3FindTable(analysisInfo.db, strArray[0], analysisInfo.zDatabase);
      if (table == null)
        return 0;
      Sqlite3.Index index1 = string.IsNullOrEmpty(strArray[1]) ? (Sqlite3.Index) null : Sqlite3.sqlite3FindIndex(analysisInfo.db, strArray[1], analysisInfo.zDatabase);
      int num1 = index1 != null ? index1.nColumn : 0;
      string str = strArray[2];
      int num2 = 0;
      for (int index2 = 0; str != null && index2 <= num1; ++index2)
      {
        int num3 = 0;
        int num4;
        for (; num2 < str.Length && (num4 = (int) str[num2]) >= 48 && num4 <= 57; ++num2)
          num3 = num3 * 10 + num4 - 48;
        if (index2 == 0)
          table.nRowEst = (uint) num3;
        if (index1 != null)
        {
          index1.aiRowEst[index2] = num3;
          if (num2 < str.Length && str[num2] == ' ')
            ++num2;
          if (str.Substring(num2).CompareTo("unordered") == 0)
          {
            index1.bUnordered = (byte) 1;
            break;
          }
        }
        else
          break;
      }
      return 0;
    }

    private static void sqlite3DeleteIndexSamples(Sqlite3.sqlite3 db, Sqlite3.Index pIdx)
    {
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3>(db);
      Sqlite3.UNUSED_PARAMETER<Sqlite3.Index>(pIdx);
    }

    private static int sqlite3AnalysisLoad(Sqlite3.sqlite3 db, int iDb)
    {
      for (Sqlite3.HashElem hashElem = db.aDb[iDb].pSchema.idxHash.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.Index data = (Sqlite3.Index) hashElem.data;
        Sqlite3.sqlite3DefaultRowEst(data);
        Sqlite3.sqlite3DeleteIndexSamples(db, data);
        data.aSample = (Sqlite3.IndexSample[]) null;
      }
      Sqlite3.analysisInfo pArg;
      pArg.db = db;
      pArg.zDatabase = db.aDb[iDb].zName;
      if (Sqlite3.sqlite3FindTable(db, "sqlite_stat1", pArg.zDatabase) == null)
        return 1;
      string pString = Sqlite3.sqlite3MPrintf(db, "SELECT tbl, idx, stat FROM %Q.sqlite_stat1", (object) pArg.zDatabase);
      int num = Sqlite3.sqlite3_exec(db, pString, new Sqlite3.dxCallback(Sqlite3.analysisLoader), (object) pArg, 0);
      Sqlite3.sqlite3DbFree(db, ref pString);
      return num;
    }

    private static int resolveAttachExpr(Sqlite3.NameContext pName, Sqlite3.Expr pExpr)
    {
      int num = 0;
      if (pExpr != null)
      {
        if (pExpr.op != (byte) 26)
        {
          num = Sqlite3.sqlite3ResolveExprNames(pName, ref pExpr);
          if (num == 0 && Sqlite3.sqlite3ExprIsConstant(pExpr) == 0)
          {
            Sqlite3.sqlite3ErrorMsg(pName.pParse, "invalid name: \"%s\"", (object) pExpr.u.zToken);
            return 1;
          }
        }
        else
          pExpr.op = (byte) 94;
      }
      return num;
    }

    private static void attachFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      int errCode = 0;
      Sqlite3.sqlite3 sqlite3 = Sqlite3.sqlite3_context_db_handle(context);
      string pzFile = "";
      string pzErrMsg = "";
      string z = "";
      Sqlite3.sqlite3_vfs ppVfs = (Sqlite3.sqlite3_vfs) null;
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      string zUri = argv[0].z == null || argv[0].z.Length <= 0 || argv[0].flags == (ushort) 1 ? "" : Sqlite3.sqlite3_value_text(argv[0]);
      string str = argv[1].z == null || argv[1].z.Length <= 0 || argv[1].flags == (ushort) 1 ? "" : Sqlite3.sqlite3_value_text(argv[1]);
      if (sqlite3.nDb >= sqlite3.aLimit[7] + 2)
        z = Sqlite3.sqlite3MPrintf(sqlite3, "too many attached databases - max %d", (object) sqlite3.aLimit[7]);
      else if (sqlite3.autoCommit == (byte) 0)
      {
        z = Sqlite3.sqlite3MPrintf(sqlite3, "cannot ATTACH database within transaction");
      }
      else
      {
        for (int index = 0; index < sqlite3.nDb; ++index)
        {
          if (sqlite3.aDb[index].zName.Equals(str, StringComparison.InvariantCultureIgnoreCase))
          {
            z = Sqlite3.sqlite3MPrintf(sqlite3, "database %s is already in use", (object) str);
            goto label_37;
          }
        }
        if (sqlite3.aDb.Length <= sqlite3.nDb)
          Array.Resize<Sqlite3.Db>(ref sqlite3.aDb, sqlite3.nDb + 1);
        if (sqlite3.aDb == null)
          return;
        sqlite3.aDb[sqlite3.nDb] = new Sqlite3.Db();
        Sqlite3.Db db = sqlite3.aDb[sqlite3.nDb];
        int openFlags = sqlite3.openFlags;
        if (Sqlite3.sqlite3ParseUri(sqlite3.pVfs.zName, zUri, ref openFlags, ref ppVfs, ref pzFile, ref pzErrMsg) != 0)
        {
          Sqlite3.sqlite3_result_error(context, pzErrMsg, -1);
          return;
        }
        int vfsFlags = openFlags | 256;
        errCode = Sqlite3.sqlite3BtreeOpen(ppVfs, pzFile, sqlite3, ref db.pBt, 0, vfsFlags);
        ++sqlite3.nDb;
        switch (errCode)
        {
          case 0:
            db.pSchema = Sqlite3.sqlite3SchemaGet(sqlite3, db.pBt);
            if (db.pSchema.file_format != (byte) 0 && (int) db.pSchema.enc != (int) Sqlite3.ENC(sqlite3))
            {
              z = Sqlite3.sqlite3MPrintf(sqlite3, "attached databases must use the same text encoding as main database");
              errCode = 1;
            }
            Sqlite3.sqlite3PagerLockingMode(Sqlite3.sqlite3BtreePager(db.pBt), (int) sqlite3.dfltLockMode);
            Sqlite3.sqlite3BtreeSecureDelete(db.pBt, Sqlite3.sqlite3BtreeSecureDelete(sqlite3.aDb[0].pBt, -1));
            break;
          case 19:
            errCode = 1;
            z = Sqlite3.sqlite3MPrintf(sqlite3, "database is already attached");
            break;
        }
        db.safety_level = (byte) 3;
        db.zName = str;
        if (errCode == 0)
        {
          switch (Sqlite3.sqlite3_value_type(argv[2]))
          {
            case 1:
            case 2:
              z = "Invalid key value";
              errCode = 1;
              break;
            case 3:
            case 4:
              int nKey1 = Sqlite3.sqlite3_value_bytes(argv[2]);
              string zKey1 = Sqlite3.sqlite3_value_blob(argv[2]).ToString();
              errCode = Sqlite3.sqlite3CodecAttach(sqlite3, sqlite3.nDb - 1, zKey1, nKey1);
              break;
            case 5:
              string zKey2;
              int nKey2;
              Sqlite3.sqlite3CodecGetKey(sqlite3, 0, out zKey2, out nKey2);
              if (nKey2 > 0 || Sqlite3.sqlite3BtreeGetReserve(sqlite3.aDb[0].pBt) > 0)
              {
                errCode = Sqlite3.sqlite3CodecAttach(sqlite3, sqlite3.nDb - 1, zKey2, nKey2);
                break;
              }
              break;
          }
        }
        if (errCode == 0)
        {
          Sqlite3.sqlite3BtreeEnterAll(sqlite3);
          errCode = Sqlite3.sqlite3Init(sqlite3, ref z);
          Sqlite3.sqlite3BtreeLeaveAll(sqlite3);
        }
        if (errCode == 0)
          return;
        int index1 = sqlite3.nDb - 1;
        if (sqlite3.aDb[index1].pBt != null)
        {
          Sqlite3.sqlite3BtreeClose(ref sqlite3.aDb[index1].pBt);
          sqlite3.aDb[index1].pBt = (Sqlite3.Btree) null;
          sqlite3.aDb[index1].pSchema = (Sqlite3.Schema) null;
        }
        Sqlite3.sqlite3ResetInternalSchema(sqlite3, -1);
        sqlite3.nDb = index1;
        if (errCode == 7 || errCode == 3082)
        {
          Sqlite3.sqlite3DbFree(sqlite3, ref z);
          z = Sqlite3.sqlite3MPrintf(sqlite3, "out of memory");
        }
        else if (z == "")
          z = Sqlite3.sqlite3MPrintf(sqlite3, "unable to open database: %s", (object) zUri);
      }
label_37:
      if (z != "")
      {
        Sqlite3.sqlite3_result_error(context, z, -1);
        Sqlite3.sqlite3DbFree(sqlite3, ref z);
      }
      if (errCode == 0)
        return;
      Sqlite3.sqlite3_result_error_code(context, errCode);
    }

    private static void detachFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      string str1;
      string str2 = str1 = argv[0].z == null || argv[0].z.Length <= 0 ? "" : Sqlite3.sqlite3_value_text(argv[0]);
      Sqlite3.sqlite3 db1 = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.Db db2 = (Sqlite3.Db) null;
      StringBuilder zBuf = new StringBuilder(200);
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      if (str2 == null)
        str2 = "";
      int index;
      for (index = 0; index < db1.nDb; ++index)
      {
        db2 = db1.aDb[index];
        if (db2.pBt != null && db2.zName.Equals(str2, StringComparison.InvariantCultureIgnoreCase))
          break;
      }
      if (index >= db1.nDb)
        Sqlite3.sqlite3_snprintf(200, zBuf, "no such database: %s", (object) str2);
      else if (index < 2)
        Sqlite3.sqlite3_snprintf(200, zBuf, "cannot detach database %s", (object) str2);
      else if (db1.autoCommit == (byte) 0)
        Sqlite3.sqlite3_snprintf(200, zBuf, "cannot DETACH database within transaction");
      else if (Sqlite3.sqlite3BtreeIsInReadTrans(db2.pBt) || Sqlite3.sqlite3BtreeIsInBackup(db2.pBt))
      {
        Sqlite3.sqlite3_snprintf(200, zBuf, "database %s is locked", (object) str2);
      }
      else
      {
        Sqlite3.sqlite3BtreeClose(ref db2.pBt);
        db2.pBt = (Sqlite3.Btree) null;
        db2.pSchema = (Sqlite3.Schema) null;
        Sqlite3.sqlite3ResetInternalSchema(db1, -1);
        return;
      }
      Sqlite3.sqlite3_result_error(context, zBuf.ToString(), -1);
    }

    private static void codeAttach(
      Sqlite3.Parse pParse,
      int type,
      Sqlite3.FuncDef pFunc,
      Sqlite3.Expr pAuthArg,
      Sqlite3.Expr pFilename,
      Sqlite3.Expr pDbname,
      Sqlite3.Expr pKey)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.NameContext pName = new Sqlite3.NameContext();
      pName.pParse = pParse;
      int num;
      if ((num = Sqlite3.resolveAttachExpr(pName, pFilename)) != 0 || (num = Sqlite3.resolveAttachExpr(pName, pDbname)) != 0 || (num = Sqlite3.resolveAttachExpr(pName, pKey)) != 0)
      {
        ++pParse.nErr;
      }
      else
      {
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
        int tempRange = Sqlite3.sqlite3GetTempRange(pParse, 4);
        Sqlite3.sqlite3ExprCode(pParse, pFilename, tempRange);
        Sqlite3.sqlite3ExprCode(pParse, pDbname, tempRange + 1);
        Sqlite3.sqlite3ExprCode(pParse, pKey, tempRange + 2);
        if (vdbe != null)
        {
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 18, 0, tempRange + 3 - (int) pFunc.nArg, tempRange + 3);
          Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) pFunc.nArg);
          Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, pFunc, -5);
          Sqlite3.sqlite3VdbeAddOp1(vdbe, 122, type == 24 ? 1 : 0);
        }
      }
      Sqlite3.sqlite3ExprDelete(db, ref pFilename);
      Sqlite3.sqlite3ExprDelete(db, ref pDbname);
      Sqlite3.sqlite3ExprDelete(db, ref pKey);
    }

    private static void sqlite3Detach(Sqlite3.Parse pParse, Sqlite3.Expr pDbname) => Sqlite3.codeAttach(pParse, 25, Sqlite3.detach_func, pDbname, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pDbname);

    private static void sqlite3Attach(
      Sqlite3.Parse pParse,
      Sqlite3.Expr p,
      Sqlite3.Expr pDbname,
      Sqlite3.Expr pKey)
    {
      Sqlite3.codeAttach(pParse, 24, Sqlite3.attach_func, p, p, pDbname, pKey);
    }

    private static int sqlite3FixInit(
      Sqlite3.DbFixer pFix,
      Sqlite3.Parse pParse,
      int iDb,
      string zType,
      Sqlite3.Token pName)
    {
      if (Sqlite3.NEVER(iDb < 0) || iDb == 1)
        return 0;
      Sqlite3.sqlite3 db = pParse.db;
      pFix.pParse = pParse;
      pFix.zDb = db.aDb[iDb].zName;
      pFix.zType = zType;
      pFix.pName = pName;
      return 1;
    }

    private static int sqlite3FixSrcList(Sqlite3.DbFixer pFix, Sqlite3.SrcList pList)
    {
      if (Sqlite3.NEVER(pList == null))
        return 0;
      string zDb = pFix.zDb;
      for (int index = 0; index < (int) pList.nSrc; ++index)
      {
        Sqlite3.SrcList_item srcListItem = pList.a[index];
        if (srcListItem.zDatabase == null)
          srcListItem.zDatabase = zDb;
        else if (!srcListItem.zDatabase.Equals(zDb, StringComparison.InvariantCultureIgnoreCase))
        {
          Sqlite3.sqlite3ErrorMsg(pFix.pParse, "%s %T cannot reference objects in database %s", (object) pFix.zType, (object) pFix.pName, (object) srcListItem.zDatabase);
          return 1;
        }
        if (Sqlite3.sqlite3FixSelect(pFix, srcListItem.pSelect) != 0 || Sqlite3.sqlite3FixExpr(pFix, srcListItem.pOn) != 0)
          return 1;
      }
      return 0;
    }

    private static int sqlite3FixSelect(Sqlite3.DbFixer pFix, Sqlite3.Select pSelect)
    {
      for (; pSelect != null; pSelect = pSelect.pPrior)
      {
        if (Sqlite3.sqlite3FixExprList(pFix, pSelect.pEList) != 0 || Sqlite3.sqlite3FixSrcList(pFix, pSelect.pSrc) != 0 || Sqlite3.sqlite3FixExpr(pFix, pSelect.pWhere) != 0 || Sqlite3.sqlite3FixExpr(pFix, pSelect.pHaving) != 0)
          return 1;
      }
      return 0;
    }

    private static int sqlite3FixExpr(Sqlite3.DbFixer pFix, Sqlite3.Expr pExpr)
    {
      for (; pExpr != null && !Sqlite3.ExprHasAnyProperty(pExpr, 8192); pExpr = pExpr.pLeft)
      {
        if (Sqlite3.ExprHasProperty(pExpr, 2048))
        {
          if (Sqlite3.sqlite3FixSelect(pFix, pExpr.x.pSelect) != 0)
            return 1;
        }
        else if (Sqlite3.sqlite3FixExprList(pFix, pExpr.x.pList) != 0)
          return 1;
        if (Sqlite3.sqlite3FixExpr(pFix, pExpr.pRight) != 0)
          return 1;
      }
      return 0;
    }

    private static int sqlite3FixExprList(Sqlite3.DbFixer pFix, Sqlite3.ExprList pList)
    {
      if (pList == null)
        return 0;
      for (int index = 0; index < pList.nExpr; ++index)
      {
        Sqlite3.ExprList_item exprListItem = pList.a[index];
        if (Sqlite3.sqlite3FixExpr(pFix, exprListItem.pExpr) != 0)
          return 1;
      }
      return 0;
    }

    private static int sqlite3FixTriggerStep(Sqlite3.DbFixer pFix, Sqlite3.TriggerStep pStep)
    {
      for (; pStep != null; pStep = pStep.pNext)
      {
        if (Sqlite3.sqlite3FixSelect(pFix, pStep.pSelect) != 0 || Sqlite3.sqlite3FixExpr(pFix, pStep.pWhere) != 0 || Sqlite3.sqlite3FixExprList(pFix, pStep.pExprList) != 0)
          return 1;
      }
      return 0;
    }

    private static Sqlite3.Btree findBtree(
      Sqlite3.sqlite3 pErrorDb,
      Sqlite3.sqlite3 pDb,
      string zDb)
    {
      int dbName = Sqlite3.sqlite3FindDbName(pDb, zDb);
      if (dbName == 1)
      {
        int num = 0;
        Sqlite3.Parse pParse = new Sqlite3.Parse();
        if (pParse == null)
        {
          Sqlite3.sqlite3Error(pErrorDb, 7, "out of memory");
          num = 7;
        }
        else
        {
          pParse.db = pDb;
          if (Sqlite3.sqlite3OpenTempDatabase(pParse) != 0)
          {
            Sqlite3.sqlite3Error(pErrorDb, pParse.rc, "%s", (object) pParse.zErrMsg);
            num = 1;
          }
          Sqlite3.sqlite3DbFree(pErrorDb, ref pParse.zErrMsg);
        }
        if (num != 0)
          return (Sqlite3.Btree) null;
      }
      if (dbName >= 0)
        return pDb.aDb[dbName].pBt;
      Sqlite3.sqlite3Error(pErrorDb, 1, "unknown database %s", (object) zDb);
      return (Sqlite3.Btree) null;
    }

    private static int setDestPgsz(Sqlite3.sqlite3_backup p) => Sqlite3.sqlite3BtreeSetPageSize(p.pDest, Sqlite3.sqlite3BtreeGetPageSize(p.pSrc), -1, 0);

    public static Sqlite3.sqlite3_backup sqlite3_backup_init(
      Sqlite3.sqlite3 pDestDb,
      string zDestDb,
      Sqlite3.sqlite3 pSrcDb,
      string zSrcDb)
    {
      Sqlite3.sqlite3_mutex_enter(pSrcDb.mutex);
      Sqlite3.sqlite3_mutex_enter(pDestDb.mutex);
      Sqlite3.sqlite3_backup p;
      if (pSrcDb == pDestDb)
      {
        Sqlite3.sqlite3Error(pDestDb, 1, "source and destination must be distinct");
        p = (Sqlite3.sqlite3_backup) null;
      }
      else
        p = new Sqlite3.sqlite3_backup();
      if (p != null)
      {
        p.pSrc = Sqlite3.findBtree(pDestDb, pSrcDb, zSrcDb);
        p.pDest = Sqlite3.findBtree(pDestDb, pDestDb, zDestDb);
        p.pDestDb = pDestDb;
        p.pSrcDb = pSrcDb;
        p.iNext = 1U;
        p.isAttached = 0;
        if (p.pSrc == null || p.pDest == null || Sqlite3.setDestPgsz(p) == 7)
          p = (Sqlite3.sqlite3_backup) null;
      }
      if (p != null)
        ++p.pSrc.nBackup;
      Sqlite3.sqlite3_mutex_leave(pDestDb.mutex);
      Sqlite3.sqlite3_mutex_leave(pSrcDb.mutex);
      return p;
    }

    private static bool isFatalError(int rc) => rc != 0 && rc != 5 && Sqlite3.ALWAYS(rc != 6);

    private static int backupOnePage(Sqlite3.sqlite3_backup p, uint iSrcPg, byte[] zSrcData)
    {
      Sqlite3.Pager pPager = Sqlite3.sqlite3BtreePager(p.pDest);
      int pageSize1 = Sqlite3.sqlite3BtreeGetPageSize(p.pSrc);
      int pageSize2 = Sqlite3.sqlite3BtreeGetPageSize(p.pDest);
      int count = Sqlite3.MIN(pageSize1, pageSize2);
      long num1 = (long) iSrcPg * (long) pageSize1;
      int reserve1 = Sqlite3.sqlite3BtreeGetReserve(p.pSrc);
      int reserve2 = Sqlite3.sqlite3BtreeGetReserve(p.pDest);
      int num2 = 0;
      if (pageSize1 != pageSize2 && Sqlite3.sqlite3PagerIsMemdb(pPager))
        num2 = 8;
      if (pageSize1 != pageSize2 && Sqlite3.sqlite3PagerGetCodec(pPager) != null)
        num2 = 8;
      if (reserve1 != reserve2)
      {
        uint pPageSize = (uint) pageSize1;
        num2 = Sqlite3.sqlite3PagerSetPagesize(pPager, ref pPageSize, reserve1);
        if (num2 == 0 && (long) pPageSize != (long) pageSize1)
          num2 = 8;
      }
      for (long index = num1 - (long) pageSize1; num2 == 0 && index < num1; index += (long) pageSize2)
      {
        Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
        uint pgno = (uint) ((ulong) index / (ulong) pageSize2) + 1U;
        if ((int) pgno != (int) Sqlite3.PENDING_BYTE_PAGE(p.pDest.pBt))
        {
          if ((num2 = Sqlite3.sqlite3PagerGet(pPager, pgno, ref ppPage)) == 0 && (num2 = Sqlite3.sqlite3PagerWrite(ppPage)) == 0)
          {
            byte[] data = Sqlite3.sqlite3PagerGetData(ppPage);
            Buffer.BlockCopy((Array) zSrcData, (int) (index % (long) pageSize1), (Array) data, (int) (index % (long) pageSize2), count);
            Sqlite3.sqlite3PagerGetExtra(ppPage).isInit = (byte) 0;
          }
          Sqlite3.sqlite3PagerUnref(ppPage);
        }
      }
      return num2;
    }

    private static int backupTruncateFile(Sqlite3.sqlite3_file pFile, int iSize)
    {
      long pSize = 0;
      int num = Sqlite3.sqlite3OsFileSize(pFile, ref pSize);
      if (num == 0 && pSize > (long) iSize)
        num = Sqlite3.sqlite3OsTruncate(pFile, (long) iSize);
      return num;
    }

    private static void attachBackupObject(Sqlite3.sqlite3_backup p)
    {
      Sqlite3.sqlite3_backup sqlite3Backup = Sqlite3.sqlite3PagerBackupPtr(Sqlite3.sqlite3BtreePager(p.pSrc));
      p.pNext = sqlite3Backup;
      Sqlite3.sqlite3BtreePager(p.pSrc).pBackup = p;
      p.isAttached = 1;
    }

    public static int sqlite3_backup_step(Sqlite3.sqlite3_backup p, int nPage)
    {
      Sqlite3.sqlite3_mutex_enter(p.pSrcDb.mutex);
      Sqlite3.sqlite3BtreeEnter(p.pSrc);
      if (p.pDestDb != null)
        Sqlite3.sqlite3_mutex_enter(p.pDestDb.mutex);
      int rc = p.rc;
      if (!Sqlite3.isFatalError(rc))
      {
        Sqlite3.Pager pPager1 = Sqlite3.sqlite3BtreePager(p.pSrc);
        Sqlite3.Pager pPager2 = Sqlite3.sqlite3BtreePager(p.pDest);
        int num1 = 0;
        rc = p.pDestDb == null || p.pSrc.pBt.inTransaction != (byte) 2 ? 0 : 5;
        if (rc == 0 && p.bDestLocked == 0 && (rc = Sqlite3.sqlite3BtreeBeginTrans(p.pDest, 2)) == 0)
        {
          p.bDestLocked = 1;
          Sqlite3.sqlite3BtreeGetMeta(p.pDest, 1, ref p.iDestSchema);
        }
        if (rc == 0 && !Sqlite3.sqlite3BtreeIsInReadTrans(p.pSrc))
        {
          rc = Sqlite3.sqlite3BtreeBeginTrans(p.pSrc, 0);
          num1 = 1;
        }
        int pageSize1 = Sqlite3.sqlite3BtreeGetPageSize(p.pSrc);
        int pageSize2 = Sqlite3.sqlite3BtreeGetPageSize(p.pDest);
        int journalMode = Sqlite3.sqlite3PagerGetJournalMode(Sqlite3.sqlite3BtreePager(p.pDest));
        if (rc == 0 && journalMode == 5 && pageSize1 != pageSize2)
          rc = 8;
        uint num2 = Sqlite3.sqlite3BtreeLastPage(p.pSrc);
        for (int index = 0; (nPage < 0 || index < nPage) && p.iNext <= num2 && rc == 0; ++index)
        {
          uint iNext = p.iNext;
          if ((int) iNext != (int) Sqlite3.PENDING_BYTE_PAGE(p.pSrc.pBt))
          {
            Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
            rc = Sqlite3.sqlite3PagerGet(pPager1, iNext, ref ppPage);
            if (rc == 0)
            {
              rc = Sqlite3.backupOnePage(p, iNext, Sqlite3.sqlite3PagerGetData(ppPage));
              Sqlite3.sqlite3PagerUnref(ppPage);
            }
          }
          ++p.iNext;
        }
        if (rc == 0)
        {
          p.nPagecount = num2;
          p.nRemaining = num2 + 1U - p.iNext;
          if (p.iNext > num2)
            rc = 101;
          else if (p.isAttached == 0)
            Sqlite3.attachBackupObject(p);
        }
        if (rc == 101 && (rc = Sqlite3.sqlite3BtreeUpdateMeta(p.pDest, 1, p.iDestSchema + 1U)) == 0)
        {
          if (p.pDestDb != null)
            Sqlite3.sqlite3ResetInternalSchema(p.pDestDb, -1);
          uint nPage1;
          if (pageSize1 < pageSize2)
          {
            int num3 = pageSize2 / pageSize1;
            nPage1 = (uint) ((ulong) ((long) num2 + (long) num3 - 1L) / (ulong) num3);
            if ((long) nPage1 == (long) (int) Sqlite3.PENDING_BYTE_PAGE(p.pDest.pBt))
              --nPage1;
          }
          else
            nPage1 = (uint) ((ulong) num2 * (ulong) (pageSize1 / pageSize2));
          Sqlite3.sqlite3PagerTruncateImage(pPager2, nPage1);
          if (pageSize1 < pageSize2)
          {
            int num4 = (int) ((long) pageSize1 * (long) num2);
            Sqlite3.sqlite3_file sqlite3File = Sqlite3.sqlite3PagerFile(pPager2);
            rc = Sqlite3.sqlite3PagerCommitPhaseOne(pPager2, (string) null, true);
            long num5 = (long) Sqlite3.MIN(Sqlite3.PENDING_BYTE + pageSize2, num4);
            for (long offset = (long) (Sqlite3.PENDING_BYTE + pageSize1); rc == 0 && offset < num5; offset += (long) pageSize1)
            {
              Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
              uint pgno = (uint) ((ulong) offset / (ulong) pageSize1 + 1UL);
              rc = Sqlite3.sqlite3PagerGet(pPager1, pgno, ref ppPage);
              if (rc == 0)
              {
                byte[] data = Sqlite3.sqlite3PagerGetData(ppPage);
                rc = Sqlite3.sqlite3OsWrite(sqlite3File, data, pageSize1, offset);
              }
              Sqlite3.sqlite3PagerUnref(ppPage);
            }
            if (rc == 0)
              rc = Sqlite3.backupTruncateFile(sqlite3File, num4);
            if (rc == 0)
              rc = Sqlite3.sqlite3PagerSync(pPager2);
          }
          else
            rc = Sqlite3.sqlite3PagerCommitPhaseOne(pPager2, (string) null, false);
          if (rc == 0 && (rc = Sqlite3.sqlite3BtreeCommitPhaseTwo(p.pDest, 0)) == 0)
            rc = 101;
        }
        if (num1 != 0)
        {
          Sqlite3.sqlite3BtreeCommitPhaseOne(p.pSrc, (string) null);
          Sqlite3.sqlite3BtreeCommitPhaseTwo(p.pSrc, 0);
        }
        if (rc == 3082)
          rc = 7;
        p.rc = rc;
      }
      if (p.pDestDb != null)
        Sqlite3.sqlite3_mutex_leave(p.pDestDb.mutex);
      Sqlite3.sqlite3BtreeLeave(p.pSrc);
      Sqlite3.sqlite3_mutex_leave(p.pSrcDb.mutex);
      return rc;
    }

    public static int sqlite3_backup_finish(Sqlite3.sqlite3_backup p)
    {
      if (p == null)
        return 0;
      Sqlite3.sqlite3_mutex_enter(p.pSrcDb.mutex);
      Sqlite3.sqlite3BtreeEnter(p.pSrc);
      Sqlite3.sqlite3_mutex mutex = p.pSrcDb.mutex;
      if (p.pDestDb != null)
        Sqlite3.sqlite3_mutex_enter(p.pDestDb.mutex);
      if (p.pDestDb != null)
        --p.pSrc.nBackup;
      if (p.isAttached != 0)
      {
        Sqlite3.sqlite3_backup sqlite3Backup = Sqlite3.sqlite3PagerBackupPtr(Sqlite3.sqlite3BtreePager(p.pSrc));
        while (sqlite3Backup != p)
          sqlite3Backup = sqlite3Backup.pNext;
        Sqlite3.sqlite3BtreePager(p.pSrc).pBackup = p.pNext;
      }
      Sqlite3.sqlite3BtreeRollback(p.pDest);
      int err_code = p.rc == 101 ? 0 : p.rc;
      Sqlite3.sqlite3Error(p.pDestDb, err_code, 0);
      if (p.pDestDb != null)
        Sqlite3.sqlite3_mutex_leave(p.pDestDb.mutex);
      Sqlite3.sqlite3BtreeLeave(p.pSrc);
      Sqlite3.sqlite3 pDestDb = p.pDestDb;
      Sqlite3.sqlite3_mutex_leave(mutex);
      return err_code;
    }

    private static int sqlite3_backup_remaining(Sqlite3.sqlite3_backup p) => (int) p.nRemaining;

    private static int sqlite3_backup_pagecount(Sqlite3.sqlite3_backup p) => (int) p.nPagecount;

    private static void sqlite3BackupUpdate(
      Sqlite3.sqlite3_backup pBackup,
      uint iPage,
      byte[] aData)
    {
      for (Sqlite3.sqlite3_backup p = pBackup; p != null; p = p.pNext)
      {
        if (!Sqlite3.isFatalError(p.rc) && iPage < p.iNext)
        {
          Sqlite3.sqlite3_mutex_enter(p.pDestDb.mutex);
          int num = Sqlite3.backupOnePage(p, iPage, aData);
          Sqlite3.sqlite3_mutex_leave(p.pDestDb.mutex);
          if (num != 0)
            p.rc = num;
        }
      }
    }

    private static void sqlite3BackupRestart(Sqlite3.sqlite3_backup pBackup)
    {
      for (Sqlite3.sqlite3_backup sqlite3Backup = pBackup; sqlite3Backup != null; sqlite3Backup = sqlite3Backup.pNext)
        sqlite3Backup.iNext = 1U;
    }

    private static int sqlite3BtreeCopyFile(Sqlite3.Btree pTo, Sqlite3.Btree pFrom)
    {
      Sqlite3.sqlite3BtreeEnter(pTo);
      Sqlite3.sqlite3BtreeEnter(pFrom);
      Sqlite3.sqlite3_backup p = new Sqlite3.sqlite3_backup();
      p.pSrcDb = pFrom.db;
      p.pSrc = pFrom;
      p.pDest = pTo;
      p.iNext = 1U;
      Sqlite3.sqlite3_backup_step(p, int.MaxValue);
      int num = Sqlite3.sqlite3_backup_finish(p);
      if (num == 0)
        pTo.pBt.pageSizeFixed = false;
      Sqlite3.sqlite3BtreeLeave(pFrom);
      Sqlite3.sqlite3BtreeLeave(pTo);
      return num;
    }

    private static uint BITVEC_HASH(uint X) => X % Sqlite3.BITVEC_NINT;

    private static Sqlite3.Bitvec sqlite3BitvecCreate(uint iSize)
    {
      Sqlite3.Bitvec bitvec = new Sqlite3.Bitvec();
      if (bitvec != null)
        bitvec.iSize = iSize;
      return bitvec;
    }

    private static int sqlite3BitvecTest(Sqlite3.Bitvec p, uint i)
    {
      if (p == null || i == 0U || i > p.iSize)
        return 0;
      --i;
      while (p.iDivisor != 0U)
      {
        uint index = i / p.iDivisor;
        i %= p.iDivisor;
        p = p.u.apSub[(int) index];
        if (p == null)
          return 0;
      }
      if ((long) p.iSize <= (long) Sqlite3.BITVEC_NBIT)
        return ((int) p.u.aBitmap[(int) (i / 8U)] & 1 << ((int) i & 7)) == 0 ? 0 : 1;
      for (uint index = Sqlite3.BITVEC_HASH(i++); p.u.aHash[(int) index] != 0U; index = (index + 1U) % Sqlite3.BITVEC_NINT)
      {
        if ((int) p.u.aHash[(int) index] == (int) i)
          return 1;
      }
      return 0;
    }

    private static int sqlite3BitvecSet(Sqlite3.Bitvec p, uint i)
    {
      if (p == null)
        return 0;
      --i;
      uint index1;
      for (; (long) p.iSize > (long) Sqlite3.BITVEC_NBIT && p.iDivisor != 0U; p = p.u.apSub[(int) index1])
      {
        index1 = i / p.iDivisor;
        i %= p.iDivisor;
        if (p.u.apSub[(int) index1] == null)
          p.u.apSub[(int) index1] = Sqlite3.sqlite3BitvecCreate(p.iDivisor);
      }
      if ((long) p.iSize <= (long) Sqlite3.BITVEC_NBIT)
      {
        p.u.aBitmap[(int) (i / 8U)] |= (byte) (1 << ((int) i & 7));
        return 0;
      }
      uint index2 = Sqlite3.BITVEC_HASH(i++);
      if (p.u.aHash[(int) index2] == 0U)
      {
        if (p.nSet < Sqlite3.BITVEC_NINT - 1U)
          goto label_23;
      }
      else
      {
        while ((int) p.u.aHash[(int) index2] != (int) i)
        {
          ++index2;
          if (index2 >= Sqlite3.BITVEC_NINT)
            index2 = 0U;
          if (p.u.aHash[(int) index2] == 0U)
            goto label_16;
        }
        return 0;
      }
label_16:
      if ((long) p.nSet >= (long) Sqlite3.BITVEC_MXHASH)
      {
        uint[] dst = new uint[(int) Sqlite3.BITVEC_NINT];
        Buffer.BlockCopy((Array) p.u.aHash, 0, (Array) dst, 0, dst.Length * 4);
        p.u.apSub = new Sqlite3.Bitvec[Sqlite3.BITVEC_NPTR];
        p.iDivisor = (uint) ((ulong) ((long) p.iSize + (long) Sqlite3.BITVEC_NPTR - 1L) / (ulong) Sqlite3.BITVEC_NPTR);
        int num = Sqlite3.sqlite3BitvecSet(p, i);
        for (uint index3 = 0; index3 < Sqlite3.BITVEC_NINT; ++index3)
        {
          if (dst[(int) index3] != 0U)
            num |= Sqlite3.sqlite3BitvecSet(p, dst[(int) index3]);
        }
        return num;
      }
label_23:
      ++p.nSet;
      p.u.aHash[(int) index2] = i;
      return 0;
    }

    private static void sqlite3BitvecClear(Sqlite3.Bitvec p, uint i, uint[] pBuf)
    {
      if (p == null)
        return;
      --i;
      while (p.iDivisor != 0U)
      {
        uint index = i / p.iDivisor;
        i %= p.iDivisor;
        p = p.u.apSub[(int) index];
        if (p == null)
          return;
      }
      if ((long) p.iSize <= (long) Sqlite3.BITVEC_NBIT)
      {
        p.u.aBitmap[(int) (i / 8U)] &= (byte) ~(1 << ((int) i & 7));
      }
      else
      {
        uint[] destinationArray = pBuf;
        Array.Copy((Array) p.u.aHash, (Array) destinationArray, p.u.aHash.Length);
        p.u.aHash = new uint[destinationArray.Length];
        p.nSet = 0U;
        for (uint index1 = 0; index1 < Sqlite3.BITVEC_NINT; ++index1)
        {
          if (destinationArray[(int) index1] != 0U && (int) destinationArray[(int) index1] != (int) i + 1)
          {
            uint index2 = Sqlite3.BITVEC_HASH(destinationArray[(int) index1] - 1U);
            ++p.nSet;
            while (p.u.aHash[(int) index2] != 0U)
            {
              ++index2;
              if (index2 >= Sqlite3.BITVEC_NINT)
                index2 = 0U;
            }
            p.u.aHash[(int) index2] = destinationArray[(int) index1];
          }
        }
      }
    }

    private static void sqlite3BitvecDestroy(ref Sqlite3.Bitvec p)
    {
      if (p == null || p.iDivisor == 0U)
        return;
      for (uint index = 0; (long) index < (long) Sqlite3.BITVEC_NPTR; ++index)
        Sqlite3.sqlite3BitvecDestroy(ref p.u.apSub[(int) index]);
    }

    private static uint sqlite3BitvecSize(Sqlite3.Bitvec p) => p.iSize;

    private static void SETBIT(byte[] V, int I) => V[I >> 3] |= (byte) (1 << (I & 7));

    private static void CLEARBIT(byte[] V, int I) => V[I >> 3] &= (byte) ~(1 << (I & 7));

    private static int TESTBIT(byte[] V, int I) => ((int) V[I >> 3] & 1 << (I & 7)) == 0 ? 0 : 1;

    private static int sqlite3BitvecBuiltinTest(uint sz, int[] aOp)
    {
      int num1 = -1;
      Sqlite3.Bitvec p = Sqlite3.sqlite3BitvecCreate(sz);
      byte[] V = Sqlite3.sqlite3_malloc(((int) sz + 7) / 8 + 1);
      uint[] pBuf1 = new uint[Sqlite3.BITVEC_SZ];
      if (p != null && V != null && pBuf1 != null)
      {
        Array.Clear((Array) V, 0, ((int) sz + 7) / 8 + 1);
        Sqlite3.sqlite3BitvecSet((Sqlite3.Bitvec) null, 1U);
        Sqlite3.sqlite3BitvecClear((Sqlite3.Bitvec) null, 1U, pBuf1);
        int index1 = 0;
        int num2;
        while ((num2 = aOp[index1]) != 0)
        {
          int num3;
          int num4;
          switch (num2)
          {
            case 1:
            case 2:
            case 5:
              num3 = 4;
              num4 = aOp[index1 + 2] - 1;
              aOp[index1 + 2] += aOp[index1 + 3];
              break;
            default:
              num3 = 2;
              long pBuf2 = 0;
              Sqlite3.sqlite3_randomness(8, ref pBuf2);
              num4 = (int) pBuf2;
              break;
          }
          if (--aOp[index1 + 1] > 0)
            num3 = 0;
          index1 += num3;
          int num5 = (int) ((long) (num4 & int.MaxValue) % (long) sz);
          if ((num2 & 1) != 0)
          {
            Sqlite3.SETBIT(V, num5 + 1);
            if (num2 != 5 && Sqlite3.sqlite3BitvecSet(p, (uint) (num5 + 1)) != 0)
              goto label_16;
          }
          else
          {
            Sqlite3.CLEARBIT(V, num5 + 1);
            Sqlite3.sqlite3BitvecClear(p, (uint) (num5 + 1), pBuf1);
          }
        }
        num1 = Sqlite3.sqlite3BitvecTest((Sqlite3.Bitvec) null, 0U) + Sqlite3.sqlite3BitvecTest(p, sz + 1U) + Sqlite3.sqlite3BitvecTest(p, 0U) + ((int) Sqlite3.sqlite3BitvecSize(p) - (int) sz);
        for (int index2 = 1; (long) index2 <= (long) sz; ++index2)
        {
          if (Sqlite3.TESTBIT(V, index2) != Sqlite3.sqlite3BitvecTest(p, (uint) index2))
          {
            num1 = index2;
            break;
          }
        }
      }
label_16:
      Sqlite3.sqlite3BitvecDestroy(ref p);
      return num1;
    }

    private static int MX_CELL_SIZE(Sqlite3.BtShared pBt) => (int) pBt.pageSize - 8;

    private static int MX_CELL(Sqlite3.BtShared pBt) => ((int) pBt.pageSize - 8) / 6;

    private static uint PENDING_BYTE_PAGE(Sqlite3.BtShared pBt) => Sqlite3.PAGER_MJ_PGNO(pBt.pPager);

    private static uint PTRMAP_PAGENO(Sqlite3.BtShared pBt, uint pgno) => Sqlite3.ptrmapPageno(pBt, pgno);

    private static uint PTRMAP_PTROFFSET(uint pgptrmap, uint pgno) => (uint) (5 * ((int) pgno - (int) pgptrmap - 1));

    private static bool PTRMAP_ISPAGE(Sqlite3.BtShared pBt, uint pgno) => (int) Sqlite3.PTRMAP_PAGENO(pBt, pgno) == (int) pgno;

    private static void btreeIntegrity(Sqlite3.Btree p)
    {
    }

    private static int get2byte(byte[] p, int offset) => (int) p[offset] << 8 | (int) p[offset + 1];

    private static void put2byte(byte[] pData, int Offset, uint v)
    {
      pData[Offset] = (byte) (v >> 8);
      pData[Offset + 1] = (byte) v;
    }

    private static void put2byte(byte[] pData, int Offset, int v)
    {
      pData[Offset] = (byte) (v >> 8);
      pData[Offset + 1] = (byte) v;
    }

    private static void TRACE(string X, params object[] ap)
    {
    }

    private static int get2byteNotZero(byte[] X, int offset) => (Sqlite3.get2byte(X, offset) - 1 & (int) ushort.MaxValue) + 1;

    private static int querySharedCacheTableLock(Sqlite3.Btree p, uint iTab, byte eLock) => 0;

    private static void clearAllSharedCacheTableLocks(Sqlite3.Btree a)
    {
    }

    private static void downgradeAllSharedCacheTableLocks(Sqlite3.Btree a)
    {
    }

    private static bool hasSharedCacheTableLock(Sqlite3.Btree a, uint b, int c, int d) => true;

    private static bool hasReadConflicts(Sqlite3.Btree a, uint b) => false;

    private static bool cursorHoldsMutex(Sqlite3.BtCursor p) => true;

    private static void invalidateOverflowCache(Sqlite3.BtCursor pCur)
    {
    }

    private static void invalidateAllOverflowCache(Sqlite3.BtShared pBt)
    {
    }

    private static void invalidateIncrblobCursors(Sqlite3.Btree x, long y, int z)
    {
    }

    private static int btreeSetHasContent(Sqlite3.BtShared pBt, uint pgno)
    {
      int num = 0;
      if (pBt.pHasContent == null)
        pBt.pHasContent = Sqlite3.sqlite3BitvecCreate(pBt.nPage);
      if (num == 0 && pgno <= Sqlite3.sqlite3BitvecSize(pBt.pHasContent))
        num = Sqlite3.sqlite3BitvecSet(pBt.pHasContent, pgno);
      return num;
    }

    private static bool btreeGetHasContent(Sqlite3.BtShared pBt, uint pgno)
    {
      Sqlite3.Bitvec pHasContent = pBt.pHasContent;
      if (pHasContent == null)
        return false;
      return pgno > Sqlite3.sqlite3BitvecSize(pHasContent) || Sqlite3.sqlite3BitvecTest(pHasContent, pgno) != 0;
    }

    private static void btreeClearHasContent(Sqlite3.BtShared pBt)
    {
      Sqlite3.sqlite3BitvecDestroy(ref pBt.pHasContent);
      pBt.pHasContent = (Sqlite3.Bitvec) null;
    }

    private static int saveCursorPosition(Sqlite3.BtCursor pCur)
    {
      int num = Sqlite3.sqlite3BtreeKeySize(pCur, ref pCur.nKey);
      if (pCur.apPage[0].intKey == (byte) 0)
      {
        byte[] pBuf = Sqlite3.sqlite3Malloc((int) pCur.nKey);
        num = Sqlite3.sqlite3BtreeKey(pCur, 0U, (uint) pCur.nKey, pBuf);
        if (num == 0)
          pCur.pKey = pBuf;
      }
      if (num == 0)
      {
        for (int index = 0; index <= (int) pCur.iPage; ++index)
        {
          Sqlite3.releasePage(pCur.apPage[index]);
          pCur.apPage[index] = (Sqlite3.MemPage) null;
        }
        pCur.iPage = (short) -1;
        pCur.eState = 2;
      }
      Sqlite3.invalidateOverflowCache(pCur);
      return num;
    }

    private static int saveAllCursors(Sqlite3.BtShared pBt, uint iRoot, Sqlite3.BtCursor pExcept)
    {
      for (Sqlite3.BtCursor pCur = pBt.pCursor; pCur != null; pCur = pCur.pNext)
      {
        if (pCur != pExcept && (iRoot == 0U || (int) pCur.pgnoRoot == (int) iRoot) && pCur.eState == 1)
        {
          int num = Sqlite3.saveCursorPosition(pCur);
          if (num != 0)
            return num;
        }
      }
      return 0;
    }

    private static void sqlite3BtreeClearCursor(Sqlite3.BtCursor pCur)
    {
      Sqlite3.sqlite3_free(ref pCur.pKey);
      pCur.eState = 0;
    }

    private static int btreeMoveto(
      Sqlite3.BtCursor pCur,
      byte[] pKey,
      long nKey,
      int bias,
      ref int pRes)
    {
      Sqlite3.UnpackedRecord pSpace = new Sqlite3.UnpackedRecord();
      Sqlite3.UnpackedRecord unpackedRecord = pKey == null ? (Sqlite3.UnpackedRecord) null : Sqlite3.sqlite3VdbeRecordUnpack(pCur.pKeyInfo, (int) nKey, pKey, pSpace, 16);
      int num = Sqlite3.sqlite3BtreeMovetoUnpacked(pCur, unpackedRecord, nKey, bias != 0 ? 1 : 0, ref pRes);
      if (pKey == null)
        return num;
      Sqlite3.sqlite3VdbeDeleteUnpackedRecord(unpackedRecord);
      return num;
    }

    private static int btreeRestoreCursorPosition(Sqlite3.BtCursor pCur)
    {
      if (pCur.eState == 3)
        return pCur.skipNext;
      pCur.eState = 0;
      int num = Sqlite3.btreeMoveto(pCur, pCur.pKey, pCur.nKey, 0, ref pCur.skipNext);
      if (num != 0)
        return num;
      pCur.pKey = (byte[]) null;
      return num;
    }

    private static int restoreCursorPosition(Sqlite3.BtCursor pCur) => pCur.eState >= 2 ? Sqlite3.btreeRestoreCursorPosition(pCur) : 0;

    private static int sqlite3BtreeCursorHasMoved(Sqlite3.BtCursor pCur, ref int pHasMoved)
    {
      int num = Sqlite3.restoreCursorPosition(pCur);
      if (num != 0)
      {
        pHasMoved = 1;
        return num;
      }
      pHasMoved = pCur.eState != 1 || pCur.skipNext != 0 ? 1 : 0;
      return 0;
    }

    private static uint ptrmapPageno(Sqlite3.BtShared pBt, uint pgno)
    {
      if (pgno < 2U)
        return 0;
      int num1 = (int) (pBt.usableSize / 5U) + 1;
      uint num2 = (uint) ((ulong) (uint) ((ulong) (pgno - 2U) / (ulong) num1) * (ulong) num1) + 2U;
      if ((int) num2 == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
        ++num2;
      return num2;
    }

    private static void ptrmapPut(
      Sqlite3.BtShared pBt,
      uint key,
      byte eType,
      uint parent,
      ref int pRC)
    {
      Sqlite3.PgHdr ppPage = new Sqlite3.PgHdr();
      if (pRC != 0)
        return;
      if (key == 0U)
      {
        pRC = Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      else
      {
        uint num1 = Sqlite3.PTRMAP_PAGENO(pBt, key);
        int num2 = Sqlite3.sqlite3PagerGet(pBt.pPager, num1, ref ppPage);
        if (num2 != 0)
        {
          pRC = num2;
        }
        else
        {
          int index = (int) Sqlite3.PTRMAP_PTROFFSET(num1, key);
          if (index < 0)
          {
            pRC = Sqlite3.SQLITE_CORRUPT_BKPT();
          }
          else
          {
            byte[] data = Sqlite3.sqlite3PagerGetData(ppPage);
            if ((int) eType != (int) data[index] || (int) Sqlite3.sqlite3Get4byte(data, index + 1) != (int) parent)
            {
              Sqlite3.TRACE("PTRMAP_UPDATE: %d->(%d,%d)\n", (object) key, (object) eType, (object) parent);
              if ((pRC = Sqlite3.sqlite3PagerWrite(ppPage)) == 0)
              {
                data[index] = eType;
                Sqlite3.sqlite3Put4byte(data, index + 1, (ulong) parent);
              }
            }
          }
          Sqlite3.sqlite3PagerUnref(ppPage);
        }
      }
    }

    private static int ptrmapGet(Sqlite3.BtShared pBt, uint key, ref byte pEType, ref uint pPgno)
    {
      Sqlite3.PgHdr ppPage = new Sqlite3.PgHdr();
      int num1 = (int) Sqlite3.PTRMAP_PAGENO(pBt, key);
      int num2 = Sqlite3.sqlite3PagerGet(pBt.pPager, (uint) num1, ref ppPage);
      if (num2 != 0)
        return num2;
      byte[] data = Sqlite3.sqlite3PagerGetData(ppPage);
      int index = (int) Sqlite3.PTRMAP_PTROFFSET((uint) num1, key);
      if (index < 0)
      {
        Sqlite3.sqlite3PagerUnref(ppPage);
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      pEType = data[index];
      pPgno = Sqlite3.sqlite3Get4byte(data, index + 1);
      Sqlite3.sqlite3PagerUnref(ppPage);
      return pEType < (byte) 1 || pEType > (byte) 5 ? Sqlite3.SQLITE_CORRUPT_BKPT() : 0;
    }

    private static int findCell(Sqlite3.MemPage pPage, int iCell) => Sqlite3.get2byte(pPage.aData, (int) pPage.cellOffset + 2 * iCell);

    private static byte[] findCellv2(byte[] pPage, ushort iCell, ushort O, int I)
    {
      Debugger.Break();
      return pPage;
    }

    private static int findOverflowCell(Sqlite3.MemPage pPage, int iCell)
    {
      for (int index = (int) pPage.nOverflow - 1; index >= 0; --index)
      {
        int idx = (int) pPage.aOvfl[index].idx;
        if (idx <= iCell)
        {
          if (idx == iCell)
            return -index - 1;
          --iCell;
        }
      }
      return Sqlite3.findCell(pPage, iCell);
    }

    private static void btreeParseCellPtr(
      Sqlite3.MemPage pPage,
      int iCell,
      ref Sqlite3.CellInfo pInfo)
    {
      Sqlite3.btreeParseCellPtr(pPage, pPage.aData, iCell, ref pInfo);
    }

    private static void btreeParseCellPtr(
      Sqlite3.MemPage pPage,
      byte[] pCell,
      ref Sqlite3.CellInfo pInfo)
    {
      Sqlite3.btreeParseCellPtr(pPage, pCell, 0, ref pInfo);
    }

    private static void btreeParseCellPtr(
      Sqlite3.MemPage pPage,
      byte[] pCell,
      int iCell,
      ref Sqlite3.CellInfo pInfo)
    {
      uint v = 0;
      if (pInfo.pCell != pCell)
        pInfo.pCell = pCell;
      pInfo.iCell = iCell;
      ushort childPtrSize = (ushort) pPage.childPtrSize;
      ushort num1;
      if (pPage.intKey != (byte) 0)
      {
        if (pPage.hasData != (byte) 0)
          childPtrSize += (ushort) Sqlite3.getVarint32(pCell, iCell + (int) childPtrSize, out v);
        else
          v = 0U;
        num1 = (ushort) ((uint) childPtrSize + (uint) (ushort) Sqlite3.getVarint(pCell, iCell + (int) childPtrSize, out pInfo.nKey));
        pInfo.nData = v;
      }
      else
      {
        pInfo.nData = 0U;
        num1 = (ushort) ((uint) childPtrSize + (uint) (ushort) Sqlite3.getVarint32(pCell, iCell + (int) childPtrSize, out v));
        pInfo.nKey = (long) v;
      }
      pInfo.nPayload = v;
      pInfo.nHeader = num1;
      Sqlite3.testcase<bool>((int) v == (int) pPage.maxLocal);
      Sqlite3.testcase<bool>((long) v == (long) ((int) pPage.maxLocal + 1));
      if (Sqlite3.likely(v <= (uint) pPage.maxLocal))
      {
        if ((pInfo.nSize = (ushort) ((uint) num1 + v)) < (ushort) 4)
          pInfo.nSize = (ushort) 4;
        pInfo.nLocal = (ushort) v;
        pInfo.iOverflow = (ushort) 0;
      }
      else
      {
        int minLocal = (int) pPage.minLocal;
        int maxLocal = (int) pPage.maxLocal;
        int num2 = (int) ((long) minLocal + ((long) v - (long) minLocal) % (long) (pPage.pBt.usableSize - 4U));
        Sqlite3.testcase<bool>(num2 == maxLocal);
        Sqlite3.testcase<bool>(num2 == maxLocal + 1);
        pInfo.nLocal = num2 > maxLocal ? (ushort) minLocal : (ushort) num2;
        pInfo.iOverflow = (ushort) ((uint) pInfo.nLocal + (uint) num1);
        pInfo.nSize = (ushort) ((uint) pInfo.iOverflow + 4U);
      }
    }

    private static void parseCell(Sqlite3.MemPage pPage, int iCell, ref Sqlite3.CellInfo pInfo) => Sqlite3.btreeParseCellPtr(pPage, Sqlite3.findCell(pPage, iCell), ref pInfo);

    private static void btreeParseCell(
      Sqlite3.MemPage pPage,
      int iCell,
      ref Sqlite3.CellInfo pInfo)
    {
      Sqlite3.parseCell(pPage, iCell, ref pInfo);
    }

    private static ushort cellSizePtr(Sqlite3.MemPage pPage, int iCell)
    {
      Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
      byte[] numArray = new byte[13];
      if (iCell < 0)
        Buffer.BlockCopy((Array) pPage.aOvfl[-(iCell + 1)].pCell, 0, (Array) numArray, 0, numArray.Length < pPage.aOvfl[-(iCell + 1)].pCell.Length ? numArray.Length : pPage.aOvfl[-(iCell + 1)].pCell.Length);
      else if (iCell >= pPage.aData.Length + 1 - numArray.Length)
        Buffer.BlockCopy((Array) pPage.aData, iCell, (Array) numArray, 0, pPage.aData.Length - iCell);
      else
        Buffer.BlockCopy((Array) pPage.aData, iCell, (Array) numArray, 0, numArray.Length);
      Sqlite3.btreeParseCellPtr(pPage, numArray, ref pInfo);
      return pInfo.nSize;
    }

    private static ushort cellSizePtr(Sqlite3.MemPage pPage, byte[] pCell, int offset)
    {
      Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
      pInfo.pCell = Sqlite3.sqlite3Malloc(pCell.Length);
      Buffer.BlockCopy((Array) pCell, offset, (Array) pInfo.pCell, 0, pCell.Length - offset);
      Sqlite3.btreeParseCellPtr(pPage, pInfo.pCell, ref pInfo);
      return pInfo.nSize;
    }

    private static ushort cellSizePtr(Sqlite3.MemPage pPage, byte[] pCell)
    {
      int childPtrSize = (int) pPage.childPtrSize;
      uint v = 0;
      if (pPage.intKey != (byte) 0)
      {
        if (pPage.hasData != (byte) 0)
          childPtrSize += Sqlite3.getVarint32(pCell, out v);
        else
          v = 0U;
        int num = childPtrSize + 9;
        while (((int) pCell[childPtrSize++] & 128) != 0 && childPtrSize < num)
          ;
      }
      else
        childPtrSize += Sqlite3.getVarint32(pCell, childPtrSize, out v);
      Sqlite3.testcase<bool>((int) v == (int) pPage.maxLocal);
      Sqlite3.testcase<bool>((long) v == (long) ((int) pPage.maxLocal + 1));
      if (v > (uint) pPage.maxLocal)
      {
        int minLocal = (int) pPage.minLocal;
        v = (uint) ((ulong) minLocal + ((ulong) v - (ulong) minLocal) % (ulong) (pPage.pBt.usableSize - 4U));
        Sqlite3.testcase<bool>((int) v == (int) pPage.maxLocal);
        Sqlite3.testcase<bool>((long) v == (long) ((int) pPage.maxLocal + 1));
        if (v > (uint) pPage.maxLocal)
          v = (uint) minLocal;
        v += 4U;
      }
      v += (uint) childPtrSize;
      if (v < 4U)
        v = 4U;
      return (ushort) v;
    }

    private static int cellSize(Sqlite3.MemPage pPage, int iCell) => -1;

    private static void ptrmapPutOvflPtr(Sqlite3.MemPage pPage, int pCell, ref int pRC)
    {
      if (pRC != 0)
        return;
      Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
      Sqlite3.btreeParseCellPtr(pPage, pCell, ref pInfo);
      if (pInfo.iOverflow == (ushort) 0)
        return;
      uint key = Sqlite3.sqlite3Get4byte(pPage.aData, pCell, (int) pInfo.iOverflow);
      Sqlite3.ptrmapPut(pPage.pBt, key, (byte) 3, pPage.pgno, ref pRC);
    }

    private static void ptrmapPutOvflPtr(Sqlite3.MemPage pPage, byte[] pCell, ref int pRC)
    {
      if (pRC != 0)
        return;
      Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
      Sqlite3.btreeParseCellPtr(pPage, pCell, ref pInfo);
      if (pInfo.iOverflow == (ushort) 0)
        return;
      uint key = Sqlite3.sqlite3Get4byte(pCell, (int) pInfo.iOverflow);
      Sqlite3.ptrmapPut(pPage.pBt, key, (byte) 3, pPage.pgno, ref pRC);
    }

    private static int defragmentPage(Sqlite3.MemPage pPage)
    {
      byte[] numArray = Sqlite3.sqlite3PagerTempSpace(pPage.pBt.pPager);
      byte[] aData = pPage.aData;
      int hdrOffset = (int) pPage.hdrOffset;
      int cellOffset = (int) pPage.cellOffset;
      int nCell = (int) pPage.nCell;
      int usableSize = (int) pPage.pBt.usableSize;
      int num1 = Sqlite3.get2byte(aData, hdrOffset + 5);
      Buffer.BlockCopy((Array) aData, num1, (Array) numArray, num1, usableSize - num1);
      int num2 = usableSize;
      int num3 = cellOffset + 2 * nCell;
      int num4 = usableSize - 4;
      for (int index = 0; index < nCell; ++index)
      {
        int num5 = cellOffset + index * 2;
        int num6 = Sqlite3.get2byte(aData, num5);
        Sqlite3.testcase<bool>(num6 == num3);
        Sqlite3.testcase<bool>(num6 == num4);
        int count = (int) Sqlite3.cellSizePtr(pPage, numArray, num6);
        num2 -= count;
        if (num2 < num3 || num6 + count > usableSize)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        Sqlite3.testcase<bool>(num2 + count == usableSize);
        Sqlite3.testcase<bool>(num6 + count == usableSize);
        Buffer.BlockCopy((Array) numArray, num6, (Array) aData, num2, count);
        Sqlite3.put2byte(aData, num5, num2);
      }
      Sqlite3.put2byte(aData, hdrOffset + 5, num2);
      aData[hdrOffset + 1] = (byte) 0;
      aData[hdrOffset + 2] = (byte) 0;
      aData[hdrOffset + 7] = (byte) 0;
      int index1 = cellOffset + 2 * nCell;
      Array.Clear((Array) aData, index1, num2 - index1);
      return num2 - num3 != (int) pPage.nFree ? Sqlite3.SQLITE_CORRUPT_BKPT() : 0;
    }

    private static int allocateSpace(Sqlite3.MemPage pPage, int nByte, ref int pIdx)
    {
      int hdrOffset = (int) pPage.hdrOffset;
      byte[] aData = pPage.aData;
      uint usableSize = pPage.pBt.usableSize;
      int num1 = (int) aData[hdrOffset + 7];
      int num2 = (int) pPage.cellOffset + 2 * (int) pPage.nCell;
      int num3 = Sqlite3.get2byteNotZero(aData, hdrOffset + 5);
      if (num2 > num3)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      Sqlite3.testcase<bool>(num2 + 2 == num3);
      Sqlite3.testcase<bool>(num2 + 1 == num3);
      Sqlite3.testcase<bool>(num2 == num3);
      if (num1 >= 60)
      {
        int num4 = Sqlite3.defragmentPage(pPage);
        if (num4 != 0)
          return num4;
        num3 = Sqlite3.get2byteNotZero(aData, hdrOffset + 5);
      }
      else if (num2 + 2 <= num3)
      {
        int index;
        for (int offset = hdrOffset + 1; (index = Sqlite3.get2byte(aData, offset)) > 0; offset = index)
        {
          if ((long) index > (long) (usableSize - 4U) || index < offset + 4)
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          int num5 = Sqlite3.get2byte(aData, index + 2);
          if (num5 >= nByte)
          {
            int v = num5 - nByte;
            Sqlite3.testcase<bool>(v == 4);
            Sqlite3.testcase<bool>(v == 3);
            if (v < 4)
            {
              aData[offset] = aData[index];
              aData[offset + 1] = aData[index + 1];
              aData[hdrOffset + 7] = (byte) (num1 + v);
            }
            else
            {
              if ((long) (num5 + index) > (long) usableSize)
                return Sqlite3.SQLITE_CORRUPT_BKPT();
              Sqlite3.put2byte(aData, index + 2, v);
            }
            pIdx = index + v;
            return 0;
          }
        }
      }
      Sqlite3.testcase<bool>(num2 + 2 + nByte == num3);
      if (num2 + 2 + nByte > num3)
      {
        int num6 = Sqlite3.defragmentPage(pPage);
        if (num6 != 0)
          return num6;
        num3 = Sqlite3.get2byteNotZero(aData, hdrOffset + 5);
      }
      int v1 = num3 - nByte;
      Sqlite3.put2byte(aData, hdrOffset + 5, v1);
      pIdx = v1;
      return 0;
    }

    private static int freeSpace(Sqlite3.MemPage pPage, uint start, int size) => Sqlite3.freeSpace(pPage, (int) start, size);

    private static int freeSpace(Sqlite3.MemPage pPage, int start, int size)
    {
      byte[] aData = pPage.aData;
      if (pPage.pBt.secureDelete)
        Array.Clear((Array) aData, start, size);
      int hdrOffset = (int) pPage.hdrOffset;
      int num1 = hdrOffset + 1;
      int num2 = (int) pPage.pBt.usableSize - 4;
      int v1;
      for (; (v1 = Sqlite3.get2byte(aData, num1)) < start && v1 > 0; num1 = v1)
      {
        if (v1 < num1 + 4)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      if (v1 > num2)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      Sqlite3.put2byte(aData, num1, start);
      Sqlite3.put2byte(aData, start, v1);
      Sqlite3.put2byte(aData, start + 2, size);
      pPage.nFree += (ushort) size;
      int offset1 = hdrOffset + 1;
      int num3;
      while ((num3 = Sqlite3.get2byte(aData, offset1)) > 0)
      {
        int offset2 = Sqlite3.get2byte(aData, num3);
        int num4 = Sqlite3.get2byte(aData, num3 + 2);
        if (num3 + num4 + 3 >= offset2 && offset2 > 0)
        {
          int num5 = offset2 - (num3 + num4);
          if (num5 < 0 || num5 > (int) aData[hdrOffset + 7])
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          aData[hdrOffset + 7] -= (byte) num5;
          int v2 = Sqlite3.get2byte(aData, offset2);
          Sqlite3.put2byte(aData, num3, v2);
          int v3 = offset2 + Sqlite3.get2byte(aData, offset2 + 2) - num3;
          Sqlite3.put2byte(aData, num3 + 2, v3);
        }
        else
          offset1 = num3;
      }
      if ((int) aData[hdrOffset + 1] == (int) aData[hdrOffset + 5] && (int) aData[hdrOffset + 2] == (int) aData[hdrOffset + 6])
      {
        int offset3 = Sqlite3.get2byte(aData, hdrOffset + 1);
        Sqlite3.put2byte(aData, hdrOffset + 1, Sqlite3.get2byte(aData, offset3));
        int v4 = Sqlite3.get2byte(aData, hdrOffset + 5) + Sqlite3.get2byte(aData, offset3 + 2);
        Sqlite3.put2byte(aData, hdrOffset + 5, v4);
      }
      return 0;
    }

    private static int decodeFlags(Sqlite3.MemPage pPage, int flagByte)
    {
      pPage.leaf = (byte) (flagByte >> 3);
      flagByte &= -9;
      pPage.childPtrSize = (byte) (4 - 4 * (int) pPage.leaf);
      Sqlite3.BtShared pBt = pPage.pBt;
      switch (flagByte)
      {
        case 2:
          pPage.intKey = (byte) 0;
          pPage.hasData = (byte) 0;
          pPage.maxLocal = pBt.maxLocal;
          pPage.minLocal = pBt.minLocal;
          break;
        case 5:
          pPage.intKey = (byte) 1;
          pPage.hasData = pPage.leaf;
          pPage.maxLocal = pBt.maxLeaf;
          pPage.minLocal = pBt.minLeaf;
          break;
        default:
          return Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      return 0;
    }

    private static int btreeInitPage(Sqlite3.MemPage pPage)
    {
      if (pPage.isInit == (byte) 0)
      {
        Sqlite3.BtShared pBt = pPage.pBt;
        byte hdrOffset = pPage.hdrOffset;
        byte[] aData = pPage.aData;
        if (Sqlite3.decodeFlags(pPage, (int) aData[(int) hdrOffset]) != 0)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        pPage.maskPage = (ushort) (pBt.pageSize - 1U);
        pPage.nOverflow = (byte) 0;
        int usableSize = (int) pBt.usableSize;
        ushort num1;
        pPage.cellOffset = num1 = (ushort) ((int) hdrOffset + 12 - 4 * (int) pPage.leaf);
        int num2 = Sqlite3.get2byteNotZero(aData, (int) hdrOffset + 5);
        pPage.nCell = (ushort) Sqlite3.get2byte(aData, (int) hdrOffset + 3);
        if ((int) pPage.nCell > Sqlite3.MX_CELL(pBt))
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        Sqlite3.testcase<bool>((int) pPage.nCell == Sqlite3.MX_CELL(pBt));
        int num3 = (int) num1 + 2 * (int) pPage.nCell;
        int num4 = usableSize - 4;
        if (pPage.leaf == (byte) 0)
          --num4;
        for (int index = 0; index < (int) pPage.nCell; ++index)
        {
          ushort offset = (ushort) Sqlite3.get2byte(aData, (int) num1 + index * 2);
          Sqlite3.testcase<bool>((int) offset == num3);
          Sqlite3.testcase<bool>((int) offset == num4);
          if ((int) offset < num3 || (int) offset > num4)
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          int num5 = (int) Sqlite3.cellSizePtr(pPage, aData, (int) offset);
          Sqlite3.testcase<bool>((int) offset + num5 == usableSize);
          if ((int) offset + num5 > usableSize)
            return Sqlite3.SQLITE_CORRUPT_BKPT();
        }
        if (pPage.leaf == (byte) 0)
          ++num4;
        ushort offset1 = (ushort) Sqlite3.get2byte(aData, (int) hdrOffset + 1);
        int num6 = (int) (ushort) ((uint) aData[(int) hdrOffset + 7] + (uint) num2);
        ushort num7;
        for (; offset1 > (ushort) 0; offset1 = num7)
        {
          if ((int) offset1 < num3 || (int) offset1 > num4)
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          num7 = (ushort) Sqlite3.get2byte(aData, (int) offset1);
          ushort num8 = (ushort) Sqlite3.get2byte(aData, (int) offset1 + 2);
          if (num7 > (ushort) 0 && (int) num7 <= (int) offset1 + (int) num8 + 3 || (int) offset1 + (int) num8 > usableSize)
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          num6 = (int) (ushort) ((uint) num6 + (uint) num8);
        }
        if (num6 > usableSize)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        pPage.nFree = (ushort) (num6 - num3);
        pPage.isInit = (byte) 1;
      }
      return 0;
    }

    private static void zeroPage(Sqlite3.MemPage pPage, int flags)
    {
      byte[] aData = pPage.aData;
      Sqlite3.BtShared pBt = pPage.pBt;
      byte hdrOffset = pPage.hdrOffset;
      if (pBt.secureDelete)
        Array.Clear((Array) aData, (int) hdrOffset, (int) pBt.usableSize - (int) hdrOffset);
      aData[(int) hdrOffset] = (byte) flags;
      ushort num = (ushort) ((int) hdrOffset + 8 + 4 * ((flags & 8) == 0 ? 1 : 0));
      Array.Clear((Array) aData, (int) hdrOffset + 1, 4);
      aData[(int) hdrOffset + 7] = (byte) 0;
      Sqlite3.put2byte(aData, (int) hdrOffset + 5, pBt.usableSize);
      pPage.nFree = (ushort) (pBt.usableSize - (uint) num);
      Sqlite3.decodeFlags(pPage, flags);
      pPage.hdrOffset = hdrOffset;
      pPage.cellOffset = num;
      pPage.nOverflow = (byte) 0;
      pPage.maskPage = (ushort) (pBt.pageSize - 1U);
      pPage.nCell = (ushort) 0;
      pPage.isInit = (byte) 1;
    }

    private static Sqlite3.MemPage btreePageFromDbPage(
      Sqlite3.PgHdr pDbPage,
      uint pgno,
      Sqlite3.BtShared pBt)
    {
      Sqlite3.MemPage extra = Sqlite3.sqlite3PagerGetExtra(pDbPage);
      extra.aData = Sqlite3.sqlite3PagerGetData(pDbPage);
      extra.pDbPage = pDbPage;
      extra.pBt = pBt;
      extra.pgno = pgno;
      extra.hdrOffset = extra.pgno == 1U ? (byte) 100 : (byte) 0;
      return extra;
    }

    private static int btreeGetPage(
      Sqlite3.BtShared pBt,
      uint pgno,
      ref Sqlite3.MemPage ppPage,
      int noContent)
    {
      Sqlite3.PgHdr ppPage1 = (Sqlite3.PgHdr) null;
      int page = Sqlite3.sqlite3PagerAcquire(pBt.pPager, pgno, ref ppPage1, (byte) noContent);
      if (page != 0)
        return page;
      ppPage = Sqlite3.btreePageFromDbPage(ppPage1, pgno, pBt);
      return 0;
    }

    private static Sqlite3.MemPage btreePageLookup(Sqlite3.BtShared pBt, uint pgno)
    {
      Sqlite3.PgHdr pDbPage = Sqlite3.sqlite3PagerLookup(pBt.pPager, pgno);
      return (bool) pDbPage ? Sqlite3.btreePageFromDbPage(pDbPage, pgno, pBt) : (Sqlite3.MemPage) null;
    }

    private static uint btreePagecount(Sqlite3.BtShared pBt) => pBt.nPage;

    private static uint sqlite3BtreeLastPage(Sqlite3.Btree p) => Sqlite3.btreePagecount(p.pBt);

    private static int getAndInitPage(Sqlite3.BtShared pBt, uint pgno, ref Sqlite3.MemPage ppPage)
    {
      int andInitPage;
      if (pgno > Sqlite3.btreePagecount(pBt))
      {
        andInitPage = Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      else
      {
        andInitPage = Sqlite3.btreeGetPage(pBt, pgno, ref ppPage, 0);
        if (andInitPage == 0)
        {
          andInitPage = Sqlite3.btreeInitPage(ppPage);
          if (andInitPage != 0)
            Sqlite3.releasePage(ppPage);
        }
      }
      Sqlite3.testcase<bool>(pgno == 0U);
      return andInitPage;
    }

    private static void releasePage(Sqlite3.MemPage pPage)
    {
      if (pPage == null)
        return;
      Sqlite3.sqlite3PagerUnref(pPage.pDbPage);
    }

    private static void pageReinit(Sqlite3.PgHdr pData)
    {
      Sqlite3.MemPage extra = Sqlite3.sqlite3PagerGetExtra(pData);
      if (extra.isInit == (byte) 0)
        return;
      extra.isInit = (byte) 0;
      if (Sqlite3.sqlite3PagerPageRefcount(pData) <= 1)
        return;
      Sqlite3.btreeInitPage(extra);
    }

    private static int btreeInvokeBusyHandler(object pArg) => Sqlite3.sqlite3InvokeBusyHandler(((Sqlite3.BtShared) pArg).db.busyHandler);

    private static int sqlite3BtreeOpen(
      Sqlite3.sqlite3_vfs pVfs,
      string zFilename,
      Sqlite3.sqlite3 db,
      ref Sqlite3.Btree ppBtree,
      int flags,
      int vfsFlags)
    {
      Sqlite3.BtShared pBusyHandlerArg = (Sqlite3.BtShared) null;
      Sqlite3.sqlite3_mutex m = (Sqlite3.sqlite3_mutex) null;
      int num = 0;
      byte[] numArray = new byte[100];
      bool flag1 = string.IsNullOrEmpty(zFilename);
      bool flag2 = zFilename == ":memory:" || flag1 && Sqlite3.sqlite3TempInMemory(db);
      if ((db.flags & 131072) != 0)
        flags |= 2;
      if (flag2)
        flags |= 4;
      if ((vfsFlags & 256) != 0 && flag2 | flag1)
        vfsFlags = vfsFlags & -257 | 512;
      Sqlite3.Btree p = new Sqlite3.Btree();
      p.inTrans = (byte) 0;
      p.db = db;
      if (pBusyHandlerArg == null)
      {
        pBusyHandlerArg = new Sqlite3.BtShared();
        num = Sqlite3.sqlite3PagerOpen(pVfs, out pBusyHandlerArg.pPager, zFilename, 0, flags, vfsFlags, new Sqlite3.dxReiniter(Sqlite3.pageReinit));
        if (num == 0)
          num = Sqlite3.sqlite3PagerReadFileheader(pBusyHandlerArg.pPager, numArray.Length, numArray);
        if (num == 0)
        {
          pBusyHandlerArg.openFlags = (byte) flags;
          pBusyHandlerArg.db = db;
          Sqlite3.sqlite3PagerSetBusyhandler(pBusyHandlerArg.pPager, new Sqlite3.dxBusyHandler(Sqlite3.btreeInvokeBusyHandler), (object) pBusyHandlerArg);
          p.pBt = pBusyHandlerArg;
          pBusyHandlerArg.pCursor = (Sqlite3.BtCursor) null;
          pBusyHandlerArg.pPage1 = (Sqlite3.MemPage) null;
          pBusyHandlerArg.readOnly = Sqlite3.sqlite3PagerIsreadonly(pBusyHandlerArg.pPager);
          pBusyHandlerArg.pageSize = (uint) ((int) numArray[16] << 8 | (int) numArray[17] << 16);
          byte nReserve;
          if (pBusyHandlerArg.pageSize < 512U || pBusyHandlerArg.pageSize > (uint) ushort.MaxValue || ((int) pBusyHandlerArg.pageSize - 1 & (int) pBusyHandlerArg.pageSize) != 0)
          {
            pBusyHandlerArg.pageSize = 0U;
            if (zFilename != "" && !flag2)
            {
              pBusyHandlerArg.autoVacuum = false;
              pBusyHandlerArg.incrVacuum = false;
            }
            nReserve = (byte) 0;
          }
          else
          {
            nReserve = numArray[20];
            pBusyHandlerArg.pageSizeFixed = true;
            pBusyHandlerArg.autoVacuum = Sqlite3.sqlite3Get4byte(numArray, 52) > 0U;
            pBusyHandlerArg.incrVacuum = Sqlite3.sqlite3Get4byte(numArray, 64) > 0U;
          }
          num = Sqlite3.sqlite3PagerSetPagesize(pBusyHandlerArg.pPager, ref pBusyHandlerArg.pageSize, (int) nReserve);
          if (num == 0)
            pBusyHandlerArg.usableSize = (uint) (ushort) (pBusyHandlerArg.pageSize - (uint) nReserve);
          else
            goto label_18;
        }
        else
          goto label_18;
      }
      ppBtree = p;
label_18:
      if (num != 0)
      {
        if (pBusyHandlerArg != null && pBusyHandlerArg.pPager != null)
          Sqlite3.sqlite3PagerClose(pBusyHandlerArg.pPager);
        ppBtree = (Sqlite3.Btree) null;
      }
      else if (Sqlite3.sqlite3BtreeSchema(p, 0, (Sqlite3.dxFreeSchema) null) == null)
        Sqlite3.sqlite3PagerSetCachesize(p.pBt.pPager, 2000);
      if (m != null)
        Sqlite3.sqlite3_mutex_leave(m);
      return num;
    }

    private static bool removeFromSharingList(Sqlite3.BtShared pBt) => true;

    private static void allocateTempSpace(Sqlite3.BtShared pBt)
    {
      if (pBt.pTmpSpace != null)
        return;
      pBt.pTmpSpace = Sqlite3.sqlite3Malloc(pBt.pageSize);
    }

    private static void freeTempSpace(Sqlite3.BtShared pBt) => Sqlite3.sqlite3PageFree(ref pBt.pTmpSpace);

    private static int sqlite3BtreeClose(ref Sqlite3.Btree p)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      Sqlite3.BtCursor btCursor = pBt.pCursor;
      while (btCursor != null)
      {
        Sqlite3.BtCursor pCur = btCursor;
        btCursor = btCursor.pNext;
        if (pCur.pBtree == p)
          Sqlite3.sqlite3BtreeCloseCursor(pCur);
      }
      Sqlite3.sqlite3BtreeRollback(p);
      Sqlite3.sqlite3BtreeLeave(p);
      if (!p.sharable || Sqlite3.removeFromSharingList(pBt))
      {
        Sqlite3.sqlite3PagerClose(pBt.pPager);
        if (pBt.xFreeSchema != null && pBt.pSchema != null)
          pBt.xFreeSchema(pBt.pSchema);
        pBt.pSchema = (Sqlite3.Schema) null;
      }
      return 0;
    }

    private static int sqlite3BtreeSetCacheSize(Sqlite3.Btree p, int mxPage)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      Sqlite3.sqlite3PagerSetCachesize(pBt.pPager, mxPage);
      Sqlite3.sqlite3BtreeLeave(p);
      return 0;
    }

    private static int sqlite3BtreeSetSafetyLevel(
      Sqlite3.Btree p,
      int level,
      int fullSync,
      int ckptFullSync)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      Sqlite3.sqlite3PagerSetSafetyLevel(pBt.pPager, level, fullSync, ckptFullSync);
      Sqlite3.sqlite3BtreeLeave(p);
      return 0;
    }

    private static int sqlite3BtreeSyncDisabled(Sqlite3.Btree p)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.sqlite3PagerNosync(pBt.pPager) ? 1 : 0;
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeSetPageSize(
      Sqlite3.Btree p,
      int pageSize,
      int nReserve,
      int iFix)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      if (pBt.pageSizeFixed)
      {
        Sqlite3.sqlite3BtreeLeave(p);
        return 8;
      }
      if (nReserve < 0)
        nReserve = (int) pBt.pageSize - (int) pBt.usableSize;
      if (pageSize >= 512 && pageSize <= (int) ushort.MaxValue && (pageSize - 1 & pageSize) == 0)
        pBt.pageSize = (uint) pageSize;
      int num = Sqlite3.sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, nReserve);
      pBt.usableSize = (uint) (ushort) ((ulong) pBt.pageSize - (ulong) nReserve);
      if (iFix != 0)
        pBt.pageSizeFixed = true;
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeGetPageSize(Sqlite3.Btree p) => (int) p.pBt.pageSize;

    private static int sqlite3BtreeGetReserve(Sqlite3.Btree p)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int reserve = (int) p.pBt.pageSize - (int) p.pBt.usableSize;
      Sqlite3.sqlite3BtreeLeave(p);
      return reserve;
    }

    private static uint sqlite3BtreeMaxPageCount(Sqlite3.Btree p, int mxPage)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int num = (int) Sqlite3.sqlite3PagerMaxPageCount(p.pBt.pPager, mxPage);
      Sqlite3.sqlite3BtreeLeave(p);
      return (uint) num;
    }

    private static int sqlite3BtreeSecureDelete(Sqlite3.Btree p, int newFlag)
    {
      if (p == null)
        return 0;
      Sqlite3.sqlite3BtreeEnter(p);
      if (newFlag >= 0)
        p.pBt.secureDelete = newFlag != 0;
      int num = p.pBt.secureDelete ? 1 : 0;
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeSetAutoVacuum(Sqlite3.Btree p, int autoVacuum)
    {
      Sqlite3.BtShared pBt = p.pBt;
      int num1 = 0;
      byte num2 = (byte) autoVacuum;
      Sqlite3.sqlite3BtreeEnter(p);
      if (pBt.pageSizeFixed && num2 > (byte) 0 != pBt.autoVacuum)
      {
        num1 = 8;
      }
      else
      {
        pBt.autoVacuum = num2 > (byte) 0;
        pBt.incrVacuum = num2 == (byte) 2;
      }
      Sqlite3.sqlite3BtreeLeave(p);
      return num1;
    }

    private static int sqlite3BtreeGetAutoVacuum(Sqlite3.Btree p)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int autoVacuum = !p.pBt.autoVacuum ? 0 : (!p.pBt.incrVacuum ? 1 : 2);
      Sqlite3.sqlite3BtreeLeave(p);
      return autoVacuum;
    }

    private static int lockBtree(Sqlite3.BtShared pBt)
    {
      Sqlite3.MemPage ppPage = (Sqlite3.MemPage) null;
      uint pnPage = 0;
      int num1 = Sqlite3.sqlite3PagerSharedLock(pBt.pPager);
      if (num1 != 0)
        return num1;
      int page = Sqlite3.btreeGetPage(pBt, 1U, ref ppPage, 0);
      if (page != 0)
        return page;
      uint num2 = Sqlite3.sqlite3Get4byte(ppPage.aData, 28);
      Sqlite3.sqlite3PagerPagecount(pBt.pPager, out pnPage);
      if (num2 == 0U || Sqlite3.memcmp(ppPage.aData, 24, ppPage.aData, 92, 4) != 0)
        num2 = pnPage;
      if (num2 > 0U)
      {
        byte[] aData = ppPage.aData;
        int num3 = 26;
        if (Sqlite3.memcmp(aData, Sqlite3.zMagicHeader, 16) == 0)
        {
          if (aData[18] > (byte) 1)
            pBt.readOnly = true;
          if (aData[19] > (byte) 1)
            pBt.pSchema.file_format = aData[19];
          else if (Sqlite3.memcmp(aData, 21, "@  ", 3) == 0)
          {
            uint num4 = (uint) ((int) aData[16] << 8 | (int) aData[17] << 16);
            if (((int) num4 - 1 & (int) num4) == 0 && num4 <= (uint) ushort.MaxValue && num4 > 256U)
            {
              uint num5 = num4 - (uint) aData[20];
              if ((int) num4 != (int) pBt.pageSize)
              {
                Sqlite3.releasePage(ppPage);
                pBt.usableSize = num5;
                pBt.pageSize = num4;
                return Sqlite3.sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, (int) num4 - (int) num5);
              }
              if ((pBt.db.flags & 8388608) == 0 && num2 > pnPage)
                num3 = Sqlite3.SQLITE_CORRUPT_BKPT();
              else if (num5 >= 480U)
              {
                pBt.pageSize = num4;
                pBt.usableSize = num5;
                pBt.autoVacuum = Sqlite3.sqlite3Get4byte(aData, 52) > 0U;
                pBt.incrVacuum = Sqlite3.sqlite3Get4byte(aData, 64) > 0U;
                goto label_20;
              }
            }
          }
        }
        Sqlite3.releasePage(ppPage);
        pBt.pPage1 = (Sqlite3.MemPage) null;
        return num3;
      }
label_20:
      pBt.maxLocal = (ushort) ((uint) (((int) pBt.usableSize - 12) * 64) / (uint) byte.MaxValue - 23U);
      pBt.minLocal = (ushort) ((uint) (((int) pBt.usableSize - 12) * 32) / (uint) byte.MaxValue - 23U);
      pBt.maxLeaf = (ushort) (pBt.usableSize - 35U);
      pBt.minLeaf = (ushort) ((uint) (((int) pBt.usableSize - 12) * 32) / (uint) byte.MaxValue - 23U);
      pBt.pPage1 = ppPage;
      pBt.nPage = num2;
      return 0;
    }

    private static void unlockBtreeIfUnused(Sqlite3.BtShared pBt)
    {
      if (pBt.inTransaction != (byte) 0 || pBt.pPage1 == null)
        return;
      Sqlite3.releasePage(pBt.pPage1);
      pBt.pPage1 = (Sqlite3.MemPage) null;
    }

    private static int newDatabase(Sqlite3.BtShared pBt)
    {
      if (pBt.nPage > 0U)
        return 0;
      Sqlite3.MemPage pPage1 = pBt.pPage1;
      byte[] aData = pPage1.aData;
      int num = Sqlite3.sqlite3PagerWrite(pPage1.pDbPage);
      if (num != 0)
        return num;
      Buffer.BlockCopy((Array) Sqlite3.zMagicHeader, 0, (Array) aData, 0, 16);
      aData[16] = (byte) (pBt.pageSize >> 8 & (uint) byte.MaxValue);
      aData[17] = (byte) (pBt.pageSize >> 16 & (uint) byte.MaxValue);
      aData[18] = (byte) 1;
      aData[19] = (byte) 1;
      aData[20] = (byte) (pBt.pageSize - pBt.usableSize);
      aData[21] = (byte) 64;
      aData[22] = (byte) 32;
      aData[23] = (byte) 32;
      Sqlite3.zeroPage(pPage1, 13);
      pBt.pageSizeFixed = true;
      Sqlite3.sqlite3Put4byte(aData, 52, pBt.autoVacuum ? 1 : 0);
      Sqlite3.sqlite3Put4byte(aData, 64, pBt.incrVacuum ? 1 : 0);
      pBt.nPage = 1U;
      aData[31] = (byte) 1;
      return 0;
    }

    private static int sqlite3BtreeBeginTrans(Sqlite3.Btree p, int wrflag)
    {
      Sqlite3.BtShared pBt = p.pBt;
      int num = 0;
      Sqlite3.sqlite3BtreeEnter(p);
      Sqlite3.btreeIntegrity(p);
      if (p.inTrans != (byte) 2 && (p.inTrans != (byte) 1 || wrflag != 0))
      {
        if (pBt.readOnly && wrflag != 0)
        {
          num = 8;
        }
        else
        {
          num = Sqlite3.querySharedCacheTableLock(p, 1U, (byte) 1);
          if (num == 0)
          {
            pBt.initiallyEmpty = pBt.nPage == 0U;
            do
            {
              do
                ;
              while (pBt.pPage1 == null && (num = Sqlite3.lockBtree(pBt)) == 0);
              if (num == 0 && wrflag != 0)
              {
                if (pBt.readOnly)
                {
                  num = 8;
                }
                else
                {
                  num = Sqlite3.sqlite3PagerBegin(pBt.pPager, wrflag > 1, Sqlite3.sqlite3TempInMemory(p.db) ? 1 : 0);
                  if (num == 0)
                    num = Sqlite3.newDatabase(pBt);
                }
              }
              if (num != 0)
                Sqlite3.unlockBtreeIfUnused(pBt);
            }
            while ((num & (int) byte.MaxValue) == 5 && pBt.inTransaction == (byte) 0 && Sqlite3.btreeInvokeBusyHandler((object) pBt) != 0);
            if (num == 0)
            {
              if (p.inTrans == (byte) 0)
                ++pBt.nTransaction;
              p.inTrans = wrflag != 0 ? (byte) 2 : (byte) 1;
              if ((int) p.inTrans > (int) pBt.inTransaction)
                pBt.inTransaction = p.inTrans;
              if (wrflag != 0)
              {
                Sqlite3.MemPage pPage1 = pBt.pPage1;
                if ((int) pBt.nPage != (int) Sqlite3.sqlite3Get4byte(pPage1.aData, 28))
                {
                  num = Sqlite3.sqlite3PagerWrite(pPage1.pDbPage);
                  if (num == 0)
                    Sqlite3.sqlite3Put4byte(pPage1.aData, 28U, pBt.nPage);
                }
              }
            }
          }
        }
      }
      if (num == 0 && wrflag != 0)
        num = Sqlite3.sqlite3PagerOpenSavepoint(pBt.pPager, p.db.nSavepoint);
      Sqlite3.btreeIntegrity(p);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int setChildPtrmaps(Sqlite3.MemPage pPage)
    {
      Sqlite3.BtShared pBt = pPage.pBt;
      byte isInit = pPage.isInit;
      uint pgno = pPage.pgno;
      int pRC = Sqlite3.btreeInitPage(pPage);
      if (pRC == 0)
      {
        int nCell = (int) pPage.nCell;
        for (int iCell = 0; iCell < nCell; ++iCell)
        {
          int cell = Sqlite3.findCell(pPage, iCell);
          Sqlite3.ptrmapPutOvflPtr(pPage, cell, ref pRC);
          if (pPage.leaf == (byte) 0)
          {
            uint key = Sqlite3.sqlite3Get4byte(pPage.aData, cell);
            Sqlite3.ptrmapPut(pBt, key, (byte) 5, pgno, ref pRC);
          }
        }
        if (pPage.leaf == (byte) 0)
        {
          uint key = Sqlite3.sqlite3Get4byte(pPage.aData, (int) pPage.hdrOffset + 8);
          Sqlite3.ptrmapPut(pBt, key, (byte) 5, pgno, ref pRC);
        }
      }
      pPage.isInit = isInit;
      return pRC;
    }

    private static int modifyPagePointer(Sqlite3.MemPage pPage, uint iFrom, uint iTo, byte eType)
    {
      if (eType == (byte) 4)
      {
        if ((int) Sqlite3.sqlite3Get4byte(pPage.aData) != (int) iFrom)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        Sqlite3.sqlite3Put4byte(pPage.aData, (ulong) iTo);
      }
      else
      {
        byte isInit = pPage.isInit;
        Sqlite3.btreeInitPage(pPage);
        int nCell = (int) pPage.nCell;
        int iCell;
        for (iCell = 0; iCell < nCell; ++iCell)
        {
          int cell = Sqlite3.findCell(pPage, iCell);
          if (eType == (byte) 3)
          {
            Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
            Sqlite3.btreeParseCellPtr(pPage, cell, ref pInfo);
            if (pInfo.iOverflow != (ushort) 0 && (int) iFrom == (int) Sqlite3.sqlite3Get4byte(pPage.aData, cell, (int) pInfo.iOverflow))
            {
              Sqlite3.sqlite3Put4byte(pPage.aData, cell + (int) pInfo.iOverflow, (int) iTo);
              break;
            }
          }
          else if ((int) Sqlite3.sqlite3Get4byte(pPage.aData, cell) == (int) iFrom)
          {
            Sqlite3.sqlite3Put4byte(pPage.aData, cell, (int) iTo);
            break;
          }
        }
        if (iCell == nCell)
        {
          if (eType != (byte) 5 || (int) Sqlite3.sqlite3Get4byte(pPage.aData, (int) pPage.hdrOffset + 8) != (int) iFrom)
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          Sqlite3.sqlite3Put4byte(pPage.aData, (int) pPage.hdrOffset + 8, (ulong) iTo);
        }
        pPage.isInit = isInit;
      }
      return 0;
    }

    private static int relocatePage(
      Sqlite3.BtShared pBt,
      Sqlite3.MemPage pDbPage,
      byte eType,
      uint iPtrPage,
      uint iFreePage,
      int isCommit)
    {
      Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
      uint pgno = pDbPage.pgno;
      Sqlite3.Pager pPager = pBt.pPager;
      Sqlite3.TRACE("AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n", (object) pgno, (object) iFreePage, (object) iPtrPage, (object) eType);
      int pRC = Sqlite3.sqlite3PagerMovepage(pPager, pDbPage.pDbPage, iFreePage, isCommit);
      if (pRC != 0)
        return pRC;
      pDbPage.pgno = iFreePage;
      if (eType == (byte) 5 || eType == (byte) 1)
      {
        pRC = Sqlite3.setChildPtrmaps(pDbPage);
        if (pRC != 0)
          return pRC;
      }
      else
      {
        uint key = Sqlite3.sqlite3Get4byte(pDbPage.aData);
        if (key != 0U)
        {
          Sqlite3.ptrmapPut(pBt, key, (byte) 4, iFreePage, ref pRC);
          if (pRC != 0)
            return pRC;
        }
      }
      if (eType != (byte) 1)
      {
        pRC = Sqlite3.btreeGetPage(pBt, iPtrPage, ref ppPage, 0);
        if (pRC != 0)
          return pRC;
        pRC = Sqlite3.sqlite3PagerWrite(ppPage.pDbPage);
        if (pRC != 0)
        {
          Sqlite3.releasePage(ppPage);
          return pRC;
        }
        pRC = Sqlite3.modifyPagePointer(ppPage, pgno, iFreePage, eType);
        Sqlite3.releasePage(ppPage);
        if (pRC == 0)
          Sqlite3.ptrmapPut(pBt, iFreePage, eType, iPtrPage, ref pRC);
      }
      return pRC;
    }

    private static int incrVacuumStep(Sqlite3.BtShared pBt, uint nFin, uint iLastPg)
    {
      if (!Sqlite3.PTRMAP_ISPAGE(pBt, iLastPg) && (int) iLastPg != (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
      {
        byte pEType = 0;
        uint pPgno1 = 0;
        if (Sqlite3.sqlite3Get4byte(pBt.pPage1.aData, 36) == 0U)
          return 101;
        int num1 = Sqlite3.ptrmapGet(pBt, iLastPg, ref pEType, ref pPgno1);
        if (num1 != 0)
          return num1;
        switch (pEType)
        {
          case 1:
            return Sqlite3.SQLITE_CORRUPT_BKPT();
          case 2:
            if (nFin == 0U)
            {
              uint pPgno2 = 0;
              Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
              int num2 = Sqlite3.allocateBtreePage(pBt, ref ppPage, ref pPgno2, iLastPg, (byte) 1);
              if (num2 != 0)
                return num2;
              Sqlite3.releasePage(ppPage);
              break;
            }
            break;
          default:
            uint pPgno3 = 0;
            Sqlite3.MemPage ppPage1 = new Sqlite3.MemPage();
            int page = Sqlite3.btreeGetPage(pBt, iLastPg, ref ppPage1, 0);
            if (page != 0)
              return page;
            do
            {
              Sqlite3.MemPage ppPage2 = new Sqlite3.MemPage();
              int num3 = Sqlite3.allocateBtreePage(pBt, ref ppPage2, ref pPgno3, 0U, (byte) 0);
              if (num3 != 0)
              {
                Sqlite3.releasePage(ppPage1);
                return num3;
              }
              Sqlite3.releasePage(ppPage2);
            }
            while (nFin != 0U && pPgno3 > nFin);
            int num4 = Sqlite3.sqlite3PagerWrite(ppPage1.pDbPage);
            if (num4 == 0)
              num4 = Sqlite3.relocatePage(pBt, ppPage1, pEType, pPgno1, pPgno3, nFin != 0U ? 1 : 0);
            Sqlite3.releasePage(ppPage1);
            if (num4 != 0)
              return num4;
            break;
        }
      }
      if (nFin == 0U)
      {
        for (--iLastPg; (int) iLastPg == (int) Sqlite3.PENDING_BYTE_PAGE(pBt) || Sqlite3.PTRMAP_ISPAGE(pBt, iLastPg); --iLastPg)
        {
          if (Sqlite3.PTRMAP_ISPAGE(pBt, iLastPg))
          {
            Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
            int page = Sqlite3.btreeGetPage(pBt, iLastPg, ref ppPage, 0);
            if (page != 0)
              return page;
            int num = Sqlite3.sqlite3PagerWrite(ppPage.pDbPage);
            Sqlite3.releasePage(ppPage);
            if (num != 0)
              return num;
          }
        }
        Sqlite3.sqlite3PagerTruncateImage(pBt.pPager, iLastPg);
        pBt.nPage = iLastPg;
      }
      return 0;
    }

    private static int sqlite3BtreeIncrVacuum(Sqlite3.Btree p)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      int num;
      if (!pBt.autoVacuum)
      {
        num = 101;
      }
      else
      {
        Sqlite3.invalidateAllOverflowCache(pBt);
        num = Sqlite3.incrVacuumStep(pBt, 0U, Sqlite3.btreePagecount(pBt));
        if (num == 0)
        {
          num = Sqlite3.sqlite3PagerWrite(pBt.pPage1.pDbPage);
          Sqlite3.sqlite3Put4byte(pBt.pPage1.aData, 28U, pBt.nPage);
        }
      }
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int autoVacuumCommit(Sqlite3.BtShared pBt)
    {
      int num1 = 0;
      Sqlite3.Pager pPager = pBt.pPager;
      Sqlite3.invalidateAllOverflowCache(pBt);
      if (!pBt.incrVacuum)
      {
        uint pgno = Sqlite3.btreePagecount(pBt);
        if (Sqlite3.PTRMAP_ISPAGE(pBt, pgno) || (int) pgno == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        uint num2 = Sqlite3.sqlite3Get4byte(pBt.pPage1.aData, 36);
        int num3 = (int) pBt.usableSize / 5;
        uint num4 = (uint) ((ulong) (uint) ((int) num2 - (int) pgno + (int) Sqlite3.PTRMAP_PAGENO(pBt, pgno) + num3) / (ulong) num3);
        uint num5 = pgno - num2 - num4;
        if (pgno > Sqlite3.PENDING_BYTE_PAGE(pBt) && num5 < Sqlite3.PENDING_BYTE_PAGE(pBt))
          --num5;
        while (Sqlite3.PTRMAP_ISPAGE(pBt, num5) || (int) num5 == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
          --num5;
        if (num5 > pgno)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        for (uint iLastPg = pgno; iLastPg > num5 && num1 == 0; --iLastPg)
          num1 = Sqlite3.incrVacuumStep(pBt, num5, iLastPg);
        if ((num1 == 101 || num1 == 0) && num2 > 0U)
        {
          num1 = Sqlite3.sqlite3PagerWrite(pBt.pPage1.pDbPage);
          Sqlite3.sqlite3Put4byte(pBt.pPage1.aData, 32, 0);
          Sqlite3.sqlite3Put4byte(pBt.pPage1.aData, 36, 0);
          Sqlite3.sqlite3Put4byte(pBt.pPage1.aData, 28U, num5);
          Sqlite3.sqlite3PagerTruncateImage(pBt.pPager, num5);
          pBt.nPage = num5;
        }
        if (num1 != 0)
          Sqlite3.sqlite3PagerRollback(pPager);
      }
      return num1;
    }

    private static int sqlite3BtreeCommitPhaseOne(Sqlite3.Btree p, string zMaster)
    {
      int num1 = 0;
      if (p.inTrans == (byte) 2)
      {
        Sqlite3.BtShared pBt = p.pBt;
        Sqlite3.sqlite3BtreeEnter(p);
        if (pBt.autoVacuum)
        {
          int num2 = Sqlite3.autoVacuumCommit(pBt);
          if (num2 != 0)
          {
            Sqlite3.sqlite3BtreeLeave(p);
            return num2;
          }
        }
        num1 = Sqlite3.sqlite3PagerCommitPhaseOne(pBt.pPager, zMaster, false);
        Sqlite3.sqlite3BtreeLeave(p);
      }
      return num1;
    }

    private static void btreeEndTransaction(Sqlite3.Btree p)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.btreeClearHasContent(pBt);
      if (p.inTrans > (byte) 0 && p.db.activeVdbeCnt > 1)
      {
        Sqlite3.downgradeAllSharedCacheTableLocks(p);
        p.inTrans = (byte) 1;
      }
      else
      {
        if (p.inTrans != (byte) 0)
        {
          Sqlite3.clearAllSharedCacheTableLocks(p);
          --pBt.nTransaction;
          if (pBt.nTransaction == 0)
            pBt.inTransaction = (byte) 0;
        }
        p.inTrans = (byte) 0;
        Sqlite3.unlockBtreeIfUnused(pBt);
      }
      Sqlite3.btreeIntegrity(p);
    }

    private static int sqlite3BtreeCommitPhaseTwo(Sqlite3.Btree p, int bCleanup)
    {
      if (p.inTrans == (byte) 0)
        return 0;
      Sqlite3.sqlite3BtreeEnter(p);
      Sqlite3.btreeIntegrity(p);
      if (p.inTrans == (byte) 2)
      {
        Sqlite3.BtShared pBt = p.pBt;
        int num = Sqlite3.sqlite3PagerCommitPhaseTwo(pBt.pPager);
        if (num != 0 && bCleanup == 0)
        {
          Sqlite3.sqlite3BtreeLeave(p);
          return num;
        }
        pBt.inTransaction = (byte) 1;
      }
      Sqlite3.btreeEndTransaction(p);
      Sqlite3.sqlite3BtreeLeave(p);
      return 0;
    }

    private static int sqlite3BtreeCommit(Sqlite3.Btree p)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.sqlite3BtreeCommitPhaseOne(p, (string) null);
      if (num == 0)
        num = Sqlite3.sqlite3BtreeCommitPhaseTwo(p, 0);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int countWriteCursors(Sqlite3.BtShared pBt) => -1;

    private static void sqlite3BtreeTripAllCursors(Sqlite3.Btree pBtree, int errCode)
    {
      Sqlite3.sqlite3BtreeEnter(pBtree);
      for (Sqlite3.BtCursor pCur = pBtree.pBt.pCursor; pCur != null; pCur = pCur.pNext)
      {
        Sqlite3.sqlite3BtreeClearCursor(pCur);
        pCur.eState = 3;
        pCur.skipNext = errCode;
        for (int index = 0; index <= (int) pCur.iPage; ++index)
        {
          Sqlite3.releasePage(pCur.apPage[index]);
          pCur.apPage[index] = (Sqlite3.MemPage) null;
        }
      }
      Sqlite3.sqlite3BtreeLeave(pBtree);
    }

    private static int sqlite3BtreeRollback(Sqlite3.Btree p)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
      Sqlite3.sqlite3BtreeEnter(p);
      int num1 = Sqlite3.saveAllCursors(pBt, 0U, (Sqlite3.BtCursor) null);
      Sqlite3.btreeIntegrity(p);
      if (p.inTrans == (byte) 2)
      {
        int num2 = Sqlite3.sqlite3PagerRollback(pBt.pPager);
        if (num2 != 0)
          num1 = num2;
        if (Sqlite3.btreeGetPage(pBt, 1U, ref ppPage, 0) == 0)
        {
          uint pnPage = Sqlite3.sqlite3Get4byte(ppPage.aData, 28);
          Sqlite3.testcase<bool>(pnPage == 0U);
          if (pnPage == 0U)
            Sqlite3.sqlite3PagerPagecount(pBt.pPager, out pnPage);
          Sqlite3.testcase<bool>((int) pBt.nPage != (int) pnPage);
          pBt.nPage = pnPage;
          Sqlite3.releasePage(ppPage);
        }
        pBt.inTransaction = (byte) 1;
      }
      Sqlite3.btreeEndTransaction(p);
      Sqlite3.sqlite3BtreeLeave(p);
      return num1;
    }

    private static int sqlite3BtreeBeginStmt(Sqlite3.Btree p, int iStatement)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.sqlite3PagerOpenSavepoint(pBt.pPager, iStatement);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeSavepoint(Sqlite3.Btree p, int op, int iSavepoint)
    {
      int num = 0;
      if (p != null && p.inTrans == (byte) 2)
      {
        Sqlite3.BtShared pBt = p.pBt;
        Sqlite3.sqlite3BtreeEnter(p);
        num = Sqlite3.sqlite3PagerSavepoint(pBt.pPager, op, iSavepoint);
        if (num == 0)
        {
          if (iSavepoint < 0 && pBt.initiallyEmpty)
            pBt.nPage = 0U;
          num = Sqlite3.newDatabase(pBt);
          pBt.nPage = Sqlite3.sqlite3Get4byte(pBt.pPage1.aData, 28);
        }
        Sqlite3.sqlite3BtreeLeave(p);
      }
      return num;
    }

    private static int btreeCursor(
      Sqlite3.Btree p,
      int iTable,
      int wrFlag,
      Sqlite3.KeyInfo pKeyInfo,
      Sqlite3.BtCursor pCur)
    {
      Sqlite3.BtShared pBt = p.pBt;
      if (Sqlite3.NEVER(wrFlag != 0 && pBt.readOnly))
        return 8;
      if (iTable == 1 && Sqlite3.btreePagecount(pBt) == 0U)
        return 16;
      pCur.pgnoRoot = (uint) iTable;
      pCur.iPage = (short) -1;
      pCur.pKeyInfo = pKeyInfo;
      pCur.pBtree = p;
      pCur.pBt = pBt;
      pCur.wrFlag = (byte) wrFlag;
      pCur.pNext = pBt.pCursor;
      if (pCur.pNext != null)
        pCur.pNext.pPrev = pCur;
      pBt.pCursor = pCur;
      pCur.eState = 0;
      pCur.cachedRowid = 0L;
      return 0;
    }

    private static int sqlite3BtreeCursor(
      Sqlite3.Btree p,
      int iTable,
      int wrFlag,
      Sqlite3.KeyInfo pKeyInfo,
      Sqlite3.BtCursor pCur)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeCursorSize() => -1;

    private static void sqlite3BtreeCursorZero(Sqlite3.BtCursor p) => p.Clear();

    private static void sqlite3BtreeSetCachedRowid(Sqlite3.BtCursor pCur, long iRowid)
    {
      for (Sqlite3.BtCursor btCursor = pCur.pBt.pCursor; btCursor != null; btCursor = btCursor.pNext)
      {
        if ((int) btCursor.pgnoRoot == (int) pCur.pgnoRoot)
          btCursor.cachedRowid = iRowid;
      }
    }

    private static long sqlite3BtreeGetCachedRowid(Sqlite3.BtCursor pCur) => pCur.cachedRowid;

    private static int sqlite3BtreeCloseCursor(Sqlite3.BtCursor pCur)
    {
      Sqlite3.Btree pBtree = pCur.pBtree;
      if (pBtree != null)
      {
        Sqlite3.BtShared pBt = pCur.pBt;
        Sqlite3.sqlite3BtreeEnter(pBtree);
        Sqlite3.sqlite3BtreeClearCursor(pCur);
        if (pCur.pPrev != null)
          pCur.pPrev.pNext = pCur.pNext;
        else
          pBt.pCursor = pCur.pNext;
        if (pCur.pNext != null)
          pCur.pNext.pPrev = pCur.pPrev;
        for (int index = 0; index <= (int) pCur.iPage; ++index)
          Sqlite3.releasePage(pCur.apPage[index]);
        Sqlite3.unlockBtreeIfUnused(pBt);
        Sqlite3.invalidateOverflowCache(pCur);
        Sqlite3.sqlite3BtreeLeave(pBtree);
      }
      return 0;
    }

    private static void assertCellInfo(Sqlite3.BtCursor pCur)
    {
    }

    private static void getCellInfo(Sqlite3.BtCursor pCur)
    {
      if (pCur.info.nSize == (ushort) 0)
      {
        int iPage = (int) pCur.iPage;
        Sqlite3.btreeParseCell(pCur.apPage[iPage], (int) pCur.aiIdx[iPage], ref pCur.info);
        pCur.validNKey = true;
      }
      else
        Sqlite3.assertCellInfo(pCur);
    }

    private static bool sqlite3BtreeCursorIsValid(Sqlite3.BtCursor pCur) => true;

    private static int sqlite3BtreeKeySize(Sqlite3.BtCursor pCur, ref long pSize)
    {
      if (pCur.eState != 1)
      {
        pSize = 0L;
      }
      else
      {
        Sqlite3.getCellInfo(pCur);
        pSize = pCur.info.nKey;
      }
      return 0;
    }

    private static int sqlite3BtreeDataSize(Sqlite3.BtCursor pCur, ref uint pSize)
    {
      Sqlite3.getCellInfo(pCur);
      pSize = pCur.info.nData;
      return 0;
    }

    private static int getOverflowPage(
      Sqlite3.BtShared pBt,
      uint ovfl,
      out Sqlite3.MemPage ppPage,
      out uint pPgnoNext)
    {
      uint num1 = 0;
      Sqlite3.MemPage ppPage1 = (Sqlite3.MemPage) null;
      ppPage = (Sqlite3.MemPage) null;
      int num2 = 0;
      if (pBt.autoVacuum)
      {
        uint pPgno = 0;
        uint num3 = ovfl + 1U;
        byte pEType = 0;
        while (Sqlite3.PTRMAP_ISPAGE(pBt, num3) || (int) num3 == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
          ++num3;
        if (num3 <= Sqlite3.btreePagecount(pBt))
        {
          num2 = Sqlite3.ptrmapGet(pBt, num3, ref pEType, ref pPgno);
          if (num2 == 0 && pEType == (byte) 4 && (int) pPgno == (int) ovfl)
          {
            num1 = num3;
            num2 = 101;
          }
        }
      }
      if (num2 == 0)
      {
        num2 = Sqlite3.btreeGetPage(pBt, ovfl, ref ppPage1, 0);
        if (num2 == 0)
          num1 = Sqlite3.sqlite3Get4byte(ppPage1.aData);
      }
      pPgnoNext = num1;
      if (ppPage != null)
        ppPage = ppPage1;
      else
        Sqlite3.releasePage(ppPage1);
      return num2 != 101 ? num2 : 0;
    }

    private static int copyPayload(
      byte[] pPayload,
      uint payloadOffset,
      byte[] pBuf,
      uint pBufOffset,
      uint nByte,
      int eOp,
      Sqlite3.PgHdr pDbPage)
    {
      if (eOp != 0)
      {
        int num = Sqlite3.sqlite3PagerWrite(pDbPage);
        if (num != 0)
          return num;
        Buffer.BlockCopy((Array) pBuf, (int) pBufOffset, (Array) pPayload, (int) payloadOffset, (int) nByte);
      }
      else
        Buffer.BlockCopy((Array) pPayload, (int) payloadOffset, (Array) pBuf, (int) pBufOffset, (int) nByte);
      return 0;
    }

    private static int accessPayload(
      Sqlite3.BtCursor pCur,
      uint offset,
      uint amt,
      byte[] pBuf,
      int eOp)
    {
      uint pBufOffset = 0;
      int num1 = 0;
      int num2 = 0;
      Sqlite3.MemPage memPage = pCur.apPage[(int) pCur.iPage];
      Sqlite3.BtShared pBt = pCur.pBt;
      Sqlite3.getCellInfo(pCur);
      byte[] pCell = pCur.info.pCell;
      uint num3 = memPage.intKey != (byte) 0 ? 0U : (uint) (int) pCur.info.nKey;
      if (Sqlite3.NEVER(offset + amt > num3 + pCur.info.nData) || (uint) pCur.info.nLocal > pBt.usableSize)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      if (offset < (uint) pCur.info.nLocal)
      {
        int nByte = (int) amt;
        if ((long) nByte + (long) offset > (long) pCur.info.nLocal)
          nByte = (int) pCur.info.nLocal - (int) offset;
        num1 = Sqlite3.copyPayload(pCell, (uint) ((ulong) offset + (ulong) pCur.info.iCell + (ulong) pCur.info.nHeader), pBuf, pBufOffset, (uint) nByte, eOp, memPage.pDbPage);
        offset = 0U;
        pBufOffset += (uint) nByte;
        amt -= (uint) nByte;
      }
      else
        offset -= (uint) pCur.info.nLocal;
      if (num1 == 0 && amt > 0U)
      {
        uint num4 = pBt.usableSize - 4U;
        uint pPgnoNext = Sqlite3.sqlite3Get4byte(pCell, (int) pCur.info.nLocal + pCur.info.iCell + (int) pCur.info.nHeader);
        while (num1 == 0 && amt > 0U && pPgnoNext != 0U)
        {
          Sqlite3.MemPage ppPage1 = (Sqlite3.MemPage) null;
          if (offset >= num4)
          {
            num1 = Sqlite3.getOverflowPage(pBt, pPgnoNext, out ppPage1, out pPgnoNext);
            offset -= num4;
          }
          else
          {
            Sqlite3.PgHdr ppPage2 = new Sqlite3.PgHdr();
            int nByte = (int) amt;
            num1 = Sqlite3.sqlite3PagerGet(pBt.pPager, pPgnoNext, ref ppPage2);
            if (num1 == 0)
            {
              byte[] data = Sqlite3.sqlite3PagerGetData(ppPage2);
              pPgnoNext = Sqlite3.sqlite3Get4byte(data);
              if ((long) nByte + (long) offset > (long) num4)
                nByte = (int) num4 - (int) offset;
              num1 = Sqlite3.copyPayload(data, offset + 4U, pBuf, pBufOffset, (uint) nByte, eOp, ppPage2);
              Sqlite3.sqlite3PagerUnref(ppPage2);
              offset = 0U;
              amt -= (uint) nByte;
              pBufOffset += (uint) nByte;
            }
          }
          ++num2;
        }
      }
      return num1 == 0 && amt > 0U ? Sqlite3.SQLITE_CORRUPT_BKPT() : num1;
    }

    private static int sqlite3BtreeKey(Sqlite3.BtCursor pCur, uint offset, uint amt, byte[] pBuf) => Sqlite3.accessPayload(pCur, offset, amt, pBuf, 0);

    private static int sqlite3BtreeData(Sqlite3.BtCursor pCur, uint offset, uint amt, byte[] pBuf)
    {
      int num = Sqlite3.restoreCursorPosition(pCur);
      if (num == 0)
        num = Sqlite3.accessPayload(pCur, offset, amt, pBuf, 0);
      return num;
    }

    private static byte[] fetchPayload(
      Sqlite3.BtCursor pCur,
      ref int pAmt,
      ref int outOffset,
      bool skipKey)
    {
      outOffset = -1;
      Sqlite3.MemPage memPage = pCur.apPage[(int) pCur.iPage];
      if (Sqlite3.NEVER(pCur.info.nSize == (ushort) 0))
        Sqlite3.btreeParseCell(pCur.apPage[(int) pCur.iPage], (int) pCur.aiIdx[(int) pCur.iPage], ref pCur.info);
      byte[] dst = Sqlite3.sqlite3Malloc((int) pCur.info.nSize - (int) pCur.info.nHeader);
      uint num1 = memPage.intKey == (byte) 0 ? (uint) pCur.info.nKey : 0U;
      uint num2;
      if (skipKey)
      {
        outOffset = (int) ((long) (pCur.info.iCell + (int) pCur.info.nHeader) + (long) num1);
        Buffer.BlockCopy((Array) pCur.info.pCell, outOffset, (Array) dst, 0, (int) ((long) ((int) pCur.info.nSize - (int) pCur.info.nHeader) - (long) num1));
        num2 = (uint) pCur.info.nLocal - num1;
      }
      else
      {
        outOffset = pCur.info.iCell + (int) pCur.info.nHeader;
        Buffer.BlockCopy((Array) pCur.info.pCell, outOffset, (Array) dst, 0, (int) pCur.info.nSize - (int) pCur.info.nHeader);
        num2 = (uint) pCur.info.nLocal;
      }
      pAmt = (int) num2;
      return dst;
    }

    private static byte[] sqlite3BtreeKeyFetch(
      Sqlite3.BtCursor pCur,
      ref int pAmt,
      ref int outOffset)
    {
      byte[] numArray = (byte[]) null;
      if (Sqlite3.ALWAYS(pCur.eState == 1))
        numArray = Sqlite3.fetchPayload(pCur, ref pAmt, ref outOffset, false);
      return numArray;
    }

    private static byte[] sqlite3BtreeDataFetch(
      Sqlite3.BtCursor pCur,
      ref int pAmt,
      ref int outOffset)
    {
      byte[] numArray = (byte[]) null;
      if (Sqlite3.ALWAYS(pCur.eState == 1))
        numArray = Sqlite3.fetchPayload(pCur, ref pAmt, ref outOffset, true);
      return numArray;
    }

    private static int moveToChild(Sqlite3.BtCursor pCur, uint newPgno)
    {
      int iPage = (int) pCur.iPage;
      Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
      Sqlite3.BtShared pBt = pCur.pBt;
      if (pCur.iPage >= (short) 19)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      int andInitPage = Sqlite3.getAndInitPage(pBt, newPgno, ref ppPage);
      if (andInitPage != 0)
        return andInitPage;
      pCur.apPage[iPage + 1] = ppPage;
      pCur.aiIdx[iPage + 1] = (ushort) 0;
      ++pCur.iPage;
      pCur.info.nSize = (ushort) 0;
      pCur.validNKey = false;
      return ppPage.nCell < (ushort) 1 || (int) ppPage.intKey != (int) pCur.apPage[iPage].intKey ? Sqlite3.SQLITE_CORRUPT_BKPT() : 0;
    }

    private static void assertParentIndex(Sqlite3.MemPage pParent, int iIdx, uint iChild)
    {
    }

    private static void moveToParent(Sqlite3.BtCursor pCur)
    {
      Sqlite3.assertParentIndex(pCur.apPage[(int) pCur.iPage - 1], (int) pCur.aiIdx[(int) pCur.iPage - 1], pCur.apPage[(int) pCur.iPage].pgno);
      Sqlite3.releasePage(pCur.apPage[(int) pCur.iPage]);
      --pCur.iPage;
      pCur.info.nSize = (ushort) 0;
      pCur.validNKey = false;
    }

    private static int moveToRoot(Sqlite3.BtCursor pCur)
    {
      int root = 0;
      Sqlite3.BtShared pBt = pCur.pBtree.pBt;
      if (pCur.eState >= 2)
      {
        if (pCur.eState == 3)
          return pCur.skipNext;
        Sqlite3.sqlite3BtreeClearCursor(pCur);
      }
      if (pCur.iPage >= (short) 0)
      {
        for (int index = 1; index <= (int) pCur.iPage; ++index)
          Sqlite3.releasePage(pCur.apPage[index]);
        pCur.iPage = (short) 0;
      }
      else
      {
        root = Sqlite3.getAndInitPage(pBt, pCur.pgnoRoot, ref pCur.apPage[0]);
        if (root != 0)
        {
          pCur.eState = 0;
          return root;
        }
        pCur.iPage = (short) 0;
        if (pCur.pKeyInfo == null != pCur.apPage[0].intKey > (byte) 0)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      Sqlite3.MemPage memPage = pCur.apPage[0];
      pCur.aiIdx[0] = (ushort) 0;
      pCur.info.nSize = (ushort) 0;
      pCur.atLast = (byte) 0;
      pCur.validNKey = false;
      if (memPage.nCell == (ushort) 0 && memPage.leaf == (byte) 0)
      {
        if (memPage.pgno != 1U)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        uint newPgno = Sqlite3.sqlite3Get4byte(memPage.aData, (int) memPage.hdrOffset + 8);
        pCur.eState = 1;
        root = Sqlite3.moveToChild(pCur, newPgno);
      }
      else
        pCur.eState = memPage.nCell > (ushort) 0 ? 1 : 0;
      return root;
    }

    private static int moveToLeftmost(Sqlite3.BtCursor pCur)
    {
      int leftmost;
      Sqlite3.MemPage pPage;
      uint newPgno;
      for (leftmost = 0; leftmost == 0 && (pPage = pCur.apPage[(int) pCur.iPage]).leaf == (byte) 0; leftmost = Sqlite3.moveToChild(pCur, newPgno))
        newPgno = Sqlite3.sqlite3Get4byte(pPage.aData, Sqlite3.findCell(pPage, (int) pCur.aiIdx[(int) pCur.iPage]));
      return leftmost;
    }

    private static int moveToRightmost(Sqlite3.BtCursor pCur)
    {
      int rightmost = 0;
      Sqlite3.MemPage memPage = (Sqlite3.MemPage) null;
      uint newPgno;
      for (; rightmost == 0 && (memPage = pCur.apPage[(int) pCur.iPage]).leaf == (byte) 0; rightmost = Sqlite3.moveToChild(pCur, newPgno))
      {
        newPgno = Sqlite3.sqlite3Get4byte(memPage.aData, (int) memPage.hdrOffset + 8);
        pCur.aiIdx[(int) pCur.iPage] = memPage.nCell;
      }
      if (rightmost == 0)
      {
        pCur.aiIdx[(int) pCur.iPage] = (ushort) ((uint) memPage.nCell - 1U);
        pCur.info.nSize = (ushort) 0;
        pCur.validNKey = false;
      }
      return rightmost;
    }

    private static int sqlite3BtreeFirst(Sqlite3.BtCursor pCur, ref int pRes)
    {
      int num = Sqlite3.moveToRoot(pCur);
      if (num == 0)
      {
        if (pCur.eState == 0)
        {
          pRes = 1;
        }
        else
        {
          pRes = 0;
          num = Sqlite3.moveToLeftmost(pCur);
        }
      }
      return num;
    }

    private static int sqlite3BtreeLast(Sqlite3.BtCursor pCur, ref int pRes)
    {
      if (1 == pCur.eState && pCur.atLast != (byte) 0)
        return 0;
      int num = Sqlite3.moveToRoot(pCur);
      if (num == 0)
      {
        if (pCur.eState == 0)
        {
          pRes = 1;
        }
        else
        {
          pRes = 0;
          num = Sqlite3.moveToRightmost(pCur);
          pCur.atLast = num == 0 ? (byte) 1 : (byte) 0;
        }
      }
      return num;
    }

    private static int sqlite3BtreeMovetoUnpacked(
      Sqlite3.BtCursor pCur,
      Sqlite3.UnpackedRecord pIdxKey,
      long intKey,
      int biasRight,
      ref int pRes)
    {
      if (pCur.eState == 1 && pCur.validNKey && pCur.apPage[0].intKey != (byte) 0)
      {
        if (pCur.info.nKey == intKey)
        {
          pRes = 0;
          return 0;
        }
        if (pCur.atLast != (byte) 0 && pCur.info.nKey < intKey)
        {
          pRes = -1;
          return 0;
        }
      }
      int root = Sqlite3.moveToRoot(pCur);
      if (root != 0)
        return root;
      if (pCur.eState == 0)
      {
        pRes = -1;
        return 0;
      }
      int num1;
      do
      {
        Sqlite3.MemPage pPage = pCur.apPage[(int) pCur.iPage];
        int iCell1 = 0;
        int num2 = (int) pPage.nCell - 1;
        int iCell2;
        pCur.aiIdx[(int) pCur.iPage] = biasRight == 0 ? (ushort) (iCell2 = (num2 + iCell1) / 2) : (ushort) (iCell2 = num2);
        int num3;
        byte[] numArray1;
        while (true)
        {
          pCur.info.nSize = (ushort) 0;
          int offset = Sqlite3.findCell(pPage, iCell2) + (int) pPage.childPtrSize;
          if (pPage.intKey != (byte) 0)
          {
            long v1 = 0;
            if (pPage.hasData != (byte) 0)
            {
              uint v2 = 0;
              offset += Sqlite3.getVarint32(pPage.aData, offset, out v2);
            }
            Sqlite3.getVarint(pPage.aData, offset, out v1);
            num3 = v1 != intKey ? (v1 >= intKey ? 1 : -1) : 0;
            pCur.validNKey = true;
            pCur.info.nKey = v1;
          }
          else
          {
            int nKey1_1 = (int) pPage.aData[offset];
            if ((nKey1_1 & 128) == 0 && nKey1_1 <= (int) pPage.maxLocal)
            {
              num3 = Sqlite3.sqlite3VdbeRecordCompare(nKey1_1, pPage.aData, offset + 1, pIdxKey);
            }
            else
            {
              int nKey1_2;
              if (((int) pPage.aData[offset + 1] & 128) == 0 && (nKey1_2 = ((nKey1_1 & (int) sbyte.MaxValue) << 7) + (int) pPage.aData[offset + 1]) <= (int) pPage.maxLocal)
              {
                num3 = Sqlite3.sqlite3VdbeRecordCompare(nKey1_2, pPage.aData, offset + 2, pIdxKey);
              }
              else
              {
                byte[] numArray2 = new byte[pPage.aData.Length - offset + (int) pPage.childPtrSize];
                Buffer.BlockCopy((Array) pPage.aData, offset - (int) pPage.childPtrSize, (Array) numArray2, 0, numArray2.Length);
                Sqlite3.btreeParseCellPtr(pPage, numArray2, ref pCur.info);
                int nKey = (int) pCur.info.nKey;
                byte[] numArray3 = Sqlite3.sqlite3Malloc(nKey);
                num1 = Sqlite3.accessPayload(pCur, 0U, (uint) nKey, numArray3, 0);
                if (num1 == 0)
                {
                  num3 = Sqlite3.sqlite3VdbeRecordCompare(nKey, numArray3, pIdxKey);
                  numArray1 = (byte[]) null;
                }
                else
                  break;
              }
            }
          }
          if (num3 != 0)
          {
            if (num3 < 0)
              iCell1 = iCell2 + 1;
            else
              num2 = iCell2 - 1;
            if (iCell1 <= num2)
              pCur.aiIdx[(int) pCur.iPage] = (ushort) (iCell2 = (iCell1 + num2) / 2);
            else
              goto label_30;
          }
          else
            goto label_22;
        }
        numArray1 = (byte[]) null;
        break;
label_22:
        if (pPage.intKey != (byte) 0 && pPage.leaf == (byte) 0)
        {
          iCell1 = iCell2;
          int num4 = iCell1 - 1;
        }
        else
        {
          pRes = 0;
          num1 = 0;
          break;
        }
label_30:
        uint newPgno = pPage.leaf == (byte) 0 ? (iCell1 < (int) pPage.nCell ? Sqlite3.sqlite3Get4byte(pPage.aData, Sqlite3.findCell(pPage, iCell1)) : Sqlite3.sqlite3Get4byte(pPage.aData, (int) pPage.hdrOffset + 8)) : 0U;
        if (newPgno == 0U)
        {
          pRes = num3;
          num1 = 0;
          break;
        }
        pCur.aiIdx[(int) pCur.iPage] = (ushort) iCell1;
        pCur.info.nSize = (ushort) 0;
        pCur.validNKey = false;
        num1 = Sqlite3.moveToChild(pCur, newPgno);
      }
      while (num1 == 0);
      return num1;
    }

    private static bool sqlite3BtreeEof(Sqlite3.BtCursor pCur) => 1 != pCur.eState;

    private static int sqlite3BtreeNext(Sqlite3.BtCursor pCur, ref int pRes)
    {
      int num1 = Sqlite3.restoreCursorPosition(pCur);
      if (num1 != 0)
        return num1;
      if (pCur.eState == 0)
      {
        pRes = 1;
        return 0;
      }
      if (pCur.skipNext > 0)
      {
        pCur.skipNext = 0;
        pRes = 0;
        return 0;
      }
      pCur.skipNext = 0;
      Sqlite3.MemPage memPage1 = pCur.apPage[(int) pCur.iPage];
      int num2 = (int) ++pCur.aiIdx[(int) pCur.iPage];
      pCur.info.nSize = (ushort) 0;
      pCur.validNKey = false;
      int nCell = (int) memPage1.nCell;
      if (num2 >= nCell)
      {
        if (memPage1.leaf == (byte) 0)
        {
          int child = Sqlite3.moveToChild(pCur, Sqlite3.sqlite3Get4byte(memPage1.aData, (int) memPage1.hdrOffset + 8));
          if (child != 0)
            return child;
          int leftmost = Sqlite3.moveToLeftmost(pCur);
          pRes = 0;
          return leftmost;
        }
        while (pCur.iPage != (short) 0)
        {
          Sqlite3.moveToParent(pCur);
          Sqlite3.MemPage memPage2 = pCur.apPage[(int) pCur.iPage];
          if ((int) pCur.aiIdx[(int) pCur.iPage] < (int) memPage2.nCell)
          {
            pRes = 0;
            return memPage2.intKey == (byte) 0 ? 0 : Sqlite3.sqlite3BtreeNext(pCur, ref pRes);
          }
        }
        pRes = 1;
        pCur.eState = 0;
        return 0;
      }
      pRes = 0;
      return memPage1.leaf != (byte) 0 ? 0 : Sqlite3.moveToLeftmost(pCur);
    }

    private static int sqlite3BtreePrevious(Sqlite3.BtCursor pCur, ref int pRes)
    {
      int num1 = Sqlite3.restoreCursorPosition(pCur);
      if (num1 != 0)
        return num1;
      pCur.atLast = (byte) 0;
      if (pCur.eState == 0)
      {
        pRes = 1;
        return 0;
      }
      if (pCur.skipNext < 0)
      {
        pCur.skipNext = 0;
        pRes = 0;
        return 0;
      }
      pCur.skipNext = 0;
      Sqlite3.MemPage pPage = pCur.apPage[(int) pCur.iPage];
      int num2;
      if (pPage.leaf == (byte) 0)
      {
        int iCell = (int) pCur.aiIdx[(int) pCur.iPage];
        int child = Sqlite3.moveToChild(pCur, Sqlite3.sqlite3Get4byte(pPage.aData, Sqlite3.findCell(pPage, iCell)));
        if (child != 0)
          return child;
        num2 = Sqlite3.moveToRightmost(pCur);
      }
      else
      {
        while (pCur.aiIdx[(int) pCur.iPage] == (ushort) 0)
        {
          if (pCur.iPage == (short) 0)
          {
            pCur.eState = 0;
            pRes = 1;
            return 0;
          }
          Sqlite3.moveToParent(pCur);
        }
        pCur.info.nSize = (ushort) 0;
        pCur.validNKey = false;
        --pCur.aiIdx[(int) pCur.iPage];
        Sqlite3.MemPage memPage = pCur.apPage[(int) pCur.iPage];
        num2 = memPage.intKey == (byte) 0 || memPage.leaf != (byte) 0 ? 0 : Sqlite3.sqlite3BtreePrevious(pCur, ref pRes);
      }
      pRes = 0;
      return num2;
    }

    private static int allocateBtreePage(
      Sqlite3.BtShared pBt,
      ref Sqlite3.MemPage ppPage,
      ref uint pPgno,
      uint nearby,
      byte exact)
    {
      Sqlite3.MemPage ppPage1 = (Sqlite3.MemPage) null;
      Sqlite3.MemPage pPage = (Sqlite3.MemPage) null;
      Sqlite3.MemPage pPage1 = pBt.pPage1;
      uint num1 = Sqlite3.btreePagecount(pBt);
      uint num2 = Sqlite3.sqlite3Get4byte(pPage1.aData, 36);
      Sqlite3.testcase<bool>((int) num2 == (int) num1 - 1);
      if (num2 >= num1)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      int num3;
      if (num2 > 0U)
      {
        byte num4 = 0;
        if (exact != (byte) 0 && nearby <= num1)
        {
          byte pEType = 0;
          uint pPgno1 = 0;
          int num5 = Sqlite3.ptrmapGet(pBt, nearby, ref pEType, ref pPgno1);
          if (num5 != 0)
            return num5;
          if (pEType == (byte) 2)
            num4 = (byte) 1;
          pPgno = nearby;
        }
        int num6 = Sqlite3.sqlite3PagerWrite(pPage1.pDbPage);
        if (num6 != 0)
          return num6;
        Sqlite3.sqlite3Put4byte(pPage1.aData, 36U, num2 - 1U);
        do
        {
          pPage = ppPage1;
          uint pgno = pPage == null ? Sqlite3.sqlite3Get4byte(pPage1.aData, 32) : Sqlite3.sqlite3Get4byte(pPage.aData, 0);
          Sqlite3.testcase<bool>((int) pgno == (int) num1);
          num3 = pgno <= num1 ? Sqlite3.btreeGetPage(pBt, pgno, ref ppPage1, 0) : Sqlite3.SQLITE_CORRUPT_BKPT();
          if (num3 != 0)
          {
            ppPage1 = (Sqlite3.MemPage) null;
            break;
          }
          uint num7 = Sqlite3.sqlite3Get4byte(ppPage1.aData, 4);
          if (num7 == 0U && num4 == (byte) 0)
          {
            num3 = Sqlite3.sqlite3PagerWrite(ppPage1.pDbPage);
            if (num3 == 0)
            {
              pPgno = pgno;
              Buffer.BlockCopy((Array) ppPage1.aData, 0, (Array) pPage1.aData, 32, 4);
              ppPage = ppPage1;
              ppPage1 = (Sqlite3.MemPage) null;
              Sqlite3.TRACE("ALLOCATE: %d trunk - %d free pages left\n", (object) pPgno, (object) (uint) ((int) num2 - 1));
            }
            else
              break;
          }
          else
          {
            if (num7 > pBt.usableSize / 4U - 2U)
            {
              num3 = Sqlite3.SQLITE_CORRUPT_BKPT();
              break;
            }
            if (num4 != (byte) 0 && (int) nearby == (int) pgno)
            {
              ppPage = ppPage1;
              num4 = (byte) 0;
              num3 = Sqlite3.sqlite3PagerWrite(ppPage1.pDbPage);
              if (num3 == 0)
              {
                if (num7 == 0U)
                {
                  if (pPage == null)
                  {
                    pPage1.aData[32] = ppPage1.aData[0];
                    pPage1.aData[33] = ppPage1.aData[1];
                    pPage1.aData[34] = ppPage1.aData[2];
                    pPage1.aData[35] = ppPage1.aData[3];
                  }
                  else
                  {
                    num3 = Sqlite3.sqlite3PagerWrite(pPage.pDbPage);
                    if (num3 == 0)
                    {
                      pPage.aData[0] = ppPage1.aData[0];
                      pPage.aData[1] = ppPage1.aData[1];
                      pPage.aData[2] = ppPage1.aData[2];
                      pPage.aData[3] = ppPage1.aData[3];
                    }
                    else
                      break;
                  }
                }
                else
                {
                  Sqlite3.MemPage ppPage2 = new Sqlite3.MemPage();
                  uint num8 = Sqlite3.sqlite3Get4byte(ppPage1.aData, 8);
                  if (num8 > num1)
                  {
                    num3 = Sqlite3.SQLITE_CORRUPT_BKPT();
                    break;
                  }
                  Sqlite3.testcase<bool>((int) num8 == (int) num1);
                  num3 = Sqlite3.btreeGetPage(pBt, num8, ref ppPage2, 0);
                  if (num3 == 0)
                  {
                    num3 = Sqlite3.sqlite3PagerWrite(ppPage2.pDbPage);
                    if (num3 != 0)
                    {
                      Sqlite3.releasePage(ppPage2);
                      break;
                    }
                    ppPage2.aData[0] = ppPage1.aData[0];
                    ppPage2.aData[1] = ppPage1.aData[1];
                    ppPage2.aData[2] = ppPage1.aData[2];
                    ppPage2.aData[3] = ppPage1.aData[3];
                    Sqlite3.sqlite3Put4byte(ppPage2.aData, 4U, num7 - 1U);
                    Buffer.BlockCopy((Array) ppPage1.aData, 12, (Array) ppPage2.aData, 8, ((int) num7 - 1) * 4);
                    Sqlite3.releasePage(ppPage2);
                    if (pPage == null)
                    {
                      Sqlite3.sqlite3Put4byte(pPage1.aData, 32U, num8);
                    }
                    else
                    {
                      num3 = Sqlite3.sqlite3PagerWrite(pPage.pDbPage);
                      if (num3 == 0)
                        Sqlite3.sqlite3Put4byte(pPage.aData, 0U, num8);
                      else
                        break;
                    }
                  }
                  else
                    break;
                }
                ppPage1 = (Sqlite3.MemPage) null;
                Sqlite3.TRACE("ALLOCATE: %d trunk - %d free pages left\n", (object) pPgno, (object) (uint) ((int) num2 - 1));
              }
              else
                break;
            }
            else if (num7 > 0U)
            {
              byte[] aData = ppPage1.aData;
              uint num9;
              if (nearby > 0U)
              {
                num9 = 0U;
                int num10 = Sqlite3.sqlite3AbsInt32((int) Sqlite3.sqlite3Get4byte(aData, 8) - (int) nearby);
                for (uint index = 1; index < num7; ++index)
                {
                  int num11 = Sqlite3.sqlite3AbsInt32((int) Sqlite3.sqlite3Get4byte(aData, (uint) (8 + (int) index * 4)) - (int) nearby);
                  if (num11 < num10)
                  {
                    num9 = index;
                    num10 = num11;
                  }
                }
              }
              else
                num9 = 0U;
              uint num12 = Sqlite3.sqlite3Get4byte(aData, (uint) (8 + (int) num9 * 4));
              Sqlite3.testcase<bool>((int) num12 == (int) num1);
              if (num12 > num1)
              {
                num3 = Sqlite3.SQLITE_CORRUPT_BKPT();
                break;
              }
              Sqlite3.testcase<bool>((int) num12 == (int) num1);
              if (num4 == (byte) 0 || (int) num12 == (int) nearby)
              {
                pPgno = num12;
                Sqlite3.TRACE("ALLOCATE: %d was leaf %d of %d on trunk %d: %d more free pages\n", (object) pPgno, (object) (uint) ((int) num9 + 1), (object) num7, (object) ppPage1.pgno, (object) (uint) ((int) num2 - 1));
                num3 = Sqlite3.sqlite3PagerWrite(ppPage1.pDbPage);
                if (num3 == 0)
                {
                  if (num9 < num7 - 1U)
                    Buffer.BlockCopy((Array) aData, 4 + (int) num7 * 4, (Array) aData, 8 + (int) num9 * 4, 4);
                  Sqlite3.sqlite3Put4byte(aData, 4U, num7 - 1U);
                  int noContent = !Sqlite3.btreeGetHasContent(pBt, pPgno) ? 1 : 0;
                  num3 = Sqlite3.btreeGetPage(pBt, pPgno, ref ppPage, noContent);
                  if (num3 == 0)
                  {
                    num3 = Sqlite3.sqlite3PagerWrite(ppPage.pDbPage);
                    if (num3 != 0)
                      Sqlite3.releasePage(ppPage);
                  }
                  num4 = (byte) 0;
                }
                else
                  break;
              }
            }
          }
          Sqlite3.releasePage(pPage);
          pPage = (Sqlite3.MemPage) null;
        }
        while (num4 != (byte) 0);
      }
      else
      {
        int num13 = Sqlite3.sqlite3PagerWrite(pBt.pPage1.pDbPage);
        if (num13 != 0)
          return num13;
        ++pBt.nPage;
        if ((int) pBt.nPage == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
          ++pBt.nPage;
        if (pBt.autoVacuum && Sqlite3.PTRMAP_ISPAGE(pBt, pBt.nPage))
        {
          Sqlite3.MemPage ppPage3 = (Sqlite3.MemPage) null;
          Sqlite3.TRACE("ALLOCATE: %d from end of file (pointer-map page)\n", (object) pPgno);
          int num14 = Sqlite3.btreeGetPage(pBt, pBt.nPage, ref ppPage3, 1);
          if (num14 == 0)
          {
            num14 = Sqlite3.sqlite3PagerWrite(ppPage3.pDbPage);
            Sqlite3.releasePage(ppPage3);
          }
          if (num14 != 0)
            return num14;
          ++pBt.nPage;
          if ((int) pBt.nPage == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
            ++pBt.nPage;
        }
        Sqlite3.sqlite3Put4byte(pBt.pPage1.aData, 28U, pBt.nPage);
        pPgno = pBt.nPage;
        int page = Sqlite3.btreeGetPage(pBt, pPgno, ref ppPage, 1);
        if (page != 0)
          return page;
        num3 = Sqlite3.sqlite3PagerWrite(ppPage.pDbPage);
        if (num3 != 0)
          Sqlite3.releasePage(ppPage);
        Sqlite3.TRACE("ALLOCATE: %d from end of file\n", (object) pPgno);
      }
      Sqlite3.releasePage(ppPage1);
      Sqlite3.releasePage(pPage);
      if (num3 == 0)
      {
        if (Sqlite3.sqlite3PagerPageRefcount(ppPage.pDbPage) > 1)
        {
          Sqlite3.releasePage(ppPage);
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        }
        ppPage.isInit = (byte) 0;
      }
      else
        ppPage = (Sqlite3.MemPage) null;
      return num3;
    }

    private static int freePage2(Sqlite3.BtShared pBt, Sqlite3.MemPage pMemPage, uint iPage)
    {
      Sqlite3.MemPage ppPage1 = (Sqlite3.MemPage) null;
      uint num1 = 0;
      Sqlite3.MemPage pPage1 = pBt.pPage1;
      Sqlite3.MemPage ppPage2;
      if (pMemPage != null)
      {
        ppPage2 = pMemPage;
        Sqlite3.sqlite3PagerRef(ppPage2.pDbPage);
      }
      else
        ppPage2 = Sqlite3.btreePageLookup(pBt, iPage);
      int pRC = Sqlite3.sqlite3PagerWrite(pPage1.pDbPage);
      if (pRC == 0)
      {
        int num2 = (int) Sqlite3.sqlite3Get4byte(pPage1.aData, 36);
        Sqlite3.sqlite3Put4byte(pPage1.aData, 36, num2 + 1);
        if (pBt.secureDelete)
        {
          if ((ppPage2 != null || (pRC = Sqlite3.btreeGetPage(pBt, iPage, ref ppPage2, 0)) == 0) && (pRC = Sqlite3.sqlite3PagerWrite(ppPage2.pDbPage)) == 0)
            Array.Clear((Array) ppPage2.aData, 0, (int) ppPage2.pBt.pageSize);
          else
            goto label_22;
        }
        if (pBt.autoVacuum)
        {
          Sqlite3.ptrmapPut(pBt, iPage, (byte) 2, 0U, ref pRC);
          if (pRC != 0)
            goto label_22;
        }
        if (num2 != 0)
        {
          num1 = Sqlite3.sqlite3Get4byte(pPage1.aData, 32);
          pRC = Sqlite3.btreeGetPage(pBt, num1, ref ppPage1, 0);
          if (pRC == 0)
          {
            uint num3 = Sqlite3.sqlite3Get4byte(ppPage1.aData, 4);
            if (num3 > pBt.usableSize / 4U - 2U)
            {
              pRC = Sqlite3.SQLITE_CORRUPT_BKPT();
              goto label_22;
            }
            else if (num3 < pBt.usableSize / 4U - 8U)
            {
              pRC = Sqlite3.sqlite3PagerWrite(ppPage1.pDbPage);
              if (pRC == 0)
              {
                Sqlite3.sqlite3Put4byte(ppPage1.aData, 4U, num3 + 1U);
                Sqlite3.sqlite3Put4byte(ppPage1.aData, (uint) (8 + (int) num3 * 4), iPage);
                if (ppPage2 != null && !pBt.secureDelete)
                  Sqlite3.sqlite3PagerDontWrite(ppPage2.pDbPage);
                pRC = Sqlite3.btreeSetHasContent(pBt, iPage);
              }
              Sqlite3.TRACE("FREE-PAGE: %d leaf on trunk page %d\n", (object) iPage, (object) ppPage1.pgno);
              goto label_22;
            }
          }
          else
            goto label_22;
        }
        if (ppPage2 != null || (pRC = Sqlite3.btreeGetPage(pBt, iPage, ref ppPage2, 0)) == 0)
        {
          pRC = Sqlite3.sqlite3PagerWrite(ppPage2.pDbPage);
          if (pRC == 0)
          {
            Sqlite3.sqlite3Put4byte(ppPage2.aData, (ulong) num1);
            Sqlite3.sqlite3Put4byte(ppPage2.aData, 4, 0);
            Sqlite3.sqlite3Put4byte(pPage1.aData, 32U, iPage);
            Sqlite3.TRACE("FREE-PAGE: %d new trunk page replacing %d\n", (object) ppPage2.pgno, (object) num1);
          }
        }
      }
label_22:
      if (ppPage2 != null)
        ppPage2.isInit = (byte) 0;
      Sqlite3.releasePage(ppPage2);
      Sqlite3.releasePage(ppPage1);
      return pRC;
    }

    private static void freePage(Sqlite3.MemPage pPage, ref int pRC)
    {
      if (pRC != 0)
        return;
      pRC = Sqlite3.freePage2(pPage.pBt, pPage, pPage.pgno);
    }

    private static int clearCell(Sqlite3.MemPage pPage, int pCell)
    {
      Sqlite3.BtShared pBt = pPage.pBt;
      Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
      Sqlite3.btreeParseCellPtr(pPage, pCell, ref pInfo);
      if (pInfo.iOverflow == (ushort) 0)
        return 0;
      uint num1 = Sqlite3.sqlite3Get4byte(pPage.aData, pCell, (int) pInfo.iOverflow);
      uint num2 = (uint) (ushort) (pBt.usableSize - 4U);
      int num3 = (int) ((uint) ((int) pInfo.nPayload - (int) pInfo.nLocal + (int) num2 - 1) / num2);
      while (num3-- != 0)
      {
        uint pPgnoNext = 0;
        Sqlite3.MemPage ppPage = (Sqlite3.MemPage) null;
        if (num1 < 2U || num1 > Sqlite3.btreePagecount(pBt))
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        if (num3 != 0)
        {
          int overflowPage = Sqlite3.getOverflowPage(pBt, num1, out ppPage, out pPgnoNext);
          if (overflowPage != 0)
            return overflowPage;
        }
        int num4 = ppPage == null && (ppPage = Sqlite3.btreePageLookup(pBt, num1)) == null || Sqlite3.sqlite3PagerPageRefcount(ppPage.pDbPage) == 1 ? Sqlite3.freePage2(pBt, ppPage, num1) : Sqlite3.SQLITE_CORRUPT_BKPT();
        if (ppPage != null)
          Sqlite3.sqlite3PagerUnref(ppPage.pDbPage);
        if (num4 != 0)
          return num4;
        num1 = pPgnoNext;
      }
      return 0;
    }

    private static int fillInCell(
      Sqlite3.MemPage pPage,
      byte[] pCell,
      byte[] pKey,
      long nKey,
      byte[] pData,
      int nData,
      int nZero,
      ref int pnSize)
    {
      int srcOffset = 0;
      Sqlite3.MemPage ppPage = (Sqlite3.MemPage) null;
      Sqlite3.MemPage pPage1 = (Sqlite3.MemPage) null;
      Sqlite3.BtShared pBt = pPage.pBt;
      uint pPgno = 0;
      Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
      int offset1 = 0;
      if (pPage.leaf == (byte) 0)
        offset1 += 4;
      if (pPage.hasData != (byte) 0)
        offset1 += Sqlite3.putVarint(pCell, offset1, nData + nZero);
      else
        nData = nZero = 0;
      int num1 = offset1 + Sqlite3.putVarint(pCell, offset1, (ulong) nKey);
      Sqlite3.btreeParseCellPtr(pPage, pCell, ref pInfo);
      int num2 = nData + nZero;
      byte[] src;
      int num3;
      if (pPage.intKey != (byte) 0)
      {
        src = pData;
        num3 = nData;
        nData = 0;
      }
      else
      {
        if (Sqlite3.NEVER(nKey > (long) int.MaxValue || pKey == null))
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        num2 += (int) nKey;
        src = pKey;
        num3 = (int) nKey;
      }
      pnSize = (int) pInfo.nSize;
      int num4 = (int) pInfo.nLocal;
      byte[] dst = pCell;
      int dstOffset = num1;
      byte[] p = pCell;
      int offset2 = (int) pInfo.iOverflow;
      while (num2 > 0)
      {
        if (num4 == 0)
        {
          uint parent = pPgno;
          if (pBt.autoVacuum)
          {
            do
            {
              ++pPgno;
            }
            while (Sqlite3.PTRMAP_ISPAGE(pBt, pPgno) || (int) pPgno == (int) Sqlite3.PENDING_BYTE_PAGE(pBt));
          }
          int pRC = Sqlite3.allocateBtreePage(pBt, ref ppPage, ref pPgno, pPgno, (byte) 0);
          if (pBt.autoVacuum && pRC == 0)
          {
            byte eType = parent != 0U ? (byte) 4 : (byte) 3;
            Sqlite3.ptrmapPut(pBt, pPgno, eType, parent, ref pRC);
            if (pRC != 0)
              Sqlite3.releasePage(ppPage);
          }
          if (pRC != 0)
          {
            Sqlite3.releasePage(pPage1);
            return pRC;
          }
          Sqlite3.sqlite3Put4byte(p, offset2, (ulong) pPgno);
          Sqlite3.releasePage(pPage1);
          pPage1 = ppPage;
          p = ppPage.aData;
          offset2 = 0;
          Sqlite3.sqlite3Put4byte(p, 0);
          dst = ppPage.aData;
          dstOffset = 4;
          num4 = (int) pBt.usableSize - 4;
        }
        int num5 = num2;
        if (num5 > num4)
          num5 = num4;
        if (num3 > 0)
        {
          if (num5 > num3)
            num5 = num3;
          Buffer.BlockCopy((Array) src, srcOffset, (Array) dst, dstOffset, num5);
        }
        else
          Buffer.BlockCopy((Array) Sqlite3.sqlite3Malloc(num5), 0, (Array) dst, dstOffset, num5);
        num2 -= num5;
        dstOffset += num5;
        srcOffset += num5;
        num3 -= num5;
        num4 -= num5;
        if (num3 == 0)
        {
          num3 = nData;
          src = pData;
        }
      }
      Sqlite3.releasePage(pPage1);
      return 0;
    }

    private static void dropCell(Sqlite3.MemPage pPage, int idx, int sz, ref int pRC)
    {
      if (pRC != 0)
        return;
      byte[] aData = pPage.aData;
      int num1 = (int) pPage.cellOffset + 2 * idx;
      uint start = (uint) Sqlite3.get2byte(aData, num1);
      int hdrOffset = (int) pPage.hdrOffset;
      Sqlite3.testcase<bool>((long) start == (long) Sqlite3.get2byte(aData, hdrOffset + 5));
      Sqlite3.testcase<bool>((long) start + (long) sz == (long) pPage.pBt.usableSize);
      if (start < (uint) Sqlite3.get2byte(aData, hdrOffset + 5) || (long) start + (long) sz > (long) pPage.pBt.usableSize)
      {
        pRC = Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      else
      {
        int num2 = Sqlite3.freeSpace(pPage, start, sz);
        if (num2 != 0)
        {
          pRC = num2;
        }
        else
        {
          Buffer.BlockCopy((Array) aData, num1 + 2, (Array) aData, num1, ((int) pPage.nCell - 1 - idx) * 2);
          --pPage.nCell;
          aData[(int) pPage.hdrOffset + 3] = (byte) ((uint) pPage.nCell >> 8);
          aData[(int) pPage.hdrOffset + 4] = (byte) pPage.nCell;
          pPage.nFree += (ushort) 2;
        }
      }
    }

    private static void insertCell(
      Sqlite3.MemPage pPage,
      int i,
      byte[] pCell,
      int sz,
      byte[] pTemp,
      uint iChild,
      ref int pRC)
    {
      int pIdx = 0;
      int num1 = iChild != 0U ? 4 : 0;
      if (pRC != 0)
        return;
      if (pPage.nOverflow != (byte) 0 || sz + 2 > (int) pPage.nFree)
      {
        if (pTemp != null)
        {
          Buffer.BlockCopy((Array) pCell, num1, (Array) pTemp, num1, sz - num1);
          pCell = pTemp;
        }
        if (iChild != 0U)
          Sqlite3.sqlite3Put4byte(pCell, (ulong) iChild);
        int index = (int) pPage.nOverflow++;
        pPage.aOvfl[index].pCell = pCell;
        pPage.aOvfl[index].idx = (ushort) i;
      }
      else
      {
        int num2 = Sqlite3.sqlite3PagerWrite(pPage.pDbPage);
        if (num2 != 0)
        {
          pRC = num2;
        }
        else
        {
          byte[] aData = pPage.aData;
          int cellOffset = (int) pPage.cellOffset;
          int num3 = cellOffset + 2 * (int) pPage.nCell;
          int Offset = cellOffset + 2 * i;
          int num4 = Sqlite3.allocateSpace(pPage, sz, ref pIdx);
          if (num4 != 0)
          {
            pRC = num4;
          }
          else
          {
            ++pPage.nCell;
            pPage.nFree -= (ushort) (2 + sz);
            Buffer.BlockCopy((Array) pCell, num1, (Array) aData, pIdx + num1, sz - num1);
            if (iChild != 0U)
              Sqlite3.sqlite3Put4byte(aData, pIdx, (ulong) iChild);
            for (int index = num3; index > Offset; index -= 2)
            {
              aData[index] = aData[index - 2];
              aData[index + 1] = aData[index - 1];
            }
            Sqlite3.put2byte(aData, Offset, pIdx);
            Sqlite3.put2byte(aData, (int) pPage.hdrOffset + 3, (int) pPage.nCell);
            if (!pPage.pBt.autoVacuum)
              return;
            Sqlite3.ptrmapPutOvflPtr(pPage, pCell, ref pRC);
          }
        }
      }
    }

    private static void assemblePage(Sqlite3.MemPage pPage, int nCell, byte[] apCell, int[] aSize)
    {
      byte[] aData = pPage.aData;
      int hdrOffset = (int) pPage.hdrOffset;
      int usableSize = (int) pPage.pBt.usableSize;
      int Offset = (int) pPage.cellOffset + nCell * 2;
      int num = usableSize;
      for (int index = nCell - 1; index >= 0; --index)
      {
        ushort count = (ushort) aSize[index];
        Offset -= 2;
        num -= (int) count;
        Sqlite3.put2byte(aData, Offset, num);
        Buffer.BlockCopy((Array) apCell, 0, (Array) aData, num, (int) count);
      }
      Sqlite3.put2byte(aData, hdrOffset + 3, nCell);
      Sqlite3.put2byte(aData, hdrOffset + 5, num);
      pPage.nFree -= (ushort) (nCell * 2 + usableSize - num);
      pPage.nCell = (ushort) nCell;
    }

    private static void assemblePage(
      Sqlite3.MemPage pPage,
      int nCell,
      byte[][] apCell,
      ushort[] aSize,
      int offset)
    {
      byte[] aData = pPage.aData;
      int hdrOffset = (int) pPage.hdrOffset;
      int usableSize = (int) pPage.pBt.usableSize;
      int Offset = (int) pPage.cellOffset + nCell * 2;
      int num = usableSize;
      for (int index = nCell - 1; index >= 0; --index)
      {
        Offset -= 2;
        num -= (int) aSize[index + offset];
        Sqlite3.put2byte(aData, Offset, num);
        Buffer.BlockCopy((Array) apCell[offset + index], 0, (Array) aData, num, (int) aSize[index + offset]);
      }
      Sqlite3.put2byte(aData, hdrOffset + 3, nCell);
      Sqlite3.put2byte(aData, hdrOffset + 5, num);
      pPage.nFree -= (ushort) (nCell * 2 + usableSize - num);
      pPage.nCell = (ushort) nCell;
    }

    private static void assemblePage(
      Sqlite3.MemPage pPage,
      int nCell,
      byte[] apCell,
      ushort[] aSize)
    {
      byte[] aData = pPage.aData;
      int hdrOffset = (int) pPage.hdrOffset;
      int usableSize = (int) pPage.pBt.usableSize;
      int Offset = (int) pPage.cellOffset + nCell * 2;
      int num = usableSize;
      for (int index = nCell - 1; index >= 0; --index)
      {
        Offset -= 2;
        num -= (int) aSize[index];
        Sqlite3.put2byte(aData, Offset, num);
        Buffer.BlockCopy((Array) apCell, 0, (Array) aData, num, (int) aSize[index]);
      }
      Sqlite3.put2byte(aData, hdrOffset + 3, nCell);
      Sqlite3.put2byte(aData, hdrOffset + 5, num);
      pPage.nFree -= (ushort) (nCell * 2 + usableSize - num);
      pPage.nCell = (ushort) nCell;
    }

    private static int balance_quick(Sqlite3.MemPage pParent, Sqlite3.MemPage pPage, byte[] pSpace)
    {
      Sqlite3.BtShared pBt = pPage.pBt;
      Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
      uint pPgno = 0;
      if (pPage.nCell <= (ushort) 0)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      int pRC = Sqlite3.allocateBtreePage(pBt, ref ppPage, ref pPgno, 0U, (byte) 0);
      if (pRC == 0)
      {
        int sz = 4;
        byte[] pCell = pPage.aOvfl[0].pCell;
        int[] aSize = new int[1]
        {
          (int) Sqlite3.cellSizePtr(pPage, pCell)
        };
        Sqlite3.zeroPage(ppPage, 13);
        Sqlite3.assemblePage(ppPage, 1, pCell, aSize);
        if (pBt.autoVacuum)
        {
          Sqlite3.ptrmapPut(pBt, pPgno, (byte) 5, pParent.pgno, ref pRC);
          if (aSize[0] > (int) ppPage.minLocal)
            Sqlite3.ptrmapPutOvflPtr(ppPage, pCell, ref pRC);
        }
        int cell = Sqlite3.findCell(pPage, (int) pPage.nCell - 1);
        byte[] aData = pPage.aData;
        int num1 = cell;
        int num2 = num1 + 9;
        do
          ;
        while (((int) aData[num1++] & 128) != 0 && num1 < num2);
        int num3 = num1 + 9;
        byte num4;
        do
        {
          byte[] numArray1 = pSpace;
          int index1 = sz++;
          byte[] numArray2 = aData;
          int index2 = num1++;
          int num5;
          num4 = (byte) (num5 = (int) numArray2[index2]);
          numArray1[index1] = (byte) num5;
        }
        while (((int) num4 & 128) != 0 && num1 < num3);
        Sqlite3.insertCell(pParent, (int) pParent.nCell, pSpace, sz, (byte[]) null, pPage.pgno, ref pRC);
        Sqlite3.sqlite3Put4byte(pParent.aData, (int) pParent.hdrOffset + 8, (ulong) pPgno);
        Sqlite3.releasePage(ppPage);
      }
      return pRC;
    }

    private static void copyNodeContent(Sqlite3.MemPage pFrom, Sqlite3.MemPage pTo, ref int pRC)
    {
      if (pRC != 0)
        return;
      Sqlite3.BtShared pBt = pFrom.pBt;
      byte[] aData1 = pFrom.aData;
      byte[] aData2 = pTo.aData;
      int hdrOffset = (int) pFrom.hdrOffset;
      int dstOffset = pTo.pgno == 1U ? 100 : 0;
      int num1 = Sqlite3.get2byte(aData1, hdrOffset + 5);
      Buffer.BlockCopy((Array) aData1, num1, (Array) aData2, num1, (int) pBt.usableSize - num1);
      Buffer.BlockCopy((Array) aData1, hdrOffset, (Array) aData2, dstOffset, (int) pFrom.cellOffset + 2 * (int) pFrom.nCell);
      pTo.isInit = (byte) 0;
      int num2 = Sqlite3.btreeInitPage(pTo);
      if (num2 != 0)
      {
        pRC = num2;
      }
      else
      {
        if (!pBt.autoVacuum)
          return;
        pRC = Sqlite3.setChildPtrmaps(pTo);
      }
    }

    private static int balance_nonroot(
      Sqlite3.MemPage pParent,
      int iParentIdx,
      byte[] aOvflSpace,
      int isRoot)
    {
      Sqlite3.MemPage[] memPageArray1 = new Sqlite3.MemPage[Sqlite3.NB];
      Sqlite3.MemPage[] memPageArray2 = new Sqlite3.MemPage[Sqlite3.NB];
      Sqlite3.MemPage[] memPageArray3 = new Sqlite3.MemPage[Sqlite3.NB + 2];
      int[] numArray1 = new int[Sqlite3.NB - 1];
      int[] numArray2 = new int[Sqlite3.NB + 2];
      int[] numArray3 = new int[Sqlite3.NB + 2];
      ushort[] array = new ushort[1];
      int index1 = 0;
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      byte[][] numArray4 = (byte[][]) null;
      Sqlite3.BtShared pBt = pParent.pBt;
      int index2 = (int) pParent.nOverflow + (int) pParent.nCell;
      int i;
      int num4;
      if (index2 < 2)
      {
        i = 0;
        num4 = index2 + 1;
      }
      else
      {
        num4 = 3;
        i = iParentIdx != 0 ? (iParentIdx != index2 ? iParentIdx - 1 : index2 - 2) : 0;
        index2 = 2;
      }
      int offset1 = index2 + i - (int) pParent.nOverflow != (int) pParent.nCell ? Sqlite3.findCell(pParent, index2 + i - (int) pParent.nOverflow) : (int) pParent.hdrOffset + 8;
      uint pPgno = Sqlite3.sqlite3Get4byte(pParent.aData, offset1);
      int pRC;
      while (true)
      {
        pRC = Sqlite3.getAndInitPage(pBt, pPgno, ref memPageArray1[index2]);
        if (pRC == 0)
        {
          num1 += 1 + (int) memPageArray1[index2].nCell + (int) memPageArray1[index2].nOverflow;
          if (index2-- != 0)
          {
            if (index2 + i == (int) pParent.aOvfl[0].idx && pParent.nOverflow != (byte) 0)
            {
              numArray1[index2] = 0;
              pPgno = Sqlite3.sqlite3Get4byte(pParent.aOvfl[0].pCell, numArray1[index2]);
              numArray3[index2] = (int) Sqlite3.cellSizePtr(pParent, numArray1[index2]);
              pParent.nOverflow = (byte) 0;
            }
            else
            {
              numArray1[index2] = Sqlite3.findCell(pParent, index2 + i - (int) pParent.nOverflow);
              pPgno = Sqlite3.sqlite3Get4byte(pParent.aData, numArray1[index2]);
              numArray3[index2] = (int) Sqlite3.cellSizePtr(pParent, numArray1[index2]);
              Sqlite3.dropCell(pParent, index2 + i - (int) pParent.nOverflow, numArray3[index2], ref pRC);
            }
          }
          else
            break;
        }
        else
          goto label_109;
      }
      int num5 = num1 + 3 & -4;
      numArray4 = Sqlite3.sqlite3ScratchMalloc(numArray4, num5);
      if (array.Length < num5)
        Array.Resize<ushort>(ref array, num5);
      ushort srcOffset = (ushort) ((uint) memPageArray1[0].leaf * 4U);
      int hasData = (int) memPageArray1[0].hasData;
      for (int index3 = 0; index3 < num4; ++index3)
      {
        Sqlite3.MemPage pPage = memPageArray2[index3] = memPageArray1[index3].Copy();
        int num6 = (int) pPage.nCell + (int) pPage.nOverflow;
        int nOverflow = (int) pPage.nOverflow;
        for (int iCell = 0; iCell < num6; ++iCell)
        {
          int overflowCell = Sqlite3.findOverflowCell(pPage, iCell);
          array[index1] = Sqlite3.cellSizePtr(pPage, overflowCell);
          if (numArray4[index1] == null)
            numArray4[index1] = new byte[(int) array[index1]];
          else if (numArray4[index1].Length < (int) array[index1])
            Array.Resize<byte>(ref numArray4[index1], (int) array[index1]);
          if (overflowCell < 0)
            Buffer.BlockCopy((Array) pPage.aOvfl[-(overflowCell + 1)].pCell, 0, (Array) numArray4[index1], 0, (int) array[index1]);
          else
            Buffer.BlockCopy((Array) pPage.aData, overflowCell, (Array) numArray4[index1], 0, (int) array[index1]);
          ++index1;
        }
        if (index3 < num4 - 1 && hasData == 0)
        {
          ushort num7 = (ushort) numArray3[index3];
          byte[] numArray5 = Sqlite3.sqlite3Malloc((int) num7 + (int) srcOffset);
          array[index1] = num7;
          Buffer.BlockCopy((Array) pParent.aData, numArray1[index3], (Array) numArray5, 0, (int) num7);
          if (numArray4[index1] == null || numArray4[index1].Length < (int) num7)
            Array.Resize<byte>(ref numArray4[index1], (int) num7);
          Buffer.BlockCopy((Array) numArray5, (int) srcOffset, (Array) numArray4[index1], 0, (int) num7);
          array[index1] = (ushort) ((uint) array[index1] - (uint) srcOffset);
          if (pPage.leaf == (byte) 0)
            Buffer.BlockCopy((Array) pPage.aData, 8, (Array) numArray4[index1], 0, 4);
          else if (array[index1] < (ushort) 4)
            array[index1] = (ushort) 4;
          ++index1;
        }
      }
      int num8 = (int) pBt.usableSize - 12 + (int) srcOffset;
      int num9;
      int index4 = num9 = 0;
      int index5 = num9;
      int num10 = num9;
      for (; index4 < index1; ++index4)
      {
        num10 += (int) array[index4] + 2;
        if (num10 > num8)
        {
          numArray3[index5] = num10 - (int) array[index4];
          numArray2[index5] = index4;
          if (hasData != 0)
            --index4;
          num10 = 0;
          ++index5;
          if (index5 > Sqlite3.NB + 1)
          {
            pRC = Sqlite3.SQLITE_CORRUPT_BKPT();
            goto label_109;
          }
        }
      }
      numArray3[index5] = num10;
      numArray2[index5] = index1;
      int num11 = index5 + 1;
      for (int index6 = num11 - 1; index6 > 0; --index6)
      {
        int num12 = numArray3[index6];
        int num13 = numArray3[index6 - 1];
        int index7 = numArray2[index6 - 1] - 1;
        for (int index8 = index7 + 1 - hasData; num12 == 0 || num12 + (int) array[index8] + 2 <= num13 - ((int) array[index7] + 2); index8 = index7 + 1 - hasData)
        {
          num12 += (int) array[index8] + 2;
          num13 -= (int) array[index7] + 2;
          --numArray2[index6 - 1];
          index7 = numArray2[index6 - 1] - 1;
        }
        numArray3[index6] = num12;
        numArray3[index6 - 1] = num13;
      }
      Sqlite3.TRACE("BALANCE: old: %d %d %d  ", (object) memPageArray1[0].pgno, (object) (uint) (num4 >= 2 ? (int) memPageArray1[1].pgno : 0), (object) (uint) (num4 >= 3 ? (int) memPageArray1[2].pgno : 0));
      if (memPageArray1[0].pgno <= 1U)
      {
        pRC = Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      else
      {
        int flags = (int) memPageArray1[0].aData[0];
        int index9;
        for (index9 = 0; index9 < num11; ++index9)
        {
          Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
          if (index9 < num4)
          {
            Sqlite3.MemPage memPage = memPageArray3[index9] = memPageArray1[index9];
            memPageArray1[index9] = (Sqlite3.MemPage) null;
            pRC = Sqlite3.sqlite3PagerWrite(memPage.pDbPage);
            ++num2;
            if (pRC != 0)
              goto label_109;
          }
          else
          {
            pRC = Sqlite3.allocateBtreePage(pBt, ref ppPage, ref pPgno, pPgno, (byte) 0);
            if (pRC == 0)
            {
              memPageArray3[index9] = ppPage;
              ++num2;
              if (pBt.autoVacuum)
              {
                Sqlite3.ptrmapPut(pBt, ppPage.pgno, (byte) 5, pParent.pgno, ref pRC);
                if (pRC != 0)
                  goto label_109;
              }
            }
            else
              goto label_109;
          }
        }
        for (; index9 < num4; ++index9)
        {
          Sqlite3.freePage(memPageArray1[index9], ref pRC);
          if (pRC == 0)
          {
            Sqlite3.releasePage(memPageArray1[index9]);
            memPageArray1[index9] = (Sqlite3.MemPage) null;
          }
          else
            goto label_109;
        }
        for (int index10 = 0; index10 < num11 - 1; ++index10)
        {
          int pgno = (int) memPageArray3[index10].pgno;
          int index11 = index10;
          for (int index12 = index10 + 1; index12 < num11; ++index12)
          {
            if (memPageArray3[index12].pgno < (uint) pgno)
            {
              index11 = index12;
              pgno = (int) memPageArray3[index12].pgno;
            }
          }
          if (index11 > index10)
          {
            Sqlite3.MemPage memPage = memPageArray3[index10];
            memPageArray3[index10] = memPageArray3[index11];
            memPageArray3[index11] = memPage;
          }
        }
        Sqlite3.TRACE("new: %d(%d) %d(%d) %d(%d) %d(%d) %d(%d)\n", (object) memPageArray3[0].pgno, (object) numArray3[0], (object) (uint) (num2 >= 2 ? (int) memPageArray3[1].pgno : 0), (object) (num2 >= 2 ? numArray3[1] : 0), (object) (uint) (num2 >= 3 ? (int) memPageArray3[2].pgno : 0), (object) (num2 >= 3 ? numArray3[2] : 0), (object) (uint) (num2 >= 4 ? (int) memPageArray3[3].pgno : 0), (object) (num2 >= 4 ? numArray3[3] : 0), (object) (uint) (num2 >= 5 ? (int) memPageArray3[4].pgno : 0), (object) (num2 >= 5 ? numArray3[4] : 0));
        Sqlite3.sqlite3Put4byte(pParent.aData, offset1, (ulong) memPageArray3[num2 - 1].pgno);
        int offset2 = 0;
        for (int index13 = 0; index13 < num2; ++index13)
        {
          Sqlite3.MemPage pPage = memPageArray3[index13];
          Sqlite3.zeroPage(pPage, flags);
          Sqlite3.assemblePage(pPage, numArray2[index13] - offset2, numArray4, array, offset2);
          offset2 = numArray2[index13];
          if (offset2 < index1)
          {
            byte[] numArray6 = numArray4[offset2];
            int num14 = (int) array[offset2] + (int) srcOffset;
            byte[] pTemp = Sqlite3.sqlite3Malloc(num14);
            if (pPage.leaf == (byte) 0)
              Buffer.BlockCopy((Array) numArray6, 0, (Array) pPage.aData, 8, 4);
            else if (hasData != 0)
            {
              Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
              --offset2;
              Sqlite3.btreeParseCellPtr(pPage, numArray4[offset2], ref pInfo);
              numArray6 = pTemp;
              num14 = 4 + Sqlite3.putVarint(numArray6, 4, (ulong) pInfo.nKey);
              pTemp = (byte[]) null;
            }
            else
            {
              byte[] dst = Sqlite3.sqlite3Malloc(numArray6.Length + 4);
              Buffer.BlockCopy((Array) numArray6, 0, (Array) dst, 4, numArray6.Length);
              numArray6 = dst;
              if (array[offset2] == (ushort) 4)
                num14 = (int) Sqlite3.cellSizePtr(pParent, numArray6);
            }
            num3 += num14;
            Sqlite3.insertCell(pParent, i, numArray6, num14, pTemp, pPage.pgno, ref pRC);
            if (pRC == 0)
            {
              ++offset2;
              ++i;
            }
            else
              goto label_109;
          }
        }
        if ((flags & 8) == 0)
          Buffer.BlockCopy((Array) memPageArray2[num4 - 1].aData, 8, (Array) memPageArray3[num2 - 1].aData, 8, 4);
        if (isRoot != 0 && pParent.nCell == (ushort) 0 && (int) pParent.hdrOffset <= (int) memPageArray3[0].nFree)
        {
          Sqlite3.copyNodeContent(memPageArray3[0], pParent, ref pRC);
          Sqlite3.freePage(memPageArray3[0], ref pRC);
        }
        else if (pBt.autoVacuum)
        {
          Sqlite3.MemPage pPage = memPageArray3[0];
          Sqlite3.MemPage memPage = memPageArray2[0];
          int nOverflow = (int) memPage.nOverflow;
          int num15 = (int) memPage.nCell + nOverflow;
          int num16 = nOverflow != 0 ? (int) memPage.aOvfl[0].idx : -1;
          int num17 = 0;
          int index14 = 0;
          for (int index15 = 0; index15 < index1; ++index15)
          {
            int num18 = 0;
            while (index15 == num15)
            {
              memPage = memPageArray2[++num17];
              num15 = index15 + (hasData == 0 ? 1 : 0) + (int) memPage.nCell + (int) memPage.nOverflow;
              if (memPage.nOverflow != (byte) 0)
              {
                nOverflow = (int) memPage.nOverflow;
                num16 = index15 + (hasData == 0 ? 1 : 0) + (int) memPage.aOvfl[0].idx;
              }
              num18 = hasData == 0 ? 1 : 0;
            }
            if (index15 == num16)
            {
              num18 = 1;
              if (--nOverflow > 0)
                ++num16;
            }
            if (index15 == numArray2[index14])
            {
              pPage = memPageArray3[++index14];
              if (hasData == 0)
                continue;
            }
            if (num18 != 0 || (int) memPage.pgno != (int) pPage.pgno)
            {
              if (srcOffset == (ushort) 0)
                Sqlite3.ptrmapPut(pBt, Sqlite3.sqlite3Get4byte(numArray4[index15]), (byte) 5, pPage.pgno, ref pRC);
              if ((int) array[index15] > (int) pPage.minLocal)
                Sqlite3.ptrmapPutOvflPtr(pPage, numArray4[index15], ref pRC);
            }
          }
          if (srcOffset == (ushort) 0)
          {
            for (int index16 = 0; index16 < num2; ++index16)
            {
              uint key = Sqlite3.sqlite3Get4byte(memPageArray3[index16].aData, 8);
              Sqlite3.ptrmapPut(pBt, key, (byte) 5, memPageArray3[index16].pgno, ref pRC);
            }
          }
        }
        Sqlite3.TRACE("BALANCE: finished: old=%d new=%d cells=%d\n", (object) num4, (object) num2, (object) index1);
      }
label_109:
      Sqlite3.sqlite3ScratchFree(numArray4);
      for (int index17 = 0; index17 < num4; ++index17)
        Sqlite3.releasePage(memPageArray1[index17]);
      for (int index18 = 0; index18 < num2; ++index18)
        Sqlite3.releasePage(memPageArray3[index18]);
      return pRC;
    }

    private static int balance_deeper(Sqlite3.MemPage pRoot, ref Sqlite3.MemPage ppChild)
    {
      Sqlite3.MemPage ppPage = (Sqlite3.MemPage) null;
      uint pPgno = 0;
      Sqlite3.BtShared pBt = pRoot.pBt;
      int pRC = Sqlite3.sqlite3PagerWrite(pRoot.pDbPage);
      if (pRC == 0)
      {
        pRC = Sqlite3.allocateBtreePage(pBt, ref ppPage, ref pPgno, pRoot.pgno, (byte) 0);
        Sqlite3.copyNodeContent(pRoot, ppPage, ref pRC);
        if (pBt.autoVacuum)
          Sqlite3.ptrmapPut(pBt, pPgno, (byte) 5, pRoot.pgno, ref pRC);
      }
      if (pRC != 0)
      {
        ppChild = (Sqlite3.MemPage) null;
        Sqlite3.releasePage(ppPage);
        return pRC;
      }
      Sqlite3.TRACE("BALANCE: copy root %d into %d\n", (object) pRoot.pgno, (object) ppPage.pgno);
      Array.Copy((Array) pRoot.aOvfl, (Array) ppPage.aOvfl, (int) pRoot.nOverflow);
      ppPage.nOverflow = pRoot.nOverflow;
      Sqlite3.zeroPage(pRoot, (int) ppPage.aData[0] & -9);
      Sqlite3.sqlite3Put4byte(pRoot.aData, (int) pRoot.hdrOffset + 8, (ulong) pPgno);
      ppChild = ppPage;
      return 0;
    }

    private static int balance(Sqlite3.BtCursor pCur)
    {
      int num1 = 0;
      int num2 = (int) pCur.pBt.usableSize * 2 / 3;
      do
      {
        int iPage = (int) pCur.iPage;
        Sqlite3.MemPage memPage = pCur.apPage[iPage];
        if (iPage == 0)
        {
          if (memPage.nOverflow != (byte) 0)
          {
            num1 = Sqlite3.balance_deeper(memPage, ref pCur.apPage[1]);
            if (num1 == 0)
            {
              pCur.iPage = (short) 1;
              pCur.aiIdx[0] = (ushort) 0;
              pCur.aiIdx[1] = (ushort) 0;
            }
          }
          else
            break;
        }
        else if (memPage.nOverflow != (byte) 0 || (int) memPage.nFree > num2)
        {
          Sqlite3.MemPage pParent = pCur.apPage[iPage - 1];
          int iParentIdx = (int) pCur.aiIdx[iPage - 1];
          num1 = Sqlite3.sqlite3PagerWrite(pParent.pDbPage);
          if (num1 == 0)
          {
            if (memPage.hasData != (byte) 0 && memPage.nOverflow == (byte) 1 && (int) memPage.aOvfl[0].idx == (int) memPage.nCell && pParent.pgno != 1U && (int) pParent.nCell == iParentIdx)
            {
              num1 = Sqlite3.balance_quick(pParent, memPage, Sqlite3.aBalanceQuickSpace);
            }
            else
            {
              byte[] numArray = new byte[(int) pCur.pBt.pageSize];
              num1 = Sqlite3.balance_nonroot(pParent, iParentIdx, (byte[]) null, iPage == 1 ? 1 : 0);
            }
          }
          memPage.nOverflow = (byte) 0;
          Sqlite3.releasePage(memPage);
          --pCur.iPage;
        }
        else
          break;
      }
      while (num1 == 0);
      return num1;
    }

    private static int sqlite3BtreeInsert(
      Sqlite3.BtCursor pCur,
      byte[] pKey,
      long nKey,
      byte[] pData,
      int nData,
      int nZero,
      int appendBias,
      int seekResult)
    {
      int pRes = seekResult;
      int pnSize = 0;
      Sqlite3.Btree pBtree = pCur.pBtree;
      Sqlite3.BtShared pBt = pBtree.pBt;
      if (pCur.eState == 3)
        return pCur.skipNext;
      if (pCur.pKeyInfo == null)
        Sqlite3.invalidateIncrblobCursors(pBtree, nKey, 0);
      int num1 = Sqlite3.saveAllCursors(pBt, pCur.pgnoRoot, pCur);
      if (num1 != 0)
        return num1;
      if (pRes == 0)
      {
        int num2 = Sqlite3.btreeMoveto(pCur, pKey, nKey, appendBias, ref pRes);
        if (num2 != 0)
          return num2;
      }
      Sqlite3.MemPage pPage = pCur.apPage[(int) pCur.iPage];
      Sqlite3.TRACE("INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n", (object) pCur.pgnoRoot, (object) nKey, (object) nData, (object) pPage.pgno, pRes == 0 ? (object) "overwrite" : (object) "new entry");
      Sqlite3.allocateTempSpace(pBt);
      byte[] pTmpSpace = pBt.pTmpSpace;
      int pRC = Sqlite3.fillInCell(pPage, pTmpSpace, pKey, nKey, pData, nData, nZero, ref pnSize);
      if (pRC == 0)
      {
        int num3 = (int) pCur.aiIdx[(int) pCur.iPage];
        if (pRes == 0)
        {
          pRC = Sqlite3.sqlite3PagerWrite(pPage.pDbPage);
          if (pRC == 0)
          {
            int cell = Sqlite3.findCell(pPage, num3);
            if (pPage.leaf == (byte) 0)
            {
              pTmpSpace[0] = pPage.aData[cell];
              pTmpSpace[1] = pPage.aData[cell + 1];
              pTmpSpace[2] = pPage.aData[cell + 2];
              pTmpSpace[3] = pPage.aData[cell + 3];
            }
            ushort sz = Sqlite3.cellSizePtr(pPage, cell);
            pRC = Sqlite3.clearCell(pPage, cell);
            Sqlite3.dropCell(pPage, num3, (int) sz, ref pRC);
            if (pRC != 0)
              goto label_19;
          }
          else
            goto label_19;
        }
        else if (pRes < 0 && pPage.nCell > (ushort) 0)
          num3 = (int) ++pCur.aiIdx[(int) pCur.iPage];
        Sqlite3.insertCell(pPage, num3, pTmpSpace, pnSize, (byte[]) null, 0U, ref pRC);
        pCur.info.nSize = (ushort) 0;
        pCur.validNKey = false;
        if (pRC == 0 && pPage.nOverflow != (byte) 0)
        {
          pRC = Sqlite3.balance(pCur);
          pCur.apPage[(int) pCur.iPage].nOverflow = (byte) 0;
          pCur.eState = 0;
        }
      }
label_19:
      return pRC;
    }

    private static int sqlite3BtreeDelete(Sqlite3.BtCursor pCur)
    {
      Sqlite3.Btree pBtree = pCur.pBtree;
      Sqlite3.BtShared pBt = pBtree.pBt;
      if (Sqlite3.NEVER((int) pCur.aiIdx[(int) pCur.iPage] >= (int) pCur.apPage[(int) pCur.iPage].nCell) || Sqlite3.NEVER(pCur.eState != 1))
        return 1;
      if (pCur.pKeyInfo == null)
        Sqlite3.invalidateIncrblobCursors(pBtree, pCur.info.nKey, 0);
      int iPage = (int) pCur.iPage;
      int num1 = (int) pCur.aiIdx[iPage];
      Sqlite3.MemPage pPage1 = pCur.apPage[iPage];
      int cell1 = Sqlite3.findCell(pPage1, num1);
      if (pPage1.leaf == (byte) 0)
      {
        int pRes = 0;
        int num2 = Sqlite3.sqlite3BtreePrevious(pCur, ref pRes);
        if (num2 != 0)
          return num2;
      }
      int num3 = Sqlite3.saveAllCursors(pBt, pCur.pgnoRoot, pCur);
      if (num3 != 0)
        return num3;
      int num4 = Sqlite3.sqlite3PagerWrite(pPage1.pDbPage);
      if (num4 != 0)
        return num4;
      int pRC1 = Sqlite3.clearCell(pPage1, cell1);
      Sqlite3.dropCell(pPage1, num1, (int) Sqlite3.cellSizePtr(pPage1, cell1), ref pRC1);
      if (pRC1 != 0)
        return pRC1;
      if (pPage1.leaf == (byte) 0)
      {
        Sqlite3.MemPage pPage2 = pCur.apPage[(int) pCur.iPage];
        uint pgno = pCur.apPage[iPage + 1].pgno;
        int cell2 = Sqlite3.findCell(pPage2, (int) pPage2.nCell - 1);
        int sz = (int) Sqlite3.cellSizePtr(pPage2, cell2);
        int pRC2 = Sqlite3.sqlite3PagerWrite(pPage2.pDbPage);
        byte[] numArray = Sqlite3.sqlite3Malloc(sz + 4);
        Buffer.BlockCopy((Array) pPage2.aData, cell2 - 4, (Array) numArray, 0, sz + 4);
        Sqlite3.insertCell(pPage1, num1, numArray, sz + 4, (byte[]) null, pgno, ref pRC2);
        Sqlite3.dropCell(pPage2, (int) pPage2.nCell - 1, sz, ref pRC2);
        if (pRC2 != 0)
          return pRC2;
      }
      int num5 = Sqlite3.balance(pCur);
      if (num5 == 0 && (int) pCur.iPage > iPage)
      {
        while ((int) pCur.iPage > iPage)
          Sqlite3.releasePage(pCur.apPage[(int) pCur.iPage--]);
        num5 = Sqlite3.balance(pCur);
      }
      if (num5 == 0)
        Sqlite3.moveToRoot(pCur);
      return num5;
    }

    private static int btreeCreateTable(Sqlite3.Btree p, ref int piTable, int createTabFlags)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.MemPage ppPage1 = new Sqlite3.MemPage();
      uint num = 0;
      if (pBt.autoVacuum)
      {
        uint pPgno1 = 0;
        Sqlite3.MemPage ppPage2 = new Sqlite3.MemPage();
        Sqlite3.invalidateAllOverflowCache(pBt);
        Sqlite3.sqlite3BtreeGetMeta(p, 4, ref num);
        ++num;
        while ((int) num == (int) Sqlite3.PTRMAP_PAGENO(pBt, num) || (int) num == (int) Sqlite3.PENDING_BYTE_PAGE(pBt))
          ++num;
        int pRC = Sqlite3.allocateBtreePage(pBt, ref ppPage2, ref pPgno1, num, (byte) 1);
        if (pRC != 0)
          return pRC;
        if ((int) pPgno1 != (int) num)
        {
          byte pEType = 0;
          uint pPgno2 = 0;
          Sqlite3.releasePage(ppPage2);
          int page1 = Sqlite3.btreeGetPage(pBt, num, ref ppPage1, 0);
          if (page1 != 0)
            return page1;
          int table1 = Sqlite3.ptrmapGet(pBt, num, ref pEType, ref pPgno2);
          if (pEType == (byte) 1 || pEType == (byte) 2)
            table1 = Sqlite3.SQLITE_CORRUPT_BKPT();
          if (table1 != 0)
          {
            Sqlite3.releasePage(ppPage1);
            return table1;
          }
          int table2 = Sqlite3.relocatePage(pBt, ppPage1, pEType, pPgno2, pPgno1, 0);
          Sqlite3.releasePage(ppPage1);
          if (table2 != 0)
            return table2;
          int page2 = Sqlite3.btreeGetPage(pBt, num, ref ppPage1, 0);
          if (page2 != 0)
            return page2;
          pRC = Sqlite3.sqlite3PagerWrite(ppPage1.pDbPage);
          if (pRC != 0)
          {
            Sqlite3.releasePage(ppPage1);
            return pRC;
          }
        }
        else
          ppPage1 = ppPage2;
        Sqlite3.ptrmapPut(pBt, num, (byte) 1, 0U, ref pRC);
        if (pRC != 0)
        {
          Sqlite3.releasePage(ppPage1);
          return pRC;
        }
        pRC = Sqlite3.sqlite3BtreeUpdateMeta(p, 4, num);
        if (Sqlite3.NEVER(pRC != 0))
        {
          Sqlite3.releasePage(ppPage1);
          return pRC;
        }
      }
      else
      {
        int table = Sqlite3.allocateBtreePage(pBt, ref ppPage1, ref num, 1U, (byte) 0);
        if (table != 0)
          return table;
      }
      int flags = (createTabFlags & 1) == 0 ? 10 : 13;
      Sqlite3.zeroPage(ppPage1, flags);
      Sqlite3.sqlite3PagerUnref(ppPage1.pDbPage);
      piTable = (int) num;
      return 0;
    }

    private static int sqlite3BtreeCreateTable(Sqlite3.Btree p, ref int piTable, int flags)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int table = Sqlite3.btreeCreateTable(p, ref piTable, flags);
      Sqlite3.sqlite3BtreeLeave(p);
      return table;
    }

    private static int clearDatabasePage(
      Sqlite3.BtShared pBt,
      uint pgno,
      int freePageFlag,
      ref int pnChange)
    {
      Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
      if (pgno > Sqlite3.btreePagecount(pBt))
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      int pRC = Sqlite3.getAndInitPage(pBt, pgno, ref ppPage);
      if (pRC != 0)
        return pRC;
      for (int iCell = 0; iCell < (int) ppPage.nCell; ++iCell)
      {
        int cell = Sqlite3.findCell(ppPage, iCell);
        byte[] aData = ppPage.aData;
        if (ppPage.leaf == (byte) 0)
        {
          pRC = Sqlite3.clearDatabasePage(pBt, Sqlite3.sqlite3Get4byte(aData, cell), 1, ref pnChange);
          if (pRC != 0)
            goto label_17;
        }
        pRC = Sqlite3.clearCell(ppPage, cell);
        if (pRC != 0)
          goto label_17;
      }
      if (ppPage.leaf == (byte) 0)
      {
        pRC = Sqlite3.clearDatabasePage(pBt, Sqlite3.sqlite3Get4byte(ppPage.aData, 8), 1, ref pnChange);
        if (pRC != 0)
          goto label_17;
      }
      else
        pnChange += (int) ppPage.nCell;
      if (freePageFlag != 0)
        Sqlite3.freePage(ppPage, ref pRC);
      else if ((pRC = Sqlite3.sqlite3PagerWrite(ppPage.pDbPage)) == 0)
        Sqlite3.zeroPage(ppPage, (int) ppPage.aData[0] | 8);
label_17:
      Sqlite3.releasePage(ppPage);
      return pRC;
    }

    private static int sqlite3BtreeClearTable(Sqlite3.Btree p, int iTable, ref int pnChange)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      Sqlite3.invalidateIncrblobCursors(p, 0L, 1);
      int num = Sqlite3.saveAllCursors(pBt, (uint) iTable, (Sqlite3.BtCursor) null);
      if (num == 0)
        num = Sqlite3.clearDatabasePage(pBt, (uint) iTable, 0, ref pnChange);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int btreeDropTable(Sqlite3.Btree p, uint iTable, ref int piMoved)
    {
      Sqlite3.MemPage ppPage1 = (Sqlite3.MemPage) null;
      Sqlite3.BtShared pBt = p.pBt;
      if (Sqlite3.NEVER<Sqlite3.BtCursor>(pBt.pCursor))
      {
        Sqlite3.sqlite3ConnectionBlocked(p.db, pBt.pCursor.pBtree.db);
        return 262;
      }
      int page1 = Sqlite3.btreeGetPage(pBt, iTable, ref ppPage1, 0);
      if (page1 != 0)
        return page1;
      int pnChange = 0;
      int pRC = Sqlite3.sqlite3BtreeClearTable(p, (int) iTable, ref pnChange);
      if (pRC != 0)
      {
        Sqlite3.releasePage(ppPage1);
        return pRC;
      }
      piMoved = 0;
      if (iTable > 1U)
      {
        if (pBt.autoVacuum)
        {
          uint pMeta = 0;
          Sqlite3.sqlite3BtreeGetMeta(p, 4, ref pMeta);
          if ((int) iTable == (int) pMeta)
          {
            Sqlite3.freePage(ppPage1, ref pRC);
            Sqlite3.releasePage(ppPage1);
            if (pRC != 0)
              return pRC;
          }
          else
          {
            Sqlite3.MemPage ppPage2 = new Sqlite3.MemPage();
            Sqlite3.releasePage(ppPage1);
            int page2 = Sqlite3.btreeGetPage(pBt, pMeta, ref ppPage2, 0);
            if (page2 != 0)
              return page2;
            int num = Sqlite3.relocatePage(pBt, ppPage2, (byte) 1, 0U, iTable, 0);
            Sqlite3.releasePage(ppPage2);
            if (num != 0)
              return num;
            Sqlite3.MemPage ppPage3 = (Sqlite3.MemPage) null;
            pRC = Sqlite3.btreeGetPage(pBt, pMeta, ref ppPage3, 0);
            Sqlite3.freePage(ppPage3, ref pRC);
            Sqlite3.releasePage(ppPage3);
            if (pRC != 0)
              return pRC;
            piMoved = (int) pMeta;
          }
          --pMeta;
          while ((int) pMeta == (int) Sqlite3.PENDING_BYTE_PAGE(pBt) || Sqlite3.PTRMAP_ISPAGE(pBt, pMeta))
            --pMeta;
          pRC = Sqlite3.sqlite3BtreeUpdateMeta(p, 4, pMeta);
        }
        else
        {
          Sqlite3.freePage(ppPage1, ref pRC);
          Sqlite3.releasePage(ppPage1);
        }
      }
      else
      {
        Sqlite3.zeroPage(ppPage1, 9);
        Sqlite3.releasePage(ppPage1);
      }
      return pRC;
    }

    private static int sqlite3BtreeDropTable(Sqlite3.Btree p, int iTable, ref int piMoved)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.btreeDropTable(p, (uint) iTable, ref piMoved);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static void sqlite3BtreeGetMeta(Sqlite3.Btree p, int idx, ref uint pMeta)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      pMeta = Sqlite3.sqlite3Get4byte(pBt.pPage1.aData, 36 + idx * 4);
      Sqlite3.sqlite3BtreeLeave(p);
    }

    private static int sqlite3BtreeUpdateMeta(Sqlite3.Btree p, int idx, uint iMeta)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      byte[] aData = pBt.pPage1.aData;
      int num = Sqlite3.sqlite3PagerWrite(pBt.pPage1.pDbPage);
      if (num == 0)
      {
        Sqlite3.sqlite3Put4byte(aData, 36 + idx * 4, (ulong) iMeta);
        if (idx == 7)
          pBt.incrVacuum = iMeta > 0U;
      }
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeCount(Sqlite3.BtCursor pCur, ref long pnEntry)
    {
      long num1 = 0;
      int num2;
      Sqlite3.MemPage pPage;
      int iCell;
      for (num2 = Sqlite3.moveToRoot(pCur); num2 == 0; num2 = iCell != (int) pPage.nCell ? Sqlite3.moveToChild(pCur, Sqlite3.sqlite3Get4byte(pPage.aData, Sqlite3.findCell(pPage, iCell))) : Sqlite3.moveToChild(pCur, Sqlite3.sqlite3Get4byte(pPage.aData, (int) pPage.hdrOffset + 8)))
      {
        pPage = pCur.apPage[(int) pCur.iPage];
        if (pPage.leaf != (byte) 0 || pPage.intKey == (byte) 0)
          num1 += (long) pPage.nCell;
        if (pPage.leaf != (byte) 0)
        {
          while (pCur.iPage != (short) 0)
          {
            Sqlite3.moveToParent(pCur);
            if ((int) pCur.aiIdx[(int) pCur.iPage] < (int) pCur.apPage[(int) pCur.iPage].nCell)
            {
              ++pCur.aiIdx[(int) pCur.iPage];
              pPage = pCur.apPage[(int) pCur.iPage];
              goto label_8;
            }
          }
          pnEntry = num1;
          return 0;
        }
label_8:
        iCell = (int) pCur.aiIdx[(int) pCur.iPage];
      }
      return num2;
    }

    private static Sqlite3.Pager sqlite3BtreePager(Sqlite3.Btree p) => p.pBt.pPager;

    private static void checkAppendMsg(
      Sqlite3.IntegrityCk pCheck,
      string zMsg1,
      string zFormat,
      params object[] ap)
    {
      if (pCheck.mxErr == 0)
        return;
      lock (Sqlite3.lock_va_list)
      {
        --pCheck.mxErr;
        ++pCheck.nErr;
        Sqlite3.va_start(ap, zFormat);
        if (pCheck.errMsg.zText.Length != 0)
          Sqlite3.sqlite3StrAccumAppend(pCheck.errMsg, "\n", 1);
        if (zMsg1.Length > 0)
          Sqlite3.sqlite3StrAccumAppend(pCheck.errMsg, zMsg1.ToString(), -1);
        Sqlite3.sqlite3VXPrintf(pCheck.errMsg, 1, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
    }

    private static void checkAppendMsg(
      Sqlite3.IntegrityCk pCheck,
      StringBuilder zMsg1,
      string zFormat,
      params object[] ap)
    {
      if (pCheck.mxErr == 0)
        return;
      lock (Sqlite3.lock_va_list)
      {
        --pCheck.mxErr;
        ++pCheck.nErr;
        Sqlite3.va_start(ap, zFormat);
        if (pCheck.errMsg.zText.Length != 0)
          Sqlite3.sqlite3StrAccumAppend(pCheck.errMsg, "\n", 1);
        if (zMsg1.Length > 0)
          Sqlite3.sqlite3StrAccumAppend(pCheck.errMsg, zMsg1.ToString(), -1);
        Sqlite3.sqlite3VXPrintf(pCheck.errMsg, 1, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
    }

    private static int checkRef(Sqlite3.IntegrityCk pCheck, uint iPage, string zContext)
    {
      if (iPage == 0U)
        return 1;
      if (iPage > pCheck.nPage)
      {
        Sqlite3.checkAppendMsg(pCheck, zContext, "invalid page number %d", (object) iPage);
        return 1;
      }
      if (pCheck.anRef[(int) iPage] == 1)
      {
        Sqlite3.checkAppendMsg(pCheck, zContext, "2nd reference to page %d", (object) iPage);
        return 1;
      }
      return pCheck.anRef[(int) iPage]++ <= 1 ? 0 : 1;
    }

    private static void checkPtrmap(
      Sqlite3.IntegrityCk pCheck,
      uint iChild,
      byte eType,
      uint iParent,
      string zContext)
    {
      byte pEType = 0;
      uint pPgno = 0;
      if (Sqlite3.ptrmapGet(pCheck.pBt, iChild, ref pEType, ref pPgno) != 0)
      {
        Sqlite3.checkAppendMsg(pCheck, zContext, "Failed to read ptrmap key=%d", (object) iChild);
      }
      else
      {
        if ((int) pEType == (int) eType && (int) pPgno == (int) iParent)
          return;
        Sqlite3.checkAppendMsg(pCheck, zContext, "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)", (object) iChild, (object) eType, (object) iParent, (object) pEType, (object) pPgno);
      }
    }

    private static void checkList(
      Sqlite3.IntegrityCk pCheck,
      int isFreeList,
      int iPage,
      int N,
      string zContext)
    {
      int num1 = N;
      int num2 = iPage;
      while (N-- > 0 && pCheck.mxErr != 0)
      {
        Sqlite3.PgHdr ppPage = new Sqlite3.PgHdr();
        if (iPage < 1)
        {
          Sqlite3.checkAppendMsg(pCheck, zContext, "%d of %d pages missing from overflow list starting at %d", (object) (N + 1), (object) num1, (object) num2);
          break;
        }
        if (Sqlite3.checkRef(pCheck, (uint) iPage, zContext) != 0)
          break;
        if (Sqlite3.sqlite3PagerGet(pCheck.pPager, (uint) iPage, ref ppPage) != 0)
        {
          Sqlite3.checkAppendMsg(pCheck, zContext, "failed to get page %d", (object) iPage);
          break;
        }
        byte[] data = Sqlite3.sqlite3PagerGetData(ppPage);
        if (isFreeList != 0)
        {
          int num3 = (int) Sqlite3.sqlite3Get4byte(data, 4);
          if (pCheck.pBt.autoVacuum)
            Sqlite3.checkPtrmap(pCheck, (uint) iPage, (byte) 2, 0U, zContext);
          if (num3 > (int) pCheck.pBt.usableSize / 4 - 2)
          {
            Sqlite3.checkAppendMsg(pCheck, zContext, "freelist leaf count too big on page %d", (object) iPage);
            --N;
          }
          else
          {
            for (int index = 0; index < num3; ++index)
            {
              uint num4 = Sqlite3.sqlite3Get4byte(data, 8 + index * 4);
              if (pCheck.pBt.autoVacuum)
                Sqlite3.checkPtrmap(pCheck, num4, (byte) 2, 0U, zContext);
              Sqlite3.checkRef(pCheck, num4, zContext);
            }
            N -= num3;
          }
        }
        else if (pCheck.pBt.autoVacuum && N > 0)
        {
          int iChild = (int) Sqlite3.sqlite3Get4byte(data);
          Sqlite3.checkPtrmap(pCheck, (uint) iChild, (byte) 4, (uint) iPage, zContext);
        }
        iPage = (int) Sqlite3.sqlite3Get4byte(data);
        Sqlite3.sqlite3PagerUnref(ppPage);
      }
    }

    private static int checkTreePage(
      Sqlite3.IntegrityCk pCheck,
      int iPage,
      string zParentContext,
      ref long pnParentMinKey,
      ref long pnParentMaxKey,
      object _pnParentMinKey,
      object _pnParentMaxKey)
    {
      Sqlite3.MemPage ppPage = new Sqlite3.MemPage();
      StringBuilder stringBuilder = new StringBuilder(100);
      long pnParentMinKey1 = 0;
      long pnParentMaxKey1 = 0;
      Sqlite3.sqlite3_snprintf(200, stringBuilder, "Page %d: ", (object) iPage);
      Sqlite3.BtShared pBt = pCheck.pBt;
      int usableSize = (int) pBt.usableSize;
      if (iPage == 0 || Sqlite3.checkRef(pCheck, (uint) iPage, zParentContext) != 0)
        return 0;
      int page;
      if ((page = Sqlite3.btreeGetPage(pBt, (uint) iPage, ref ppPage, 0)) != 0)
      {
        Sqlite3.checkAppendMsg(pCheck, stringBuilder.ToString(), "unable to get the page. error code=%d", (object) page);
        return 0;
      }
      ppPage.isInit = (byte) 0;
      int num1;
      if ((num1 = Sqlite3.btreeInitPage(ppPage)) != 0)
      {
        Sqlite3.checkAppendMsg(pCheck, stringBuilder.ToString(), "btreeInitPage() returns error code %d", (object) num1);
        Sqlite3.releasePage(ppPage);
        return 0;
      }
      int num2 = 0;
      for (int iCell = 0; iCell < (int) ppPage.nCell && pCheck.mxErr != 0; ++iCell)
      {
        Sqlite3.CellInfo pInfo = new Sqlite3.CellInfo();
        Sqlite3.sqlite3_snprintf(200, stringBuilder, "On tree page %d cell %d: ", (object) iPage, (object) iCell);
        int cell = Sqlite3.findCell(ppPage, iCell);
        byte[] aData = ppPage.aData;
        Sqlite3.btreeParseCellPtr(ppPage, cell, ref pInfo);
        uint nData = pInfo.nData;
        if (ppPage.intKey == (byte) 0)
          nData += (uint) pInfo.nKey;
        else if (iCell == 0)
        {
          pnParentMinKey1 = pnParentMaxKey1 = pInfo.nKey;
        }
        else
        {
          if (pInfo.nKey <= pnParentMaxKey1)
            Sqlite3.checkAppendMsg(pCheck, stringBuilder.ToString(), "Rowid %lld out of order (previous was %lld)", (object) pInfo.nKey, (object) pnParentMaxKey1);
          pnParentMaxKey1 = pInfo.nKey;
        }
        if (nData > (uint) pInfo.nLocal)
        {
          int N = (int) ((long) (nData - (uint) pInfo.nLocal) + (long) usableSize - 5L) / (usableSize - 4);
          uint num3 = Sqlite3.sqlite3Get4byte(aData, cell, (int) pInfo.iOverflow);
          if (pBt.autoVacuum)
            Sqlite3.checkPtrmap(pCheck, num3, (byte) 3, (uint) iPage, stringBuilder.ToString());
          Sqlite3.checkList(pCheck, 0, (int) num3, N, stringBuilder.ToString());
        }
        if (ppPage.leaf == (byte) 0)
        {
          int num4 = (int) Sqlite3.sqlite3Get4byte(aData, cell);
          if (pBt.autoVacuum)
            Sqlite3.checkPtrmap(pCheck, (uint) num4, (byte) 5, (uint) iPage, stringBuilder.ToString());
          int num5 = iCell != 0 ? Sqlite3.checkTreePage(pCheck, num4, stringBuilder.ToString(), ref pnParentMinKey1, ref pnParentMaxKey1, (object) pCheck, (object) pCheck) : Sqlite3.checkTreePage(pCheck, num4, stringBuilder.ToString(), ref pnParentMinKey1, ref Sqlite3.refNULL, (object) pCheck, (object) null);
          if (iCell > 0 && num5 != num2)
            Sqlite3.checkAppendMsg(pCheck, stringBuilder, "Child page depth differs");
          num2 = num5;
        }
      }
      if (ppPage.leaf == (byte) 0)
      {
        int num6 = (int) Sqlite3.sqlite3Get4byte(ppPage.aData, (int) ppPage.hdrOffset + 8);
        Sqlite3.sqlite3_snprintf(200, stringBuilder, "On page %d at right child: ", (object) iPage);
        if (pBt.autoVacuum)
          Sqlite3.checkPtrmap(pCheck, (uint) num6, (byte) 5, (uint) iPage, stringBuilder.ToString());
        if (ppPage.nCell == (ushort) 0)
          Sqlite3.checkTreePage(pCheck, num6, stringBuilder.ToString(), ref Sqlite3.refNULL, ref Sqlite3.refNULL, (object) null, (object) null);
        else
          Sqlite3.checkTreePage(pCheck, num6, stringBuilder.ToString(), ref Sqlite3.refNULL, ref pnParentMaxKey1, (object) null, (object) pCheck);
      }
      if (ppPage.leaf != (byte) 0 && ppPage.intKey != (byte) 0)
      {
        if (_pnParentMinKey != null)
        {
          if (_pnParentMaxKey == null)
          {
            if (pnParentMaxKey1 > pnParentMinKey)
              Sqlite3.checkAppendMsg(pCheck, stringBuilder, "Rowid %lld out of order (max larger than parent min of %lld)", (object) pnParentMaxKey1, (object) pnParentMinKey);
          }
          else
          {
            if (pnParentMinKey1 <= pnParentMinKey)
              Sqlite3.checkAppendMsg(pCheck, stringBuilder, "Rowid %lld out of order (min less than parent min of %lld)", (object) pnParentMinKey1, (object) pnParentMinKey);
            if (pnParentMaxKey1 > pnParentMaxKey)
              Sqlite3.checkAppendMsg(pCheck, stringBuilder, "Rowid %lld out of order (max larger than parent max of %lld)", (object) pnParentMaxKey1, (object) pnParentMaxKey);
            pnParentMinKey = pnParentMaxKey1;
          }
        }
        else if (_pnParentMaxKey != null && pnParentMinKey1 <= pnParentMaxKey)
          Sqlite3.checkAppendMsg(pCheck, stringBuilder, "Rowid %lld out of order (min less than parent max of %lld)", (object) pnParentMinKey1, (object) pnParentMaxKey);
      }
      byte[] aData1 = ppPage.aData;
      int hdrOffset = (int) ppPage.hdrOffset;
      byte[] p = Sqlite3.sqlite3Malloc(pBt.pageSize);
      int index1 = Sqlite3.get2byteNotZero(aData1, hdrOffset + 5);
      Array.Clear((Array) p, index1, usableSize - index1);
      for (int index2 = index1 - 1; index2 >= 0; --index2)
        p[index2] = (byte) 1;
      int num7 = Sqlite3.get2byte(aData1, hdrOffset + 3);
      int num8 = hdrOffset + 12 - 4 * (int) ppPage.leaf;
      for (int index3 = 0; index3 < num7; ++index3)
      {
        int offset = Sqlite3.get2byte(aData1, num8 + index3 * 2);
        uint num9 = 65536;
        if (offset <= usableSize - 4)
          num9 = (uint) Sqlite3.cellSizePtr(ppPage, aData1, offset);
        if ((int) ((long) offset + (long) num9 - 1L) >= usableSize)
        {
          Sqlite3.checkAppendMsg(pCheck, "", "Corruption detected in cell %d on page %d", (object) index3, (object) iPage);
        }
        else
        {
          for (int index4 = (int) ((long) offset + (long) num9 - 1L); index4 >= offset; --index4)
            ++p[index4];
        }
      }
      for (int offset = Sqlite3.get2byte(aData1, hdrOffset + 1); offset > 0; offset = Sqlite3.get2byte(aData1, offset))
      {
        int num10 = Sqlite3.get2byte(aData1, offset + 2);
        for (int index5 = offset + num10 - 1; index5 >= offset; --index5)
          ++p[index5];
      }
      int num11;
      for (int index6 = num11 = 0; index6 < usableSize; ++index6)
      {
        if (p[index6] == (byte) 0)
          ++num11;
        else if (p[index6] > (byte) 1)
        {
          Sqlite3.checkAppendMsg(pCheck, "", "Multiple uses for byte %d of page %d", (object) index6, (object) iPage);
          break;
        }
      }
      if (num11 != (int) aData1[hdrOffset + 7])
        Sqlite3.checkAppendMsg(pCheck, "", "Fragmentation of %d bytes reported as %d on page %d", (object) num11, (object) aData1[hdrOffset + 7], (object) iPage);
      Sqlite3.sqlite3PageFree(ref p);
      Sqlite3.releasePage(ppPage);
      return num2 + 1;
    }

    private static string sqlite3BtreeIntegrityCheck(
      Sqlite3.Btree p,
      int[] aRoot,
      int nRoot,
      int mxErr,
      ref int pnErr)
    {
      Sqlite3.IntegrityCk pCheck = new Sqlite3.IntegrityCk();
      Sqlite3.BtShared pBt = p.pBt;
      StringBuilder stringBuilder = new StringBuilder(100);
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.sqlite3PagerRefcount(pBt.pPager);
      pCheck.pBt = pBt;
      pCheck.pPager = pBt.pPager;
      pCheck.nPage = Sqlite3.btreePagecount(pCheck.pBt);
      pCheck.mxErr = mxErr;
      pCheck.nErr = 0;
      pnErr = 0;
      if (pCheck.nPage == 0U)
      {
        Sqlite3.sqlite3BtreeLeave(p);
        return "";
      }
      pCheck.anRef = Sqlite3.sqlite3Malloc(pCheck.anRef, (int) pCheck.nPage + 1);
      uint index1 = Sqlite3.PENDING_BYTE_PAGE(pBt);
      if (index1 <= pCheck.nPage)
        pCheck.anRef[(int) index1] = 1;
      Sqlite3.sqlite3StrAccumInit(pCheck.errMsg, (StringBuilder) null, 1000, 20000);
      Sqlite3.checkList(pCheck, 1, (int) Sqlite3.sqlite3Get4byte(pBt.pPage1.aData, 32), (int) Sqlite3.sqlite3Get4byte(pBt.pPage1.aData, 36), "Main freelist: ");
      for (uint index2 = 0; (int) index2 < nRoot && pCheck.mxErr != 0; ++index2)
      {
        if (aRoot[(int) index2] != 0)
        {
          if (pBt.autoVacuum && aRoot[(int) index2] > 1)
            Sqlite3.checkPtrmap(pCheck, (uint) aRoot[(int) index2], (byte) 1, 0U, "");
          Sqlite3.checkTreePage(pCheck, aRoot[(int) index2], "List of tree roots: ", ref Sqlite3.refNULL, ref Sqlite3.refNULL, (object) null, (object) null);
        }
      }
      for (uint pgno = 1; pgno <= pCheck.nPage && pCheck.mxErr != 0; ++pgno)
      {
        if (pCheck.anRef[(int) pgno] == 0 && ((int) Sqlite3.PTRMAP_PAGENO(pBt, pgno) != (int) pgno || !pBt.autoVacuum))
          Sqlite3.checkAppendMsg(pCheck, "", "Page %d is never used", (object) pgno);
        if (pCheck.anRef[(int) pgno] != 0 && (int) Sqlite3.PTRMAP_PAGENO(pBt, pgno) == (int) pgno && pBt.autoVacuum)
          Sqlite3.checkAppendMsg(pCheck, "", "Pointer map page %d is referenced", (object) pgno);
      }
      if (Sqlite3.NEVER(num != Sqlite3.sqlite3PagerRefcount(pBt.pPager)))
        Sqlite3.checkAppendMsg(pCheck, "", "Outstanding page count goes from %d to %d during this analysis", (object) num, (object) Sqlite3.sqlite3PagerRefcount(pBt.pPager));
      Sqlite3.sqlite3BtreeLeave(p);
      pCheck.anRef = (int[]) null;
      pnErr = pCheck.nErr;
      if (pCheck.nErr == 0)
        Sqlite3.sqlite3StrAccumReset(pCheck.errMsg);
      return Sqlite3.sqlite3StrAccumFinish(pCheck.errMsg);
    }

    private static string sqlite3BtreeGetFilename(Sqlite3.Btree p) => Sqlite3.sqlite3PagerFilename(p.pBt.pPager);

    private static string sqlite3BtreeGetJournalname(Sqlite3.Btree p) => Sqlite3.sqlite3PagerJournalname(p.pBt.pPager);

    private static bool sqlite3BtreeIsInTrans(Sqlite3.Btree p) => p != null && p.inTrans == (byte) 2;

    private static bool sqlite3BtreeIsInReadTrans(Sqlite3.Btree p) => p.inTrans > (byte) 0;

    private static bool sqlite3BtreeIsInBackup(Sqlite3.Btree p) => p.nBackup != 0;

    private static Sqlite3.Schema sqlite3BtreeSchema(
      Sqlite3.Btree p,
      int nBytes,
      Sqlite3.dxFreeSchema xFree)
    {
      Sqlite3.BtShared pBt = p.pBt;
      Sqlite3.sqlite3BtreeEnter(p);
      if (pBt.pSchema == null && nBytes != 0)
      {
        pBt.pSchema = new Sqlite3.Schema();
        pBt.xFreeSchema = xFree;
      }
      Sqlite3.sqlite3BtreeLeave(p);
      return pBt.pSchema;
    }

    private static int sqlite3BtreeSchemaLocked(Sqlite3.Btree p)
    {
      Sqlite3.sqlite3BtreeEnter(p);
      int num = Sqlite3.querySharedCacheTableLock(p, 1U, (byte) 1);
      Sqlite3.sqlite3BtreeLeave(p);
      return num;
    }

    private static int sqlite3BtreeSetVersion(Sqlite3.Btree pBtree, int iVersion)
    {
      Sqlite3.BtShared pBt = pBtree.pBt;
      pBt.doNotUseWAL = iVersion == 1;
      int num = Sqlite3.sqlite3BtreeBeginTrans(pBtree, 0);
      if (num == 0)
      {
        byte[] aData = pBt.pPage1.aData;
        if ((int) aData[18] != (int) (byte) iVersion || (int) aData[19] != (int) (byte) iVersion)
        {
          num = Sqlite3.sqlite3BtreeBeginTrans(pBtree, 2);
          if (num == 0)
          {
            num = Sqlite3.sqlite3PagerWrite(pBt.pPage1.pDbPage);
            if (num == 0)
            {
              aData[18] = (byte) iVersion;
              aData[19] = (byte) iVersion;
            }
          }
        }
      }
      pBt.doNotUseWAL = false;
      return num;
    }

    private static void sqlite3BtreeEnter(Sqlite3.Btree bt)
    {
    }

    private static void sqlite3BtreeEnterAll(Sqlite3.sqlite3 p)
    {
    }

    private static bool sqlite3BtreeSharable(Sqlite3.Btree X) => false;

    private static void sqlite3BtreeLeave(Sqlite3.Btree X)
    {
    }

    private static void sqlite3BtreeEnterCursor(Sqlite3.BtCursor X)
    {
    }

    private static void sqlite3BtreeLeaveCursor(Sqlite3.BtCursor X)
    {
    }

    private static void sqlite3BtreeLeaveAll(Sqlite3.sqlite3 X)
    {
    }

    private static bool sqlite3BtreeHoldsMutex(Sqlite3.Btree X) => true;

    private static bool sqlite3BtreeHoldsAllMutexes(Sqlite3.sqlite3 X) => true;

    private static bool sqlite3SchemaMutexHeld(Sqlite3.sqlite3 X, int y, Sqlite3.Schema z) => true;

    private static void sqlite3BeginParse(Sqlite3.Parse pParse, int explainFlag)
    {
      pParse.explain = (byte) explainFlag;
      pParse.nVar = 0;
    }

    private static void codeTableLocks(Sqlite3.Parse pParse)
    {
    }

    private static void sqlite3FinishCoding(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.nested != (byte) 0 || pParse.nErr != 0)
        return;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe != null)
      {
        Sqlite3.sqlite3VdbeAddOp0(vdbe, 6);
        if (pParse.cookieGoto > 0)
        {
          Sqlite3.sqlite3VdbeJumpHere(vdbe, pParse.cookieGoto - 1);
          int index = 0;
          uint num = 1;
          for (; index < db.nDb; ++index)
          {
            if (((long) num & (long) pParse.cookieMask) != 0L)
            {
              Sqlite3.sqlite3VdbeUsesBtree(vdbe, index);
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 34, index, ((ulong) num & (ulong) pParse.writeMask) > 0UL);
              if (db.init.busy == (byte) 0)
                Sqlite3.sqlite3VdbeAddOp3(vdbe, 37, index, pParse.cookieValue[index], (int) db.aDb[index].pSchema.iGeneration);
            }
            num <<= 1;
          }
          Sqlite3.codeTableLocks(pParse);
          Sqlite3.sqlite3AutoincrementBegin(pParse);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, pParse.cookieGoto);
        }
      }
      if (vdbe != null && Sqlite3.ALWAYS(pParse.nErr == 0))
      {
        if (pParse.pAinc != null && pParse.nTab == 0)
          pParse.nTab = 1;
        Sqlite3.sqlite3VdbeMakeReady(vdbe, pParse);
        pParse.rc = 101;
        pParse.colNamesSet = (byte) 0;
      }
      else
        pParse.rc = 1;
      pParse.nTab = 0;
      pParse.nMem = 0;
      pParse.nSet = 0;
      pParse.nVar = 0;
      pParse.cookieMask = 0;
      pParse.cookieGoto = 0;
    }

    private static void sqlite3NestedParse(
      Sqlite3.Parse pParse,
      string zFormat,
      params object[] ap)
    {
      string str = "";
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.nErr != 0)
        return;
      string pString;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        pString = Sqlite3.sqlite3VMPrintf(db, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
      lock (Sqlite3.nestingLock)
      {
        ++pParse.nested;
        pParse.SaveMembers();
        pParse.ResetMembers();
        Sqlite3.sqlite3RunParser(pParse, pString, ref str);
        Sqlite3.sqlite3DbFree(db, ref str);
        Sqlite3.sqlite3DbFree(db, ref pString);
        pParse.RestoreMembers();
        --pParse.nested;
      }
    }

    private static Sqlite3.Table sqlite3FindTable(
      Sqlite3.sqlite3 db,
      string zName,
      string zDatabase)
    {
      Sqlite3.Table table = (Sqlite3.Table) null;
      int nKey = Sqlite3.sqlite3Strlen30(zName);
      for (int omitTempdb = Sqlite3.OMIT_TEMPDB; omitTempdb < db.nDb; ++omitTempdb)
      {
        int index = omitTempdb < 2 ? omitTempdb ^ 1 : omitTempdb;
        if (zDatabase == null || zDatabase.Equals(db.aDb[index].zName, StringComparison.InvariantCultureIgnoreCase))
        {
          table = Sqlite3.sqlite3HashFind<Sqlite3.Table>(db.aDb[index].pSchema.tblHash, zName, nKey, (Sqlite3.Table) null);
          if (table != null)
            break;
        }
      }
      return table;
    }

    private static Sqlite3.Table sqlite3LocateTable(
      Sqlite3.Parse pParse,
      int isView,
      string zName,
      string zDbase)
    {
      if (Sqlite3.sqlite3ReadSchema(pParse) != 0)
        return (Sqlite3.Table) null;
      Sqlite3.Table table = Sqlite3.sqlite3FindTable(pParse.db, zName, zDbase);
      if (table == null)
      {
        string str = isView != 0 ? "no such view" : "no such table";
        if (zDbase != null)
          Sqlite3.sqlite3ErrorMsg(pParse, "%s: %s.%s", (object) str, (object) zDbase, (object) zName);
        else
          Sqlite3.sqlite3ErrorMsg(pParse, "%s: %s", (object) str, (object) zName);
        pParse.checkSchema = (byte) 1;
      }
      return table;
    }

    private static Sqlite3.Index sqlite3FindIndex(
      Sqlite3.sqlite3 db,
      string zName,
      string zDb)
    {
      Sqlite3.Index index1 = (Sqlite3.Index) null;
      int nKey = Sqlite3.sqlite3Strlen30(zName);
      for (int omitTempdb = Sqlite3.OMIT_TEMPDB; omitTempdb < db.nDb; ++omitTempdb)
      {
        int index2 = omitTempdb < 2 ? omitTempdb ^ 1 : omitTempdb;
        Sqlite3.Schema pSchema = db.aDb[index2].pSchema;
        if (zDb == null || zDb.Equals(db.aDb[index2].zName, StringComparison.InvariantCultureIgnoreCase))
        {
          index1 = Sqlite3.sqlite3HashFind<Sqlite3.Index>(pSchema.idxHash, zName, nKey, (Sqlite3.Index) null);
          if (index1 != null)
            break;
        }
      }
      return index1;
    }

    private static void freeIndex(Sqlite3.sqlite3 db, ref Sqlite3.Index p)
    {
      Sqlite3.sqlite3DeleteIndexSamples(db, p);
      Sqlite3.sqlite3DbFree(db, ref p.zColAff);
      Sqlite3.sqlite3DbFree<Sqlite3.Index>(db, ref p);
    }

    private static void sqlite3UnlinkAndDeleteIndex(Sqlite3.sqlite3 db, int iDb, string zIdxName)
    {
      Sqlite3.Hash idxHash = db.aDb[iDb].pSchema.idxHash;
      int nKey = Sqlite3.sqlite3Strlen30(zIdxName);
      Sqlite3.Index p = Sqlite3.sqlite3HashInsert<Sqlite3.Index>(ref idxHash, zIdxName, nKey, (Sqlite3.Index) null);
      if (Sqlite3.ALWAYS<Sqlite3.Index>(p))
      {
        if (p.pTable.pIndex == p)
        {
          p.pTable.pIndex = p.pNext;
        }
        else
        {
          Sqlite3.Index index = p.pTable.pIndex;
          while (Sqlite3.ALWAYS(index != null) && index.pNext != p)
            index = index.pNext;
          if (Sqlite3.ALWAYS(index != null && index.pNext == p))
            index.pNext = p.pNext;
        }
        Sqlite3.freeIndex(db, ref p);
      }
      db.flags |= 512;
    }

    private static void sqlite3ResetInternalSchema(Sqlite3.sqlite3 db, int iDb)
    {
      if (iDb >= 0)
      {
        Sqlite3.sqlite3SchemaClear(db.aDb[iDb].pSchema);
        if (iDb == 1)
          return;
        Sqlite3.sqlite3SchemaClear(db.aDb[1].pSchema);
      }
      else
      {
        Sqlite3.sqlite3BtreeEnterAll(db);
        for (int index = 0; index < db.nDb; ++index)
        {
          Sqlite3.Db db1 = db.aDb[index];
          if (db1.pSchema != null)
            Sqlite3.sqlite3SchemaClear(db1.pSchema);
        }
        db.flags &= -513;
        Sqlite3.sqlite3VtabUnlockList(db);
        Sqlite3.sqlite3BtreeLeaveAll(db);
        int index1;
        for (int index2 = index1 = 2; index2 < db.nDb; ++index2)
        {
          Sqlite3.Db db2 = db.aDb[index2];
          if (db2.pBt == null)
          {
            Sqlite3.sqlite3DbFree(db, ref db2.zName);
          }
          else
          {
            if (index1 < index2)
              db.aDb[index1] = db.aDb[index2];
            ++index1;
          }
        }
        if (db.nDb != index1)
          db.aDb[index1] = new Sqlite3.Db();
        db.nDb = index1;
        if (db.nDb > 2 || db.aDb == db.aDbStatic)
          return;
        Array.Copy((Array) db.aDb, (Array) db.aDbStatic, 2);
      }
    }

    private static void sqlite3CommitInternalChanges(Sqlite3.sqlite3 db) => db.flags &= -513;

    private static void sqliteDeleteColumnNames(Sqlite3.sqlite3 db, Sqlite3.Table pTable)
    {
      for (int index = 0; index < pTable.nCol; ++index)
      {
        Sqlite3.Column column = pTable.aCol[index];
        if (column != null)
        {
          Sqlite3.sqlite3DbFree(db, ref column.zName);
          Sqlite3.sqlite3ExprDelete(db, ref column.pDflt);
          Sqlite3.sqlite3DbFree(db, ref column.zDflt);
          Sqlite3.sqlite3DbFree(db, ref column.zType);
          Sqlite3.sqlite3DbFree(db, ref column.zColl);
        }
      }
    }

    private static void sqlite3DeleteTable(Sqlite3.sqlite3 db, ref Sqlite3.Table pTable)
    {
      if (pTable == null || --pTable.nRef > (ushort) 0)
        return;
      Sqlite3.Index pNext;
      for (Sqlite3.Index p = pTable.pIndex; p != null; p = pNext)
      {
        pNext = p.pNext;
        string zName = p.zName;
        Sqlite3.sqlite3HashInsert<Sqlite3.Index>(ref p.pSchema.idxHash, zName, Sqlite3.sqlite3Strlen30(zName), (Sqlite3.Index) null);
        Sqlite3.freeIndex(db, ref p);
      }
      Sqlite3.sqlite3FkDelete(db, pTable);
      Sqlite3.sqliteDeleteColumnNames(db, pTable);
      Sqlite3.sqlite3DbFree(db, ref pTable.zName);
      Sqlite3.sqlite3DbFree(db, ref pTable.zColAff);
      Sqlite3.sqlite3SelectDelete(db, ref pTable.pSelect);
      Sqlite3.sqlite3ExprDelete(db, ref pTable.pCheck);
      pTable = (Sqlite3.Table) null;
    }

    private static void sqlite3UnlinkAndDeleteTable(Sqlite3.sqlite3 db, int iDb, string zTabName)
    {
      Sqlite3.testcase<bool>(zTabName.Length == 0);
      Sqlite3.Table pTable = Sqlite3.sqlite3HashInsert<Sqlite3.Table>(ref db.aDb[iDb].pSchema.tblHash, zTabName, Sqlite3.sqlite3Strlen30(zTabName), (Sqlite3.Table) null);
      Sqlite3.sqlite3DeleteTable(db, ref pTable);
      db.flags |= 512;
    }

    private static string sqlite3NameFromToken(Sqlite3.sqlite3 db, Sqlite3.Token pName)
    {
      if (pName == null || pName.z == null)
        return (string) null;
      string z = pName.z.Substring(0, pName.n);
      Sqlite3.sqlite3Dequote(ref z);
      return z;
    }

    private static void sqlite3OpenMasterTable(Sqlite3.Parse p, int iDb)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(p);
      Sqlite3.sqlite3TableLock(p, iDb, 1, (byte) 1, Sqlite3.SCHEMA_TABLE(iDb));
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 39, 0, 1, iDb);
      Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, 5, -14);
      if (p.nTab != 0)
        return;
      p.nTab = 1;
    }

    private static int sqlite3FindDbName(Sqlite3.sqlite3 db, string zName)
    {
      int dbName = -1;
      if (zName != null)
      {
        int num = Sqlite3.sqlite3Strlen30(zName);
        for (dbName = db.nDb - 1; dbName >= 0; --dbName)
        {
          Sqlite3.Db db1 = db.aDb[dbName];
          if ((Sqlite3.OMIT_TEMPDB == 0 || dbName != 1) && num == Sqlite3.sqlite3Strlen30(db1.zName) && db1.zName.Equals(zName, StringComparison.InvariantCultureIgnoreCase))
            break;
        }
      }
      return dbName;
    }

    private static int sqlite3FindDb(Sqlite3.sqlite3 db, Sqlite3.Token pName)
    {
      string pString = Sqlite3.sqlite3NameFromToken(db, pName);
      int dbName = Sqlite3.sqlite3FindDbName(db, pString);
      Sqlite3.sqlite3DbFree(db, ref pString);
      return dbName;
    }

    private static int sqlite3TwoPartName(
      Sqlite3.Parse pParse,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2,
      ref Sqlite3.Token pUnqual)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int num;
      if (Sqlite3.ALWAYS(pName2 != null) && pName2.n > 0)
      {
        if (db.init.busy != (byte) 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "corrupt database");
          ++pParse.nErr;
          return -1;
        }
        pUnqual = pName2;
        num = Sqlite3.sqlite3FindDb(db, pName1);
        if (num < 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "unknown database %T", (object) pName1);
          ++pParse.nErr;
          return -1;
        }
      }
      else
      {
        num = db.init.iDb;
        pUnqual = pName1;
      }
      return num;
    }

    private static int sqlite3CheckObjectName(Sqlite3.Parse pParse, string zName)
    {
      if (pParse.db.init.busy != (byte) 0 || pParse.nested != (byte) 0 || (pParse.db.flags & 65536) != 0 || !zName.StartsWith("sqlite_", StringComparison.InvariantCultureIgnoreCase))
        return 0;
      Sqlite3.sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", (object) zName);
      return 1;
    }

    private static void sqlite3StartTable(
      Sqlite3.Parse pParse,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2,
      int isTemp,
      int isView,
      int isVirtual,
      int noErr)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Token pUnqual = new Sqlite3.Token();
      int index = Sqlite3.sqlite3TwoPartName(pParse, pName1, pName2, ref pUnqual);
      if (index < 0)
        return;
      if (Sqlite3.OMIT_TEMPDB == 0 && isTemp != 0 && pName2.n > 0 && index != 1)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
      }
      else
      {
        if (Sqlite3.OMIT_TEMPDB == 0 && isTemp != 0)
          index = 1;
        pParse.sNameToken = pUnqual;
        string pString = Sqlite3.sqlite3NameFromToken(db, pUnqual);
        if (pString == null)
          return;
        if (Sqlite3.sqlite3CheckObjectName(pParse, pString) == 0)
        {
          if (db.init.iDb == 1)
            isTemp = 1;
          if (!Sqlite3.IN_DECLARE_VTAB(pParse))
          {
            string zName = db.aDb[index].zName;
            if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
            {
              if (Sqlite3.sqlite3FindTable(db, pString, zName) != null)
              {
                if (noErr == 0)
                {
                  Sqlite3.sqlite3ErrorMsg(pParse, "table %T already exists", (object) pUnqual);
                  goto label_28;
                }
                else
                {
                  Sqlite3.sqlite3CodeVerifySchema(pParse, index);
                  goto label_28;
                }
              }
              else if (Sqlite3.sqlite3FindIndex(db, pString, zName) != null)
              {
                Sqlite3.sqlite3ErrorMsg(pParse, "there is already an index named %s", (object) pString);
                goto label_28;
              }
            }
            else
              goto label_28;
          }
          Sqlite3.Table table = new Sqlite3.Table();
          table.zName = pString;
          table.iPKey = -1;
          table.pSchema = db.aDb[index].pSchema;
          table.nRef = (ushort) 1;
          table.nRowEst = 1000000U;
          pParse.pNewTable = table;
          if (pParse.nested == (byte) 0 && pString == "sqlite_sequence")
            table.pSchema.pSeqTab = table;
          Sqlite3.Vdbe vdbe;
          if (db.init.busy != (byte) 0 || (vdbe = Sqlite3.sqlite3GetVdbe(pParse)) == null)
            return;
          Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index);
          if (isVirtual != 0)
            Sqlite3.sqlite3VdbeAddOp0(vdbe, 124);
          Sqlite3.Parse parse1 = pParse;
          int num1 = ++pParse.nMem;
          int num2;
          int num3 = num2 = num1;
          parse1.regRowid = num2;
          int num4 = num3;
          Sqlite3.Parse parse2 = pParse;
          int num5 = ++pParse.nMem;
          int num6;
          int num7 = num6 = num5;
          parse2.regRoot = num6;
          int p2 = num7;
          int num8 = ++pParse.nMem;
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 35, index, num8, 2);
          Sqlite3.sqlite3VdbeUsesBtree(vdbe, index);
          int addr = Sqlite3.sqlite3VdbeAddOp1(vdbe, 26, num8);
          int p1 = (db.flags & 1048576) != 0 ? 1 : Sqlite3.SQLITE_MAX_FILE_FORMAT;
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, p1, num8);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 36, index, 2, num8);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, (int) Sqlite3.ENC(db), num8);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 36, index, 5, num8);
          Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
          if (isView != 0 || isVirtual != 0)
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, p2);
          else
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 98, index, p2);
          Sqlite3.sqlite3OpenMasterTable(pParse, index);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 54, 0, num4);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num8);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, 0, num8, num4);
          Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 8);
          Sqlite3.sqlite3VdbeAddOp0(vdbe, 43);
          return;
        }
label_28:
        Sqlite3.sqlite3DbFree(db, ref pString);
      }
    }

    private static void sqlite3AddColumn(Sqlite3.Parse pParse, Sqlite3.Token pName)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Table pNewTable;
      if ((pNewTable = pParse.pNewTable) == null)
        return;
      if (pNewTable.nCol + 1 > db.aLimit[2])
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "too many columns on %s", (object) pNewTable.zName);
      }
      else
      {
        string pString = Sqlite3.sqlite3NameFromToken(db, pName);
        if (pString == null)
          return;
        for (int index = 0; index < pNewTable.nCol; ++index)
        {
          if (pString.Equals(pNewTable.aCol[index].zName, StringComparison.InvariantCultureIgnoreCase))
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "duplicate column name: %s", (object) pString);
            Sqlite3.sqlite3DbFree(db, ref pString);
            return;
          }
        }
        if ((pNewTable.nCol & 7) == 0)
          Array.Resize<Sqlite3.Column>(ref pNewTable.aCol, pNewTable.nCol + 8);
        pNewTable.aCol[pNewTable.nCol] = new Sqlite3.Column();
        Sqlite3.Column column = pNewTable.aCol[pNewTable.nCol];
        column.zName = pString;
        column.affinity = 'b';
        ++pNewTable.nCol;
      }
    }

    private static void sqlite3AddNotNull(Sqlite3.Parse pParse, int onError)
    {
      Sqlite3.Table pNewTable = pParse.pNewTable;
      if (pNewTable == null || Sqlite3.NEVER(pNewTable.nCol < 1))
        return;
      pNewTable.aCol[pNewTable.nCol - 1].notNull = (byte) onError;
    }

    private static char sqlite3AffinityType(string zIn)
    {
      zIn = zIn.ToLower();
      if (zIn.Contains("char") || zIn.Contains("clob") || zIn.Contains("text"))
        return 'a';
      if (zIn.Contains("blob"))
        return 'b';
      if (zIn.Contains("doub") || zIn.Contains("floa") || zIn.Contains("real"))
        return 'e';
      return zIn.Contains("int") ? 'd' : 'c';
    }

    private static void sqlite3AddColumnType(Sqlite3.Parse pParse, Sqlite3.Token pType)
    {
      Sqlite3.Table pNewTable = pParse.pNewTable;
      if (pNewTable == null || Sqlite3.NEVER(pNewTable.nCol < 1))
        return;
      Sqlite3.Column column = pNewTable.aCol[pNewTable.nCol - 1];
      column.zType = Sqlite3.sqlite3NameFromToken(pParse.db, pType);
      column.affinity = Sqlite3.sqlite3AffinityType(column.zType);
    }

    private static void sqlite3AddDefaultValue(Sqlite3.Parse pParse, Sqlite3.ExprSpan pSpan)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Table pNewTable = pParse.pNewTable;
      if (pNewTable != null)
      {
        Sqlite3.Column column = pNewTable.aCol[pNewTable.nCol - 1];
        if (Sqlite3.sqlite3ExprIsConstantOrFunction(pSpan.pExpr) == 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant", (object) column.zName);
        }
        else
        {
          Sqlite3.sqlite3ExprDelete(db, ref column.pDflt);
          column.pDflt = Sqlite3.sqlite3ExprDup(db, pSpan.pExpr, 1);
          Sqlite3.sqlite3DbFree(db, ref column.zDflt);
          column.zDflt = pSpan.zStart.Substring(0, pSpan.zStart.Length - pSpan.zEnd.Length);
        }
      }
      Sqlite3.sqlite3ExprDelete(db, ref pSpan.pExpr);
    }

    private static void sqlite3AddPrimaryKey(
      Sqlite3.Parse pParse,
      int null_2,
      int onError,
      int autoInc,
      int sortOrder)
    {
      Sqlite3.sqlite3AddPrimaryKey(pParse, (Sqlite3.ExprList) null, onError, autoInc, sortOrder);
    }

    private static void sqlite3AddPrimaryKey(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      int onError,
      int autoInc,
      int sortOrder)
    {
      Sqlite3.Table pNewTable = pParse.pNewTable;
      string str = (string) null;
      int index1 = -1;
      if (pNewTable != null && !Sqlite3.IN_DECLARE_VTAB(pParse))
      {
        if (((int) pNewTable.tabFlags & 4) != 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "table \"%s\" has more than one primary key", (object) pNewTable.zName);
        }
        else
        {
          pNewTable.tabFlags |= (byte) 4;
          if (pList == null)
          {
            index1 = pNewTable.nCol - 1;
            pNewTable.aCol[index1].isPrimKey = (byte) 1;
          }
          else
          {
            for (int index2 = 0; index2 < pList.nExpr; ++index2)
            {
              index1 = 0;
              while (index1 < pNewTable.nCol && !pList.a[index2].zName.Equals(pNewTable.aCol[index1].zName, StringComparison.InvariantCultureIgnoreCase))
                ++index1;
              if (index1 < pNewTable.nCol)
                pNewTable.aCol[index1].isPrimKey = (byte) 1;
            }
            if (pList.nExpr > 1)
              index1 = -1;
          }
          if (index1 >= 0 && index1 < pNewTable.nCol)
            str = pNewTable.aCol[index1].zType;
          if (str != null && str.Equals("INTEGER", StringComparison.InvariantCultureIgnoreCase) && sortOrder == 0)
          {
            pNewTable.iPKey = index1;
            pNewTable.keyConf = (byte) onError;
            pNewTable.tabFlags |= (byte) (autoInc * 8);
          }
          else if (autoInc != 0)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an INTEGER PRIMARY KEY");
          }
          else
          {
            Sqlite3.Index index3 = Sqlite3.sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0);
            if (index3 != null)
              index3.autoIndex = (byte) 2;
            pList = (Sqlite3.ExprList) null;
          }
        }
      }
      Sqlite3.sqlite3ExprListDelete(pParse.db, ref pList);
    }

    private static void sqlite3AddCheckConstraint(Sqlite3.Parse pParse, Sqlite3.Expr pCheckExpr)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Table pNewTable = pParse.pNewTable;
      if (pNewTable != null && !Sqlite3.IN_DECLARE_VTAB(pParse))
        pNewTable.pCheck = Sqlite3.sqlite3ExprAnd(db, pNewTable.pCheck, pCheckExpr);
      else
        Sqlite3.sqlite3ExprDelete(db, ref pCheckExpr);
    }

    private static void sqlite3AddCollateType(Sqlite3.Parse pParse, Sqlite3.Token pToken)
    {
      Sqlite3.Table pNewTable;
      if ((pNewTable = pParse.pNewTable) == null)
        return;
      int index1 = pNewTable.nCol - 1;
      Sqlite3.sqlite3 db = pParse.db;
      string pString = Sqlite3.sqlite3NameFromToken(db, pToken);
      if (pString == null)
        return;
      if (Sqlite3.sqlite3LocateCollSeq(pParse, pString) != null)
      {
        pNewTable.aCol[index1].zColl = pString;
        for (Sqlite3.Index index2 = pNewTable.pIndex; index2 != null; index2 = index2.pNext)
        {
          if (index2.aiColumn[0] == index1)
            index2.azColl[0] = pNewTable.aCol[index1].zColl;
        }
      }
      else
        Sqlite3.sqlite3DbFree(db, ref pString);
    }

    private static Sqlite3.CollSeq sqlite3LocateCollSeq(Sqlite3.Parse pParse, string zName)
    {
      Sqlite3.sqlite3 db = pParse.db;
      byte enc = db.aDb[0].pSchema.enc;
      byte busy = db.init.busy;
      Sqlite3.CollSeq collSeq = Sqlite3.sqlite3FindCollSeq(db, enc, zName, busy);
      if (busy == (byte) 0 && (collSeq == null || collSeq.xCmp == null))
      {
        collSeq = Sqlite3.sqlite3GetCollSeq(db, enc, collSeq, zName);
        if (collSeq == null)
          Sqlite3.sqlite3ErrorMsg(pParse, "no such collation sequence: %s", (object) zName);
      }
      return collSeq;
    }

    private static void sqlite3ChangeCookie(Sqlite3.Parse pParse, int iDb)
    {
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, db.aDb[iDb].pSchema.schema_cookie + 1, tempReg);
      Sqlite3.sqlite3VdbeAddOp3(pVdbe, 36, iDb, 1, tempReg);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
    }

    private static int identLength(string z)
    {
      int index;
      for (index = 0; index < z.Length; ++index)
      {
        if (z[index] == '"')
          ++index;
      }
      return index + 2;
    }

    private static void identPut(StringBuilder z, ref int pIdx, string zSignedIdent)
    {
      string z1 = zSignedIdent;
      int num1 = pIdx;
      int num2 = 0;
      while (num2 < z1.Length && (Sqlite3.sqlite3Isalnum(z1[num2]) || z1[num2] == '_'))
        ++num2;
      bool flag = Sqlite3.sqlite3Isdigit(z1[0]) || Sqlite3.sqlite3KeywordCode(z1, num2) != 26;
      if (!flag)
        flag = num2 < z1.Length && z1[num2] > char.MinValue;
      if (flag)
      {
        if (num1 == z.Length)
          z.Append(char.MinValue);
        z[num1++] = '"';
      }
      for (int index = 0; index < z1.Length; ++index)
      {
        if (num1 == z.Length)
          z.Append(char.MinValue);
        z[num1++] = z1[index];
        if (z1[index] == '"')
        {
          if (num1 == z.Length)
            z.Append(char.MinValue);
          z[num1++] = '"';
        }
      }
      if (flag)
      {
        if (num1 == z.Length)
          z.Append(char.MinValue);
        z[num1++] = '"';
      }
      pIdx = num1;
    }

    private static string createTableStmt(Sqlite3.sqlite3 db, Sqlite3.Table p)
    {
      int num1 = 0;
      for (int index = 0; index < p.nCol; ++index)
      {
        Sqlite3.Column column = p.aCol[index];
        num1 += Sqlite3.identLength(column.zName) + 5;
      }
      int num2 = num1 + Sqlite3.identLength(p.zName);
      string str1;
      string str2;
      string str3;
      if (num2 < 50)
      {
        str1 = "";
        str2 = ",";
        str3 = ")";
      }
      else
      {
        str1 = "\n  ";
        str2 = ",\n  ";
        str3 = "\n)";
      }
      StringBuilder z1 = new StringBuilder(num2 + (35 + 6 * p.nCol));
      z1.Append("CREATE TABLE ");
      int pIdx1 = Sqlite3.sqlite3Strlen30(z1);
      Sqlite3.identPut(z1, ref pIdx1, p.zName);
      z1.Append('(');
      for (int index = 0; index < p.nCol; ++index)
      {
        Sqlite3.Column column = p.aCol[index];
        string[] strArray = new string[5]
        {
          " TEXT",
          "",
          " NUM",
          " INT",
          " REAL"
        };
        z1.Append(str1);
        int pIdx2 = Sqlite3.sqlite3Strlen30(z1);
        str1 = str2;
        Sqlite3.identPut(z1, ref pIdx2, column.zName);
        Sqlite3.testcase<bool>(column.affinity == 'a');
        Sqlite3.testcase<bool>(column.affinity == 'b');
        Sqlite3.testcase<bool>(column.affinity == 'c');
        Sqlite3.testcase<bool>(column.affinity == 'd');
        Sqlite3.testcase<bool>(column.affinity == 'e');
        string z2 = strArray[(int) column.affinity - 97];
        int num3 = Sqlite3.sqlite3Strlen30(z2);
        z1.Append(z2);
        int num4 = pIdx2 + num3;
      }
      z1.Append(str3);
      return z1.ToString();
    }

    private static void sqlite3EndTable(
      Sqlite3.Parse pParse,
      Sqlite3.Token pCons,
      Sqlite3.Token pEnd,
      int null_4)
    {
      Sqlite3.sqlite3EndTable(pParse, pCons, pEnd, (Sqlite3.Select) null);
    }

    private static void sqlite3EndTable(
      Sqlite3.Parse pParse,
      int null_2,
      int null_3,
      Sqlite3.Select pSelect)
    {
      Sqlite3.sqlite3EndTable(pParse, (Sqlite3.Token) null, (Sqlite3.Token) null, pSelect);
    }

    private static void sqlite3EndTable(
      Sqlite3.Parse pParse,
      Sqlite3.Token pCons,
      Sqlite3.Token pEnd,
      Sqlite3.Select pSelect)
    {
      Sqlite3.sqlite3 db1 = pParse.db;
      if (pEnd == null && pSelect == null)
        return;
      Sqlite3.Table pNewTable = pParse.pNewTable;
      if (pNewTable == null)
        return;
      int index = Sqlite3.sqlite3SchemaToIndex(db1, pNewTable.pSchema);
      if (pNewTable.pCheck != null)
      {
        Sqlite3.NameContext pNC = new Sqlite3.NameContext();
        Sqlite3.SrcList srcList = new Sqlite3.SrcList();
        srcList.nSrc = (short) 1;
        srcList.a = new Sqlite3.SrcList_item[1];
        srcList.a[0] = new Sqlite3.SrcList_item();
        srcList.a[0].zName = pNewTable.zName;
        srcList.a[0].pTab = pNewTable;
        srcList.a[0].iCursor = -1;
        pNC.pParse = pParse;
        pNC.pSrcList = srcList;
        pNC.isCheck = (byte) 1;
        if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pNewTable.pCheck) != 0)
          return;
      }
      if (db1.init.busy != (byte) 0)
        pNewTable.tnum = db1.init.newTnum;
      if (db1.init.busy == (byte) 0)
      {
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
        if (Sqlite3.NEVER(vdbe == null))
          return;
        Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, 0);
        string str1;
        string str2;
        if (pNewTable.pSelect == null)
        {
          str1 = "table";
          str2 = "TABLE";
        }
        else
        {
          str1 = "view";
          str2 = "VIEW";
        }
        if (pSelect != null)
        {
          Sqlite3.SelectDest pDest = new Sqlite3.SelectDest();
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 39, 1, pParse.regRoot, index);
          Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 1);
          pParse.nTab = 2;
          Sqlite3.sqlite3SelectDestInit(pDest, 8, 1);
          Sqlite3.sqlite3Select(pParse, pSelect, ref pDest);
          Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, 1);
          if (pParse.nErr == 0)
          {
            Sqlite3.Table pTable = Sqlite3.sqlite3ResultSetOfSelect(pParse, pSelect);
            if (pTable == null)
              return;
            pNewTable.nCol = pTable.nCol;
            pNewTable.aCol = pTable.aCol;
            pTable.nCol = 0;
            pTable.aCol = (Sqlite3.Column[]) null;
            Sqlite3.sqlite3DeleteTable(db1, ref pTable);
          }
        }
        string pString;
        if (pSelect != null)
        {
          pString = Sqlite3.createTableStmt(db1, pNewTable);
        }
        else
        {
          int num = pParse.sNameToken.z.Length - pEnd.z.Length + 1;
          pString = Sqlite3.sqlite3MPrintf(db1, "CREATE %s %.*s", (object) str2, (object) num, (object) pParse.sNameToken.z);
        }
        Sqlite3.sqlite3NestedParse(pParse, "UPDATE %Q.%s SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q WHERE rowid=#%d", (object) db1.aDb[index].zName, (object) Sqlite3.SCHEMA_TABLE(index), (object) str1, (object) pNewTable.zName, (object) pNewTable.zName, (object) pParse.regRoot, (object) pString, (object) pParse.regRowid);
        Sqlite3.sqlite3DbFree(db1, ref pString);
        Sqlite3.sqlite3ChangeCookie(pParse, index);
        if (((int) pNewTable.tabFlags & 8) != 0)
        {
          Sqlite3.Db db2 = db1.aDb[index];
          if (db2.pSchema.pSeqTab == null)
            Sqlite3.sqlite3NestedParse(pParse, "CREATE TABLE %Q.sqlite_sequence(name,seq)", (object) db2.zName);
        }
        Sqlite3.sqlite3VdbeAddParseSchemaOp(vdbe, index, Sqlite3.sqlite3MPrintf(db1, "tbl_name='%q'", (object) pNewTable.zName));
      }
      if (db1.init.busy == (byte) 0 || Sqlite3.sqlite3HashInsert<Sqlite3.Table>(ref pNewTable.pSchema.tblHash, pNewTable.zName, Sqlite3.sqlite3Strlen30(pNewTable.zName), pNewTable) != null)
        return;
      pParse.pNewTable = (Sqlite3.Table) null;
      ++db1.nTable;
      db1.flags |= 512;
      if (pNewTable.pSelect != null)
        return;
      string z = pParse.sNameToken.z;
      if (pCons.z == null)
        pCons = pEnd;
      int num1 = z.Length - pCons.z.Length;
      pNewTable.addColOffset = 13 + num1;
    }

    private static void sqlite3CreateView(
      Sqlite3.Parse pParse,
      Sqlite3.Token pBegin,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2,
      Sqlite3.Select pSelect,
      int isTemp,
      int noErr)
    {
      Sqlite3.DbFixer pFix = new Sqlite3.DbFixer();
      Sqlite3.Token pUnqual = (Sqlite3.Token) null;
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.nVar > 0)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
        Sqlite3.sqlite3SelectDelete(db, ref pSelect);
      }
      else
      {
        Sqlite3.sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
        Sqlite3.Table pNewTable = pParse.pNewTable;
        if (pNewTable == null || pParse.nErr != 0)
        {
          Sqlite3.sqlite3SelectDelete(db, ref pSelect);
        }
        else
        {
          Sqlite3.sqlite3TwoPartName(pParse, pName1, pName2, ref pUnqual);
          int index = Sqlite3.sqlite3SchemaToIndex(db, pNewTable.pSchema);
          if (Sqlite3.sqlite3FixInit(pFix, pParse, index, "view", pUnqual) != 0 && Sqlite3.sqlite3FixSelect(pFix, pSelect) != 0)
          {
            Sqlite3.sqlite3SelectDelete(db, ref pSelect);
          }
          else
          {
            pNewTable.pSelect = Sqlite3.sqlite3SelectDup(db, pSelect, 1);
            Sqlite3.sqlite3SelectDelete(db, ref pSelect);
            if (db.init.busy == (byte) 0)
              Sqlite3.sqlite3ViewGetColumnNames(pParse, pNewTable);
            Sqlite3.Token sLastToken = pParse.sLastToken;
            if (Sqlite3.ALWAYS(sLastToken.z[0] > char.MinValue) && sLastToken.z[0] != ';')
              sLastToken.z = sLastToken.z.Substring(sLastToken.n);
            sLastToken.n = 0;
            int num = pBegin.z.Length - sLastToken.z.Length;
            string z = pBegin.z;
            while (Sqlite3.ALWAYS(num > 0) && Sqlite3.sqlite3Isspace(z[num - 1]))
              --num;
            sLastToken.z = z.Substring(num - 1);
            sLastToken.n = 1;
            Sqlite3.sqlite3EndTable(pParse, (Sqlite3.Token) null, sLastToken, (Sqlite3.Select) null);
          }
        }
      }
    }

    private static int sqlite3ViewGetColumnNames(Sqlite3.Parse pParse, Sqlite3.Table pTable)
    {
      int columnNames = 0;
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.IsVirtual(pTable) || pTable.nCol > 0)
        return 0;
      if (pTable.nCol < 0)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "view %s is circularly defined", (object) pTable.zName);
        return 1;
      }
      Sqlite3.Select p = Sqlite3.sqlite3SelectDup(db, pTable.pSelect, 0);
      if (p != null)
      {
        byte bEnabled = db.lookaside.bEnabled;
        int nTab = pParse.nTab;
        Sqlite3.sqlite3SrcListAssignCursors(pParse, p.pSrc);
        pTable.nCol = -1;
        db.lookaside.bEnabled = (byte) 0;
        Sqlite3.Table pTable1 = Sqlite3.sqlite3ResultSetOfSelect(pParse, p);
        db.lookaside.bEnabled = bEnabled;
        pParse.nTab = nTab;
        if (pTable1 != null)
        {
          pTable.nCol = pTable1.nCol;
          pTable.aCol = pTable1.aCol;
          pTable1.nCol = 0;
          pTable1.aCol = (Sqlite3.Column[]) null;
          Sqlite3.sqlite3DeleteTable(db, ref pTable1);
          pTable.pSchema.flags |= (ushort) 2;
        }
        else
        {
          pTable.nCol = 0;
          ++columnNames;
        }
        Sqlite3.sqlite3SelectDelete(db, ref p);
      }
      else
        ++columnNames;
      return columnNames;
    }

    private static void sqliteViewResetAll(Sqlite3.sqlite3 db, int idx)
    {
      if (!Sqlite3.DbHasProperty(db, idx, (ushort) 2))
        return;
      for (Sqlite3.HashElem hashElem = db.aDb[idx].pSchema.tblHash.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
        if (data.pSelect != null)
        {
          Sqlite3.sqliteDeleteColumnNames(db, data);
          data.aCol = (Sqlite3.Column[]) null;
          data.nCol = 0;
        }
      }
      Sqlite3.DbClearProperty(db, idx, (ushort) 2);
    }

    private static void sqlite3RootPageMoved(Sqlite3.sqlite3 db, int iDb, int iFrom, int iTo)
    {
      Sqlite3.Db db1 = db.aDb[iDb];
      for (Sqlite3.HashElem hashElem = db1.pSchema.tblHash.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
        if (data.tnum == iFrom)
          data.tnum = iTo;
      }
      for (Sqlite3.HashElem hashElem = db1.pSchema.idxHash.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.Index data = (Sqlite3.Index) hashElem.data;
        if (data.tnum == iFrom)
          data.tnum = iTo;
      }
    }

    private static void destroyRootPage(Sqlite3.Parse pParse, int iTable, int iDb)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      int p1 = iTable;
      int p2 = tempReg;
      int p3 = iDb;
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 95, p1, p2, p3);
      Sqlite3.sqlite3MayAbort(pParse);
      Sqlite3.sqlite3NestedParse(pParse, "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d", (object) pParse.db.aDb[iDb].zName, (object) Sqlite3.SCHEMA_TABLE(iDb), (object) iTable, (object) tempReg, (object) tempReg);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
    }

    private static void destroyTable(Sqlite3.Parse pParse, Sqlite3.Table pTab)
    {
      int tnum1 = pTab.tnum;
      int num = 0;
      while (true)
      {
        int iTable = 0;
        if (num == 0 || tnum1 < num)
          iTable = tnum1;
        for (Sqlite3.Index index = pTab.pIndex; index != null; index = index.pNext)
        {
          int tnum2 = index.tnum;
          if ((num == 0 || tnum2 < num) && tnum2 > iTable)
            iTable = tnum2;
        }
        if (iTable != 0)
        {
          int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
          Sqlite3.destroyRootPage(pParse, iTable, index);
          num = iTable;
        }
        else
          break;
      }
    }

    private static void sqlite3DropTable(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pName,
      int isView,
      int noErr)
    {
      Sqlite3.sqlite3 db1 = pParse.db;
      if (noErr != 0)
        ++db1.suppressErr;
      Sqlite3.Table table = Sqlite3.sqlite3LocateTable(pParse, isView, pName.a[0].zName, pName.a[0].zDatabase);
      if (noErr != 0)
        --db1.suppressErr;
      if (table == null)
      {
        if (noErr != 0)
          Sqlite3.sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
      }
      else
      {
        int index = Sqlite3.sqlite3SchemaToIndex(db1, table.pSchema);
        if (!Sqlite3.IsVirtual(table) || Sqlite3.sqlite3ViewGetColumnNames(pParse, table) == 0)
        {
          if (table.zName.StartsWith("sqlite_", StringComparison.InvariantCultureIgnoreCase))
            Sqlite3.sqlite3ErrorMsg(pParse, "table %s may not be dropped", (object) table.zName);
          else if (isView != 0 && table.pSelect == null)
            Sqlite3.sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", (object) table.zName);
          else if (isView == 0 && table.pSelect != null)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", (object) table.zName);
          }
          else
          {
            Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
            if (vdbe != null)
            {
              Sqlite3.Db db2 = db1.aDb[index];
              Sqlite3.sqlite3BeginWriteOperation(pParse, 1, index);
              Sqlite3.sqlite3FkDropTable(pParse, pName, table);
              for (Sqlite3.Trigger pTrigger = Sqlite3.sqlite3TriggerList(pParse, table); pTrigger != null; pTrigger = pTrigger.pNext)
                Sqlite3.sqlite3DropTriggerPtr(pParse, pTrigger);
              if (((int) table.tabFlags & 8) != 0)
                Sqlite3.sqlite3NestedParse(pParse, "DELETE FROM %s.sqlite_sequence WHERE name=%Q", (object) db2.zName, (object) table.zName);
              Sqlite3.sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'", (object) db2.zName, (object) Sqlite3.SCHEMA_TABLE(index), (object) table.zName);
              if (Sqlite3.sqlite3FindTable(db1, "sqlite_stat1", db1.aDb[index].zName) != null)
                Sqlite3.sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q", (object) db2.zName, (object) table.zName);
              if (isView == 0 && !Sqlite3.IsVirtual(table))
                Sqlite3.destroyTable(pParse, table);
              if (Sqlite3.IsVirtual(table))
                Sqlite3.sqlite3VdbeAddOp4(vdbe, 126, index, 0, 0, table.zName, 0);
              Sqlite3.sqlite3VdbeAddOp4(vdbe, 101, index, 0, 0, table.zName, 0);
              Sqlite3.sqlite3ChangeCookie(pParse, index);
            }
            Sqlite3.sqliteViewResetAll(db1, index);
          }
        }
      }
      Sqlite3.sqlite3SrcListDelete(db1, ref pName);
    }

    private static void sqlite3CreateForeignKey(
      Sqlite3.Parse pParse,
      int null_2,
      Sqlite3.Token pTo,
      Sqlite3.ExprList pToCol,
      int flags)
    {
      Sqlite3.sqlite3CreateForeignKey(pParse, (Sqlite3.ExprList) null, pTo, pToCol, flags);
    }

    private static void sqlite3CreateForeignKey(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pFromCol,
      Sqlite3.Token pTo,
      Sqlite3.ExprList pToCol,
      int flags)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.FKey pT = (Sqlite3.FKey) null;
      Sqlite3.Table pNewTable = pParse.pNewTable;
      if (pNewTable != null && !Sqlite3.IN_DECLARE_VTAB(pParse))
      {
        int length;
        if (pFromCol == null)
        {
          int index = pNewTable.nCol - 1;
          if (!Sqlite3.NEVER(index < 0))
          {
            if (pToCol != null && pToCol.nExpr != 1)
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "foreign key on %s should reference only one column of table %T", (object) pNewTable.aCol[index].zName, (object) pTo);
              goto label_33;
            }
            else
              length = 1;
          }
          else
            goto label_33;
        }
        else if (pToCol != null && pToCol.nExpr != pFromCol.nExpr)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "number of columns in foreign key does not match the number of columns in the referenced table");
          goto label_33;
        }
        else
          length = pFromCol.nExpr;
        pT = new Sqlite3.FKey();
        if (pT != null)
        {
          pT.pFrom = pNewTable;
          pT.pNextFrom = pNewTable.pFKey;
          pT.aCol = new Sqlite3.FKey.sColMap[length];
          pT.aCol[0] = new Sqlite3.FKey.sColMap();
          pT.zTo = pTo.z.Substring(0, pTo.n);
          Sqlite3.sqlite3Dequote(ref pT.zTo);
          pT.nCol = length;
          if (pFromCol == null)
          {
            pT.aCol[0].iFrom = pNewTable.nCol - 1;
          }
          else
          {
            for (int index1 = 0; index1 < length; ++index1)
            {
              if (pT.aCol[index1] == null)
                pT.aCol[index1] = new Sqlite3.FKey.sColMap();
              int index2;
              for (index2 = 0; index2 < pNewTable.nCol; ++index2)
              {
                if (pNewTable.aCol[index2].zName.Equals(pFromCol.a[index1].zName, StringComparison.InvariantCultureIgnoreCase))
                {
                  pT.aCol[index1].iFrom = index2;
                  break;
                }
              }
              if (index2 >= pNewTable.nCol)
              {
                Sqlite3.sqlite3ErrorMsg(pParse, "unknown column \"%s\" in foreign key definition", (object) pFromCol.a[index1].zName);
                goto label_33;
              }
            }
          }
          if (pToCol != null)
          {
            for (int index = 0; index < length; ++index)
            {
              Sqlite3.sqlite3Strlen30(pToCol.a[index].zName);
              if (pT.aCol[index] == null)
                pT.aCol[index] = new Sqlite3.FKey.sColMap();
              pT.aCol[index].zCol = pToCol.a[index].zName;
            }
          }
          pT.isDeferred = (byte) 0;
          pT.aAction[0] = (byte) (flags & (int) byte.MaxValue);
          pT.aAction[1] = (byte) (flags >> 8 & (int) byte.MaxValue);
          Sqlite3.FKey fkey = Sqlite3.sqlite3HashInsert<Sqlite3.FKey>(ref pNewTable.pSchema.fkeyHash, pT.zTo, Sqlite3.sqlite3Strlen30(pT.zTo), pT);
          if (fkey != null)
          {
            pT.pNextTo = fkey;
            fkey.pPrevTo = pT;
          }
          pNewTable.pFKey = pT;
          pT = (Sqlite3.FKey) null;
        }
      }
label_33:
      Sqlite3.sqlite3DbFree<Sqlite3.FKey>(db, ref pT);
      Sqlite3.sqlite3ExprListDelete(db, ref pFromCol);
      Sqlite3.sqlite3ExprListDelete(db, ref pToCol);
    }

    private static void sqlite3DeferForeignKey(Sqlite3.Parse pParse, int isDeferred)
    {
      Sqlite3.Table pNewTable;
      Sqlite3.FKey pFkey;
      if ((pNewTable = pParse.pNewTable) == null || (pFkey = pNewTable.pFKey) == null)
        return;
      pFkey.isDeferred = (byte) isDeferred;
    }

    private static void sqlite3RefillIndex(
      Sqlite3.Parse pParse,
      Sqlite3.Index pIndex,
      int memRootPage)
    {
      Sqlite3.Table pTable = pIndex.pTable;
      int num1 = pParse.nTab++;
      int p1 = pParse.nTab++;
      int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pIndex.pSchema);
      Sqlite3.sqlite3TableLock(pParse, index, pTable.tnum, (byte) 1, pTable.zName);
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      int num2;
      if (memRootPage >= 0)
      {
        num2 = memRootPage;
      }
      else
      {
        num2 = pIndex.tnum;
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 96, num2, index);
      }
      Sqlite3.KeyInfo pP4_1 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIndex);
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 39, p1, num2, index, pP4_1, -16);
      if (memRootPage >= 0)
        Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 1);
      Sqlite3.sqlite3OpenTable(pParse, num1, index, pTable, 38);
      int addr = Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, num1, 0);
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      int indexKey = Sqlite3.sqlite3GenerateIndexKey(pParse, pIndex, num1, tempReg, true);
      if (pIndex.onError != (byte) 0)
      {
        int p3 = indexKey + pIndex.nColumn;
        int p2 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe) + 2;
        int pP4_2 = indexKey;
        Sqlite3.sqlite3VdbeAddOp4(vdbe, 51, p1, p2, p3, pP4_2, -14);
        Sqlite3.sqlite3HaltConstraint(pParse, 2, "indexed columns are not unique", -2);
      }
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 70, p1, tempReg);
      Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 16);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, num1, addr + 1);
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
      Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, num1);
      Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, p1);
    }

    private static Sqlite3.Index sqlite3CreateIndex(
      Sqlite3.Parse pParse,
      int null_2,
      int null_3,
      int null_4,
      int null_5,
      int onError,
      int null_7,
      int null_8,
      int sortOrder,
      int ifNotExist)
    {
      return Sqlite3.sqlite3CreateIndex(pParse, (Sqlite3.Token) null, (Sqlite3.Token) null, (Sqlite3.SrcList) null, (Sqlite3.ExprList) null, onError, (Sqlite3.Token) null, (Sqlite3.Token) null, sortOrder, ifNotExist);
    }

    private static Sqlite3.Index sqlite3CreateIndex(
      Sqlite3.Parse pParse,
      int null_2,
      int null_3,
      int null_4,
      Sqlite3.ExprList pList,
      int onError,
      int null_7,
      int null_8,
      int sortOrder,
      int ifNotExist)
    {
      return Sqlite3.sqlite3CreateIndex(pParse, (Sqlite3.Token) null, (Sqlite3.Token) null, (Sqlite3.SrcList) null, pList, onError, (Sqlite3.Token) null, (Sqlite3.Token) null, sortOrder, ifNotExist);
    }

    private static Sqlite3.Index sqlite3CreateIndex(
      Sqlite3.Parse pParse,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2,
      Sqlite3.SrcList pTblName,
      Sqlite3.ExprList pList,
      int onError,
      Sqlite3.Token pStart,
      Sqlite3.Token pEnd,
      int sortOrder,
      int ifNotExist)
    {
      Sqlite3.Index index1 = (Sqlite3.Index) null;
      Sqlite3.Index pT = (Sqlite3.Index) null;
      string pString1 = (string) null;
      Sqlite3.Token pName = new Sqlite3.Token();
      Sqlite3.DbFixer pFix = new Sqlite3.DbFixer();
      Sqlite3.sqlite3 db1 = pParse.db;
      Sqlite3.Token pUnqual = (Sqlite3.Token) null;
      int num1 = 0;
      StringBuilder stringBuilder1 = new StringBuilder();
      if (!Sqlite3.IN_DECLARE_VTAB(pParse) && Sqlite3.sqlite3ReadSchema(pParse) == 0)
      {
        int index2;
        Sqlite3.Table T;
        if (pTblName != null)
        {
          index2 = Sqlite3.sqlite3TwoPartName(pParse, pName1, pName2, ref pUnqual);
          if (index2 >= 0)
          {
            if (db1.init.busy == (byte) 0)
            {
              Sqlite3.Table table = Sqlite3.sqlite3SrcListLookup(pParse, pTblName);
              if (pName2.n == 0 && table != null && table.pSchema == db1.aDb[1].pSchema)
                index2 = 1;
            }
            if (Sqlite3.sqlite3FixInit(pFix, pParse, index2, "index", pUnqual) != 0 && Sqlite3.sqlite3FixSrcList(pFix, pTblName) != 0)
              Debugger.Break();
            T = Sqlite3.sqlite3LocateTable(pParse, 0, pTblName.a[0].zName, pTblName.a[0].zDatabase);
            if (T == null)
              goto label_84;
          }
          else
            goto label_84;
        }
        else
        {
          T = pParse.pNewTable;
          if (T != null)
            index2 = Sqlite3.sqlite3SchemaToIndex(db1, T.pSchema);
          else
            goto label_84;
        }
        Sqlite3.Db db2 = db1.aDb[index2];
        if (T.zName.StartsWith("sqlite_", StringComparison.InvariantCultureIgnoreCase) && !T.zName.StartsWith("sqlite_altertab_", StringComparison.InvariantCultureIgnoreCase))
          Sqlite3.sqlite3ErrorMsg(pParse, "table %s may not be indexed", (object) T.zName);
        else if (T.pSelect != null)
          Sqlite3.sqlite3ErrorMsg(pParse, "views may not be indexed");
        else if (Sqlite3.IsVirtual(T))
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
        }
        else
        {
          if (pUnqual != null)
          {
            pString1 = Sqlite3.sqlite3NameFromToken(db1, pUnqual);
            if (pString1 != null && Sqlite3.sqlite3CheckObjectName(pParse, pString1) == 0)
            {
              if (db1.init.busy == (byte) 0 && Sqlite3.sqlite3FindTable(db1, pString1, (string) null) != null)
              {
                Sqlite3.sqlite3ErrorMsg(pParse, "there is already a table named %s", (object) pString1);
                goto label_84;
              }
              else if (Sqlite3.sqlite3FindIndex(db1, pString1, db2.zName) != null)
              {
                if (ifNotExist == 0)
                {
                  Sqlite3.sqlite3ErrorMsg(pParse, "index %s already exists", (object) pString1);
                  goto label_84;
                }
                else
                {
                  Sqlite3.sqlite3CodeVerifySchema(pParse, index2);
                  goto label_84;
                }
              }
            }
            else
              goto label_84;
          }
          else
          {
            Sqlite3.Index index3 = T.pIndex;
            int num2 = 1;
            while (index3 != null)
            {
              index3 = index3.pNext;
              ++num2;
            }
            pString1 = Sqlite3.sqlite3MPrintf(db1, "sqlite_autoindex_%s_%d", (object) T.zName, (object) num2);
            if (pString1 == null)
              goto label_84;
          }
          if (pList == null)
          {
            pName.z = T.aCol[T.nCol - 1].zName;
            pName.n = Sqlite3.sqlite3Strlen30(pName.z);
            pList = Sqlite3.sqlite3ExprListAppend(pParse, (Sqlite3.ExprList) null, (Sqlite3.Expr) null);
            if (pList != null)
            {
              Sqlite3.sqlite3ExprListSetName(pParse, pList, pName, 0);
              pList.a[0].sortOrder = (byte) sortOrder;
            }
            else
              goto label_84;
          }
          for (int index4 = 0; index4 < pList.nExpr; ++index4)
          {
            Sqlite3.Expr pExpr = pList.a[index4].pExpr;
            if (pExpr != null)
            {
              Sqlite3.CollSeq pColl = pExpr.pColl;
              if (Sqlite3.ALWAYS(pColl != null))
                num1 += 1 + Sqlite3.sqlite3Strlen30(pColl.zName);
            }
          }
          int length1 = Sqlite3.sqlite3Strlen30(pString1);
          int nExpr = pList.nExpr;
          pT = new Sqlite3.Index();
          pT.azColl = new string[nExpr + 1];
          pT.aiColumn = new int[nExpr + 1];
          pT.aiRowEst = new int[nExpr + 1];
          pT.aSortOrder = new byte[nExpr + 1];
          StringBuilder stringBuilder2 = new StringBuilder(length1 + 1);
          pT.zName = pString1.Length != length1 ? pString1.Substring(0, length1) : pString1;
          pT.pTable = T;
          pT.nColumn = pList.nExpr;
          pT.onError = (byte) onError;
          pT.autoIndex = pUnqual == null ? (byte) 1 : (byte) 0;
          pT.pSchema = db1.aDb[index2].pSchema;
          int num3 = db2.pSchema.file_format < (byte) 4 ? 0 : 1;
          for (int index5 = 0; index5 < pList.nExpr; ++index5)
          {
            Sqlite3.ExprList_item exprListItem = pList.a[index5];
            string zName1 = exprListItem.zName;
            int index6;
            for (index6 = 0; index6 < T.nCol; ++index6)
            {
              Sqlite3.Column column = T.aCol[index6];
              if (zName1.Equals(column.zName, StringComparison.InvariantCultureIgnoreCase))
                break;
            }
            if (index6 >= T.nCol)
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "table %s has no column named %s", (object) T.zName, (object) zName1);
              pParse.checkSchema = (byte) 1;
              goto label_84;
            }
            else
            {
              pT.aiColumn[index5] = index6;
              string zName2;
              if (exprListItem.pExpr != null && Sqlite3.ALWAYS<Sqlite3.CollSeq>(exprListItem.pExpr.pColl))
              {
                string zName3 = exprListItem.pExpr.pColl.zName;
                int length2 = Sqlite3.sqlite3Strlen30(zName3);
                zName2 = new StringBuilder(zName3.Substring(0, length2)).ToString();
                num1 -= length2;
              }
              else
                zName2 = T.aCol[index6].zColl ?? db1.pDfltColl.zName;
              if (db1.init.busy != (byte) 0 || Sqlite3.sqlite3LocateCollSeq(pParse, zName2) != null)
              {
                pT.azColl[index5] = zName2;
                byte num4 = ((int) exprListItem.sortOrder & num3) != 0 ? (byte) 1 : (byte) 0;
                pT.aSortOrder[index5] = num4;
              }
              else
                goto label_84;
            }
          }
          Sqlite3.sqlite3DefaultRowEst(pT);
          if (T == pParse.pNewTable)
          {
            for (Sqlite3.Index index7 = T.pIndex; index7 != null; index7 = index7.pNext)
            {
              if (index7.nColumn == pT.nColumn)
              {
                int index8;
                for (index8 = 0; index8 < index7.nColumn && index7.aiColumn[index8] == pT.aiColumn[index8]; ++index8)
                {
                  string str1 = index7.azColl[index8];
                  string str2 = pT.azColl[index8];
                  if (str1 != str2 && !str1.Equals(str2, StringComparison.InvariantCultureIgnoreCase))
                    break;
                }
                if (index8 == index7.nColumn)
                {
                  if ((int) index7.onError != (int) pT.onError)
                  {
                    if (index7.onError != (byte) 99 && pT.onError != (byte) 99)
                      Sqlite3.sqlite3ErrorMsg(pParse, "conflicting ON CONFLICT clauses specified", (object) 0);
                    if (index7.onError == (byte) 99)
                    {
                      index7.onError = pT.onError;
                      goto label_84;
                    }
                    else
                      goto label_84;
                  }
                  else
                    goto label_84;
                }
              }
            }
          }
          if (db1.init.busy != (byte) 0)
          {
            if (Sqlite3.sqlite3HashInsert<Sqlite3.Index>(ref pT.pSchema.idxHash, pT.zName, Sqlite3.sqlite3Strlen30(pT.zName), pT) == null)
            {
              db1.flags |= 512;
              if (pTblName != null)
                pT.tnum = db1.init.newTnum;
            }
            else
              goto label_84;
          }
          else
          {
            int num5 = ++pParse.nMem;
            Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
            if (vdbe != null)
            {
              Sqlite3.sqlite3BeginWriteOperation(pParse, 1, index2);
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 97, index2, num5);
              string pString2;
              if (pStart != null)
                pString2 = Sqlite3.sqlite3MPrintf(db1, "CREATE%s INDEX %.*s", onError == 0 ? (object) "" : (object) " UNIQUE", (object) (pUnqual.z.Length - pEnd.z.Length + 1), (object) pUnqual.z);
              else
                pString2 = (string) null;
              Sqlite3.sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);", (object) db1.aDb[index2].zName, (object) Sqlite3.SCHEMA_TABLE(index2), (object) pT.zName, (object) T.zName, (object) num5, (object) pString2);
              Sqlite3.sqlite3DbFree(db1, ref pString2);
              if (pTblName != null)
              {
                Sqlite3.sqlite3RefillIndex(pParse, pT, num5);
                Sqlite3.sqlite3ChangeCookie(pParse, index2);
                Sqlite3.sqlite3VdbeAddParseSchemaOp(vdbe, index2, Sqlite3.sqlite3MPrintf(db1, "name='%q' AND type='index'", (object) pT.zName));
                Sqlite3.sqlite3VdbeAddOp1(vdbe, 122, 0);
              }
            }
            else
              goto label_84;
          }
          if (db1.init.busy != (byte) 0 || pTblName == null)
          {
            if (onError != 5 || T.pIndex == null || T.pIndex.onError == (byte) 5)
            {
              pT.pNext = T.pIndex;
              T.pIndex = pT;
            }
            else
            {
              Sqlite3.Index index9 = T.pIndex;
              while (index9.pNext != null && index9.pNext.onError != (byte) 5)
                index9 = index9.pNext;
              pT.pNext = index9.pNext;
              index9.pNext = pT;
            }
            index1 = pT;
            pT = (Sqlite3.Index) null;
          }
        }
      }
label_84:
      if (pT != null)
        Sqlite3.sqlite3DbFree<Sqlite3.Index>(db1, ref pT);
      Sqlite3.sqlite3ExprListDelete(db1, ref pList);
      Sqlite3.sqlite3SrcListDelete(db1, ref pTblName);
      Sqlite3.sqlite3DbFree(db1, ref pString1);
      return index1;
    }

    private static void sqlite3DefaultRowEst(Sqlite3.Index pIdx)
    {
      int[] aiRowEst = pIdx.aiRowEst;
      aiRowEst[0] = (int) pIdx.pTable.nRowEst;
      if (aiRowEst[0] < 10)
        aiRowEst[0] = 10;
      int num = 10;
      for (int index = 1; index <= pIdx.nColumn; ++index)
      {
        aiRowEst[index] = num;
        if (num > 5)
          --num;
      }
      if (pIdx.onError == (byte) 0)
        return;
      aiRowEst[pIdx.nColumn] = 1;
    }

    private static void sqlite3DropIndex(Sqlite3.Parse pParse, Sqlite3.SrcList pName, int ifExists)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
      {
        Sqlite3.Index index1 = Sqlite3.sqlite3FindIndex(db, pName.a[0].zName, pName.a[0].zDatabase);
        if (index1 == null)
        {
          if (ifExists == 0)
            Sqlite3.sqlite3ErrorMsg(pParse, "no such index: %S", (object) pName, (object) 0);
          else
            Sqlite3.sqlite3CodeVerifyNamedSchema(pParse, pName.a[0].zDatabase);
          pParse.checkSchema = (byte) 1;
        }
        else if (index1.autoIndex != (byte) 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "index associated with UNIQUE or PRIMARY KEY constraint cannot be dropped", (object) 0);
        }
        else
        {
          int index2 = Sqlite3.sqlite3SchemaToIndex(db, index1.pSchema);
          Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
          if (vdbe != null)
          {
            Sqlite3.sqlite3BeginWriteOperation(pParse, 1, index2);
            Sqlite3.sqlite3NestedParse(pParse, "DELETE FROM %Q.%s WHERE name=%Q AND type='index'", (object) db.aDb[index2].zName, (object) Sqlite3.SCHEMA_TABLE(index2), (object) index1.zName);
            if (Sqlite3.sqlite3FindTable(db, "sqlite_stat1", db.aDb[index2].zName) != null)
              Sqlite3.sqlite3NestedParse(pParse, "DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q", (object) db.aDb[index2].zName, (object) index1.zName);
            Sqlite3.sqlite3ChangeCookie(pParse, index2);
            Sqlite3.destroyRootPage(pParse, index1.tnum, index2);
            Sqlite3.sqlite3VdbeAddOp4(vdbe, 102, index2, 0, 0, index1.zName, 0);
          }
        }
      }
      Sqlite3.sqlite3SrcListDelete(db, ref pName);
    }

    private static T[] sqlite3ArrayAllocate<T>(
      Sqlite3.sqlite3 db,
      T[] pArray,
      int szEntry,
      int initSize,
      ref int pnEntry,
      ref int pnAlloc,
      ref int pIdx)
      where T : new()
    {
      if (pnEntry >= pnAlloc)
      {
        int newSize = pnAlloc * 2 + initSize;
        pnAlloc = newSize;
        Array.Resize<T>(ref pArray, newSize);
      }
      pArray[pnEntry] = new T();
      pIdx = pnEntry;
      ++pnEntry;
      return pArray;
    }

    private static Sqlite3.IdList sqlite3IdListAppend(
      Sqlite3.sqlite3 db,
      int null_2,
      Sqlite3.Token pToken)
    {
      return Sqlite3.sqlite3IdListAppend(db, (Sqlite3.IdList) null, pToken);
    }

    private static Sqlite3.IdList sqlite3IdListAppend(
      Sqlite3.sqlite3 db,
      Sqlite3.IdList pList,
      Sqlite3.Token pToken)
    {
      int pIdx = 0;
      if (pList == null)
      {
        pList = new Sqlite3.IdList();
        if (pList == null)
          return (Sqlite3.IdList) null;
        pList.nAlloc = 0;
      }
      pList.a = Sqlite3.sqlite3ArrayAllocate<Sqlite3.IdList_item>(db, pList.a, -1, 5, ref pList.nId, ref pList.nAlloc, ref pIdx);
      if (pIdx < 0)
      {
        Sqlite3.sqlite3IdListDelete(db, ref pList);
        return (Sqlite3.IdList) null;
      }
      pList.a[pIdx].zName = Sqlite3.sqlite3NameFromToken(db, pToken);
      return pList;
    }

    private static void sqlite3IdListDelete(Sqlite3.sqlite3 db, ref Sqlite3.IdList pList)
    {
      if (pList == null)
        return;
      for (int index = 0; index < pList.nId; ++index)
        Sqlite3.sqlite3DbFree(db, ref pList.a[index].zName);
      Sqlite3.sqlite3DbFree<Sqlite3.IdList_item[]>(db, ref pList.a);
      Sqlite3.sqlite3DbFree<Sqlite3.IdList>(db, ref pList);
    }

    private static int sqlite3IdListIndex(Sqlite3.IdList pList, string zName)
    {
      if (pList == null)
        return -1;
      for (int index = 0; index < pList.nId; ++index)
      {
        if (pList.a[index].zName.Equals(zName, StringComparison.InvariantCultureIgnoreCase))
          return index;
      }
      return -1;
    }

    private static Sqlite3.SrcList sqlite3SrcListEnlarge(
      Sqlite3.sqlite3 db,
      Sqlite3.SrcList pSrc,
      int nExtra,
      int iStart)
    {
      if ((int) pSrc.nSrc + nExtra > (int) pSrc.nAlloc)
      {
        int newSize = (int) pSrc.nSrc + nExtra;
        pSrc.nAlloc = (short) newSize;
        Array.Resize<Sqlite3.SrcList_item>(ref pSrc.a, newSize);
      }
      for (int index = (int) pSrc.nSrc - 1; index >= iStart; --index)
        pSrc.a[index + nExtra] = pSrc.a[index];
      pSrc.nSrc += (short) nExtra;
      for (int index = iStart; index < iStart + nExtra; ++index)
      {
        pSrc.a[index] = new Sqlite3.SrcList_item();
        pSrc.a[index].iCursor = -1;
      }
      return pSrc;
    }

    private static Sqlite3.SrcList sqlite3SrcListAppend(
      Sqlite3.sqlite3 db,
      int null_2,
      Sqlite3.Token pTable,
      int null_4)
    {
      return Sqlite3.sqlite3SrcListAppend(db, (Sqlite3.SrcList) null, pTable, (Sqlite3.Token) null);
    }

    private static Sqlite3.SrcList sqlite3SrcListAppend(
      Sqlite3.sqlite3 db,
      int null_2,
      Sqlite3.Token pTable,
      Sqlite3.Token pDatabase)
    {
      return Sqlite3.sqlite3SrcListAppend(db, (Sqlite3.SrcList) null, pTable, pDatabase);
    }

    private static Sqlite3.SrcList sqlite3SrcListAppend(
      Sqlite3.sqlite3 db,
      Sqlite3.SrcList pList,
      Sqlite3.Token pTable,
      Sqlite3.Token pDatabase)
    {
      if (pList == null)
      {
        pList = new Sqlite3.SrcList();
        pList.nAlloc = (short) 1;
        pList.a = new Sqlite3.SrcList_item[1];
      }
      pList = Sqlite3.sqlite3SrcListEnlarge(db, pList, 1, (int) pList.nSrc);
      Sqlite3.SrcList_item srcListItem = pList.a[(int) pList.nSrc - 1];
      if (pDatabase != null && string.IsNullOrEmpty(pDatabase.z))
        pDatabase = (Sqlite3.Token) null;
      if (pDatabase != null)
      {
        Sqlite3.Token token = pDatabase;
        pDatabase = pTable;
        pTable = token;
      }
      srcListItem.zName = Sqlite3.sqlite3NameFromToken(db, pTable);
      srcListItem.zDatabase = Sqlite3.sqlite3NameFromToken(db, pDatabase);
      return pList;
    }

    private static void sqlite3SrcListAssignCursors(Sqlite3.Parse pParse, Sqlite3.SrcList pList)
    {
      if (pList == null)
        return;
      for (int index = 0; index < (int) pList.nSrc; ++index)
      {
        Sqlite3.SrcList_item srcListItem = pList.a[index];
        if (srcListItem.iCursor >= 0)
          break;
        srcListItem.iCursor = pParse.nTab++;
        if (srcListItem.pSelect != null)
          Sqlite3.sqlite3SrcListAssignCursors(pParse, srcListItem.pSelect.pSrc);
      }
    }

    private static void sqlite3SrcListDelete(Sqlite3.sqlite3 db, ref Sqlite3.SrcList pList)
    {
      if (pList == null)
        return;
      for (int index = 0; index < (int) pList.nSrc; ++index)
      {
        Sqlite3.SrcList_item srcListItem = pList.a[index];
        Sqlite3.sqlite3DbFree(db, ref srcListItem.zDatabase);
        Sqlite3.sqlite3DbFree(db, ref srcListItem.zName);
        Sqlite3.sqlite3DbFree(db, ref srcListItem.zAlias);
        Sqlite3.sqlite3DbFree(db, ref srcListItem.zIndex);
        Sqlite3.sqlite3DeleteTable(db, ref srcListItem.pTab);
        Sqlite3.sqlite3SelectDelete(db, ref srcListItem.pSelect);
        Sqlite3.sqlite3ExprDelete(db, ref srcListItem.pOn);
        Sqlite3.sqlite3IdListDelete(db, ref srcListItem.pUsing);
      }
      Sqlite3.sqlite3DbFree<Sqlite3.SrcList>(db, ref pList);
    }

    private static Sqlite3.SrcList sqlite3SrcListAppendFromTerm(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList p,
      int null_3,
      int null_4,
      Sqlite3.Token pAlias,
      Sqlite3.Select pSubquery,
      Sqlite3.Expr pOn,
      Sqlite3.IdList pUsing)
    {
      return Sqlite3.sqlite3SrcListAppendFromTerm(pParse, p, (Sqlite3.Token) null, (Sqlite3.Token) null, pAlias, pSubquery, pOn, pUsing);
    }

    private static Sqlite3.SrcList sqlite3SrcListAppendFromTerm(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList p,
      Sqlite3.Token pTable,
      Sqlite3.Token pDatabase,
      Sqlite3.Token pAlias,
      int null_6,
      Sqlite3.Expr pOn,
      Sqlite3.IdList pUsing)
    {
      return Sqlite3.sqlite3SrcListAppendFromTerm(pParse, p, pTable, pDatabase, pAlias, (Sqlite3.Select) null, pOn, pUsing);
    }

    private static Sqlite3.SrcList sqlite3SrcListAppendFromTerm(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList p,
      Sqlite3.Token pTable,
      Sqlite3.Token pDatabase,
      Sqlite3.Token pAlias,
      Sqlite3.Select pSubquery,
      Sqlite3.Expr pOn,
      Sqlite3.IdList pUsing)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (p == null && (pOn != null || pUsing != null))
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s", pOn != null ? (object) "ON" : (object) "USING");
        Sqlite3.sqlite3ExprDelete(db, ref pOn);
        Sqlite3.sqlite3IdListDelete(db, ref pUsing);
        Sqlite3.sqlite3SelectDelete(db, ref pSubquery);
        return (Sqlite3.SrcList) null;
      }
      p = Sqlite3.sqlite3SrcListAppend(db, p, pTable, pDatabase);
      Sqlite3.SrcList_item srcListItem = p.a[(int) p.nSrc - 1];
      if (pAlias.n != 0)
        srcListItem.zAlias = Sqlite3.sqlite3NameFromToken(db, pAlias);
      srcListItem.pSelect = pSubquery;
      srcListItem.pOn = pOn;
      srcListItem.pUsing = pUsing;
      return p;
    }

    private static void sqlite3SrcListIndexedBy(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList p,
      Sqlite3.Token pIndexedBy)
    {
      if (p == null || !Sqlite3.ALWAYS(p.nSrc > (short) 0))
        return;
      Sqlite3.SrcList_item srcListItem = p.a[(int) p.nSrc - 1];
      if (pIndexedBy.n == 1 && pIndexedBy.z == null)
        srcListItem.notIndexed = (byte) 1;
      else
        srcListItem.zIndex = Sqlite3.sqlite3NameFromToken(pParse.db, pIndexedBy);
    }

    private static void sqlite3SrcListShiftJoinType(Sqlite3.SrcList p)
    {
      if (p == null || p.a == null)
        return;
      for (int index = (int) p.nSrc - 1; index > 0; --index)
        p.a[index].jointype = p.a[index - 1].jointype;
      p.a[0].jointype = (byte) 0;
    }

    private static void sqlite3BeginTransaction(Sqlite3.Parse pParse, int type)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.sqlite3AuthCheck(pParse, 22, "BEGIN", (byte[]) null, (byte[]) null) != 0)
        return;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      if (type != 7)
      {
        for (int index = 0; index < db.nDb; ++index)
        {
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 34, index, type == 9 ? 2 : 1);
          Sqlite3.sqlite3VdbeUsesBtree(vdbe, index);
        }
      }
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 33, 0, 0);
    }

    private static void sqlite3CommitTransaction(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.sqlite3AuthCheck(pParse, 22, "COMMIT", (byte[]) null, (byte[]) null) != 0)
        return;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 33, 1, 0);
    }

    private static void sqlite3RollbackTransaction(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.sqlite3AuthCheck(pParse, 22, "ROLLBACK", (byte[]) null, (byte[]) null) != 0)
        return;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 33, 1, 1);
    }

    private static void sqlite3Savepoint(Sqlite3.Parse pParse, int op, Sqlite3.Token pName)
    {
      string pString = Sqlite3.sqlite3NameFromToken(pParse.db, pName);
      if (pString == null)
        return;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        Sqlite3.sqlite3DbFree(pParse.db, ref pString);
      else
        Sqlite3.sqlite3VdbeAddOp4(vdbe, 32, op, 0, 0, pString, -1);
    }

    private static int sqlite3OpenTempDatabase(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (db.aDb[1].pBt == null && pParse.explain == (byte) 0)
      {
        Sqlite3.Btree ppBtree = (Sqlite3.Btree) null;
        int num = Sqlite3.sqlite3BtreeOpen(db.pVfs, (string) null, db, ref ppBtree, 0, 542);
        if (num != 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "unable to open a temporary database file for storing temporary tables");
          pParse.rc = num;
          return 1;
        }
        db.aDb[1].pBt = ppBtree;
        Sqlite3.sqlite3BtreeSetPageSize(ppBtree, db.nextPagesize, -1, 0);
      }
      return 0;
    }

    private static void sqlite3CodeVerifySchema(Sqlite3.Parse pParse, int iDb)
    {
      Sqlite3.Parse toplevel = Sqlite3.sqlite3ParseToplevel(pParse);
      if (toplevel.cookieGoto == 0)
      {
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(toplevel);
        if (vdbe == null)
          return;
        toplevel.cookieGoto = Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, 0) + 1;
      }
      if (iDb < 0)
        return;
      Sqlite3.sqlite3 db = toplevel.db;
      int num = 1 << iDb;
      if ((toplevel.cookieMask & num) != 0)
        return;
      toplevel.cookieMask |= num;
      toplevel.cookieValue[iDb] = db.aDb[iDb].pSchema.schema_cookie;
      if (Sqlite3.OMIT_TEMPDB != 0 || iDb != 1)
        return;
      Sqlite3.sqlite3OpenTempDatabase(toplevel);
    }

    private static void sqlite3CodeVerifyNamedSchema(Sqlite3.Parse pParse, string zDb)
    {
      Sqlite3.sqlite3 db1 = pParse.db;
      for (int iDb = 0; iDb < db1.nDb; ++iDb)
      {
        Sqlite3.Db db2 = db1.aDb[iDb];
        if (db2.pBt != null && (zDb == null || zDb.CompareTo(db2.zName) == 0))
          Sqlite3.sqlite3CodeVerifySchema(pParse, iDb);
      }
    }

    private static void sqlite3BeginWriteOperation(Sqlite3.Parse pParse, int setStatement, int iDb)
    {
      Sqlite3.Parse toplevel = Sqlite3.sqlite3ParseToplevel(pParse);
      Sqlite3.sqlite3CodeVerifySchema(pParse, iDb);
      toplevel.writeMask |= 1 << iDb;
      toplevel.isMultiWrite |= (byte) setStatement;
    }

    private static void sqlite3MultiWrite(Sqlite3.Parse pParse) => Sqlite3.sqlite3ParseToplevel(pParse).isMultiWrite = (byte) 1;

    private static void sqlite3MayAbort(Sqlite3.Parse pParse) => Sqlite3.sqlite3ParseToplevel(pParse).mayAbort = (byte) 1;

    private static void sqlite3HaltConstraint(
      Sqlite3.Parse pParse,
      int onError,
      string p4,
      int p4type)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (onError == 2)
        Sqlite3.sqlite3MayAbort(pParse);
      int p2 = onError;
      string pP4 = p4;
      int p4type1 = p4type;
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 6, 19, p2, 0, pP4, p4type1);
    }

    private static void sqlite3HaltConstraint(
      Sqlite3.Parse pParse,
      int onError,
      byte[] p4,
      int p4type)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (onError == 2)
        Sqlite3.sqlite3MayAbort(pParse);
      int p2 = onError;
      byte[] pP4 = p4;
      int p4type1 = p4type;
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 6, 19, p2, 0, pP4, p4type1);
    }

    private static bool collationMatch(string zColl, Sqlite3.Index pIndex)
    {
      for (int index = 0; index < pIndex.nColumn; ++index)
      {
        if (pIndex.azColl[index].Equals(zColl, StringComparison.InvariantCultureIgnoreCase))
          return true;
      }
      return false;
    }

    private static void reindexTable(Sqlite3.Parse pParse, Sqlite3.Table pTab, string zColl)
    {
      for (Sqlite3.Index pIndex = pTab.pIndex; pIndex != null; pIndex = pIndex.pNext)
      {
        if (zColl == null || Sqlite3.collationMatch(zColl, pIndex))
        {
          int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
          Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index);
          Sqlite3.sqlite3RefillIndex(pParse, pIndex, -1);
        }
      }
    }

    private static void reindexDatabases(Sqlite3.Parse pParse, string zColl)
    {
      Sqlite3.sqlite3 db = pParse.db;
      for (int index = 0; index < db.nDb; ++index)
      {
        for (Sqlite3.HashElem hashElem = db.aDb[index].pSchema.tblHash.first; hashElem != null; hashElem = hashElem.next)
        {
          Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
          Sqlite3.reindexTable(pParse, data, zColl);
        }
      }
    }

    private static void sqlite3Reindex(Sqlite3.Parse pParse, int null_2, int null_3) => Sqlite3.sqlite3Reindex(pParse, (Sqlite3.Token) null, (Sqlite3.Token) null);

    private static void sqlite3Reindex(
      Sqlite3.Parse pParse,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Token pUnqual = new Sqlite3.Token();
      if (Sqlite3.sqlite3ReadSchema(pParse) != 0)
        return;
      if (pName1 == null)
      {
        Sqlite3.reindexDatabases(pParse, (string) null);
      }
      else
      {
        if (Sqlite3.NEVER(pName2 == null) || pName2.z == null || pName2.z.Length == 0)
        {
          string pString = Sqlite3.sqlite3NameFromToken(pParse.db, pName1);
          if (pString == null)
            return;
          if (Sqlite3.sqlite3FindCollSeq(db, Sqlite3.ENC(db), pString, (byte) 0) != null)
          {
            Sqlite3.reindexDatabases(pParse, pString);
            Sqlite3.sqlite3DbFree(db, ref pString);
            return;
          }
          Sqlite3.sqlite3DbFree(db, ref pString);
        }
        int iDb = Sqlite3.sqlite3TwoPartName(pParse, pName1, pName2, ref pUnqual);
        if (iDb < 0)
          return;
        string pString1 = Sqlite3.sqlite3NameFromToken(db, pUnqual);
        if (pString1 == null)
          return;
        string zName = db.aDb[iDb].zName;
        Sqlite3.Table table = Sqlite3.sqlite3FindTable(db, pString1, zName);
        if (table != null)
        {
          Sqlite3.reindexTable(pParse, table, (string) null);
          Sqlite3.sqlite3DbFree(db, ref pString1);
        }
        else
        {
          Sqlite3.Index index = Sqlite3.sqlite3FindIndex(db, pString1, zName);
          Sqlite3.sqlite3DbFree(db, ref pString1);
          if (index != null)
          {
            Sqlite3.sqlite3BeginWriteOperation(pParse, 0, iDb);
            Sqlite3.sqlite3RefillIndex(pParse, index, -1);
          }
          else
            Sqlite3.sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
        }
      }
    }

    private static Sqlite3.KeyInfo sqlite3IndexKeyinfo(
      Sqlite3.Parse pParse,
      Sqlite3.Index pIdx)
    {
      int nColumn = pIdx.nColumn;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.KeyInfo pT = new Sqlite3.KeyInfo();
      if (pT != null)
      {
        pT.db = pParse.db;
        pT.aSortOrder = new byte[nColumn];
        pT.aColl = new Sqlite3.CollSeq[nColumn];
        for (int index = 0; index < nColumn; ++index)
        {
          string zName = pIdx.azColl[index];
          pT.aColl[index] = Sqlite3.sqlite3LocateCollSeq(pParse, zName);
          pT.aSortOrder[index] = pIdx.aSortOrder[index];
        }
        pT.nField = (ushort) nColumn;
      }
      if (pParse.nErr != 0)
      {
        pT = (Sqlite3.KeyInfo) null;
        Sqlite3.sqlite3DbFree<Sqlite3.KeyInfo>(db, ref pT);
      }
      return pT;
    }

    private static void callCollNeeded(Sqlite3.sqlite3 db, int enc, string zName)
    {
      if (db.xCollNeeded == null)
        return;
      string pString = zName;
      if (pString == null)
        return;
      db.xCollNeeded(db.pCollNeededArg, db, enc, pString);
      Sqlite3.sqlite3DbFree(db, ref pString);
    }

    private static int synthCollSeq(Sqlite3.sqlite3 db, Sqlite3.CollSeq pColl)
    {
      string zName = pColl.zName;
      byte[] numArray = new byte[3]
      {
        (byte) 3,
        (byte) 2,
        (byte) 1
      };
      for (int index = 0; index < 3; ++index)
      {
        Sqlite3.CollSeq collSeq = Sqlite3.sqlite3FindCollSeq(db, numArray[index], zName, (byte) 0);
        if (collSeq.xCmp != null)
        {
          pColl = collSeq.Copy();
          pColl.xDel = (Sqlite3.dxDelCollSeq) null;
          return 0;
        }
      }
      return 1;
    }

    private static Sqlite3.CollSeq sqlite3GetCollSeq(
      Sqlite3.sqlite3 db,
      byte enc,
      Sqlite3.CollSeq pColl,
      string zName)
    {
      Sqlite3.CollSeq pColl1 = pColl ?? Sqlite3.sqlite3FindCollSeq(db, enc, zName, (byte) 0);
      if (pColl1 == null || pColl1.xCmp == null)
      {
        Sqlite3.callCollNeeded(db, (int) enc, zName);
        pColl1 = Sqlite3.sqlite3FindCollSeq(db, enc, zName, (byte) 0);
      }
      if (pColl1 != null && pColl1.xCmp == null && Sqlite3.synthCollSeq(db, pColl1) != 0)
        pColl1 = (Sqlite3.CollSeq) null;
      return pColl1;
    }

    private static int sqlite3CheckCollSeq(Sqlite3.Parse pParse, Sqlite3.CollSeq pColl)
    {
      if (pColl != null)
      {
        string zName = pColl.zName;
        Sqlite3.sqlite3 db = pParse.db;
        Sqlite3.CollSeq collSeq = Sqlite3.sqlite3GetCollSeq(db, Sqlite3.ENC(db), pColl, zName);
        if (collSeq == null)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "no such collation sequence: %s", (object) zName);
          ++pParse.nErr;
          return 1;
        }
        if (collSeq != pColl)
        {
          pColl.enc = collSeq.enc;
          pColl.pUser = collSeq.pUser;
          pColl.type = collSeq.type;
          pColl.xCmp = collSeq.xCmp;
          pColl.xDel = collSeq.xDel;
        }
      }
      return 0;
    }

    private static Sqlite3.CollSeq[] findCollSeqEntry(
      Sqlite3.sqlite3 db,
      string zName,
      int create)
    {
      int nKey = Sqlite3.sqlite3Strlen30(zName);
      Sqlite3.CollSeq[] data = Sqlite3.sqlite3HashFind<Sqlite3.CollSeq[]>(db.aCollSeq, zName, nKey, (Sqlite3.CollSeq[]) null);
      if (data == null && create != 0)
      {
        data = new Sqlite3.CollSeq[3];
        if (data != null)
        {
          Sqlite3.CollSeq collSeq = (Sqlite3.CollSeq) null;
          data[0] = new Sqlite3.CollSeq();
          data[0].zName = zName;
          data[0].enc = (byte) 1;
          data[1] = new Sqlite3.CollSeq();
          data[1].zName = zName;
          data[1].enc = (byte) 2;
          data[2] = new Sqlite3.CollSeq();
          data[2].zName = zName;
          data[2].enc = (byte) 3;
          Sqlite3.CollSeq[] collSeqArray = Sqlite3.sqlite3HashInsert<Sqlite3.CollSeq[]>(ref db.aCollSeq, data[0].zName, nKey, data);
          if (collSeqArray != null)
            collSeq = collSeqArray[0];
          if (collSeq != null)
            data = (Sqlite3.CollSeq[]) null;
        }
      }
      return data;
    }

    private static Sqlite3.CollSeq sqlite3FindCollSeq(
      Sqlite3.sqlite3 db,
      byte enc,
      string zName,
      byte create)
    {
      Sqlite3.CollSeq[] collSeqArray;
      if (zName != null)
      {
        collSeqArray = Sqlite3.findCollSeqEntry(db, zName, (int) create);
      }
      else
      {
        collSeqArray = new Sqlite3.CollSeq[(int) enc];
        collSeqArray[(int) enc - 1] = db.pDfltColl;
      }
      if (collSeqArray == null)
        return (Sqlite3.CollSeq) null;
      --enc;
      return collSeqArray[(int) enc];
    }

    private static int matchQuality(Sqlite3.FuncDef p, int nArg, int enc)
    {
      int num = 0;
      if (p.nArg == (short) -1 || (int) p.nArg == nArg || nArg == -1 && (p.xFunc != null || p.xStep != null))
      {
        num = 1;
        if ((int) p.nArg == nArg || nArg == -1)
          num = 4;
        if (enc == (int) p.iPrefEnc)
          num += 2;
        else if (enc == 2 && p.iPrefEnc == (byte) 3 || enc == 3 && p.iPrefEnc == (byte) 2)
          ++num;
      }
      return num;
    }

    private static Sqlite3.FuncDef functionSearch(
      Sqlite3.FuncDefHash pHash,
      int h,
      string zFunc,
      int nFunc)
    {
      for (Sqlite3.FuncDef pHash1 = pHash.a[h]; pHash1 != null; pHash1 = pHash1.pHash)
      {
        if (pHash1.zName.Length == nFunc && pHash1.zName.StartsWith(zFunc, StringComparison.InvariantCultureIgnoreCase))
          return pHash1;
      }
      return (Sqlite3.FuncDef) null;
    }

    private static void sqlite3FuncDefInsert(Sqlite3.FuncDefHash pHash, Sqlite3.FuncDef pDef)
    {
      int nFunc = Sqlite3.sqlite3Strlen30(pDef.zName);
      byte index = (byte) pDef.zName[0];
      int h = (Sqlite3.sqlite3UpperToLower[(int) index] + nFunc) % Sqlite3.ArraySize<Sqlite3.FuncDef>(pHash.a);
      Sqlite3.FuncDef funcDef = Sqlite3.functionSearch(pHash, h, pDef.zName, nFunc);
      if (funcDef != null)
      {
        pDef.pNext = funcDef.pNext;
        funcDef.pNext = pDef;
      }
      else
      {
        pDef.pNext = (Sqlite3.FuncDef) null;
        pDef.pHash = pHash.a[h];
        pHash.a[h] = pDef;
      }
    }

    private static Sqlite3.FuncDef sqlite3FindFunction(
      Sqlite3.sqlite3 db,
      string zName,
      int nName,
      int nArg,
      byte enc,
      byte createFlag)
    {
      Sqlite3.FuncDef pDef = (Sqlite3.FuncDef) null;
      int num1 = 0;
      int h1 = (Sqlite3.sqlite3UpperToLower[(int) (byte) zName[0]] + nName) % Sqlite3.ArraySize<Sqlite3.FuncDef>(db.aFunc.a);
      for (Sqlite3.FuncDef p = Sqlite3.functionSearch(db.aFunc, h1, zName, nName); p != null; p = p.pNext)
      {
        int num2 = Sqlite3.matchQuality(p, nArg, (int) enc);
        if (num2 > num1)
        {
          pDef = p;
          num1 = num2;
        }
      }
      if (createFlag == (byte) 0 && (pDef == null || (db.flags & 268435456) != 0))
      {
        Sqlite3.FuncDefHash sqlite3GlobalFunctions = Sqlite3.sqlite3GlobalFunctions;
        num1 = 0;
        int h2 = h1;
        string zFunc = zName;
        int nFunc = nName;
        for (Sqlite3.FuncDef p = Sqlite3.functionSearch(sqlite3GlobalFunctions, h2, zFunc, nFunc); p != null; p = p.pNext)
        {
          int num3 = Sqlite3.matchQuality(p, nArg, (int) enc);
          if (num3 > num1)
          {
            pDef = p;
            num1 = num3;
          }
        }
      }
      if (createFlag != (byte) 0 && (num1 < 6 || (int) pDef.nArg != nArg) && (pDef = new Sqlite3.FuncDef()) != null)
      {
        pDef.nArg = (short) nArg;
        pDef.iPrefEnc = enc;
        pDef.zName = zName;
        Sqlite3.sqlite3FuncDefInsert(db.aFunc, pDef);
      }
      return pDef != null && (pDef.xStep != null || pDef.xFunc != null || createFlag != (byte) 0) ? pDef : (Sqlite3.FuncDef) null;
    }

    private static void sqlite3SchemaClear(Sqlite3.Schema p)
    {
      Sqlite3.Schema schema = p;
      Sqlite3.Hash tblHash = schema.tblHash;
      Sqlite3.Hash trigHash = schema.trigHash;
      Sqlite3.sqlite3HashInit(schema.trigHash);
      Sqlite3.sqlite3HashClear(schema.idxHash);
      for (Sqlite3.HashElem E = Sqlite3.sqliteHashFirst(trigHash); E != null; E = Sqlite3.sqliteHashNext(E))
      {
        Sqlite3.Trigger pTrigger = (Sqlite3.Trigger) Sqlite3.sqliteHashData(E);
        Sqlite3.sqlite3DeleteTrigger((Sqlite3.sqlite3) null, ref pTrigger);
      }
      Sqlite3.sqlite3HashClear(trigHash);
      Sqlite3.sqlite3HashInit(schema.trigHash);
      for (Sqlite3.HashElem hashElem = tblHash.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
        Sqlite3.sqlite3DeleteTable((Sqlite3.sqlite3) null, ref data);
      }
      Sqlite3.sqlite3HashClear(tblHash);
      Sqlite3.sqlite3HashClear(schema.fkeyHash);
      schema.pSeqTab = (Sqlite3.Table) null;
      if (((int) schema.flags & 1) != 0)
      {
        ++schema.iGeneration;
        schema.flags &= (ushort) 65534;
      }
      p.Clear();
    }

    private static Sqlite3.Schema sqlite3SchemaGet(Sqlite3.sqlite3 db, Sqlite3.Btree pBt)
    {
      Sqlite3.Schema schema = pBt == null ? new Sqlite3.Schema() : Sqlite3.sqlite3BtreeSchema(pBt, -1, new Sqlite3.dxFreeSchema(Sqlite3.sqlite3SchemaClear));
      if (schema != null && schema.file_format == (byte) 0)
      {
        Sqlite3.sqlite3HashInit(schema.tblHash);
        Sqlite3.sqlite3HashInit(schema.idxHash);
        Sqlite3.sqlite3HashInit(schema.trigHash);
        Sqlite3.sqlite3HashInit(schema.fkeyHash);
        schema.enc = (byte) 1;
      }
      return schema;
    }

    private static bool IdChar(byte C) => ((uint) Sqlite3.sqlite3CtypeMap[(int) C] & 70U) > 0U;

    public static int sqlite3_complete(string zSql)
    {
      int index1 = 0;
      byte[][] numArray = new byte[8][]
      {
        new byte[8]
        {
          (byte) 1,
          (byte) 0,
          (byte) 2,
          (byte) 3,
          (byte) 4,
          (byte) 2,
          (byte) 2,
          (byte) 2
        },
        new byte[8]
        {
          (byte) 1,
          (byte) 1,
          (byte) 2,
          (byte) 3,
          (byte) 4,
          (byte) 2,
          (byte) 2,
          (byte) 2
        },
        new byte[8]
        {
          (byte) 1,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        },
        new byte[8]
        {
          (byte) 1,
          (byte) 3,
          (byte) 3,
          (byte) 2,
          (byte) 4,
          (byte) 2,
          (byte) 2,
          (byte) 2
        },
        new byte[8]
        {
          (byte) 1,
          (byte) 4,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 4,
          (byte) 5,
          (byte) 2
        },
        new byte[8]
        {
          (byte) 6,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5
        },
        new byte[8]
        {
          (byte) 6,
          (byte) 6,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 7
        },
        new byte[8]
        {
          (byte) 1,
          (byte) 7,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5,
          (byte) 5
        }
      };
      for (int index2 = 0; index2 < zSql.Length; ++index2)
      {
        int index3;
        switch (zSql[index2])
        {
          case '\t':
          case '\n':
          case '\f':
          case '\r':
          case ' ':
            index3 = 1;
            break;
          case '"':
          case '\'':
          case '`':
            int num1 = (int) zSql[index2];
            ++index2;
            while (index2 < zSql.Length && (int) zSql[index2] != num1)
              ++index2;
            if (index2 == zSql.Length)
              return 0;
            index3 = 2;
            break;
          case '-':
            if (zSql[index2 + 1] != '-')
            {
              index3 = 2;
              break;
            }
            while (index2 < zSql.Length && zSql[index2] != '\n')
              ++index2;
            if (index2 == zSql.Length)
              return index1 != 1 ? 0 : 1;
            index3 = 1;
            break;
          case '/':
            if (zSql[index2 + 1] != '*')
            {
              index3 = 2;
              break;
            }
            int index4 = index2 + 2;
            while (index4 < zSql.Length && zSql[index4] != '*' || index4 < zSql.Length - 1 && zSql[index4 + 1] != '/')
              ++index4;
            if (index4 == zSql.Length)
              return 0;
            index2 = index4 + 1;
            index3 = 1;
            break;
          case ';':
            index3 = 0;
            break;
          case '[':
            ++index2;
            while (index2 < zSql.Length && zSql[index2] != ']')
              ++index2;
            if (index2 == zSql.Length)
              return 0;
            index3 = 2;
            break;
          default:
            if (Sqlite3.IdChar((byte) zSql[index2]))
            {
              int num2 = 1;
              while (index2 + num2 < zSql.Length && Sqlite3.IdChar((byte) zSql[index2 + num2]))
                ++num2;
              switch (zSql[index2])
              {
                case 'C':
                case 'c':
                  index3 = num2 != 6 || Sqlite3.sqlite3StrNICmp(zSql, index2, "create", 6) != 0 ? 2 : 4;
                  break;
                case 'E':
                case 'e':
                  index3 = num2 != 3 || Sqlite3.sqlite3StrNICmp(zSql, index2, "end", 3) != 0 ? (num2 != 7 || Sqlite3.sqlite3StrNICmp(zSql, index2, "explain", 7) != 0 ? 2 : 3) : 7;
                  break;
                case 'T':
                case 't':
                  index3 = num2 != 7 || Sqlite3.sqlite3StrNICmp(zSql, index2, "trigger", 7) != 0 ? (num2 != 4 || Sqlite3.sqlite3StrNICmp(zSql, index2, "temp", 4) != 0 ? (num2 != 9 || Sqlite3.sqlite3StrNICmp(zSql, index2, "temporary", 9) != 0 ? 2 : 5) : 5) : 6;
                  break;
                default:
                  index3 = 2;
                  break;
              }
              index2 += num2 - 1;
              break;
            }
            index3 = 2;
            break;
        }
        index1 = (int) numArray[index1][index3];
      }
      return index1 != 1 ? 0 : 1;
    }

    private static void CODEC_TRACE(string T, params object[] ap)
    {
    }

    private static void sqlite3pager_get_codec(Sqlite3.Pager pPager, ref Sqlite3.codec_ctx ctx) => ctx = pPager.pCodec;

    private static int sqlite3pager_is_mj_pgno(Sqlite3.Pager pPager, uint pgno) => (int) Sqlite3.PAGER_MJ_PGNO(pPager) != (int) pgno ? 0 : 1;

    private static Sqlite3.sqlite3_file sqlite3Pager_get_fd(Sqlite3.Pager pPager) => !Sqlite3.isOpen(pPager.fd) ? (Sqlite3.sqlite3_file) null : pPager.fd;

    private static void sqlite3pager_sqlite3PagerSetCodec(
      Sqlite3.Pager pPager,
      Sqlite3.dxCodec xCodec,
      Sqlite3.dxCodecSizeChng xCodecSizeChng,
      Sqlite3.dxCodecFree xCodecFree,
      Sqlite3.codec_ctx pCodec)
    {
      Sqlite3.sqlite3PagerSetCodec(pPager, xCodec, xCodecSizeChng, xCodecFree, pCodec);
    }

    private static void codec_free(ref byte[] ptr, int sz)
    {
      if (ptr == null)
        return;
      if (sz > 0)
        Array.Clear((Array) ptr, 0, sz);
      Sqlite3.sqlite3_free(ref ptr);
    }

    private static int cipher_ctx_set_pass(Sqlite3.cipher_ctx ctx, string zKey, int nKey)
    {
      ctx.pass = (string) null;
      ctx.pass_sz = nKey;
      if (string.IsNullOrEmpty(zKey) || nKey <= 0)
        return 1;
      ctx.pass = zKey;
      return 0;
    }

    private static int cipher_ctx_init(ref Sqlite3.cipher_ctx iCtx)
    {
      iCtx = new Sqlite3.cipher_ctx();
      return 0;
    }

    private static void cipher_ctx_free(ref Sqlite3.cipher_ctx ictx)
    {
      Sqlite3.cipher_ctx cipherCtx = ictx;
      Sqlite3.CODEC_TRACE("cipher_ctx_free: entered ictx=%d\n", (object) ictx);
      cipherCtx.pass = (string) null;
      if (cipherCtx.key != null)
        Array.Clear((Array) cipherCtx.key, 0, cipherCtx.key.Length);
      if (cipherCtx.iv != null)
        Array.Clear((Array) cipherCtx.iv, 0, cipherCtx.iv.Length);
      ictx = new Sqlite3.cipher_ctx();
    }

    private static int cipher_ctx_copy(Sqlite3.cipher_ctx target, Sqlite3.cipher_ctx source)
    {
      Sqlite3.CODEC_TRACE("cipher_ctx_copy: entered target=%d, source=%d\n", (object) target, (object) source);
      source.CopyTo(target);
      return 0;
    }

    private static int cipher_ctx_cmp(Sqlite3.cipher_ctx c1, Sqlite3.cipher_ctx c2)
    {
      Sqlite3.CODEC_TRACE("cipher_ctx_cmp: entered c1=%d c2=%d\n", (object) c1, (object) c2);
      return c1.key_sz == c2.key_sz && c1.pass_sz == c2.pass_sz && c1.pass == c2.pass ? 0 : 1;
    }

    private static void codec_ctx_free(ref Sqlite3.codec_ctx iCtx)
    {
      Sqlite3.codec_ctx codecCtx = iCtx;
      Sqlite3.CODEC_TRACE("codec_ctx_free: entered iCtx=%d\n", (object) iCtx);
      Sqlite3.cipher_ctx_free(ref codecCtx.read_ctx);
      Sqlite3.cipher_ctx_free(ref codecCtx.write_ctx);
      iCtx = new Sqlite3.codec_ctx();
    }

    private static int codec_key_derive(Sqlite3.codec_ctx ctx, Sqlite3.cipher_ctx c_ctx)
    {
      Sqlite3.CODEC_TRACE("codec_key_derive: entered c_ctx.pass=%s, c_ctx.pass_sz=%d ctx.iv=%d ctx.iv_sz=%d c_ctx.kdf_iter=%d c_ctx.key_sz=%d\n", (object) c_ctx.pass, (object) c_ctx.pass_sz, (object) c_ctx.iv, (object) c_ctx.iv_sz, (object) c_ctx.key_sz);
      if (c_ctx.pass == null || c_ctx.pass_sz <= 0)
        return 1;
      if (c_ctx.pass_sz == c_ctx.key_sz * 2 + 3 && c_ctx.pass.StartsWith("x'", StringComparison.InvariantCultureIgnoreCase))
      {
        int n = c_ctx.pass_sz - 3;
        string z = c_ctx.pass.Substring(2);
        Sqlite3.CODEC_TRACE("codec_key_derive: deriving key from hex\n");
        c_ctx.key = Sqlite3.sqlite3HexToBlob((Sqlite3.sqlite3) null, z, n);
      }
      else
      {
        Sqlite3.CODEC_TRACE("codec_key_derive: deriving key using AES256\n");
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(c_ctx.pass, c_ctx.iv, 2010);
        c_ctx.key_sz = 32;
        c_ctx.key = rfc2898DeriveBytes.GetBytes(c_ctx.key_sz);
      }
      c_ctx.encryptor = Sqlite3.Aes.CreateEncryptor(c_ctx.key, c_ctx.iv);
      c_ctx.decryptor = Sqlite3.Aes.CreateDecryptor(c_ctx.key, c_ctx.iv);
      return 0;
    }

    private static int codec_cipher(
      Sqlite3.cipher_ctx ctx,
      uint pgno,
      int mode,
      int size,
      byte[] bIn,
      byte[] bOut)
    {
      Sqlite3.CODEC_TRACE("codec_cipher:entered pgno=%d, mode=%d, size=%d\n", (object) pgno, (object) mode, (object) size);
      if (ctx.key_sz == 0)
      {
        Array.Copy((Array) bIn, (Array) bOut, bIn.Length);
        return 0;
      }
      MemoryStream memoryStream = new MemoryStream();
      CryptoStream cryptoStream = mode != 1 ? new CryptoStream((Stream) memoryStream, ctx.decryptor, CryptoStreamMode.Write) : new CryptoStream((Stream) memoryStream, ctx.encryptor, CryptoStreamMode.Write);
      cryptoStream.Write(bIn, 0, size);
      cryptoStream.FlushFinalBlock();
      memoryStream.Position = 0L;
      memoryStream.Read(bOut, 0, (int) memoryStream.Length);
      cryptoStream.Close();
      memoryStream.Close();
      return 0;
    }

    private static int codec_set_cipher_name(
      Sqlite3.sqlite3 db,
      int nDb,
      string cipher_name,
      int for_ctx)
    {
      Sqlite3.Db db1 = db.aDb[nDb];
      Sqlite3.CODEC_TRACE("codec_set_cipher_name: entered db=%d nDb=%d cipher_name=%s for_ctx=%d\n", (object) db, (object) nDb, (object) cipher_name, (object) for_ctx);
      if (db1.pBt == null)
        return 1;
      Sqlite3.codec_ctx ctx = (Sqlite3.codec_ctx) null;
      Sqlite3.sqlite3pager_get_codec(db1.pBt.pBt.pPager, ref ctx);
      Sqlite3.cipher_ctx source = for_ctx != 0 ? ctx.write_ctx : ctx.read_ctx;
      source.derive_key = true;
      if (for_ctx == 2)
        Sqlite3.cipher_ctx_copy(for_ctx != 0 ? ctx.read_ctx : ctx.write_ctx, source);
      return 0;
    }

    private static int codec_set_pass_key(
      Sqlite3.sqlite3 db,
      int nDb,
      string zKey,
      int nKey,
      int for_ctx)
    {
      Sqlite3.Db db1 = db.aDb[nDb];
      Sqlite3.CODEC_TRACE("codec_set_pass_key: entered db=%d nDb=%d cipher_name=%s nKey=%d for_ctx=%d\n", (object) db, (object) nDb, (object) zKey, (object) nKey, (object) for_ctx);
      if (db1.pBt == null)
        return 1;
      Sqlite3.codec_ctx ctx = (Sqlite3.codec_ctx) null;
      Sqlite3.sqlite3pager_get_codec(db1.pBt.pBt.pPager, ref ctx);
      Sqlite3.cipher_ctx cipherCtx = for_ctx != 0 ? ctx.write_ctx : ctx.read_ctx;
      Sqlite3.cipher_ctx_set_pass(cipherCtx, zKey, nKey);
      cipherCtx.derive_key = true;
      if (for_ctx == 2)
        Sqlite3.cipher_ctx_copy(for_ctx != 0 ? ctx.read_ctx : ctx.write_ctx, cipherCtx);
      return 0;
    }

    private static byte[] sqlite3Codec(Sqlite3.codec_ctx iCtx, byte[] data, uint pgno, int mode)
    {
      Sqlite3.codec_ctx ctx = iCtx;
      int pageSize = Sqlite3.sqlite3BtreeGetPageSize(ctx.pBt);
      int num = 0;
      byte[] numArray = data;
      Sqlite3.CODEC_TRACE("sqlite3Codec: entered pgno=%d, mode=%d, ctx.mode_rekey=%d, pg_sz=%d\n", (object) pgno, (object) mode, (object) ctx.mode_rekey, (object) pageSize);
      if (ctx.read_ctx.derive_key)
      {
        Sqlite3.codec_key_derive(ctx, ctx.read_ctx);
        ctx.read_ctx.derive_key = false;
      }
      if (ctx.write_ctx.derive_key)
      {
        if (Sqlite3.cipher_ctx_cmp(ctx.write_ctx, ctx.read_ctx) == 0)
        {
          Sqlite3.cipher_ctx_copy(ctx.write_ctx, ctx.read_ctx);
        }
        else
        {
          Sqlite3.codec_key_derive(ctx, ctx.write_ctx);
          ctx.write_ctx.derive_key = false;
        }
      }
      Sqlite3.CODEC_TRACE("sqlite3Codec: switch mode=%d offset=%d\n", (object) mode, (object) num);
      if (ctx.buffer.Length != pageSize)
        ctx.buffer = Sqlite3.sqlite3MemMalloc(pageSize);
      switch (mode)
      {
        case 3:
          Sqlite3.codec_cipher(ctx.read_ctx, pgno, 0, pageSize, numArray, ctx.buffer);
          if (pgno == 1U)
            Buffer.BlockCopy((Array) Encoding.UTF8.GetBytes("SQLite format 3\0"), 0, (Array) ctx.buffer, 0, 16);
          Buffer.BlockCopy((Array) ctx.buffer, 0, (Array) numArray, 0, pageSize);
          return numArray;
        case 6:
          if (pgno == 1U)
            Buffer.BlockCopy((Array) ctx.write_ctx.iv, 0, (Array) ctx.buffer, 0, 16);
          Sqlite3.codec_cipher(ctx.write_ctx, pgno, 1, pageSize, numArray, ctx.buffer);
          return ctx.buffer;
        case 7:
          if (pgno == 1U)
            Buffer.BlockCopy((Array) ctx.read_ctx.iv, 0, (Array) ctx.buffer, 0, 16);
          Sqlite3.codec_cipher(ctx.read_ctx, pgno, 1, pageSize, numArray, ctx.buffer);
          return ctx.buffer;
        default:
          return numArray;
      }
    }

    private static int sqlite3CodecAttach(Sqlite3.sqlite3 db, int nDb, string zKey, int nKey)
    {
      Sqlite3.Db db1 = db.aDb[nDb];
      Sqlite3.CODEC_TRACE("sqlite3CodecAttach: entered nDb=%d zKey=%s, nKey=%d\n", (object) nDb, (object) zKey, (object) nKey);
      if (zKey != null && db1.pBt != null)
      {
        Sqlite3.Aes.KeySize = 256;
        Sqlite3.Pager pPager = db1.pBt.pBt.pPager;
        Sqlite3.codec_ctx pCodec = new Sqlite3.codec_ctx();
        pCodec.pBt = db1.pBt;
        int num1;
        if ((num1 = Sqlite3.cipher_ctx_init(ref pCodec.read_ctx)) != 0)
          return num1;
        int num2;
        if ((num2 = Sqlite3.cipher_ctx_init(ref pCodec.write_ctx)) != 0)
          return num2;
        pCodec.buffer = Sqlite3.sqlite3MemMalloc(Sqlite3.sqlite3BtreeGetPageSize(pCodec.pBt));
        pCodec.read_ctx.iv_sz = 16;
        pCodec.read_ctx.iv = new byte[pCodec.read_ctx.iv_sz];
        Buffer.BlockCopy((Array) Encoding.UTF8.GetBytes("SQLite format 3\0"), 0, (Array) pCodec.read_ctx.iv, 0, 16);
        Sqlite3.sqlite3pager_sqlite3PagerSetCodec(Sqlite3.sqlite3BtreePager(db1.pBt), new Sqlite3.dxCodec(Sqlite3.sqlite3Codec), (Sqlite3.dxCodecSizeChng) null, new Sqlite3.dxCodecFree(Sqlite3.sqlite3FreeCodecArg), pCodec);
        Sqlite3.codec_set_cipher_name(db, nDb, "aes-256-cbc", 0);
        Sqlite3.codec_set_pass_key(db, nDb, zKey, nKey, 0);
        Sqlite3.cipher_ctx_copy(pCodec.write_ctx, pCodec.read_ctx);
      }
      return 0;
    }

    private static void sqlite3FreeCodecArg(ref Sqlite3.codec_ctx pCodecArg)
    {
      if (pCodecArg == null)
        return;
      Sqlite3.codec_ctx_free(ref pCodecArg);
    }

    private static void sqlite3_activate_see(string zPassword)
    {
    }

    public static int sqlite3_key(Sqlite3.sqlite3 db, string pKey, int nKey)
    {
      Sqlite3.CODEC_TRACE("sqlite3_key: entered db=%d pKey=%s nKey=%d\n", (object) db, (object) pKey, (object) nKey);
      if (db == null || pKey == null)
        return 1;
      Sqlite3.sqlite3CodecAttach(db, 0, pKey, nKey);
      Sqlite3.BtShared pBt = db.aDb[0].pBt.pBt;
      byte[] O = Sqlite3.sqlite3MemMalloc((int) pBt.pageSize);
      Sqlite3.sqlite3PagerReadFileheader(pBt.pPager, O.Length, O);
      if (Sqlite3.sqlite3Get4byte(O) > 0U)
      {
        Sqlite3.CODEC2(pBt.pPager, O, 2U, 3, ref O);
        byte nReserve = O[20];
        pBt.pageSize = (uint) ((int) O[16] << 8 | (int) O[17] << 16);
        if (pBt.pageSize < 512U || pBt.pageSize > (uint) ushort.MaxValue || ((int) pBt.pageSize - 1 & (int) pBt.pageSize) != 0)
          pBt.pageSize = 0U;
        pBt.pageSizeFixed = true;
        pBt.autoVacuum = Sqlite3.sqlite3Get4byte(O, 52) > 0U;
        pBt.incrVacuum = Sqlite3.sqlite3Get4byte(O, 64) > 0U;
        Sqlite3.sqlite3PagerSetPagesize(pBt.pPager, ref pBt.pageSize, (int) nReserve);
        pBt.usableSize = (uint) (ushort) (pBt.pageSize - (uint) nReserve);
      }
      return 0;
    }

    private static int sqlite3_rekey(Sqlite3.sqlite3 db, string pKey, int nKey)
    {
      Sqlite3.CODEC_TRACE("sqlite3_rekey: entered db=%d pKey=%s, nKey=%d\n", (object) db, (object) pKey, (object) nKey);
      if (db == null || pKey == null)
        return 1;
      Sqlite3.Db db1 = db.aDb[0];
      Sqlite3.CODEC_TRACE("sqlite3_rekey: database pDb=%d\n", (object) db1);
      if (db1.pBt != null)
      {
        Sqlite3.codec_ctx ctx = (Sqlite3.codec_ctx) null;
        uint pnPage = 0;
        Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
        Sqlite3.Pager pPager = db1.pBt.pBt.pPager;
        Sqlite3.sqlite3pager_get_codec(db1.pBt.pBt.pPager, ref ctx);
        if (ctx == null)
        {
          Sqlite3.CODEC_TRACE("sqlite3_rekey: no codec attached to db, attaching now\n");
          Sqlite3.sqlite3CodecAttach(db, 0, pKey, nKey);
          Sqlite3.sqlite3pager_get_codec(db1.pBt.pBt.pPager, ref ctx);
          Buffer.BlockCopy((Array) Encoding.UTF8.GetBytes("SQLite format 3\0"), 0, (Array) ctx.read_ctx.iv, 0, 16);
          ctx.read_ctx.key_sz = ctx.read_ctx.iv_sz = ctx.read_ctx.pass_sz = 0;
        }
        Sqlite3.codec_set_pass_key(db, 0, pKey, nKey, 1);
        ctx.mode_rekey = 1;
        int num = Sqlite3.sqlite3BtreeBeginTrans(db1.pBt, 1);
        Sqlite3.sqlite3PagerPagecount(pPager, out pnPage);
        for (uint pgno = 1; num == 0 && pgno <= pnPage; ++pgno)
        {
          if (Sqlite3.sqlite3pager_is_mj_pgno(pPager, pgno) == 0)
          {
            num = Sqlite3.sqlite3PagerGet(pPager, pgno, ref ppPage);
            if (num == 0)
            {
              num = Sqlite3.sqlite3PagerWrite(ppPage);
              if (num == 0)
                Sqlite3.sqlite3PagerUnref(ppPage);
            }
          }
        }
        if (num == 0)
        {
          Sqlite3.CODEC_TRACE("sqlite3_rekey: committing\n");
          db.nextPagesize = Sqlite3.sqlite3BtreeGetPageSize(db1.pBt);
          Sqlite3.sqlite3BtreeCommit(db1.pBt);
          if (ctx != null)
            Sqlite3.cipher_ctx_copy(ctx.read_ctx, ctx.write_ctx);
        }
        else
        {
          Sqlite3.CODEC_TRACE("sqlite3_rekey: rollback\n");
          Sqlite3.sqlite3BtreeRollback(db1.pBt);
        }
        ctx.mode_rekey = 0;
      }
      return 0;
    }

    private static void sqlite3CodecGetKey(
      Sqlite3.sqlite3 db,
      int nDb,
      out string zKey,
      out int nKey)
    {
      Sqlite3.Db db1 = db.aDb[nDb];
      Sqlite3.CODEC_TRACE("sqlite3CodecGetKey: entered db=%d, nDb=%d\n", (object) db, (object) nDb);
      if (db1.pBt != null)
      {
        Sqlite3.codec_ctx ctx = (Sqlite3.codec_ctx) null;
        Sqlite3.sqlite3pager_get_codec(db1.pBt.pBt.pPager, ref ctx);
        if (ctx != null)
        {
          zKey = ctx.read_ctx.pass;
          nKey = ctx.read_ctx.pass_sz;
          return;
        }
      }
      zKey = (string) null;
      nKey = 0;
    }

    private static int sqlite3_compileoption_used(string zOptName)
    {
      if (zOptName.EndsWith("="))
        return 0;
      int indexA = 0;
      if (zOptName.StartsWith("SQLITE_", StringComparison.InvariantCultureIgnoreCase))
        indexA = 7;
      if (!string.IsNullOrEmpty(zOptName))
      {
        for (int index = 0; index < Sqlite3.ArraySize<string>(Sqlite3.azCompileOpt); ++index)
        {
          int length = zOptName.Length - indexA < Sqlite3.azCompileOpt[index].Length ? zOptName.Length - indexA : Sqlite3.azCompileOpt[index].Length;
          if (string.Compare(zOptName, indexA, Sqlite3.azCompileOpt[index], 0, length, StringComparison.InvariantCultureIgnoreCase) == 0)
            return 1;
        }
      }
      return 0;
    }

    private static string sqlite3_compileoption_get(int N) => N >= 0 && N < Sqlite3.ArraySize<string>(Sqlite3.azCompileOpt) ? Sqlite3.azCompileOpt[N] : (string) null;

    private static int getDigits(
      string zDate,
      int N0,
      int min0,
      int max0,
      char nextC0,
      ref int pVal0,
      int N1,
      int min1,
      int max1,
      char nextC1,
      ref int pVal1)
    {
      int digits = Sqlite3.getDigits(zDate + "\0", N0, min0, max0, nextC0, ref pVal0);
      return digits != 0 ? digits + Sqlite3.getDigits(zDate.Substring(zDate.IndexOf(nextC0) + 1) + "\0", N1, min1, max1, nextC1, ref pVal1) : 0;
    }

    private static int getDigits(
      string zDate,
      int N0,
      int min0,
      int max0,
      char nextC0,
      ref int pVal0,
      int N1,
      int min1,
      int max1,
      char nextC1,
      ref int pVal1,
      int N2,
      int min2,
      int max2,
      char nextC2,
      ref int pVal2)
    {
      int digits1 = Sqlite3.getDigits(zDate + "\0", N0, min0, max0, nextC0, ref pVal0);
      if (digits1 == 0)
        return 0;
      string str = zDate.Substring(zDate.IndexOf(nextC0) + 1);
      int digits2 = Sqlite3.getDigits(str + "\0", N1, min1, max1, nextC1, ref pVal1);
      return digits2 == 0 ? digits1 : digits1 + digits2 + Sqlite3.getDigits(str.Substring(str.IndexOf(nextC1) + 1) + "\0", N2, min2, max2, nextC2, ref pVal2);
    }

    private static int getDigits(
      string zDate,
      int N,
      int min,
      int max,
      char nextC,
      ref int pVal)
    {
      int digits = 0;
      int index = 0;
      int num1 = 0;
      while (N-- != 0)
      {
        if (Sqlite3.sqlite3Isdigit(zDate[index]))
        {
          num1 = num1 * 10 + (int) zDate[index] - 48;
          ++index;
        }
        else
          goto label_6;
      }
      if (num1 >= min && num1 <= max && (index >= zDate.Length || nextC == char.MinValue || (int) nextC == (int) zDate[index]))
      {
        pVal = num1;
        int num2 = index + 1;
        ++digits;
      }
label_6:
      return digits;
    }

    private static int parseTimezone(string zDate, Sqlite3.DateTime p)
    {
      int pVal0 = 0;
      int pVal1 = 0;
      zDate = zDate.Trim();
      p.tz = 0;
      int num;
      switch (zDate.Length == 0 ? char.MinValue : zDate[0])
      {
        case char.MinValue:
          return 0;
        case '+':
          num = 1;
          break;
        case '-':
          num = -1;
          break;
        case 'Z':
        case 'z':
          zDate = zDate.Substring(1).Trim();
          goto label_12;
        default:
          return 1;
      }
      if (Sqlite3.getDigits(zDate.Substring(1), 2, 0, 14, ':', ref pVal0, 2, 0, 59, char.MinValue, ref pVal1) != 2)
        return 1;
      p.tz = num * (pVal1 + pVal0 * 60);
      if (zDate.Length == 6)
        zDate = "";
      else if (zDate.Length > 6)
        zDate = zDate.Substring(6).Trim();
label_12:
      return !(zDate != "") ? 0 : 1;
    }

    private static int parseHhMmSs(string zDate, Sqlite3.DateTime p)
    {
      int pVal0 = 0;
      int pVal1 = 0;
      int pVal = 0;
      double num1 = 0.0;
      if (Sqlite3.getDigits(zDate, 2, 0, 24, ':', ref pVal0, 2, 0, 59, char.MinValue, ref pVal1) != 2)
        return 1;
      int num2 = 5;
      if (num2 < zDate.Length && zDate[num2] == ':')
      {
        int startIndex = num2 + 1;
        if (Sqlite3.getDigits(zDate.Substring(startIndex), 2, 0, 59, char.MinValue, ref pVal) != 1)
          return 1;
        num2 = startIndex + 2;
        if (num2 + 1 < zDate.Length && zDate[num2] == '.' && Sqlite3.sqlite3Isdigit(zDate[num2 + 1]))
        {
          double num3 = 1.0;
          for (++num2; num2 < zDate.Length && Sqlite3.sqlite3Isdigit(zDate[num2]); ++num2)
          {
            num1 = num1 * 10.0 + (double) zDate[num2] - 48.0;
            num3 *= 10.0;
          }
          num1 /= num3;
        }
      }
      else
        pVal = 0;
      p.validJD = (byte) 0;
      p.validHMS = (byte) 1;
      p.h = pVal0;
      p.m = pVal1;
      p.s = (double) pVal + num1;
      if (num2 < zDate.Length && Sqlite3.parseTimezone(zDate.Substring(num2), p) != 0)
        return 1;
      p.validTZ = p.tz != 0 ? (byte) 1 : (byte) 0;
      return 0;
    }

    private static void computeJD(Sqlite3.DateTime p)
    {
      if (p.validJD != (byte) 0)
        return;
      int num1;
      int num2;
      int num3;
      if (p.validYMD != (byte) 0)
      {
        num1 = p.Y;
        num2 = p.M;
        num3 = p.D;
      }
      else
      {
        num1 = 2000;
        num2 = 1;
        num3 = 1;
      }
      if (num2 <= 2)
      {
        --num1;
        num2 += 12;
      }
      int num4 = num1 / 100;
      int num5 = 2 - num4 + num4 / 4;
      int num6 = 36525 * (num1 + 4716) / 100;
      int num7 = 306001 * (num2 + 1) / 10000;
      p.iJD = (long) (((double) (num6 + num7 + num3 + num5) - 1524.5) * 86400000.0);
      p.validJD = (byte) 1;
      if (p.validHMS == (byte) 0)
        return;
      p.iJD += (long) ((double) (p.h * 3600000 + p.m * 60000) + p.s * 1000.0);
      if (p.validTZ == (byte) 0)
        return;
      p.iJD -= (long) (p.tz * 60000);
      p.validYMD = (byte) 0;
      p.validHMS = (byte) 0;
      p.validTZ = (byte) 0;
    }

    private static int parseYyyyMmDd(string zDate, Sqlite3.DateTime p)
    {
      int pVal0 = 0;
      int pVal1 = 0;
      int pVal2 = 0;
      int num1 = 0;
      bool flag;
      if (zDate[num1] == '-')
      {
        ++num1;
        flag = true;
      }
      else
        flag = false;
      if (Sqlite3.getDigits(zDate.Substring(num1), 4, 0, 9999, '-', ref pVal0, 2, 1, 12, '-', ref pVal1, 2, 1, 31, char.MinValue, ref pVal2) != 3)
        return 1;
      int num2 = num1 + 10;
      while (num2 < zDate.Length && (Sqlite3.sqlite3Isspace(zDate[num2]) || 'T' == zDate[num2]))
        ++num2;
      if (num2 >= zDate.Length || Sqlite3.parseHhMmSs(zDate.Substring(num2), p) != 0)
      {
        if (num2 < zDate.Length)
          return 1;
        p.validHMS = (byte) 0;
      }
      p.validJD = (byte) 0;
      p.validYMD = (byte) 1;
      p.Y = flag ? -pVal0 : pVal0;
      p.M = pVal1;
      p.D = pVal2;
      if (p.validTZ != (byte) 0)
        Sqlite3.computeJD(p);
      return 0;
    }

    private static void setDateTimeToCurrent(Sqlite3.sqlite3_context context, Sqlite3.DateTime p)
    {
      Sqlite3.sqlite3OsCurrentTimeInt64(Sqlite3.sqlite3_context_db_handle(context).pVfs, ref p.iJD);
      p.validJD = (byte) 1;
    }

    private static int parseDateOrTime(
      Sqlite3.sqlite3_context context,
      string zDate,
      ref Sqlite3.DateTime p)
    {
      double pResult = 0.0;
      if (Sqlite3.parseYyyyMmDd(zDate, p) == 0 || Sqlite3.parseHhMmSs(zDate, p) == 0)
        return 0;
      if (zDate.Equals("now", StringComparison.InvariantCultureIgnoreCase))
      {
        Sqlite3.setDateTimeToCurrent(context, p);
        return 0;
      }
      if (!Sqlite3.sqlite3AtoF(zDate, ref pResult, Sqlite3.sqlite3Strlen30(zDate), (byte) 1))
        return 1;
      p.iJD = (long) (pResult * 86400000.0 + 0.5);
      p.validJD = (byte) 1;
      return 0;
    }

    private static void computeYMD(Sqlite3.DateTime p)
    {
      if (p.validYMD != (byte) 0)
        return;
      if (p.validJD == (byte) 0)
      {
        p.Y = 2000;
        p.M = 1;
        p.D = 1;
      }
      else
      {
        int num1;
        int num2 = (int) (((double) (num1 = (int) ((p.iJD + 43200000L) / 86400000L)) - 1867216.25) / 36524.25);
        int num3 = num1 + 1 + num2 - num2 / 4 + 1524;
        int num4 = (int) (((double) num3 - 122.1) / 365.25);
        int num5 = 36525 * num4 / 100;
        int num6 = (int) ((double) (num3 - num5) / 30.6001);
        int num7 = (int) (30.6001 * (double) num6);
        p.D = num3 - num5 - num7;
        p.M = num6 < 14 ? num6 - 1 : num6 - 13;
        p.Y = p.M > 2 ? num4 - 4716 : num4 - 4715;
      }
      p.validYMD = (byte) 1;
    }

    private static void computeHMS(Sqlite3.DateTime p)
    {
      if (p.validHMS != (byte) 0)
        return;
      Sqlite3.computeJD(p);
      int num1 = (int) ((p.iJD + 43200000L) % 86400000L);
      p.s = (double) num1 / 1000.0;
      int s = (int) p.s;
      p.s -= (double) s;
      p.h = s / 3600;
      int num2 = s - p.h * 3600;
      p.m = num2 / 60;
      p.s += (double) (num2 - p.m * 60);
      p.validHMS = (byte) 1;
    }

    private static void computeYMD_HMS(Sqlite3.DateTime p)
    {
      Sqlite3.computeYMD(p);
      Sqlite3.computeHMS(p);
    }

    private static void clearYMD_HMS_TZ(Sqlite3.DateTime p)
    {
      p.validYMD = (byte) 0;
      p.validHMS = (byte) 0;
      p.validTZ = (byte) 0;
    }

    private static int osLocaltime(long t, Sqlite3.tm pTm)
    {
      Sqlite3.sqlite3_mutex m = Sqlite3.sqlite3MutexAlloc(2);
      Sqlite3.sqlite3_mutex_enter(m);
      Sqlite3.tm tm = Sqlite3.localtime(t);
      if (Sqlite3.sqlite3GlobalConfig.bLocaltimeFault)
        tm = (Sqlite3.tm) null;
      if (tm != null)
        pTm = tm;
      Sqlite3.sqlite3_mutex_leave(m);
      return tm != null ? 0 : 1;
    }

    private static long localtimeOffset(
      Sqlite3.DateTime p,
      Sqlite3.sqlite3_context pCtx,
      out int pRc)
    {
      Sqlite3.DateTime p1 = new Sqlite3.DateTime();
      Sqlite3.tm pTm = new Sqlite3.tm();
      Sqlite3.DateTime p2 = p;
      Sqlite3.computeYMD_HMS(p2);
      if (p2.Y < 1971 || p2.Y >= 2038)
      {
        p2.Y = 2000;
        p2.M = 1;
        p2.D = 1;
        p2.h = 0;
        p2.m = 0;
        p2.s = 0.0;
      }
      else
      {
        int num = (int) (p2.s + 0.5);
        p2.s = (double) num;
      }
      p2.tz = 0;
      p2.validJD = (byte) 0;
      Sqlite3.computeJD(p2);
      if (Sqlite3.osLocaltime(p2.iJD / 1000L - 210866760000L, pTm) != 0)
      {
        Sqlite3.sqlite3_result_error(pCtx, "local time unavailable", -1);
        pRc = 1;
        return 0;
      }
      p1.Y = pTm.tm_year;
      p1.M = pTm.tm_mon;
      p1.D = pTm.tm_mday;
      p1.h = pTm.tm_hour;
      p1.m = pTm.tm_min;
      p1.s = (double) pTm.tm_sec;
      p1.validYMD = (byte) 1;
      p1.validHMS = (byte) 1;
      p1.validJD = (byte) 0;
      p1.validTZ = (byte) 0;
      Sqlite3.computeJD(p1);
      pRc = 0;
      return (long) (int) (p1.iJD - p2.iJD);
    }

    private static int parseModifier(Sqlite3.sqlite3_context pCtx, string zMod, Sqlite3.DateTime p)
    {
      int pRc = 1;
      double pResult = 0.0;
      StringBuilder stringBuilder = new StringBuilder(zMod.ToLower());
      Sqlite3.zdtBuf.Length = 0;
      switch (stringBuilder[0])
      {
        case '+':
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          int num1 = 1;
          while (num1 < stringBuilder.Length && stringBuilder[num1] != ':' && !Sqlite3.sqlite3Isspace(stringBuilder[num1]))
            ++num1;
          if (!Sqlite3.sqlite3AtoF(stringBuilder.ToString(), ref pResult, num1, (byte) 1))
          {
            pRc = 1;
            break;
          }
          if (stringBuilder[num1] == ':')
          {
            string str = stringBuilder.ToString();
            int num2 = 0;
            if (!Sqlite3.sqlite3Isdigit(str[num2]))
              ++num2;
            Sqlite3.DateTime p1 = new Sqlite3.DateTime();
            if (Sqlite3.parseHhMmSs(str.Substring(num2), p1) == 0)
            {
              Sqlite3.computeJD(p1);
              p1.iJD -= 43200000L;
              long num3 = p1.iJD / 86400000L;
              p1.iJD -= num3 * 86400000L;
              if (stringBuilder[0] == '-')
                p1.iJD = -p1.iJD;
              Sqlite3.computeJD(p);
              Sqlite3.clearYMD_HMS_TZ(p);
              p.iJD += p1.iJD;
              pRc = 0;
              break;
            }
            break;
          }
          while (Sqlite3.sqlite3Isspace(stringBuilder[num1]))
            ++num1;
          StringBuilder z = stringBuilder.Remove(0, num1);
          int num4 = Sqlite3.sqlite3Strlen30(z);
          switch (num4)
          {
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
              if (z[num4 - 1] == 's')
                z.Length = --num4;
              Sqlite3.computeJD(p);
              pRc = 0;
              double num5 = pResult < 0.0 ? -0.5 : 0.5;
              if (num4 == 3 && z.ToString() == "day")
                p.iJD += (long) (pResult * 86400000.0 + num5);
              else if (num4 == 4 && z.ToString() == "hour")
                p.iJD += (long) (pResult * 3600000.0 + num5);
              else if (num4 == 6 && z.ToString() == "minute")
                p.iJD += (long) (pResult * 60000.0 + num5);
              else if (num4 == 6 && z.ToString() == "second")
                p.iJD += (long) (pResult * 1000.0 + num5);
              else if (num4 == 5 && z.ToString() == "month")
              {
                Sqlite3.computeYMD_HMS(p);
                p.M += (int) pResult;
                int num6 = p.M > 0 ? (p.M - 1) / 12 : (p.M - 12) / 12;
                p.Y += num6;
                p.M -= num6 * 12;
                p.validJD = (byte) 0;
                Sqlite3.computeJD(p);
                int num7 = (int) pResult;
                if ((double) num7 != pResult)
                  p.iJD += (long) ((pResult - (double) num7) * 30.0 * 86400000.0 + num5);
              }
              else if (num4 == 4 && z.ToString() == "year")
              {
                int num8 = (int) pResult;
                Sqlite3.computeYMD_HMS(p);
                p.Y += num8;
                p.validJD = (byte) 0;
                Sqlite3.computeJD(p);
                if ((double) num8 != pResult)
                  p.iJD += (long) ((pResult - (double) num8) * 365.0 * 86400000.0 + num5);
              }
              else
                pRc = 1;
              Sqlite3.clearYMD_HMS_TZ(p);
              break;
          }
          break;
        case 'l':
          if (stringBuilder.ToString() == "localtime")
          {
            Sqlite3.computeJD(p);
            p.iJD += Sqlite3.localtimeOffset(p, pCtx, out pRc);
            Sqlite3.clearYMD_HMS_TZ(p);
            break;
          }
          break;
        case 's':
          if (stringBuilder.Length <= 9)
            stringBuilder.Length = 0;
          else
            stringBuilder.Remove(0, 9);
          Sqlite3.computeYMD(p);
          p.validHMS = (byte) 1;
          p.h = p.m = 0;
          p.s = 0.0;
          p.validTZ = (byte) 0;
          p.validJD = (byte) 0;
          if (stringBuilder.ToString() == "month")
          {
            p.D = 1;
            pRc = 0;
            break;
          }
          if (stringBuilder.ToString() == "year")
          {
            Sqlite3.computeYMD(p);
            p.M = 1;
            p.D = 1;
            pRc = 0;
            break;
          }
          if (stringBuilder.ToString() == "day")
          {
            pRc = 0;
            break;
          }
          break;
        case 'u':
          if (stringBuilder.ToString() == "unixepoch" && p.validJD != (byte) 0)
          {
            p.iJD = (p.iJD + 43200L) / 86400L + 210866760000000L;
            Sqlite3.clearYMD_HMS_TZ(p);
            pRc = 0;
            break;
          }
          if (stringBuilder.ToString() == "utc")
          {
            Sqlite3.computeJD(p);
            long num9 = Sqlite3.localtimeOffset(p, pCtx, out pRc);
            if (pRc == 0)
            {
              p.iJD -= num9;
              Sqlite3.clearYMD_HMS_TZ(p);
              p.iJD += num9 - Sqlite3.localtimeOffset(p, pCtx, out pRc);
              break;
            }
            break;
          }
          break;
        case 'w':
          int num10;
          if (stringBuilder.ToString().StartsWith("weekday ") && Sqlite3.sqlite3AtoF(stringBuilder.ToString().Substring(8), ref pResult, Sqlite3.sqlite3Strlen30(stringBuilder.ToString().Substring(8)), (byte) 1) && (double) (num10 = (int) pResult) == pResult && num10 >= 0 && pResult < 7.0)
          {
            Sqlite3.computeYMD_HMS(p);
            p.validTZ = (byte) 0;
            p.validJD = (byte) 0;
            Sqlite3.computeJD(p);
            long num11 = (p.iJD + 129600000L) / 86400000L % 7L;
            if (num11 > (long) num10)
              num11 -= 7L;
            p.iJD += ((long) num10 - num11) * 86400000L;
            Sqlite3.clearYMD_HMS_TZ(p);
            pRc = 0;
            break;
          }
          break;
      }
      return pRc;
    }

    private static int isDate(
      Sqlite3.sqlite3_context context,
      int argc,
      Sqlite3.Mem[] argv,
      ref Sqlite3.DateTime p)
    {
      p = new Sqlite3.DateTime();
      if (argc == 0)
      {
        Sqlite3.setDateTimeToCurrent(context, p);
      }
      else
      {
        int num;
        if ((num = Sqlite3.sqlite3_value_type(argv[0])) == 2 || num == 1)
        {
          p.iJD = (long) (Sqlite3.sqlite3_value_double(argv[0]) * 86400000.0 + 0.5);
          p.validJD = (byte) 1;
        }
        else
        {
          string zDate = Sqlite3.sqlite3_value_text(argv[0]);
          if (string.IsNullOrEmpty(zDate) || Sqlite3.parseDateOrTime(context, zDate, ref p) != 0)
            return 1;
        }
      }
      for (int index = 1; index < argc; ++index)
      {
        string zMod = Sqlite3.sqlite3_value_text(argv[index]);
        if (string.IsNullOrEmpty(zMod) || Sqlite3.parseModifier(context, zMod, p) != 0)
          return 1;
      }
      return 0;
    }

    private static void juliandayFunc(
      Sqlite3.sqlite3_context context,
      int argc,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.DateTime p = (Sqlite3.DateTime) null;
      if (Sqlite3.isDate(context, argc, argv, ref p) != 0)
        return;
      Sqlite3.computeJD(p);
      Sqlite3.sqlite3_result_double(context, (double) p.iJD / 86400000.0);
    }

    private static void datetimeFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.DateTime p = (Sqlite3.DateTime) null;
      if (Sqlite3.isDate(context, argc, argv, ref p) != 0)
        return;
      Sqlite3.zdtBuf.Length = 0;
      Sqlite3.computeYMD_HMS(p);
      Sqlite3.sqlite3_snprintf(100, Sqlite3.zdtBuf, "%04d-%02d-%02d %02d:%02d:%02d", (object) p.Y, (object) p.M, (object) p.D, (object) p.h, (object) p.m, (object) (int) p.s);
      Sqlite3.sqlite3_result_text(context, Sqlite3.zdtBuf, -1, Sqlite3.SQLITE_TRANSIENT);
    }

    private static void timeFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.DateTime p = new Sqlite3.DateTime();
      if (Sqlite3.isDate(context, argc, argv, ref p) != 0)
        return;
      Sqlite3.zdtBuf.Length = 0;
      Sqlite3.computeHMS(p);
      Sqlite3.sqlite3_snprintf(100, Sqlite3.zdtBuf, "%02d:%02d:%02d", (object) p.h, (object) p.m, (object) (int) p.s);
      Sqlite3.sqlite3_result_text(context, Sqlite3.zdtBuf, -1, Sqlite3.SQLITE_TRANSIENT);
    }

    private static void dateFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.DateTime p = (Sqlite3.DateTime) null;
      if (Sqlite3.isDate(context, argc, argv, ref p) != 0)
        return;
      StringBuilder stringBuilder = new StringBuilder(100);
      Sqlite3.computeYMD(p);
      Sqlite3.sqlite3_snprintf(100, stringBuilder, "%04d-%02d-%02d", (object) p.Y, (object) p.M, (object) p.D);
      Sqlite3.sqlite3_result_text(context, stringBuilder, -1, Sqlite3.SQLITE_TRANSIENT);
    }

    private static void strftimeFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.DateTime p = new Sqlite3.DateTime();
      string str = Sqlite3.sqlite3_value_text(argv[0]);
      StringBuilder stringBuilder = new StringBuilder(100);
      Sqlite3.Mem[] argv1 = new Sqlite3.Mem[argc - 1];
      for (int index = 0; index < argc - 1; ++index)
        argv[index + 1].CopyTo(ref argv1[index]);
      if (string.IsNullOrEmpty(str) || Sqlite3.isDate(context, argc - 1, argv1, ref p) != 0)
        return;
      Sqlite3.sqlite3 sqlite3 = Sqlite3.sqlite3_context_db_handle(context);
      int index1 = 0;
      ulong capacity = 1;
      while (index1 < str.Length)
      {
        if (str[index1] == '%')
        {
          switch (str[index1 + 1])
          {
            case '%':
            case 'w':
              ++index1;
              break;
            case 'H':
            case 'M':
            case 'S':
            case 'W':
            case 'd':
            case 'm':
              ++capacity;
              goto case '%';
            case 'J':
            case 's':
              capacity += 50UL;
              goto case '%';
            case 'Y':
              capacity += 8UL;
              goto case '%';
            case 'f':
              capacity += 8UL;
              goto case '%';
            case 'g':
            case 'h':
            case 'i':
            case 'k':
            case 'l':
              return;
            case 'j':
              capacity += 3UL;
              goto case '%';
            default:
              return;
          }
        }
        ++index1;
        ++capacity;
      }
      Sqlite3.testcase<bool>((long) capacity == (long) (stringBuilder.Length - 1));
      Sqlite3.testcase<bool>((long) capacity == (long) stringBuilder.Length);
      Sqlite3.testcase<bool>((long) capacity == (long) sqlite3.aLimit[0] + 1L);
      Sqlite3.testcase<bool>((long) capacity == (long) sqlite3.aLimit[0]);
      StringBuilder z;
      if (capacity < (ulong) stringBuilder.Capacity)
      {
        z = stringBuilder;
      }
      else
      {
        if (capacity > (ulong) sqlite3.aLimit[0])
        {
          Sqlite3.sqlite3_result_error_toobig(context);
          return;
        }
        z = new StringBuilder((int) capacity);
      }
      Sqlite3.computeJD(p);
      Sqlite3.computeYMD_HMS(p);
      int num1;
      for (int index2 = num1 = 0; index2 < str.Length; ++index2)
      {
        if (str[index2] != '%')
        {
          z.Append(str[index2]);
        }
        else
        {
          ++index2;
          Sqlite3.zdtTemp.Length = 0;
          switch (str[index2])
          {
            case 'H':
              Sqlite3.sqlite3_snprintf(3, Sqlite3.zdtTemp, "%02d", (object) p.h);
              z.Append((object) Sqlite3.zdtTemp);
              num1 += 2;
              continue;
            case 'J':
              Sqlite3.sqlite3_snprintf(20, Sqlite3.zdtTemp, "%.16g", (object) ((double) p.iJD / 86400000.0));
              z.Append((object) Sqlite3.zdtTemp);
              num1 = Sqlite3.sqlite3Strlen30(z);
              continue;
            case 'M':
              Sqlite3.sqlite3_snprintf(3, Sqlite3.zdtTemp, "%02d", (object) p.m);
              z.Append((object) Sqlite3.zdtTemp);
              num1 += 2;
              continue;
            case 'S':
              Sqlite3.sqlite3_snprintf(3, Sqlite3.zdtTemp, "%02d", (object) (int) p.s);
              z.Append((object) Sqlite3.zdtTemp);
              num1 += 2;
              continue;
            case 'W':
            case 'j':
              Sqlite3.DateTime dateTime = new Sqlite3.DateTime();
              p.CopyTo(dateTime);
              dateTime.validJD = (byte) 0;
              dateTime.M = 1;
              dateTime.D = 1;
              Sqlite3.computeJD(dateTime);
              int num2 = (int) ((p.iJD - dateTime.iJD + 43200000L) / 86400000L);
              if (str[index2] == 'W')
              {
                int num3 = (int) ((p.iJD + 43200000L) / 86400000L % 7L);
                Sqlite3.sqlite3_snprintf(3, Sqlite3.zdtTemp, "%02d", (object) ((num2 + 7 - num3) / 7));
                z.Append((object) Sqlite3.zdtTemp);
                num1 += 2;
                continue;
              }
              Sqlite3.sqlite3_snprintf(4, Sqlite3.zdtTemp, "%03d", (object) (num2 + 1));
              z.Append((object) Sqlite3.zdtTemp);
              num1 += 3;
              continue;
            case 'Y':
              Sqlite3.sqlite3_snprintf(5, Sqlite3.zdtTemp, "%04d", (object) p.Y);
              z.Append((object) Sqlite3.zdtTemp);
              num1 = Sqlite3.sqlite3Strlen30(z);
              continue;
            case 'd':
              Sqlite3.sqlite3_snprintf(3, Sqlite3.zdtTemp, "%02d", (object) p.D);
              z.Append((object) Sqlite3.zdtTemp);
              num1 += 2;
              continue;
            case 'f':
              double num4 = p.s;
              if (num4 > 59.999)
                num4 = 59.999;
              Sqlite3.sqlite3_snprintf(7, Sqlite3.zdtTemp, "%06.3f", (object) num4);
              z.Append((object) Sqlite3.zdtTemp);
              num1 = Sqlite3.sqlite3Strlen30(z);
              continue;
            case 'm':
              Sqlite3.sqlite3_snprintf(3, Sqlite3.zdtTemp, "%02d", (object) p.M);
              z.Append((object) Sqlite3.zdtTemp);
              num1 += 2;
              continue;
            case 's':
              Sqlite3.sqlite3_snprintf(30, Sqlite3.zdtTemp, "%lld", (object) (p.iJD / 1000L - 210866760000L));
              z.Append((object) Sqlite3.zdtTemp);
              num1 = Sqlite3.sqlite3Strlen30(z);
              continue;
            case 'w':
              z.Append((p.iJD + 129600000L) / 86400000L % 7L);
              continue;
            default:
              z.Append('%');
              continue;
          }
        }
      }
      Sqlite3.sqlite3_result_text(context, z, -1, z == stringBuilder ? Sqlite3.SQLITE_TRANSIENT : Sqlite3.SQLITE_DYNAMIC);
    }

    private static void ctimeFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.timeFunc(context, 0, (Sqlite3.Mem[]) null);
    }

    private static void cdateFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.dateFunc(context, 0, (Sqlite3.Mem[]) null);
    }

    private static void ctimestampFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.datetimeFunc(context, 0, (Sqlite3.Mem[]) null);
    }

    private static void sqlite3RegisterDateTimeFunctions()
    {
      Sqlite3.FuncDef[] x = new Sqlite3.FuncDef[8]
      {
        Sqlite3.FUNCTION("julianday", (short) -1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.juliandayFunc)),
        Sqlite3.FUNCTION("date", (short) -1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.dateFunc)),
        Sqlite3.FUNCTION("time", (short) -1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.timeFunc)),
        Sqlite3.FUNCTION("datetime", (short) -1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.datetimeFunc)),
        Sqlite3.FUNCTION("strftime", (short) -1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.strftimeFunc)),
        Sqlite3.FUNCTION("current_time", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.ctimeFunc)),
        Sqlite3.FUNCTION("current_timestamp", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.ctimestampFunc)),
        Sqlite3.FUNCTION("current_date", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.cdateFunc))
      };
      Sqlite3.FuncDefHash sqlite3GlobalFunctions = Sqlite3.sqlite3GlobalFunctions;
      Sqlite3.FuncDef[] funcDefArray = x;
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3.FuncDef>(x); ++index)
        Sqlite3.sqlite3FuncDefInsert(sqlite3GlobalFunctions, funcDefArray[index]);
    }

    private static Sqlite3.Table sqlite3SrcListLookup(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pSrc)
    {
      Sqlite3.SrcList_item pFrom = pSrc.a[0];
      Sqlite3.Table table = Sqlite3.sqlite3LocateTable(pParse, 0, pFrom.zName, pFrom.zDatabase);
      Sqlite3.sqlite3DeleteTable(pParse.db, ref pFrom.pTab);
      pFrom.pTab = table;
      if (table != null)
        ++table.nRef;
      if (Sqlite3.sqlite3IndexedByLookup(pParse, pFrom) != 0)
        table = (Sqlite3.Table) null;
      return table;
    }

    private static bool sqlite3IsReadOnly(Sqlite3.Parse pParse, Sqlite3.Table pTab, int viewOk)
    {
      if (Sqlite3.IsVirtual(pTab) && Sqlite3.sqlite3GetVTable(pParse.db, pTab).pMod.pModule.xUpdate == null || ((int) pTab.tabFlags & 1) != 0 && (pParse.db.flags & 65536) == 0 && pParse.nested == (byte) 0)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "table %s may not be modified", (object) pTab.zName);
        return true;
      }
      if (viewOk != 0 || pTab.pSelect == null)
        return false;
      Sqlite3.sqlite3ErrorMsg(pParse, "cannot modify %s because it is a view", (object) pTab.zName);
      return true;
    }

    private static void sqlite3MaterializeView(
      Sqlite3.Parse pParse,
      Sqlite3.Table pView,
      Sqlite3.Expr pWhere,
      int iCur)
    {
      Sqlite3.SelectDest pDest = new Sqlite3.SelectDest();
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Select p = Sqlite3.sqlite3SelectDup(db, pView.pSelect, 0);
      if (pWhere != null)
      {
        pWhere = Sqlite3.sqlite3ExprDup(db, pWhere, 0);
        Sqlite3.SrcList pSrc = Sqlite3.sqlite3SrcListAppend(db, (Sqlite3.SrcList) null, (Sqlite3.Token) null, (Sqlite3.Token) null);
        pSrc.a[0].zAlias = pView.zName;
        pSrc.a[0].pSelect = p;
        p = Sqlite3.sqlite3SelectNew(pParse, (Sqlite3.ExprList) null, pSrc, pWhere, (Sqlite3.ExprList) null, (Sqlite3.Expr) null, (Sqlite3.ExprList) null, 0, (Sqlite3.Expr) null, (Sqlite3.Expr) null);
      }
      Sqlite3.sqlite3SelectDestInit(pDest, 9, iCur);
      Sqlite3.sqlite3Select(pParse, p, ref pDest);
      Sqlite3.sqlite3SelectDelete(db, ref p);
    }

    private static void sqlite3DeleteFrom(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.Expr pWhere)
    {
      int num1 = -1;
      Sqlite3.AuthContext authContext = new Sqlite3.AuthContext();
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.nErr == 0)
      {
        Sqlite3.Table table = Sqlite3.sqlite3SrcListLookup(pParse, pTabList);
        if (table != null)
        {
          Sqlite3.Trigger pTrigger = Sqlite3.sqlite3TriggersExist(pParse, table, 106, (Sqlite3.ExprList) null, out int _);
          bool flag = table.pSelect != null;
          if (Sqlite3.sqlite3ViewGetColumnNames(pParse, table) == 0 && !Sqlite3.sqlite3IsReadOnly(pParse, table, pTrigger != null ? 1 : 0))
          {
            int index1 = Sqlite3.sqlite3SchemaToIndex(db, table.pSchema);
            string zName = db.aDb[index1].zName;
            int num2 = 0;
            if (num2 != 1)
            {
              Sqlite3.SrcList_item srcListItem = pTabList.a[0];
              int num3 = pParse.nTab++;
              int num4;
              int num5 = num4 = num3;
              srcListItem.iCursor = num4;
              int num6 = num5;
              for (Sqlite3.Index index2 = table.pIndex; index2 != null; index2 = index2.pNext)
                ++pParse.nTab;
              Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
              if (vdbe != null)
              {
                if (pParse.nested == (byte) 0)
                  Sqlite3.sqlite3VdbeCountChanges(vdbe);
                Sqlite3.sqlite3BeginWriteOperation(pParse, 1, index1);
                if (flag)
                  Sqlite3.sqlite3MaterializeView(pParse, table, pWhere, num6);
                if (Sqlite3.sqlite3ResolveExprNames(new Sqlite3.NameContext()
                {
                  pParse = pParse,
                  pSrcList = pTabList
                }, ref pWhere) == 0)
                {
                  if ((db.flags & 4096) != 0)
                  {
                    num1 = ++pParse.nMem;
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num1);
                  }
                  if (num2 == 0 && pWhere == null && pTrigger == null && !Sqlite3.IsVirtual(table) && Sqlite3.sqlite3FkRequired(pParse, table, (int[]) null, 0) == 0)
                  {
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, 96, table.tnum, index1, num1, table.zName, -2);
                    for (Sqlite3.Index index3 = table.pIndex; index3 != null; index3 = index3.pNext)
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 96, index3.tnum, index1);
                  }
                  else
                  {
                    int num7 = ++pParse.nMem;
                    int num8 = ++pParse.nMem;
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num7);
                    Sqlite3.ExprList ppOrderBy = (Sqlite3.ExprList) null;
                    Sqlite3.WhereInfo pWInfo = Sqlite3.sqlite3WhereBegin(pParse, pTabList, pWhere, ref ppOrderBy, (ushort) 8);
                    if (pWInfo != null)
                    {
                      int column = Sqlite3.sqlite3ExprCodeGetColumn(pParse, table, -1, num6, num8);
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 105, num7, column);
                      if ((db.flags & 4096) != 0)
                        Sqlite3.sqlite3VdbeAddOp2(vdbe, 20, num1, 1);
                      Sqlite3.sqlite3WhereEnd(pWInfo);
                      int num9 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
                      if (!flag)
                        Sqlite3.sqlite3OpenTableAndIndices(pParse, table, num6, 39);
                      int p2 = Sqlite3.sqlite3VdbeAddOp3(vdbe, 106, num7, num9, num8);
                      int count = pParse.nested == (byte) 0 ? 1 : 0;
                      Sqlite3.sqlite3GenerateRowDelete(pParse, table, num6, num8, count, pTrigger, 99);
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, p2);
                      Sqlite3.sqlite3VdbeResolveLabel(vdbe, num9);
                      if (!flag && !Sqlite3.IsVirtual(table))
                      {
                        int num10 = 1;
                        for (Sqlite3.Index index4 = table.pIndex; index4 != null; index4 = index4.pNext)
                        {
                          Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num6 + num10, index4.tnum);
                          ++num10;
                        }
                        Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, num6);
                      }
                    }
                    else
                      goto label_33;
                  }
                  if (pParse.nested == (byte) 0 && pParse.pTriggerTab == null)
                    Sqlite3.sqlite3AutoincrementEnd(pParse);
                  if ((db.flags & 4096) != 0 && pParse.nested == (byte) 0 && pParse.pTriggerTab == null)
                  {
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, num1, 1);
                    Sqlite3.sqlite3VdbeSetNumCols(vdbe, 1);
                    Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, "rows deleted", Sqlite3.SQLITE_STATIC);
                  }
                }
              }
            }
          }
        }
      }
label_33:
      Sqlite3.sqlite3SrcListDelete(db, ref pTabList);
      Sqlite3.sqlite3ExprDelete(db, ref pWhere);
    }

    private static void sqlite3GenerateRowDelete(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int iCur,
      int iRowid,
      int count,
      Sqlite3.Trigger pTrigger,
      int onconf)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int num1 = 0;
      int num2 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      Sqlite3.sqlite3VdbeAddOp3(pVdbe, 52, iCur, num2, iRowid);
      if (Sqlite3.sqlite3FkRequired(pParse, pTab, (int[]) null, 0) != 0 || pTrigger != null)
      {
        uint num3 = Sqlite3.sqlite3TriggerColmask(pParse, pTrigger, (Sqlite3.ExprList) null, 0, 3, pTab, onconf) | Sqlite3.sqlite3FkOldmask(pParse, pTab);
        num1 = pParse.nMem + 1;
        pParse.nMem += 1 + pTab.nCol;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 14, iRowid, num1);
        for (int iCol = 0; iCol < pTab.nCol; ++iCol)
        {
          if (num3 == uint.MaxValue || ((long) num3 & (long) (1 << iCol)) != 0L)
            Sqlite3.sqlite3ExprCodeGetColumnOfTable(pVdbe, pTab, iCur, iCol, num1 + iCol + 1);
        }
        Sqlite3.sqlite3CodeRowTrigger(pParse, pTrigger, 106, (Sqlite3.ExprList) null, 1, pTab, num1, onconf, num2);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 52, iCur, num2, iRowid);
        Sqlite3.sqlite3FkCheck(pParse, pTab, num1, 0);
      }
      if (pTab.pSelect == null)
      {
        Sqlite3.sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, 0);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 57, iCur, count != 0 ? 1 : 0);
        if (count != 0)
          Sqlite3.sqlite3VdbeChangeP4(pVdbe, -1, pTab.zName, 0);
      }
      Sqlite3.sqlite3FkActions(pParse, pTab, (Sqlite3.ExprList) null, num1);
      Sqlite3.sqlite3CodeRowTrigger(pParse, pTrigger, 106, (Sqlite3.ExprList) null, 2, pTab, num1, onconf, num2);
      Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num2);
    }

    private static void sqlite3GenerateRowIndexDelete(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int iCur,
      int nothing)
    {
      int[] aRegIdx = (int[]) null;
      Sqlite3.sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, aRegIdx);
    }

    private static void sqlite3GenerateRowIndexDelete(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int iCur,
      int[] aRegIdx)
    {
      int num = 1;
      for (Sqlite3.Index pIdx = pTab.pIndex; pIdx != null; pIdx = pIdx.pNext)
      {
        if (aRegIdx == null || aRegIdx[num - 1] != 0)
        {
          int indexKey = Sqlite3.sqlite3GenerateIndexKey(pParse, pIdx, iCur, 0, false);
          Sqlite3.sqlite3VdbeAddOp3(pParse.pVdbe, 71, iCur + num, indexKey, pIdx.nColumn + 1);
        }
        ++num;
      }
    }

    private static int sqlite3GenerateIndexKey(
      Sqlite3.Parse pParse,
      Sqlite3.Index pIdx,
      int iCur,
      int regOut,
      bool doMakeRec)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.Table pTable = pIdx.pTable;
      int nColumn = pIdx.nColumn;
      int tempRange = Sqlite3.sqlite3GetTempRange(pParse, nColumn + 1);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 61, iCur, tempRange + nColumn);
      for (int index = 0; index < nColumn; ++index)
      {
        int num = pIdx.aiColumn[index];
        if (num == pTable.iPKey)
        {
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 15, tempRange + nColumn, tempRange + index);
        }
        else
        {
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, iCur, num, tempRange + index);
          Sqlite3.sqlite3ColumnDefault(pVdbe, pTable, num, -1);
        }
      }
      if (doMakeRec)
      {
        string z = pTable.pSelect != null || (pParse.db.flags & 128) != 0 ? "" : Sqlite3.sqlite3IndexAffinityStr(pVdbe, pIdx);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, tempRange, nColumn + 1, regOut);
        Sqlite3.sqlite3VdbeChangeP4(pVdbe, -1, z, 0);
      }
      Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, nColumn + 1);
      return tempRange;
    }

    private static char sqlite3ExprAffinity(Sqlite3.Expr pExpr)
    {
      switch (pExpr.op)
      {
        case 37:
          return Sqlite3.sqlite3AffinityType(pExpr.u.zToken);
        case 116:
          return Sqlite3.sqlite3ExprAffinity(pExpr.x.pSelect.pEList.a[0].pExpr);
        case 132:
        case 152:
        case 154:
          if (pExpr.pTab != null)
          {
            int iColumn = (int) pExpr.iColumn;
            return iColumn < 0 ? 'd' : pExpr.pTab.aCol[iColumn].affinity;
          }
          break;
      }
      return pExpr.affinity;
    }

    private static Sqlite3.Expr sqlite3ExprSetColl(Sqlite3.Expr pExpr, Sqlite3.CollSeq pColl)
    {
      if (pExpr != null && pColl != null)
      {
        pExpr.pColl = pColl;
        pExpr.flags |= (ushort) 256;
      }
      return pExpr;
    }

    private static Sqlite3.Expr sqlite3ExprSetCollByToken(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      Sqlite3.Token pCollName)
    {
      Sqlite3.sqlite3 db = pParse.db;
      string pString = Sqlite3.sqlite3NameFromToken(db, pCollName);
      Sqlite3.CollSeq pColl = Sqlite3.sqlite3LocateCollSeq(pParse, pString);
      Sqlite3.sqlite3ExprSetColl(pExpr, pColl);
      Sqlite3.sqlite3DbFree(db, ref pString);
      return pExpr;
    }

    private static Sqlite3.CollSeq sqlite3ExprCollSeq(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr)
    {
      Sqlite3.CollSeq pColl = (Sqlite3.CollSeq) null;
      for (Sqlite3.Expr X = pExpr; Sqlite3.ALWAYS<Sqlite3.Expr>(X); X = X.pLeft)
      {
        pColl = pExpr.pColl;
        if (pColl == null)
        {
          int op = (int) X.op;
          if (X.pTab != null && (op == 154 || op == 152 || op == 132 || op == 60))
          {
            int iColumn = (int) X.iColumn;
            if (iColumn >= 0)
            {
              Sqlite3.sqlite3 db = pParse.db;
              string zColl = X.pTab.aCol[iColumn].zColl;
              pColl = Sqlite3.sqlite3FindCollSeq(db, Sqlite3.ENC(db), zColl, (byte) 0);
              pExpr.pColl = pColl;
              break;
            }
            break;
          }
          if (op != 37 && op != 157)
            break;
        }
        else
          break;
      }
      if (Sqlite3.sqlite3CheckCollSeq(pParse, pColl) != 0)
        pColl = (Sqlite3.CollSeq) null;
      return pColl;
    }

    private static char sqlite3CompareAffinity(Sqlite3.Expr pExpr, char aff2)
    {
      char ch = Sqlite3.sqlite3ExprAffinity(pExpr);
      if (ch != char.MinValue && aff2 != char.MinValue)
        return ch >= 'c' || aff2 >= 'c' ? 'c' : 'b';
      if (ch == char.MinValue && aff2 == char.MinValue)
        return 'b';
      return ch == char.MinValue ? aff2 : ch;
    }

    private static char comparisonAffinity(Sqlite3.Expr pExpr)
    {
      char aff2 = Sqlite3.sqlite3ExprAffinity(pExpr.pLeft);
      if (pExpr.pRight != null)
        aff2 = Sqlite3.sqlite3CompareAffinity(pExpr.pRight, aff2);
      else if (Sqlite3.ExprHasProperty(pExpr, 2048))
        aff2 = Sqlite3.sqlite3CompareAffinity(pExpr.x.pSelect.pEList.a[0].pExpr, aff2);
      else if (aff2 == char.MinValue)
        aff2 = 'b';
      return aff2;
    }

    private static bool sqlite3IndexAffinityOk(Sqlite3.Expr pExpr, char idx_affinity)
    {
      switch (Sqlite3.comparisonAffinity(pExpr))
      {
        case 'a':
          return idx_affinity == 'a';
        case 'b':
          return true;
        default:
          return idx_affinity >= 'c';
      }
    }

    private static byte binaryCompareP5(Sqlite3.Expr pExpr1, Sqlite3.Expr pExpr2, int jumpIfNull)
    {
      byte aff2 = (byte) Sqlite3.sqlite3ExprAffinity(pExpr2);
      return (byte) ((uint) (byte) Sqlite3.sqlite3CompareAffinity(pExpr1, (char) aff2) | (uint) (byte) jumpIfNull);
    }

    private static Sqlite3.CollSeq sqlite3BinaryCompareCollSeq(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pLeft,
      Sqlite3.Expr pRight)
    {
      return ((int) pLeft.flags & 256) == 0 ? (pRight == null || ((int) pRight.flags & 256) == 0 ? Sqlite3.sqlite3ExprCollSeq(pParse, pLeft) ?? Sqlite3.sqlite3ExprCollSeq(pParse, pRight) : pRight.pColl) : pLeft.pColl;
    }

    private static int codeCompare(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pLeft,
      Sqlite3.Expr pRight,
      int opcode,
      int in1,
      int in2,
      int dest,
      int jumpIfNull)
    {
      Sqlite3.CollSeq pP4 = Sqlite3.sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
      int val = (int) Sqlite3.binaryCompareP5(pLeft, pRight, jumpIfNull);
      int num = Sqlite3.sqlite3VdbeAddOp4(pParse.pVdbe, opcode, in2, dest, in1, pP4, -4);
      Sqlite3.sqlite3VdbeChangeP5(pParse.pVdbe, (byte) val);
      return num;
    }

    private static int sqlite3ExprCheckHeight(Sqlite3.Parse pParse, int nHeight)
    {
      int num1 = 0;
      int num2 = pParse.db.aLimit[3];
      if (nHeight > num2)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "Expression tree is too large (maximum depth %d)", (object) num2);
        num1 = 1;
      }
      return num1;
    }

    private static void heightOfExpr(Sqlite3.Expr p, ref int pnHeight)
    {
      if (p == null || p.nHeight <= pnHeight)
        return;
      pnHeight = p.nHeight;
    }

    private static void heightOfExprList(Sqlite3.ExprList p, ref int pnHeight)
    {
      if (p == null)
        return;
      for (int index = 0; index < p.nExpr; ++index)
        Sqlite3.heightOfExpr(p.a[index].pExpr, ref pnHeight);
    }

    private static void heightOfSelect(Sqlite3.Select p, ref int pnHeight)
    {
      if (p == null)
        return;
      Sqlite3.heightOfExpr(p.pWhere, ref pnHeight);
      Sqlite3.heightOfExpr(p.pHaving, ref pnHeight);
      Sqlite3.heightOfExpr(p.pLimit, ref pnHeight);
      Sqlite3.heightOfExpr(p.pOffset, ref pnHeight);
      Sqlite3.heightOfExprList(p.pEList, ref pnHeight);
      Sqlite3.heightOfExprList(p.pGroupBy, ref pnHeight);
      Sqlite3.heightOfExprList(p.pOrderBy, ref pnHeight);
      Sqlite3.heightOfSelect(p.pPrior, ref pnHeight);
    }

    private static void exprSetHeight(Sqlite3.Expr p)
    {
      int pnHeight = 0;
      Sqlite3.heightOfExpr(p.pLeft, ref pnHeight);
      Sqlite3.heightOfExpr(p.pRight, ref pnHeight);
      if (Sqlite3.ExprHasProperty(p, 2048))
        Sqlite3.heightOfSelect(p.x.pSelect, ref pnHeight);
      else
        Sqlite3.heightOfExprList(p.x.pList, ref pnHeight);
      p.nHeight = pnHeight + 1;
    }

    private static void sqlite3ExprSetHeight(Sqlite3.Parse pParse, Sqlite3.Expr p)
    {
      Sqlite3.exprSetHeight(p);
      Sqlite3.sqlite3ExprCheckHeight(pParse, p.nHeight);
    }

    private static int sqlite3SelectExprHeight(Sqlite3.Select p)
    {
      int pnHeight = 0;
      Sqlite3.heightOfSelect(p, ref pnHeight);
      return pnHeight;
    }

    private static Sqlite3.Expr sqlite3ExprAlloc(
      Sqlite3.sqlite3 db,
      int op,
      Sqlite3.Token pToken,
      int dequote)
    {
      int num1 = 0;
      int pValue = 0;
      if (pToken != null && (op != 129 || pToken.z == null || pToken.z.Length == 0 || !Sqlite3.sqlite3GetInt32(pToken.z.ToString(), ref pValue)))
        num1 = pToken.n + 1;
      Sqlite3.Expr expr = new Sqlite3.Expr();
      if (expr != null)
      {
        expr.op = (byte) op;
        expr.iAgg = (short) -1;
        if (pToken != null)
        {
          if (num1 == 0)
          {
            expr.flags |= (ushort) 1024;
            expr.u.iValue = pValue;
          }
          else
          {
            if (pToken.n > 0)
              expr.u.zToken = pToken.z.Substring(0, pToken.n);
            else if (pToken.n == 0 && pToken.z == "")
              expr.u.zToken = "";
            int num2;
            if (dequote != 0 && num1 >= 3 && ((num2 = (int) pToken.z[0]) == 39 || num2 == 34 || num2 == 91 || num2 == 96))
            {
              Sqlite3.sqlite3Dequote(ref expr.u.zToken);
              if (num2 == 34)
                expr.flags |= (ushort) 64;
            }
          }
        }
        expr.nHeight = 1;
      }
      return expr;
    }

    private static Sqlite3.Expr sqlite3Expr(Sqlite3.sqlite3 db, int op, string zToken) => Sqlite3.sqlite3ExprAlloc(db, op, new Sqlite3.Token()
    {
      z = zToken,
      n = !string.IsNullOrEmpty(zToken) ? Sqlite3.sqlite3Strlen30(zToken) : 0
    }, 0);

    private static void sqlite3ExprAttachSubtrees(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr pRoot,
      Sqlite3.Expr pLeft,
      Sqlite3.Expr pRight)
    {
      if (pRoot == null)
      {
        Sqlite3.sqlite3ExprDelete(db, ref pLeft);
        Sqlite3.sqlite3ExprDelete(db, ref pRight);
      }
      else
      {
        if (pRight != null)
        {
          pRoot.pRight = pRight;
          if (((int) pRight.flags & 256) != 0)
          {
            pRoot.flags |= (ushort) 256;
            pRoot.pColl = pRight.pColl;
          }
        }
        if (pLeft != null)
        {
          pRoot.pLeft = pLeft;
          if (((int) pLeft.flags & 256) != 0)
          {
            pRoot.flags |= (ushort) 256;
            pRoot.pColl = pLeft.pColl;
          }
        }
        Sqlite3.exprSetHeight(pRoot);
      }
    }

    private static Sqlite3.Expr sqlite3PExpr(
      Sqlite3.Parse pParse,
      int op,
      int null_3,
      int null_4,
      int null_5)
    {
      return Sqlite3.sqlite3PExpr(pParse, op, (Sqlite3.Expr) null, (Sqlite3.Expr) null, (Sqlite3.Token) null);
    }

    private static Sqlite3.Expr sqlite3PExpr(
      Sqlite3.Parse pParse,
      int op,
      int null_3,
      int null_4,
      Sqlite3.Token pToken)
    {
      return Sqlite3.sqlite3PExpr(pParse, op, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken);
    }

    private static Sqlite3.Expr sqlite3PExpr(
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.Expr pLeft,
      int null_4,
      int null_5)
    {
      return Sqlite3.sqlite3PExpr(pParse, op, pLeft, (Sqlite3.Expr) null, (Sqlite3.Token) null);
    }

    private static Sqlite3.Expr sqlite3PExpr(
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.Expr pLeft,
      int null_4,
      Sqlite3.Token pToken)
    {
      return Sqlite3.sqlite3PExpr(pParse, op, pLeft, (Sqlite3.Expr) null, pToken);
    }

    private static Sqlite3.Expr sqlite3PExpr(
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.Expr pLeft,
      Sqlite3.Expr pRight,
      int null_5)
    {
      return Sqlite3.sqlite3PExpr(pParse, op, pLeft, pRight, (Sqlite3.Token) null);
    }

    private static Sqlite3.Expr sqlite3PExpr(
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.Expr pLeft,
      Sqlite3.Expr pRight,
      Sqlite3.Token pToken)
    {
      Sqlite3.Expr pRoot = Sqlite3.sqlite3ExprAlloc(pParse.db, op, pToken, 1);
      Sqlite3.sqlite3ExprAttachSubtrees(pParse.db, pRoot, pLeft, pRight);
      if (pRoot != null)
        Sqlite3.sqlite3ExprCheckHeight(pParse, pRoot.nHeight);
      return pRoot;
    }

    private static Sqlite3.Expr sqlite3ExprAnd(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr pLeft,
      Sqlite3.Expr pRight)
    {
      if (pLeft == null)
        return pRight;
      if (pRight == null)
        return pLeft;
      Sqlite3.Expr pRoot = Sqlite3.sqlite3ExprAlloc(db, 69, (Sqlite3.Token) null, 0);
      Sqlite3.sqlite3ExprAttachSubtrees(db, pRoot, pLeft, pRight);
      return pRoot;
    }

    private static Sqlite3.Expr sqlite3ExprFunction(
      Sqlite3.Parse pParse,
      int null_2,
      Sqlite3.Token pToken)
    {
      return Sqlite3.sqlite3ExprFunction(pParse, (Sqlite3.ExprList) null, pToken);
    }

    private static Sqlite3.Expr sqlite3ExprFunction(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      int null_3)
    {
      return Sqlite3.sqlite3ExprFunction(pParse, pList, (Sqlite3.Token) null);
    }

    private static Sqlite3.Expr sqlite3ExprFunction(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      Sqlite3.Token pToken)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Expr p = Sqlite3.sqlite3ExprAlloc(db, 151, pToken, 1);
      if (p == null)
      {
        Sqlite3.sqlite3ExprListDelete(db, ref pList);
        return (Sqlite3.Expr) null;
      }
      p.x.pList = pList;
      Sqlite3.sqlite3ExprSetHeight(pParse, p);
      return p;
    }

    private static void sqlite3ExprAssignVarNumber(Sqlite3.Parse pParse, Sqlite3.Expr pExpr)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pExpr == null)
        return;
      string zToken = pExpr.u.zToken;
      if (zToken.Length == 1)
      {
        pExpr.iColumn = (short) ++pParse.nVar;
      }
      else
      {
        short newSize = 0;
        int length = Sqlite3.sqlite3Strlen30(zToken);
        if (zToken[0] == '?')
        {
          long pNum = 0;
          int num = Sqlite3.sqlite3Atoi64(zToken.Substring(1), ref pNum, length - 1, (byte) 1) == 0 ? 1 : 0;
          pExpr.iColumn = newSize = (short) pNum;
          Sqlite3.testcase<bool>(pNum == 0L);
          Sqlite3.testcase<bool>(pNum == 1L);
          Sqlite3.testcase<bool>(pNum == (long) (db.aLimit[9] - 1));
          Sqlite3.testcase<bool>(pNum == (long) db.aLimit[9]);
          if (num == 0 || pNum < 1L || pNum > (long) db.aLimit[9])
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d", (object) db.aLimit[9]);
            newSize = (short) 0;
          }
          if (pNum > (long) pParse.nVar)
            pParse.nVar = (int) pNum;
        }
        else
        {
          for (short index = 0; (int) index < pParse.nzVar; ++index)
          {
            if (pParse.azVar[(int) index] != null && zToken.CompareTo(pParse.azVar[(int) index]) == 0)
            {
              pExpr.iColumn = newSize = (short) ((int) index + 1);
              break;
            }
          }
          if (newSize == (short) 0)
          {
            Sqlite3.Expr expr = pExpr;
            int num1 = ++pParse.nVar;
            int num2;
            short num3 = (short) (num2 = (int) (short) num1);
            expr.iColumn = (short) num2;
            newSize = num3;
          }
        }
        if (newSize > (short) 0)
        {
          if ((int) newSize > pParse.nzVar)
          {
            Array.Resize<string>(ref pParse.azVar, (int) newSize);
            pParse.nzVar = (int) newSize;
          }
          if (zToken[0] != '?' || pParse.azVar[(int) newSize - 1] == null)
            pParse.azVar[(int) newSize - 1] = zToken.Substring(0, length);
        }
      }
      if (pParse.nErr != 0 || pParse.nVar <= db.aLimit[9])
        return;
      Sqlite3.sqlite3ErrorMsg(pParse, "too many SQL variables");
    }

    private static void sqlite3ExprDelete(Sqlite3.sqlite3 db, ref Sqlite3.Expr p)
    {
      if (p == null)
        return;
      if (!Sqlite3.ExprHasAnyProperty(p, 8192))
      {
        Sqlite3.sqlite3ExprDelete(db, ref p.pLeft);
        Sqlite3.sqlite3ExprDelete(db, ref p.pRight);
        if (!Sqlite3.ExprHasProperty(p, 4096) && ((int) p.flags2 & 1) != 0)
          Sqlite3.sqlite3DbFree(db, ref p.u.zToken);
        if (Sqlite3.ExprHasProperty(p, 2048))
          Sqlite3.sqlite3SelectDelete(db, ref p.x.pSelect);
        else
          Sqlite3.sqlite3ExprListDelete(db, ref p.x.pList);
      }
      if (Sqlite3.ExprHasProperty(p, 16384))
        return;
      Sqlite3.sqlite3DbFree<Sqlite3.Expr>(db, ref p);
    }

    private static int exprStructSize(Sqlite3.Expr p)
    {
      if (Sqlite3.ExprHasProperty(p, 8192))
        return 8;
      return Sqlite3.ExprHasProperty(p, 4096) ? 24 : 48;
    }

    private static int dupedExprStructSize(Sqlite3.Expr p, int flags) => (flags & 1) != 0 ? (p.pLeft != null || p.pRight != null || p.pColl != null || p.x.pList != null || p.x.pSelect != null ? 4120 : 8200) : 48;

    private static int dupedExprNodeSize(Sqlite3.Expr p, int flags)
    {
      int x = Sqlite3.dupedExprStructSize(p, flags) & 4095;
      if (!Sqlite3.ExprHasProperty(p, 1024) && p.u.zToken != null)
        x += Sqlite3.sqlite3Strlen30(p.u.zToken) + 1;
      return Sqlite3.ROUND8(x);
    }

    private static int dupedExprSize(Sqlite3.Expr p, int flags)
    {
      int num = 0;
      if (p != null)
      {
        num = Sqlite3.dupedExprNodeSize(p, flags);
        if ((flags & 1) != 0)
          num += Sqlite3.dupedExprSize(p.pLeft, flags) + Sqlite3.dupedExprSize(p.pRight, flags);
      }
      return num;
    }

    private static Sqlite3.Expr exprDup(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr p,
      int flags,
      ref Sqlite3.Expr pzBuffer)
    {
      Sqlite3.Expr E = (Sqlite3.Expr) null;
      if (p != null)
      {
        bool flag = (flags & 1) != 0;
        Sqlite3.Expr expr = new Sqlite3.Expr();
        uint num1 = 0;
        int num2 = Sqlite3.dupedExprStructSize(p, flags);
        int length = Sqlite3.ExprHasProperty(p, 1024) || string.IsNullOrEmpty(p.u.zToken) ? 0 : Sqlite3.sqlite3Strlen30(p.u.zToken);
        if (flag)
        {
          E = p.Copy(8);
        }
        else
        {
          Sqlite3.exprStructSize(p);
          E = p.Copy();
        }
        E.flags &= (ushort) 36863;
        E.flags |= (ushort) (num2 & 12288);
        E.flags |= (ushort) num1;
        if (length != 0)
          p.u.zToken.Substring(0, length);
        if ((((int) p.flags | (int) E.flags) & 8192) == 0)
        {
          if (Sqlite3.ExprHasProperty(p, 2048))
            E.x.pSelect = Sqlite3.sqlite3SelectDup(db, p.x.pSelect, flag ? 1 : 0);
          else
            E.x.pList = Sqlite3.sqlite3ExprListDup(db, p.x.pList, flag ? 1 : 0);
        }
        if (Sqlite3.ExprHasAnyProperty(E, 12288))
        {
          if (Sqlite3.ExprHasProperty(E, 4096))
          {
            E.pLeft = Sqlite3.exprDup(db, p.pLeft, 1, ref pzBuffer);
            E.pRight = Sqlite3.exprDup(db, p.pRight, 1, ref pzBuffer);
          }
        }
        else
        {
          E.flags2 = (byte) 0;
          if (!Sqlite3.ExprHasAnyProperty(p, 8192))
          {
            E.pLeft = Sqlite3.sqlite3ExprDup(db, p.pLeft, 0);
            E.pRight = Sqlite3.sqlite3ExprDup(db, p.pRight, 0);
          }
        }
      }
      return E;
    }

    private static Sqlite3.Expr sqlite3ExprDup(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr p,
      int flags)
    {
      Sqlite3.Expr pzBuffer = (Sqlite3.Expr) null;
      return Sqlite3.exprDup(db, p, flags, ref pzBuffer);
    }

    private static Sqlite3.ExprList sqlite3ExprListDup(
      Sqlite3.sqlite3 db,
      Sqlite3.ExprList p,
      int flags)
    {
      if (p == null)
        return (Sqlite3.ExprList) null;
      Sqlite3.ExprList exprList = new Sqlite3.ExprList()
      {
        iECursor = 0
      };
      exprList.nExpr = exprList.nAlloc = p.nExpr;
      exprList.a = new Sqlite3.ExprList_item[p.nExpr];
      for (int index = 0; index < p.nExpr; ++index)
      {
        Sqlite3.ExprList_item exprListItem1 = exprList.a[index] = new Sqlite3.ExprList_item();
        Sqlite3.ExprList_item exprListItem2 = p.a[index];
        Sqlite3.Expr pExpr = exprListItem2.pExpr;
        exprListItem1.pExpr = Sqlite3.sqlite3ExprDup(db, pExpr, flags);
        exprListItem1.zName = exprListItem2.zName;
        exprListItem1.zSpan = exprListItem2.zSpan;
        exprListItem1.sortOrder = exprListItem2.sortOrder;
        exprListItem1.done = (byte) 0;
        exprListItem1.iCol = exprListItem2.iCol;
        exprListItem1.iAlias = exprListItem2.iAlias;
      }
      return exprList;
    }

    private static Sqlite3.SrcList sqlite3SrcListDup(
      Sqlite3.sqlite3 db,
      Sqlite3.SrcList p,
      int flags)
    {
      if (p == null)
        return (Sqlite3.SrcList) null;
      Sqlite3.SrcList srcList = new Sqlite3.SrcList();
      if (p.nSrc > (short) 0)
        srcList.a = new Sqlite3.SrcList_item[(int) p.nSrc];
      if (srcList == null)
        return (Sqlite3.SrcList) null;
      srcList.nSrc = srcList.nAlloc = p.nSrc;
      for (int index = 0; index < (int) p.nSrc; ++index)
      {
        srcList.a[index] = new Sqlite3.SrcList_item();
        Sqlite3.SrcList_item srcListItem1 = srcList.a[index];
        Sqlite3.SrcList_item srcListItem2 = p.a[index];
        srcListItem1.zDatabase = srcListItem2.zDatabase;
        srcListItem1.zName = srcListItem2.zName;
        srcListItem1.zAlias = srcListItem2.zAlias;
        srcListItem1.jointype = srcListItem2.jointype;
        srcListItem1.iCursor = srcListItem2.iCursor;
        srcListItem1.isPopulated = srcListItem2.isPopulated;
        srcListItem1.zIndex = srcListItem2.zIndex;
        srcListItem1.notIndexed = srcListItem2.notIndexed;
        srcListItem1.pIndex = srcListItem2.pIndex;
        Sqlite3.Table pTab;
        Sqlite3.Table table1 = pTab = srcListItem2.pTab;
        srcListItem1.pTab = pTab;
        Sqlite3.Table table2 = table1;
        if (table2 != null)
          ++table2.nRef;
        srcListItem1.pSelect = Sqlite3.sqlite3SelectDup(db, srcListItem2.pSelect, flags);
        srcListItem1.pOn = Sqlite3.sqlite3ExprDup(db, srcListItem2.pOn, flags);
        srcListItem1.pUsing = Sqlite3.sqlite3IdListDup(db, srcListItem2.pUsing);
        srcListItem1.colUsed = srcListItem2.colUsed;
      }
      return srcList;
    }

    private static Sqlite3.IdList sqlite3IdListDup(Sqlite3.sqlite3 db, Sqlite3.IdList p)
    {
      if (p == null)
        return (Sqlite3.IdList) null;
      Sqlite3.IdList pT = new Sqlite3.IdList();
      if (pT == null)
        return (Sqlite3.IdList) null;
      pT.nId = pT.nAlloc = p.nId;
      pT.a = new Sqlite3.IdList_item[p.nId];
      if (pT.a == null)
      {
        Sqlite3.sqlite3DbFree<Sqlite3.IdList>(db, ref pT);
        return (Sqlite3.IdList) null;
      }
      for (int index = 0; index < p.nId; ++index)
      {
        pT.a[index] = new Sqlite3.IdList_item();
        Sqlite3.IdList_item idListItem1 = pT.a[index];
        Sqlite3.IdList_item idListItem2 = p.a[index];
        idListItem1.zName = idListItem2.zName;
        idListItem1.idx = idListItem2.idx;
      }
      return pT;
    }

    private static Sqlite3.Select sqlite3SelectDup(
      Sqlite3.sqlite3 db,
      Sqlite3.Select p,
      int flags)
    {
      if (p == null)
        return (Sqlite3.Select) null;
      Sqlite3.Select select = new Sqlite3.Select();
      select.pEList = Sqlite3.sqlite3ExprListDup(db, p.pEList, flags);
      select.pSrc = Sqlite3.sqlite3SrcListDup(db, p.pSrc, flags);
      select.pWhere = Sqlite3.sqlite3ExprDup(db, p.pWhere, flags);
      select.pGroupBy = Sqlite3.sqlite3ExprListDup(db, p.pGroupBy, flags);
      select.pHaving = Sqlite3.sqlite3ExprDup(db, p.pHaving, flags);
      select.pOrderBy = Sqlite3.sqlite3ExprListDup(db, p.pOrderBy, flags);
      select.op = p.op;
      select.pPrior = Sqlite3.sqlite3SelectDup(db, p.pPrior, flags);
      select.pLimit = Sqlite3.sqlite3ExprDup(db, p.pLimit, flags);
      select.pOffset = Sqlite3.sqlite3ExprDup(db, p.pOffset, flags);
      select.iLimit = 0;
      select.iOffset = 0;
      select.selFlags = (ushort) ((uint) p.selFlags & 4294967287U);
      select.pRightmost = (Sqlite3.Select) null;
      select.addrOpenEphm[0] = -1;
      select.addrOpenEphm[1] = -1;
      select.addrOpenEphm[2] = -1;
      return select;
    }

    private static Sqlite3.ExprList sqlite3ExprListAppend(
      Sqlite3.Parse pParse,
      int null_2,
      Sqlite3.Expr pExpr)
    {
      return Sqlite3.sqlite3ExprListAppend(pParse, (Sqlite3.ExprList) null, pExpr);
    }

    private static Sqlite3.ExprList sqlite3ExprListAppend(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      Sqlite3.Expr pExpr)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pList == null)
        pList = new Sqlite3.ExprList();
      if (pList.nAlloc <= pList.nExpr)
      {
        int newSize = pList.nAlloc * 2 + 4;
        Array.Resize<Sqlite3.ExprList_item>(ref pList.a, newSize);
        pList.nAlloc = pList.a.Length;
      }
      pList.a[pList.nExpr] = new Sqlite3.ExprList_item();
      pList.a[pList.nExpr++].pExpr = pExpr;
      return pList;
    }

    private static void sqlite3ExprListSetName(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      Sqlite3.Token pName,
      int dequote)
    {
      if (pList == null)
        return;
      Sqlite3.ExprList_item exprListItem = pList.a[pList.nExpr - 1];
      exprListItem.zName = pName.z.Substring(0, pName.n);
      if (dequote == 0 || string.IsNullOrEmpty(exprListItem.zName))
        return;
      Sqlite3.sqlite3Dequote(ref exprListItem.zName);
    }

    private static void sqlite3ExprListSetSpan(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      Sqlite3.ExprSpan pSpan)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pList == null)
        return;
      Sqlite3.ExprList_item exprListItem = pList.a[pList.nExpr - 1];
      Sqlite3.sqlite3DbFree(db, ref exprListItem.zSpan);
      exprListItem.zSpan = pSpan.zStart.Substring(0, pSpan.zStart.Length <= pSpan.zEnd.Length ? pSpan.zStart.Length : pSpan.zStart.Length - pSpan.zEnd.Length);
    }

    private static void sqlite3ExprListCheckLength(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pEList,
      string zObject)
    {
      int num = pParse.db.aLimit[2];
      Sqlite3.testcase<bool>(pEList != null && pEList.nExpr == num);
      Sqlite3.testcase<bool>(pEList != null && pEList.nExpr == num + 1);
      if (pEList == null || pEList.nExpr <= num)
        return;
      Sqlite3.sqlite3ErrorMsg(pParse, "too many columns in %s", (object) zObject);
    }

    private static void sqlite3ExprListDelete(Sqlite3.sqlite3 db, ref Sqlite3.ExprList pList)
    {
      if (pList == null)
        return;
      for (int index = 0; index < pList.nExpr; ++index)
      {
        Sqlite3.ExprList_item exprListItem;
        if ((exprListItem = pList.a[index]) != null)
        {
          Sqlite3.sqlite3ExprDelete(db, ref exprListItem.pExpr);
          Sqlite3.sqlite3DbFree(db, ref exprListItem.zName);
          Sqlite3.sqlite3DbFree(db, ref exprListItem.zSpan);
        }
      }
      Sqlite3.sqlite3DbFree<Sqlite3.ExprList_item[]>(db, ref pList.a);
      Sqlite3.sqlite3DbFree<Sqlite3.ExprList>(db, ref pList);
    }

    private static int exprNodeIsConstant(Sqlite3.Walker pWalker, ref Sqlite3.Expr pExpr)
    {
      if (pWalker.u.i == 3 && Sqlite3.ExprHasAnyProperty(pExpr, 1))
      {
        pWalker.u.i = 0;
        return 2;
      }
      switch (pExpr.op)
      {
        case 26:
        case 152:
        case 153:
        case 154:
          Sqlite3.testcase<bool>(pExpr.op == (byte) 26);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 152);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 153);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 154);
          pWalker.u.i = 0;
          return 2;
        case 151:
          if (pWalker.u.i == 2)
            return 0;
          goto case 26;
        default:
          Sqlite3.testcase<bool>(pExpr.op == (byte) 116);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 20);
          return 0;
      }
    }

    private static int selectNodeIsConstant(Sqlite3.Walker pWalker, Sqlite3.Select NotUsed)
    {
      Sqlite3.UNUSED_PARAMETER<Sqlite3.Select>(NotUsed);
      pWalker.u.i = 0;
      return 2;
    }

    private static int exprIsConst(Sqlite3.Expr p, int initFlag)
    {
      Sqlite3.Walker pWalker = new Sqlite3.Walker();
      pWalker.u.i = initFlag;
      pWalker.xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.exprNodeIsConstant);
      pWalker.xSelectCallback = new Sqlite3.dxSelectCallback(Sqlite3.selectNodeIsConstant);
      Sqlite3.sqlite3WalkExpr(pWalker, ref p);
      return pWalker.u.i;
    }

    private static int sqlite3ExprIsConstant(Sqlite3.Expr p) => Sqlite3.exprIsConst(p, 1);

    private static int sqlite3ExprIsConstantNotJoin(Sqlite3.Expr p) => Sqlite3.exprIsConst(p, 3);

    private static int sqlite3ExprIsConstantOrFunction(Sqlite3.Expr p) => Sqlite3.exprIsConst(p, 2);

    private static int sqlite3ExprIsInteger(Sqlite3.Expr p, ref int pValue)
    {
      int num = 0;
      if (((int) p.flags & 1024) != 0)
      {
        pValue = p.u.iValue;
        return 1;
      }
      switch (p.op)
      {
        case 156:
          int pValue1 = 0;
          if (Sqlite3.sqlite3ExprIsInteger(p.pLeft, ref pValue1) != 0)
          {
            pValue = -pValue1;
            num = 1;
            break;
          }
          break;
        case 157:
          num = Sqlite3.sqlite3ExprIsInteger(p.pLeft, ref pValue);
          break;
      }
      return num;
    }

    private static int sqlite3ExprCanBeNull(Sqlite3.Expr p)
    {
      while (p.op == (byte) 157 || p.op == (byte) 156)
        p = p.pLeft;
      byte num = p.op;
      if (num == (byte) 132)
        num = p.op2;
      if (num != (byte) 94)
      {
        switch ((int) num - 129)
        {
          case 0:
          case 1:
          case 2:
            break;
          default:
            return 1;
        }
      }
      return 0;
    }

    private static void sqlite3ExprCodeIsNullJump(
      Sqlite3.Vdbe v,
      Sqlite3.Expr pExpr,
      int iReg,
      int iDest)
    {
      if (Sqlite3.sqlite3ExprCanBeNull(pExpr) == 0)
        return;
      Sqlite3.sqlite3VdbeAddOp2(v, 73, iReg, iDest);
    }

    private static int sqlite3ExprNeedsNoAffinityChange(Sqlite3.Expr p, char aff)
    {
      if (aff == 'b')
        return 1;
      while (p.op == (byte) 157 || p.op == (byte) 156)
        p = p.pLeft;
      byte num = p.op;
      if (num == (byte) 132)
        num = p.op2;
      if (num != (byte) 94)
      {
        switch ((int) num - 129)
        {
          case 0:
            return aff != 'd' && aff != 'c' ? 0 : 1;
          case 1:
            return aff != 'e' && aff != 'c' ? 0 : 1;
          case 2:
            return 1;
          default:
            return num == (byte) 152 && p.iColumn < (short) 0 && (aff == 'd' || aff == 'c') ? 1 : 0;
        }
      }
      else
        return aff != 'a' ? 0 : 1;
    }

    private static bool sqlite3IsRowid(string z) => z.Equals("_ROWID_", StringComparison.InvariantCultureIgnoreCase) || z.Equals("ROWID", StringComparison.InvariantCultureIgnoreCase) || z.Equals("OID", StringComparison.InvariantCultureIgnoreCase);

    private static int isCandidateForInOpt(Sqlite3.Select p)
    {
      if (p == null || p.pPrior != null)
        return 0;
      if (((int) p.selFlags & 5) != 0)
      {
        Sqlite3.testcase<bool>(((int) p.selFlags & 5) == 1);
        Sqlite3.testcase<bool>(((int) p.selFlags & 5) == 4);
        return 0;
      }
      if (p.pLimit != null || p.pWhere != null)
        return 0;
      Sqlite3.SrcList pSrc = p.pSrc;
      if (pSrc.nSrc != (short) 1 || pSrc.a[0].pSelect != null)
        return 0;
      Sqlite3.Table pTab = pSrc.a[0].pTab;
      if (Sqlite3.NEVER(pTab == null) || Sqlite3.IsVirtual(pTab))
        return 0;
      Sqlite3.ExprList pElist = p.pEList;
      return pElist.nExpr != 1 || pElist.a[0].pExpr.op != (byte) 152 ? 0 : 1;
    }

    private static int sqlite3FindInIndex(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pX,
      ref int prNotFound)
    {
      int inIndex = 0;
      int num1 = pParse.nTab++;
      bool flag1 = prNotFound != 0;
      Sqlite3.Select p = Sqlite3.ExprHasProperty(pX, 2048) ? pX.x.pSelect : (Sqlite3.Select) null;
      if (Sqlite3.ALWAYS(pParse.nErr == 0) && Sqlite3.isCandidateForInOpt(p) != 0)
      {
        Sqlite3.sqlite3 db = pParse.db;
        Sqlite3.Expr pExpr = p.pEList.a[0].pExpr;
        int iColumn = (int) pExpr.iColumn;
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
        Sqlite3.Table pTab = p.pSrc.a[0].pTab;
        int index = Sqlite3.sqlite3SchemaToIndex(db, pTab.pSchema);
        Sqlite3.sqlite3CodeVerifySchema(pParse, index);
        Sqlite3.sqlite3TableLock(pParse, index, pTab.tnum, (byte) 0, pTab.zName);
        if (iColumn < 0)
        {
          int num2 = ++pParse.nMem;
          int addr = Sqlite3.sqlite3VdbeAddOp1(vdbe, 26, num2);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 1, num2);
          Sqlite3.sqlite3OpenTable(pParse, num1, index, pTab, 38);
          inIndex = 1;
          Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
        }
        else
        {
          Sqlite3.CollSeq collSeq = Sqlite3.sqlite3BinaryCompareCollSeq(pParse, pX.pLeft, pExpr);
          char ch = Sqlite3.comparisonAffinity(pX);
          bool flag2 = (int) pTab.aCol[iColumn].affinity == (int) ch || ch == 'b';
          for (Sqlite3.Index pIdx = pTab.pIndex; ((pIdx == null ? 0 : (inIndex == 0 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0; pIdx = pIdx.pNext)
          {
            if (pIdx.aiColumn[0] == iColumn && Sqlite3.sqlite3FindCollSeq(db, Sqlite3.ENC(db), pIdx.azColl[0], (byte) 0) == collSeq && (!flag1 || pIdx.nColumn == 1 && pIdx.onError != (byte) 0))
            {
              int num3 = ++pParse.nMem;
              Sqlite3.KeyInfo pP4 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
              int addr = Sqlite3.sqlite3VdbeAddOp1(vdbe, 26, num3);
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 1, num3);
              Sqlite3.sqlite3VdbeAddOp4(vdbe, 38, num1, pIdx.tnum, index, pP4, -16);
              inIndex = 3;
              Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
              if (pTab.aCol[iColumn].notNull == (byte) 0)
                prNotFound = ++pParse.nMem;
            }
          }
        }
      }
      if (inIndex == 0)
      {
        double nQueryLoop = pParse.nQueryLoop;
        int rMayHaveNull = 0;
        inIndex = 2;
        if (prNotFound != -1)
        {
          ref int local = ref prNotFound;
          int num4 = ++pParse.nMem;
          int num5;
          rMayHaveNull = num5 = num4;
          local = num5;
        }
        else
        {
          Sqlite3.testcase<bool>(pParse.nQueryLoop > 1.0);
          pParse.nQueryLoop = 1.0;
          if (pX.pLeft.iColumn < (short) 0 && !Sqlite3.ExprHasAnyProperty(pX, 2048))
            inIndex = 1;
        }
        Sqlite3.sqlite3CodeSubselect(pParse, pX, rMayHaveNull, inIndex == 1);
        pParse.nQueryLoop = nQueryLoop;
      }
      else
        pX.iTable = num1;
      return inIndex;
    }

    private static int sqlite3CodeSubselect(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      int rMayHaveNull,
      bool isRowid)
    {
      int num1 = 0;
      int num2 = 0;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (Sqlite3.NEVER(vdbe == null))
        return 0;
      Sqlite3.sqlite3ExprCachePush(pParse);
      if (!Sqlite3.ExprHasAnyProperty(pExpr, 32) && pParse.pTriggerTab == null)
      {
        int num3 = ++pParse.nMem;
        Sqlite3.sqlite3VdbeAddOp1(vdbe, 26, num3);
        num1 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 1, num3);
      }
      if (pParse.explain == (byte) 2)
      {
        string pP4 = Sqlite3.sqlite3MPrintf(pParse.db, "EXECUTE %s%s SUBQUERY %d", num1 != 0 ? (object) "" : (object) "CORRELATED ", pExpr.op == (byte) 72 ? (object) "LIST" : (object) "SCALAR", (object) pParse.iNextSelectId);
        Sqlite3.sqlite3VdbeAddOp4(vdbe, 138, pParse.iSelectId, 0, 0, pP4, -1);
      }
      switch (pExpr.op)
      {
        case 72:
          Sqlite3.Expr pLeft = pExpr.pLeft;
          if (rMayHaveNull != 0)
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, rMayHaveNull);
          char pP4_1 = Sqlite3.sqlite3ExprAffinity(pLeft);
          pExpr.iTable = pParse.nTab++;
          int addr = Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, pExpr.iTable, !isRowid);
          if (rMayHaveNull == 0)
            Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 16);
          Sqlite3.KeyInfo pKeyInfo = new Sqlite3.KeyInfo();
          pKeyInfo.nField = (ushort) 1;
          if (Sqlite3.ExprHasProperty(pExpr, 2048))
          {
            Sqlite3.SelectDest pDest = new Sqlite3.SelectDest();
            Sqlite3.sqlite3SelectDestInit(pDest, 7, pExpr.iTable);
            pDest.affinity = pP4_1;
            pExpr.x.pSelect.iLimit = 0;
            if (Sqlite3.sqlite3Select(pParse, pExpr.x.pSelect, ref pDest) != 0)
              return 0;
            Sqlite3.ExprList pElist = pExpr.x.pSelect.pEList;
            if (Sqlite3.ALWAYS(pElist != null) && pElist.nExpr > 0)
              pKeyInfo.aColl[0] = Sqlite3.sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pElist.a[0].pExpr);
          }
          else if (Sqlite3.ALWAYS(pExpr.x.pList != null))
          {
            Sqlite3.ExprList pList = pExpr.x.pList;
            if (pP4_1 == char.MinValue)
              pP4_1 = 'b';
            pKeyInfo.aColl[0] = Sqlite3.sqlite3ExprCollSeq(pParse, pExpr.pLeft);
            int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
            int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, tempReg2);
            for (int index = 0; index < pList.nExpr; ++index)
            {
              Sqlite3.Expr pExpr1 = pList.a[index].pExpr;
              int pValue = 0;
              if (num1 != 0 && Sqlite3.sqlite3ExprIsConstant(pExpr1) == 0)
              {
                Sqlite3.sqlite3VdbeChangeToNoop(vdbe, num1 - 1, 2);
                num1 = 0;
              }
              if (isRowid && Sqlite3.sqlite3ExprIsInteger(pExpr1, ref pValue) != 0)
              {
                Sqlite3.sqlite3VdbeAddOp3(vdbe, 56, pExpr.iTable, tempReg2, pValue);
              }
              else
              {
                int num4 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr1, tempReg1);
                if (isRowid)
                {
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 21, num4, Sqlite3.sqlite3VdbeCurrentAddr(vdbe) + 2);
                  Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, pExpr.iTable, tempReg2, num4);
                }
                else
                {
                  Sqlite3.sqlite3VdbeAddOp4(vdbe, 30, num4, 1, tempReg2, pP4_1, 1);
                  Sqlite3.sqlite3ExprCacheAffinityChange(pParse, num4, 1);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 70, pExpr.iTable, tempReg2);
                }
              }
            }
            Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
            Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
          }
          if (!isRowid)
          {
            Sqlite3.sqlite3VdbeChangeP4(vdbe, addr, pKeyInfo, -6);
            break;
          }
          break;
        default:
          Sqlite3.SelectDest pDest1 = new Sqlite3.SelectDest();
          Sqlite3.testcase<bool>(pExpr.op == (byte) 20);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 116);
          Sqlite3.Select pSelect = pExpr.x.pSelect;
          Sqlite3.sqlite3SelectDestInit(pDest1, 0, ++pParse.nMem);
          if (pExpr.op == (byte) 116)
          {
            pDest1.eDest = (byte) 6;
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, pDest1.iParm);
          }
          else
          {
            pDest1.eDest = (byte) 3;
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, pDest1.iParm);
          }
          Sqlite3.sqlite3ExprDelete(pParse.db, ref pSelect.pLimit);
          pSelect.pLimit = Sqlite3.sqlite3PExpr(pParse, 129, (Sqlite3.Expr) null, (Sqlite3.Expr) null, Sqlite3.sqlite3IntTokens[1]);
          pSelect.iLimit = 0;
          if (Sqlite3.sqlite3Select(pParse, pSelect, ref pDest1) != 0)
            return 0;
          num2 = pDest1.iParm;
          Sqlite3.ExprSetIrreducible(pExpr);
          break;
      }
      if (num1 != 0)
        Sqlite3.sqlite3VdbeJumpHere(vdbe, num1 - 1);
      Sqlite3.sqlite3ExprCachePop(pParse, 1);
      return num2;
    }

    private static void sqlite3ExprCodeIN(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      int destIfFalse,
      int destIfNull)
    {
      int prNotFound = 0;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.VdbeNoopComment(pVdbe, "begin IN expr");
      int inIndex = Sqlite3.sqlite3FindInIndex(pParse, pExpr, ref prNotFound);
      char pP4 = Sqlite3.comparisonAffinity(pExpr);
      Sqlite3.sqlite3ExprCachePush(pParse);
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3ExprCode(pParse, pExpr.pLeft, tempReg);
      if (destIfNull == destIfFalse)
      {
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 73, tempReg, destIfNull);
      }
      else
      {
        int addr = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 74, tempReg);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 65, pExpr.iTable, destIfFalse);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, destIfNull);
        Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr);
      }
      if (inIndex == 1)
      {
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 21, tempReg, destIfFalse);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 52, pExpr.iTable, destIfFalse, tempReg);
      }
      else
      {
        Sqlite3.sqlite3VdbeAddOp4(pVdbe, 29, tempReg, 1, 0, pP4, 1);
        if (prNotFound == 0 || destIfFalse == destIfNull)
        {
          Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, 49, pExpr.iTable, destIfFalse, tempReg, 1);
        }
        else
        {
          int addr1 = Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, 50, pExpr.iTable, 0, tempReg, 1);
          int addr2 = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 74, prNotFound);
          int addr3 = Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, 50, pExpr.iTable, 0, prNotFound, 1);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, -1, prNotFound);
          Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr3);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 20, prNotFound, 1);
          Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr2);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, prNotFound, destIfNull);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, destIfFalse);
          Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr1);
        }
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      Sqlite3.sqlite3ExprCachePop(pParse, 1);
      Sqlite3.VdbeComment(pVdbe, "end IN expr");
    }

    private static void codeReal(Sqlite3.Vdbe v, string z, bool negateFlag, int iMem)
    {
      if (!Sqlite3.ALWAYS(!string.IsNullOrEmpty(z)))
        return;
      double pResult = 0.0;
      Sqlite3.sqlite3AtoF(z, ref pResult, Sqlite3.sqlite3Strlen30(z), (byte) 1);
      if (negateFlag)
        pResult = -pResult;
      Sqlite3.sqlite3VdbeAddOp4(v, 130, 0, iMem, 0, pResult, -12);
    }

    private static void codeInteger(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      bool negFlag,
      int iMem)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      if (((int) pExpr.flags & 1024) != 0)
      {
        int p1 = pExpr.u.iValue;
        if (negFlag)
          p1 = -p1;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, p1, iMem);
      }
      else
      {
        long pNum = 0;
        string zToken = pExpr.u.zToken;
        int num = Sqlite3.sqlite3Atoi64(zToken, ref pNum, Sqlite3.sqlite3Strlen30(zToken), (byte) 1);
        if (num == 0 || num == 2 & negFlag)
        {
          if (negFlag)
            pNum = num == 2 ? long.MinValue : -pNum;
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 8, 0, iMem, 0, pNum, -13);
        }
        else
          Sqlite3.codeReal(pVdbe, zToken, negFlag, iMem);
      }
    }

    private static void cacheEntryClear(Sqlite3.Parse pParse, Sqlite3.yColCache p)
    {
      if (p.tempReg == (byte) 0)
        return;
      if ((int) pParse.nTempReg < Sqlite3.ArraySize<int>(pParse.aTempReg))
        pParse.aTempReg[(int) pParse.nTempReg++] = p.iReg;
      p.tempReg = (byte) 0;
    }

    private static void sqlite3ExprCacheStore(Sqlite3.Parse pParse, int iTab, int iCol, int iReg)
    {
      Sqlite3.yColCache yColCache1 = new Sqlite3.yColCache();
      if ((pParse.db.flags & 2) != 0)
        return;
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache yColCache2 = pParse.aColCache[index];
        if (yColCache2.iReg == 0)
        {
          yColCache2.iLevel = pParse.iCacheLevel;
          yColCache2.iTable = iTab;
          yColCache2.iColumn = iCol;
          yColCache2.iReg = iReg;
          yColCache2.tempReg = (byte) 0;
          yColCache2.lru = pParse.iCacheCnt++;
          return;
        }
      }
      int num = int.MaxValue;
      int index1 = -1;
      for (int index2 = 0; index2 < 10; ++index2)
      {
        Sqlite3.yColCache yColCache3 = pParse.aColCache[index2];
        if (yColCache3.lru < num)
        {
          index1 = index2;
          num = yColCache3.lru;
        }
      }
      if (!Sqlite3.ALWAYS(index1 >= 0))
        return;
      Sqlite3.yColCache yColCache4 = pParse.aColCache[index1];
      yColCache4.iLevel = pParse.iCacheLevel;
      yColCache4.iTable = iTab;
      yColCache4.iColumn = iCol;
      yColCache4.iReg = iReg;
      yColCache4.tempReg = (byte) 0;
      yColCache4.lru = pParse.iCacheCnt++;
    }

    private static void sqlite3ExprCacheRemove(Sqlite3.Parse pParse, int iReg, int nReg)
    {
      int num = iReg + nReg - 1;
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache p = pParse.aColCache[index];
        int iReg1 = p.iReg;
        if (iReg1 >= iReg && iReg1 <= num)
        {
          Sqlite3.cacheEntryClear(pParse, p);
          p.iReg = 0;
        }
      }
    }

    private static void sqlite3ExprCachePush(Sqlite3.Parse pParse) => ++pParse.iCacheLevel;

    private static void sqlite3ExprCachePop(Sqlite3.Parse pParse, int N)
    {
      pParse.iCacheLevel -= N;
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache p = pParse.aColCache[index];
        if (p.iReg != 0 && p.iLevel > pParse.iCacheLevel)
        {
          Sqlite3.cacheEntryClear(pParse, p);
          p.iReg = 0;
        }
      }
    }

    private static void sqlite3ExprCachePinRegister(Sqlite3.Parse pParse, int iReg)
    {
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache yColCache = pParse.aColCache[index];
        if (yColCache.iReg == iReg)
          yColCache.tempReg = (byte) 0;
      }
    }

    private static void sqlite3ExprCodeGetColumnOfTable(
      Sqlite3.Vdbe v,
      Sqlite3.Table pTab,
      int iTabCur,
      int iCol,
      int regOut)
    {
      if (iCol < 0 || iCol == pTab.iPKey)
      {
        Sqlite3.sqlite3VdbeAddOp2(v, 61, iTabCur, regOut);
      }
      else
      {
        int op = Sqlite3.IsVirtual(pTab) ? 129 : 28;
        Sqlite3.sqlite3VdbeAddOp3(v, op, iTabCur, iCol, regOut);
      }
      if (iCol < 0)
        return;
      Sqlite3.sqlite3ColumnDefault(v, pTab, iCol, regOut);
    }

    private static int sqlite3ExprCodeGetColumn(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int iColumn,
      int iTable,
      int iReg)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache yColCache = pParse.aColCache[index];
        if (yColCache.iReg > 0 && yColCache.iTable == iTable && yColCache.iColumn == iColumn)
        {
          yColCache.lru = pParse.iCacheCnt++;
          Sqlite3.sqlite3ExprCachePinRegister(pParse, yColCache.iReg);
          return yColCache.iReg;
        }
      }
      Sqlite3.sqlite3ExprCodeGetColumnOfTable(pVdbe, pTab, iTable, iColumn, iReg);
      Sqlite3.sqlite3ExprCacheStore(pParse, iTable, iColumn, iReg);
      return iReg;
    }

    private static void sqlite3ExprCacheClear(Sqlite3.Parse pParse)
    {
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache p = pParse.aColCache[index];
        if (p.iReg != 0)
        {
          Sqlite3.cacheEntryClear(pParse, p);
          p.iReg = 0;
        }
      }
    }

    private static void sqlite3ExprCacheAffinityChange(
      Sqlite3.Parse pParse,
      int iStart,
      int iCount)
    {
      Sqlite3.sqlite3ExprCacheRemove(pParse, iStart, iCount);
    }

    private static void sqlite3ExprCodeMove(Sqlite3.Parse pParse, int iFrom, int iTo, int nReg)
    {
      if (Sqlite3.NEVER(iFrom == iTo))
        return;
      Sqlite3.sqlite3VdbeAddOp3(pParse.pVdbe, 13, iFrom, iTo, nReg);
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache yColCache = pParse.aColCache[index];
        int iReg = yColCache.iReg;
        if (iReg >= iFrom && iReg < iFrom + nReg)
          yColCache.iReg += iTo - iFrom;
      }
    }

    private static void sqlite3ExprCodeCopy(Sqlite3.Parse pParse, int iFrom, int iTo, int nReg)
    {
      if (Sqlite3.NEVER(iFrom == iTo))
        return;
      for (int index = 0; index < nReg; ++index)
        Sqlite3.sqlite3VdbeAddOp2(pParse.pVdbe, 14, iFrom + index, iTo + index);
    }

    private static int usedAsColumnCache(Sqlite3.Parse pParse, int iFrom, int iTo) => 0;

    private static int sqlite3ExprCodeTarget(Sqlite3.Parse pParse, Sqlite3.Expr pExpr, int target)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int num1 = target;
      int pReg1 = 0;
      int pReg2 = 0;
      Sqlite3.sqlite3 db = pParse.db;
      if (pVdbe == null)
        return 0;
      int num2 = pExpr != null ? (int) pExpr.op : 98;
      switch (num2)
      {
        case 19:
        case 93:
          Sqlite3.testcase<bool>(num2 == 93);
          Sqlite3.testcase<bool>(num2 == 19);
          int p1_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          Sqlite3.testcase<bool>(pReg1 == 0);
          num1 = target;
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, num2, p1_1, num1);
          break;
        case 20:
        case 116:
          Sqlite3.testcase<bool>(num2 == 20);
          Sqlite3.testcase<bool>(num2 == 116);
          num1 = Sqlite3.sqlite3CodeSubselect(pParse, pExpr, 0, false);
          break;
        case 24:
          num1 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr.pLeft, target);
          break;
        case 37:
          num1 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr.pLeft, target);
          int op = (int) Sqlite3.sqlite3AffinityType(pExpr.u.zToken) - 97 + 141;
          Sqlite3.testcase<bool>(op == 141);
          Sqlite3.testcase<bool>(op == 142);
          Sqlite3.testcase<bool>(op == 143);
          Sqlite3.testcase<bool>(op == 144);
          Sqlite3.testcase<bool>(op == 145);
          if (num1 != target)
          {
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 15, num1, target);
            num1 = target;
          }
          Sqlite3.sqlite3VdbeAddOp1(pVdbe, op, num1);
          Sqlite3.testcase<bool>(Sqlite3.usedAsColumnCache(pParse, num1, num1) != 0);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, num1, 1);
          break;
        case 56:
          if (pParse.pTriggerTab == null)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "RAISE() may only be used within a trigger-program");
            return 0;
          }
          if (pExpr.affinity == '\u0002')
            Sqlite3.sqlite3MayAbort(pParse);
          if (pExpr.affinity == '\u0004')
          {
            Sqlite3.sqlite3VdbeAddOp4(pVdbe, 6, 0, 4, 0, pExpr.u.zToken, 0);
            break;
          }
          Sqlite3.sqlite3HaltConstraint(pParse, (int) pExpr.affinity, pExpr.u.zToken, 0);
          break;
        case 60:
          Sqlite3.Table pTab = pExpr.pTab;
          int p1_2 = pExpr.iTable * (pTab.nCol + 1) + 1 + (int) pExpr.iColumn;
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 109, p1_2, target);
          Sqlite3.VdbeComment(pVdbe, "%s.%s -> $%d", pExpr.iTable != 0 ? (object) "new" : (object) "old", pExpr.iColumn < (short) 0 ? (object) "rowid" : (object) pExpr.pTab.aCol[(int) pExpr.iColumn].zName, (object) target);
          if (pExpr.iColumn >= (short) 0 && pTab.aCol[(int) pExpr.iColumn].affinity == 'e')
          {
            Sqlite3.sqlite3VdbeAddOp1(pVdbe, 22, target);
            break;
          }
          break;
        case 68:
        case 69:
        case 82:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
          Sqlite3.testcase<bool>(num2 == 69);
          Sqlite3.testcase<bool>(num2 == 68);
          Sqlite3.testcase<bool>(num2 == 86);
          Sqlite3.testcase<bool>(num2 == 87);
          Sqlite3.testcase<bool>(num2 == 90);
          Sqlite3.testcase<bool>(num2 == 82);
          Sqlite3.testcase<bool>(num2 == 83);
          Sqlite3.testcase<bool>(num2 == 89);
          Sqlite3.testcase<bool>(num2 == 84);
          Sqlite3.testcase<bool>(num2 == 85);
          Sqlite3.testcase<bool>(num2 == 91);
          int p2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int p1_3 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, num2, p1_3, p2, target);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        case 70:
        case 146:
          Sqlite3.testcase<bool>(num2 == 70);
          Sqlite3.testcase<bool>(num2 == 146);
          int in1_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int in2_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          int opcode = num2 == 70 ? 76 : 75;
          Sqlite3.codeCompare(pParse, pExpr.pLeft, pExpr.pRight, opcode, in1_1, in2_1, num1, 144);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        case 71:
          Sqlite3.Expr pLeft1 = pExpr.pLeft;
          Sqlite3.Expr pExpr1 = pExpr.x.pList.a[0].pExpr;
          int in1_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pLeft1, ref pReg1);
          int in2_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr1, ref pReg2);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
          int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.codeCompare(pParse, pLeft1, pExpr1, 80, in1_2, in2_2, tempReg1, 16);
          Sqlite3.Expr pExpr2 = pExpr.x.pList.a[1].pExpr;
          Sqlite3.sqlite3ReleaseTempReg(pParse, pReg2);
          int in2_3 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr2, ref pReg2);
          Sqlite3.testcase<bool>(pReg2 == 0);
          Sqlite3.codeCompare(pParse, pLeft1, pExpr2, 78, in1_2, in2_3, tempReg2, 16);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 69, tempReg1, tempReg2, target);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
          break;
        case 72:
          int num3 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
          int num4 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, target);
          Sqlite3.sqlite3ExprCodeIN(pParse, pExpr, num3, num4);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, target);
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num3);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 20, target, 0);
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num4);
          break;
        case 73:
        case 74:
          Sqlite3.testcase<bool>(num2 == 73);
          Sqlite3.testcase<bool>(num2 == 74);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, target);
          int p1_4 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          Sqlite3.testcase<bool>(pReg1 == 0);
          int addr = Sqlite3.sqlite3VdbeAddOp1(pVdbe, num2, p1_4);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 20, target, -1);
          Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr);
          break;
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
          Sqlite3.testcase<bool>(num2 == 79);
          Sqlite3.testcase<bool>(num2 == 78);
          Sqlite3.testcase<bool>(num2 == 77);
          Sqlite3.testcase<bool>(num2 == 80);
          Sqlite3.testcase<bool>(num2 == 76);
          Sqlite3.testcase<bool>(num2 == 75);
          int in1_3 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int in2_4 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          Sqlite3.codeCompare(pParse, pExpr.pLeft, pExpr.pRight, num2, in1_3, in2_4, num1, 16);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        case 94:
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 94, 0, target, 0, pExpr.u.zToken, 0);
          break;
        case 98:
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, target);
          break;
        case 129:
          Sqlite3.codeInteger(pParse, pExpr, false, target);
          break;
        case 130:
          Sqlite3.codeReal(pVdbe, pExpr.u.zToken, false, target);
          break;
        case 131:
          string z = pExpr.u.zToken.Substring(2);
          int n = Sqlite3.sqlite3Strlen30(z) - 1;
          byte[] blob = Sqlite3.sqlite3HexToBlob(Sqlite3.sqlite3VdbeDb(pVdbe), z, n);
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 11, n / 2, target, 0, blob, -1);
          break;
        case 132:
          num1 = pExpr.iTable;
          break;
        case 133:
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 12, (int) pExpr.iColumn, target);
          if (pExpr.u.zToken.Length > 1)
          {
            Sqlite3.sqlite3VdbeChangeP4(pVdbe, -1, pParse.azVar[(int) pExpr.iColumn - 1], -2);
            break;
          }
          break;
        case 151:
        case 155:
          int p1_5 = 0;
          byte enc = Sqlite3.ENC(db);
          Sqlite3.CollSeq pP4 = (Sqlite3.CollSeq) null;
          Sqlite3.testcase<bool>(num2 == 155);
          Sqlite3.testcase<bool>(num2 == 151);
          Sqlite3.ExprList pList1 = !Sqlite3.ExprHasAnyProperty(pExpr, 8192) ? pExpr.x.pList : (Sqlite3.ExprList) null;
          int num5 = pList1 != null ? pList1.nExpr : 0;
          string zToken = pExpr.u.zToken;
          int nName = Sqlite3.sqlite3Strlen30(zToken);
          Sqlite3.FuncDef function = Sqlite3.sqlite3FindFunction(pParse.db, zToken, nName, num5, enc, (byte) 0);
          if (function == null)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "unknown function: %.*s()", (object) nName, (object) zToken);
            break;
          }
          if (((int) function.flags & 64) != 0)
          {
            int num6 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
            Sqlite3.sqlite3ExprCode(pParse, pList1.a[0].pExpr, target);
            for (int index = 1; index < num5; ++index)
            {
              Sqlite3.sqlite3VdbeAddOp2(pVdbe, 74, target, num6);
              Sqlite3.sqlite3ExprCacheRemove(pParse, target, 1);
              Sqlite3.sqlite3ExprCachePush(pParse);
              Sqlite3.sqlite3ExprCode(pParse, pList1.a[index].pExpr, target);
              Sqlite3.sqlite3ExprCachePop(pParse, 1);
            }
            Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num6);
            break;
          }
          int num7;
          if (pList1 != null)
          {
            num7 = Sqlite3.sqlite3GetTempRange(pParse, num5);
            Sqlite3.sqlite3ExprCachePush(pParse);
            Sqlite3.sqlite3ExprCodeExprList(pParse, pList1, num7, true);
            Sqlite3.sqlite3ExprCachePop(pParse, 1);
          }
          else
            num7 = 0;
          for (int index = 0; index < num5; ++index)
          {
            if (index < 32 && Sqlite3.sqlite3ExprIsConstant(pList1.a[index].pExpr) != 0)
              p1_5 |= 1 << index;
            if (((int) function.flags & 8) != 0 && pP4 == null)
              pP4 = Sqlite3.sqlite3ExprCollSeq(pParse, pList1.a[index].pExpr);
          }
          if (((int) function.flags & 8) != 0)
          {
            if (pP4 == null)
              pP4 = db.pDfltColl;
            Sqlite3.sqlite3VdbeAddOp4(pVdbe, 17, 0, 0, 0, pP4, -4);
          }
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 18, p1_5, num7, target, function, -5);
          Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) num5);
          if (num5 != 0)
          {
            Sqlite3.sqlite3ReleaseTempRange(pParse, num7, num5);
            break;
          }
          break;
        case 152:
          num1 = pExpr.iTable >= 0 ? Sqlite3.sqlite3ExprCodeGetColumn(pParse, pExpr.pTab, (int) pExpr.iColumn, pExpr.iTable, target) : (int) pExpr.iColumn + pParse.ckBase;
          break;
        case 153:
          Sqlite3.AggInfo pAggInfo1 = pExpr.pAggInfo;
          if (pAggInfo1 == null)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", (object) pExpr.u.zToken);
            break;
          }
          num1 = pAggInfo1.aFunc[(int) pExpr.iAgg].iMem;
          break;
        case 154:
          Sqlite3.AggInfo pAggInfo2 = pExpr.pAggInfo;
          Sqlite3.AggInfo_col aggInfoCol = pAggInfo2.aCol[(int) pExpr.iAgg];
          if (pAggInfo2.directMode == (byte) 0)
          {
            num1 = aggInfoCol.iMem;
            break;
          }
          if (pAggInfo2.useSortingIdx != (byte) 0)
          {
            Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, pAggInfo2.sortingIdx, aggInfoCol.iSorterColumn, target);
            break;
          }
          goto case 152;
        case 156:
          Sqlite3.Expr pLeft2 = pExpr.pLeft;
          if (pLeft2.op == (byte) 129)
            Sqlite3.codeInteger(pParse, pLeft2, true, target);
          else if (pLeft2.op == (byte) 130)
          {
            Sqlite3.codeReal(pVdbe, pLeft2.u.zToken, true, target);
          }
          else
          {
            int tempReg3;
            pReg1 = tempReg3 = Sqlite3.sqlite3GetTempReg(pParse);
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, tempReg3);
            int p1_6 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg2);
            Sqlite3.sqlite3VdbeAddOp3(pVdbe, 87, p1_6, tempReg3, target);
            Sqlite3.testcase<bool>(pReg2 == 0);
          }
          num1 = target;
          break;
        case 157:
          num1 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr.pLeft, target);
          break;
        default:
          Sqlite3.Expr expr1 = new Sqlite3.Expr();
          Sqlite3.Expr pExpr3 = (Sqlite3.Expr) null;
          Sqlite3.ExprList pList2 = pExpr.x.pList;
          Sqlite3.ExprList_item[] a = pList2.a;
          int nExpr = pList2.nExpr;
          int num8 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
          Sqlite3.Expr pLeft3;
          if ((pLeft3 = pExpr.pLeft) != null)
          {
            Sqlite3.Expr expr2 = pLeft3;
            Sqlite3.testcase<bool>(pLeft3.op == (byte) 152);
            Sqlite3.testcase<bool>(pLeft3.op == (byte) 132);
            expr2.iTable = Sqlite3.sqlite3ExprCodeTemp(pParse, pLeft3, ref pReg1);
            Sqlite3.testcase<bool>(pReg1 == 0);
            expr2.op = (byte) 132;
            expr1.op = (byte) 76;
            expr1.pLeft = expr2;
            pExpr3 = expr1;
            pReg1 = 0;
          }
          for (int index = 0; index < nExpr; index += 2)
          {
            Sqlite3.sqlite3ExprCachePush(pParse);
            if (pLeft3 != null)
              expr1.pRight = a[index].pExpr;
            else
              pExpr3 = a[index].pExpr;
            int num9 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
            Sqlite3.testcase<bool>(pExpr3.op == (byte) 152);
            Sqlite3.sqlite3ExprIfFalse(pParse, pExpr3, num9, 8);
            Sqlite3.testcase<bool>(a[index + 1].pExpr.op == (byte) 152);
            Sqlite3.testcase<bool>(a[index + 1].pExpr.op == (byte) 132);
            Sqlite3.sqlite3ExprCode(pParse, a[index + 1].pExpr, target);
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, num8);
            Sqlite3.sqlite3ExprCachePop(pParse, 1);
            Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num9);
          }
          if (pExpr.pRight != null)
          {
            Sqlite3.sqlite3ExprCachePush(pParse);
            Sqlite3.sqlite3ExprCode(pParse, pExpr.pRight, target);
            Sqlite3.sqlite3ExprCachePop(pParse, 1);
          }
          else
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, target);
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num8);
          break;
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg1);
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg2);
      return num1;
    }

    private static int sqlite3ExprCodeTemp(Sqlite3.Parse pParse, Sqlite3.Expr pExpr, ref int pReg)
    {
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      int num = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr, tempReg);
      if (num == tempReg)
      {
        pReg = tempReg;
        return num;
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      pReg = 0;
      return num;
    }

    private static int sqlite3ExprCode(Sqlite3.Parse pParse, Sqlite3.Expr pExpr, int target)
    {
      if (pExpr != null && pExpr.op == (byte) 132)
      {
        Sqlite3.sqlite3VdbeAddOp2(pParse.pVdbe, 14, pExpr.iTable, target);
      }
      else
      {
        int p1 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr, target);
        if (p1 != target && pParse.pVdbe != null)
          Sqlite3.sqlite3VdbeAddOp2(pParse.pVdbe, 15, p1, target);
      }
      return target;
    }

    private static int sqlite3ExprCodeAndCache(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      int target)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int p1 = Sqlite3.sqlite3ExprCode(pParse, pExpr, target);
      if (Sqlite3.ALWAYS(pExpr.op != (byte) 132))
      {
        int p2 = ++pParse.nMem;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 14, p1, p2);
        pExpr.iTable = p2;
        pExpr.op2 = pExpr.op;
        pExpr.op = (byte) 132;
      }
      return p1;
    }

    private static int isAppropriateForFactoring(Sqlite3.Expr p)
    {
      if (Sqlite3.sqlite3ExprIsConstantNotJoin(p) == 0)
        return 0;
      if (((int) p.flags & 512) == 0)
        return 1;
      while (p.op == (byte) 157)
        p = p.pLeft;
      switch (p.op)
      {
        case 94:
        case 98:
        case 129:
        case 130:
        case 131:
        case 133:
          Sqlite3.testcase<bool>(p.op == (byte) 131);
          Sqlite3.testcase<bool>(p.op == (byte) 133);
          Sqlite3.testcase<bool>(p.op == (byte) 129);
          Sqlite3.testcase<bool>(p.op == (byte) 130);
          Sqlite3.testcase<bool>(p.op == (byte) 98);
          Sqlite3.testcase<bool>(p.op == (byte) 94);
          return 0;
        case 156:
          if (p.pLeft.op == (byte) 130 || p.pLeft.op == (byte) 129)
            return 0;
          break;
      }
      return 1;
    }

    private static int evalConstExpr(Sqlite3.Walker pWalker, ref Sqlite3.Expr pExpr)
    {
      Sqlite3.Parse pParse = pWalker.pParse;
      switch (pExpr.op)
      {
        case 72:
        case 132:
          return 1;
        case 151:
        case 153:
        case 155:
          Sqlite3.ExprList pList = pExpr.x.pList;
          if (pList != null)
          {
            for (int nExpr = pList.nExpr; nExpr > 0; --nExpr)
            {
              Sqlite3.ExprList_item exprListItem = pList.a[pList.nExpr - nExpr];
              if (Sqlite3.ALWAYS(exprListItem.pExpr != null))
                exprListItem.pExpr.flags |= (ushort) 512;
            }
            break;
          }
          break;
      }
      if (Sqlite3.isAppropriateForFactoring(pExpr) == 0)
        return 0;
      int num1 = ++pParse.nMem;
      int num2 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr, num1);
      if (Sqlite3.NEVER(num1 != num2))
        Sqlite3.sqlite3ReleaseTempReg(pParse, num1);
      pExpr.op2 = pExpr.op;
      pExpr.op = (byte) 132;
      pExpr.iTable = num2;
      return 1;
    }

    private static void sqlite3ExprCodeConstants(Sqlite3.Parse pParse, Sqlite3.Expr pExpr)
    {
      if (pParse.cookieGoto != 0 || (pParse.db.flags & 64) != 0)
        return;
      Sqlite3.sqlite3WalkExpr(new Sqlite3.Walker()
      {
        xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.evalConstExpr),
        xSelectCallback = (Sqlite3.dxSelectCallback) null,
        pParse = pParse
      }, ref pExpr);
    }

    private static int sqlite3ExprCodeExprList(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList,
      int target,
      bool doHardCopy)
    {
      int nExpr = pList.nExpr;
      for (int index = 0; index < nExpr; ++index)
      {
        Sqlite3.Expr pExpr = pList.a[index].pExpr;
        int p1 = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr, target + index);
        if (p1 != target + index)
          Sqlite3.sqlite3VdbeAddOp2(pParse.pVdbe, doHardCopy ? 14 : 15, p1, target + index);
      }
      return nExpr;
    }

    private static void exprCodeBetween(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      int dest,
      int jumpIfTrue,
      int jumpIfNull)
    {
      Sqlite3.Expr pExpr1 = new Sqlite3.Expr();
      Sqlite3.Expr expr1 = new Sqlite3.Expr();
      Sqlite3.Expr expr2 = new Sqlite3.Expr();
      int pReg = 0;
      Sqlite3.Expr pExpr2 = pExpr.pLeft.Copy();
      pExpr1.op = (byte) 69;
      pExpr1.pLeft = expr1;
      pExpr1.pRight = expr2;
      expr1.op = (byte) 80;
      expr1.pLeft = pExpr2;
      expr1.pRight = pExpr.x.pList.a[0].pExpr;
      expr2.op = (byte) 78;
      expr2.pLeft = pExpr2;
      expr2.pRight = pExpr.x.pList.a[1].pExpr;
      pExpr2.iTable = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr2, ref pReg);
      pExpr2.op = (byte) 132;
      if (jumpIfTrue != 0)
        Sqlite3.sqlite3ExprIfTrue(pParse, pExpr1, dest, jumpIfNull);
      else
        Sqlite3.sqlite3ExprIfFalse(pParse, pExpr1, dest, jumpIfNull);
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg);
      Sqlite3.testcase<bool>(jumpIfTrue == 0 && jumpIfNull == 0 && pReg == 0);
      Sqlite3.testcase<bool>(jumpIfTrue == 0 && jumpIfNull == 0 && pReg != 0);
      Sqlite3.testcase<bool>(jumpIfTrue == 0 && jumpIfNull != 0 && pReg == 0);
      Sqlite3.testcase<bool>(jumpIfTrue == 0 && jumpIfNull != 0 && pReg != 0);
      Sqlite3.testcase<bool>(jumpIfTrue != 0 && jumpIfNull == 0 && pReg == 0);
      Sqlite3.testcase<bool>(jumpIfTrue != 0 && jumpIfNull == 0 && pReg != 0);
      Sqlite3.testcase<bool>(jumpIfTrue != 0 && jumpIfNull != 0 && pReg == 0);
      Sqlite3.testcase<bool>(jumpIfTrue != 0 && jumpIfNull != 0 && pReg != 0);
    }

    private static void sqlite3ExprIfTrue(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      int dest,
      int jumpIfNull)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int pReg1 = 0;
      int pReg2 = 0;
      if (Sqlite3.NEVER(pVdbe == null) || Sqlite3.NEVER(pExpr == null))
        return;
      int op = (int) pExpr.op;
      switch (op)
      {
        case 19:
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.sqlite3ExprIfFalse(pParse, pExpr.pLeft, dest, jumpIfNull);
          break;
        case 68:
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.sqlite3ExprIfTrue(pParse, pExpr.pLeft, dest, jumpIfNull);
          Sqlite3.sqlite3ExprIfTrue(pParse, pExpr.pRight, dest, jumpIfNull);
          break;
        case 69:
          int num = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.sqlite3ExprCachePush(pParse);
          Sqlite3.sqlite3ExprIfFalse(pParse, pExpr.pLeft, num, jumpIfNull ^ 8);
          Sqlite3.sqlite3ExprIfTrue(pParse, pExpr.pRight, dest, jumpIfNull);
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num);
          Sqlite3.sqlite3ExprCachePop(pParse, 1);
          break;
        case 70:
        case 146:
          Sqlite3.testcase<bool>(op == 70);
          Sqlite3.testcase<bool>(op == 146);
          int in1_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int in2_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          int opcode = op == 70 ? 76 : 75;
          Sqlite3.codeCompare(pParse, pExpr.pLeft, pExpr.pRight, opcode, in1_1, in2_1, dest, 128);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        case 71:
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.exprCodeBetween(pParse, pExpr, dest, 1, jumpIfNull);
          break;
        case 73:
        case 74:
          Sqlite3.testcase<bool>(op == 73);
          Sqlite3.testcase<bool>(op == 74);
          int p1_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, op, p1_1, dest);
          Sqlite3.testcase<bool>(pReg1 == 0);
          break;
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
          Sqlite3.testcase<bool>(op == 79);
          Sqlite3.testcase<bool>(op == 78);
          Sqlite3.testcase<bool>(op == 77);
          Sqlite3.testcase<bool>(op == 80);
          Sqlite3.testcase<bool>(op == 76);
          Sqlite3.testcase<bool>(op == 75);
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          int in1_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int in2_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          Sqlite3.codeCompare(pParse, pExpr.pLeft, pExpr.pRight, op, in1_2, in2_2, dest, jumpIfNull);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        default:
          int p1_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr, ref pReg1);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 26, p1_2, dest, jumpIfNull != 0 ? 1 : 0);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          break;
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg1);
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg2);
    }

    private static void sqlite3ExprIfFalse(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      int dest,
      int jumpIfNull)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int pReg1 = 0;
      int pReg2 = 0;
      if (Sqlite3.NEVER(pVdbe == null) || pExpr == null)
        return;
      int num1 = ((int) pExpr.op + 1 ^ 1) - 1;
      switch (pExpr.op)
      {
        case 19:
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.sqlite3ExprIfTrue(pParse, pExpr.pLeft, dest, jumpIfNull);
          break;
        case 68:
          int num2 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.sqlite3ExprCachePush(pParse);
          Sqlite3.sqlite3ExprIfTrue(pParse, pExpr.pLeft, num2, jumpIfNull ^ 8);
          Sqlite3.sqlite3ExprIfFalse(pParse, pExpr.pRight, dest, jumpIfNull);
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num2);
          Sqlite3.sqlite3ExprCachePop(pParse, 1);
          break;
        case 69:
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.sqlite3ExprIfFalse(pParse, pExpr.pLeft, dest, jumpIfNull);
          Sqlite3.sqlite3ExprIfFalse(pParse, pExpr.pRight, dest, jumpIfNull);
          break;
        case 70:
        case 146:
          Sqlite3.testcase<bool>(pExpr.op == (byte) 70);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 146);
          int in1_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int in2_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          int opcode = pExpr.op == (byte) 70 ? 75 : 76;
          Sqlite3.codeCompare(pParse, pExpr.pLeft, pExpr.pRight, opcode, in1_1, in2_1, dest, 128);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        case 71:
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          Sqlite3.exprCodeBetween(pParse, pExpr, dest, 0, jumpIfNull);
          break;
        case 73:
        case 74:
          Sqlite3.testcase<bool>(num1 == 73);
          Sqlite3.testcase<bool>(num1 == 74);
          int p1_1 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, num1, p1_1, dest);
          Sqlite3.testcase<bool>(pReg1 == 0);
          break;
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
          Sqlite3.testcase<bool>(num1 == 79);
          Sqlite3.testcase<bool>(num1 == 78);
          Sqlite3.testcase<bool>(num1 == 77);
          Sqlite3.testcase<bool>(num1 == 80);
          Sqlite3.testcase<bool>(num1 == 76);
          Sqlite3.testcase<bool>(num1 == 75);
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          int in1_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pLeft, ref pReg1);
          int in2_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg2);
          Sqlite3.codeCompare(pParse, pExpr.pLeft, pExpr.pRight, num1, in1_2, in2_2, dest, jumpIfNull);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(pReg2 == 0);
          break;
        default:
          int p1_2 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr, ref pReg1);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 27, p1_2, dest, jumpIfNull != 0 ? 1 : 0);
          Sqlite3.testcase<bool>(pReg1 == 0);
          Sqlite3.testcase<bool>(jumpIfNull == 0);
          break;
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg1);
      Sqlite3.sqlite3ReleaseTempReg(pParse, pReg2);
    }

    private static int sqlite3ExprCompare(Sqlite3.Expr pA, Sqlite3.Expr pB)
    {
      if (pA == null || pB == null)
        return pB != pA ? 2 : 0;
      if (Sqlite3.ExprHasProperty(pA, 2048) || Sqlite3.ExprHasProperty(pB, 2048) || ((int) pA.flags & 16) != ((int) pB.flags & 16) || (int) pA.op != (int) pB.op || Sqlite3.sqlite3ExprCompare(pA.pLeft, pB.pLeft) != 0 || Sqlite3.sqlite3ExprCompare(pA.pRight, pB.pRight) != 0 || Sqlite3.sqlite3ExprListCompare(pA.x.pList, pB.x.pList) != 0 || pA.iTable != pB.iTable || (int) pA.iColumn != (int) pB.iColumn)
        return 2;
      if (Sqlite3.ExprHasProperty(pA, 1024))
      {
        if (!Sqlite3.ExprHasProperty(pB, 1024) || pA.u.iValue != pB.u.iValue)
          return 2;
      }
      else if (pA.op != (byte) 152 && pA.u.zToken != null && (Sqlite3.ExprHasProperty(pB, 1024) || Sqlite3.NEVER(pB.u.zToken == null) || !pA.u.zToken.Equals(pB.u.zToken, StringComparison.InvariantCultureIgnoreCase)))
        return 2;
      if (((int) pA.flags & 256) != ((int) pB.flags & 256))
        return 1;
      return ((int) pA.flags & 256) != 0 && pA.pColl != pB.pColl ? 2 : 0;
    }

    private static int sqlite3ExprListCompare(Sqlite3.ExprList pA, Sqlite3.ExprList pB)
    {
      if (pA == null && pB == null)
        return 0;
      if (pA == null || pB == null || pA.nExpr != pB.nExpr)
        return 1;
      for (int index = 0; index < pA.nExpr; ++index)
      {
        Sqlite3.Expr pExpr1 = pA.a[index].pExpr;
        Sqlite3.Expr pExpr2 = pB.a[index].pExpr;
        if ((int) pA.a[index].sortOrder != (int) pB.a[index].sortOrder || Sqlite3.sqlite3ExprCompare(pExpr1, pExpr2) != 0)
          return 1;
      }
      return 0;
    }

    private static int addAggInfoColumn(Sqlite3.sqlite3 db, Sqlite3.AggInfo pInfo)
    {
      int pIdx = 0;
      pInfo.aCol = Sqlite3.sqlite3ArrayAllocate<Sqlite3.AggInfo_col>(db, pInfo.aCol, -1, 3, ref pInfo.nColumn, ref pInfo.nColumnAlloc, ref pIdx);
      return pIdx;
    }

    private static int addAggInfoFunc(Sqlite3.sqlite3 db, Sqlite3.AggInfo pInfo)
    {
      int pIdx = 0;
      pInfo.aFunc = Sqlite3.sqlite3ArrayAllocate<Sqlite3.AggInfo_func>(db, pInfo.aFunc, -1, 3, ref pInfo.nFunc, ref pInfo.nFuncAlloc, ref pIdx);
      return pIdx;
    }

    private static int analyzeAggregate(Sqlite3.Walker pWalker, ref Sqlite3.Expr pExpr)
    {
      Sqlite3.NameContext pNc = pWalker.u.pNC;
      Sqlite3.Parse pParse = pNc.pParse;
      Sqlite3.SrcList pSrcList = pNc.pSrcList;
      Sqlite3.AggInfo pAggInfo = pNc.pAggInfo;
      switch (pExpr.op)
      {
        case 152:
        case 154:
          Sqlite3.testcase<bool>(pExpr.op == (byte) 154);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 152);
          if (Sqlite3.ALWAYS(pSrcList != null))
          {
            for (int index1 = 0; index1 < (int) pSrcList.nSrc; ++index1)
            {
              Sqlite3.SrcList_item srcListItem = pSrcList.a[index1];
              if (pExpr.iTable == srcListItem.iCursor)
              {
                int index2;
                for (index2 = 0; index2 < pAggInfo.nColumn; ++index2)
                {
                  Sqlite3.AggInfo_col aggInfoCol = pAggInfo.aCol[index2];
                  if (aggInfoCol.iTable == pExpr.iTable && aggInfoCol.iColumn == (int) pExpr.iColumn)
                    break;
                }
                if (index2 >= pAggInfo.nColumn && (index2 = Sqlite3.addAggInfoColumn(pParse.db, pAggInfo)) >= 0)
                {
                  Sqlite3.AggInfo_col aggInfoCol = pAggInfo.aCol[index2];
                  aggInfoCol.pTab = pExpr.pTab;
                  aggInfoCol.iTable = pExpr.iTable;
                  aggInfoCol.iColumn = (int) pExpr.iColumn;
                  aggInfoCol.iMem = ++pParse.nMem;
                  aggInfoCol.iSorterColumn = -1;
                  aggInfoCol.pExpr = pExpr;
                  if (pAggInfo.pGroupBy != null)
                  {
                    Sqlite3.ExprList pGroupBy = pAggInfo.pGroupBy;
                    int nExpr = pGroupBy.nExpr;
                    for (int index3 = 0; index3 < nExpr; ++index3)
                    {
                      Sqlite3.Expr pExpr1 = pGroupBy.a[index3].pExpr;
                      if (pExpr1.op == (byte) 152 && pExpr1.iTable == pExpr.iTable && (int) pExpr1.iColumn == (int) pExpr.iColumn)
                      {
                        aggInfoCol.iSorterColumn = index3;
                        break;
                      }
                    }
                  }
                  if (aggInfoCol.iSorterColumn < 0)
                    aggInfoCol.iSorterColumn = pAggInfo.nSortingColumn++;
                }
                Sqlite3.ExprSetIrreducible(pExpr);
                pExpr.pAggInfo = pAggInfo;
                pExpr.op = (byte) 154;
                pExpr.iAgg = (short) index2;
                break;
              }
            }
          }
          return 1;
        case 153:
          if (pNc.nDepth == 0)
          {
            int index = 0;
            while (index < pAggInfo.nFunc && Sqlite3.sqlite3ExprCompare(pAggInfo.aFunc[index].pExpr, pExpr) != 0)
              ++index;
            if (index >= pAggInfo.nFunc)
            {
              byte enc = pParse.db.aDbStatic[0].pSchema.enc;
              index = Sqlite3.addAggInfoFunc(pParse.db, pAggInfo);
              if (index >= 0)
              {
                Sqlite3.AggInfo_func aggInfoFunc = pAggInfo.aFunc[index];
                aggInfoFunc.pExpr = pExpr;
                aggInfoFunc.iMem = ++pParse.nMem;
                aggInfoFunc.pFunc = Sqlite3.sqlite3FindFunction(pParse.db, pExpr.u.zToken, Sqlite3.sqlite3Strlen30(pExpr.u.zToken), pExpr.x.pList != null ? pExpr.x.pList.nExpr : 0, enc, (byte) 0);
                aggInfoFunc.iDistinct = ((int) pExpr.flags & 16) == 0 ? -1 : pParse.nTab++;
              }
            }
            Sqlite3.ExprSetIrreducible(pExpr);
            pExpr.iAgg = (short) index;
            pExpr.pAggInfo = pAggInfo;
            return 1;
          }
          break;
      }
      return 0;
    }

    private static int analyzeAggregatesInSelect(Sqlite3.Walker pWalker, Sqlite3.Select pSelect)
    {
      Sqlite3.NameContext pNc = pWalker.u.pNC;
      if (pNc.nDepth != 0)
        return 0;
      ++pNc.nDepth;
      Sqlite3.sqlite3WalkSelect(pWalker, pSelect);
      --pNc.nDepth;
      return 1;
    }

    private static void sqlite3ExprAnalyzeAggregates(
      Sqlite3.NameContext pNC,
      ref Sqlite3.Expr pExpr)
    {
      Sqlite3.sqlite3WalkExpr(new Sqlite3.Walker()
      {
        xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.analyzeAggregate),
        xSelectCallback = new Sqlite3.dxSelectCallback(Sqlite3.analyzeAggregatesInSelect),
        u = {
          pNC = pNC
        }
      }, ref pExpr);
    }

    private static void sqlite3ExprAnalyzeAggList(Sqlite3.NameContext pNC, Sqlite3.ExprList pList)
    {
      if (pList == null)
        return;
      for (int index = 0; index < pList.nExpr; ++index)
      {
        Sqlite3.ExprList_item exprListItem = pList.a[index];
        Sqlite3.sqlite3ExprAnalyzeAggregates(pNC, ref exprListItem.pExpr);
      }
    }

    private static int sqlite3GetTempReg(Sqlite3.Parse pParse) => pParse.nTempReg == (byte) 0 ? ++pParse.nMem : pParse.aTempReg[(int) --pParse.nTempReg];

    private static void sqlite3ReleaseTempReg(Sqlite3.Parse pParse, int iReg)
    {
      if (iReg == 0 || (int) pParse.nTempReg >= Sqlite3.ArraySize<int>(pParse.aTempReg))
        return;
      for (int index = 0; index < 10; ++index)
      {
        Sqlite3.yColCache yColCache = pParse.aColCache[index];
        if (yColCache.iReg == iReg)
        {
          yColCache.tempReg = (byte) 1;
          return;
        }
      }
      pParse.aTempReg[(int) pParse.nTempReg++] = iReg;
    }

    private static int sqlite3GetTempRange(Sqlite3.Parse pParse, int nReg)
    {
      int tempRange = pParse.iRangeReg;
      int nRangeReg = pParse.nRangeReg;
      if (nReg <= nRangeReg)
      {
        pParse.iRangeReg += nReg;
        pParse.nRangeReg -= nReg;
      }
      else
      {
        tempRange = pParse.nMem + 1;
        pParse.nMem += nReg;
      }
      return tempRange;
    }

    private static void sqlite3ReleaseTempRange(Sqlite3.Parse pParse, int iReg, int nReg)
    {
      Sqlite3.sqlite3ExprCacheRemove(pParse, iReg, nReg);
      if (nReg <= pParse.nRangeReg)
        return;
      pParse.nRangeReg = nReg;
      pParse.iRangeReg = iReg;
    }

    private static void wsdHooksInit()
    {
    }

    private static void sqlite3BenignMallocHooks(
      Sqlite3.void_function xBenignBegin,
      Sqlite3.void_function xBenignEnd)
    {
      Sqlite3.wsdHooksInit();
      Sqlite3.wsdHooks.xBenignBegin = xBenignBegin;
      Sqlite3.wsdHooks.xBenignEnd = xBenignEnd;
    }

    private static void sqlite3BeginBenignMalloc()
    {
      Sqlite3.wsdHooksInit();
      if (Sqlite3.wsdHooks.xBenignBegin == null)
        return;
      Sqlite3.wsdHooks.xBenignBegin();
    }

    private static void sqlite3EndBenignMalloc()
    {
      Sqlite3.wsdHooksInit();
      if (Sqlite3.wsdHooks.xBenignEnd == null)
        return;
      Sqlite3.wsdHooks.xBenignEnd();
    }

    private static int locateFkeyIndex(
      Sqlite3.Parse pParse,
      Sqlite3.Table pParent,
      Sqlite3.FKey pFKey,
      out Sqlite3.Index ppIdx,
      out int[] paiCol)
    {
      ppIdx = (Sqlite3.Index) null;
      int[] pPrior = (int[]) null;
      paiCol = (int[]) null;
      int nCol = pFKey.nCol;
      string zCol = pFKey.aCol[0].zCol;
      if (nCol == 1)
      {
        if (pParent.iPKey >= 0 && (zCol == null || pParent.aCol[pParent.iPKey].zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase)))
          return 0;
      }
      else
      {
        pPrior = new int[nCol];
        paiCol = pPrior;
      }
      Sqlite3.Index index1;
      for (index1 = pParent.pIndex; index1 != null; index1 = index1.pNext)
      {
        if (index1.nColumn == nCol && index1.onError != (byte) 0)
        {
          if (zCol == null)
          {
            if (index1.autoIndex == (byte) 2)
            {
              if (pPrior != null)
              {
                for (int index2 = 0; index2 < nCol; ++index2)
                  pPrior[index2] = pFKey.aCol[index2].iFrom;
                break;
              }
              break;
            }
          }
          else
          {
            int index3;
            for (index3 = 0; index3 < nCol; ++index3)
            {
              int index4 = index1.aiColumn[index3];
              string str = pParent.aCol[index4].zColl;
              if (string.IsNullOrEmpty(str))
                str = "BINARY";
              if (index1.azColl[index3].Equals(str, StringComparison.InvariantCultureIgnoreCase))
              {
                string zName = pParent.aCol[index4].zName;
                int index5;
                for (index5 = 0; index5 < nCol; ++index5)
                {
                  if (pFKey.aCol[index5].zCol.Equals(zName, StringComparison.InvariantCultureIgnoreCase))
                  {
                    if (pPrior != null)
                    {
                      pPrior[index3] = pFKey.aCol[index5].iFrom;
                      break;
                    }
                    break;
                  }
                }
                if (index5 == nCol)
                  break;
              }
              else
                break;
            }
            if (index3 == nCol)
              break;
          }
        }
      }
      if (index1 == null)
      {
        if (pParse.disableTriggers == (byte) 0)
          Sqlite3.sqlite3ErrorMsg(pParse, "foreign key mismatch");
        Sqlite3.sqlite3DbFree(pParse.db, ref pPrior);
        return 1;
      }
      ppIdx = index1;
      return 0;
    }

    private static void fkLookupParent(
      Sqlite3.Parse pParse,
      int iDb,
      Sqlite3.Table pTab,
      Sqlite3.Index pIdx,
      Sqlite3.FKey pFKey,
      int[] aiCol,
      int regData,
      int nIncr,
      int isIgnore)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      int num1 = pParse.nTab - 1;
      int num2 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
      if (nIncr < 0)
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 111, (int) pFKey.isDeferred, num2);
      for (int index = 0; index < pFKey.nCol; ++index)
      {
        int p1 = aiCol[index] + regData + 1;
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 73, p1, num2);
      }
      if (isIgnore == 0)
      {
        if (pIdx == null)
        {
          int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, aiCol[0] + 1 + regData, tempReg);
          int addr = Sqlite3.sqlite3VdbeAddOp2(vdbe, 21, tempReg, 0);
          if (pTab == pFKey.pFrom && nIncr == 1)
            Sqlite3.sqlite3VdbeAddOp3(vdbe, 76, regData, num2, tempReg);
          Sqlite3.sqlite3OpenTable(pParse, num1, iDb, pTab, 38);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 52, num1, 0, tempReg);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, num2);
          Sqlite3.sqlite3VdbeJumpHere(vdbe, Sqlite3.sqlite3VdbeCurrentAddr(vdbe) - 2);
          Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
        }
        else
        {
          int nCol = pFKey.nCol;
          int tempRange = Sqlite3.sqlite3GetTempRange(pParse, nCol);
          int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.KeyInfo pKeyInfo = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 38, num1, pIdx.tnum, iDb);
          Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, pKeyInfo, -16);
          for (int index = 0; index < nCol; ++index)
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 14, aiCol[index] + 1 + regData, tempRange + index);
          if (pTab == pFKey.pFrom && nIncr == 1)
          {
            int p2 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe) + nCol + 1;
            for (int index = 0; index < nCol; ++index)
            {
              int p1 = aiCol[index] + 1 + regData;
              int p3 = pIdx.aiColumn[index] + 1 + regData;
              if (pIdx.aiColumn[index] == pTab.iPKey)
                p3 = regData;
              Sqlite3.sqlite3VdbeAddOp3(vdbe, 75, p1, p2, p3);
              Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 8);
            }
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, num2);
          }
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 30, tempRange, nCol, tempReg);
          Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, Sqlite3.sqlite3IndexAffinityStr(vdbe, pIdx), 0);
          Sqlite3.sqlite3VdbeAddOp4Int(vdbe, 50, num1, num2, tempReg, 0);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
          Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, nCol);
        }
      }
      if (pFKey.isDeferred == (byte) 0 && pParse.pToplevel == null && pParse.isMultiWrite == (byte) 0)
      {
        Sqlite3.sqlite3HaltConstraint(pParse, 2, "foreign key constraint failed", -2);
      }
      else
      {
        if (nIncr > 0 && pFKey.isDeferred == (byte) 0)
          Sqlite3.sqlite3ParseToplevel(pParse).mayAbort = (byte) 1;
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 110, (int) pFKey.isDeferred, nIncr);
      }
      Sqlite3.sqlite3VdbeResolveLabel(vdbe, num2);
      Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, num1);
    }

    private static void fkScanChildren(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pSrc,
      Sqlite3.Table pTab,
      Sqlite3.Index pIdx,
      Sqlite3.FKey pFKey,
      int[] aiCol,
      int regData,
      int nIncr)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Expr expr = (Sqlite3.Expr) null;
      int addr = 0;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (nIncr < 0)
        addr = Sqlite3.sqlite3VdbeAddOp2(vdbe, 111, (int) pFKey.isDeferred, 0);
      for (int index1 = 0; index1 < pFKey.nCol; ++index1)
      {
        Sqlite3.Expr pLeft = Sqlite3.sqlite3Expr(db, 132, (string) null);
        if (pLeft != null)
        {
          if (pIdx != null)
          {
            int index2 = pIdx.aiColumn[index1];
            Sqlite3.Column column = pTab.aCol[index2];
            if (pTab.iPKey == index2)
              index2 = -1;
            pLeft.iTable = regData + index2 + 1;
            pLeft.affinity = column.affinity;
            pLeft.pColl = Sqlite3.sqlite3LocateCollSeq(pParse, column.zColl);
          }
          else
          {
            pLeft.iTable = regData;
            pLeft.affinity = 'd';
          }
        }
        int index3 = aiCol != null ? aiCol[index1] : pFKey.aCol[0].iFrom;
        string zName = pFKey.pFrom.aCol[index3].zName;
        Sqlite3.Expr pRight1 = Sqlite3.sqlite3Expr(db, 26, zName);
        Sqlite3.Expr pRight2 = Sqlite3.sqlite3PExpr(pParse, 76, pLeft, pRight1, 0);
        expr = Sqlite3.sqlite3ExprAnd(db, expr, pRight2);
      }
      if (pTab == pFKey.pFrom && nIncr > 0)
      {
        Sqlite3.Expr pLeft = Sqlite3.sqlite3Expr(db, 132, (string) null);
        Sqlite3.Expr pRight3 = Sqlite3.sqlite3Expr(db, 152, (string) null);
        if (pLeft != null && pRight3 != null)
        {
          pLeft.iTable = regData;
          pLeft.affinity = 'd';
          pRight3.iTable = pSrc.a[0].iCursor;
          pRight3.iColumn = (short) -1;
        }
        Sqlite3.Expr pRight4 = Sqlite3.sqlite3PExpr(pParse, 75, pLeft, pRight3, 0);
        expr = Sqlite3.sqlite3ExprAnd(db, expr, pRight4);
      }
      Sqlite3.sqlite3ResolveExprNames(new Sqlite3.NameContext()
      {
        pSrcList = pSrc,
        pParse = pParse
      }, ref expr);
      Sqlite3.ExprList ppOrderBy = (Sqlite3.ExprList) null;
      Sqlite3.WhereInfo pWInfo = Sqlite3.sqlite3WhereBegin(pParse, pSrc, expr, ref ppOrderBy, (ushort) 0);
      if (nIncr > 0 && pFKey.isDeferred == (byte) 0)
        Sqlite3.sqlite3ParseToplevel(pParse).mayAbort = (byte) 1;
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 110, (int) pFKey.isDeferred, nIncr);
      if (pWInfo != null)
        Sqlite3.sqlite3WhereEnd(pWInfo);
      Sqlite3.sqlite3ExprDelete(db, ref expr);
      if (addr == 0)
        return;
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
    }

    private static Sqlite3.FKey sqlite3FkReferences(Sqlite3.Table pTab)
    {
      int nKey = Sqlite3.sqlite3Strlen30(pTab.zName);
      return Sqlite3.sqlite3HashFind<Sqlite3.FKey>(pTab.pSchema.fkeyHash, pTab.zName, nKey, (Sqlite3.FKey) null);
    }

    private static void fkTriggerDelete(Sqlite3.sqlite3 dbMem, Sqlite3.Trigger p)
    {
      if (p == null)
        return;
      Sqlite3.TriggerStep stepList = p.step_list;
      Sqlite3.sqlite3ExprDelete(dbMem, ref stepList.pWhere);
      Sqlite3.sqlite3ExprListDelete(dbMem, ref stepList.pExprList);
      Sqlite3.sqlite3SelectDelete(dbMem, ref stepList.pSelect);
      Sqlite3.sqlite3ExprDelete(dbMem, ref p.pWhen);
      Sqlite3.sqlite3DbFree<Sqlite3.Trigger>(dbMem, ref p);
    }

    private static void sqlite3FkDropTable(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pName,
      Sqlite3.Table pTab)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if ((db.flags & 67108864) == 0 || Sqlite3.IsVirtual(pTab) || pTab.pSelect != null)
        return;
      int num = 0;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (Sqlite3.sqlite3FkReferences(pTab) == null)
      {
        Sqlite3.FKey fkey = pTab.pFKey;
        while (fkey != null && fkey.isDeferred == (byte) 0)
          fkey = fkey.pNextFrom;
        if (fkey == null)
          return;
        num = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 111, 1, num);
      }
      pParse.disableTriggers = (byte) 1;
      Sqlite3.sqlite3DeleteFrom(pParse, Sqlite3.sqlite3SrcListDup(db, pName, 0), (Sqlite3.Expr) null);
      pParse.disableTriggers = (byte) 0;
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 111, 0, Sqlite3.sqlite3VdbeCurrentAddr(vdbe) + 2);
      Sqlite3.sqlite3HaltConstraint(pParse, 2, "foreign key constraint failed", -2);
      if (num == 0)
        return;
      Sqlite3.sqlite3VdbeResolveLabel(vdbe, num);
    }

    private static void sqlite3FkCheck(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int regOld,
      int regNew)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int disableTriggers = (int) pParse.disableTriggers;
      if ((db.flags & 67108864) == 0)
        return;
      int index1 = Sqlite3.sqlite3SchemaToIndex(db, pTab.pSchema);
      string zName = db.aDb[index1].zName;
      for (Sqlite3.FKey pFKey = pTab.pFKey; pFKey != null; pFKey = pFKey.pNextFrom)
      {
        Sqlite3.Index ppIdx = (Sqlite3.Index) null;
        int[] paiCol = (int[]) null;
        int isIgnore = 0;
        Sqlite3.Table table = pParse.disableTriggers == (byte) 0 ? Sqlite3.sqlite3LocateTable(pParse, 0, pFKey.zTo, zName) : Sqlite3.sqlite3FindTable(db, pFKey.zTo, zName);
        if (table == null || Sqlite3.locateFkeyIndex(pParse, table, pFKey, out ppIdx, out paiCol) != 0)
        {
          if (disableTriggers == 0)
            return;
        }
        else
        {
          int[] aiCol;
          if (paiCol != null)
            aiCol = paiCol;
          else
            aiCol = new int[1]{ pFKey.aCol[0].iFrom };
          for (int index2 = 0; index2 < pFKey.nCol; ++index2)
          {
            if (aiCol[index2] == pTab.iPKey)
              aiCol[index2] = -1;
          }
          Sqlite3.sqlite3TableLock(pParse, index1, table.tnum, (byte) 0, table.zName);
          ++pParse.nTab;
          if (regOld != 0)
            Sqlite3.fkLookupParent(pParse, index1, table, ppIdx, pFKey, aiCol, regOld, -1, isIgnore);
          if (regNew != 0)
            Sqlite3.fkLookupParent(pParse, index1, table, ppIdx, pFKey, aiCol, regNew, 1, isIgnore);
          Sqlite3.sqlite3DbFree(db, ref paiCol);
        }
      }
      for (Sqlite3.FKey pFKey = Sqlite3.sqlite3FkReferences(pTab); pFKey != null; pFKey = pFKey.pNextTo)
      {
        Sqlite3.Index ppIdx = (Sqlite3.Index) null;
        int[] paiCol = (int[]) null;
        if (pFKey.isDeferred != (byte) 0 || pParse.pToplevel != null || pParse.isMultiWrite != (byte) 0)
        {
          if (Sqlite3.locateFkeyIndex(pParse, pTab, pFKey, out ppIdx, out paiCol) != 0)
          {
            if (disableTriggers == 0)
              break;
          }
          else
          {
            Sqlite3.SrcList pList = Sqlite3.sqlite3SrcListAppend(db, 0, (Sqlite3.Token) null, (Sqlite3.Token) null);
            if (pList != null)
            {
              Sqlite3.SrcList_item srcListItem = pList.a[0];
              srcListItem.pTab = pFKey.pFrom;
              srcListItem.zName = pFKey.pFrom.zName;
              ++srcListItem.pTab.nRef;
              srcListItem.iCursor = pParse.nTab++;
              if (regNew != 0)
                Sqlite3.fkScanChildren(pParse, pList, pTab, ppIdx, pFKey, paiCol, regNew, -1);
              if (regOld != 0)
                Sqlite3.fkScanChildren(pParse, pList, pTab, ppIdx, pFKey, paiCol, regOld, 1);
              srcListItem.zName = (string) null;
              Sqlite3.sqlite3SrcListDelete(db, ref pList);
            }
            Sqlite3.sqlite3DbFree(db, ref paiCol);
          }
        }
      }
    }

    private static uint COLUMN_MASK(int x) => x <= 31 ? (uint) (1 << x) : uint.MaxValue;

    private static uint sqlite3FkOldmask(Sqlite3.Parse pParse, Sqlite3.Table pTab)
    {
      uint num = 0;
      if ((pParse.db.flags & 67108864) != 0)
      {
        for (Sqlite3.FKey fkey = pTab.pFKey; fkey != null; fkey = fkey.pNextFrom)
        {
          for (int index = 0; index < fkey.nCol; ++index)
            num |= Sqlite3.COLUMN_MASK(fkey.aCol[index].iFrom);
        }
        for (Sqlite3.FKey pFKey = Sqlite3.sqlite3FkReferences(pTab); pFKey != null; pFKey = pFKey.pNextTo)
        {
          Sqlite3.Index ppIdx;
          Sqlite3.locateFkeyIndex(pParse, pTab, pFKey, out ppIdx, out int[] _);
          if (ppIdx != null)
          {
            for (int index = 0; index < ppIdx.nColumn; ++index)
              num |= Sqlite3.COLUMN_MASK(ppIdx.aiColumn[index]);
          }
        }
      }
      return num;
    }

    private static int sqlite3FkRequired(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int[] aChange,
      int chngRowid)
    {
      if ((pParse.db.flags & 67108864) != 0)
      {
        if (aChange == null)
          return Sqlite3.sqlite3FkReferences(pTab) == null && pTab.pFKey == null ? 0 : 1;
        for (Sqlite3.FKey fkey = pTab.pFKey; fkey != null; fkey = fkey.pNextFrom)
        {
          for (int index = 0; index < fkey.nCol; ++index)
          {
            int iFrom = fkey.aCol[index].iFrom;
            if (aChange[iFrom] >= 0 || iFrom == pTab.iPKey && chngRowid != 0)
              return 1;
          }
        }
        for (Sqlite3.FKey fkey = Sqlite3.sqlite3FkReferences(pTab); fkey != null; fkey = fkey.pNextTo)
        {
          for (int index1 = 0; index1 < fkey.nCol; ++index1)
          {
            string zCol = fkey.aCol[index1].zCol;
            for (int index2 = 0; index2 < pTab.nCol; ++index2)
            {
              Sqlite3.Column column = pTab.aCol[index2];
              if ((!string.IsNullOrEmpty(zCol) ? (column.zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase) ? 1 : 0) : (column.isPrimKey > (byte) 0 ? 1 : 0)) != 0 && (aChange[index2] >= 0 || index2 == pTab.iPKey && chngRowid != 0))
                return 1;
            }
          }
        }
      }
      return 0;
    }

    private static Sqlite3.Trigger fkActionTrigger(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      Sqlite3.FKey pFKey,
      Sqlite3.ExprList pChanges)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int index1 = pChanges != null ? 1 : 0;
      int num1 = (int) pFKey.aAction[index1];
      Sqlite3.Trigger trigger = pFKey.apTrigger[index1];
      if (num1 != 0 && trigger == null)
      {
        Sqlite3.Index ppIdx = (Sqlite3.Index) null;
        int[] paiCol = (int[]) null;
        Sqlite3.Expr p1 = (Sqlite3.Expr) null;
        Sqlite3.ExprList pList = (Sqlite3.ExprList) null;
        Sqlite3.Select p2 = (Sqlite3.Select) null;
        Sqlite3.Expr p3 = (Sqlite3.Expr) null;
        if (Sqlite3.locateFkeyIndex(pParse, pTab, pFKey, out ppIdx, out paiCol) != 0)
          return (Sqlite3.Trigger) null;
        for (int index2 = 0; index2 < pFKey.nCol; ++index2)
        {
          Sqlite3.Token pToken1 = new Sqlite3.Token("old", 3);
          Sqlite3.Token pToken2 = new Sqlite3.Token("new", 3);
          Sqlite3.Token token = new Sqlite3.Token();
          Sqlite3.Token pToken3 = new Sqlite3.Token();
          int index3 = paiCol != null ? paiCol[index2] : pFKey.aCol[0].iFrom;
          pToken3.z = ppIdx != null ? pTab.aCol[ppIdx.aiColumn[index2]].zName : "oid";
          token.z = pFKey.pFrom.aCol[index3].zName;
          pToken3.n = Sqlite3.sqlite3Strlen30(pToken3.z);
          token.n = Sqlite3.sqlite3Strlen30(token.z);
          Sqlite3.Expr pRight1 = Sqlite3.sqlite3PExpr(pParse, 76, Sqlite3.sqlite3PExpr(pParse, 118, Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken1), Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken3), 0), Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, token), 0);
          p1 = Sqlite3.sqlite3ExprAnd(db, p1, pRight1);
          if (pChanges != null)
          {
            Sqlite3.Expr pRight2 = Sqlite3.sqlite3PExpr(pParse, 70, Sqlite3.sqlite3PExpr(pParse, 118, Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken1), Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken3), 0), Sqlite3.sqlite3PExpr(pParse, 118, Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken2), Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken3), 0), 0);
            p3 = Sqlite3.sqlite3ExprAnd(db, p3, pRight2);
          }
          if (num1 != 6 && (num1 != 9 || pChanges != null))
          {
            Sqlite3.Expr pExpr;
            switch (num1)
            {
              case 8:
                Sqlite3.Expr pDflt = pFKey.pFrom.aCol[index3].pDflt;
                pExpr = pDflt == null ? Sqlite3.sqlite3PExpr(pParse, 98, 0, 0, 0) : Sqlite3.sqlite3ExprDup(db, pDflt, 0);
                break;
              case 9:
                pExpr = Sqlite3.sqlite3PExpr(pParse, 118, Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken2), Sqlite3.sqlite3PExpr(pParse, 26, (Sqlite3.Expr) null, (Sqlite3.Expr) null, pToken3), 0);
                break;
              default:
                pExpr = Sqlite3.sqlite3PExpr(pParse, 98, 0, 0, 0);
                break;
            }
            pList = Sqlite3.sqlite3ExprListAppend(pParse, pList, pExpr);
            Sqlite3.sqlite3ExprListSetName(pParse, pList, token, 0);
          }
        }
        Sqlite3.sqlite3DbFree(db, ref paiCol);
        string zName = pFKey.pFrom.zName;
        int num2 = Sqlite3.sqlite3Strlen30(zName);
        if (num1 == 6)
        {
          Sqlite3.Token pTable = new Sqlite3.Token();
          pTable.z = zName;
          pTable.n = num2;
          Sqlite3.Expr pExpr = Sqlite3.sqlite3Expr(db, 56, "foreign key constraint failed");
          if (pExpr != null)
            pExpr.affinity = '\u0002';
          p2 = Sqlite3.sqlite3SelectNew(pParse, Sqlite3.sqlite3ExprListAppend(pParse, 0, pExpr), Sqlite3.sqlite3SrcListAppend(db, 0, pTable, (Sqlite3.Token) null), p1, (Sqlite3.ExprList) null, (Sqlite3.Expr) null, (Sqlite3.ExprList) null, 0, (Sqlite3.Expr) null, (Sqlite3.Expr) null);
          p1 = (Sqlite3.Expr) null;
        }
        byte bEnabled = db.lookaside.bEnabled;
        db.lookaside.bEnabled = (byte) 0;
        trigger = new Sqlite3.Trigger();
        Sqlite3.TriggerStep triggerStep = trigger.step_list = new Sqlite3.TriggerStep();
        triggerStep.target.n = num2;
        triggerStep.target.z = zName;
        triggerStep.pWhere = Sqlite3.sqlite3ExprDup(db, p1, 1);
        triggerStep.pExprList = Sqlite3.sqlite3ExprListDup(db, pList, 1);
        triggerStep.pSelect = Sqlite3.sqlite3SelectDup(db, p2, 1);
        if (p3 != null)
        {
          p3 = Sqlite3.sqlite3PExpr(pParse, 19, p3, 0, 0);
          trigger.pWhen = Sqlite3.sqlite3ExprDup(db, p3, 1);
        }
        db.lookaside.bEnabled = bEnabled;
        Sqlite3.sqlite3ExprDelete(db, ref p1);
        Sqlite3.sqlite3ExprDelete(db, ref p3);
        Sqlite3.sqlite3ExprListDelete(db, ref pList);
        Sqlite3.sqlite3SelectDelete(db, ref p2);
        switch (num1)
        {
          case 6:
            triggerStep.op = (byte) 116;
            break;
          case 9:
            if (pChanges == null)
            {
              triggerStep.op = (byte) 106;
              break;
            }
            goto default;
          default:
            triggerStep.op = (byte) 107;
            break;
        }
        triggerStep.pTrig = trigger;
        trigger.pSchema = pTab.pSchema;
        trigger.pTabSchema = pTab.pSchema;
        pFKey.apTrigger[index1] = trigger;
        trigger.op = pChanges != null ? (byte) 107 : (byte) 106;
      }
      return trigger;
    }

    private static void sqlite3FkActions(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      Sqlite3.ExprList pChanges,
      int regOld)
    {
      if ((pParse.db.flags & 67108864) == 0)
        return;
      for (Sqlite3.FKey pFKey = Sqlite3.sqlite3FkReferences(pTab); pFKey != null; pFKey = pFKey.pNextTo)
      {
        Sqlite3.Trigger p = Sqlite3.fkActionTrigger(pParse, pTab, pFKey, pChanges);
        if (p != null)
          Sqlite3.sqlite3CodeRowTriggerDirect(pParse, p, pTab, regOld, 2, 0);
      }
    }

    private static void sqlite3FkDelete(Sqlite3.sqlite3 db, Sqlite3.Table pTab)
    {
      Sqlite3.FKey pNextFrom;
      for (Sqlite3.FKey pT = pTab.pFKey; pT != null; pT = pNextFrom)
      {
        if (pT.pPrevTo != null)
        {
          pT.pPrevTo.pNextTo = pT.pNextTo;
        }
        else
        {
          Sqlite3.FKey pNextTo = pT.pNextTo;
          string str = pNextTo != null ? pT.pNextTo.zTo : pT.zTo;
          Sqlite3.sqlite3HashInsert<Sqlite3.FKey>(ref pTab.pSchema.fkeyHash, str, Sqlite3.sqlite3Strlen30(str), pNextTo);
        }
        if (pT.pNextTo != null)
          pT.pNextTo.pPrevTo = pT.pPrevTo;
        Sqlite3.fkTriggerDelete(db, pT.apTrigger[0]);
        Sqlite3.fkTriggerDelete(db, pT.apTrigger[1]);
        pNextFrom = pT.pNextFrom;
        Sqlite3.sqlite3DbFree<Sqlite3.FKey>(db, ref pT);
      }
    }

    private static Sqlite3.CollSeq sqlite3GetFuncCollSeq(Sqlite3.sqlite3_context context) => context.pColl;

    private static void minmaxFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      int num = (int) Sqlite3.sqlite3_user_data(context) == 0 ? 0 : -1;
      Sqlite3.CollSeq funcCollSeq = Sqlite3.sqlite3GetFuncCollSeq(context);
      Sqlite3.testcase<bool>(num == 0);
      int index1 = 0;
      if (Sqlite3.sqlite3_value_type(argv[0]) == 5)
        return;
      for (int index2 = 1; index2 < argc; ++index2)
      {
        if (Sqlite3.sqlite3_value_type(argv[index2]) == 5)
          return;
        if ((Sqlite3.sqlite3MemCompare(argv[index1], argv[index2], funcCollSeq) ^ num) >= 0)
          index1 = index2;
      }
      Sqlite3.sqlite3_result_value(context, argv[index1]);
    }

    private static void typeofFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      string z;
      switch (Sqlite3.sqlite3_value_type(argv[0]))
      {
        case 1:
          z = "integer";
          break;
        case 2:
          z = "real";
          break;
        case 3:
          z = "text";
          break;
        case 4:
          z = "blob";
          break;
        default:
          z = "null";
          break;
      }
      Sqlite3.sqlite3_result_text(context, z, -1, Sqlite3.SQLITE_STATIC);
    }

    private static void lengthFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      switch (Sqlite3.sqlite3_value_type(argv[0]))
      {
        case 1:
        case 2:
        case 4:
          Sqlite3.sqlite3_result_int(context, Sqlite3.sqlite3_value_bytes(argv[0]));
          break;
        case 3:
          byte[] zIn = Sqlite3.sqlite3_value_blob(argv[0]);
          if (zIn == null)
            break;
          int iVal = 0;
          int iz = 0;
          while (iz < zIn.Length && zIn[iz] != (byte) 0)
          {
            ++iVal;
            Sqlite3.SQLITE_SKIP_UTF8(zIn, ref iz);
          }
          Sqlite3.sqlite3_result_int(context, iVal);
          break;
        default:
          Sqlite3.sqlite3_result_null(context);
          break;
      }
    }

    private static void absFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      switch (Sqlite3.sqlite3_value_type(argv[0]))
      {
        case 1:
          long iVal = Sqlite3.sqlite3_value_int64(argv[0]);
          if (iVal < 0L)
          {
            if (iVal << 1 == 0L)
            {
              Sqlite3.sqlite3_result_error(context, "integer overflow", -1);
              break;
            }
            iVal = -iVal;
          }
          Sqlite3.sqlite3_result_int64(context, iVal);
          break;
        case 5:
          Sqlite3.sqlite3_result_null(context);
          break;
        default:
          double rVal = Sqlite3.sqlite3_value_double(argv[0]);
          if (rVal < 0.0)
            rVal = -rVal;
          Sqlite3.sqlite3_result_double(context, rVal);
          break;
      }
    }

    private static void substrFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      string z = "";
      byte[] numArray = (byte[]) null;
      int num1 = 0;
      if (Sqlite3.sqlite3_value_type(argv[1]) == 5 || argc == 3 && Sqlite3.sqlite3_value_type(argv[2]) == 5)
        return;
      int num2 = Sqlite3.sqlite3_value_type(argv[0]);
      int o = Sqlite3.sqlite3_value_int(argv[1]);
      int num3;
      if (num2 == 4)
      {
        num3 = Sqlite3.sqlite3_value_bytes(argv[0]);
        numArray = argv[0].zBLOB;
        if (numArray == null)
          return;
      }
      else
      {
        z = Sqlite3.sqlite3_value_text(argv[0]);
        if (string.IsNullOrEmpty(z))
          return;
        num3 = 0;
        if (o < 0)
          num3 = z.Length;
      }
      int n;
      if (argc == 3)
      {
        n = Sqlite3.sqlite3_value_int(argv[2]);
        if (n < 0)
        {
          n = -n;
          num1 = 1;
        }
      }
      else
        n = Sqlite3.sqlite3_context_db_handle(context).aLimit[0];
      if (o < 0)
      {
        o += num3;
        if (o < 0)
        {
          n += o;
          if (n < 0)
            n = 0;
          o = 0;
        }
      }
      else if (o > 0)
        --o;
      else if (n > 0)
        --n;
      if (num1 != 0)
      {
        o -= n;
        if (o < 0)
        {
          n += o;
          o = 0;
        }
      }
      if (num2 != 4)
      {
        Sqlite3.sqlite3_result_text(context, z, o, n <= z.Length - o ? n : z.Length - o, Sqlite3.SQLITE_TRANSIENT);
      }
      else
      {
        if (o + n > num3)
        {
          n = num3 - o;
          if (n < 0)
            n = 0;
        }
        StringBuilder stringBuilder = new StringBuilder(numArray.Length);
        if (numArray.Length == 0 || o > numArray.Length)
        {
          stringBuilder.Length = 0;
        }
        else
        {
          for (int index = o; index < o + n; ++index)
            stringBuilder.Append((char) numArray[index]);
        }
        Sqlite3.sqlite3_result_blob(context, stringBuilder.ToString(), n, Sqlite3.SQLITE_TRANSIENT);
      }
    }

    private static void roundFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      int num = 0;
      if (argc == 2)
      {
        if (5 == Sqlite3.sqlite3_value_type(argv[1]))
          return;
        num = Sqlite3.sqlite3_value_int(argv[1]);
        if (num > 30)
          num = 30;
        if (num < 0)
          num = 0;
      }
      if (Sqlite3.sqlite3_value_type(argv[0]) == 5)
        return;
      double pResult = Sqlite3.sqlite3_value_double(argv[0]);
      if (num == 0 && pResult >= 0.0 && pResult < (double) long.MaxValue)
        pResult = (double) (long) (pResult + 0.5);
      else if (num == 0 && pResult < 0.0 && -pResult < (double) long.MaxValue)
      {
        pResult = -(double) (long) (-pResult + 0.5);
      }
      else
      {
        string z = Sqlite3.sqlite3_mprintf("%.*f", (object) num, (object) pResult);
        if (z == null)
        {
          Sqlite3.sqlite3_result_error_nomem(context);
          return;
        }
        Sqlite3.sqlite3AtoF(z, ref pResult, Sqlite3.sqlite3Strlen30(z), (byte) 1);
      }
      Sqlite3.sqlite3_result_double(context, pResult);
    }

    private static void upperFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      string str = Sqlite3.sqlite3_value_text(argv[0]);
      int length = Sqlite3.sqlite3_value_bytes(argv[0]);
      if (str == null)
        return;
      Sqlite3.sqlite3_result_text(context, str.Length == 0 ? "" : str.Substring(0, length).ToUpper(), -1, (Sqlite3.dxDel) null);
    }

    private static void lowerFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      string str = Sqlite3.sqlite3_value_text(argv[0]);
      int length = Sqlite3.sqlite3_value_bytes(argv[0]);
      if (str == null)
        return;
      Sqlite3.sqlite3_result_text(context, str.Length == 0 ? "" : str.Substring(0, length).ToLower(), -1, (Sqlite3.dxDel) null);
    }

    private static void randomFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      long pBuf = 0;
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_randomness(8, ref pBuf);
      if (pBuf < 0L)
        pBuf = -(pBuf ^ long.MinValue);
      Sqlite3.sqlite3_result_int64(context, pBuf);
    }

    private static void randomBlob(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      int n = Sqlite3.sqlite3_value_int(argv[0]);
      if (n < 1)
        n = 1;
      char[] chArray;
      if (n > Sqlite3.sqlite3_context_db_handle(context).aLimit[0])
      {
        Sqlite3.sqlite3_result_error_toobig(context);
        chArray = (char[]) null;
      }
      else
        chArray = new char[n];
      if (chArray == null)
        return;
      long pBuf = 0;
      for (int index = 0; index < n; ++index)
      {
        Sqlite3.sqlite3_randomness(1, ref pBuf);
        chArray[index] = (char) ((ulong) pBuf & (ulong) sbyte.MaxValue);
      }
      Sqlite3.sqlite3_result_blob(context, new string(chArray), n, (Sqlite3.dxDel) null);
    }

    private static void last_insert_rowid(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_result_int64(context, Sqlite3.sqlite3_last_insert_rowid(db));
    }

    private static void changes(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_result_int(context, Sqlite3.sqlite3_changes(db));
    }

    private static void total_changes(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_result_int(context, Sqlite3.sqlite3_total_changes(db));
    }

    private static bool patternCompare(
      string zPattern,
      string zString,
      Sqlite3.compareInfo pInfo,
      uint esc)
    {
      int matchOne = (int) pInfo.matchOne;
      int matchAll = (int) pInfo.matchAll;
      int matchSet = (int) pInfo.matchSet;
      bool noCase = pInfo.noCase;
      bool flag = false;
      string str = zPattern;
      uint index1;
      while ((index1 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern)) != 0U)
      {
        if (!flag && (long) index1 == (long) matchAll)
        {
          uint index2;
          while ((long) (index2 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern)) == (long) matchAll || (long) index2 == (long) matchOne)
          {
            if ((long) index2 == (long) matchOne && Sqlite3.sqlite3Utf8Read(zString, ref zString) == 0U)
              return false;
          }
          if (index2 == 0U)
            return true;
          if ((int) index2 == (int) esc)
          {
            index2 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern);
            if (index2 == 0U)
              return false;
          }
          else if ((long) index2 == (long) matchSet)
          {
            int iz = 0;
            while (iz < zString.Length && !Sqlite3.patternCompare(str.Substring(str.Length - zPattern.Length - 1), zString.Substring(iz), pInfo, esc))
              Sqlite3.SQLITE_SKIP_UTF8(zString, ref iz);
            return iz < zString.Length;
          }
          uint index3;
          while ((index3 = Sqlite3.sqlite3Utf8Read(zString, ref zString)) != 0U)
          {
            if (noCase)
            {
              if (((long) index3 & (long) sbyte.MinValue) == 0L)
                index3 = (uint) Sqlite3.sqlite3UpperToLower[index3];
              if (((long) index2 & (long) sbyte.MinValue) == 0L)
                index2 = (uint) Sqlite3.sqlite3UpperToLower[index2];
              while (index3 != 0U && (int) index3 != (int) index2)
              {
                index3 = Sqlite3.sqlite3Utf8Read(zString, ref zString);
                if (((long) index3 & (long) sbyte.MinValue) == 0L)
                  index3 = (uint) Sqlite3.sqlite3UpperToLower[index3];
              }
            }
            else
            {
              while (index3 != 0U && (int) index3 != (int) index2)
                index3 = Sqlite3.sqlite3Utf8Read(zString, ref zString);
            }
            if (index3 == 0U)
              return false;
            if (Sqlite3.patternCompare(zPattern, zString, pInfo, esc))
              return true;
          }
          return false;
        }
        if (!flag && (long) index1 == (long) matchOne)
        {
          if (Sqlite3.sqlite3Utf8Read(zString, ref zString) == 0U)
            return false;
        }
        else if ((long) index1 == (long) matchSet)
        {
          uint num1 = 0;
          int num2 = 0;
          int num3 = 0;
          uint num4 = Sqlite3.sqlite3Utf8Read(zString, ref zString);
          if (num4 == 0U)
            return false;
          uint num5 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern);
          if (num5 == 94U)
          {
            num3 = 1;
            num5 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern);
          }
          if (num5 == 93U)
          {
            if (num4 == 93U)
              num2 = 1;
            num5 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern);
          }
          for (; num5 != 0U && num5 != 93U; num5 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern))
          {
            if (num5 == 45U && zPattern[0] != ']' && zPattern[0] != char.MinValue && num1 > 0U)
            {
              uint num6 = Sqlite3.sqlite3Utf8Read(zPattern, ref zPattern);
              if (num4 >= num1 && num4 <= num6)
                num2 = 1;
              num1 = 0U;
            }
            else
            {
              if ((int) num4 == (int) num5)
                num2 = 1;
              num1 = num5;
            }
          }
          if (num5 == 0U || (num2 ^ num3) == 0)
            return false;
        }
        else if ((int) esc == (int) index1 && !flag)
        {
          flag = true;
        }
        else
        {
          uint index4 = Sqlite3.sqlite3Utf8Read(zString, ref zString);
          if (noCase)
          {
            if (index1 < 128U)
              index1 = (uint) Sqlite3.sqlite3UpperToLower[index1];
            if (index4 < 128U)
              index4 = (uint) Sqlite3.sqlite3UpperToLower[index4];
          }
          if ((int) index1 != (int) index4)
            return false;
          flag = false;
        }
      }
      return zString.Length == 0;
    }

    private static void likeFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      uint esc = 0;
      Sqlite3.sqlite3 sqlite3 = Sqlite3.sqlite3_context_db_handle(context);
      string zPattern = Sqlite3.sqlite3_value_text(argv[0]);
      string zString = Sqlite3.sqlite3_value_text(argv[1]);
      int num = Sqlite3.sqlite3_value_bytes(argv[0]);
      Sqlite3.testcase<bool>(num == sqlite3.aLimit[8]);
      Sqlite3.testcase<bool>(num == sqlite3.aLimit[8] + 1);
      if (num > sqlite3.aLimit[8])
      {
        Sqlite3.sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
      }
      else
      {
        if (argc == 3)
        {
          string pzNext = Sqlite3.sqlite3_value_text(argv[2]);
          if (pzNext == null)
            return;
          if (Sqlite3.sqlite3Utf8CharLen(pzNext, -1) != 1)
          {
            Sqlite3.sqlite3_result_error(context, "ESCAPE expression must be a single character", -1);
            return;
          }
          esc = Sqlite3.sqlite3Utf8Read(pzNext, ref pzNext);
        }
        if (zString == null || zPattern == null)
          return;
        Sqlite3.compareInfo pInfo = (Sqlite3.compareInfo) Sqlite3.sqlite3_user_data(context);
        Sqlite3.sqlite3_result_int(context, Sqlite3.patternCompare(zPattern, zString, pInfo, esc) ? 1 : 0);
      }
    }

    private static void nullifFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.CollSeq funcCollSeq = Sqlite3.sqlite3GetFuncCollSeq(context);
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      if (Sqlite3.sqlite3MemCompare(argv[0], argv[1], funcCollSeq) == 0)
        return;
      Sqlite3.sqlite3_result_value(context, argv[0]);
    }

    private static void versionFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_result_text(context, Sqlite3.sqlite3_libversion(), -1, Sqlite3.SQLITE_STATIC);
    }

    private static void sourceidFunc(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_result_text(context, Sqlite3.sqlite3_sourceid(), -1, Sqlite3.SQLITE_STATIC);
    }

    private static void errlogFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_context>(context);
      Sqlite3.sqlite3_log(Sqlite3.sqlite3_value_int(argv[0]), "%s", (object) Sqlite3.sqlite3_value_text(argv[1]));
    }

    private static void compileoptionusedFunc(
      Sqlite3.sqlite3_context context,
      int argc,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      string zOptName;
      if ((zOptName = Sqlite3.sqlite3_value_text(argv[0])) == null)
        return;
      Sqlite3.sqlite3_result_int(context, Sqlite3.sqlite3_compileoption_used(zOptName));
    }

    private static void compileoptiongetFunc(
      Sqlite3.sqlite3_context context,
      int argc,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      int N = Sqlite3.sqlite3_value_int(argv[0]);
      Sqlite3.sqlite3_result_text(context, Sqlite3.sqlite3_compileoption_get(N), -1, Sqlite3.SQLITE_STATIC);
    }

    private static void quoteFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      switch (Sqlite3.sqlite3_value_type(argv[0]))
      {
        case 1:
        case 2:
          Sqlite3.sqlite3_result_value(context, argv[0]);
          break;
        case 3:
          string str = Sqlite3.sqlite3_value_text(argv[0]);
          if (str == null || str.Length == 0)
            break;
          int index1 = 0;
          int num1 = 0;
          for (; index1 < str.Length; ++index1)
          {
            if (str[index1] == '\'')
              ++num1;
          }
          StringBuilder z1 = new StringBuilder(index1 + num1 + 3);
          if (z1 == null)
            break;
          z1.Append('\'');
          int index2 = 0;
          int num2 = 1;
          for (; index2 < str.Length && str[index2] != char.MinValue; ++index2)
          {
            z1.Append(str[index2]);
            ++num2;
            if (str[index2] == '\'')
            {
              z1.Append('\'');
              ++num2;
            }
          }
          z1.Append('\'');
          int n = num2 + 1;
          Sqlite3.sqlite3_result_text(context, z1, n, (Sqlite3.dxDel) null);
          break;
        case 4:
          byte[] numArray = Sqlite3.sqlite3_value_blob(argv[0]);
          int num3 = Sqlite3.sqlite3_value_bytes(argv[0]);
          StringBuilder z2 = new StringBuilder(2 * num3 + 4);
          z2.Append("X'");
          if (z2 == null)
            break;
          for (int index3 = 0; index3 < num3; ++index3)
          {
            z2.Append(Sqlite3.hexdigits[(int) numArray[index3] >> 4 & 15]);
            z2.Append(Sqlite3.hexdigits[(int) numArray[index3] & 15]);
          }
          z2.Append("'");
          Sqlite3.sqlite3_result_text(context, z2, -1, Sqlite3.SQLITE_TRANSIENT);
          break;
        default:
          Sqlite3.sqlite3_result_text(context, "NULL", 4, Sqlite3.SQLITE_STATIC);
          break;
      }
    }

    private static void hexFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      byte[] numArray = Sqlite3.sqlite3_value_blob(argv[0]);
      int num1 = Sqlite3.sqlite3_value_bytes(argv[0]);
      StringBuilder z = new StringBuilder(num1 * 2 + 1);
      if (z == null)
        return;
      for (int index = 0; index < num1; ++index)
      {
        byte num2 = numArray[index];
        z.Append(Sqlite3.hexdigits[(int) num2 >> 4 & 15]);
        z.Append(Sqlite3.hexdigits[(int) num2 & 15]);
      }
      Sqlite3.sqlite3_result_text(context, z, num1 * 2, (Sqlite3.dxDel) null);
    }

    private static void zeroblobFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.sqlite3 sqlite3 = Sqlite3.sqlite3_context_db_handle(context);
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      long n = Sqlite3.sqlite3_value_int64(argv[0]);
      Sqlite3.testcase<bool>(n == (long) sqlite3.aLimit[0]);
      Sqlite3.testcase<bool>(n == (long) (sqlite3.aLimit[0] + 1));
      if (n > (long) sqlite3.aLimit[0])
        Sqlite3.sqlite3_result_error_toobig(context);
      else
        Sqlite3.sqlite3_result_zeroblob(context, (int) n);
    }

    private static void replaceFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      string z = (string) null;
      int n = 0;
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      string str = Sqlite3.sqlite3_value_text(argv[0]);
      if (str == null)
        return;
      int num = Sqlite3.sqlite3_value_bytes(argv[0]);
      string oldValue = Sqlite3.sqlite3_value_text(argv[1]);
      if (oldValue == null)
        return;
      if (oldValue == "")
      {
        Sqlite3.sqlite3_result_value(context, argv[0]);
      }
      else
      {
        Sqlite3.sqlite3_value_bytes(argv[1]);
        string newValue = Sqlite3.sqlite3_value_text(argv[2]);
        if (newValue == null)
          return;
        Sqlite3.sqlite3_value_bytes(argv[2]);
        if (num + 1 <= Sqlite3.sqlite3_context_db_handle(context).aLimit[0])
        {
          try
          {
            z = str.Replace(oldValue, newValue);
            n = z.Length;
          }
          catch
          {
            n = 0;
          }
        }
        if (n == 0 || n > Sqlite3.sqlite3_context_db_handle(context).aLimit[0])
          Sqlite3.sqlite3_result_error_toobig(context);
        else
          Sqlite3.sqlite3_result_text(context, z, n, (Sqlite3.dxDel) null);
      }
    }

    private static void trimFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      int Offset = 0;
      int[] numArray1 = (int[]) null;
      byte[][] numArray2 = (byte[][]) null;
      int length = 0;
      if (Sqlite3.sqlite3_value_type(argv[0]) == 5 || Sqlite3.sqlite3_value_text(argv[0]) == null)
        return;
      int num1 = Sqlite3.sqlite3_value_bytes(argv[0]);
      byte[] a = Sqlite3.sqlite3_value_blob(argv[0]);
      string str;
      if (argc == 1)
      {
        int[] numArray3 = new int[1]{ 1 };
        byte[] numArray4 = new byte[1]{ (byte) 32 };
        length = 1;
        numArray1 = numArray3;
        numArray2 = new byte[1][]{ numArray4 };
        str = (string) null;
      }
      else
      {
        if ((str = Sqlite3.sqlite3_value_text(argv[1])) == null)
          return;
        byte[] numArray5;
        if ((numArray5 = Sqlite3.sqlite3_value_blob(argv[1])) != null)
        {
          int iz1 = 0;
          length = 0;
          while (iz1 < numArray5.Length)
          {
            Sqlite3.SQLITE_SKIP_UTF8(numArray5, ref iz1);
            ++length;
          }
          if (length > 0)
          {
            numArray2 = new byte[length][];
            if (numArray2 == null)
              return;
            numArray1 = new int[length];
            int srcOffset = 0;
            int iz2 = 0;
            for (int index = 0; index < length; ++index)
            {
              Sqlite3.SQLITE_SKIP_UTF8(numArray5, ref iz2);
              numArray1[index] = iz2 - srcOffset;
              numArray2[index] = new byte[numArray1[index]];
              Buffer.BlockCopy((Array) numArray5, srcOffset, (Array) numArray2[index], 0, numArray2[index].Length);
              srcOffset = iz2;
            }
          }
        }
      }
      if (length > 0)
      {
        int num2 = (int) Sqlite3.sqlite3_user_data(context);
        int Limit1;
        if ((num2 & 1) != 0)
        {
          for (; num1 > 0; num1 -= Limit1)
          {
            Limit1 = 0;
            int index;
            for (index = 0; index < length; ++index)
            {
              Limit1 = numArray1[index];
              if (Limit1 <= num1 && Sqlite3.memcmp(a, Offset, numArray2[index], Limit1) == 0)
                break;
            }
            if (index < length)
              Offset += Limit1;
            else
              break;
          }
        }
        int Limit2;
        if ((num2 & 2) != 0)
        {
          for (; num1 > 0; num1 -= Limit2)
          {
            Limit2 = 0;
            int index;
            for (index = 0; index < length; ++index)
            {
              Limit2 = numArray1[index];
              if (Limit2 <= num1 && Sqlite3.memcmp(a, Offset + num1 - Limit2, numArray2[index], Limit2) == 0)
                break;
            }
            if (index >= length)
              break;
          }
        }
      }
      StringBuilder z = new StringBuilder(num1);
      for (int index = 0; index < num1; ++index)
        z.Append((char) a[Offset + index]);
      Sqlite3.sqlite3_result_text(context, z, num1, Sqlite3.SQLITE_TRANSIENT);
    }

    private static void loadExt(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      string zFile = Sqlite3.sqlite3_value_text(argv[0]);
      Sqlite3.sqlite3 db = Sqlite3.sqlite3_context_db_handle(context);
      string z = "";
      string zProc = argc != 2 ? "" : Sqlite3.sqlite3_value_text(argv[1]);
      if (zFile == null || Sqlite3.sqlite3_load_extension(db, zFile, zProc, ref z) == 0)
        return;
      Sqlite3.sqlite3_result_error(context, z, -1);
      Sqlite3.sqlite3DbFree(db, ref z);
    }

    private static void sumStep(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 1);
      if (mem._SumCtx == null)
        mem._SumCtx = new Sqlite3.SumCtx();
      Sqlite3.SumCtx sumCtx = mem._SumCtx;
      if (sumCtx.Context == null)
        sumCtx.Context = mem;
      int num = Sqlite3.sqlite3_value_numeric_type(argv[0]);
      if (sumCtx == null || num == 5)
        return;
      ++sumCtx.cnt;
      if (num == 1)
      {
        long iB = Sqlite3.sqlite3_value_int64(argv[0]);
        sumCtx.rSum += (double) iB;
        if (sumCtx.approx | sumCtx.overflow != 0 || Sqlite3.sqlite3AddInt64(ref sumCtx.iSum, iB) == 0)
          return;
        sumCtx.overflow = 1;
      }
      else
      {
        sumCtx.rSum += Sqlite3.sqlite3_value_double(argv[0]);
        sumCtx.approx = true;
      }
    }

    private static void sumFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.SumCtx sumCtx = (Sqlite3.SumCtx) null;
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 0);
      if (mem != null)
        sumCtx = mem._SumCtx;
      if (sumCtx == null || sumCtx.cnt <= 0L)
        return;
      if (sumCtx.overflow != 0)
        Sqlite3.sqlite3_result_error(context, "integer overflow", -1);
      else if (sumCtx.approx)
        Sqlite3.sqlite3_result_double(context, sumCtx.rSum);
      else
        Sqlite3.sqlite3_result_int64(context, sumCtx.iSum);
      sumCtx.cnt = 0L;
    }

    private static void avgFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.SumCtx sumCtx = (Sqlite3.SumCtx) null;
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 0);
      if (mem != null)
        sumCtx = mem._SumCtx;
      if (sumCtx == null || sumCtx.cnt <= 0L)
        return;
      Sqlite3.sqlite3_result_double(context, sumCtx.rSum / (double) sumCtx.cnt);
    }

    private static void totalFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.SumCtx sumCtx = (Sqlite3.SumCtx) null;
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 0);
      if (mem != null)
        sumCtx = mem._SumCtx;
      Sqlite3.sqlite3_result_double(context, sumCtx != null ? sumCtx.rSum : 0.0);
    }

    private static void countStep(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.CountCtx countCtx = new Sqlite3.CountCtx();
      countCtx.Context = Sqlite3.sqlite3_aggregate_context(context, 1);
      if (argc != 0 && 5 == Sqlite3.sqlite3_value_type(argv[0]) || countCtx.Context == null)
        return;
      ++countCtx.n;
    }

    private static void countFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.CountCtx countCtx = new Sqlite3.CountCtx();
      countCtx.Context = Sqlite3.sqlite3_aggregate_context(context, 0);
      Sqlite3.sqlite3_result_int64(context, countCtx != null ? countCtx.n : 0L);
    }

    private static void minmaxStep(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] argv)
    {
      Sqlite3.Mem mem1 = argv[0];
      Sqlite3.UNUSED_PARAMETER<int>(NotUsed);
      if (Sqlite3.sqlite3_value_type(argv[0]) == 5)
        return;
      Sqlite3.Mem mem2 = Sqlite3.sqlite3_aggregate_context(context, 1);
      if (mem2.flags != (ushort) 0)
      {
        Sqlite3.CollSeq funcCollSeq = Sqlite3.sqlite3GetFuncCollSeq(context);
        bool flag = Sqlite3.sqlite3_context_db_handle(context) != null && (int) Sqlite3.sqlite3_user_data(context) != 0;
        int num = Sqlite3.sqlite3MemCompare(mem2, mem1, funcCollSeq);
        if ((!flag || num >= 0) && (flag || num <= 0))
          return;
        Sqlite3.sqlite3VdbeMemCopy(mem2, mem1);
      }
      else
        Sqlite3.sqlite3VdbeMemCopy(mem2, mem1);
    }

    private static void minMaxFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 0);
      if (mem == null)
        return;
      if (Sqlite3.ALWAYS(mem.flags > (ushort) 0))
        Sqlite3.sqlite3_result_value(context, mem);
      Sqlite3.sqlite3VdbeMemRelease(mem);
    }

    private static void groupConcatStep(
      Sqlite3.sqlite3_context context,
      int argc,
      Sqlite3.Mem[] argv)
    {
      if (Sqlite3.sqlite3_value_type(argv[0]) == 5)
        return;
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 1);
      if (mem._StrAccum == null)
        mem._StrAccum = new Sqlite3.StrAccum(100);
      Sqlite3.sqlite3 sqlite3 = Sqlite3.sqlite3_context_db_handle(context);
      mem._StrAccum.mxAlloc = sqlite3.aLimit[0];
      if (mem._StrAccum.Context == null)
      {
        mem._StrAccum.Context = mem;
      }
      else
      {
        string z;
        int N;
        if (argc == 2)
        {
          z = Sqlite3.sqlite3_value_text(argv[1]);
          N = Sqlite3.sqlite3_value_bytes(argv[1]);
        }
        else
        {
          z = ",";
          N = 1;
        }
        Sqlite3.sqlite3StrAccumAppend(mem._StrAccum, z, N);
      }
      string z1 = Sqlite3.sqlite3_value_text(argv[0]);
      int N1 = Sqlite3.sqlite3_value_bytes(argv[0]);
      Sqlite3.sqlite3StrAccumAppend(mem._StrAccum, z1, N1);
    }

    private static void groupConcatFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 0);
      if (mem == null)
        return;
      if (mem._StrAccum == null)
        mem._StrAccum = new Sqlite3.StrAccum(100);
      Sqlite3.StrAccum strAccum = mem._StrAccum;
      if (strAccum.tooBig)
        Sqlite3.sqlite3_result_error_toobig(context);
      else
        Sqlite3.sqlite3_result_text(context, Sqlite3.sqlite3StrAccumFinish(strAccum), -1, (Sqlite3.dxDel) null);
    }

    private static void sqlite3RegisterBuiltinFunctions(Sqlite3.sqlite3 db) => Sqlite3.sqlite3_overload_function(db, "MATCH", 2);

    private static void setLikeOptFlag(Sqlite3.sqlite3 db, string zName, int flagVal)
    {
      Sqlite3.FuncDef function = Sqlite3.sqlite3FindFunction(db, zName, Sqlite3.sqlite3Strlen30(zName), 2, (byte) 1, (byte) 0);
      if (!Sqlite3.ALWAYS(function != null))
        return;
      function.flags = (byte) flagVal;
    }

    private static void sqlite3RegisterLikeFunctions(Sqlite3.sqlite3 db, int caseSensitive)
    {
      Sqlite3.compareInfo pUserData = caseSensitive == 0 ? Sqlite3.likeInfoNorm : Sqlite3.likeInfoAlt;
      Sqlite3.sqlite3CreateFunc(db, "like", 2, (byte) 1, (object) pUserData, new Sqlite3.dxFunc(Sqlite3.likeFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, (Sqlite3.FuncDestructor) null);
      Sqlite3.sqlite3CreateFunc(db, "like", 3, (byte) 1, (object) pUserData, new Sqlite3.dxFunc(Sqlite3.likeFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, (Sqlite3.FuncDestructor) null);
      Sqlite3.sqlite3CreateFunc(db, "glob", 2, (byte) 1, (object) Sqlite3.globInfo, new Sqlite3.dxFunc(Sqlite3.likeFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, (Sqlite3.FuncDestructor) null);
      Sqlite3.setLikeOptFlag(db, "glob", 3);
      Sqlite3.setLikeOptFlag(db, "like", caseSensitive != 0 ? 3 : 1);
    }

    private static bool sqlite3IsLikeFunction(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr pExpr,
      ref bool pIsNocase,
      char[] aWc)
    {
      if (pExpr.op != (byte) 151 || pExpr.x.pList == null || pExpr.x.pList.nExpr != 2)
        return false;
      Sqlite3.FuncDef function = Sqlite3.sqlite3FindFunction(db, pExpr.u.zToken, Sqlite3.sqlite3Strlen30(pExpr.u.zToken), 2, (byte) 1, (byte) 0);
      if (Sqlite3.NEVER(function == null) || ((int) function.flags & 1) == 0)
        return false;
      aWc[0] = ((Sqlite3.compareInfo) function.pUserData).matchAll;
      aWc[1] = ((Sqlite3.compareInfo) function.pUserData).matchOne;
      aWc[2] = ((Sqlite3.compareInfo) function.pUserData).matchSet;
      pIsNocase = ((int) function.flags & 2) == 0;
      return true;
    }

    private static void sqlite3RegisterGlobalFunctions()
    {
      Sqlite3.FuncDef[] x = new Sqlite3.FuncDef[53]
      {
        Sqlite3.FUNCTION("ltrim", (short) 1, 1, (byte) 0, new Sqlite3.dxFunc(Sqlite3.trimFunc)),
        Sqlite3.FUNCTION("ltrim", (short) 2, 1, (byte) 0, new Sqlite3.dxFunc(Sqlite3.trimFunc)),
        Sqlite3.FUNCTION("rtrim", (short) 1, 2, (byte) 0, new Sqlite3.dxFunc(Sqlite3.trimFunc)),
        Sqlite3.FUNCTION("rtrim", (short) 2, 2, (byte) 0, new Sqlite3.dxFunc(Sqlite3.trimFunc)),
        Sqlite3.FUNCTION("trim", (short) 1, 3, (byte) 0, new Sqlite3.dxFunc(Sqlite3.trimFunc)),
        Sqlite3.FUNCTION("trim", (short) 2, 3, (byte) 0, new Sqlite3.dxFunc(Sqlite3.trimFunc)),
        Sqlite3.FUNCTION("min", (short) -1, 0, (byte) 1, new Sqlite3.dxFunc(Sqlite3.minmaxFunc)),
        Sqlite3.FUNCTION("min", (short) 0, 0, (byte) 1, (Sqlite3.dxFunc) null),
        Sqlite3.AGGREGATE("min", (short) 1, 0, (byte) 1, new Sqlite3.dxStep(Sqlite3.minmaxStep), new Sqlite3.dxFinal(Sqlite3.minMaxFinalize)),
        Sqlite3.FUNCTION("max", (short) -1, 1, (byte) 1, new Sqlite3.dxFunc(Sqlite3.minmaxFunc)),
        Sqlite3.FUNCTION("max", (short) 0, 1, (byte) 1, (Sqlite3.dxFunc) null),
        Sqlite3.AGGREGATE("max", (short) 1, 1, (byte) 1, new Sqlite3.dxStep(Sqlite3.minmaxStep), new Sqlite3.dxFinal(Sqlite3.minMaxFinalize)),
        Sqlite3.FUNCTION("typeof", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.typeofFunc)),
        Sqlite3.FUNCTION("length", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.lengthFunc)),
        Sqlite3.FUNCTION("substr", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.substrFunc)),
        Sqlite3.FUNCTION("substr", (short) 3, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.substrFunc)),
        Sqlite3.FUNCTION("abs", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.absFunc)),
        Sqlite3.FUNCTION("round", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.roundFunc)),
        Sqlite3.FUNCTION("round", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.roundFunc)),
        Sqlite3.FUNCTION("upper", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.upperFunc)),
        Sqlite3.FUNCTION("lower", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.lowerFunc)),
        Sqlite3.FUNCTION("coalesce", (short) 1, 0, (byte) 0, (Sqlite3.dxFunc) null),
        Sqlite3.FUNCTION("coalesce", (short) 0, 0, (byte) 0, (Sqlite3.dxFunc) null),
        new Sqlite3.FuncDef((short) -1, (byte) 1, (byte) 64, (object) null, (Sqlite3.FuncDef) null, new Sqlite3.dxFunc(Sqlite3.versionFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, "coalesce", (Sqlite3.FuncDef) null, (Sqlite3.FuncDestructor) null),
        Sqlite3.FUNCTION("hex", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.hexFunc)),
        new Sqlite3.FuncDef((short) 2, (byte) 1, (byte) 64, (object) null, (Sqlite3.FuncDef) null, new Sqlite3.dxFunc(Sqlite3.versionFunc), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, "ifnull", (Sqlite3.FuncDef) null, (Sqlite3.FuncDestructor) null),
        Sqlite3.FUNCTION("random", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.randomFunc)),
        Sqlite3.FUNCTION("randomblob", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.randomBlob)),
        Sqlite3.FUNCTION("nullif", (short) 2, 0, (byte) 1, new Sqlite3.dxFunc(Sqlite3.nullifFunc)),
        Sqlite3.FUNCTION("sqlite_version", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.versionFunc)),
        Sqlite3.FUNCTION("sqlite_source_id", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.sourceidFunc)),
        Sqlite3.FUNCTION("sqlite_log", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.errlogFunc)),
        Sqlite3.FUNCTION("sqlite_compileoption_used", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.compileoptionusedFunc)),
        Sqlite3.FUNCTION("sqlite_compileoption_get", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.compileoptiongetFunc)),
        Sqlite3.FUNCTION("quote", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.quoteFunc)),
        Sqlite3.FUNCTION("last_insert_rowid", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.last_insert_rowid)),
        Sqlite3.FUNCTION("changes", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.changes)),
        Sqlite3.FUNCTION("total_changes", (short) 0, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.total_changes)),
        Sqlite3.FUNCTION("replace", (short) 3, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.replaceFunc)),
        Sqlite3.FUNCTION("zeroblob", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.zeroblobFunc)),
        Sqlite3.FUNCTION("load_extension", (short) 1, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.loadExt)),
        Sqlite3.FUNCTION("load_extension", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.loadExt)),
        Sqlite3.AGGREGATE("sum", (short) 1, 0, (byte) 0, new Sqlite3.dxStep(Sqlite3.sumStep), new Sqlite3.dxFinal(Sqlite3.sumFinalize)),
        Sqlite3.AGGREGATE("total", (short) 1, 0, (byte) 0, new Sqlite3.dxStep(Sqlite3.sumStep), new Sqlite3.dxFinal(Sqlite3.totalFinalize)),
        Sqlite3.AGGREGATE("avg", (short) 1, 0, (byte) 0, new Sqlite3.dxStep(Sqlite3.sumStep), new Sqlite3.dxFinal(Sqlite3.avgFinalize)),
        new Sqlite3.FuncDef((short) 0, (byte) 1, (byte) 32, (object) null, (Sqlite3.FuncDef) null, (Sqlite3.dxFunc) null, new Sqlite3.dxStep(Sqlite3.countStep), new Sqlite3.dxFinal(Sqlite3.countFinalize), "count", (Sqlite3.FuncDef) null, (Sqlite3.FuncDestructor) null),
        Sqlite3.AGGREGATE("count", (short) 1, 0, (byte) 0, new Sqlite3.dxStep(Sqlite3.countStep), new Sqlite3.dxFinal(Sqlite3.countFinalize)),
        Sqlite3.AGGREGATE("group_concat", (short) 1, 0, (byte) 0, new Sqlite3.dxStep(Sqlite3.groupConcatStep), new Sqlite3.dxFinal(Sqlite3.groupConcatFinalize)),
        Sqlite3.AGGREGATE("group_concat", (short) 2, 0, (byte) 0, new Sqlite3.dxStep(Sqlite3.groupConcatStep), new Sqlite3.dxFinal(Sqlite3.groupConcatFinalize)),
        Sqlite3.LIKEFUNC("glob", (short) 2, (object) Sqlite3.globInfo, (byte) 3),
        Sqlite3.LIKEFUNC("like", (short) 2, (object) Sqlite3.likeInfoNorm, (byte) 1),
        Sqlite3.LIKEFUNC("like", (short) 3, (object) Sqlite3.likeInfoNorm, (byte) 1),
        Sqlite3.FUNCTION("regexp", (short) 2, 0, (byte) 0, new Sqlite3.dxFunc(Sqlite3.regexpFunc))
      };
      Sqlite3.FuncDefHash sqlite3GlobalFunctions = Sqlite3.sqlite3GlobalFunctions;
      Sqlite3.FuncDef[] funcDefArray = x;
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3.FuncDef>(x); ++index)
        Sqlite3.sqlite3FuncDefInsert(sqlite3GlobalFunctions, funcDefArray[index]);
      Sqlite3.sqlite3RegisterDateTimeFunctions();
      Sqlite3.sqlite3AlterFunctions();
    }

    private static void sqlite3HashInit(Sqlite3.Hash pNew)
    {
      pNew.first = (Sqlite3.HashElem) null;
      pNew.count = 0U;
      pNew.htsize = 0U;
      pNew.ht = (Sqlite3._ht[]) null;
    }

    private static void sqlite3HashClear(Sqlite3.Hash pH)
    {
      Sqlite3.HashElem hashElem = pH.first;
      pH.first = (Sqlite3.HashElem) null;
      pH.ht = (Sqlite3._ht[]) null;
      pH.htsize = 0U;
      while (hashElem != null)
        hashElem = hashElem.next;
      pH.count = 0U;
    }

    private static uint strHash(string z, int nKey)
    {
      int num1 = 0;
      int num2 = 0;
      for (; nKey > 0; --nKey)
        num1 = num1 << 3 ^ num1 ^ (num2 < z.Length ? Sqlite3.sqlite3UpperToLower[(int) (byte) z[num2++]] : 0);
      return (uint) num1;
    }

    private static void insertElement(Sqlite3.Hash pH, Sqlite3._ht pEntry, Sqlite3.HashElem pNew)
    {
      Sqlite3.HashElem hashElem;
      if (pEntry != null)
      {
        hashElem = pEntry.count != 0 ? pEntry.chain : (Sqlite3.HashElem) null;
        ++pEntry.count;
        pEntry.chain = pNew;
      }
      else
        hashElem = (Sqlite3.HashElem) null;
      if (hashElem != null)
      {
        pNew.next = hashElem;
        pNew.prev = hashElem.prev;
        if (hashElem.prev != null)
          hashElem.prev.next = pNew;
        else
          pH.first = pNew;
        hashElem.prev = pNew;
      }
      else
      {
        pNew.next = pH.first;
        if (pH.first != null)
          pH.first.prev = pNew;
        pNew.prev = (Sqlite3.HashElem) null;
        pH.first = pNew;
      }
    }

    private static bool rehash(ref Sqlite3.Hash pH, uint new_size)
    {
      Sqlite3.sqlite3BeginBenignMalloc();
      Sqlite3._ht[] htArray = new Sqlite3._ht[(int) new_size];
      for (int index = 0; (long) index < (long) new_size; ++index)
        htArray[index] = new Sqlite3._ht();
      Sqlite3.sqlite3EndBenignMalloc();
      if (htArray == null)
        return false;
      pH.ht = htArray;
      pH.htsize = new_size;
      Sqlite3.HashElem pNew = pH.first;
      pH.first = (Sqlite3.HashElem) null;
      Sqlite3.HashElem next;
      for (; pNew != null; pNew = next)
      {
        uint index = Sqlite3.strHash(pNew.pKey, pNew.nKey) % new_size;
        next = pNew.next;
        Sqlite3.insertElement(pH, htArray[(int) index], pNew);
      }
      return true;
    }

    private static Sqlite3.HashElem findElementGivenHash(
      Sqlite3.Hash pH,
      string pKey,
      int nKey,
      uint h)
    {
      Sqlite3.HashElem X;
      int count;
      if (pH.ht != null && pH.ht[(int) h] != null)
      {
        Sqlite3._ht ht = pH.ht[(int) h];
        X = ht.chain;
        count = ht.count;
      }
      else
      {
        X = pH.first;
        count = (int) pH.count;
      }
      for (; count-- > 0 && Sqlite3.ALWAYS<Sqlite3.HashElem>(X); X = X.next)
      {
        if (X.nKey == nKey && X.pKey.Equals(pKey, StringComparison.InvariantCultureIgnoreCase))
          return X;
      }
      return (Sqlite3.HashElem) null;
    }

    private static void removeElementGivenHash(Sqlite3.Hash pH, ref Sqlite3.HashElem elem, uint h)
    {
      if (elem.prev != null)
        elem.prev.next = elem.next;
      else
        pH.first = elem.next;
      if (elem.next != null)
        elem.next.prev = elem.prev;
      if (pH.ht != null && pH.ht[(int) h] != null)
      {
        Sqlite3._ht ht = pH.ht[(int) h];
        if (ht.chain == elem)
          ht.chain = elem.next;
        --ht.count;
      }
      --pH.count;
      if (pH.count > 0U)
        return;
      Sqlite3.sqlite3HashClear(pH);
    }

    private static T sqlite3HashFind<T>(Sqlite3.Hash pH, string pKey, int nKey, T nullType) where T : class
    {
      uint h = pH.ht == null ? 0U : Sqlite3.strHash(pKey, nKey) % pH.htsize;
      Sqlite3.HashElem elementGivenHash = Sqlite3.findElementGivenHash(pH, pKey, nKey, h);
      return elementGivenHash == null ? nullType : (T) elementGivenHash.data;
    }

    private static T sqlite3HashInsert<T>(ref Sqlite3.Hash pH, string pKey, int nKey, T data) where T : class
    {
      uint h = pH.htsize == 0U ? 0U : Sqlite3.strHash(pKey, nKey) % pH.htsize;
      Sqlite3.HashElem elementGivenHash = Sqlite3.findElementGivenHash(pH, pKey, nKey, h);
      if (elementGivenHash != null)
      {
        T data1 = (T) elementGivenHash.data;
        if ((object) data == null)
        {
          Sqlite3.removeElementGivenHash(pH, ref elementGivenHash, h);
          return data1;
        }
        elementGivenHash.data = (object) data;
        elementGivenHash.pKey = pKey;
        return data1;
      }
      if ((object) data == null)
        return data;
      Sqlite3.HashElem pNew = new Sqlite3.HashElem();
      if (pNew == null)
        return data;
      pNew.pKey = pKey;
      pNew.nKey = nKey;
      pNew.data = (object) data;
      ++pH.count;
      if (pH.count >= 10U && pH.count > 2U * pH.htsize && Sqlite3.rehash(ref pH, pH.count * 2U))
        h = Sqlite3.strHash(pKey, nKey) % pH.htsize;
      if (pH.ht != null)
        Sqlite3.insertElement(pH, pH.ht[(int) h], pNew);
      else
        Sqlite3.insertElement(pH, (Sqlite3._ht) null, pNew);
      return default (T);
    }

    private static Sqlite3.HashElem sqliteHashFirst(Sqlite3.Hash H) => H.first;

    private static Sqlite3.HashElem sqliteHashNext(Sqlite3.HashElem E) => E.next;

    private static object sqliteHashData(Sqlite3.HashElem E) => E.data;

    private static ulong sqlite3Hwtime() => (ulong) System.DateTime.Now.Ticks;

    private static void sqlite3OpenTable(
      Sqlite3.Parse p,
      int iCur,
      int iDb,
      Sqlite3.Table pTab,
      int opcode)
    {
      if (Sqlite3.IsVirtual(pTab))
        return;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(p);
      Sqlite3.sqlite3TableLock(p, iDb, pTab.tnum, opcode == 39 ? (byte) 1 : (byte) 0, pTab.zName);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, opcode, iCur, pTab.tnum, iDb);
      Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, pTab.nCol, -14);
      Sqlite3.VdbeComment(vdbe, "%s", (object) pTab.zName);
    }

    private static string sqlite3IndexAffinityStr(Sqlite3.Vdbe v, Sqlite3.Index pIdx)
    {
      if (pIdx.zColAff == null || pIdx.zColAff[0] == char.MinValue)
      {
        Sqlite3.Table pTable = pIdx.pTable;
        Sqlite3.sqlite3VdbeDb(v);
        StringBuilder stringBuilder = new StringBuilder(pIdx.nColumn + 2);
        for (int index = 0; index < pIdx.nColumn; ++index)
          stringBuilder.Append(pTable.aCol[pIdx.aiColumn[index]].affinity);
        stringBuilder.Append('b');
        stringBuilder.Append(char.MinValue);
        pIdx.zColAff = stringBuilder.ToString();
      }
      return pIdx.zColAff;
    }

    private static void sqlite3TableAffinityStr(Sqlite3.Vdbe v, Sqlite3.Table pTab)
    {
      if (pTab.zColAff == null)
      {
        Sqlite3.sqlite3VdbeDb(v);
        StringBuilder stringBuilder = new StringBuilder(pTab.nCol + 1);
        if (stringBuilder == null)
          return;
        for (int index = 0; index < pTab.nCol; ++index)
          stringBuilder.Append(pTab.aCol[index].affinity);
        pTab.zColAff = stringBuilder.ToString();
      }
      Sqlite3.sqlite3VdbeChangeP4(v, -1, pTab.zColAff, 0);
    }

    private static bool readsTable(Sqlite3.Parse p, int iStartAddr, int iDb, Sqlite3.Table pTab)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(p);
      int num = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
      for (int addr = iStartAddr; addr < num; ++addr)
      {
        Sqlite3.VdbeOp op = Sqlite3.sqlite3VdbeGetOp(vdbe, addr);
        if (op.opcode == (byte) 38 && op.p3 == iDb)
        {
          int p2 = op.p2;
          if (p2 == pTab.tnum)
            return true;
          for (Sqlite3.Index index = pTab.pIndex; index != null; index = index.pNext)
          {
            if (p2 == index.tnum)
              return true;
          }
        }
      }
      return false;
    }

    private static int autoIncBegin(Sqlite3.Parse pParse, int iDb, Sqlite3.Table pTab)
    {
      int num = 0;
      if (((int) pTab.tabFlags & 8) != 0)
      {
        Sqlite3.Parse toplevel = Sqlite3.sqlite3ParseToplevel(pParse);
        Sqlite3.AutoincInfo autoincInfo = toplevel.pAinc;
        while (autoincInfo != null && autoincInfo.pTab != pTab)
          autoincInfo = autoincInfo.pNext;
        if (autoincInfo == null)
        {
          autoincInfo = new Sqlite3.AutoincInfo();
          autoincInfo.pNext = toplevel.pAinc;
          toplevel.pAinc = autoincInfo;
          autoincInfo.pTab = pTab;
          autoincInfo.iDb = iDb;
          ++toplevel.nMem;
          autoincInfo.regCtr = ++toplevel.nMem;
          ++toplevel.nMem;
        }
        num = autoincInfo.regCtr;
      }
      return num;
    }

    private static void sqlite3AutoincrementBegin(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db1 = pParse.db;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      for (Sqlite3.AutoincInfo autoincInfo = pParse.pAinc; autoincInfo != null; autoincInfo = autoincInfo.pNext)
      {
        Sqlite3.Db db2 = db1.aDb[autoincInfo.iDb];
        int regCtr = autoincInfo.regCtr;
        Sqlite3.sqlite3OpenTable(pParse, 0, autoincInfo.iDb, db2.pSchema.pSeqTab, 38);
        int num = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
        Sqlite3.sqlite3VdbeAddOp4(pVdbe, 94, 0, regCtr - 1, 0, autoincInfo.pTab.zName, 0);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 65, 0, num + 9);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, 0, 0, regCtr);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 75, regCtr - 1, num + 7, regCtr);
        Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 8);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 61, 0, regCtr + 1);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, 0, 1, regCtr);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, num + 9);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 67, 0, num + 2);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, regCtr);
        Sqlite3.sqlite3VdbeAddOp0(pVdbe, 43);
      }
    }

    private static void autoIncStep(Sqlite3.Parse pParse, int memId, int regRowid)
    {
      if (memId <= 0)
        return;
      Sqlite3.sqlite3VdbeAddOp2(pParse.pVdbe, 112, memId, regRowid);
    }

    private static void sqlite3AutoincrementEnd(Sqlite3.Parse pParse)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.sqlite3 db1 = pParse.db;
      for (Sqlite3.AutoincInfo autoincInfo = pParse.pAinc; autoincInfo != null; autoincInfo = autoincInfo.pNext)
      {
        Sqlite3.Db db2 = db1.aDb[autoincInfo.iDb];
        int regCtr = autoincInfo.regCtr;
        int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
        Sqlite3.sqlite3OpenTable(pParse, 0, autoincInfo.iDb, db2.pSchema.pSeqTab, 39);
        int addr1 = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 74, regCtr + 1);
        int addr2 = Sqlite3.sqlite3VdbeAddOp0(pVdbe, 65);
        int p2 = Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, 0, 0, tempReg);
        int addr3 = Sqlite3.sqlite3VdbeAddOp3(pVdbe, 76, regCtr - 1, 0, tempReg);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 67, 0, p2);
        Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr2);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 54, 0, regCtr + 1);
        int addr4 = Sqlite3.sqlite3VdbeAddOp0(pVdbe, 1);
        Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr3);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 61, 0, regCtr + 1);
        Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr1);
        Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr4);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, regCtr - 1, 2, tempReg);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 55, 0, tempReg, regCtr + 1);
        Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 8);
        Sqlite3.sqlite3VdbeAddOp0(pVdbe, 43);
        Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      }
    }

    private static void sqlite3Insert(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      int null_3,
      int null_4,
      Sqlite3.IdList pColumn,
      int onError)
    {
      Sqlite3.sqlite3Insert(pParse, pTabList, (Sqlite3.ExprList) null, (Sqlite3.Select) null, pColumn, onError);
    }

    private static void sqlite3Insert(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      int null_3,
      Sqlite3.Select pSelect,
      Sqlite3.IdList pColumn,
      int onError)
    {
      Sqlite3.sqlite3Insert(pParse, pTabList, (Sqlite3.ExprList) null, pSelect, pColumn, onError);
    }

    private static void sqlite3Insert(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.ExprList pList,
      int null_4,
      Sqlite3.IdList pColumn,
      int onError)
    {
      Sqlite3.sqlite3Insert(pParse, pTabList, pList, (Sqlite3.Select) null, pColumn, onError);
    }

    private static void sqlite3Insert(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.ExprList pList,
      Sqlite3.Select pSelect,
      Sqlite3.IdList pColumn,
      int onError)
    {
      int num1 = 0;
      int num2 = 0;
      int p2_1 = -1;
      bool flag1 = false;
      int p1_1 = 0;
      int addr1 = 0;
      int p2_2 = 0;
      bool appendBias = false;
      int p1_2 = 0;
      int num3 = 0;
      int num4 = 0;
      int[] pPrior = (int[]) null;
      int pMask = 0;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.SelectDest pDest = new Sqlite3.SelectDest();
      if (pParse.nErr == 0 && !Sqlite3.NEVER(pTabList.a[0].zName == null))
      {
        Sqlite3.Table table = Sqlite3.sqlite3SrcListLookup(pParse, pTabList);
        if (table != null)
        {
          int index1 = Sqlite3.sqlite3SchemaToIndex(db, table.pSchema);
          string zName = db.aDb[index1].zName;
          Sqlite3.Trigger pTrigger = Sqlite3.sqlite3TriggersExist(pParse, table, 105, (Sqlite3.ExprList) null, out pMask);
          bool flag2 = table.pSelect != null;
          if (Sqlite3.sqlite3ViewGetColumnNames(pParse, table) == 0 && !Sqlite3.sqlite3IsReadOnly(pParse, table, pMask))
          {
            Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
            if (vdbe != null)
            {
              if (pParse.nested == (byte) 0)
                Sqlite3.sqlite3VdbeCountChanges(vdbe);
              Sqlite3.sqlite3BeginWriteOperation(pParse, pSelect != null || pTrigger != null ? 1 : 0, index1);
              if (pColumn != null || Sqlite3.xferOptimization(pParse, table, pSelect, onError, index1) == 0)
              {
                int num5 = Sqlite3.autoIncBegin(pParse, index1, table);
                int p2_3;
                if (pSelect != null)
                {
                  num4 = ++pParse.nMem;
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num4);
                  Sqlite3.sqlite3SelectDestInit(pDest, 10, ++pParse.nMem);
                  int iStartAddr = Sqlite3.sqlite3VdbeCurrentAddr(vdbe) + 2;
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, iStartAddr - 1, pDest.iParm);
                  int addr2 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, 0);
                  if (Sqlite3.sqlite3Select(pParse, pSelect, ref pDest) == 0 && !Sqlite3.NEVER(pParse.nErr != 0))
                  {
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 1, num4);
                    Sqlite3.sqlite3VdbeAddOp1(vdbe, 4, pDest.iParm);
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 6, 2, 2);
                    Sqlite3.sqlite3VdbeJumpHere(vdbe, addr2);
                    p1_2 = pDest.iMem;
                    p2_3 = pSelect.pEList.nExpr;
                    if (pTrigger != null || Sqlite3.readsTable(pParse, iStartAddr, index1, table))
                      flag1 = true;
                    if (flag1)
                    {
                      p1_1 = pParse.nTab++;
                      int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
                      int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, p1_1, p2_3);
                      int p2_4 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 4, pDest.iParm);
                      int addr3 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 26, num4);
                      Sqlite3.sqlite3VdbeAddOp3(vdbe, 30, p1_2, p2_3, tempReg1);
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 54, p1_1, tempReg2);
                      Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, p1_1, tempReg1, tempReg2);
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, p2_4);
                      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr3);
                      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
                      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
                    }
                  }
                  else
                    goto label_134;
                }
                else
                {
                  Sqlite3.NameContext pNC = new Sqlite3.NameContext();
                  pNC.pParse = pParse;
                  p1_1 = -1;
                  p2_3 = pList != null ? pList.nExpr : 0;
                  for (int index2 = 0; index2 < p2_3; ++index2)
                  {
                    if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pList.a[index2].pExpr) != 0)
                      goto label_134;
                  }
                }
                if (Sqlite3.IsVirtual(table))
                {
                  for (int index3 = 0; index3 < table.nCol; ++index3)
                    num1 += Sqlite3.IsHiddenColumn(table.aCol[index3]) ? 1 : 0;
                }
                if (pColumn == null && p2_3 != 0 && p2_3 != table.nCol - num1)
                {
                  Sqlite3.sqlite3ErrorMsg(pParse, "table %S has %d columns but %d values were supplied", (object) pTabList, (object) 0, (object) (table.nCol - num1), (object) p2_3);
                  goto label_134;
                }
                else if (pColumn != null && p2_3 != pColumn.nId)
                {
                  Sqlite3.sqlite3ErrorMsg(pParse, "%d values for %d columns", (object) p2_3, (object) pColumn.nId);
                  goto label_134;
                }
                else
                {
                  if (pColumn != null)
                  {
                    for (int index4 = 0; index4 < pColumn.nId; ++index4)
                      pColumn.a[index4].idx = -1;
                    for (int index5 = 0; index5 < pColumn.nId; ++index5)
                    {
                      int index6;
                      for (index6 = 0; index6 < table.nCol; ++index6)
                      {
                        if (pColumn.a[index5].zName.Equals(table.aCol[index6].zName, StringComparison.InvariantCultureIgnoreCase))
                        {
                          pColumn.a[index5].idx = index6;
                          if (index6 == table.iPKey)
                          {
                            p2_1 = index5;
                            break;
                          }
                          break;
                        }
                      }
                      if (index6 >= table.nCol)
                      {
                        if (Sqlite3.sqlite3IsRowid(pColumn.a[index5].zName))
                        {
                          p2_1 = index5;
                        }
                        else
                        {
                          Sqlite3.sqlite3ErrorMsg(pParse, "table %S has no column named %s", (object) pTabList, (object) 0, (object) pColumn.a[index5].zName);
                          pParse.checkSchema = (byte) 1;
                          goto label_134;
                        }
                      }
                    }
                  }
                  if (pColumn == null && p2_3 > 0)
                    p2_1 = table.iPKey;
                  if ((db.flags & 4096) != 0)
                  {
                    num3 = ++pParse.nMem;
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num3);
                  }
                  if (!flag2)
                  {
                    num2 = pParse.nTab;
                    int num6 = Sqlite3.sqlite3OpenTableAndIndices(pParse, table, num2, 39);
                    pPrior = new int[num6 + 1];
                    if (pPrior != null)
                    {
                      for (int index7 = 0; index7 < num6; ++index7)
                        pPrior[index7] = ++pParse.nMem;
                    }
                    else
                      goto label_134;
                  }
                  if (flag1)
                  {
                    addr1 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 65, p1_1);
                    p2_2 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                  }
                  else if (pSelect != null)
                  {
                    p2_2 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 4, pDest.iParm);
                    addr1 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 26, num4);
                  }
                  int num7;
                  int num8 = num7 = pParse.nMem + 1;
                  pParse.nMem += table.nCol + 1;
                  if (Sqlite3.IsVirtual(table))
                  {
                    ++num8;
                    ++pParse.nMem;
                  }
                  int num9 = num8 + 1;
                  int num10 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
                  if ((pMask & 1) != 0)
                  {
                    int tempRange = Sqlite3.sqlite3GetTempRange(pParse, table.nCol + 1);
                    if (p2_1 < 0)
                    {
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, -1, tempRange);
                    }
                    else
                    {
                      if (flag1)
                        Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, p1_1, p2_1, tempRange);
                      else
                        Sqlite3.sqlite3ExprCode(pParse, pList.a[p2_1].pExpr, tempRange);
                      int addr4 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 74, tempRange);
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, -1, tempRange);
                      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr4);
                      Sqlite3.sqlite3VdbeAddOp1(vdbe, 21, tempRange);
                    }
                    for (int index8 = 0; index8 < table.nCol; ++index8)
                    {
                      int p2_5;
                      if (pColumn == null)
                      {
                        p2_5 = index8;
                      }
                      else
                      {
                        p2_5 = 0;
                        while (p2_5 < pColumn.nId && pColumn.a[p2_5].idx != index8)
                          ++p2_5;
                      }
                      if (!flag1 && pList == null || pColumn != null && p2_5 >= pColumn.nId)
                        Sqlite3.sqlite3ExprCode(pParse, table.aCol[index8].pDflt, tempRange + index8 + 1);
                      else if (flag1)
                        Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, p1_1, p2_5, tempRange + index8 + 1);
                      else
                        Sqlite3.sqlite3ExprCodeAndCache(pParse, pList.a[p2_5].pExpr, tempRange + index8 + 1);
                    }
                    if (!flag2)
                    {
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 29, tempRange + 1, table.nCol);
                      Sqlite3.sqlite3TableAffinityStr(vdbe, table);
                    }
                    Sqlite3.sqlite3CodeRowTrigger(pParse, pTrigger, 105, (Sqlite3.ExprList) null, 1, table, tempRange - table.nCol - 1, onError, num10);
                    Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, table.nCol + 1);
                  }
                  if (!flag2)
                  {
                    if (Sqlite3.IsVirtual(table))
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num7);
                    if (p2_1 >= 0)
                    {
                      if (flag1)
                        Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, p1_1, p2_1, num8);
                      else if (pSelect != null)
                      {
                        Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, p1_2 + p2_1, num8);
                      }
                      else
                      {
                        Sqlite3.sqlite3ExprCode(pParse, pList.a[p2_1].pExpr, num8);
                        Sqlite3.VdbeOp op = Sqlite3.sqlite3VdbeGetOp(vdbe, -1);
                        if (Sqlite3.ALWAYS(op != null) && op.opcode == (byte) 10 && !Sqlite3.IsVirtual(table))
                        {
                          appendBias = true;
                          op.opcode = (byte) 54;
                          op.p1 = num2;
                          op.p2 = num8;
                          op.p3 = num5;
                        }
                      }
                      if (!appendBias)
                      {
                        if (!Sqlite3.IsVirtual(table))
                        {
                          int addr5 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 74, num8);
                          Sqlite3.sqlite3VdbeAddOp3(vdbe, 54, num2, num8, num5);
                          Sqlite3.sqlite3VdbeJumpHere(vdbe, addr5);
                        }
                        else
                        {
                          int num11 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                          Sqlite3.sqlite3VdbeAddOp2(vdbe, 73, num8, num11 + 2);
                        }
                        Sqlite3.sqlite3VdbeAddOp1(vdbe, 21, num8);
                      }
                    }
                    else if (Sqlite3.IsVirtual(table))
                    {
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num8);
                    }
                    else
                    {
                      Sqlite3.sqlite3VdbeAddOp3(vdbe, 54, num2, num8, num5);
                      appendBias = true;
                    }
                    Sqlite3.autoIncStep(pParse, num5, num8);
                    int num12 = 0;
                    for (int index9 = 0; index9 < table.nCol; ++index9)
                    {
                      int num13 = num8 + 1 + index9;
                      if (index9 == table.iPKey)
                      {
                        Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num13);
                      }
                      else
                      {
                        int p2_6;
                        if (pColumn == null)
                        {
                          if (Sqlite3.IsHiddenColumn(table.aCol[index9]))
                          {
                            p2_6 = -1;
                            ++num12;
                          }
                          else
                            p2_6 = index9 - num12;
                        }
                        else
                        {
                          p2_6 = 0;
                          while (p2_6 < pColumn.nId && pColumn.a[p2_6].idx != index9)
                            ++p2_6;
                        }
                        if (p2_6 < 0 || p2_3 == 0 || pColumn != null && p2_6 >= pColumn.nId)
                          Sqlite3.sqlite3ExprCode(pParse, table.aCol[index9].pDflt, num13);
                        else if (flag1)
                          Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, p1_1, p2_6, num13);
                        else if (pSelect != null)
                          Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, p1_2 + p2_6, num13);
                        else
                          Sqlite3.sqlite3ExprCode(pParse, pList.a[p2_6].pExpr, num13);
                      }
                    }
                    int pbMayReplace = 0;
                    Sqlite3.sqlite3GenerateConstraintChecks(pParse, table, num2, num7, pPrior, p2_1 >= 0 ? 1 : 0, false, onError, num10, out pbMayReplace);
                    Sqlite3.sqlite3FkCheck(pParse, table, 0, num7);
                    Sqlite3.sqlite3CompleteInsertion(pParse, table, num2, num7, pPrior, false, appendBias, pbMayReplace == 0);
                  }
                  if ((db.flags & 4096) != 0)
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 20, num3, 1);
                  if (pTrigger != null)
                    Sqlite3.sqlite3CodeRowTrigger(pParse, pTrigger, 105, (Sqlite3.ExprList) null, 2, table, num9 - 2 - table.nCol, onError, num10);
                  Sqlite3.sqlite3VdbeResolveLabel(vdbe, num10);
                  if (flag1)
                  {
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, p1_1, p2_2);
                    Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
                    Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, p1_1);
                  }
                  else if (pSelect != null)
                  {
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, p2_2);
                    Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
                  }
                  if (!Sqlite3.IsVirtual(table) && !flag2)
                  {
                    Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, num2);
                    int num14 = 1;
                    Sqlite3.Index index10 = table.pIndex;
                    while (index10 != null)
                    {
                      Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, num14 + num2);
                      index10 = index10.pNext;
                      ++num14;
                    }
                  }
                }
              }
              if (pParse.nested == (byte) 0 && pParse.pTriggerTab == null)
                Sqlite3.sqlite3AutoincrementEnd(pParse);
              if ((db.flags & 4096) != 0 && pParse.nested == (byte) 0 && pParse.pTriggerTab == null)
              {
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, num3, 1);
                Sqlite3.sqlite3VdbeSetNumCols(vdbe, 1);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, "rows inserted", Sqlite3.SQLITE_STATIC);
              }
            }
          }
        }
      }
label_134:
      Sqlite3.sqlite3SrcListDelete(db, ref pTabList);
      Sqlite3.sqlite3ExprListDelete(db, ref pList);
      Sqlite3.sqlite3SelectDelete(db, ref pSelect);
      Sqlite3.sqlite3IdListDelete(db, ref pColumn);
      Sqlite3.sqlite3DbFree(db, ref pPrior);
    }

    private static void sqlite3GenerateConstraintChecks(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int baseCur,
      int regRowid,
      int[] aRegIdx,
      int rowidChng,
      bool isUpdate,
      int overrideError,
      int ignoreDest,
      out int pbMayReplace)
    {
      int addr1 = 0;
      bool flag = false;
      int p1 = rowidChng != 0 & isUpdate ? rowidChng : regRowid;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      int nCol = pTab.nCol;
      int num1 = regRowid + 1;
      for (int index = 0; index < nCol; ++index)
      {
        if (index != pTab.iPKey)
        {
          int p2 = (int) pTab.aCol[index].notNull;
          if (p2 != 0)
          {
            if (overrideError != 99)
              p2 = overrideError;
            else if (p2 == 99)
              p2 = 2;
            if (p2 == 5 && pTab.aCol[index].pDflt == null)
              p2 = 2;
            switch (p2)
            {
              case 1:
              case 3:
                Sqlite3.sqlite3VdbeAddOp3(vdbe, 5, 19, p2, num1 + index);
                string z = Sqlite3.sqlite3MPrintf(pParse.db, "%s.%s may not be NULL", (object) pTab.zName, (object) pTab.aCol[index].zName);
                Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, z, -1);
                continue;
              case 2:
                Sqlite3.sqlite3MayAbort(pParse);
                goto case 1;
              case 4:
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 73, num1 + index, ignoreDest);
                continue;
              default:
                int addr2 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 74, num1 + index);
                Sqlite3.sqlite3ExprCode(pParse, pTab.aCol[index].pDflt, num1 + index);
                Sqlite3.sqlite3VdbeJumpHere(vdbe, addr2);
                continue;
            }
          }
        }
      }
      if (pTab.pCheck != null && (pParse.db.flags & 262144) == 0)
      {
        int num2 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
        pParse.ckBase = num1;
        Sqlite3.sqlite3ExprIfTrue(pParse, pTab.pCheck, num2, 8);
        int onError = overrideError != 99 ? overrideError : 2;
        switch (onError)
        {
          case 4:
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, ignoreDest);
            break;
          case 5:
            onError = 2;
            goto default;
          default:
            Sqlite3.sqlite3HaltConstraint(pParse, onError, (string) null, 0);
            break;
        }
        Sqlite3.sqlite3VdbeResolveLabel(vdbe, num2);
      }
      if (rowidChng != 0)
      {
        int onError = (int) pTab.keyConf;
        if (overrideError != 99)
          onError = overrideError;
        else if (onError == 99)
          onError = 2;
        if (isUpdate)
          addr1 = Sqlite3.sqlite3VdbeAddOp3(vdbe, 76, regRowid, 0, rowidChng);
        int addr3 = Sqlite3.sqlite3VdbeAddOp3(vdbe, 52, baseCur, 0, regRowid);
        switch (onError)
        {
          case 1:
          case 2:
          case 3:
            Sqlite3.sqlite3HaltConstraint(pParse, onError, "PRIMARY KEY must be unique", -2);
            break;
          case 4:
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, ignoreDest);
            break;
          case 5:
            Sqlite3.Trigger pTrigger = (Sqlite3.Trigger) null;
            if ((pParse.db.flags & 33554432) != 0)
              pTrigger = Sqlite3.sqlite3TriggersExist(pParse, pTab, 106, (Sqlite3.ExprList) null, out int _);
            if (pTrigger != null || Sqlite3.sqlite3FkRequired(pParse, pTab, (int[]) null, 0) != 0)
            {
              Sqlite3.sqlite3MultiWrite(pParse);
              Sqlite3.sqlite3GenerateRowDelete(pParse, pTab, baseCur, regRowid, 0, pTrigger, 5);
            }
            else if (pTab.pIndex != null)
            {
              Sqlite3.sqlite3MultiWrite(pParse);
              Sqlite3.sqlite3GenerateRowIndexDelete(pParse, pTab, baseCur, 0);
            }
            flag = true;
            break;
          default:
            onError = 2;
            goto case 1;
        }
        Sqlite3.sqlite3VdbeJumpHere(vdbe, addr3);
        if (isUpdate)
          Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
      }
      int index1 = 0;
      Sqlite3.Index pIdx = pTab.pIndex;
      while (pIdx != null)
      {
        if (aRegIdx[index1] != 0)
        {
          int tempRange = Sqlite3.sqlite3GetTempRange(pParse, pIdx.nColumn + 1);
          int index2;
          for (index2 = 0; index2 < pIdx.nColumn; ++index2)
          {
            int num3 = pIdx.aiColumn[index2];
            if (num3 == pTab.iPKey)
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, regRowid, tempRange + index2);
            else
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, num1 + num3, tempRange + index2);
          }
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, regRowid, tempRange + index2);
          Sqlite3.sqlite3VdbeAddOp3(vdbe, 30, tempRange, pIdx.nColumn + 1, aRegIdx[index1]);
          Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, Sqlite3.sqlite3IndexAffinityStr(vdbe, pIdx), 0);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, tempRange, pIdx.nColumn + 1);
          int onError = (int) pIdx.onError;
          if (onError == 0)
          {
            Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, pIdx.nColumn + 1);
          }
          else
          {
            if (overrideError != 99)
              onError = overrideError;
            else if (onError == 99)
              onError = 2;
            if (flag)
            {
              switch (onError)
              {
                case 3:
                  onError = 2;
                  break;
                case 4:
                  onError = 5;
                  break;
              }
            }
            int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, p1, tempReg);
            int addr4 = Sqlite3.sqlite3VdbeAddOp4(vdbe, 51, baseCur + index1 + 1, 0, tempReg, tempRange, -14);
            Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, pIdx.nColumn + 1);
            switch (onError - 1)
            {
              case 0:
              case 1:
              case 2:
                Sqlite3.StrAccum p = new Sqlite3.StrAccum(200);
                Sqlite3.sqlite3StrAccumInit(p, (StringBuilder) null, 0, 200);
                p.db = pParse.db;
                string z = pIdx.nColumn > 1 ? "columns " : "column ";
                for (int index3 = 0; index3 < pIdx.nColumn; ++index3)
                {
                  string zName = pTab.aCol[pIdx.aiColumn[index3]].zName;
                  Sqlite3.sqlite3StrAccumAppend(p, z, -1);
                  z = ", ";
                  Sqlite3.sqlite3StrAccumAppend(p, zName, -1);
                }
                Sqlite3.sqlite3StrAccumAppend(p, pIdx.nColumn > 1 ? " are not unique" : " is not unique", -1);
                string pString = Sqlite3.sqlite3StrAccumFinish(p);
                Sqlite3.sqlite3HaltConstraint(pParse, onError, pString, 0);
                Sqlite3.sqlite3DbFree(p.db, ref pString);
                break;
              case 3:
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, ignoreDest);
                break;
              default:
                Sqlite3.Trigger pTrigger = (Sqlite3.Trigger) null;
                Sqlite3.sqlite3MultiWrite(pParse);
                if ((pParse.db.flags & 33554432) != 0)
                  pTrigger = Sqlite3.sqlite3TriggersExist(pParse, pTab, 106, (Sqlite3.ExprList) null, out int _);
                Sqlite3.sqlite3GenerateRowDelete(pParse, pTab, baseCur, tempReg, 0, pTrigger, 5);
                flag = true;
                break;
            }
            Sqlite3.sqlite3VdbeJumpHere(vdbe, addr4);
            Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
          }
        }
        pIdx = pIdx.pNext;
        ++index1;
      }
      pbMayReplace = flag ? 1 : 0;
    }

    private static void sqlite3CompleteInsertion(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int baseCur,
      int regRowid,
      int[] aRegIdx,
      bool isUpdate,
      bool appendBias,
      bool useSeekResult)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      int num1 = 0;
      Sqlite3.Index index1 = pTab.pIndex;
      while (index1 != null)
      {
        index1 = index1.pNext;
        ++num1;
      }
      for (int index2 = num1 - 1; index2 >= 0; --index2)
      {
        if (aRegIdx[index2] != 0)
        {
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 70, baseCur + index2 + 1, aRegIdx[index2]);
          if (useSeekResult)
            Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 16);
        }
      }
      int num2 = regRowid + 1;
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 30, num2, pTab.nCol, tempReg);
      Sqlite3.sqlite3TableAffinityStr(vdbe, pTab);
      Sqlite3.sqlite3ExprCacheAffinityChange(pParse, num2, pTab.nCol);
      byte val = pParse.nested == (byte) 0 ? (byte) (1 | (isUpdate ? 4 : 2)) : (byte) 0;
      if (appendBias)
        val |= (byte) 8;
      if (useSeekResult)
        val |= (byte) 16;
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, baseCur, tempReg, regRowid);
      if (pParse.nested == (byte) 0)
        Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, pTab.zName, 0);
      Sqlite3.sqlite3VdbeChangeP5(vdbe, val);
    }

    private static int sqlite3OpenTableAndIndices(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int baseCur,
      int op)
    {
      if (Sqlite3.IsVirtual(pTab))
        return 0;
      int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      Sqlite3.sqlite3OpenTable(pParse, baseCur, index, pTab, op);
      int num = 1;
      Sqlite3.Index pIdx = pTab.pIndex;
      while (pIdx != null)
      {
        Sqlite3.KeyInfo pP4 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
        Sqlite3.sqlite3VdbeAddOp4(vdbe, op, num + baseCur, pIdx.tnum, index, pP4, -16);
        pIdx = pIdx.pNext;
        ++num;
      }
      if (pParse.nTab < baseCur + num)
        pParse.nTab = baseCur + num;
      return num - 1;
    }

    private static bool xferCompatibleCollation(string z1, string z2)
    {
      if (z1 == null)
        return z2 == null;
      return z2 != null && z1.Equals(z2, StringComparison.InvariantCultureIgnoreCase);
    }

    private static bool xferCompatibleIndex(Sqlite3.Index pDest, Sqlite3.Index pSrc)
    {
      if (pDest.nColumn != pSrc.nColumn || (int) pDest.onError != (int) pSrc.onError)
        return false;
      for (int index = 0; index < pSrc.nColumn; ++index)
      {
        if (pSrc.aiColumn[index] != pDest.aiColumn[index] || (int) pSrc.aSortOrder[index] != (int) pDest.aSortOrder[index] || !Sqlite3.xferCompatibleCollation(pSrc.azColl[index], pDest.azColl[index]))
          return false;
      }
      return true;
    }

    private static int xferOptimization(
      Sqlite3.Parse pParse,
      Sqlite3.Table pDest,
      Sqlite3.Select pSelect,
      int onError,
      int iDbDest)
    {
      bool flag = false;
      if (pSelect == null || Sqlite3.sqlite3TriggerList(pParse, pDest) != null || ((int) pDest.tabFlags & 16) != 0)
        return 0;
      if (onError == 99)
        onError = 2;
      if (onError != 2 && onError != 1 || pSelect.pSrc.nSrc != (short) 1 || pSelect.pSrc.a[0].pSelect != null || pSelect.pWhere != null || pSelect.pOrderBy != null || pSelect.pGroupBy != null || pSelect.pLimit != null || pSelect.pPrior != null || ((int) pSelect.selFlags & 1) != 0)
        return 0;
      Sqlite3.ExprList pElist = pSelect.pEList;
      if (pElist.nExpr != 1 || pElist.a[0].pExpr.op != (byte) 113)
        return 0;
      Sqlite3.SrcList_item srcListItem = pSelect.pSrc.a[0];
      Sqlite3.Table pTab = Sqlite3.sqlite3LocateTable(pParse, 0, srcListItem.zName, srcListItem.zDatabase);
      if (pTab == null || pTab == pDest || ((int) pTab.tabFlags & 16) != 0 || pTab.pSelect != null || pDest.nCol != pTab.nCol || pDest.iPKey != pTab.iPKey)
        return 0;
      for (int index = 0; index < pDest.nCol; ++index)
      {
        if ((int) pDest.aCol[index].affinity != (int) pTab.aCol[index].affinity || !Sqlite3.xferCompatibleCollation(pDest.aCol[index].zColl, pTab.aCol[index].zColl) || pDest.aCol[index].notNull != (byte) 0 && pTab.aCol[index].notNull == (byte) 0)
          return 0;
      }
      for (Sqlite3.Index pDest1 = pDest.pIndex; pDest1 != null; pDest1 = pDest1.pNext)
      {
        if (pDest1.onError != (byte) 0)
          flag = true;
        Sqlite3.Index pSrc = pTab.pIndex;
        while (pSrc != null && !Sqlite3.xferCompatibleIndex(pDest1, pSrc))
          pSrc = pSrc.pNext;
        if (pSrc == null)
          return 0;
      }
      if (pDest.pCheck != null && Sqlite3.sqlite3ExprCompare(pTab.pCheck, pDest.pCheck) != 0 || (pParse.db.flags & 67108864) != 0 && pDest.pFKey != null)
        return 0;
      int index1 = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      Sqlite3.sqlite3CodeVerifySchema(pParse, index1);
      int num1 = pParse.nTab++;
      int num2 = pParse.nTab++;
      int memId = Sqlite3.autoIncBegin(pParse, iDbDest, pDest);
      Sqlite3.sqlite3OpenTable(pParse, num2, iDbDest, pDest, 39);
      int addr1;
      if (((pDest.iPKey >= 0 ? 0 : (pDest.pIndex != null ? 1 : 0)) | (flag ? 1 : 0)) != 0)
      {
        int addr2 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, num2, 0);
        addr1 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, 0);
        Sqlite3.sqlite3VdbeJumpHere(vdbe, addr2);
      }
      else
        addr1 = 0;
      Sqlite3.sqlite3OpenTable(pParse, num1, index1, pTab, 38);
      int addr3 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, num1, 0);
      int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
      int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
      int p2;
      if (pDest.iPKey >= 0)
      {
        p2 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 61, num1, tempReg2);
        int addr4 = Sqlite3.sqlite3VdbeAddOp3(vdbe, 52, num2, 0, tempReg2);
        Sqlite3.sqlite3HaltConstraint(pParse, onError, "PRIMARY KEY must be unique", -2);
        Sqlite3.sqlite3VdbeJumpHere(vdbe, addr4);
        Sqlite3.autoIncStep(pParse, memId, tempReg2);
      }
      else
        p2 = pDest.pIndex != null ? Sqlite3.sqlite3VdbeAddOp2(vdbe, 61, num1, tempReg2) : Sqlite3.sqlite3VdbeAddOp2(vdbe, 54, num2, tempReg2);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 60, num1, tempReg1);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 55, num2, tempReg1, tempReg2);
      Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 11);
      Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, pDest.zName, 0);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, num1, p2);
      for (Sqlite3.Index index2 = pDest.pIndex; index2 != null; index2 = index2.pNext)
      {
        Sqlite3.Index index3 = pTab.pIndex;
        while (index3 != null && !Sqlite3.xferCompatibleIndex(index2, index3))
          index3 = index3.pNext;
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num1, 0);
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num2, 0);
        Sqlite3.KeyInfo pP4_1 = Sqlite3.sqlite3IndexKeyinfo(pParse, index3);
        Sqlite3.sqlite3VdbeAddOp4(vdbe, 38, num1, index3.tnum, index1, pP4_1, -16);
        Sqlite3.KeyInfo pP4_2 = Sqlite3.sqlite3IndexKeyinfo(pParse, index2);
        Sqlite3.sqlite3VdbeAddOp4(vdbe, 39, num2, index2.tnum, iDbDest, pP4_2, -16);
        int addr5 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, num1, 0);
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 59, num1, tempReg1);
        Sqlite3.sqlite3VdbeAddOp3(vdbe, 70, num2, tempReg1, 1);
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, num1, addr5 + 1);
        Sqlite3.sqlite3VdbeJumpHere(vdbe, addr5);
      }
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr3);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num1, 0);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num2, 0);
      if (addr1 == 0)
        return 1;
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 6, 0, 0);
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num2, 0);
      return 0;
    }

    private static int keywordCode(string z, int iOffset, int n)
    {
      if (n < 2)
        return 26;
      int index1 = (Sqlite3.sqlite3UpperToLower[(int) z[iOffset]] * 4 ^ Sqlite3.sqlite3UpperToLower[(int) z[iOffset + n - 1]] * 3 ^ n) % (int) sbyte.MaxValue;
      for (int index2 = (int) Sqlite3.aHash[index1] - 1; index2 >= 0; index2 = (int) Sqlite3.aNext[index2] - 1)
      {
        if ((int) Sqlite3.aLen[index2] == n && string.Compare(Sqlite3.zText, Sqlite3.aOffset[index2], z, iOffset, n, StringComparison.InvariantCultureIgnoreCase) == 0)
        {
          Sqlite3.testcase<bool>(index2 == 0);
          Sqlite3.testcase<bool>(index2 == 1);
          Sqlite3.testcase<bool>(index2 == 2);
          Sqlite3.testcase<bool>(index2 == 3);
          Sqlite3.testcase<bool>(index2 == 4);
          Sqlite3.testcase<bool>(index2 == 5);
          Sqlite3.testcase<bool>(index2 == 6);
          Sqlite3.testcase<bool>(index2 == 7);
          Sqlite3.testcase<bool>(index2 == 8);
          Sqlite3.testcase<bool>(index2 == 9);
          Sqlite3.testcase<bool>(index2 == 10);
          Sqlite3.testcase<bool>(index2 == 11);
          Sqlite3.testcase<bool>(index2 == 12);
          Sqlite3.testcase<bool>(index2 == 13);
          Sqlite3.testcase<bool>(index2 == 14);
          Sqlite3.testcase<bool>(index2 == 15);
          Sqlite3.testcase<bool>(index2 == 16);
          Sqlite3.testcase<bool>(index2 == 17);
          Sqlite3.testcase<bool>(index2 == 18);
          Sqlite3.testcase<bool>(index2 == 19);
          Sqlite3.testcase<bool>(index2 == 20);
          Sqlite3.testcase<bool>(index2 == 21);
          Sqlite3.testcase<bool>(index2 == 22);
          Sqlite3.testcase<bool>(index2 == 23);
          Sqlite3.testcase<bool>(index2 == 24);
          Sqlite3.testcase<bool>(index2 == 25);
          Sqlite3.testcase<bool>(index2 == 26);
          Sqlite3.testcase<bool>(index2 == 27);
          Sqlite3.testcase<bool>(index2 == 28);
          Sqlite3.testcase<bool>(index2 == 29);
          Sqlite3.testcase<bool>(index2 == 30);
          Sqlite3.testcase<bool>(index2 == 31);
          Sqlite3.testcase<bool>(index2 == 32);
          Sqlite3.testcase<bool>(index2 == 33);
          Sqlite3.testcase<bool>(index2 == 34);
          Sqlite3.testcase<bool>(index2 == 35);
          Sqlite3.testcase<bool>(index2 == 36);
          Sqlite3.testcase<bool>(index2 == 37);
          Sqlite3.testcase<bool>(index2 == 38);
          Sqlite3.testcase<bool>(index2 == 39);
          Sqlite3.testcase<bool>(index2 == 40);
          Sqlite3.testcase<bool>(index2 == 41);
          Sqlite3.testcase<bool>(index2 == 42);
          Sqlite3.testcase<bool>(index2 == 43);
          Sqlite3.testcase<bool>(index2 == 44);
          Sqlite3.testcase<bool>(index2 == 45);
          Sqlite3.testcase<bool>(index2 == 46);
          Sqlite3.testcase<bool>(index2 == 47);
          Sqlite3.testcase<bool>(index2 == 48);
          Sqlite3.testcase<bool>(index2 == 49);
          Sqlite3.testcase<bool>(index2 == 50);
          Sqlite3.testcase<bool>(index2 == 51);
          Sqlite3.testcase<bool>(index2 == 52);
          Sqlite3.testcase<bool>(index2 == 53);
          Sqlite3.testcase<bool>(index2 == 54);
          Sqlite3.testcase<bool>(index2 == 55);
          Sqlite3.testcase<bool>(index2 == 56);
          Sqlite3.testcase<bool>(index2 == 57);
          Sqlite3.testcase<bool>(index2 == 58);
          Sqlite3.testcase<bool>(index2 == 59);
          Sqlite3.testcase<bool>(index2 == 60);
          Sqlite3.testcase<bool>(index2 == 61);
          Sqlite3.testcase<bool>(index2 == 62);
          Sqlite3.testcase<bool>(index2 == 63);
          Sqlite3.testcase<bool>(index2 == 64);
          Sqlite3.testcase<bool>(index2 == 65);
          Sqlite3.testcase<bool>(index2 == 66);
          Sqlite3.testcase<bool>(index2 == 67);
          Sqlite3.testcase<bool>(index2 == 68);
          Sqlite3.testcase<bool>(index2 == 69);
          Sqlite3.testcase<bool>(index2 == 70);
          Sqlite3.testcase<bool>(index2 == 71);
          Sqlite3.testcase<bool>(index2 == 72);
          Sqlite3.testcase<bool>(index2 == 73);
          Sqlite3.testcase<bool>(index2 == 74);
          Sqlite3.testcase<bool>(index2 == 75);
          Sqlite3.testcase<bool>(index2 == 76);
          Sqlite3.testcase<bool>(index2 == 77);
          Sqlite3.testcase<bool>(index2 == 78);
          Sqlite3.testcase<bool>(index2 == 79);
          Sqlite3.testcase<bool>(index2 == 80);
          Sqlite3.testcase<bool>(index2 == 81);
          Sqlite3.testcase<bool>(index2 == 82);
          Sqlite3.testcase<bool>(index2 == 83);
          Sqlite3.testcase<bool>(index2 == 84);
          Sqlite3.testcase<bool>(index2 == 85);
          Sqlite3.testcase<bool>(index2 == 86);
          Sqlite3.testcase<bool>(index2 == 87);
          Sqlite3.testcase<bool>(index2 == 88);
          Sqlite3.testcase<bool>(index2 == 89);
          Sqlite3.testcase<bool>(index2 == 90);
          Sqlite3.testcase<bool>(index2 == 91);
          Sqlite3.testcase<bool>(index2 == 92);
          Sqlite3.testcase<bool>(index2 == 93);
          Sqlite3.testcase<bool>(index2 == 94);
          Sqlite3.testcase<bool>(index2 == 95);
          Sqlite3.testcase<bool>(index2 == 96);
          Sqlite3.testcase<bool>(index2 == 97);
          Sqlite3.testcase<bool>(index2 == 98);
          Sqlite3.testcase<bool>(index2 == 99);
          Sqlite3.testcase<bool>(index2 == 100);
          Sqlite3.testcase<bool>(index2 == 101);
          Sqlite3.testcase<bool>(index2 == 102);
          Sqlite3.testcase<bool>(index2 == 103);
          Sqlite3.testcase<bool>(index2 == 104);
          Sqlite3.testcase<bool>(index2 == 105);
          Sqlite3.testcase<bool>(index2 == 106);
          Sqlite3.testcase<bool>(index2 == 107);
          Sqlite3.testcase<bool>(index2 == 108);
          Sqlite3.testcase<bool>(index2 == 109);
          Sqlite3.testcase<bool>(index2 == 110);
          Sqlite3.testcase<bool>(index2 == 111);
          Sqlite3.testcase<bool>(index2 == 112);
          Sqlite3.testcase<bool>(index2 == 113);
          Sqlite3.testcase<bool>(index2 == 114);
          Sqlite3.testcase<bool>(index2 == 115);
          Sqlite3.testcase<bool>(index2 == 116);
          Sqlite3.testcase<bool>(index2 == 117);
          Sqlite3.testcase<bool>(index2 == 118);
          Sqlite3.testcase<bool>(index2 == 119);
          Sqlite3.testcase<bool>(index2 == 120);
          return (int) Sqlite3.aCode[index2];
        }
      }
      return 26;
    }

    private static int sqlite3KeywordCode(string z, int n) => Sqlite3.keywordCode(z, 0, n);

    public static int exec(
      Sqlite3.sqlite3 db,
      string zSql,
      int NoCallback,
      int NoArgs,
      int NoErrors)
    {
      string pzErrMsg = "";
      return Sqlite3.sqlite3_exec(db, zSql, (Sqlite3.dxCallback) null, (object) null, ref pzErrMsg);
    }

    public static int exec(
      Sqlite3.sqlite3 db,
      string zSql,
      Sqlite3.dxCallback xCallback,
      object pArg,
      int NoErrors)
    {
      string pzErrMsg = "";
      return Sqlite3.sqlite3_exec(db, zSql, xCallback, pArg, ref pzErrMsg);
    }

    public static int exec(
      Sqlite3.sqlite3 db,
      string zSql,
      Sqlite3.dxCallback xCallback,
      object pArg,
      ref string pzErrMsg)
    {
      return Sqlite3.sqlite3_exec(db, zSql, xCallback, pArg, ref pzErrMsg);
    }

    public static int sqlite3_exec(
      Sqlite3.sqlite3 db,
      string zSql,
      int NoCallback,
      int NoArgs,
      int NoErrors)
    {
      string pzErrMsg = "";
      return Sqlite3.sqlite3_exec(db, zSql, (Sqlite3.dxCallback) null, (object) null, ref pzErrMsg);
    }

    public static int sqlite3_exec(
      Sqlite3.sqlite3 db,
      string zSql,
      Sqlite3.dxCallback xCallback,
      object pArg,
      int NoErrors)
    {
      string pzErrMsg = "";
      return Sqlite3.sqlite3_exec(db, zSql, xCallback, pArg, ref pzErrMsg);
    }

    public static int sqlite3_exec(
      Sqlite3.sqlite3 db,
      string zSql,
      Sqlite3.dxCallback xCallback,
      object pArg,
      ref string pzErrMsg)
    {
      int rc = 0;
      string pzTail = "";
      Sqlite3.Vdbe pStmt = (Sqlite3.Vdbe) null;
      string[] pT = (string[]) null;
      int num1 = 0;
      if (!Sqlite3.sqlite3SafetyCheckOk(db))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      if (zSql == null)
        zSql = "";
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      Sqlite3.sqlite3Error(db, 0, 0);
      while ((rc == 0 || rc == 17 && ++num1 < 2) && zSql != "")
      {
        string[] p2 = (string[]) null;
        pStmt = (Sqlite3.Vdbe) null;
        rc = Sqlite3.sqlite3_prepare(db, zSql, -1, ref pStmt, ref pzTail);
        if (rc == 0)
        {
          if (pStmt == null)
          {
            zSql = pzTail;
          }
          else
          {
            int num2 = 0;
            int argc = Sqlite3.sqlite3_column_count(pStmt);
            int num3;
            do
            {
              num3 = Sqlite3.sqlite3_step(pStmt);
              if (xCallback != null && (100 == num3 || 101 == num3 && num2 == 0 && (db.flags & 8192) != 0))
              {
                if (num2 == 0)
                {
                  pT = new string[argc];
                  for (int N = 0; N < argc; ++N)
                    pT[N] = Sqlite3.sqlite3_column_name(pStmt, N);
                  num2 = 1;
                }
                if (num3 == 100)
                {
                  p2 = new string[argc];
                  for (int i = 0; i < argc; ++i)
                  {
                    p2[i] = Sqlite3.sqlite3_column_text(pStmt, i);
                    if (p2[i] == null)
                      Sqlite3.sqlite3_column_type(pStmt, i);
                  }
                }
                if (xCallback(pArg, (long) argc, (object) p2, (object) pT) != 0)
                {
                  rc = 4;
                  Sqlite3.sqlite3VdbeFinalize(ref pStmt);
                  pStmt = (Sqlite3.Vdbe) null;
                  Sqlite3.sqlite3Error(db, 4, 0);
                  goto label_33;
                }
              }
            }
            while (num3 == 100);
            rc = Sqlite3.sqlite3VdbeFinalize(ref pStmt);
            pStmt = (Sqlite3.Vdbe) null;
            if (rc != 17)
            {
              num1 = 0;
              if ((zSql = pzTail) != "")
              {
                int num4 = 0;
                while (num4 < zSql.Length && Sqlite3.sqlite3Isspace(zSql[num4]))
                  ++num4;
                if (num4 != 0)
                  zSql = num4 < zSql.Length ? zSql.Substring(num4) : "";
              }
            }
            Sqlite3.sqlite3DbFree<string[]>(db, ref pT);
            pT = (string[]) null;
          }
        }
      }
label_33:
      if (pStmt != null)
        Sqlite3.sqlite3VdbeFinalize(ref pStmt);
      Sqlite3.sqlite3DbFree<string[]>(db, ref pT);
      int num5 = Sqlite3.sqlite3ApiExit(db, rc);
      if (num5 != 0 && Sqlite3.ALWAYS(num5 == Sqlite3.sqlite3_errcode(db)) && pzErrMsg != null)
        pzErrMsg = Sqlite3.sqlite3_errmsg(db);
      else if (pzErrMsg != "")
        pzErrMsg = "";
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num5;
    }

    private static string sqlite3_errmsg16(Sqlite3.sqlite3 db) => "";

    private static void sqlite3_result_text16(
      Sqlite3.sqlite3_context pCtx,
      string z,
      int n,
      Sqlite3.dxDel xDel)
    {
    }

    public static int sqlite3_get_table(
      Sqlite3.sqlite3 db,
      string zSql,
      ref string[] pazResult,
      ref int pnRow,
      ref int pnColumn,
      ref string pzErrmsg)
    {
      return 0;
    }

    private static int sqlite3LoadExtension(
      Sqlite3.sqlite3 db,
      string zFile,
      string zProc,
      ref string pzErrMsg)
    {
      Sqlite3.sqlite3_vfs pVfs = db.pVfs;
      StringBuilder zBuf = new StringBuilder(100);
      if (pzErrMsg != null)
        pzErrMsg = (string) null;
      if ((db.flags & 536870912) == 0)
      {
        pzErrMsg = Sqlite3.sqlite3_mprintf("not authorized");
        return 1;
      }
      switch (zProc)
      {
        case "":
        case null:
          zProc = "sqlite3_extension_init";
          break;
      }
      IntPtr pHdle = Sqlite3.sqlite3OsDlOpen(pVfs, zFile);
      if (pHdle == IntPtr.Zero)
      {
        pzErrMsg = "";
        Sqlite3.sqlite3_snprintf(300, zBuf, "unable to open shared library [%s]", (object) zFile);
        Sqlite3.sqlite3OsDlError(pVfs, 299, zBuf.ToString());
        return 1;
      }
      Sqlite3.dxInit dxInit = (Sqlite3.dxInit) Sqlite3.sqlite3OsDlSym(pVfs, pHdle, ref zProc);
      Debugger.Break();
      return 0;
    }

    public static int sqlite3_load_extension(
      Sqlite3.sqlite3 db,
      string zFile,
      string zProc,
      ref string pzErrMsg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      int rc = Sqlite3.sqlite3LoadExtension(db, zFile, zProc, ref pzErrMsg);
      int num = Sqlite3.sqlite3ApiExit(db, rc);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num;
    }

    private static void sqlite3CloseExtensions(Sqlite3.sqlite3 db)
    {
      for (int index = 0; index < db.nExtension; ++index)
        Sqlite3.sqlite3OsDlClose(db.pVfs, (IntPtr) db.aExtension[index]);
      Sqlite3.sqlite3DbFree<object[]>(db, ref db.aExtension);
    }

    public static int sqlite3_enable_load_extension(Sqlite3.sqlite3 db, int onoff)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      if (onoff != 0)
        db.flags |= 536870912;
      else
        db.flags &= -536870913;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return 0;
    }

    private static void wsdAutoextInit()
    {
    }

    private static int sqlite3_auto_extension(Sqlite3.dxInit xInit)
    {
      int num = Sqlite3.sqlite3_initialize();
      if (num != 0)
        return num;
      Sqlite3.sqlite3_mutex m = Sqlite3.sqlite3MutexAlloc(2);
      Sqlite3.wsdAutoextInit();
      Sqlite3.sqlite3_mutex_enter(m);
      int index = 0;
      while (index < Sqlite3.wsdAutoext.nExt && !(Sqlite3.wsdAutoext.aExt[index] == xInit))
        ++index;
      Array.Resize<Sqlite3.dxInit>(ref Sqlite3.wsdAutoext.aExt, Sqlite3.wsdAutoext.nExt + 1);
      Sqlite3.wsdAutoext.aExt[Sqlite3.wsdAutoext.nExt] = xInit;
      ++Sqlite3.wsdAutoext.nExt;
      Sqlite3.sqlite3_mutex_leave(m);
      return num;
    }

    private static void sqlite3_reset_auto_extension()
    {
      if (Sqlite3.sqlite3_initialize() != 0)
        return;
      Sqlite3.sqlite3_mutex m = Sqlite3.sqlite3MutexAlloc(2);
      Sqlite3.wsdAutoextInit();
      Sqlite3.sqlite3_mutex_enter(m);
      Sqlite3.sqlite3Autoext.aExt = (Sqlite3.dxInit[]) null;
      Sqlite3.sqlite3Autoext.nExt = 0;
      Sqlite3.sqlite3_mutex_leave(m);
    }

    private static void sqlite3AutoLoadExtensions(Sqlite3.sqlite3 db)
    {
      bool flag = true;
      Sqlite3.wsdAutoextInit();
      if (Sqlite3.sqlite3Autoext.nExt == 0)
        return;
      int index = 0;
      while (flag)
      {
        string str = "";
        Sqlite3.sqlite3_mutex m = Sqlite3.sqlite3MutexAlloc(2);
        Sqlite3.sqlite3_mutex_enter(m);
        Sqlite3.dxInit dxInit;
        if (index >= Sqlite3.wsdAutoext.nExt)
        {
          dxInit = (Sqlite3.dxInit) null;
          flag = false;
        }
        else
          dxInit = Sqlite3.wsdAutoext.aExt[index];
        Sqlite3.sqlite3_mutex_leave(m);
        str = "";
        if (dxInit != null && dxInit(db, ref str, Sqlite3.sqlite3Apis) != 0)
        {
          Sqlite3.sqlite3Error(db, 1, "automatic extension loading failed: %s", (object) str);
          flag = false;
        }
        Sqlite3.sqlite3DbFree(db, ref str);
        ++index;
      }
    }

    public static string sqlite3_libversion() => Sqlite3.sqlite3_version;

    public static string sqlite3_sourceid() => "Ported to C# from 2011-06-23 19:49:22 4374b7e83ea0a3fbc3691f9c0c936272862f32f2";

    public static int sqlite3_libversion_number() => 300700701;

    public static int sqlite3_threadsafe() => 2;

    private static int sqlite3_initialize()
    {
      if (Sqlite3.sqlite3_version == null)
        Sqlite3.sqlite3_version = "3.7.7(C#)";
      if (Sqlite3.sqlite3OpcodeProperty == null)
        Sqlite3.sqlite3OpcodeProperty = Sqlite3.OPFLG_INITIALIZER;
      if (Sqlite3.sqlite3GlobalConfig == null)
        Sqlite3.sqlite3GlobalConfig = Sqlite3.sqlite3Config;
      if (Sqlite3.sqlite3GlobalConfig.isInit != 0)
        return 0;
      int num = Sqlite3.sqlite3MutexInit();
      if (num != 0)
        return num;
      Sqlite3.sqlite3_mutex sqlite3Mutex = Sqlite3.sqlite3MutexAlloc(2);
      lock (sqlite3Mutex)
      {
        Sqlite3.sqlite3GlobalConfig.isMutexInit = 1;
        if (Sqlite3.sqlite3GlobalConfig.isMallocInit == 0)
          num = Sqlite3.sqlite3MallocInit();
        if (num == 0)
        {
          Sqlite3.sqlite3GlobalConfig.isMallocInit = 1;
          if (Sqlite3.sqlite3GlobalConfig.pInitMutex == null)
          {
            Sqlite3.sqlite3GlobalConfig.pInitMutex = Sqlite3.sqlite3MutexAlloc(1);
            if (Sqlite3.sqlite3GlobalConfig.bCoreMutex && Sqlite3.sqlite3GlobalConfig.pInitMutex == null)
              num = 7;
          }
        }
        if (num == 0)
          ++Sqlite3.sqlite3GlobalConfig.nRefInitMutex;
      }
      if (num != 0)
        return num;
      lock (Sqlite3.sqlite3GlobalConfig.pInitMutex)
      {
        if (Sqlite3.sqlite3GlobalConfig.isInit == 0)
        {
          if (Sqlite3.sqlite3GlobalConfig.inProgress == 0)
          {
            Sqlite3.sqlite3GlobalConfig.inProgress = 1;
            Sqlite3.sqlite3GlobalFunctions = new Sqlite3.FuncDefHash();
            Sqlite3.FuncDefHash sqlite3GlobalFunctions = Sqlite3.sqlite3GlobalFunctions;
            Sqlite3.sqlite3RegisterGlobalFunctions();
            if (Sqlite3.sqlite3GlobalConfig.isPCacheInit == 0)
              num = Sqlite3.sqlite3PcacheInitialize();
            if (num == 0)
            {
              Sqlite3.sqlite3GlobalConfig.isPCacheInit = 1;
              num = Sqlite3.sqlite3_os_init();
            }
            if (num == 0)
            {
              Sqlite3.sqlite3PCacheBufferSetup((object) Sqlite3.sqlite3GlobalConfig.pPage, Sqlite3.sqlite3GlobalConfig.szPage, Sqlite3.sqlite3GlobalConfig.nPage);
              Sqlite3.sqlite3GlobalConfig.isInit = 1;
            }
            Sqlite3.sqlite3GlobalConfig.inProgress = 0;
          }
        }
      }
      lock (sqlite3Mutex)
      {
        --Sqlite3.sqlite3GlobalConfig.nRefInitMutex;
        if (Sqlite3.sqlite3GlobalConfig.nRefInitMutex <= 0)
          Sqlite3.sqlite3GlobalConfig.pInitMutex = (Sqlite3.sqlite3_mutex) null;
      }
      return num;
    }

    public static int sqlite3_shutdown()
    {
      if (Sqlite3.sqlite3GlobalConfig.isInit != 0)
      {
        Sqlite3.sqlite3_os_end();
        Sqlite3.sqlite3_reset_auto_extension();
        Sqlite3.sqlite3GlobalConfig.isInit = 0;
      }
      if (Sqlite3.sqlite3GlobalConfig.isPCacheInit != 0)
      {
        Sqlite3.sqlite3PcacheShutdown();
        Sqlite3.sqlite3GlobalConfig.isPCacheInit = 0;
      }
      if (Sqlite3.sqlite3GlobalConfig.isMallocInit != 0)
      {
        Sqlite3.sqlite3MallocEnd();
        Sqlite3.sqlite3GlobalConfig.isMallocInit = 0;
      }
      if (Sqlite3.sqlite3GlobalConfig.isMutexInit != 0)
      {
        Sqlite3.sqlite3MutexEnd();
        Sqlite3.sqlite3GlobalConfig.isMutexInit = 0;
      }
      return 0;
    }

    private static int sqlite3_config(int op, Sqlite3.sqlite3_pcache_methods ap)
    {
      int num = 0;
      if (op == 14)
        Sqlite3.sqlite3GlobalConfig.pcache = ap;
      return num;
    }

    private static int sqlite3_config(int op, ref Sqlite3.sqlite3_pcache_methods ap)
    {
      int num = 0;
      if (op == 15)
      {
        if (Sqlite3.sqlite3GlobalConfig.pcache.xInit == null)
          Sqlite3.sqlite3PCacheSetDefault();
        ap = Sqlite3.sqlite3GlobalConfig.pcache;
      }
      return num;
    }

    private static int sqlite3_config(int op, Sqlite3.sqlite3_mem_methods ap)
    {
      int num = 0;
      if (op == 4)
        Sqlite3.sqlite3GlobalConfig.m = ap;
      return num;
    }

    private static int sqlite3_config(int op, ref Sqlite3.sqlite3_mem_methods ap)
    {
      int num = 0;
      if (op == 5)
        ap = Sqlite3.sqlite3GlobalConfig.m;
      return num;
    }

    private static int sqlite3_config(int op, params object[] ap)
    {
      int num = 0;
      if (Sqlite3.sqlite3GlobalConfig.isInit != 0)
        return Sqlite3.SQLITE_MISUSE_BKPT();
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, (string) null);
        switch (op)
        {
          case 4:
            Debugger.Break();
            Sqlite3.sqlite3GlobalConfig.m = Sqlite3.va_arg(ap, (Sqlite3.sqlite3_mem_methods) null);
            goto case 5;
          case 5:
            Sqlite3.va_end(ref ap);
            break;
          case 6:
            Sqlite3.sqlite3GlobalConfig.pScratch = Sqlite3.va_arg(ap, (byte[][]) null);
            Sqlite3.sqlite3GlobalConfig.szScratch = Sqlite3.va_arg(ap, 0);
            Sqlite3.sqlite3GlobalConfig.nScratch = Sqlite3.va_arg(ap, 0);
            goto case 5;
          case 7:
            Sqlite3.sqlite3GlobalConfig.pPage = Sqlite3.va_arg(ap, (Sqlite3.MemPage) null);
            Sqlite3.sqlite3GlobalConfig.szPage = Sqlite3.va_arg(ap, 0);
            Sqlite3.sqlite3GlobalConfig.nPage = Sqlite3.va_arg(ap, 0);
            goto case 5;
          case 9:
            Sqlite3.sqlite3GlobalConfig.bMemstat = Sqlite3.va_arg(ap, 0) != 0;
            goto case 5;
          case 13:
            Sqlite3.sqlite3GlobalConfig.szLookaside = Sqlite3.va_arg(ap, 0);
            Sqlite3.sqlite3GlobalConfig.nLookaside = Sqlite3.va_arg(ap, 0);
            goto case 5;
          case 14:
            Debugger.Break();
            goto case 5;
          case 15:
            if (Sqlite3.sqlite3GlobalConfig.pcache.xInit == null)
              Sqlite3.sqlite3PCacheSetDefault();
            Debugger.Break();
            goto case 5;
          case 16:
            Sqlite3.sqlite3GlobalConfig.xLog = Sqlite3.va_arg(ap, (Sqlite3.dxLog) null);
            Sqlite3.sqlite3GlobalConfig.pLogArg = Sqlite3.va_arg(ap, (object) null);
            goto case 5;
          case 17:
            Sqlite3.sqlite3GlobalConfig.bOpenUri = Sqlite3.va_arg(ap, true);
            goto case 5;
          default:
            num = 1;
            goto case 5;
        }
      }
      return num;
    }

    private static int setupLookaside(Sqlite3.sqlite3 db, byte[] pBuf, int sz, int cnt) => 0;

    private static Sqlite3.sqlite3_mutex sqlite3_db_mutex(Sqlite3.sqlite3 db) => db.mutex;

    private static int sqlite3_db_config(Sqlite3.sqlite3 db, int op, params object[] ap)
    {
      int num1;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, "");
        if (op == 1001)
        {
          byte[] pBuf = Sqlite3.va_arg(ap, (byte[]) null);
          int sz = Sqlite3.va_arg(ap, 0);
          int cnt = Sqlite3.va_arg(ap, 0);
          num1 = Sqlite3.setupLookaside(db, pBuf, sz, cnt);
        }
        else
        {
          Sqlite3._aFlagOp[] x = new Sqlite3._aFlagOp[2]
          {
            new Sqlite3._aFlagOp(1002, 67108864U),
            new Sqlite3._aFlagOp(1003, 1073741824U)
          };
          num1 = 1;
          for (uint index = 0; (long) index < (long) Sqlite3.ArraySize<Sqlite3._aFlagOp>(x); ++index)
          {
            if (x[(int) index].op == op)
            {
              int num2 = Sqlite3.va_arg(ap, 0);
              int num3 = Sqlite3.va_arg(ap, 0);
              int flags = db.flags;
              if (num2 > 0)
                db.flags |= (int) x[(int) index].mask;
              else if (num2 == 0)
                db.flags = (int) ((long) db.flags & (long) ~x[(int) index].mask);
              if (flags != db.flags)
                Sqlite3.sqlite3ExpirePreparedStatements(db);
              if (num3 != 0)
              {
                int num4 = ((long) db.flags & (long) x[(int) index].mask) != 0L ? 1 : 0;
              }
              num1 = 0;
              break;
            }
          }
        }
        Sqlite3.va_end(ref ap);
      }
      return num1;
    }

    private static bool allSpaces(string z, int iStart, int n)
    {
      while (n > 0 && z[iStart + n - 1] == ' ')
        --n;
      return n == 0;
    }

    private static int binCollFunc(
      object padFlag,
      int nKey1,
      string pKey1,
      int nKey2,
      string pKey2)
    {
      int num1 = nKey1 < nKey2 ? nKey1 : nKey2;
      int num2 = Sqlite3.memcmp(pKey1, pKey2, num1);
      if (num2 == 0 && ((int) padFlag == 0 || !Sqlite3.allSpaces(pKey1, num1, nKey1 - num1) || !Sqlite3.allSpaces(pKey2, num1, nKey2 - num1)))
        num2 = nKey1 - nKey2;
      return num2;
    }

    private static int nocaseCollatingFunc(
      object NotUsed,
      int nKey1,
      string pKey1,
      int nKey2,
      string pKey2)
    {
      int num = Sqlite3.sqlite3StrNICmp(pKey1, pKey2, nKey1 < nKey2 ? nKey1 : nKey2);
      Sqlite3.UNUSED_PARAMETER<object>(NotUsed);
      if (num == 0)
        num = nKey1 - nKey2;
      return num;
    }

    public static long sqlite3_last_insert_rowid(Sqlite3.sqlite3 db) => db.lastRowid;

    public static int sqlite3_changes(Sqlite3.sqlite3 db) => db.nChange;

    public static int sqlite3_total_changes(Sqlite3.sqlite3 db) => db.nTotalChange;

    private static void sqlite3CloseSavepoints(Sqlite3.sqlite3 db)
    {
      while (db.pSavepoint != null)
      {
        Sqlite3.Savepoint pSavepoint = db.pSavepoint;
        db.pSavepoint = pSavepoint.pNext;
        Sqlite3.sqlite3DbFree<Sqlite3.Savepoint>(db, ref pSavepoint);
      }
      db.nSavepoint = 0;
      db.nStatement = 0;
      db.isTransactionSavepoint = (byte) 0;
    }

    private static void functionDestroy(Sqlite3.sqlite3 db, Sqlite3.FuncDef p)
    {
      Sqlite3.FuncDestructor pDestructor = p.pDestructor;
      if (pDestructor == null)
        return;
      --pDestructor.nRef;
      if (pDestructor.nRef != 0)
        return;
      Sqlite3.sqlite3DbFree<Sqlite3.FuncDestructor>(db, ref pDestructor);
    }

    public static int sqlite3_close(Sqlite3.sqlite3 db)
    {
      if (db == null)
        return 0;
      if (!Sqlite3.sqlite3SafetyCheckSickOrOk(db))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      Sqlite3.sqlite3ResetInternalSchema(db, -1);
      Sqlite3.sqlite3VtabRollback(db);
      if (db.pVdbe != null)
      {
        Sqlite3.sqlite3Error(db, 5, "unable to close due to unfinalised statements");
        Sqlite3.sqlite3_mutex_leave(db.mutex);
        return 5;
      }
      for (int index = 0; index < db.nDb; ++index)
      {
        Sqlite3.Btree pBt = db.aDb[index].pBt;
        if (pBt != null && Sqlite3.sqlite3BtreeIsInBackup(pBt))
        {
          Sqlite3.sqlite3Error(db, 5, "unable to close due to unfinished backup operation");
          Sqlite3.sqlite3_mutex_leave(db.mutex);
          return 5;
        }
      }
      Sqlite3.sqlite3CloseSavepoints(db);
      for (int index = 0; index < db.nDb; ++index)
      {
        Sqlite3.Db db1 = db.aDb[index];
        if (db1.pBt != null)
        {
          Sqlite3.sqlite3BtreeClose(ref db1.pBt);
          db1.pBt = (Sqlite3.Btree) null;
          if (index != 1)
            db1.pSchema = (Sqlite3.Schema) null;
        }
      }
      Sqlite3.sqlite3ResetInternalSchema(db, -1);
      Sqlite3.sqlite3ConnectionClosed(db);
      Sqlite3.FuncDef pHash;
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3.FuncDef>(db.aFunc.a); ++index)
      {
        for (Sqlite3.FuncDef pT = db.aFunc.a[index]; pT != null; pT = pHash)
        {
          pHash = pT.pHash;
          Sqlite3.FuncDef pNext;
          for (; pT != null; pT = pNext)
          {
            Sqlite3.functionDestroy(db, pT);
            pNext = pT.pNext;
            Sqlite3.sqlite3DbFree<Sqlite3.FuncDef>(db, ref pT);
          }
        }
      }
      for (Sqlite3.HashElem hashElem = db.aCollSeq.first; hashElem != null; hashElem = hashElem.next)
      {
        Sqlite3.CollSeq[] data = (Sqlite3.CollSeq[]) hashElem.data;
        for (int index = 0; index < 3; ++index)
        {
          if (data[index].xDel != null)
            data[index].xDel(ref data[index].pUser);
        }
        Sqlite3.sqlite3DbFree<Sqlite3.CollSeq[]>(db, ref data);
      }
      Sqlite3.sqlite3HashClear(db.aCollSeq);
      Sqlite3.sqlite3Error(db, 0, 0);
      if (db.pErr != null)
        Sqlite3.sqlite3ValueFree(ref db.pErr);
      Sqlite3.sqlite3CloseExtensions(db);
      db.magic = 1429567792U;
      Sqlite3.sqlite3DbFree<Sqlite3.Schema>(db, ref db.aDb[1].pSchema);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      db.magic = 792472883U;
      Sqlite3.sqlite3_mutex_free(db.mutex);
      return 0;
    }

    private static void sqlite3RollbackAll(Sqlite3.sqlite3 db)
    {
      int num = 0;
      Sqlite3.sqlite3BeginBenignMalloc();
      for (int index = 0; index < db.nDb; ++index)
      {
        if (db.aDb[index].pBt != null)
        {
          if (Sqlite3.sqlite3BtreeIsInTrans(db.aDb[index].pBt))
            num = 1;
          Sqlite3.sqlite3BtreeRollback(db.aDb[index].pBt);
          db.aDb[index].inTrans = (byte) 0;
        }
      }
      Sqlite3.sqlite3VtabRollback(db);
      Sqlite3.sqlite3EndBenignMalloc();
      if ((db.flags & 512) != 0)
      {
        Sqlite3.sqlite3ExpirePreparedStatements(db);
        Sqlite3.sqlite3ResetInternalSchema(db, -1);
      }
      db.nDeferredCons = 0L;
      if (db.xRollbackCallback == null || num == 0 && db.autoCommit != (byte) 0)
        return;
      db.xRollbackCallback(db.pRollbackArg);
    }

    private static string sqlite3ErrStr(int rc)
    {
      string[] strArray = new string[27]
      {
        "not an error",
        "SQL logic error or missing database",
        "",
        "access permission denied",
        "callback requested query abort",
        "database is locked",
        "database table is locked",
        "out of memory",
        "attempt to write a readonly database",
        "interrupted",
        "disk I/O error",
        "database disk image is malformed",
        "unknown operation",
        "database or disk is full",
        "unable to open database file",
        "locking protocol",
        "table contains no data",
        "database schema has changed",
        "string or blob too big",
        "constraint failed",
        "datatype mismatch",
        "library routine called out of sequence",
        "large file support is disabled",
        "authorization denied",
        "auxiliary database format error",
        "bind or column index out of range",
        "file is encrypted or is not a database"
      };
      rc &= (int) byte.MaxValue;
      return Sqlite3.ALWAYS(rc >= 0) && rc < strArray.Length && strArray[rc] != "" ? strArray[rc] : "unknown error";
    }

    private static int sqliteDefaultBusyCallback(object ptr, int count)
    {
      byte[] x = new byte[12]
      {
        (byte) 1,
        (byte) 2,
        (byte) 5,
        (byte) 10,
        (byte) 15,
        (byte) 20,
        (byte) 25,
        (byte) 25,
        (byte) 25,
        (byte) 50,
        (byte) 50,
        (byte) 100
      };
      byte[] numArray = new byte[12]
      {
        (byte) 0,
        (byte) 1,
        (byte) 3,
        (byte) 8,
        (byte) 18,
        (byte) 33,
        (byte) 53,
        (byte) 78,
        (byte) 103,
        (byte) 128,
        (byte) 178,
        (byte) 228
      };
      int num1 = Sqlite3.ArraySize<byte>(x);
      Sqlite3.sqlite3 sqlite3 = (Sqlite3.sqlite3) ptr;
      int busyTimeout = sqlite3.busyTimeout;
      int num2;
      int num3;
      if (count < num1)
      {
        num2 = (int) x[count];
        num3 = (int) numArray[count];
      }
      else
      {
        num2 = (int) x[num1 - 1];
        num3 = (int) numArray[num1 - 1] + num2 * (count - (num1 - 1));
      }
      if (num3 + num2 > busyTimeout)
      {
        num2 = busyTimeout - num3;
        if (num2 <= 0)
          return 0;
      }
      Sqlite3.sqlite3OsSleep(sqlite3.pVfs, num2 * 1000);
      return 1;
    }

    private static int sqlite3InvokeBusyHandler(Sqlite3.BusyHandler p)
    {
      if (Sqlite3.NEVER(p == null) || p.xFunc == null || p.nBusy < 0)
        return 0;
      int num = p.xFunc(p.pArg, p.nBusy);
      if (num == 0)
      {
        p.nBusy = -1;
        return num;
      }
      ++p.nBusy;
      return num;
    }

    private static int sqlite3_busy_handler(Sqlite3.sqlite3 db, Sqlite3.dxBusy xBusy, object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      db.busyHandler.xFunc = xBusy;
      db.busyHandler.pArg = pArg;
      db.busyHandler.nBusy = 0;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return 0;
    }

    private static void sqlite3_progress_handler(
      Sqlite3.sqlite3 db,
      int nOps,
      Sqlite3.dxProgress xProgress,
      object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      if (nOps > 0)
      {
        db.xProgress = xProgress;
        db.nProgressOps = nOps;
        db.pProgressArg = pArg;
      }
      else
      {
        db.xProgress = (Sqlite3.dxProgress) null;
        db.nProgressOps = 0;
        db.pProgressArg = (object) null;
      }
      Sqlite3.sqlite3_mutex_leave(db.mutex);
    }

    public static int sqlite3_busy_timeout(Sqlite3.sqlite3 db, int ms)
    {
      if (ms > 0)
      {
        db.busyTimeout = ms;
        Sqlite3.sqlite3_busy_handler(db, new Sqlite3.dxBusy(Sqlite3.sqliteDefaultBusyCallback), (object) db);
      }
      else
        Sqlite3.sqlite3_busy_handler(db, (Sqlite3.dxBusy) null, (object) null);
      return 0;
    }

    private static void sqlite3_interrupt(Sqlite3.sqlite3 db) => db.u1.isInterrupted = true;

    private static int sqlite3CreateFunc(
      Sqlite3.sqlite3 db,
      string zFunctionName,
      int nArg,
      byte enc,
      object pUserData,
      Sqlite3.dxFunc xFunc,
      Sqlite3.dxStep xStep,
      Sqlite3.dxFinal xFinal,
      Sqlite3.FuncDestructor pDestructor)
    {
      int nName;
      if (zFunctionName == null || xFunc != null && (xFinal != null || xStep != null) || xFunc == null && xFinal != null && xStep == null || xFunc == null && xFinal == null && xStep != null || nArg < -1 || nArg > (int) sbyte.MaxValue || (int) byte.MaxValue < (nName = Sqlite3.sqlite3Strlen30(zFunctionName)))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      enc = (byte) 1;
      Sqlite3.FuncDef function1 = Sqlite3.sqlite3FindFunction(db, zFunctionName, nName, nArg, enc, (byte) 0);
      if (function1 != null && (int) function1.iPrefEnc == (int) enc && (int) function1.nArg == nArg)
      {
        if (db.activeVdbeCnt != 0)
        {
          Sqlite3.sqlite3Error(db, 5, "unable to delete/modify user-function due to active statements");
          return 5;
        }
        Sqlite3.sqlite3ExpirePreparedStatements(db);
      }
      Sqlite3.FuncDef function2 = Sqlite3.sqlite3FindFunction(db, zFunctionName, nName, nArg, enc, (byte) 1);
      Sqlite3.functionDestroy(db, function2);
      if (pDestructor != null)
        ++pDestructor.nRef;
      function2.pDestructor = pDestructor;
      function2.flags = (byte) 0;
      function2.xFunc = xFunc;
      function2.xStep = xStep;
      function2.xFinalize = xFinal;
      function2.pUserData = pUserData;
      function2.nArg = (short) nArg;
      return 0;
    }

    public static int sqlite3_create_function(
      Sqlite3.sqlite3 db,
      string zFunc,
      int nArg,
      byte enc,
      object p,
      Sqlite3.dxFunc xFunc,
      Sqlite3.dxStep xStep,
      Sqlite3.dxFinal xFinal)
    {
      return Sqlite3.sqlite3_create_function_v2(db, zFunc, nArg, (int) enc, p, xFunc, xStep, xFinal, (Sqlite3.dxFDestroy) null);
    }

    private static int sqlite3_create_function_v2(
      Sqlite3.sqlite3 db,
      string zFunc,
      int nArg,
      int enc,
      object p,
      Sqlite3.dxFunc xFunc,
      Sqlite3.dxStep xStep,
      Sqlite3.dxFinal xFinal,
      Sqlite3.dxFDestroy xDestroy)
    {
      Sqlite3.FuncDestructor pT = (Sqlite3.FuncDestructor) null;
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      if (xDestroy != null)
      {
        pT = new Sqlite3.FuncDestructor();
        pT.xDestroy = xDestroy;
        pT.pUserData = p;
      }
      int func = Sqlite3.sqlite3CreateFunc(db, zFunc, nArg, (byte) enc, p, xFunc, xStep, xFinal, pT);
      if (pT != null && pT.nRef == 0)
        Sqlite3.sqlite3DbFree<Sqlite3.FuncDestructor>(db, ref pT);
      int functionV2 = Sqlite3.sqlite3ApiExit(db, func);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return functionV2;
    }

    private static int sqlite3_overload_function(Sqlite3.sqlite3 db, string zName, int nArg)
    {
      int nName = Sqlite3.sqlite3Strlen30(zName);
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      if (Sqlite3.sqlite3FindFunction(db, zName, nName, nArg, (byte) 1, (byte) 0) == null)
        Sqlite3.sqlite3CreateFunc(db, zName, nArg, (byte) 1, (object) 0, new Sqlite3.dxFunc(Sqlite3.sqlite3InvalidFunction), (Sqlite3.dxStep) null, (Sqlite3.dxFinal) null, (Sqlite3.FuncDestructor) null);
      int num = Sqlite3.sqlite3ApiExit(db, 0);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num;
    }

    private static object sqlite3_trace(Sqlite3.sqlite3 db, Sqlite3.dxTrace xTrace, object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      object pTraceArg = db.pTraceArg;
      db.xTrace = xTrace;
      db.pTraceArg = pArg;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return pTraceArg;
    }

    private static object sqlite3_profile(
      Sqlite3.sqlite3 db,
      Sqlite3.dxProfile xProfile,
      object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      object pProfileArg = db.pProfileArg;
      db.xProfile = xProfile;
      db.pProfileArg = pArg;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return pProfileArg;
    }

    private static object sqlite3_commit_hook(
      Sqlite3.sqlite3 db,
      Sqlite3.dxCommitCallback xCallback,
      object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      object pCommitArg = db.pCommitArg;
      db.xCommitCallback = xCallback;
      db.pCommitArg = pArg;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return pCommitArg;
    }

    private static object sqlite3_update_hook(
      Sqlite3.sqlite3 db,
      Sqlite3.dxUpdateCallback xCallback,
      object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      object pUpdateArg = db.pUpdateArg;
      db.xUpdateCallback = xCallback;
      db.pUpdateArg = pArg;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return pUpdateArg;
    }

    private static object sqlite3_rollback_hook(
      Sqlite3.sqlite3 db,
      Sqlite3.dxRollbackCallback xCallback,
      object pArg)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      object pRollbackArg = db.pRollbackArg;
      db.xRollbackCallback = xCallback;
      db.pRollbackArg = pArg;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return pRollbackArg;
    }

    private static int sqlite3_wal_autocheckpoint(Sqlite3.sqlite3 db, int nFrame)
    {
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3>(db);
      Sqlite3.UNUSED_PARAMETER<int>(nFrame);
      return 0;
    }

    private static object sqlite3_wal_hook(
      Sqlite3.sqlite3 db,
      Sqlite3.dxWalCallback xCallback,
      object pArg)
    {
      return (object) null;
    }

    private static int sqlite3_wal_checkpoint_v2(
      Sqlite3.sqlite3 db,
      string zDb,
      int eMode,
      out int pnLog,
      out int pnCkpt)
    {
      pnLog = 0;
      pnCkpt = 0;
      return 0;
    }

    private static int sqlite3_wal_checkpoint(Sqlite3.sqlite3 db, string zDb)
    {
      int num;
      return Sqlite3.sqlite3_wal_checkpoint_v2(db, zDb, Sqlite3.SQLITE_CHECKPOINT_PASSIVE, out num, out num);
    }

    private static bool sqlite3TempInMemory(Sqlite3.sqlite3 db)
    {
      if (Sqlite3.SQLITE_TEMP_STORE == 1)
        return db.temp_store == (byte) 2;
      if (Sqlite3.SQLITE_TEMP_STORE == 2)
        return db.temp_store != (byte) 1;
      if (Sqlite3.SQLITE_TEMP_STORE == 3)
        return true;
      if (Sqlite3.SQLITE_TEMP_STORE >= 1)
      {
        int sqliteTempStore = Sqlite3.SQLITE_TEMP_STORE;
      }
      return false;
    }

    public static string sqlite3_errmsg(Sqlite3.sqlite3 db)
    {
      if (db == null)
        return Sqlite3.sqlite3ErrStr(7);
      if (!Sqlite3.sqlite3SafetyCheckSickOrOk(db))
        return Sqlite3.sqlite3ErrStr(Sqlite3.SQLITE_MISUSE_BKPT());
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      string str = Sqlite3.sqlite3_value_text(db.pErr);
      if (string.IsNullOrEmpty(str))
        str = Sqlite3.sqlite3ErrStr(db.errCode);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return str;
    }

    public static int sqlite3_errcode(Sqlite3.sqlite3 db)
    {
      if (db != null && !Sqlite3.sqlite3SafetyCheckSickOrOk(db))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      return db == null ? 7 : db.errCode & db.errMask;
    }

    private static int sqlite3_extended_errcode(Sqlite3.sqlite3 db)
    {
      if (db != null && !Sqlite3.sqlite3SafetyCheckSickOrOk(db))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      return db == null ? 7 : db.errCode;
    }

    private static int createCollation(
      Sqlite3.sqlite3 db,
      string zName,
      byte enc,
      byte collType,
      object pCtx,
      Sqlite3.dxCompare xCompare,
      Sqlite3.dxDelCollSeq xDel)
    {
      int nKey = Sqlite3.sqlite3Strlen30(zName);
      int enc1 = (int) enc;
      Sqlite3.testcase<bool>(enc1 == 4);
      Sqlite3.testcase<bool>(enc1 == 8);
      if (enc1 == 4 || enc1 == 8)
        enc1 = (int) Sqlite3.SQLITE_UTF16NATIVE;
      if (enc1 < 1 || enc1 > 3)
        return Sqlite3.SQLITE_MISUSE_BKPT();
      Sqlite3.CollSeq collSeq1 = Sqlite3.sqlite3FindCollSeq(db, (byte) enc1, zName, (byte) 0);
      if (collSeq1 != null && collSeq1.xCmp != null)
      {
        if (db.activeVdbeCnt != 0)
        {
          Sqlite3.sqlite3Error(db, 5, "unable to delete/modify collation sequence due to active statements");
          return 5;
        }
        Sqlite3.sqlite3ExpirePreparedStatements(db);
        if (((int) collSeq1.enc & -9) == enc1)
        {
          Sqlite3.CollSeq[] collSeqArray = Sqlite3.sqlite3HashFind<Sqlite3.CollSeq[]>(db.aCollSeq, zName, nKey, (Sqlite3.CollSeq[]) null);
          for (int index = 0; index < 3; ++index)
          {
            Sqlite3.CollSeq collSeq2 = collSeqArray[index];
            if ((int) collSeq2.enc == (int) collSeq1.enc)
            {
              if (collSeq2.xDel != null)
                collSeq2.xDel(ref collSeq2.pUser);
              collSeq2.xCmp = (Sqlite3.dxCompare) null;
            }
          }
        }
      }
      Sqlite3.CollSeq collSeq3 = Sqlite3.sqlite3FindCollSeq(db, (byte) enc1, zName, (byte) 1);
      collSeq3.xCmp = xCompare;
      collSeq3.pUser = pCtx;
      collSeq3.xDel = xDel;
      collSeq3.enc = (byte) (enc1 | (int) enc & 8);
      collSeq3.type = collType;
      Sqlite3.sqlite3Error(db, 0, 0);
      return 0;
    }

    private static int sqlite3_limit(Sqlite3.sqlite3 db, int limitId, int newLimit)
    {
      if (limitId < 0 || limitId >= 11)
        return -1;
      int num = db.aLimit[limitId];
      if (newLimit < 0)
        return num;
      if (newLimit > Sqlite3.aHardLimit[limitId])
        newLimit = Sqlite3.aHardLimit[limitId];
      db.aLimit[limitId] = newLimit;
      return num;
    }

    private static int sqlite3ParseUri(
      string zDefaultVfs,
      string zUri,
      ref int pFlags,
      ref Sqlite3.sqlite3_vfs ppVfs,
      ref string pzFile,
      ref string pzErrMsg)
    {
      int uri = 0;
      int num1 = pFlags;
      string zVfs = zDefaultVfs;
      int length = Sqlite3.sqlite3Strlen30(zUri);
      pzErrMsg = (string) null;
      ppVfs = (Sqlite3.sqlite3_vfs) null;
      StringBuilder z1;
      if (((num1 & 64) != 0 || Sqlite3.sqlite3GlobalConfig.bOpenUri) && length >= 5 && Sqlite3.memcmp(zUri, "file:", 5) == 0)
      {
        int capacity = length + 2;
        num1 |= 64;
        for (int index = 0; index < length; ++index)
          capacity += zUri[index] == '&' ? 1 : 0;
        z1 = new StringBuilder(capacity);
        int index1 = 5;
        if (string.Compare("///", zUri.Substring(5, 3)) == 0)
        {
          index1 = 7;
          if (string.Compare("///", zUri.Substring(7, 3)) == 0)
          {
            ++index1;
            Console.WriteLine("iIn2: {0}", (object) index1);
          }
        }
        else if (string.Compare("//localhost/", zUri.Substring(5, 12)) == 0)
          index1 = 16;
        int num2 = 0;
label_26:
        char ch1;
        while (index1 < length && (ch1 = zUri[index1]) != char.MinValue && ch1 != '#')
        {
          ++index1;
          if (ch1 == '%' && Sqlite3.sqlite3Isxdigit(zUri[index1]) && Sqlite3.sqlite3Isxdigit(zUri[index1 + 1]))
          {
            string str1 = zUri;
            int index2 = index1;
            int num3 = index2 + 1;
            int num4 = Sqlite3.sqlite3HexToInt((int) str1[index2]) << 4;
            string str2 = zUri;
            int index3 = num3;
            index1 = index3 + 1;
            int num5 = Sqlite3.sqlite3HexToInt((int) str2[index3]);
            int num6 = num4 + num5;
            if (num6 == 0)
            {
              while (true)
              {
                char ch2;
                if (index1 < length && (ch2 = zUri[index1]) != char.MinValue && ch2 != '#' && (num2 != 0 || ch2 != '?') && (num2 != 1 || ch2 != '=' && ch2 != '&') && (num2 != 2 || ch2 != '&'))
                  ++index1;
                else
                  goto label_26;
              }
            }
            else
              ch1 = (char) num6;
          }
          else if (num2 == 1 && (ch1 == '&' || ch1 == '='))
          {
            if (z1[z1.Length - 1] == char.MinValue)
            {
              while (true)
              {
                if (zUri[index1] != char.MinValue && zUri[index1] != '#' && zUri[index1 - 1] != '&')
                  ++index1;
                else
                  goto label_26;
              }
            }
            else
            {
              if (ch1 == '&')
                z1.Append(char.MinValue);
              else
                num2 = 2;
              ch1 = char.MinValue;
            }
          }
          else if (num2 == 0 && ch1 == '?' || num2 == 2 && ch1 == '&')
          {
            ch1 = char.MinValue;
            num2 = 1;
          }
          z1.Append(ch1);
        }
        if (num2 == 1)
          z1.Append(char.MinValue);
        z1.Append(char.MinValue);
        z1.Append(char.MinValue);
        string str3;
        int Limit;
        for (string str4 = z1.ToString().Substring(Sqlite3.sqlite3Strlen30(z1) + 1); str4.Length > 0; str4 = str3.Substring(Limit + 1))
        {
          int startIndex = Sqlite3.sqlite3Strlen30(str4);
          str3 = str4.Substring(startIndex);
          Limit = Sqlite3.sqlite3Strlen30(str3);
          if (startIndex == 3 && Sqlite3.memcmp("vfs", str4, 3) == 0)
          {
            zVfs = str3;
          }
          else
          {
            Sqlite3.OpenMode[] openModeArray1 = (Sqlite3.OpenMode[]) null;
            string str5 = "";
            int num7 = 0;
            int num8 = 0;
            if (startIndex == 5 && Sqlite3.memcmp("cache", str4, 5) == 0)
            {
              Sqlite3.OpenMode[] openModeArray2 = new Sqlite3.OpenMode[3]
              {
                new Sqlite3.OpenMode("shared", 131072),
                new Sqlite3.OpenMode("private", 262144),
                new Sqlite3.OpenMode((string) null, 0)
              };
              num7 = 393216;
              openModeArray1 = openModeArray2;
              num8 = num7;
              str5 = "cache";
            }
            if (startIndex == 4 && Sqlite3.memcmp("mode", str4, 4) == 0)
            {
              Sqlite3.OpenMode[] openModeArray3 = new Sqlite3.OpenMode[4]
              {
                new Sqlite3.OpenMode("ro", 1),
                new Sqlite3.OpenMode("rw", 2),
                new Sqlite3.OpenMode("rwc", 6),
                new Sqlite3.OpenMode((string) null, 0)
              };
              num7 = 7;
              openModeArray1 = openModeArray3;
              num8 = num7 & num1;
              str5 = "access";
            }
            if (openModeArray1 != null)
            {
              int num9 = 0;
              for (int index4 = 0; openModeArray1[index4].z != null; ++index4)
              {
                string z2 = openModeArray1[index4].z;
                if (Limit == Sqlite3.sqlite3Strlen30(z2) && Sqlite3.memcmp(str3, z2, Limit) == 0)
                {
                  num9 = openModeArray1[index4].mode;
                  break;
                }
              }
              if (num9 == 0)
              {
                pzErrMsg = Sqlite3.sqlite3_mprintf("no such %s mode: %s", (object) str5, (object) str3);
                uri = 1;
                goto label_52;
              }
              else if (num9 > num8)
              {
                pzErrMsg = Sqlite3.sqlite3_mprintf("%s mode not allowed: %s", (object) str5, (object) str3);
                uri = 3;
                goto label_52;
              }
              else
                num1 = num1 & ~num7 | num9;
            }
          }
        }
      }
      else
      {
        z1 = zUri == null ? new StringBuilder() : new StringBuilder(zUri.Substring(0, length));
        z1.Append(char.MinValue);
        z1.Append(char.MinValue);
      }
      ppVfs = Sqlite3.sqlite3_vfs_find(zVfs);
      if (ppVfs == null)
      {
        pzErrMsg = Sqlite3.sqlite3_mprintf("no such vfs: %s", (object) zVfs);
        uri = 1;
      }
label_52:
      if (uri != 0)
        z1 = (StringBuilder) null;
      pFlags = num1;
      pzFile = z1 == null ? (string) null : z1.ToString().Substring(0, Sqlite3.sqlite3Strlen30(z1.ToString()));
      return uri;
    }

    private static int openDatabase(
      string zFilename,
      out Sqlite3.sqlite3 ppDb,
      int flags,
      string zVfs)
    {
      string pzFile = "";
      string pzErrMsg = "";
      ppDb = (Sqlite3.sqlite3) null;
      int num1 = Sqlite3.sqlite3_initialize();
      if (num1 != 0)
        return num1;
      Sqlite3.testcase<bool>(1 << (flags & 7) == 2);
      Sqlite3.testcase<bool>(1 << (flags & 7) == 4);
      Sqlite3.testcase<bool>(1 << (flags & 7) == 64);
      if ((1 << (flags & 7) & 70) == 0)
        return Sqlite3.SQLITE_MISUSE_BKPT();
      int num2 = Sqlite3.sqlite3GlobalConfig.bCoreMutex ? ((flags & 32768) == 0 ? ((flags & 65536) == 0 ? (Sqlite3.sqlite3GlobalConfig.bFullMutex ? 1 : 0) : 1) : 0) : 0;
      if ((flags & 262144) != 0)
        flags &= -131073;
      else if (Sqlite3.sqlite3GlobalConfig.sharedCacheEnabled)
        flags |= 131072;
      flags &= -655129;
      Sqlite3.sqlite3 db = new Sqlite3.sqlite3();
      if (db != null)
      {
        if (Sqlite3.sqlite3GlobalConfig.bFullMutex && num2 != 0)
        {
          db.mutex = Sqlite3.sqlite3MutexAlloc(1);
          if (db.mutex == null)
            goto label_20;
        }
        Sqlite3.sqlite3_mutex_enter(db.mutex);
        db.errMask = (int) byte.MaxValue;
        db.nDb = 2;
        db.magic = 1077639430U;
        Array.Copy((Array) db.aDbStatic, (Array) db.aDb, db.aDbStatic.Length);
        Buffer.BlockCopy((Array) Sqlite3.aHardLimit, 0, (Array) db.aLimit, 0, Sqlite3.aHardLimit.Length * 4);
        db.autoCommit = (byte) 1;
        db.nextAutovac = -1;
        db.nextPagesize = 0;
        db.flags |= 1207961600;
        if (Sqlite3.SQLITE_DEFAULT_FILE_FORMAT < 4)
          db.flags |= 1048576;
        Sqlite3.sqlite3HashInit(db.aCollSeq);
        Sqlite3.createCollation(db, "BINARY", (byte) 1, (byte) 1, (object) 0, new Sqlite3.dxCompare(Sqlite3.binCollFunc), (Sqlite3.dxDelCollSeq) null);
        Sqlite3.createCollation(db, "BINARY", (byte) 3, (byte) 1, (object) 0, new Sqlite3.dxCompare(Sqlite3.binCollFunc), (Sqlite3.dxDelCollSeq) null);
        Sqlite3.createCollation(db, "BINARY", (byte) 2, (byte) 1, (object) 0, new Sqlite3.dxCompare(Sqlite3.binCollFunc), (Sqlite3.dxDelCollSeq) null);
        Sqlite3.createCollation(db, "RTRIM", (byte) 1, (byte) 0, (object) 1, new Sqlite3.dxCompare(Sqlite3.binCollFunc), (Sqlite3.dxDelCollSeq) null);
        db.pDfltColl = Sqlite3.sqlite3FindCollSeq(db, (byte) 1, "BINARY", (byte) 0);
        Sqlite3.createCollation(db, "NOCASE", (byte) 1, (byte) 2, (object) 0, new Sqlite3.dxCompare(Sqlite3.nocaseCollatingFunc), (Sqlite3.dxDelCollSeq) null);
        db.openFlags = flags;
        int uri = Sqlite3.sqlite3ParseUri(zVfs, zFilename, ref flags, ref db.pVfs, ref pzFile, ref pzErrMsg);
        if (uri != 0)
        {
          Sqlite3.sqlite3Error(db, uri, pzErrMsg.Length > 0 ? "%s" : "", (object) pzErrMsg);
        }
        else
        {
          int err_code1 = Sqlite3.sqlite3BtreeOpen(db.pVfs, pzFile, db, ref db.aDb[0].pBt, 0, flags | 256);
          switch (err_code1)
          {
            case 0:
              db.aDb[0].pSchema = Sqlite3.sqlite3SchemaGet(db, db.aDb[0].pBt);
              db.aDb[1].pSchema = Sqlite3.sqlite3SchemaGet(db, (Sqlite3.Btree) null);
              db.aDb[0].zName = "main";
              db.aDb[0].safety_level = (byte) 3;
              db.aDb[1].zName = "temp";
              db.aDb[1].safety_level = (byte) 1;
              db.magic = 271165079U;
              Sqlite3.sqlite3Error(db, 0, 0);
              Sqlite3.sqlite3RegisterBuiltinFunctions(db);
              Sqlite3.sqlite3AutoLoadExtensions(db);
              int err_code2 = Sqlite3.sqlite3_errcode(db);
              if (err_code2 == 0)
              {
                Sqlite3.sqlite3Error(db, err_code2, 0);
                Sqlite3.setupLookaside(db, (byte[]) null, Sqlite3.sqlite3GlobalConfig.szLookaside, Sqlite3.sqlite3GlobalConfig.nLookaside);
                Sqlite3.sqlite3_wal_autocheckpoint(db, 1000);
                goto label_20;
              }
              else
                goto label_20;
            case 3082:
              err_code1 = 7;
              break;
          }
          Sqlite3.sqlite3Error(db, err_code1, 0);
        }
      }
label_20:
      if (db != null)
        Sqlite3.sqlite3_mutex_leave(db.mutex);
      int rc = Sqlite3.sqlite3_errcode(db);
      switch (rc)
      {
        case 0:
          ppDb = db;
          return Sqlite3.sqlite3ApiExit(0, rc);
        case 7:
          Sqlite3.sqlite3_close(db);
          db = (Sqlite3.sqlite3) null;
          goto case 0;
        default:
          db.magic = 997659280U;
          goto case 0;
      }
    }

    public static int sqlite3_open(string zFilename, out Sqlite3.sqlite3 ppDb) => Sqlite3.openDatabase(zFilename, out ppDb, 6, (string) null);

    public static int sqlite3_open_v2(
      string filename,
      out Sqlite3.sqlite3 ppDb,
      int flags,
      string zVfs)
    {
      return Sqlite3.openDatabase(filename, out ppDb, flags, zVfs);
    }

    private static int sqlite3_create_collation(
      Sqlite3.sqlite3 db,
      string zName,
      int enc,
      object pCtx,
      Sqlite3.dxCompare xCompare)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      int collation1 = Sqlite3.createCollation(db, zName, (byte) enc, (byte) 0, pCtx, xCompare, (Sqlite3.dxDelCollSeq) null);
      int collation2 = Sqlite3.sqlite3ApiExit(db, collation1);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return collation2;
    }

    private static int sqlite3_create_collation_v2(
      Sqlite3.sqlite3 db,
      string zName,
      int enc,
      object pCtx,
      Sqlite3.dxCompare xCompare,
      Sqlite3.dxDelCollSeq xDel)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      int collation = Sqlite3.createCollation(db, zName, (byte) enc, (byte) 0, pCtx, xCompare, xDel);
      int collationV2 = Sqlite3.sqlite3ApiExit(db, collation);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return collationV2;
    }

    private static int sqlite3_collation_needed(
      Sqlite3.sqlite3 db,
      object pCollNeededArg,
      Sqlite3.dxCollNeeded xCollNeeded)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      db.xCollNeeded = xCollNeeded;
      db.xCollNeeded16 = (Sqlite3.dxCollNeeded) null;
      db.pCollNeededArg = pCollNeededArg;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return 0;
    }

    private static byte sqlite3_get_autocommit(Sqlite3.sqlite3 db) => db.autoCommit;

    private static int sqlite3CorruptError(int lineno)
    {
      Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
      Sqlite3.sqlite3_log(11, "database corruption at line %d of [%.10s]", (object) lineno, (object) (20.ToString() + Sqlite3.sqlite3_sourceid()));
      return 11;
    }

    private static int sqlite3MisuseError(int lineno)
    {
      Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
      Sqlite3.sqlite3_log(21, "misuse at line %d of [%.10s]", (object) lineno, (object) (20.ToString() + Sqlite3.sqlite3_sourceid()));
      return 21;
    }

    private static int sqlite3CantopenError(int lineno)
    {
      Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
      Sqlite3.sqlite3_log(14, "cannot open file at line %d of [%.10s]", (object) lineno, (object) (20.ToString() + Sqlite3.sqlite3_sourceid()));
      return 14;
    }

    public static int sqlite3_sleep(int ms)
    {
      Sqlite3.sqlite3_vfs pVfs = Sqlite3.sqlite3_vfs_find((string) null);
      return pVfs == null ? 0 : Sqlite3.sqlite3OsSleep(pVfs, 1000 * ms) / 1000;
    }

    private static int sqlite3_extended_result_codes(Sqlite3.sqlite3 db, bool onoff)
    {
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      db.errMask = onoff ? -1 : (int) byte.MaxValue;
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return 0;
    }

    private static int sqlite3_file_control(
      Sqlite3.sqlite3 db,
      string zDbName,
      int op,
      ref long pArg)
    {
      int num = 1;
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      int index;
      if (zDbName == null)
      {
        index = 0;
      }
      else
      {
        index = 0;
        while (index < db.nDb && !(db.aDb[index].zName == zDbName))
          ++index;
      }
      if (index < db.nDb)
      {
        Sqlite3.Btree pBt = db.aDb[index].pBt;
        if (pBt != null)
        {
          Sqlite3.sqlite3BtreeEnter(pBt);
          Sqlite3.sqlite3_file id = Sqlite3.sqlite3PagerFile(Sqlite3.sqlite3BtreePager(pBt));
          if (op == 7)
          {
            pArg = -1L;
            num = 0;
          }
          else
            num = id.pMethods == null ? 12 : Sqlite3.sqlite3OsFileControl(id, (uint) op, ref pArg);
          Sqlite3.sqlite3BtreeLeave(pBt);
        }
      }
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num;
    }

    private static int sqlite3_test_control(int op, params object[] ap)
    {
      int num1 = 0;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, nameof (op));
        switch (op)
        {
          case 5:
            Sqlite3.sqlite3PrngSaveState();
            break;
          case 6:
            Sqlite3.sqlite3PrngRestoreState();
            break;
          case 7:
            Sqlite3.sqlite3PrngResetState();
            break;
          case 8:
            num1 = Sqlite3.sqlite3BitvecBuiltinTest((uint) Sqlite3.va_arg(ap, 0), Sqlite3.va_arg(ap, (int[]) null));
            break;
          case 10:
            Sqlite3.sqlite3BenignMallocHooks(Sqlite3.va_arg(ap, (Sqlite3.void_function) null), Sqlite3.va_arg(ap, (Sqlite3.void_function) null));
            break;
          case 11:
            num1 = Sqlite3.PENDING_BYTE;
            uint num2 = Sqlite3.va_arg(ap, 0U);
            if (num2 != 0U)
            {
              if ((long) Sqlite3.sqlite3PendingByte != (long) num2)
                Sqlite3.sqlite3PendingByte = (int) num2;
              Sqlite3.PENDING_BYTE = Sqlite3.sqlite3PendingByte;
              break;
            }
            break;
          case 12:
            num1 = 0;
            break;
          case 13:
            num1 = Sqlite3.ALWAYS(Sqlite3.va_arg(ap, 0));
            break;
          case 14:
            Sqlite3.sqlite3 sqlite3_1 = Sqlite3.va_arg(ap, (Sqlite3.sqlite3) null);
            int nReserve = Sqlite3.va_arg(ap, 0);
            Sqlite3.sqlite3_mutex_enter(sqlite3_1.mutex);
            Sqlite3.sqlite3BtreeSetPageSize(sqlite3_1.aDb[0].pBt, 0, nReserve, 0);
            Sqlite3.sqlite3_mutex_leave(sqlite3_1.mutex);
            break;
          case 15:
            Sqlite3.sqlite3 sqlite3_2 = Sqlite3.va_arg(ap, (Sqlite3.sqlite3) null);
            int num3 = Sqlite3.va_arg(ap, 0);
            sqlite3_2.flags = num3 & (int) byte.MaxValue | sqlite3_2.flags & -256;
            break;
          case 16:
            string z = Sqlite3.va_arg(ap, "char*");
            num1 = Sqlite3.sqlite3KeywordCode(z, Sqlite3.sqlite3Strlen30(z)) != 26 ? 121 : 0;
            break;
          case 17:
            num1 = -1;
            break;
          case 19:
            Sqlite3.sqlite3GlobalConfig.bLocaltimeFault = Sqlite3.va_arg(ap, true);
            break;
        }
        Sqlite3.va_end(ref ap);
      }
      return num1;
    }

    private static string sqlite3_uri_parameter(string zFilename, string zParam)
    {
      Debugger.Break();
      return (string) null;
    }

    private static int sqlite3_release_memory(int n)
    {
      Sqlite3.UNUSED_PARAMETER<int>(n);
      return 0;
    }

    private static void softHeapLimitEnforcer(object NotUsed, long NotUsed2, int allocSize)
    {
      Sqlite3.UNUSED_PARAMETER2<object, long>(NotUsed, NotUsed2);
      Sqlite3.sqlite3_release_memory(allocSize);
    }

    private static long sqlite3_soft_heap_limit64(long n)
    {
      Sqlite3.sqlite3_initialize();
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
      long alarmThreshold = Sqlite3.mem0.alarmThreshold;
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      if (n < 0L)
        return alarmThreshold;
      if (n > 0L)
        Sqlite3.sqlite3MemoryAlarm(new Sqlite3.dxalarmCallback(Sqlite3.softHeapLimitEnforcer), (object) 0, n);
      else
        Sqlite3.sqlite3MemoryAlarm((Sqlite3.dxalarmCallback) null, (object) 0, 0L);
      long num = Sqlite3.sqlite3_memory_used() - n;
      if (num > 0L)
        Sqlite3.sqlite3_release_memory((int) (num & (long) int.MaxValue));
      return alarmThreshold;
    }

    private void sqlite3_soft_heap_limit(int n)
    {
      if (n < 0)
        n = 0;
      Sqlite3.sqlite3_soft_heap_limit64((long) n);
    }

    private static int sqlite3MallocInit()
    {
      if (Sqlite3.sqlite3GlobalConfig.m.xMalloc == null)
        Sqlite3.sqlite3MemSetDefault();
      Sqlite3.mem0 = new Sqlite3.Mem0Global(0, 0, (Sqlite3.sqlite3_mutex) null, 0L, (Sqlite3.dxalarmCallback) null, (object) null, 1, 1, 8, 8);
      if (Sqlite3.sqlite3GlobalConfig.bCoreMutex)
        Sqlite3.mem0.mutex = Sqlite3.sqlite3MutexAlloc(3);
      if (Sqlite3.sqlite3GlobalConfig.pScratch != null && Sqlite3.sqlite3GlobalConfig.szScratch >= 100 && Sqlite3.sqlite3GlobalConfig.nScratch >= 0)
      {
        Sqlite3.sqlite3GlobalConfig.szScratch = Sqlite3.ROUNDDOWN8(Sqlite3.sqlite3GlobalConfig.szScratch - 4);
      }
      else
      {
        Sqlite3.sqlite3GlobalConfig.pScratch = (byte[][]) null;
        Sqlite3.sqlite3GlobalConfig.szScratch = 0;
      }
      if (Sqlite3.sqlite3GlobalConfig.pPage == null || Sqlite3.sqlite3GlobalConfig.szPage < 512 || Sqlite3.sqlite3GlobalConfig.nPage < 1)
      {
        Sqlite3.sqlite3GlobalConfig.pPage = (Sqlite3.MemPage) null;
        Sqlite3.sqlite3GlobalConfig.szPage = 0;
        Sqlite3.sqlite3GlobalConfig.nPage = 0;
      }
      return Sqlite3.sqlite3GlobalConfig.m.xInit(Sqlite3.sqlite3GlobalConfig.m.pAppData);
    }

    private static bool sqlite3HeapNearlyFull() => Sqlite3.mem0.nearlyFull;

    private static void sqlite3MallocEnd()
    {
      if (Sqlite3.sqlite3GlobalConfig.m.xShutdown != null)
        Sqlite3.sqlite3GlobalConfig.m.xShutdown(Sqlite3.sqlite3GlobalConfig.m.pAppData);
      Sqlite3.mem0 = new Sqlite3.Mem0Global();
    }

    private static long sqlite3_memory_used()
    {
      int pCurrent = 0;
      int pHighwater = 0;
      Sqlite3.sqlite3_status(0, ref pCurrent, ref pHighwater, 0);
      return (long) pCurrent;
    }

    private static long sqlite3_memory_highwater(int resetFlag)
    {
      int pCurrent = 0;
      int pHighwater = 0;
      Sqlite3.sqlite3_status(0, ref pCurrent, ref pHighwater, resetFlag);
      return (long) pHighwater;
    }

    private static int sqlite3MemoryAlarm(
      Sqlite3.dxalarmCallback xCallback,
      object pArg,
      long iThreshold)
    {
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
      Sqlite3.mem0.alarmCallback = xCallback;
      Sqlite3.mem0.alarmArg = pArg;
      Sqlite3.mem0.alarmThreshold = iThreshold;
      int num = Sqlite3.sqlite3StatusValue(0);
      Sqlite3.mem0.nearlyFull = iThreshold > 0L && iThreshold <= (long) num;
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      return 0;
    }

    private static void sqlite3MallocAlarm(int nByte)
    {
      if (Sqlite3.mem0.alarmCallback == null)
        return;
      Sqlite3.dxalarmCallback alarmCallback = Sqlite3.mem0.alarmCallback;
      long iNotUsed = (long) Sqlite3.sqlite3StatusValue(0);
      object alarmArg = Sqlite3.mem0.alarmArg;
      Sqlite3.mem0.alarmCallback = (Sqlite3.dxalarmCallback) null;
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      alarmCallback(alarmArg, iNotUsed, nByte);
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
      Sqlite3.mem0.alarmCallback = alarmCallback;
      Sqlite3.mem0.alarmArg = alarmArg;
    }

    private static int mallocWithAlarm(int n, ref int[] pp)
    {
      int num = Sqlite3.sqlite3GlobalConfig.m.xRoundup(n);
      Sqlite3.sqlite3StatusSet(5, n);
      if (Sqlite3.mem0.alarmCallback != null)
      {
        if ((long) Sqlite3.sqlite3StatusValue(0) >= Sqlite3.mem0.alarmThreshold - (long) num)
        {
          Sqlite3.mem0.nearlyFull = true;
          Sqlite3.sqlite3MallocAlarm(num);
        }
        else
          Sqlite3.mem0.nearlyFull = false;
      }
      int[] p = Sqlite3.sqlite3GlobalConfig.m.xMallocInt(num);
      if (p != null)
      {
        num = Sqlite3.sqlite3MallocSize(p);
        Sqlite3.sqlite3StatusAdd(0, num);
      }
      pp = p;
      return num;
    }

    private static int mallocWithAlarm(int n, ref byte[] pp)
    {
      int num = Sqlite3.sqlite3GlobalConfig.m.xRoundup(n);
      Sqlite3.sqlite3StatusSet(5, n);
      if (Sqlite3.mem0.alarmCallback != null && (long) (Sqlite3.sqlite3StatusValue(0) + num) >= Sqlite3.mem0.alarmThreshold)
        Sqlite3.sqlite3MallocAlarm(num);
      byte[] p = Sqlite3.sqlite3GlobalConfig.m.xMalloc(num);
      if (p == null && Sqlite3.mem0.alarmCallback != null)
      {
        Sqlite3.sqlite3MallocAlarm(num);
        p = Sqlite3.sqlite3GlobalConfig.m.xMalloc(num);
      }
      if (p != null)
      {
        num = Sqlite3.sqlite3MallocSize(p);
        Sqlite3.sqlite3StatusAdd(0, num);
        Sqlite3.sqlite3StatusAdd(9, 1);
      }
      pp = p;
      return num;
    }

    private static Sqlite3.Mem sqlite3Malloc(Sqlite3.Mem pMem) => Sqlite3.sqlite3GlobalConfig.m.xMallocMem(pMem);

    private static int[] sqlite3Malloc(int[] pInt, uint n) => Sqlite3.sqlite3Malloc(pInt, (int) n);

    private static int[] sqlite3Malloc(int[] pInt, int n)
    {
      int[] pp = (int[]) null;
      if (n < 0 || n >= 2147483392)
        pp = (int[]) null;
      else if (Sqlite3.sqlite3GlobalConfig.bMemstat)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        Sqlite3.mallocWithAlarm(n, ref pp);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      }
      else
        pp = Sqlite3.sqlite3GlobalConfig.m.xMallocInt(n);
      return pp;
    }

    private static byte[] sqlite3Malloc(uint n) => Sqlite3.sqlite3Malloc((int) n);

    private static byte[] sqlite3Malloc(int n)
    {
      byte[] pp = (byte[]) null;
      if (n < 0 || n >= 2147483392)
        pp = (byte[]) null;
      else if (Sqlite3.sqlite3GlobalConfig.bMemstat)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        Sqlite3.mallocWithAlarm(n, ref pp);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      }
      else
        pp = Sqlite3.sqlite3GlobalConfig.m.xMalloc(n);
      return pp;
    }

    private static byte[] sqlite3_malloc(int n) => Sqlite3.sqlite3_initialize() != 0 ? (byte[]) null : Sqlite3.sqlite3Malloc(n);

    private static byte[][] sqlite3ScratchMalloc(byte[][] apCell, int n)
    {
      apCell = Sqlite3.sqlite3GlobalConfig.pScratch2;
      if (apCell == null)
        apCell = new byte[n < 200 ? 200 : n][];
      else if (apCell.Length < n)
        Array.Resize<byte[]>(ref apCell, n);
      Sqlite3.sqlite3GlobalConfig.pScratch2 = (byte[][]) null;
      return apCell;
    }

    private static byte[] sqlite3ScratchMalloc(int n)
    {
      byte[] pp = (byte[]) null;
      if (Sqlite3.sqlite3GlobalConfig.szScratch >= n)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        if (Sqlite3.mem0.nScratchFree == 0)
        {
          Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
        }
        else
        {
          for (int index = 0; index < Sqlite3.sqlite3GlobalConfig.pScratch.Length; ++index)
          {
            if (Sqlite3.sqlite3GlobalConfig.pScratch[index] != null && Sqlite3.sqlite3GlobalConfig.pScratch[index].Length >= n)
            {
              pp = Sqlite3.sqlite3GlobalConfig.pScratch[index];
              Sqlite3.sqlite3GlobalConfig.pScratch[index] = (byte[]) null;
              break;
            }
          }
          Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
          if (pp != null)
          {
            Sqlite3.sqlite3StatusAdd(3, 1);
            Sqlite3.sqlite3StatusSet(8, n);
            return pp;
          }
        }
      }
      if (Sqlite3.sqlite3GlobalConfig.bMemstat)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        Sqlite3.sqlite3StatusSet(8, n);
        n = Sqlite3.mallocWithAlarm(n, ref pp);
        if (pp != null)
          Sqlite3.sqlite3StatusAdd(4, n);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      }
      else
        pp = Sqlite3.sqlite3GlobalConfig.m.xMalloc(n);
      Sqlite3.sqlite3MemdebugSetType<byte[]>(pp, 4);
      return pp;
    }

    private static void sqlite3ScratchFree(byte[][] p)
    {
      if (p == null)
        return;
      if (Sqlite3.sqlite3GlobalConfig.pScratch2 == null || Sqlite3.sqlite3GlobalConfig.pScratch2.Length < p.Length)
      {
        Sqlite3.sqlite3MemdebugSetType<byte[][]>(p, 1);
        if (Sqlite3.sqlite3GlobalConfig.bMemstat)
        {
          int num = Sqlite3.sqlite3MallocSize(p);
          Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
          Sqlite3.sqlite3StatusAdd(4, -num);
          Sqlite3.sqlite3StatusAdd(0, -num);
          Sqlite3.sqlite3StatusAdd(9, -1);
          Sqlite3.sqlite3GlobalConfig.pScratch2 = p;
          Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
        }
        else
          Sqlite3.sqlite3GlobalConfig.pScratch2 = p;
      }
      p = (byte[][]) null;
    }

    private static bool isLookaside(Sqlite3.sqlite3 db, object p) => false;

    private static int sqlite3MallocSize(byte[][] p) => p.Length * p[0].Length;

    private static int sqlite3MallocSize(int[] p) => p.Length;

    private static int sqlite3MallocSize(byte[] p) => Sqlite3.sqlite3GlobalConfig.m.xSize(p);

    private static int sqlite3DbMallocSize(Sqlite3.sqlite3 db, byte[] p) => db != null && Sqlite3.isLookaside(db, (object) p) ? db.lookaside.sz : Sqlite3.sqlite3GlobalConfig.m.xSize(p);

    private static void sqlite3_free(ref byte[] p)
    {
      if (p == null)
        return;
      if (Sqlite3.sqlite3GlobalConfig.bMemstat)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        Sqlite3.sqlite3StatusAdd(0, -Sqlite3.sqlite3MallocSize(p));
        Sqlite3.sqlite3StatusAdd(9, -1);
        Sqlite3.sqlite3GlobalConfig.m.xFree(ref p);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      }
      else
        Sqlite3.sqlite3GlobalConfig.m.xFree(ref p);
      p = (byte[]) null;
    }

    private static void sqlite3_free(ref Sqlite3.Mem p)
    {
      if (p == null)
        return;
      if (Sqlite3.sqlite3GlobalConfig.bMemstat)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        Sqlite3.sqlite3GlobalConfig.m.xFreeMem(ref p);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      }
      else
        Sqlite3.sqlite3GlobalConfig.m.xFreeMem(ref p);
      p = (Sqlite3.Mem) null;
    }

    private static void sqlite3DbFree(Sqlite3.sqlite3 db, ref byte[] p)
    {
    }

    private static byte[] sqlite3Realloc(byte[] pOld, int nBytes)
    {
      if (pOld == null)
      {
        pOld = Sqlite3.sqlite3Malloc(nBytes);
        return pOld;
      }
      if (nBytes < 0)
      {
        Sqlite3.sqlite3_free(ref pOld);
        return (byte[]) null;
      }
      if (nBytes >= 2147483392)
        return (byte[]) null;
      int num = Sqlite3.sqlite3MallocSize(pOld);
      int nSize = Sqlite3.sqlite3GlobalConfig.m.xRoundup(nBytes);
      byte[] p;
      if (num == nSize)
        p = pOld;
      else if (Sqlite3.sqlite3GlobalConfig.bMemstat)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mem0.mutex);
        Sqlite3.sqlite3StatusSet(5, nBytes);
        int nByte = nSize - num;
        if ((long) Sqlite3.sqlite3StatusValue(0) >= Sqlite3.mem0.alarmThreshold - (long) nByte)
          Sqlite3.sqlite3MallocAlarm(nByte);
        p = Sqlite3.sqlite3GlobalConfig.m.xRealloc(pOld, nSize);
        if (p == null && Sqlite3.mem0.alarmCallback != null)
        {
          Sqlite3.sqlite3MallocAlarm(nBytes);
          p = Sqlite3.sqlite3GlobalConfig.m.xRealloc(pOld, nSize);
        }
        if (p != null)
          Sqlite3.sqlite3StatusAdd(0, Sqlite3.sqlite3MallocSize(p) - num);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mem0.mutex);
      }
      else
        p = Sqlite3.sqlite3GlobalConfig.m.xRealloc(pOld, nSize);
      return p;
    }

    private static byte[] sqlite3_realloc(byte[] pOld, int n) => Sqlite3.sqlite3_initialize() != 0 ? (byte[]) null : Sqlite3.sqlite3Realloc(pOld, n);

    private static byte[] sqlite3MallocZero(int n)
    {
      byte[] numArray = Sqlite3.sqlite3Malloc(n);
      if (numArray != null)
        Array.Clear((Array) numArray, 0, n);
      return numArray;
    }

    private static Sqlite3.Mem sqlite3DbMallocZero(Sqlite3.sqlite3 db, Sqlite3.Mem m) => new Sqlite3.Mem();

    private static byte[] sqlite3DbMallocZero(Sqlite3.sqlite3 db, int n)
    {
      byte[] numArray = Sqlite3.sqlite3DbMallocRaw(db, n);
      if (numArray != null)
        Array.Clear((Array) numArray, 0, n);
      return numArray;
    }

    private static byte[] sqlite3DbMallocRaw(Sqlite3.sqlite3 db, int n) => Sqlite3.sqlite3Malloc(n);

    private static byte[] sqlite3DbRealloc(Sqlite3.sqlite3 db, byte[] p, int n)
    {
      if (p == null)
        return Sqlite3.sqlite3DbMallocRaw(db, n);
      Sqlite3.sqlite3MemdebugSetType<byte[]>(p, 1);
      return Sqlite3.sqlite3_realloc(p, n);
    }

    private static byte[] sqlite3DbReallocOrFree(Sqlite3.sqlite3 db, byte[] p, int n)
    {
      byte[] numArray = Sqlite3.sqlite3DbRealloc(db, p, n);
      if (numArray == null)
        Sqlite3.sqlite3DbFree(db, ref p);
      return numArray;
    }

    private static void sqlite3SetString(
      ref string pz,
      Sqlite3.sqlite3 db,
      string zFormat,
      params string[] ap)
    {
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start((object[]) ap, zFormat);
        string str = Sqlite3.sqlite3VMPrintf(db, zFormat, (object[]) ap);
        Sqlite3.va_end(ref ap);
        Sqlite3.sqlite3DbFree(db, ref pz);
        pz = str;
      }
    }

    private static int sqlite3ApiExit(int zero, int rc) => Sqlite3.sqlite3ApiExit((Sqlite3.sqlite3) null, rc);

    private static int sqlite3ApiExit(Sqlite3.sqlite3 db, int rc)
    {
      if (rc == 3082)
      {
        Sqlite3.sqlite3Error(db, 7, "");
        rc = 7;
      }
      return rc & (db != null ? db.errMask : (int) byte.MaxValue);
    }

    private static int MIN(int x, int y) => x >= y ? y : x;

    private static int MIN(int x, uint y) => (long) x >= (long) y ? (int) y : x;

    private static int memjrnlRead(Sqlite3.sqlite3_file pJfd, byte[] zBuf, int iAmt, long iOfst)
    {
      Sqlite3.sqlite3_file sqlite3File = pJfd;
      byte[] dst = zBuf;
      int x = iAmt;
      Sqlite3.FileChunk fileChunk;
      if (sqlite3File.readpoint.iOffset != iOfst || iOfst == 0L)
      {
        int num = 0;
        for (fileChunk = sqlite3File.pFirst; Sqlite3.ALWAYS(fileChunk != null) && (long) (num + 4096) <= iOfst; fileChunk = fileChunk.pNext)
          num += 4096;
      }
      else
        fileChunk = sqlite3File.readpoint.pChunk;
      int srcOffset = (int) (iOfst % 4096L);
      int dstOffset = 0;
      do
      {
        int num = 4096 - srcOffset;
        int count = Sqlite3.MIN(x, 4096 - srcOffset);
        Buffer.BlockCopy((Array) fileChunk.zChunk, srcOffset, (Array) dst, dstOffset, count);
        dstOffset += count;
        x -= num;
        srcOffset = 0;
      }
      while (x >= 0 && (fileChunk = fileChunk.pNext) != null && x > 0);
      sqlite3File.readpoint.iOffset = (long) (int) (iOfst + (long) iAmt);
      sqlite3File.readpoint.pChunk = fileChunk;
      return 0;
    }

    private static int memjrnlWrite(Sqlite3.sqlite3_file pJfd, byte[] zBuf, int iAmt, long iOfst)
    {
      Sqlite3.sqlite3_file sqlite3File = pJfd;
      int x = iAmt;
      byte[] src = zBuf;
      int srcOffset = 0;
      Sqlite3.UNUSED_PARAMETER<long>(iOfst);
      while (x > 0)
      {
        Sqlite3.FileChunk pChunk = sqlite3File.endpoint.pChunk;
        int dstOffset = (int) (sqlite3File.endpoint.iOffset % 4096L);
        int count = Sqlite3.MIN(x, 4096 - dstOffset);
        if (dstOffset == 0)
        {
          Sqlite3.FileChunk fileChunk = new Sqlite3.FileChunk();
          if (fileChunk == null)
            return 3082;
          fileChunk.pNext = (Sqlite3.FileChunk) null;
          if (pChunk != null)
            pChunk.pNext = fileChunk;
          else
            sqlite3File.pFirst = fileChunk;
          sqlite3File.endpoint.pChunk = fileChunk;
        }
        Buffer.BlockCopy((Array) src, srcOffset, (Array) sqlite3File.endpoint.pChunk.zChunk, dstOffset, count);
        srcOffset += count;
        x -= count;
        sqlite3File.endpoint.iOffset += (long) count;
      }
      return 0;
    }

    private static int memjrnlTruncate(Sqlite3.sqlite3_file pJfd, long size)
    {
      Sqlite3.sqlite3_file sqlite3File = pJfd;
      Sqlite3.UNUSED_PARAMETER<long>(size);
      Sqlite3.FileChunk fileChunk = sqlite3File.pFirst;
      while (fileChunk != null)
        fileChunk = fileChunk.pNext;
      Sqlite3.sqlite3MemJournalOpen(pJfd);
      return 0;
    }

    private static int memjrnlClose(Sqlite3.sqlite3_file pJfd)
    {
      Sqlite3.memjrnlTruncate(pJfd, 0L);
      return 0;
    }

    private static int memjrnlSync(Sqlite3.sqlite3_file NotUsed, int NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<Sqlite3.sqlite3_file, int>(NotUsed, NotUsed2);
      return 0;
    }

    private static int memjrnlFileSize(Sqlite3.sqlite3_file pJfd, ref long pSize)
    {
      Sqlite3.sqlite3_file sqlite3File = pJfd;
      pSize = sqlite3File.endpoint.iOffset;
      return 0;
    }

    private static void sqlite3MemJournalOpen(Sqlite3.sqlite3_file pJfd)
    {
      Sqlite3.sqlite3_file sqlite3File = pJfd;
      sqlite3File.pFirst = (Sqlite3.FileChunk) null;
      sqlite3File.endpoint = new Sqlite3.FilePoint();
      sqlite3File.readpoint = new Sqlite3.FilePoint();
      sqlite3File.pMethods = Sqlite3.MemJournalMethods;
    }

    private static bool sqlite3IsMemJournal(Sqlite3.sqlite3_file pJfd) => pJfd.pMethods == Sqlite3.MemJournalMethods;

    private static int sqlite3MemJournalSize() => 3096;

    private static void sqlite3MemFree<T>(ref T x) where T : class => x = default (T);

    private static void sqlite3MemFree(ref string x) => x = (string) null;

    private static byte[] sqlite3MemMalloc(int nByte) => new byte[nByte];

    private static int[] sqlite3MemMallocInt(int nInt) => new int[nInt];

    private static Sqlite3.Mem sqlite3MemMallocMem(Sqlite3.Mem pMem) => new Sqlite3.Mem();

    private static void sqlite3MemFree(ref byte[] pPrior) => pPrior = (byte[]) null;

    private static void sqlite3MemFreeInt(ref int[] pPrior) => pPrior = (int[]) null;

    private static void sqlite3MemFreeMem(ref Sqlite3.Mem pPrior) => pPrior = (Sqlite3.Mem) null;

    private static int sqlite3MemInit() => 0;

    private static void sqlite3MemShutdown()
    {
    }

    private static Sqlite3.BtCursor sqlite3MemMallocBtCursor(Sqlite3.BtCursor dummy) => new Sqlite3.BtCursor();

    private static void sqlite3MemFreeBtCursor(ref Sqlite3.BtCursor pPrior) => pPrior = (Sqlite3.BtCursor) null;

    private static byte[] sqlite3MemRealloc(byte[] pPrior, int nByte)
    {
      Array.Resize<byte>(ref pPrior, nByte);
      return pPrior;
    }

    private static int sqlite3MemSize(byte[] pPrior) => pPrior != null ? pPrior.Length : 0;

    private static int sqlite3MemRoundup(int n) => n;

    private static int sqlite3MemInit(object NotUsed)
    {
      Sqlite3.UNUSED_PARAMETER<object>(NotUsed);
      if (!Sqlite3.sqlite3GlobalConfig.bMemstat)
        Sqlite3.mem0.mutex = Sqlite3.sqlite3MutexAlloc(3);
      return 0;
    }

    private static void sqlite3MemShutdown(object NotUsed) => Sqlite3.UNUSED_PARAMETER<object>(NotUsed);

    private static void sqlite3MemSetDefault() => Sqlite3.sqlite3_config(4, new Sqlite3.sqlite3_mem_methods(new Sqlite3.dxMalloc(Sqlite3.sqlite3MemMalloc), new Sqlite3.dxMallocInt(Sqlite3.sqlite3MemMallocInt), new Sqlite3.dxMallocMem(Sqlite3.sqlite3MemMallocMem), new Sqlite3.dxFree(Sqlite3.sqlite3MemFree), new Sqlite3.dxFreeInt(Sqlite3.sqlite3MemFreeInt), new Sqlite3.dxFreeMem(Sqlite3.sqlite3MemFreeMem), new Sqlite3.dxRealloc(Sqlite3.sqlite3MemRealloc), new Sqlite3.dxSize(Sqlite3.sqlite3MemSize), new Sqlite3.dxRoundup(Sqlite3.sqlite3MemRoundup), new Sqlite3.dxMemInit(Sqlite3.sqlite3MemInit), new Sqlite3.dxMemShutdown(Sqlite3.sqlite3MemShutdown), (object) 0));

    private static void sqlite3DbFree(Sqlite3.sqlite3 db, ref int[] pPrior)
    {
      if (pPrior == null)
        return;
      Sqlite3.sqlite3MemFreeInt(ref pPrior);
    }

    private static void sqlite3DbFree(Sqlite3.sqlite3 db, ref Sqlite3.Mem pPrior)
    {
      if (pPrior == null)
        return;
      Sqlite3.sqlite3MemFreeMem(ref pPrior);
    }

    private static void sqlite3DbFree(Sqlite3.sqlite3 db, ref Sqlite3.Mem[] pPrior)
    {
      if (pPrior == null)
        return;
      for (int index = 0; index < pPrior.Length; ++index)
        Sqlite3.sqlite3MemFreeMem(ref pPrior[index]);
    }

    private static void sqlite3DbFree<T>(Sqlite3.sqlite3 db, ref T pT) where T : class
    {
    }

    private static void sqlite3DbFree(Sqlite3.sqlite3 db, ref string pString)
    {
    }

    private static Sqlite3.sqlite3_mutex sqlite3MutexAlloc(int iType) => new Sqlite3.sqlite3_mutex();

    private static Sqlite3.sqlite3_mutex sqlite3_mutex_alloc(int iType) => new Sqlite3.sqlite3_mutex();

    private static void sqlite3_mutex_free(Sqlite3.sqlite3_mutex m)
    {
    }

    private static void sqlite3_mutex_enter(Sqlite3.sqlite3_mutex m)
    {
    }

    private static int sqlite3_mutex_try(int iType) => 0;

    private static void sqlite3_mutex_leave(Sqlite3.sqlite3_mutex m)
    {
    }

    private static bool sqlite3_mutex_held(Sqlite3.sqlite3_mutex m) => true;

    private static bool sqlite3_mutex_notheld(Sqlite3.sqlite3_mutex m) => true;

    private static int sqlite3MutexInit() => 0;

    private static void sqlite3MutexEnd()
    {
    }

    private static int noopMutexHeld(Sqlite3.sqlite3_mutex p) => 1;

    private static int noopMutexNotheld(Sqlite3.sqlite3_mutex p) => 1;

    private static int noopMutexInit() => 0;

    private static int noopMutexEnd() => 0;

    private static Sqlite3.sqlite3_mutex noopMutexAlloc(int id) => new Sqlite3.sqlite3_mutex();

    private static void noopMutexFree(Sqlite3.sqlite3_mutex p)
    {
    }

    private static void noopMutexEnter(Sqlite3.sqlite3_mutex p)
    {
    }

    private static int noopMutexTry(Sqlite3.sqlite3_mutex p) => 0;

    private static void noopMutexLeave(Sqlite3.sqlite3_mutex p)
    {
    }

    private Sqlite3.sqlite3_mutex_methods sqlite3DefaultMutex() => new Sqlite3.sqlite3_mutex_methods(new Sqlite3.dxMutexInit(Sqlite3.noopMutexInit), new Sqlite3.dxMutexEnd(Sqlite3.noopMutexEnd), new Sqlite3.dxMutexAlloc(Sqlite3.noopMutexAlloc), new Sqlite3.dxMutexFree(Sqlite3.noopMutexFree), new Sqlite3.dxMutexEnter(Sqlite3.noopMutexEnter), new Sqlite3.dxMutexTry(Sqlite3.noopMutexTry), new Sqlite3.dxMutexLeave(Sqlite3.noopMutexLeave), (Sqlite3.dxMutexHeld) null, (Sqlite3.dxMutexNotheld) null);

    private static string sqlite3OpcodeName(int i) => new string[146]
    {
      "?",
      "Goto",
      "Gosub",
      "Return",
      "Yield",
      "HaltIfNull",
      "Halt",
      "Integer",
      "Int64",
      "String",
      "Null",
      "Blob",
      "Variable",
      "Move",
      "Copy",
      "SCopy",
      "ResultRow",
      "CollSeq",
      "Function",
      "Not",
      "AddImm",
      "MustBeInt",
      "RealAffinity",
      "Permutation",
      "Compare",
      "Jump",
      "If",
      "IfNot",
      "Column",
      "Affinity",
      "MakeRecord",
      "Count",
      "Savepoint",
      "AutoCommit",
      "Transaction",
      "ReadCookie",
      "SetCookie",
      "VerifyCookie",
      "OpenRead",
      "OpenWrite",
      "OpenAutoindex",
      "OpenEphemeral",
      "OpenPseudo",
      "Close",
      "SeekLt",
      "SeekLe",
      "SeekGe",
      "SeekGt",
      "Seek",
      "NotFound",
      "Found",
      "IsUnique",
      "NotExists",
      "Sequence",
      "NewRowid",
      "Insert",
      "InsertInt",
      "Delete",
      "ResetCount",
      "RowKey",
      "RowData",
      "Rowid",
      "NullRow",
      "Last",
      "Sort",
      "Rewind",
      "Prev",
      "Next",
      "Or",
      "And",
      "IdxInsert",
      "IdxDelete",
      "IdxRowid",
      "IsNull",
      "NotNull",
      "Ne",
      "Eq",
      "Gt",
      "Le",
      "Lt",
      "Ge",
      "IdxLT",
      "BitAnd",
      "BitOr",
      "ShiftLeft",
      "ShiftRight",
      "Add",
      "Subtract",
      "Multiply",
      "Divide",
      "Remainder",
      "Concat",
      "IdxGE",
      "BitNot",
      "String8",
      "Destroy",
      "Clear",
      "CreateIndex",
      "CreateTable",
      "ParseSchema",
      "LoadAnalysis",
      "DropTable",
      "DropIndex",
      "DropTrigger",
      "IntegrityCk",
      "RowSetAdd",
      "RowSetRead",
      "RowSetTest",
      "Program",
      "Param",
      "FkCounter",
      "FkIfZero",
      "MemMax",
      "IfPos",
      "IfNeg",
      "IfZero",
      "AggStep",
      "AggFinal",
      "Checkpoint",
      "JournalMode",
      "Vacuum",
      "IncrVacuum",
      "Expire",
      "TableLock",
      "VBegin",
      "VCreate",
      "VDestroy",
      "VOpen",
      "VFilter",
      "VColumn",
      "Real",
      "VNext",
      "VRename",
      "VUpdate",
      "Pagecount",
      "MaxPgcnt",
      "Trace",
      "Noop",
      "Explain",
      "NotUsed_139",
      "NotUsed_140",
      "ToText",
      "ToBlob",
      "ToNumeric",
      "ToInt",
      "ToReal"
    }[i];

    private static void DO_OS_MALLOC_TEST(Sqlite3.sqlite3_file x)
    {
    }

    private static int sqlite3OsClose(Sqlite3.sqlite3_file pId)
    {
      int num = 0;
      if (pId.pMethods != null)
      {
        num = pId.pMethods.xClose(pId);
        pId.pMethods = (Sqlite3.sqlite3_io_methods) null;
      }
      return num;
    }

    private static int sqlite3OsRead(Sqlite3.sqlite3_file id, byte[] pBuf, int amt, long offset)
    {
      Sqlite3.DO_OS_MALLOC_TEST(id);
      if (pBuf == null)
        pBuf = Sqlite3.sqlite3Malloc(amt);
      return id.pMethods.xRead(id, pBuf, amt, offset);
    }

    private static int sqlite3OsWrite(Sqlite3.sqlite3_file id, byte[] pBuf, int amt, long offset)
    {
      Sqlite3.DO_OS_MALLOC_TEST(id);
      return id.pMethods.xWrite(id, pBuf, amt, offset);
    }

    private static int sqlite3OsTruncate(Sqlite3.sqlite3_file id, long size) => id.pMethods.xTruncate(id, size);

    private static int sqlite3OsSync(Sqlite3.sqlite3_file id, int flags)
    {
      Sqlite3.DO_OS_MALLOC_TEST(id);
      return id.pMethods.xSync(id, flags);
    }

    private static int sqlite3OsFileSize(Sqlite3.sqlite3_file id, ref long pSize) => id.pMethods.xFileSize(id, ref pSize);

    private static int sqlite3OsLock(Sqlite3.sqlite3_file id, int lockType)
    {
      Sqlite3.DO_OS_MALLOC_TEST(id);
      return id.pMethods.xLock(id, lockType);
    }

    private static int sqlite3OsUnlock(Sqlite3.sqlite3_file id, int lockType) => id.pMethods.xUnlock(id, lockType);

    private static int sqlite3OsCheckReservedLock(Sqlite3.sqlite3_file id, ref int pResOut)
    {
      Sqlite3.DO_OS_MALLOC_TEST(id);
      return id.pMethods.xCheckReservedLock(id, ref pResOut);
    }

    private static int sqlite3OsFileControl(Sqlite3.sqlite3_file id, uint op, ref long pArg) => id.pMethods.xFileControl(id, (int) op, ref pArg);

    private static int sqlite3OsSectorSize(Sqlite3.sqlite3_file id)
    {
      Sqlite3.dxSectorSize xSectorSize = id.pMethods.xSectorSize;
      return xSectorSize == null ? 512 : xSectorSize(id);
    }

    private static int sqlite3OsDeviceCharacteristics(Sqlite3.sqlite3_file id) => id.pMethods.xDeviceCharacteristics(id);

    private static int sqlite3OsShmLock(Sqlite3.sqlite3_file id, int offset, int n, int flags) => id.pMethods.xShmLock(id, offset, n, flags);

    private static void sqlite3OsShmBarrier(Sqlite3.sqlite3_file id) => id.pMethods.xShmBarrier(id);

    private static int sqlite3OsShmUnmap(Sqlite3.sqlite3_file id, int deleteFlag) => id.pMethods.xShmUnmap(id, deleteFlag);

    private static int sqlite3OsShmMap(
      Sqlite3.sqlite3_file id,
      int iPage,
      int pgsz,
      int bExtend,
      out object pp)
    {
      return id.pMethods.xShmMap(id, iPage, pgsz, bExtend, out pp);
    }

    private static int sqlite3OsOpen(
      Sqlite3.sqlite3_vfs pVfs,
      string zPath,
      Sqlite3.sqlite3_file pFile,
      int flags,
      ref int pFlagsOut)
    {
      Sqlite3.DO_OS_MALLOC_TEST((Sqlite3.sqlite3_file) null);
      return pVfs.xOpen(pVfs, zPath, pFile, flags & 556863, out pFlagsOut);
    }

    private static int sqlite3OsDelete(Sqlite3.sqlite3_vfs pVfs, string zPath, int dirSync) => pVfs.xDelete(pVfs, zPath, dirSync);

    private static int sqlite3OsAccess(
      Sqlite3.sqlite3_vfs pVfs,
      string zPath,
      int flags,
      ref int pResOut)
    {
      Sqlite3.DO_OS_MALLOC_TEST((Sqlite3.sqlite3_file) null);
      return pVfs.xAccess(pVfs, zPath, flags, out pResOut);
    }

    private static int sqlite3OsFullPathname(
      Sqlite3.sqlite3_vfs pVfs,
      string zPath,
      int nPathOut,
      StringBuilder zPathOut)
    {
      zPathOut.Length = 0;
      return pVfs.xFullPathname(pVfs, zPath, nPathOut, zPathOut);
    }

    private static IntPtr sqlite3OsDlOpen(Sqlite3.sqlite3_vfs pVfs, string zPath) => pVfs.xDlOpen(pVfs, zPath);

    private static void sqlite3OsDlError(Sqlite3.sqlite3_vfs pVfs, int nByte, string zBufOut)
    {
      int num = pVfs.xDlError(pVfs, nByte, zBufOut);
    }

    private static object sqlite3OsDlSym(Sqlite3.sqlite3_vfs pVfs, IntPtr pHdle, ref string zSym) => (object) pVfs.xDlSym(pVfs, pHdle, zSym);

    private static void sqlite3OsDlClose(Sqlite3.sqlite3_vfs pVfs, IntPtr pHandle)
    {
      int num = pVfs.xDlClose(pVfs, pHandle);
    }

    private static int sqlite3OsRandomness(Sqlite3.sqlite3_vfs pVfs, int nByte, byte[] zBufOut) => pVfs.xRandomness(pVfs, nByte, zBufOut);

    private static int sqlite3OsSleep(Sqlite3.sqlite3_vfs pVfs, int nMicro) => pVfs.xSleep(pVfs, nMicro);

    private static int sqlite3OsCurrentTimeInt64(Sqlite3.sqlite3_vfs pVfs, ref long pTimeOut)
    {
      int num;
      if (pVfs.iVersion >= 2 && pVfs.xCurrentTimeInt64 != null)
      {
        num = pVfs.xCurrentTimeInt64(pVfs, ref pTimeOut);
      }
      else
      {
        double currenttime = 0.0;
        num = pVfs.xCurrentTime(pVfs, ref currenttime);
        pTimeOut = (long) (currenttime * 86400000.0);
      }
      return num;
    }

    private static int sqlite3OsOpenMalloc(
      ref Sqlite3.sqlite3_vfs pVfs,
      string zFile,
      ref Sqlite3.sqlite3_file ppFile,
      int flags,
      ref int pOutFlags)
    {
      int num = 7;
      Sqlite3.sqlite3_file pFile = new Sqlite3.sqlite3_file();
      if (pFile != null)
      {
        num = Sqlite3.sqlite3OsOpen(pVfs, zFile, pFile, flags, ref pOutFlags);
        if (num == 0)
          ppFile = pFile;
      }
      return num;
    }

    private static int sqlite3OsCloseFree(Sqlite3.sqlite3_file pFile) => Sqlite3.sqlite3OsClose(pFile);

    private static int sqlite3OsInit() => Sqlite3.sqlite3_os_init();

    private static Sqlite3.sqlite3_vfs sqlite3_vfs_find(string zVfs)
    {
      if (Sqlite3.sqlite3_initialize() != 0)
        return (Sqlite3.sqlite3_vfs) null;
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mutex);
      Sqlite3.sqlite3_vfs sqlite3Vfs;
      for (sqlite3Vfs = Sqlite3.vfsList; sqlite3Vfs != null; sqlite3Vfs = sqlite3Vfs.pNext)
      {
        switch (zVfs)
        {
          case "":
          case null:
            goto label_7;
          default:
            if (!(zVfs == sqlite3Vfs.zName))
              continue;
            goto label_7;
        }
      }
label_7:
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mutex);
      return sqlite3Vfs;
    }

    private static void vfsUnlink(Sqlite3.sqlite3_vfs pVfs)
    {
      if (pVfs == null)
        return;
      if (Sqlite3.vfsList == pVfs)
      {
        Sqlite3.vfsList = pVfs.pNext;
      }
      else
      {
        if (Sqlite3.vfsList == null)
          return;
        Sqlite3.sqlite3_vfs sqlite3Vfs = Sqlite3.vfsList;
        while (sqlite3Vfs.pNext != null && sqlite3Vfs.pNext != pVfs)
          sqlite3Vfs = sqlite3Vfs.pNext;
        if (sqlite3Vfs.pNext != pVfs)
          return;
        sqlite3Vfs.pNext = pVfs.pNext;
      }
    }

    private static int sqlite3_vfs_register(Sqlite3.sqlite3_vfs pVfs, int makeDflt)
    {
      int num = Sqlite3.sqlite3_initialize();
      if (num != 0)
        return num;
      Sqlite3.sqlite3_mutex m = Sqlite3.sqlite3MutexAlloc(2);
      Sqlite3.sqlite3_mutex_enter(m);
      Sqlite3.vfsUnlink(pVfs);
      if (makeDflt != 0 || Sqlite3.vfsList == null)
      {
        pVfs.pNext = Sqlite3.vfsList;
        Sqlite3.vfsList = pVfs;
      }
      else
      {
        pVfs.pNext = Sqlite3.vfsList.pNext;
        Sqlite3.vfsList.pNext = pVfs;
      }
      Sqlite3.sqlite3_mutex_leave(m);
      return 0;
    }

    private static int sqlite3_vfs_unregister(Sqlite3.sqlite3_vfs pVfs)
    {
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mutex);
      Sqlite3.vfsUnlink(pVfs);
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mutex);
      return 0;
    }

    private static void OSTRACE(string X, params object[] ap)
    {
    }

    private static bool SimulateIOError() => false;

    private static void SimulateIOErrorBenign(int x)
    {
    }

    private static bool isNT() => Environment.OSVersion.Platform >= PlatformID.Win32NT;

    private static int getLastErrorMsg(int nBuf, ref string zBuf)
    {
      zBuf = "Unknown error";
      return 0;
    }

    private static int winLogError(int a, string b, string c)
    {
      StackFrame frame = new StackTrace(new StackFrame(true)).GetFrame(0);
      return Sqlite3.winLogErrorAtLine(a, b, c, frame.GetFileLineNumber());
    }

    private static int winLogErrorAtLine(int errcode, string zFunc, string zPath, int iLine)
    {
      string zBuf = (string) null;
      ulong num1 = 50;
      Sqlite3.getLastErrorMsg(500, ref zBuf);
      if (zPath == null)
        zPath = "";
      int num2 = 0;
      while (num2 < zBuf.Length && zBuf[num2] != '\r' && zBuf[num2] != '\n')
        ++num2;
      string str = zBuf.Substring(0, num2);
      Sqlite3.sqlite3_log(errcode, "os_win.c:%d: (%d) %s(%s) - %s", (object) iLine, (object) num1, (object) zFunc, (object) zPath, (object) str);
      return errcode;
    }

    private static int seekWinFile(Sqlite3.sqlite3_file id, long iOffset)
    {
      Sqlite3.sqlite3_file sqlite3File = id;
      try
      {
        id.fs.Seek(iOffset, SeekOrigin.Begin);
      }
      catch (Exception ex)
      {
        sqlite3File.lastErrno = 1UL;
        Sqlite3.winLogError(5642, nameof (seekWinFile), sqlite3File.zPath);
        return 1;
      }
      return 0;
    }

    private static int winClose(Sqlite3.sqlite3_file id)
    {
      int num = 0;
      Sqlite3.sqlite3_file sqlite3File = id;
      bool flag;
      do
      {
        sqlite3File.fs.Close();
        flag = true;
      }
      while (!flag && ++num < Sqlite3.MX_CLOSE_ATTEMPT);
      return !flag ? Sqlite3.winLogError(4106, nameof (winClose), sqlite3File.zPath) : 0;
    }

    private static int winRead(Sqlite3.sqlite3_file id, byte[] pBuf, int amt, long offset)
    {
      Sqlite3.sqlite3_file id1 = id;
      if (!id.fs.CanRead)
        return 266;
      if (Sqlite3.seekWinFile(id1, offset) != 0)
        return 13;
      int index;
      try
      {
        index = id.fs.Read(pBuf, 0, amt);
      }
      catch (Exception ex)
      {
        id1.lastErrno = 1UL;
        return Sqlite3.winLogError(266, nameof (winRead), id1.zPath);
      }
      if (index >= amt)
        return 0;
      Array.Clear((Array) pBuf, index, amt - index);
      return 522;
    }

    private static int winWrite(Sqlite3.sqlite3_file id, byte[] pBuf, int amt, long offset)
    {
      Sqlite3.sqlite3_file id1 = id;
      Sqlite3.seekWinFile(id1, offset);
      long position = id.fs.Position;
      int num1;
      long num2;
      try
      {
        id.fs.Write(pBuf, 0, amt);
        num1 = 1;
        num2 = id.fs.Position - position;
      }
      catch (IOException ex)
      {
        return 8;
      }
      if (num1 != 0 && amt <= (int) num2)
        return 0;
      id.lastErrno = 1UL;
      return id.lastErrno == 39UL || id.lastErrno == 112UL ? 13 : Sqlite3.winLogError(778, nameof (winWrite), id1.zPath);
    }

    private static int winTruncate(Sqlite3.sqlite3_file id, long nByte)
    {
      Sqlite3.sqlite3_file sqlite3File = id;
      if (sqlite3File.szChunk != 0)
        nByte = (nByte + (long) sqlite3File.szChunk - 1L) / (long) sqlite3File.szChunk * (long) sqlite3File.szChunk;
      int num;
      try
      {
        id.fs.SetLength(nByte);
        num = 0;
      }
      catch (IOException ex)
      {
        id.lastErrno = 1UL;
        num = Sqlite3.winLogError(1546, "winTruncate2", sqlite3File.zPath);
      }
      Sqlite3.OSTRACE("TRUNCATE %d %lld %s\n", (object) id.fs.GetHashCode(), (object) nByte, num == 0 ? (object) "ok" : (object) "failed");
      return num;
    }

    private static int winSync(Sqlite3.sqlite3_file id, int flags)
    {
      Sqlite3.sqlite3_file sqlite3File = id;
      Sqlite3.OSTRACE("SYNC %d lock=%d\n", (object) sqlite3File.fs.GetHashCode(), (object) sqlite3File.locktype);
      Sqlite3.UNUSED_PARAMETER<int>(flags);
      sqlite3File.fs.Flush();
      return 0;
    }

    private static int winFileSize(Sqlite3.sqlite3_file id, ref long pSize)
    {
      pSize = id.fs.CanRead ? id.fs.Length : 0L;
      return 0;
    }

    private static int getReadLock(Sqlite3.sqlite3_file pFile)
    {
      int readLock = 0;
      if (Sqlite3.isNT())
        readLock = Sqlite3.lockingStrategy.SharedLockFile(pFile, (long) Sqlite3.SHARED_FIRST, (long) Sqlite3.SHARED_SIZE);
      if (readLock == 0)
        pFile.lastErrno = 1UL;
      return readLock;
    }

    private static int unlockReadLock(Sqlite3.sqlite3_file pFile)
    {
      int num = 1;
      if (Sqlite3.isNT())
      {
        try
        {
          Sqlite3.lockingStrategy.UnlockFile(pFile, (long) Sqlite3.SHARED_FIRST, (long) Sqlite3.SHARED_SIZE);
        }
        catch (Exception ex)
        {
          num = 0;
        }
      }
      else
        Debugger.Break();
      if (num == 0)
      {
        pFile.lastErrno = 1UL;
        Sqlite3.winLogError(2058, nameof (unlockReadLock), pFile.zPath);
      }
      return num;
    }

    private static int winLock(Sqlite3.sqlite3_file id, int locktype)
    {
      int num1 = 1;
      bool flag = false;
      Sqlite3.sqlite3_file pFile = id;
      ulong num2 = 0;
      if (pFile.locktype >= locktype)
        return 0;
      int num3 = pFile.locktype;
      if (pFile.locktype == 0 || locktype == 4 && pFile.locktype == 2)
      {
        int num4 = 3;
        num1 = 0;
        while (num4-- > 0)
        {
          if (num1 == 0)
          {
            try
            {
              Sqlite3.lockingStrategy.LockFile(pFile, (long) Sqlite3.PENDING_BYTE, 1L);
              num1 = 1;
            }
            catch (Exception ex)
            {
              Thread.Sleep(1);
            }
          }
          else
            break;
        }
        flag = num1 != 0;
        if (num1 == 0)
          num2 = 1UL;
      }
      if (locktype == 1 && num1 != 0)
      {
        num1 = Sqlite3.getReadLock(pFile);
        if (num1 != 0)
          num3 = 1;
        else
          num2 = 1UL;
      }
      if (locktype == 2)
      {
        if (num1 != 0)
        {
          try
          {
            Sqlite3.lockingStrategy.LockFile(pFile, (long) Sqlite3.RESERVED_BYTE, 1L);
            num3 = 2;
            num1 = 1;
          }
          catch (Exception ex)
          {
            num1 = 0;
            num2 = 1UL;
          }
          if (num1 != 0)
            num3 = 2;
          else
            num2 = 1UL;
        }
      }
      if (locktype == 4 && num1 != 0)
      {
        num3 = 3;
        flag = false;
      }
      if (locktype == 4 && num1 != 0)
      {
        Sqlite3.unlockReadLock(pFile);
        try
        {
          Sqlite3.lockingStrategy.LockFile(pFile, (long) Sqlite3.SHARED_FIRST, (long) Sqlite3.SHARED_SIZE);
          num3 = 4;
          num1 = 1;
        }
        catch (Exception ex)
        {
          num1 = 0;
        }
        if (num1 != 0)
        {
          num3 = 4;
        }
        else
        {
          num2 = 1UL;
          Sqlite3.getReadLock(pFile);
        }
      }
      if (flag && locktype == 1)
        Sqlite3.lockingStrategy.UnlockFile(pFile, (long) Sqlite3.PENDING_BYTE, 1L);
      int num5;
      if (num1 != 0)
      {
        num5 = 0;
      }
      else
      {
        pFile.lastErrno = num2;
        num5 = 5;
      }
      pFile.locktype = (int) (byte) num3;
      return num5;
    }

    private static int winCheckReservedLock(Sqlite3.sqlite3_file id, ref int pResOut)
    {
      Sqlite3.sqlite3_file pFile = id;
      if (Sqlite3.SimulateIOError())
        return 3594;
      int num1;
      if (pFile.locktype >= 2)
      {
        num1 = 1;
      }
      else
      {
        int num2;
        try
        {
          Sqlite3.lockingStrategy.LockFile(pFile, (long) Sqlite3.RESERVED_BYTE, 1L);
          Sqlite3.lockingStrategy.UnlockFile(pFile, (long) Sqlite3.RESERVED_BYTE, 1L);
          num2 = 1;
        }
        catch (IOException ex)
        {
          num2 = 0;
        }
        num1 = 1 - num2;
      }
      pResOut = num1;
      return 0;
    }

    private static int winUnlock(Sqlite3.sqlite3_file id, int locktype)
    {
      Sqlite3.sqlite3_file pFile = id;
      int num = 0;
      int locktype1 = pFile.locktype;
      if (locktype1 >= 4)
      {
        Sqlite3.lockingStrategy.UnlockFile(pFile, (long) Sqlite3.SHARED_FIRST, (long) Sqlite3.SHARED_SIZE);
        if (locktype == 1 && Sqlite3.getReadLock(pFile) == 0)
          num = Sqlite3.winLogError(2058, nameof (winUnlock), pFile.zPath);
      }
      if (locktype1 >= 2)
      {
        try
        {
          Sqlite3.lockingStrategy.UnlockFile(pFile, (long) Sqlite3.RESERVED_BYTE, 1L);
        }
        catch (Exception ex)
        {
        }
      }
      if (locktype == 0 && locktype1 >= 1)
        Sqlite3.unlockReadLock(pFile);
      if (locktype1 >= 3)
      {
        try
        {
          Sqlite3.lockingStrategy.UnlockFile(pFile, (long) Sqlite3.PENDING_BYTE, 1L);
        }
        catch (Exception ex)
        {
        }
      }
      pFile.locktype = (int) (byte) locktype;
      return num;
    }

    private static int winFileControl(Sqlite3.sqlite3_file id, int op, ref long pArg)
    {
      switch (op)
      {
        case 1:
          pArg = (long) id.locktype;
          return 0;
        case 4:
          pArg = (long) (int) id.lastErrno;
          return 0;
        case 5:
          long nByte = pArg;
          Sqlite3.SimulateIOErrorBenign(1);
          Sqlite3.winTruncate(id, nByte);
          Sqlite3.SimulateIOErrorBenign(0);
          return 0;
        case 6:
          id.szChunk = (int) pArg;
          return 0;
        case 8:
          return 0;
        default:
          return 12;
      }
    }

    private static int winSectorSize(Sqlite3.sqlite3_file id) => (int) id.sectorSize;

    private static int winDeviceCharacteristics(Sqlite3.sqlite3_file id)
    {
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_file>(id);
      return 0;
    }

    private static int winShmMap(
      Sqlite3.sqlite3_file fd,
      int iRegion,
      int szRegion,
      int isWrite,
      out object pp)
    {
      pp = (object) null;
      return 0;
    }

    private static int winShmLock(Sqlite3.sqlite3_file fd, int ofst, int n, int flags) => 0;

    private static void winShmBarrier(Sqlite3.sqlite3_file fd)
    {
    }

    private static int winShmUnmap(Sqlite3.sqlite3_file fd, int deleteFlag) => 0;

    private static string convertUtf8Filename(string zFilename) => zFilename;

    private static int getTempname(int nBuf, StringBuilder zBuf)
    {
      StringBuilder stringBuilder = new StringBuilder(20);
      long pBuf = 0;
      for (int index = 0; index < 15; ++index)
      {
        Sqlite3.sqlite3_randomness(1, ref pBuf);
        stringBuilder.Append("abcdefghijklmnopqrstuvwxyz0123456789"[(int) (pBuf % (long) ("abcdefghijklmnopqrstuvwxyz0123456789".Length - 1))]);
      }
      zBuf.Append(Path.GetTempPath() + "etilqs_" + stringBuilder.ToString());
      return 0;
    }

    private static int winOpen(
      Sqlite3.sqlite3_vfs pVfs,
      string zName,
      Sqlite3.sqlite3_file pFile,
      int flags,
      out int pOutFlags)
    {
      FileStream fileStream = (FileStream) null;
      string str = zName;
      pOutFlags = 0;
      StringBuilder zBuf = new StringBuilder(261);
      int num1 = 0;
      int num2 = (int) ((long) flags & 4294967040L);
      bool flag1 = (flags & 16) != 0;
      bool flag2 = (flags & 8) != 0;
      bool flag3 = (flags & 4) != 0;
      bool flag4 = (flags & 2) != 0;
      int num3 = !flag3 ? 0 : (num2 == 16384 || num2 == 2048 ? 1 : (num2 == 524288 ? 1 : 0));
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      pFile.fs = (FileStream) null;
      if (string.IsNullOrEmpty(str))
      {
        num1 = Sqlite3.getTempname(261, zBuf);
        if (num1 != 0)
          return num1;
        str = zBuf.ToString();
      }
      string path = str;
      if (path.StartsWith("/") && !path.StartsWith("//"))
        path = path.Substring(1);
      FileAccess access = !flag4 ? FileAccess.Read : FileAccess.ReadWrite;
      FileMode mode = !flag1 ? (!flag3 ? FileMode.Open : FileMode.OpenOrCreate) : FileMode.CreateNew;
      FileShare share = FileShare.ReadWrite;
      int num4 = flag2 ? 1 : 0;
      if (Sqlite3.isNT())
      {
        int num5 = 3;
        while (fileStream == null)
        {
          if (num5 > 0)
          {
            try
            {
              --num5;
              Path.IsPathRooted(path);
              fileStream = new FileStream(path, mode, access, share, 4096);
            }
            catch (Exception ex)
            {
              Thread.Sleep(100);
            }
          }
          else
            break;
        }
      }
      else
        Debugger.Break();
      Sqlite3.OSTRACE("OPEN %d %s 0x%lx %s\n", (object) pFile.GetHashCode(), (object) zName, (object) access, fileStream == null ? (object) "failed" : (object) "ok");
      if (fileStream == null || !fileStream.CanRead)
      {
        pFile.lastErrno = 1UL;
        Sqlite3.winLogError(14, nameof (winOpen), str);
        return flag4 ? Sqlite3.winOpen(pVfs, zName, pFile, (flags | 1) & -7, out pOutFlags) : Sqlite3.SQLITE_CANTOPEN_BKPT();
      }
      pOutFlags = !flag4 ? 1 : 2;
      pFile.Clear();
      pFile.pMethods = Sqlite3.winIoMethod;
      pFile.fs = fileStream;
      pFile.lastErrno = 0UL;
      pFile.pVfs = pVfs;
      pFile.pShm = (object) null;
      pFile.zPath = zName;
      pFile.sectorSize = (ulong) Sqlite3.getSectorSize(pVfs, str);
      return num1;
    }

    private static int winDelete(Sqlite3.sqlite3_vfs pVfs, string zFilename, int syncDir)
    {
      int num1 = 0;
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      Sqlite3.UNUSED_PARAMETER<int>(syncDir);
      string path = Sqlite3.convertUtf8Filename(zFilename);
      int num2;
      if (Sqlite3.isNT())
      {
        num2 = 10;
      }
      else
      {
        while (File.Exists(zFilename))
        {
          try
          {
            File.Delete(path);
            num2 = 0;
          }
          catch (IOException ex)
          {
            num2 = 10;
            Thread.Sleep(100);
          }
          if (num2 == 0 || num1++ >= Sqlite3.MX_DELETION_ATTEMPTS)
            goto label_7;
        }
        num2 = 10;
      }
label_7:
      if (num2 == 0)
        return num2;
      int num3 = 50;
      return num2 != -1 || num3 != 2 ? Sqlite3.winLogError(2570, nameof (winDelete), zFilename) : 0;
    }

    private static int winAccess(
      Sqlite3.sqlite3_vfs pVfs,
      string zFilename,
      int flags,
      out int pResOut)
    {
      FileAttributes fileAttributes = (FileAttributes) 0;
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      if (flags == 0)
      {
        pResOut = File.Exists(zFilename) ? 1 : 0;
        return 0;
      }
      try
      {
        if (new DirectoryInfo(zFilename).Exists)
        {
          try
          {
            string path = Path.Combine(Path.GetTempPath(), Path.GetTempFileName());
            File.Create(path).Close();
            File.Delete(path);
            fileAttributes = FileAttributes.Normal;
          }
          catch (IOException ex)
          {
            fileAttributes = FileAttributes.ReadOnly;
          }
        }
      }
      catch (IOException ex)
      {
        Sqlite3.winLogError(3338, nameof (winAccess), zFilename);
      }
      int num;
      switch (flags)
      {
        case 0:
        case 2:
          num = fileAttributes != (FileAttributes) 0 ? 1 : 0;
          break;
        case 1:
          num = fileAttributes == (FileAttributes) 0 ? 0 : ((fileAttributes & FileAttributes.ReadOnly) != (FileAttributes) 0 ? 0 : 1);
          break;
        default:
          num = 0;
          break;
      }
      pResOut = num;
      return 0;
    }

    private static int winFullPathname(
      Sqlite3.sqlite3_vfs pVfs,
      string zRelative,
      int nFull,
      StringBuilder zFull)
    {
      string str = (string) null;
      if (zRelative[0] == '/' && char.IsLetter(zRelative[1]) && zRelative[2] == ':')
        zRelative = zRelative.Substring(1);
      Sqlite3.UNUSED_PARAMETER<int>(nFull);
      if (Sqlite3.isNT())
      {
        try
        {
          str = zRelative;
        }
        catch (Exception ex)
        {
          str = zRelative;
        }
      }
      else
        Debugger.Break();
      if (str == null)
        return 7;
      if (zFull.Length > pVfs.mxPathname)
        zFull.Length = pVfs.mxPathname;
      zFull.Append(str);
      return 0;
    }

    private static int getSectorSize(Sqlite3.sqlite3_vfs pVfs, string zRelative) => 512;

    private static IntPtr winDlOpen(Sqlite3.sqlite3_vfs vfs, string zFilename) => IntPtr.Zero;

    private static int winDlError(Sqlite3.sqlite3_vfs vfs, int nByte, string zErrMsg) => 0;

    private static IntPtr winDlSym(Sqlite3.sqlite3_vfs vfs, IntPtr data, string zSymbol) => IntPtr.Zero;

    private static int winDlClose(Sqlite3.sqlite3_vfs vfs, IntPtr data) => 0;

    private static int winRandomness(Sqlite3.sqlite3_vfs pVfs, int nBuf, byte[] zBuf)
    {
      int num = 0;
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      byte[] bytes = BitConverter.GetBytes(System.DateTime.Now.Ticks);
      zBuf[0] = bytes[0];
      zBuf[1] = bytes[1];
      zBuf[2] = bytes[2];
      zBuf[3] = bytes[3];
      int offset = num + 16;
      if (8 <= nBuf - offset)
      {
        uint val = 28376023;
        Sqlite3.put32bits(zBuf, offset, val);
        offset += 4;
      }
      if (8 <= nBuf - offset)
      {
        System.DateTime dateTime = new System.DateTime();
        Sqlite3.put32bits(zBuf, offset, (uint) dateTime.Ticks);
        offset += 4;
      }
      if (8 <= nBuf - offset)
      {
        long millisecond = (long) System.DateTime.UtcNow.Millisecond;
        Sqlite3.put32bits(zBuf, offset, (uint) ((ulong) millisecond & (ulong) uint.MaxValue));
        Sqlite3.put32bits(zBuf, offset, (uint) (millisecond >> 32));
        offset += 8;
      }
      return offset;
    }

    private static int winSleep(Sqlite3.sqlite3_vfs pVfs, int microsec)
    {
      Thread.Sleep((microsec + 999) / 1000);
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      return (microsec + 999) / 1000 * 1000;
    }

    private static int winCurrentTimeInt64(Sqlite3.sqlite3_vfs pVfs, ref long piNow)
    {
      piNow = 199222286400000L + System.DateTime.UtcNow.ToFileTimeUtc() / 10000L;
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      return 0;
    }

    private static int winCurrentTime(Sqlite3.sqlite3_vfs pVfs, ref double prNow)
    {
      long piNow = 0;
      int num = Sqlite3.winCurrentTimeInt64(pVfs, ref piNow);
      if (num == 0)
        prNow = (double) piNow / 86400000.0;
      return num;
    }

    private static int winGetLastError(Sqlite3.sqlite3_vfs pVfs, int nBuf, ref string zBuf)
    {
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3_vfs>(pVfs);
      return Sqlite3.getLastErrorMsg(nBuf, ref zBuf);
    }

    private static int sqlite3_os_init()
    {
      Sqlite3.sqlite3_vfs_register(Sqlite3.winVfs, 1);
      return 0;
    }

    private static int sqlite3_os_end() => 0;

    private static void PAGERTRACE(string T, params object[] ap)
    {
    }

    private static int PAGERID(Sqlite3.Pager p) => p.GetHashCode();

    private static int FILEHANDLEID(Sqlite3.sqlite3_file fd) => fd.GetHashCode();

    private static bool CODEC1(Sqlite3.Pager P, byte[] D, uint N, int X) => P.xCodec != null && P.xCodec(P.pCodec, D, N, X) == null;

    private static bool CODEC2(Sqlite3.Pager P, byte[] D, uint N, int X, ref byte[] O)
    {
      if (P.xCodec != null)
        return (O = P.xCodec(P.pCodec, D, N, X)) == null;
      O = D;
      return false;
    }

    private static void PAGER_INCR(ref int v)
    {
    }

    private static int JOURNAL_PG_SZ(Sqlite3.Pager pPager) => pPager.pageSize + 8;

    private static uint JOURNAL_HDR_SZ(Sqlite3.Pager pPager) => pPager.sectorSize;

    private static bool isOpen(Sqlite3.sqlite3_file pFd) => pFd.pMethods != null;

    private static bool pagerUseWal(Sqlite3.Pager x) => false;

    private static int pagerRollbackWal(Sqlite3.Pager x) => 0;

    private static int pagerWalFrames(Sqlite3.Pager v, Sqlite3.PgHdr w, uint x, int y, int z) => 0;

    private static int pagerOpenWalIfPresent(Sqlite3.Pager z) => 0;

    private static int pagerBeginReadTransaction(Sqlite3.Pager z) => 0;

    private static bool assert_pager_state(Sqlite3.Pager p)
    {
      Sqlite3.Pager x = p;
      int memDb = (int) x.memDb;
      switch (p.eState)
      {
        case 2:
          if (Sqlite3.pagerUseWal(x))
            break;
          break;
        case 3:
          Sqlite3.pagerUseWal(x);
          break;
      }
      return true;
    }

    private static bool subjRequiresPage(Sqlite3.PgHdr pPg)
    {
      uint pgno = pPg.pgno;
      Sqlite3.Pager pPager = pPg.pPager;
      for (int index = 0; index < pPager.nSavepoint; ++index)
      {
        Sqlite3.PagerSavepoint pagerSavepoint = pPager.aSavepoint[index];
        if (pagerSavepoint.nOrig >= pgno && Sqlite3.sqlite3BitvecTest(pagerSavepoint.pInSavepoint, pgno) == 0)
          return true;
      }
      return false;
    }

    private static bool pageInJournal(Sqlite3.PgHdr pPg) => Sqlite3.sqlite3BitvecTest(pPg.pPager.pInJournal, pPg.pgno) != 0;

    private static int read32bits(Sqlite3.sqlite3_file fd, int offset, ref int pRes)
    {
      uint pRes1 = 0;
      int num = Sqlite3.read32bits(fd, offset, ref pRes1);
      pRes = (int) pRes1;
      return num;
    }

    private static int read32bits(Sqlite3.sqlite3_file fd, long offset, ref uint pRes) => Sqlite3.read32bits(fd, (int) offset, ref pRes);

    private static int read32bits(Sqlite3.sqlite3_file fd, int offset, ref uint pRes)
    {
      byte[] numArray = new byte[4];
      int num = Sqlite3.sqlite3OsRead(fd, numArray, numArray.Length, (long) offset);
      if (num == 0)
      {
        pRes = Sqlite3.sqlite3Get4byte(numArray);
        return num;
      }
      pRes = 0U;
      return num;
    }

    private static void put32bits(string ac, int offset, int val) => Sqlite3.sqlite3Put4byte(new byte[4]
    {
      (byte) ac[offset],
      (byte) ac[offset + 1],
      (byte) ac[offset + 2],
      (byte) ac[offset + 3]
    }, 0, val);

    private static void put32bits(byte[] ac, int offset, int val) => Sqlite3.sqlite3Put4byte(ac, offset, (ulong) (uint) val);

    private static void put32bits(byte[] ac, uint val) => Sqlite3.sqlite3Put4byte(ac, 0U, val);

    private static void put32bits(byte[] ac, int offset, uint val) => Sqlite3.sqlite3Put4byte(ac, offset, (ulong) val);

    private static int write32bits(Sqlite3.sqlite3_file fd, long offset, uint val)
    {
      byte[] numArray = new byte[4];
      Sqlite3.put32bits(numArray, val);
      return Sqlite3.sqlite3OsWrite(fd, numArray, 4, offset);
    }

    private static int pagerUnlockDb(Sqlite3.Pager pPager, int eLock)
    {
      int num = 0;
      if (Sqlite3.isOpen(pPager.fd))
      {
        num = Sqlite3.sqlite3OsUnlock(pPager.fd, eLock);
        if (pPager.eLock != (byte) 5)
          pPager.eLock = (byte) eLock;
        Sqlite3.IOTRACE("UNLOCK %p %d\n", (object) pPager, (object) eLock);
      }
      return num;
    }

    private static int pagerLockDb(Sqlite3.Pager pPager, int eLock)
    {
      int num = 0;
      if ((int) pPager.eLock < eLock || pPager.eLock == (byte) 5)
      {
        num = Sqlite3.sqlite3OsLock(pPager.fd, eLock);
        if (num == 0 && (pPager.eLock != (byte) 5 || eLock == 4))
        {
          pPager.eLock = (byte) eLock;
          Sqlite3.IOTRACE("LOCK %p %d\n", (object) pPager, (object) eLock);
        }
      }
      return num;
    }

    private static int pager_datahash(int X, byte[] Y) => 0;

    private static int pager_pagehash(Sqlite3.PgHdr X) => 0;

    private static void pager_set_pagehash(Sqlite3.PgHdr X)
    {
    }

    private static int readMasterJournal(Sqlite3.sqlite3_file pJrnl, byte[] zMaster, uint nMaster)
    {
      int pRes1 = 0;
      long pSize = 0;
      uint pRes2 = 0;
      byte[] numArray = new byte[8];
      zMaster[0] = (byte) 0;
      int num;
      if ((num = Sqlite3.sqlite3OsFileSize(pJrnl, ref pSize)) != 0 || pSize < 16L || (num = Sqlite3.read32bits(pJrnl, (int) (pSize - 16L), ref pRes1)) != 0 || (long) pRes1 >= (long) nMaster || (num = Sqlite3.read32bits(pJrnl, pSize - 12L, ref pRes2)) != 0 || (num = Sqlite3.sqlite3OsRead(pJrnl, numArray, 8, pSize - 8L)) != 0 || Sqlite3.memcmp(numArray, Sqlite3.aJournalMagic, 8) != 0 || (num = Sqlite3.sqlite3OsRead(pJrnl, zMaster, pRes1, pSize - 16L - (long) pRes1)) != 0)
        return num;
      for (int index = 0; index < pRes1; ++index)
        pRes2 -= (uint) zMaster[index];
      if (pRes2 != 0U)
        pRes1 = 0;
      if (pRes1 == 0)
        zMaster[0] = (byte) 0;
      return 0;
    }

    private static long journalHdrOffset(Sqlite3.Pager pPager)
    {
      long num = 0;
      long journalOff = pPager.journalOff;
      if (journalOff != 0L)
        num = (long) (int) (((journalOff - 1L) / (long) pPager.sectorSize + 1L) * (long) pPager.sectorSize);
      return num;
    }

    private static void seekJournalHdr(Sqlite3.Pager pPager) => pPager.journalOff = Sqlite3.journalHdrOffset(pPager);

    private static int zeroJournalHdr(Sqlite3.Pager pPager, int doTruncate)
    {
      int num = 0;
      if (pPager.journalOff != 0L)
      {
        long journalSizeLimit = pPager.journalSizeLimit;
        Sqlite3.IOTRACE("JZEROHDR %p\n", (object) pPager);
        if (doTruncate != 0 || journalSizeLimit == 0L)
        {
          num = Sqlite3.sqlite3OsTruncate(pPager.jfd, 0L);
        }
        else
        {
          byte[] pBuf = new byte[28];
          num = Sqlite3.sqlite3OsWrite(pPager.jfd, pBuf, pBuf.Length, 0L);
        }
        if (num == 0 && !pPager.noSync)
          num = Sqlite3.sqlite3OsSync(pPager.jfd, 16 | (int) pPager.syncFlags);
        if (num == 0 && journalSizeLimit > 0L)
        {
          long pSize = 0;
          num = Sqlite3.sqlite3OsFileSize(pPager.jfd, ref pSize);
          if (num == 0 && pSize > journalSizeLimit)
            num = Sqlite3.sqlite3OsTruncate(pPager.jfd, journalSizeLimit);
        }
      }
      return num;
    }

    private static int writeJournalHdr(Sqlite3.Pager pPager)
    {
      int num = 0;
      byte[] pTmpSpace = pPager.pTmpSpace;
      uint amt = (uint) pPager.pageSize;
      if (amt > Sqlite3.JOURNAL_HDR_SZ(pPager))
        amt = Sqlite3.JOURNAL_HDR_SZ(pPager);
      for (int index = 0; index < pPager.nSavepoint; ++index)
      {
        if (pPager.aSavepoint[index].iHdrOffset == 0L)
          pPager.aSavepoint[index].iHdrOffset = pPager.journalOff;
      }
      pPager.journalHdr = pPager.journalOff = Sqlite3.journalHdrOffset(pPager);
      if (pPager.noSync || pPager.journalMode == (byte) 4 || (Sqlite3.sqlite3OsDeviceCharacteristics(pPager.fd) & 512) != 0)
      {
        Sqlite3.aJournalMagic.CopyTo((Array) pTmpSpace, 0);
        Sqlite3.put32bits(pTmpSpace, Sqlite3.aJournalMagic.Length, uint.MaxValue);
      }
      else
        Array.Clear((Array) pTmpSpace, 0, Sqlite3.aJournalMagic.Length + 4);
      long pBuf = 0;
      Sqlite3.sqlite3_randomness(8, ref pBuf);
      pPager.cksumInit = (uint) pBuf;
      Sqlite3.put32bits(pTmpSpace, Sqlite3.aJournalMagic.Length + 4, pPager.cksumInit);
      Sqlite3.put32bits(pTmpSpace, Sqlite3.aJournalMagic.Length + 8, pPager.dbOrigSize);
      Sqlite3.put32bits(pTmpSpace, Sqlite3.aJournalMagic.Length + 12, pPager.sectorSize);
      Sqlite3.put32bits(pTmpSpace, Sqlite3.aJournalMagic.Length + 16, (uint) pPager.pageSize);
      Array.Clear((Array) pTmpSpace, Sqlite3.aJournalMagic.Length + 20, (int) amt - (Sqlite3.aJournalMagic.Length + 20));
      for (uint index = 0; num == 0 && index < Sqlite3.JOURNAL_HDR_SZ(pPager); index += amt)
      {
        Sqlite3.IOTRACE("JHDR %p %lld %d\n", (object) pPager, (object) pPager.journalHdr, (object) amt);
        num = Sqlite3.sqlite3OsWrite(pPager.jfd, pTmpSpace, (int) amt, pPager.journalOff);
        pPager.journalOff += (long) (int) amt;
      }
      return num;
    }

    private static int readJournalHdr(
      Sqlite3.Pager pPager,
      int isHot,
      long journalSize,
      out uint pNRec,
      out uint pDbSize)
    {
      byte[] numArray = new byte[8];
      pNRec = 0U;
      pDbSize = 0U;
      pPager.journalOff = Sqlite3.journalHdrOffset(pPager);
      if (pPager.journalOff + (long) Sqlite3.JOURNAL_HDR_SZ(pPager) > journalSize)
        return 101;
      long journalOff = pPager.journalOff;
      if (isHot != 0 || journalOff != pPager.journalHdr)
      {
        int num = Sqlite3.sqlite3OsRead(pPager.jfd, numArray, numArray.Length, journalOff);
        if (num != 0)
          return num;
        if (Sqlite3.memcmp(numArray, Sqlite3.aJournalMagic, numArray.Length) != 0)
          return 101;
      }
      int num1;
      if ((num1 = Sqlite3.read32bits(pPager.jfd, journalOff + 8L, ref pNRec)) != 0 || (num1 = Sqlite3.read32bits(pPager.jfd, journalOff + 12L, ref pPager.cksumInit)) != 0 || (num1 = Sqlite3.read32bits(pPager.jfd, journalOff + 16L, ref pDbSize)) != 0)
        return num1;
      if (pPager.journalOff == 0L)
      {
        uint num2 = 0;
        uint pRes = 0;
        int num3;
        if ((num3 = Sqlite3.read32bits(pPager.jfd, journalOff + 20L, ref pRes)) != 0 || (num3 = Sqlite3.read32bits(pPager.jfd, journalOff + 24L, ref num2)) != 0)
          return num3;
        if (num2 == 0U)
          num2 = (uint) pPager.pageSize;
        if (num2 < 512U || pRes < 32U || num2 > (uint) ushort.MaxValue || pRes > 65536U || ((int) num2 - 1 & (int) num2) != 0 || ((int) pRes - 1 & (int) pRes) != 0)
          return 101;
        num1 = Sqlite3.sqlite3PagerSetPagesize(pPager, ref num2, -1);
        Sqlite3.testcase<bool>(num1 != 0);
        pPager.sectorSize = pRes;
      }
      pPager.journalOff += (long) (int) Sqlite3.JOURNAL_HDR_SZ(pPager);
      return num1;
    }

    private static int writeMasterJournal(Sqlite3.Pager pPager, string zMaster)
    {
      long pSize = 0;
      uint val = 0;
      if (zMaster == null || pPager.journalMode == (byte) 4 || pPager.journalMode == (byte) 2)
        return 0;
      pPager.setMaster = 1;
      int num1;
      for (num1 = 0; num1 < zMaster.Length && zMaster[num1] != char.MinValue; ++num1)
        val += (uint) zMaster[num1];
      if (pPager.fullSync)
        pPager.journalOff = Sqlite3.journalHdrOffset(pPager);
      long journalOff = pPager.journalOff;
      int num2;
      if ((num2 = Sqlite3.write32bits(pPager.jfd, journalOff, Sqlite3.PAGER_MJ_PGNO(pPager))) != 0 || (num2 = Sqlite3.sqlite3OsWrite(pPager.jfd, Encoding.UTF8.GetBytes(zMaster), num1, journalOff + 4L)) != 0 || (num2 = Sqlite3.write32bits(pPager.jfd, journalOff + 4L + (long) num1, (uint) num1)) != 0 || (num2 = Sqlite3.write32bits(pPager.jfd, journalOff + 4L + (long) num1 + 4L, val)) != 0 || (num2 = Sqlite3.sqlite3OsWrite(pPager.jfd, Sqlite3.aJournalMagic, 8, journalOff + 4L + (long) num1 + 8L)) != 0)
        return num2;
      pPager.journalOff += (long) (num1 + 20);
      int num3;
      if ((num3 = Sqlite3.sqlite3OsFileSize(pPager.jfd, ref pSize)) == 0 && pSize > pPager.journalOff)
        num3 = Sqlite3.sqlite3OsTruncate(pPager.jfd, pPager.journalOff);
      return num3;
    }

    private static Sqlite3.PgHdr pager_lookup(Sqlite3.Pager pPager, uint pgno)
    {
      Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
      Sqlite3.sqlite3PcacheFetch(pPager.pPCache, pgno, 0, ref ppPage);
      return ppPage;
    }

    private static void pager_reset(Sqlite3.Pager pPager)
    {
      Sqlite3.sqlite3BackupRestart(pPager.pBackup);
      Sqlite3.sqlite3PcacheClear(pPager.pPCache);
    }

    private static void releaseAllSavepoints(Sqlite3.Pager pPager)
    {
      for (int index = 0; index < pPager.nSavepoint; ++index)
        Sqlite3.sqlite3BitvecDestroy(ref pPager.aSavepoint[index].pInSavepoint);
      if (!pPager.exclusiveMode || Sqlite3.sqlite3IsMemJournal(pPager.sjfd))
        Sqlite3.sqlite3OsClose(pPager.sjfd);
      pPager.aSavepoint = (Sqlite3.PagerSavepoint[]) null;
      pPager.nSavepoint = 0;
      pPager.nSubRec = 0U;
    }

    private static int addToSavepointBitvecs(Sqlite3.Pager pPager, uint pgno)
    {
      int savepointBitvecs = 0;
      for (int index = 0; index < pPager.nSavepoint; ++index)
      {
        Sqlite3.PagerSavepoint pagerSavepoint = pPager.aSavepoint[index];
        if (pgno <= pagerSavepoint.nOrig)
        {
          savepointBitvecs |= Sqlite3.sqlite3BitvecSet(pagerSavepoint.pInSavepoint, pgno);
          Sqlite3.testcase<bool>(savepointBitvecs == 7);
        }
      }
      return savepointBitvecs;
    }

    private static void pager_unlock(Sqlite3.Pager pPager)
    {
      Sqlite3.sqlite3BitvecDestroy(ref pPager.pInJournal);
      pPager.pInJournal = (Sqlite3.Bitvec) null;
      Sqlite3.releaseAllSavepoints(pPager);
      if (Sqlite3.pagerUseWal(pPager))
      {
        Sqlite3.sqlite3WalEndReadTransaction((object) pPager.pWal);
        pPager.eState = (byte) 0;
      }
      else if (!pPager.exclusiveMode)
      {
        if (((Sqlite3.isOpen(pPager.fd) ? Sqlite3.sqlite3OsDeviceCharacteristics(pPager.fd) : 0) & 2048) == 0 || 1 != ((int) pPager.journalMode & 5))
          Sqlite3.sqlite3OsClose(pPager.jfd);
        if (Sqlite3.pagerUnlockDb(pPager, 0) != 0 && pPager.eState == (byte) 6)
          pPager.eLock = (byte) 5;
        pPager.changeCountDone = false;
        pPager.eState = (byte) 0;
      }
      if (pPager.errCode != 0)
      {
        Sqlite3.pager_reset(pPager);
        pPager.changeCountDone = pPager.tempFile;
        pPager.eState = (byte) 0;
        pPager.errCode = 0;
      }
      pPager.journalOff = 0L;
      pPager.journalHdr = 0L;
      pPager.setMaster = 0;
    }

    private static int pager_error(Sqlite3.Pager pPager, int rc)
    {
      switch (rc & (int) byte.MaxValue)
      {
        case 10:
        case 13:
          pPager.errCode = rc;
          pPager.eState = (byte) 6;
          break;
      }
      return rc;
    }

    private static int pager_end_transaction(Sqlite3.Pager pPager, int hasMaster)
    {
      int num1 = 0;
      int num2 = 0;
      if (pPager.eState < (byte) 2 && pPager.eLock < (byte) 2)
        return 0;
      Sqlite3.releaseAllSavepoints(pPager);
      if (Sqlite3.isOpen(pPager.jfd))
      {
        if (Sqlite3.sqlite3IsMemJournal(pPager.jfd))
          Sqlite3.sqlite3OsClose(pPager.jfd);
        else if (pPager.journalMode == (byte) 3)
        {
          num1 = pPager.journalOff != 0L ? Sqlite3.sqlite3OsTruncate(pPager.jfd, 0L) : 0;
          pPager.journalOff = 0L;
        }
        else if (pPager.journalMode == (byte) 1 || pPager.exclusiveMode && pPager.journalMode != (byte) 5)
        {
          num1 = Sqlite3.zeroJournalHdr(pPager, hasMaster);
          pPager.journalOff = 0L;
        }
        else
        {
          Sqlite3.sqlite3OsClose(pPager.jfd);
          if (!pPager.tempFile)
            num1 = Sqlite3.sqlite3OsDelete(pPager.pVfs, pPager.zJournal, 0);
        }
      }
      Sqlite3.sqlite3BitvecDestroy(ref pPager.pInJournal);
      pPager.pInJournal = (Sqlite3.Bitvec) null;
      pPager.nRec = 0;
      Sqlite3.sqlite3PcacheCleanAll(pPager.pPCache);
      Sqlite3.sqlite3PcacheTruncate(pPager.pPCache, pPager.dbSize);
      if (Sqlite3.pagerUseWal(pPager))
        num2 = Sqlite3.sqlite3WalEndWriteTransaction((object) pPager.pWal);
      if (!pPager.exclusiveMode && (!Sqlite3.pagerUseWal(pPager) || Sqlite3.sqlite3WalExclusiveMode((object) pPager.pWal, 0)))
      {
        num2 = Sqlite3.pagerUnlockDb(pPager, 1);
        pPager.changeCountDone = false;
      }
      pPager.eState = (byte) 1;
      pPager.setMaster = 0;
      return num1 != 0 ? num1 : num2;
    }

    private static void pagerUnlockAndRollback(Sqlite3.Pager pPager)
    {
      if (pPager.eState != (byte) 6 && pPager.eState != (byte) 0)
      {
        if (pPager.eState >= (byte) 2)
        {
          Sqlite3.sqlite3BeginBenignMalloc();
          Sqlite3.sqlite3PagerRollback(pPager);
          Sqlite3.sqlite3EndBenignMalloc();
        }
        else if (!pPager.exclusiveMode)
          Sqlite3.pager_end_transaction(pPager, 0);
      }
      Sqlite3.pager_unlock(pPager);
    }

    private static uint pager_cksum(Sqlite3.Pager pPager, byte[] aData)
    {
      uint cksumInit = pPager.cksumInit;
      for (int index = pPager.pageSize - 200; index > 0; index -= 200)
        cksumInit += (uint) aData[index];
      return cksumInit;
    }

    private static void pagerReportSize(Sqlite3.Pager pPager)
    {
      if (pPager.xCodecSizeChng == null)
        return;
      pPager.xCodecSizeChng(pPager.pCodec, pPager.pageSize, pPager.nReserve);
    }

    private static int pager_playback_one_page(
      Sqlite3.Pager pPager,
      ref long pOffset,
      Sqlite3.Bitvec pDone,
      int isMainJrnl,
      int isSavepnt)
    {
      uint pRes1 = 0;
      uint pRes2 = 0;
      byte[] pTmpSpace = pPager.pTmpSpace;
      Sqlite3.sqlite3_file sqlite3File = isMainJrnl != 0 ? pPager.jfd : pPager.sjfd;
      int num1 = Sqlite3.read32bits(sqlite3File, pOffset, ref pRes1);
      if (num1 != 0)
        return num1;
      int num2 = Sqlite3.sqlite3OsRead(sqlite3File, pTmpSpace, pPager.pageSize, pOffset + 4L);
      if (num2 != 0)
        return num2;
      pOffset += (long) (pPager.pageSize + 4 + isMainJrnl * 4);
      if (pRes1 == 0U || (int) pRes1 == (int) Sqlite3.PAGER_MJ_PGNO(pPager))
        return 101;
      if (pRes1 > pPager.dbSize || Sqlite3.sqlite3BitvecTest(pDone, pRes1) != 0)
        return 0;
      if (isMainJrnl != 0)
      {
        num2 = Sqlite3.read32bits(sqlite3File, pOffset - 4L, ref pRes2);
        if (num2 != 0)
          return num2;
        if (isSavepnt == 0 && (int) Sqlite3.pager_cksum(pPager, pTmpSpace) != (int) pRes2)
          return 101;
      }
      if (pDone != null && (num2 = Sqlite3.sqlite3BitvecSet(pDone, pRes1)) != 0)
        return num2;
      if (pRes1 == 1U && (int) pPager.nReserve != (int) pTmpSpace[20])
      {
        pPager.nReserve = (short) pTmpSpace[20];
        Sqlite3.pagerReportSize(pPager);
      }
      Sqlite3.PgHdr ppPage = !Sqlite3.pagerUseWal(pPager) ? Sqlite3.pager_lookup(pPager, pRes1) : (Sqlite3.PgHdr) null;
      Sqlite3.PAGERTRACE("PLAYBACK %d page %d hash(%08x) %s\n", (object) Sqlite3.PAGERID(pPager), (object) pRes1, (object) Sqlite3.pager_datahash(pPager.pageSize, pTmpSpace), isMainJrnl != 0 ? (object) "main-journal" : (object) "sub-journal");
      bool flag = isMainJrnl == 0 ? ppPage == null || (ppPage.flags & 4) == 0 : pPager.noSync || pOffset <= pPager.journalHdr;
      if (((!Sqlite3.isOpen(pPager.fd) ? 0 : (pPager.eState >= (byte) 4 ? 1 : (pPager.eState == (byte) 0 ? 1 : 0))) & (flag ? 1 : 0)) != 0)
      {
        long offset = (long) (pRes1 - 1U) * (long) pPager.pageSize;
        Sqlite3.testcase<bool>(isSavepnt == 0 && ppPage != null && (ppPage.flags & 4) != 0);
        num2 = Sqlite3.sqlite3OsWrite(pPager.fd, pTmpSpace, pPager.pageSize, offset);
        if (pRes1 > pPager.dbFileSize)
          pPager.dbFileSize = pRes1;
        if (pPager.pBackup != null)
        {
          if (Sqlite3.CODEC1(pPager, pTmpSpace, pRes1, 3))
            num2 = 7;
          Sqlite3.sqlite3BackupUpdate(pPager.pBackup, pRes1, pTmpSpace);
          if (Sqlite3.CODEC2(pPager, pTmpSpace, pRes1, 7, ref pTmpSpace))
            num2 = 7;
        }
      }
      else if (isMainJrnl == 0 && ppPage == null)
      {
        ++pPager.doNotSpill;
        num2 = Sqlite3.sqlite3PagerAcquire(pPager, pRes1, ref ppPage, (byte) 1);
        --pPager.doNotSpill;
        if (num2 != 0)
          return num2;
        ppPage.flags &= -9;
        Sqlite3.sqlite3PcacheMakeDirty(ppPage);
      }
      if (ppPage != null)
      {
        byte[] pData = ppPage.pData;
        Buffer.BlockCopy((Array) pTmpSpace, 0, (Array) pData, 0, pPager.pageSize);
        pPager.xReiniter(ppPage);
        if (isMainJrnl != 0 && (isSavepnt == 0 || pOffset <= pPager.journalHdr))
          Sqlite3.sqlite3PcacheMakeClean(ppPage);
        Sqlite3.pager_set_pagehash(ppPage);
        if (pRes1 == 1U)
          Buffer.BlockCopy((Array) pData, 24, (Array) pPager.dbFileVers, 0, pPager.dbFileVers.Length);
        if (Sqlite3.CODEC1(pPager, pData, ppPage.pgno, 3))
          num2 = 7;
        Sqlite3.sqlite3PcacheRelease(ppPage);
      }
      return num2;
    }

    private static int pager_delmaster(Sqlite3.Pager pPager, string zMaster)
    {
      Sqlite3.sqlite3_vfs pVfs = pPager.pVfs;
      Sqlite3.sqlite3_file pId = new Sqlite3.sqlite3_file();
      Sqlite3.sqlite3_file sqlite3File = new Sqlite3.sqlite3_file();
      int num1 = 0;
      string zPath = zMaster;
      Sqlite3.sqlite3_file pFile = pId;
      ref int local = ref num1;
      int num2 = Sqlite3.sqlite3OsOpen(pVfs, zPath, pFile, 16385, ref local);
      if (num2 == 0)
        Debugger.Break();
      if (pId == null)
        return num2;
      Sqlite3.sqlite3OsClose(pId);
      return num2;
    }

    private static int pager_truncate(Sqlite3.Pager pPager, uint nPage)
    {
      int num = 0;
      if (Sqlite3.isOpen(pPager.fd) && (pPager.eState >= (byte) 4 || pPager.eState == (byte) 0))
      {
        long pSize = 0;
        int pageSize = pPager.pageSize;
        num = Sqlite3.sqlite3OsFileSize(pPager.fd, ref pSize);
        long size = (long) pageSize * (long) nPage;
        if (num == 0 && pSize != size)
        {
          if (pSize > size)
          {
            num = Sqlite3.sqlite3OsTruncate(pPager.fd, size);
          }
          else
          {
            byte[] pTmpSpace = pPager.pTmpSpace;
            Array.Clear((Array) pTmpSpace, 0, pageSize);
            Sqlite3.testcase<bool>(size - (long) pageSize < pSize);
            Sqlite3.testcase<bool>(size - (long) pageSize == pSize);
            Sqlite3.testcase<bool>(size - (long) pageSize > pSize);
            num = Sqlite3.sqlite3OsWrite(pPager.fd, pTmpSpace, pageSize, size - (long) pageSize);
          }
          if (num == 0)
            pPager.dbSize = nPage;
        }
      }
      return num;
    }

    private static void setSectorSize(Sqlite3.Pager pPager)
    {
      if (!pPager.tempFile)
        pPager.sectorSize = (uint) Sqlite3.sqlite3OsSectorSize(pPager.fd);
      if (pPager.sectorSize < 32U)
        pPager.sectorSize = 512U;
      if (pPager.sectorSize <= 65536U)
        return;
      pPager.sectorSize = 65536U;
    }

    private static int pager_playback(Sqlite3.Pager pPager, int isHot)
    {
      Sqlite3.sqlite3_vfs pVfs = pPager.pVfs;
      long pSize = 0;
      uint pNRec = 0;
      uint pDbSize = 0;
      int pResOut = 1;
      byte[] numArray1 = (byte[]) null;
      int num1 = Sqlite3.sqlite3OsFileSize(pPager.jfd, ref pSize);
      if (num1 == 0)
      {
        byte[] numArray2 = new byte[pPager.pVfs.mxPathname + 1];
        num1 = Sqlite3.readMasterJournal(pPager.jfd, numArray2, (uint) (pPager.pVfs.mxPathname + 1));
        if (num1 == 0 && numArray2[0] != (byte) 0)
          num1 = Sqlite3.sqlite3OsAccess(pVfs, Encoding.UTF8.GetString(numArray2, 0, numArray2.Length), 0, ref pResOut);
        numArray1 = (byte[]) null;
        if (num1 == 0 && pResOut != 0)
        {
          pPager.journalOff = 0L;
          int num2 = isHot;
label_5:
          num1 = Sqlite3.readJournalHdr(pPager, isHot, pSize, out pNRec, out pDbSize);
          switch (num1)
          {
            case 0:
              if (pNRec == uint.MaxValue)
                pNRec = (uint) (((ulong) pSize - (ulong) Sqlite3.JOURNAL_HDR_SZ(pPager)) / (ulong) Sqlite3.JOURNAL_PG_SZ(pPager));
              if (pNRec == 0U && isHot == 0 && pPager.journalHdr + (long) Sqlite3.JOURNAL_HDR_SZ(pPager) == pPager.journalOff)
                pNRec = (uint) ((ulong) (pSize - pPager.journalOff) / (ulong) Sqlite3.JOURNAL_PG_SZ(pPager));
              if (pPager.journalOff == (long) Sqlite3.JOURNAL_HDR_SZ(pPager))
              {
                num1 = Sqlite3.pager_truncate(pPager, pDbSize);
                if (num1 == 0)
                  pPager.dbSize = pDbSize;
                else
                  break;
              }
              for (uint index = 0; index < pNRec; ++index)
              {
                if (num2 != 0)
                {
                  Sqlite3.pager_reset(pPager);
                  num2 = 0;
                }
                num1 = Sqlite3.pager_playback_one_page(pPager, ref pPager.journalOff, (Sqlite3.Bitvec) null, 1, 0);
                switch (num1)
                {
                  case 0:
                    continue;
                  case 101:
                    pPager.journalOff = pSize;
                    goto label_5;
                  case 522:
                    num1 = 0;
                    goto label_22;
                  default:
                    goto label_22;
                }
              }
              goto label_5;
            case 101:
              num1 = 0;
              break;
          }
        }
      }
label_22:
      pPager.changeCountDone = pPager.tempFile;
      if (num1 == 0)
      {
        numArray1 = new byte[pPager.pVfs.mxPathname + 1];
        num1 = Sqlite3.readMasterJournal(pPager.jfd, numArray1, (uint) (pPager.pVfs.mxPathname + 1));
        Sqlite3.testcase<bool>(num1 != 0);
      }
      if (num1 == 0 && (pPager.eState >= (byte) 4 || pPager.eState == (byte) 0))
        num1 = Sqlite3.sqlite3PagerSync(pPager);
      if (num1 == 0)
      {
        num1 = Sqlite3.pager_end_transaction(pPager, numArray1[0] != (byte) 0 ? 1 : 0);
        Sqlite3.testcase<bool>(num1 != 0);
      }
      if (num1 == 0 && numArray1[0] != (byte) 0 && pResOut != 0)
      {
        num1 = Sqlite3.pager_delmaster(pPager, Encoding.UTF8.GetString(numArray1, 0, numArray1.Length));
        Sqlite3.testcase<bool>(num1 != 0);
      }
      Sqlite3.setSectorSize(pPager);
      return num1;
    }

    private static int readDbPage(Sqlite3.PgHdr pPg)
    {
      Sqlite3.Pager pPager = pPg.pPager;
      uint pgno = pPg.pgno;
      int num1 = 0;
      int x = 0;
      int pageSize = pPager.pageSize;
      if (Sqlite3.NEVER(!Sqlite3.isOpen(pPager.fd)))
      {
        Array.Clear((Array) pPg.pData, 0, pPager.pageSize);
        return 0;
      }
      if (Sqlite3.pagerUseWal(pPager))
        num1 = Sqlite3.sqlite3WalRead((object) pPager.pWal, pgno, ref x, pageSize, pPg.pData);
      if (num1 == 0 && x == 0)
      {
        long offset = (long) (pgno - 1U) * (long) pPager.pageSize;
        num1 = Sqlite3.sqlite3OsRead(pPager.fd, pPg.pData, pageSize, offset);
        if (num1 == 522)
          num1 = 0;
      }
      if (pgno == 1U)
      {
        if (num1 != 0)
        {
          int num2 = 0;
          while (num2 < pPager.dbFileVers.Length)
            pPager.dbFileVers[num2++] = byte.MaxValue;
        }
        else
          Buffer.BlockCopy((Array) pPg.pData, 24, (Array) pPager.dbFileVers, 0, pPager.dbFileVers.Length);
      }
      if (Sqlite3.CODEC1(pPager, pPg.pData, pgno, 3))
        num1 = 7;
      Sqlite3.IOTRACE("PGIN %p %d\n", (object) pPager, (object) pgno);
      Sqlite3.PAGERTRACE("FETCH %d page %d hash(%08x)\n", (object) Sqlite3.PAGERID(pPager), (object) pgno, (object) Sqlite3.pager_pagehash(pPg));
      return num1;
    }

    private static void pager_write_changecounter(Sqlite3.PgHdr pPg)
    {
      uint val = Sqlite3.sqlite3Get4byte(pPg.pPager.dbFileVers, 0) + 1U;
      Sqlite3.put32bits(pPg.pData, 24, val);
      Sqlite3.put32bits(pPg.pData, 92, val);
      Sqlite3.put32bits(pPg.pData, 96, 300700701);
    }

    private static int pagerPagecount(Sqlite3.Pager pPager, ref uint pnPage)
    {
      uint num1 = Sqlite3.sqlite3WalDbsize((object) pPager.pWal);
      if (num1 == 0U)
      {
        long pSize = 0;
        if (Sqlite3.isOpen(pPager.fd))
        {
          int num2 = Sqlite3.sqlite3OsFileSize(pPager.fd, ref pSize);
          if (num2 != 0)
            return num2;
        }
        num1 = (uint) ((ulong) pSize / (ulong) pPager.pageSize);
        if (num1 == 0U && pSize > 0L)
          num1 = 1U;
      }
      if (num1 > pPager.mxPgno)
        pPager.mxPgno = num1;
      pnPage = num1;
      return 0;
    }

    private static int pagerPlaybackSavepoint(
      Sqlite3.Pager pPager,
      Sqlite3.PagerSavepoint pSavepoint)
    {
      int num1 = 0;
      Sqlite3.Bitvec p = (Sqlite3.Bitvec) null;
      if (pSavepoint != null)
        p = Sqlite3.sqlite3BitvecCreate(pSavepoint.nOrig);
      pPager.dbSize = pSavepoint != null ? pSavepoint.nOrig : pPager.dbOrigSize;
      pPager.changeCountDone = pPager.tempFile;
      if (!(bool) pSavepoint && Sqlite3.pagerUseWal(pPager))
        return Sqlite3.pagerRollbackWal(pPager);
      long journalOff = pPager.journalOff;
      if (pSavepoint != null && !Sqlite3.pagerUseWal(pPager))
      {
        long num2 = pSavepoint.iHdrOffset != 0L ? pSavepoint.iHdrOffset : journalOff;
        pPager.journalOff = pSavepoint.iOffset;
        while (num1 == 0 && pPager.journalOff < num2)
          num1 = Sqlite3.pager_playback_one_page(pPager, ref pPager.journalOff, p, 1, 1);
      }
      else
        pPager.journalOff = 0L;
label_14:
      while (num1 == 0 && pPager.journalOff < journalOff)
      {
        uint pNRec;
        num1 = Sqlite3.readJournalHdr(pPager, 0, (long) (int) journalOff, out pNRec, out uint _);
        if (pNRec == 0U && pPager.journalHdr + (long) Sqlite3.JOURNAL_HDR_SZ(pPager) >= pPager.journalOff)
          pNRec = (uint) ((ulong) (journalOff - pPager.journalOff) / (ulong) Sqlite3.JOURNAL_PG_SZ(pPager));
        uint num3 = 0;
        while (true)
        {
          if (num1 == 0 && num3 < pNRec && pPager.journalOff < journalOff)
          {
            num1 = Sqlite3.pager_playback_one_page(pPager, ref pPager.journalOff, p, 1, 1);
            ++num3;
          }
          else
            goto label_14;
        }
      }
      if (pSavepoint != null)
      {
        long pOffset = (long) pSavepoint.iSubRec * (long) (4 + pPager.pageSize);
        if (Sqlite3.pagerUseWal(pPager))
          num1 = Sqlite3.sqlite3WalSavepointUndo((object) pPager.pWal, pSavepoint.aWalData);
        for (uint iSubRec = pSavepoint.iSubRec; num1 == 0 && iSubRec < pPager.nSubRec; ++iSubRec)
          num1 = Sqlite3.pager_playback_one_page(pPager, ref pOffset, p, 0, 1);
      }
      Sqlite3.sqlite3BitvecDestroy(ref p);
      if (num1 == 0)
        pPager.journalOff = (long) (int) journalOff;
      return num1;
    }

    private static void sqlite3PagerSetCachesize(Sqlite3.Pager pPager, int mxPage) => Sqlite3.sqlite3PcacheSetCachesize(pPager.pPCache, mxPage);

    private static void sqlite3PagerSetSafetyLevel(
      Sqlite3.Pager pPager,
      int level,
      int bFullFsync,
      int bCkptFullFsync)
    {
      pPager.noSync = level == 1 || pPager.tempFile;
      pPager.fullSync = level == 3 && !pPager.tempFile;
      if (pPager.noSync)
      {
        pPager.syncFlags = (byte) 0;
        pPager.ckptSyncFlags = (byte) 0;
      }
      else if (bFullFsync != 0)
      {
        pPager.syncFlags = (byte) 3;
        pPager.ckptSyncFlags = (byte) 3;
      }
      else if (bCkptFullFsync != 0)
      {
        pPager.syncFlags = (byte) 2;
        pPager.ckptSyncFlags = (byte) 3;
      }
      else
      {
        pPager.syncFlags = (byte) 2;
        pPager.ckptSyncFlags = (byte) 2;
      }
    }

    private static int pagerOpentemp(
      Sqlite3.Pager pPager,
      ref Sqlite3.sqlite3_file pFile,
      int vfsFlags)
    {
      vfsFlags |= 30;
      int pFlagsOut = 0;
      return Sqlite3.sqlite3OsOpen(pPager.pVfs, (string) null, pFile, vfsFlags, ref pFlagsOut);
    }

    private static void sqlite3PagerSetBusyhandler(
      Sqlite3.Pager pPager,
      Sqlite3.dxBusyHandler xBusyHandler,
      object pBusyHandlerArg)
    {
      pPager.xBusyHandler = xBusyHandler;
      pPager.pBusyHandlerArg = pBusyHandlerArg;
    }

    private static int sqlite3PagerSetPagesize(
      Sqlite3.Pager pPager,
      ref uint pPageSize,
      int nReserve)
    {
      int num1 = 0;
      uint num2 = pPageSize;
      if ((pPager.memDb == (byte) 0 || pPager.dbSize == 0U) && Sqlite3.sqlite3PcacheRefCount(pPager.pPCache) == 0 && num2 != 0U && (int) num2 != pPager.pageSize)
      {
        long pSize = 0;
        if (pPager.eState > (byte) 0 && Sqlite3.isOpen(pPager.fd))
          num1 = Sqlite3.sqlite3OsFileSize(pPager.fd, ref pSize);
        if (num1 == 0)
        {
          Sqlite3.pager_reset(pPager);
          pPager.dbSize = (uint) ((ulong) pSize / (ulong) num2);
          pPager.pageSize = (int) num2;
          Sqlite3.sqlite3PageFree(ref pPager.pTmpSpace);
          pPager.pTmpSpace = Sqlite3.sqlite3Malloc(num2);
          Sqlite3.sqlite3PcacheSetPageSize(pPager.pPCache, (int) num2);
        }
      }
      pPageSize = (uint) pPager.pageSize;
      if (num1 == 0)
      {
        if (nReserve < 0)
          nReserve = (int) pPager.nReserve;
        pPager.nReserve = (short) nReserve;
        Sqlite3.pagerReportSize(pPager);
      }
      return num1;
    }

    private static byte[] sqlite3PagerTempSpace(Sqlite3.Pager pPager) => pPager.pTmpSpace;

    private static uint sqlite3PagerMaxPageCount(Sqlite3.Pager pPager, int mxPage)
    {
      if (mxPage > 0)
        pPager.mxPgno = (uint) mxPage;
      return pPager.mxPgno;
    }

    private static int sqlite3PagerReadFileheader(Sqlite3.Pager pPager, int N, byte[] pDest)
    {
      int num = 0;
      Array.Clear((Array) pDest, 0, N);
      if (Sqlite3.isOpen(pPager.fd))
      {
        Sqlite3.IOTRACE("DBHDR %p 0 %d\n", (object) pPager, (object) N);
        num = Sqlite3.sqlite3OsRead(pPager.fd, pDest, N, 0L);
        if (num == 522)
          num = 0;
      }
      return num;
    }

    private static void sqlite3PagerPagecount(Sqlite3.Pager pPager, out uint pnPage) => pnPage = pPager.dbSize;

    private static int pager_wait_on_lock(Sqlite3.Pager pPager, int locktype)
    {
      int num;
      do
      {
        num = Sqlite3.pagerLockDb(pPager, locktype);
      }
      while (num == 5 && pPager.xBusyHandler(pPager.pBusyHandlerArg) != 0);
      return num;
    }

    private static void assertTruncateConstraintCb(Sqlite3.PgHdr pPg)
    {
    }

    private static void assertTruncateConstraint(Sqlite3.Pager pPager)
    {
    }

    private static void sqlite3PagerTruncateImage(Sqlite3.Pager pPager, uint nPage)
    {
      pPager.dbSize = nPage;
      Sqlite3.assertTruncateConstraint(pPager);
    }

    private static int pagerSyncHotJournal(Sqlite3.Pager pPager)
    {
      int num = 0;
      if (!pPager.noSync)
        num = Sqlite3.sqlite3OsSync(pPager.jfd, 2);
      if (num == 0)
        num = Sqlite3.sqlite3OsFileSize(pPager.jfd, ref pPager.journalHdr);
      return num;
    }

    private static int sqlite3PagerClose(Sqlite3.Pager pPager)
    {
      byte[] pTmpSpace = pPager.pTmpSpace;
      Sqlite3.sqlite3BeginBenignMalloc();
      pPager.exclusiveMode = false;
      Sqlite3.pager_reset(pPager);
      if ((byte) 1 == pPager.memDb)
      {
        Sqlite3.pager_unlock(pPager);
      }
      else
      {
        if (Sqlite3.isOpen(pPager.jfd))
          Sqlite3.pager_error(pPager, Sqlite3.pagerSyncHotJournal(pPager));
        Sqlite3.pagerUnlockAndRollback(pPager);
      }
      Sqlite3.sqlite3EndBenignMalloc();
      Sqlite3.PAGERTRACE("CLOSE %d\n", (object) Sqlite3.PAGERID(pPager));
      Sqlite3.IOTRACE("CLOSE %p\n", (object) pPager);
      Sqlite3.sqlite3OsClose(pPager.jfd);
      Sqlite3.sqlite3OsClose(pPager.fd);
      Sqlite3.sqlite3PcacheClose(pPager.pPCache);
      if (pPager.xCodecFree != null)
        pPager.xCodecFree(ref pPager.pCodec);
      return 0;
    }

    private static uint sqlite3PagerPagenumber(Sqlite3.PgHdr pPg) => pPg.pgno;

    private static void sqlite3PagerRef(Sqlite3.PgHdr pPg) => Sqlite3.sqlite3PcacheRef(pPg);

    private static int syncJournal(Sqlite3.Pager pPager, int newHdr)
    {
      int num1 = Sqlite3.sqlite3PagerExclusiveLock(pPager);
      if (num1 != 0)
        return num1;
      if (!pPager.noSync)
      {
        if (Sqlite3.isOpen(pPager.jfd) && pPager.journalMode != (byte) 4)
        {
          int num2 = Sqlite3.sqlite3OsDeviceCharacteristics(pPager.fd);
          if ((num2 & 512) == 0)
          {
            byte[] numArray1 = new byte[8];
            byte[] numArray2 = new byte[Sqlite3.aJournalMagic.Length + 4];
            Sqlite3.aJournalMagic.CopyTo((Array) numArray2, 0);
            Sqlite3.put32bits(numArray2, Sqlite3.aJournalMagic.Length, pPager.nRec);
            long offset = Sqlite3.journalHdrOffset(pPager);
            int num3 = Sqlite3.sqlite3OsRead(pPager.jfd, numArray1, 8, offset);
            if (num3 == 0 && Sqlite3.memcmp(numArray1, Sqlite3.aJournalMagic, 8) == 0)
            {
              byte[] pBuf = new byte[1];
              num3 = Sqlite3.sqlite3OsWrite(pPager.jfd, pBuf, 1, offset);
            }
            if (num3 != 0 && num3 != 522)
              return num3;
            if (pPager.fullSync && (num2 & 1024) == 0)
            {
              Sqlite3.PAGERTRACE("SYNC journal of %d\n", (object) Sqlite3.PAGERID(pPager));
              Sqlite3.IOTRACE("JSYNC %p\n", (object) pPager);
              int num4 = Sqlite3.sqlite3OsSync(pPager.jfd, (int) pPager.syncFlags);
              if (num4 != 0)
                return num4;
            }
            Sqlite3.IOTRACE("JHDR %p %lld\n", (object) pPager, (object) pPager.journalHdr);
            int num5 = Sqlite3.sqlite3OsWrite(pPager.jfd, numArray2, numArray2.Length, pPager.journalHdr);
            if (num5 != 0)
              return num5;
          }
          if ((num2 & 1024) == 0)
          {
            Sqlite3.PAGERTRACE("SYNC journal of %d\n", (object) Sqlite3.PAGERID(pPager));
            Sqlite3.IOTRACE("JSYNC %p\n", (object) pPager);
            int num6 = Sqlite3.sqlite3OsSync(pPager.jfd, (int) pPager.syncFlags | (pPager.syncFlags == (byte) 3 ? 16 : 0));
            if (num6 != 0)
              return num6;
          }
          pPager.journalHdr = pPager.journalOff;
          if (newHdr != 0 && (num2 & 512) == 0)
          {
            pPager.nRec = 0;
            int num7 = Sqlite3.writeJournalHdr(pPager);
            if (num7 != 0)
              return num7;
          }
        }
        else
          pPager.journalHdr = pPager.journalOff;
      }
      Sqlite3.sqlite3PcacheClearSyncFlags(pPager.pPCache);
      pPager.eState = (byte) 4;
      return 0;
    }

    private static int pager_write_pagelist(Sqlite3.Pager pPager, Sqlite3.PgHdr pList)
    {
      int num = 0;
      if (!Sqlite3.isOpen(pPager.fd))
        num = Sqlite3.pagerOpentemp(pPager, ref pPager.fd, (int) pPager.vfsFlags);
      if (num == 0 && pPager.dbSize > pPager.dbHintSize)
      {
        long pArg = (long) pPager.pageSize * (long) pPager.dbSize;
        Sqlite3.sqlite3OsFileControl(pPager.fd, 5U, ref pArg);
        pPager.dbHintSize = pPager.dbSize;
      }
      for (; num == 0 && (bool) pList; pList = pList.pDirty)
      {
        uint pgno = pList.pgno;
        if (pList.pgno <= pPager.dbSize && (pList.flags & 32) == 0)
        {
          long offset = (long) (pList.pgno - 1U) * (long) pPager.pageSize;
          byte[] O = (byte[]) null;
          if (pList.pgno == 1U)
            Sqlite3.pager_write_changecounter(pList);
          if (Sqlite3.CODEC2(pPager, pList.pData, pgno, 6, ref O))
            return 7;
          num = Sqlite3.sqlite3OsWrite(pPager.fd, O, pPager.pageSize, offset);
          if (pgno == 1U)
            Buffer.BlockCopy((Array) O, 24, (Array) pPager.dbFileVers, 0, pPager.dbFileVers.Length);
          if (pgno > pPager.dbFileSize)
            pPager.dbFileSize = pgno;
          Sqlite3.sqlite3BackupUpdate(pPager.pBackup, pgno, pList.pData);
          Sqlite3.PAGERTRACE("STORE %d page %d hash(%08x)\n", (object) Sqlite3.PAGERID(pPager), (object) pgno, (object) Sqlite3.pager_pagehash(pList));
          Sqlite3.IOTRACE("PGOUT %p %d\n", (object) pPager, (object) pgno);
        }
        else
          Sqlite3.PAGERTRACE("NOSTORE %d page %d\n", (object) Sqlite3.PAGERID(pPager), (object) pgno);
        Sqlite3.pager_set_pagehash(pList);
      }
      return num;
    }

    private static int openSubJournal(Sqlite3.Pager pPager)
    {
      int num = 0;
      if (!Sqlite3.isOpen(pPager.sjfd))
      {
        if (pPager.journalMode == (byte) 4 || pPager.subjInMemory != (byte) 0)
          Sqlite3.sqlite3MemJournalOpen(pPager.sjfd);
        else
          num = Sqlite3.pagerOpentemp(pPager, ref pPager.sjfd, 8192);
      }
      return num;
    }

    private static int subjournalPage(Sqlite3.PgHdr pPg)
    {
      int num = 0;
      Sqlite3.Pager pPager = pPg.pPager;
      if (pPager.journalMode != (byte) 2)
      {
        num = Sqlite3.openSubJournal(pPager);
        if (num == 0)
        {
          byte[] pData = pPg.pData;
          long offset = (long) pPager.nSubRec * (long) (4 + pPager.pageSize);
          byte[] O = (byte[]) null;
          if (Sqlite3.CODEC2(pPager, pData, pPg.pgno, 7, ref O))
            return 7;
          Sqlite3.PAGERTRACE("STMT-JOURNAL %d page %d\n", (object) Sqlite3.PAGERID(pPager), (object) pPg.pgno);
          num = Sqlite3.write32bits(pPager.sjfd, offset, pPg.pgno);
          if (num == 0)
            num = Sqlite3.sqlite3OsWrite(pPager.sjfd, O, pPager.pageSize, offset + 4L);
        }
      }
      if (num == 0)
      {
        ++pPager.nSubRec;
        num = Sqlite3.addToSavepointBitvecs(pPager, pPg.pgno);
      }
      return num;
    }

    private static int pagerStress(object p, Sqlite3.PgHdr pPg)
    {
      Sqlite3.Pager pager = (Sqlite3.Pager) p;
      int rc = 0;
      if (Sqlite3.NEVER(pager.errCode != 0) || pager.doNotSpill != (byte) 0 || pager.doNotSyncSpill != (byte) 0 && (pPg.flags & 4) != 0)
        return 0;
      pPg.pDirty = (Sqlite3.PgHdr) null;
      if (Sqlite3.pagerUseWal(pager))
      {
        if (Sqlite3.subjRequiresPage(pPg))
          rc = Sqlite3.subjournalPage(pPg);
        if (rc == 0)
          rc = Sqlite3.pagerWalFrames(pager, pPg, 0U, 0, 0);
      }
      else
      {
        if ((pPg.flags & 4) != 0 || pager.eState == (byte) 3)
          rc = Sqlite3.syncJournal(pager, 1);
        if (Sqlite3.NEVER(rc == 0 && pPg.pgno > pager.dbSize && Sqlite3.subjRequiresPage(pPg)))
          rc = Sqlite3.subjournalPage(pPg);
        if (rc == 0)
          rc = Sqlite3.pager_write_pagelist(pager, pPg);
      }
      if (rc == 0)
      {
        Sqlite3.PAGERTRACE("STRESS %d page %d\n", (object) Sqlite3.PAGERID(pager), (object) pPg.pgno);
        Sqlite3.sqlite3PcacheMakeClean(pPg);
      }
      return Sqlite3.pager_error(pager, rc);
    }

    private static int sqlite3PagerOpen(
      Sqlite3.sqlite3_vfs pVfs,
      out Sqlite3.Pager ppPager,
      string zFilename,
      int nExtra,
      int flags,
      int vfsFlags,
      Sqlite3.dxReiniter xReinit)
    {
      int num1 = 0;
      byte num2 = 0;
      byte num3 = 0;
      StringBuilder stringBuilder = (StringBuilder) null;
      bool flag1 = (flags & 1) == 0;
      bool flag2 = (flags & 2) != 0;
      Sqlite3.sqlite3PcacheSize();
      uint pPageSize = 1024;
      if (Sqlite3.sqlite3JournalSize(pVfs) > Sqlite3.sqlite3MemJournalSize())
        Sqlite3.ROUND8(Sqlite3.sqlite3JournalSize(pVfs));
      else
        Sqlite3.ROUND8(Sqlite3.sqlite3MemJournalSize());
      ppPager = (Sqlite3.Pager) null;
      if ((flags & 4) != 0)
      {
        num3 = (byte) 1;
        zFilename = (string) null;
      }
      if (!string.IsNullOrEmpty(zFilename))
      {
        int nPathOut = pVfs.mxPathname + 1;
        stringBuilder = new StringBuilder(nPathOut * 2);
        num1 = Sqlite3.sqlite3OsFullPathname(pVfs, zFilename, nPathOut, stringBuilder);
        int num4 = Sqlite3.sqlite3Strlen30(stringBuilder);
        int length = zFilename.Length;
        if (num1 == 0 && num4 + 8 > pVfs.mxPathname)
          num1 = Sqlite3.SQLITE_CANTOPEN_BKPT();
        if (num1 != 0)
          return num1;
      }
      Sqlite3.Pager pager = new Sqlite3.Pager();
      pager.pPCache = new Sqlite3.PCache();
      pager.fd = new Sqlite3.sqlite3_file();
      pager.sjfd = new Sqlite3.sqlite3_file();
      pager.jfd = new Sqlite3.sqlite3_file();
      if (stringBuilder != null)
      {
        pager.zFilename = stringBuilder.ToString();
        string zFilename1 = pager.zFilename;
        pager.zJournal = pager.zFilename + "-journal";
        Sqlite3.sqlite3FileSuffix3(pager.zFilename, pager.zJournal);
      }
      else
        pager.zFilename = "";
      pager.pVfs = pVfs;
      pager.vfsFlags = (uint) vfsFlags;
      bool flag3;
      if (!string.IsNullOrEmpty(zFilename))
      {
        int pFlagsOut = 0;
        num1 = Sqlite3.sqlite3OsOpen(pVfs, pager.zFilename, pager.fd, vfsFlags, ref pFlagsOut);
        flag3 = (pFlagsOut & 1) != 0;
        if (num1 == 0 && !flag3)
        {
          Sqlite3.setSectorSize(pager);
          if (pPageSize < pager.sectorSize)
            pPageSize = pager.sectorSize <= 8192U ? pager.sectorSize : 8192U;
        }
      }
      else
      {
        num2 = (byte) 1;
        pager.eState = (byte) 1;
        pager.eLock = (byte) 4;
        flag3 = (vfsFlags & 1) != 0;
      }
      if (num1 == 0)
      {
        num1 = Sqlite3.sqlite3PagerSetPagesize(pager, ref pPageSize, -1);
        Sqlite3.testcase<bool>(num1 != 0);
      }
      if (num1 != 0)
      {
        Sqlite3.sqlite3OsClose(pager.fd);
        return num1;
      }
      nExtra = Sqlite3.ROUND8(nExtra);
      Sqlite3.sqlite3PcacheOpen((int) pPageSize, nExtra, num3 == (byte) 0, num3 == (byte) 0 ? new Sqlite3.dxStress(Sqlite3.pagerStress) : (Sqlite3.dxStress) null, (object) pager, pager.pPCache);
      Sqlite3.PAGERTRACE("OPEN %d %s\n", (object) Sqlite3.FILEHANDLEID(pager.fd), (object) pager.zFilename);
      Sqlite3.IOTRACE("OPEN %p %s\n", (object) pager, (object) pager.zFilename);
      pager.useJournal = flag1 ? (byte) 1 : (byte) 0;
      pager.noReadlock = flag2 & flag3 ? (byte) 1 : (byte) 0;
      pager.mxPgno = 1073741823U;
      pager.tempFile = num2 > (byte) 0;
      pager.exclusiveMode = num2 > (byte) 0;
      pager.changeCountDone = pager.tempFile;
      pager.memDb = num3;
      pager.readOnly = flag3;
      pager.noSync = pager.tempFile;
      pager.fullSync = pager.noSync;
      pager.syncFlags = pager.noSync ? (byte) 0 : (byte) 2;
      pager.ckptSyncFlags = pager.syncFlags;
      pager.nExtra = (ushort) nExtra;
      pager.journalSizeLimit = -1L;
      Sqlite3.setSectorSize(pager);
      if (!flag1)
        pager.journalMode = (byte) 2;
      else if (num3 != (byte) 0)
        pager.journalMode = (byte) 4;
      pager.xReiniter = xReinit;
      ppPager = pager;
      return 0;
    }

    private static int hasHotJournal(Sqlite3.Pager pPager, ref int pExists)
    {
      Sqlite3.sqlite3_vfs pVfs = pPager.pVfs;
      int num1 = 0;
      int pResOut1 = 1;
      int num2 = Sqlite3.isOpen(pPager.jfd) ? 1 : 0;
      pExists = 0;
      if (num2 == 0)
        num1 = Sqlite3.sqlite3OsAccess(pVfs, pPager.zJournal, 0, ref pResOut1);
      if (num1 == 0 && pResOut1 != 0)
      {
        int pResOut2 = 0;
        num1 = Sqlite3.sqlite3OsCheckReservedLock(pPager.fd, ref pResOut2);
        if (num1 == 0 && pResOut2 == 0)
        {
          uint pnPage = 0;
          num1 = Sqlite3.pagerPagecount(pPager, ref pnPage);
          if (num1 == 0)
          {
            if (pnPage == 0U)
            {
              Sqlite3.sqlite3BeginBenignMalloc();
              if (Sqlite3.pagerLockDb(pPager, 2) == 0)
              {
                Sqlite3.sqlite3OsDelete(pVfs, pPager.zJournal, 0);
                if (!pPager.exclusiveMode)
                  Sqlite3.pagerUnlockDb(pPager, 1);
              }
              Sqlite3.sqlite3EndBenignMalloc();
            }
            else
            {
              if (num2 == 0)
              {
                int pFlagsOut = 2049;
                num1 = Sqlite3.sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, pFlagsOut, ref pFlagsOut);
              }
              switch (num1)
              {
                case 0:
                  byte[] pBuf = new byte[1];
                  num1 = Sqlite3.sqlite3OsRead(pPager.jfd, pBuf, 1, 0L);
                  if (num1 == 522)
                    num1 = 0;
                  if (num2 == 0)
                    Sqlite3.sqlite3OsClose(pPager.jfd);
                  pExists = pBuf[0] != (byte) 0 ? 1 : 0;
                  break;
                case 14:
                  pExists = 1;
                  num1 = 0;
                  break;
              }
            }
          }
        }
      }
      return num1;
    }

    private static int sqlite3PagerSharedLock(Sqlite3.Pager pPager)
    {
      int rc = 0;
      if (Sqlite3.NEVER(pPager.memDb != (byte) 0 && pPager.errCode != 0))
        return pPager.errCode;
      if (!Sqlite3.pagerUseWal(pPager) && pPager.eState == (byte) 0)
      {
        int pExists = 1;
        if (pPager.noReadlock == (byte) 0)
        {
          rc = Sqlite3.pager_wait_on_lock(pPager, 1);
          if (rc != 0)
            goto label_33;
        }
        if (pPager.eLock <= (byte) 1)
          rc = Sqlite3.hasHotJournal(pPager, ref pExists);
        if (rc == 0)
        {
          if (pExists != 0)
          {
            rc = Sqlite3.pagerLockDb(pPager, 4);
            if (rc == 0)
            {
              if (!Sqlite3.isOpen(pPager.jfd))
              {
                Sqlite3.sqlite3_vfs pVfs = pPager.pVfs;
                int pResOut = 0;
                rc = Sqlite3.sqlite3OsAccess(pVfs, pPager.zJournal, 0, ref pResOut);
                if (rc == 0 && pResOut != 0)
                {
                  int pFlagsOut = 0;
                  int flags = 2050;
                  rc = Sqlite3.sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, flags, ref pFlagsOut);
                  if (rc == 0 && (pFlagsOut & 1) != 0)
                  {
                    rc = Sqlite3.SQLITE_CANTOPEN_BKPT();
                    Sqlite3.sqlite3OsClose(pPager.jfd);
                  }
                }
              }
              if (Sqlite3.isOpen(pPager.jfd))
              {
                rc = Sqlite3.pagerSyncHotJournal(pPager);
                if (rc == 0)
                {
                  rc = Sqlite3.pager_playback(pPager, 1);
                  pPager.eState = (byte) 0;
                }
              }
              else if (!pPager.exclusiveMode)
                Sqlite3.pagerUnlockDb(pPager, 1);
              if (rc != 0)
              {
                Sqlite3.pager_error(pPager, rc);
                goto label_33;
              }
            }
            else
              goto label_33;
          }
          if (!pPager.tempFile && (pPager.pBackup != null || Sqlite3.sqlite3PcachePagecount(pPager.pPCache) > 0))
          {
            uint pnPage = 0;
            byte[] numArray = new byte[pPager.dbFileVers.Length];
            rc = Sqlite3.pagerPagecount(pPager, ref pnPage);
            if (rc == 0)
            {
              if (pnPage > 0U)
              {
                Sqlite3.IOTRACE("CKVERS %p %d\n", (object) pPager, (object) numArray.Length);
                rc = Sqlite3.sqlite3OsRead(pPager.fd, numArray, numArray.Length, 24L);
                if (rc != 0)
                  goto label_33;
              }
              else
                Array.Clear((Array) numArray, 0, numArray.Length);
              if (Sqlite3.memcmp(pPager.dbFileVers, numArray, numArray.Length) != 0)
                Sqlite3.pager_reset(pPager);
            }
            else
              goto label_33;
          }
          rc = Sqlite3.pagerOpenWalIfPresent(pPager);
        }
        else
          goto label_33;
      }
      if (Sqlite3.pagerUseWal(pPager))
        rc = Sqlite3.pagerBeginReadTransaction(pPager);
      if (pPager.eState == (byte) 0 && rc == 0)
        rc = Sqlite3.pagerPagecount(pPager, ref pPager.dbSize);
label_33:
      if (rc != 0)
        Sqlite3.pager_unlock(pPager);
      else
        pPager.eState = (byte) 1;
      return rc;
    }

    private static void pagerUnlockIfUnused(Sqlite3.Pager pPager)
    {
      if (Sqlite3.sqlite3PcacheRefCount(pPager.pPCache) != 0)
        return;
      Sqlite3.pagerUnlockAndRollback(pPager);
    }

    private static int sqlite3PagerGet(Sqlite3.Pager pPager, uint pgno, ref Sqlite3.PgHdr ppPage) => Sqlite3.sqlite3PagerAcquire(pPager, pgno, ref ppPage, (byte) 0);

    private static int sqlite3PagerAcquire(
      Sqlite3.Pager pPager,
      uint pgno,
      ref Sqlite3.PgHdr ppPage,
      byte noContent)
    {
      if (pgno == 0U)
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      int num = pPager.errCode == 0 ? Sqlite3.sqlite3PcacheFetch(pPager.pPCache, pgno, 1, ref ppPage) : pPager.errCode;
      Sqlite3.PgHdr pgHdr;
      if (num != 0)
      {
        pgHdr = (Sqlite3.PgHdr) null;
      }
      else
      {
        if (ppPage.pPager != null && noContent == (byte) 0)
        {
          Sqlite3.PAGER_INCR(ref pPager.nHit);
          return 0;
        }
        pgHdr = ppPage;
        pgHdr.pPager = pPager;
        pgHdr.pExtra = new Sqlite3.MemPage();
        if (pgno > (uint) int.MaxValue || (int) pgno == (int) Sqlite3.PAGER_MJ_PGNO(pPager))
        {
          num = Sqlite3.SQLITE_CORRUPT_BKPT();
        }
        else
        {
          if (pPager.memDb != (byte) 0 || pPager.dbSize < pgno || noContent != (byte) 0 || !Sqlite3.isOpen(pPager.fd))
          {
            if (pgno > pPager.mxPgno)
            {
              num = 13;
              goto label_18;
            }
            else
            {
              if (noContent != (byte) 0)
              {
                Sqlite3.sqlite3BeginBenignMalloc();
                if (pgno <= pPager.dbOrigSize)
                {
                  Sqlite3.sqlite3BitvecSet(pPager.pInJournal, pgno);
                  Sqlite3.testcase<bool>(num == 7);
                }
                Sqlite3.addToSavepointBitvecs(pPager, pgno);
                Sqlite3.testcase<bool>(num == 7);
                Sqlite3.sqlite3EndBenignMalloc();
              }
              Array.Clear((Array) pgHdr.pData, 0, pPager.pageSize);
              Sqlite3.IOTRACE("ZERO %p %d\n", (object) pPager, (object) pgno);
            }
          }
          else
          {
            num = Sqlite3.readDbPage(pgHdr);
            if (num != 0)
              goto label_18;
          }
          Sqlite3.pager_set_pagehash(pgHdr);
          return 0;
        }
      }
label_18:
      if (pgHdr != null)
        Sqlite3.sqlite3PcacheDrop(pgHdr);
      Sqlite3.pagerUnlockIfUnused(pPager);
      ppPage = (Sqlite3.PgHdr) null;
      return num;
    }

    private static Sqlite3.PgHdr sqlite3PagerLookup(Sqlite3.Pager pPager, uint pgno)
    {
      Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
      Sqlite3.sqlite3PcacheFetch(pPager.pPCache, pgno, 0, ref ppPage);
      return ppPage;
    }

    private static void sqlite3PagerUnref(Sqlite3.PgHdr pPg)
    {
      if (pPg == null)
        return;
      Sqlite3.Pager pPager = pPg.pPager;
      Sqlite3.sqlite3PcacheRelease(pPg);
      Sqlite3.pagerUnlockIfUnused(pPager);
    }

    private static int pager_open_journal(Sqlite3.Pager pPager)
    {
      int num = 0;
      Sqlite3.sqlite3_vfs pVfs = pPager.pVfs;
      if (Sqlite3.NEVER(pPager.errCode) != 0)
        return pPager.errCode;
      if (!Sqlite3.pagerUseWal(pPager) && pPager.journalMode != (byte) 2)
      {
        pPager.pInJournal = Sqlite3.sqlite3BitvecCreate(pPager.dbSize);
        if (!Sqlite3.isOpen(pPager.jfd))
        {
          if (pPager.journalMode == (byte) 4)
          {
            Sqlite3.sqlite3MemJournalOpen(pPager.jfd);
          }
          else
          {
            int flags = 6 | (pPager.tempFile ? 4104 : 2048);
            int pFlagsOut = 0;
            num = Sqlite3.sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, flags, ref pFlagsOut);
          }
        }
        if (num == 0)
        {
          pPager.nRec = 0;
          pPager.journalOff = 0L;
          pPager.setMaster = 0;
          pPager.journalHdr = 0L;
          num = Sqlite3.writeJournalHdr(pPager);
        }
      }
      if (num != 0)
      {
        Sqlite3.sqlite3BitvecDestroy(ref pPager.pInJournal);
        pPager.pInJournal = (Sqlite3.Bitvec) null;
      }
      else
        pPager.eState = (byte) 3;
      return num;
    }

    private static int sqlite3PagerBegin(Sqlite3.Pager pPager, bool exFlag, int subjInMemory)
    {
      int num1 = 0;
      if (pPager.errCode != 0)
        return pPager.errCode;
      pPager.subjInMemory = (byte) subjInMemory;
      if (Sqlite3.ALWAYS(pPager.eState == (byte) 1))
      {
        if (Sqlite3.pagerUseWal(pPager))
        {
          if (pPager.exclusiveMode && Sqlite3.sqlite3WalExclusiveMode((object) pPager.pWal, -1))
          {
            int num2 = Sqlite3.pagerLockDb(pPager, 4);
            if (num2 != 0)
              return num2;
            Sqlite3.sqlite3WalExclusiveMode((object) pPager.pWal, 1);
          }
          num1 = Sqlite3.sqlite3WalBeginWriteTransaction((object) pPager.pWal);
        }
        else
        {
          num1 = Sqlite3.pagerLockDb(pPager, 2);
          if (num1 == 0 & exFlag)
            num1 = Sqlite3.pager_wait_on_lock(pPager, 4);
        }
        if (num1 == 0)
        {
          pPager.eState = (byte) 2;
          pPager.dbHintSize = pPager.dbSize;
          pPager.dbFileSize = pPager.dbSize;
          pPager.dbOrigSize = pPager.dbSize;
          pPager.journalOff = 0L;
        }
      }
      Sqlite3.PAGERTRACE("TRANSACTION %d\n", (object) Sqlite3.PAGERID(pPager));
      return num1;
    }

    private static int pager_write(Sqlite3.PgHdr pPg)
    {
      byte[] pData = pPg.pData;
      Sqlite3.Pager pPager = pPg.pPager;
      int num1 = 0;
      if (Sqlite3.NEVER(pPager.errCode) != 0)
        return pPager.errCode;
      if (Sqlite3.NEVER(pPager.readOnly))
        return 3;
      if (pPager.eState == (byte) 2)
      {
        num1 = Sqlite3.pager_open_journal(pPager);
        if (num1 != 0)
          return num1;
      }
      Sqlite3.sqlite3PcacheMakeDirty(pPg);
      if (!Sqlite3.pageInJournal(pPg) || Sqlite3.subjRequiresPage(pPg))
      {
        if (!Sqlite3.pageInJournal(pPg) && !Sqlite3.pagerUseWal(pPager))
        {
          if (pPg.pgno <= pPager.dbOrigSize && Sqlite3.isOpen(pPager.jfd))
          {
            byte[] O = (byte[]) null;
            long journalOff = pPager.journalOff;
            if (Sqlite3.CODEC2(pPager, pData, pPg.pgno, 7, ref O))
              return 7;
            uint val = Sqlite3.pager_cksum(pPager, O);
            pPg.flags |= 4;
            int num2 = Sqlite3.write32bits(pPager.jfd, journalOff, pPg.pgno);
            if (num2 != 0)
              return num2;
            int num3 = Sqlite3.sqlite3OsWrite(pPager.jfd, O, pPager.pageSize, journalOff + 4L);
            if (num3 != 0)
              return num3;
            int num4 = Sqlite3.write32bits(pPager.jfd, journalOff + (long) pPager.pageSize + 4L, val);
            if (num4 != 0)
              return num4;
            Sqlite3.IOTRACE("JOUT %p %d %lld %d\n", (object) pPager, (object) pPg.pgno, (object) pPager.journalOff, (object) pPager.pageSize);
            Sqlite3.PAGERTRACE("JOURNAL %d page %d needSync=%d hash(%08x)\n", (object) Sqlite3.PAGERID(pPager), (object) pPg.pgno, (object) ((pPg.flags & 4) != 0 ? 1 : 0), (object) Sqlite3.pager_pagehash(pPg));
            pPager.journalOff += (long) (8 + pPager.pageSize);
            ++pPager.nRec;
            int num5 = Sqlite3.sqlite3BitvecSet(pPager.pInJournal, pPg.pgno);
            Sqlite3.testcase<bool>(num5 == 7);
            num1 = num5 | Sqlite3.addToSavepointBitvecs(pPager, pPg.pgno);
            if (num1 != 0)
              return num1;
          }
          else
          {
            if (pPager.eState != (byte) 4)
              pPg.flags |= 4;
            Sqlite3.PAGERTRACE("APPEND %d page %d needSync=%d\n", (object) Sqlite3.PAGERID(pPager), (object) pPg.pgno, (object) ((pPg.flags & 4) != 0 ? 1 : 0));
          }
        }
        if (Sqlite3.subjRequiresPage(pPg))
          num1 = Sqlite3.subjournalPage(pPg);
      }
      if (pPager.dbSize < pPg.pgno)
        pPager.dbSize = pPg.pgno;
      return num1;
    }

    private static int sqlite3PagerWrite(Sqlite3.PgHdr pDbPage)
    {
      int num1 = 0;
      Sqlite3.PgHdr pgHdr = pDbPage;
      Sqlite3.Pager pPager = pgHdr.pPager;
      uint num2 = (uint) ((ulong) pPager.sectorSize / (ulong) pPager.pageSize);
      if (num2 > 1U)
      {
        bool flag = false;
        ++pPager.doNotSyncSpill;
        uint num3 = (uint) (((int) pgHdr.pgno - 1 & ~((int) num2 - 1)) + 1);
        uint dbSize = pPager.dbSize;
        uint num4 = pgHdr.pgno <= dbSize ? ((uint) ((int) num3 + (int) num2 - 1) <= dbSize ? num2 : dbSize + 1U - num3) : (uint) ((int) pgHdr.pgno - (int) num3 + 1);
        for (int index = 0; (long) index < (long) num4 && num1 == 0; ++index)
        {
          uint num5 = (uint) ((ulong) num3 + (ulong) index);
          Sqlite3.PgHdr ppPage = new Sqlite3.PgHdr();
          if ((int) num5 == (int) pgHdr.pgno || Sqlite3.sqlite3BitvecTest(pPager.pInJournal, num5) == 0)
          {
            if ((long) num5 != (long) (Sqlite3.PENDING_BYTE / pPager.pageSize + 1))
            {
              num1 = Sqlite3.sqlite3PagerGet(pPager, num5, ref ppPage);
              if (num1 == 0)
              {
                num1 = Sqlite3.pager_write(ppPage);
                if ((ppPage.flags & 4) != 0)
                  flag = true;
                Sqlite3.sqlite3PagerUnref(ppPage);
              }
            }
          }
          else
          {
            Sqlite3.PgHdr pPg;
            if ((pPg = Sqlite3.pager_lookup(pPager, num5)) != null)
            {
              if ((pPg.flags & 4) != 0)
                flag = true;
              Sqlite3.sqlite3PagerUnref(pPg);
            }
          }
        }
        if (num1 == 0 & flag)
        {
          for (int index = 0; (long) index < (long) num4; ++index)
          {
            Sqlite3.PgHdr pPg = Sqlite3.pager_lookup(pPager, (uint) ((ulong) num3 + (ulong) index));
            if (pPg != null)
            {
              pPg.flags |= 4;
              Sqlite3.sqlite3PagerUnref(pPg);
            }
          }
        }
        --pPager.doNotSyncSpill;
      }
      else
        num1 = Sqlite3.pager_write(pDbPage);
      return num1;
    }

    private static bool sqlite3PagerIswriteable(Sqlite3.PgHdr pPg) => true;

    private static void sqlite3PagerDontWrite(Sqlite3.PgHdr pPg)
    {
      Sqlite3.Pager pPager = pPg.pPager;
      if ((pPg.flags & 2) == 0 || pPager.nSavepoint != 0)
        return;
      Sqlite3.PAGERTRACE("DONT_WRITE page %d of %d\n", (object) pPg.pgno, (object) Sqlite3.PAGERID(pPager));
      Sqlite3.IOTRACE("CLEAN %p %d\n", (object) pPager, (object) pPg.pgno);
      pPg.flags |= 32;
      Sqlite3.pager_set_pagehash(pPg);
    }

    private static int pager_incr_changecounter(Sqlite3.Pager pPager, bool isDirectMode)
    {
      int num1 = 0;
      bool flag = false;
      Sqlite3.UNUSED_PARAMETER<bool>(isDirectMode);
      if (!pPager.changeCountDone && pPager.dbSize > 0U)
      {
        Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
        num1 = Sqlite3.sqlite3PagerGet(pPager, 1U, ref ppPage);
        if (!flag && Sqlite3.ALWAYS(num1 == 0))
          num1 = Sqlite3.sqlite3PagerWrite(ppPage);
        if (num1 == 0)
        {
          Sqlite3.pager_write_changecounter(ppPage);
          if (flag)
          {
            byte[] O = (byte[]) null;
            if (Sqlite3.CODEC2(pPager, ppPage.pData, 1U, 6, ref O))
            {
              int num2;
              return num2 = 7;
            }
            if (num1 == 0)
              num1 = Sqlite3.sqlite3OsWrite(pPager.fd, O, pPager.pageSize, 0L);
            if (num1 == 0)
              pPager.changeCountDone = true;
          }
          else
            pPager.changeCountDone = true;
        }
        Sqlite3.sqlite3PagerUnref(ppPage);
      }
      return num1;
    }

    private static int sqlite3PagerSync(Sqlite3.Pager pPager)
    {
      long pArg = 0;
      if (!pPager.noSync)
        pArg = (long) Sqlite3.sqlite3OsSync(pPager.fd, (int) pPager.syncFlags);
      else if (Sqlite3.isOpen(pPager.fd))
        Sqlite3.sqlite3OsFileControl(pPager.fd, 8U, ref pArg);
      return (int) pArg;
    }

    private static int sqlite3PagerExclusiveLock(Sqlite3.Pager pPager)
    {
      int num = 0;
      if (!Sqlite3.pagerUseWal(pPager))
        num = Sqlite3.pager_wait_on_lock(pPager, 4);
      return num;
    }

    private static int sqlite3PagerCommitPhaseOne(
      Sqlite3.Pager pPager,
      string zMaster,
      bool noSync)
    {
      int num1 = 0;
      if (Sqlite3.NEVER(pPager.errCode != 0))
        return pPager.errCode;
      Sqlite3.PAGERTRACE("DATABASE SYNC: File=%s zMaster=%s nSize=%d\n", (object) pPager.zFilename, (object) zMaster, (object) pPager.dbSize);
      if (pPager.eState < (byte) 3)
        return 0;
      if (pPager.memDb != (byte) 0)
        Sqlite3.sqlite3BackupRestart(pPager.pBackup);
      else if (Sqlite3.pagerUseWal(pPager))
      {
        Sqlite3.PgHdr pgHdr = Sqlite3.sqlite3PcacheDirtyList(pPager.pPCache);
        Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
        if (pgHdr == null)
        {
          num1 = Sqlite3.sqlite3PagerGet(pPager, 1U, ref ppPage);
          pgHdr = ppPage;
          pgHdr.pDirty = (Sqlite3.PgHdr) null;
        }
        if (Sqlite3.ALWAYS<Sqlite3.PgHdr>(pgHdr))
          num1 = Sqlite3.pagerWalFrames(pPager, pgHdr, pPager.dbSize, 1, pPager.fullSync ? (int) pPager.syncFlags : 0);
        Sqlite3.sqlite3PagerUnref(ppPage);
        if (num1 == 0)
          Sqlite3.sqlite3PcacheCleanAll(pPager.pPCache);
      }
      else
      {
        num1 = Sqlite3.pager_incr_changecounter(pPager, false);
        if (num1 == 0)
        {
          if (pPager.dbSize < pPager.dbOrigSize && pPager.journalMode != (byte) 2)
          {
            uint num2 = Sqlite3.PAGER_MJ_PGNO(pPager);
            uint dbSize = pPager.dbSize;
            pPager.dbSize = pPager.dbOrigSize;
            for (uint index = dbSize + 1U; index <= pPager.dbOrigSize; ++index)
            {
              if (Sqlite3.sqlite3BitvecTest(pPager.pInJournal, index) == 0 && (int) index != (int) num2)
              {
                Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
                num1 = Sqlite3.sqlite3PagerGet(pPager, index, ref ppPage);
                if (num1 == 0)
                {
                  num1 = Sqlite3.sqlite3PagerWrite(ppPage);
                  Sqlite3.sqlite3PagerUnref(ppPage);
                  if (num1 != 0)
                    goto label_30;
                }
                else
                  goto label_30;
              }
            }
            pPager.dbSize = dbSize;
          }
          num1 = Sqlite3.writeMasterJournal(pPager, zMaster);
          if (num1 == 0)
          {
            num1 = Sqlite3.syncJournal(pPager, 0);
            if (num1 == 0)
            {
              num1 = Sqlite3.pager_write_pagelist(pPager, Sqlite3.sqlite3PcacheDirtyList(pPager.pPCache));
              if (num1 == 0)
              {
                Sqlite3.sqlite3PcacheCleanAll(pPager.pPCache);
                if ((int) pPager.dbSize != (int) pPager.dbFileSize)
                {
                  uint nPage = (uint) ((long) pPager.dbSize - ((int) pPager.dbSize == (int) Sqlite3.PAGER_MJ_PGNO(pPager) ? 1L : 0L));
                  num1 = Sqlite3.pager_truncate(pPager, nPage);
                  if (num1 != 0)
                    goto label_30;
                }
                if (!noSync)
                  num1 = Sqlite3.sqlite3PagerSync(pPager);
                Sqlite3.IOTRACE("DBSYNC %p\n", (object) pPager);
              }
            }
          }
        }
      }
label_30:
      if (num1 == 0 && !Sqlite3.pagerUseWal(pPager))
        pPager.eState = (byte) 5;
      return num1;
    }

    private static int sqlite3PagerCommitPhaseTwo(Sqlite3.Pager pPager)
    {
      if (Sqlite3.NEVER(pPager.errCode) != 0)
        return pPager.errCode;
      if (pPager.eState == (byte) 2 && pPager.exclusiveMode && pPager.journalMode == (byte) 1)
      {
        pPager.eState = (byte) 1;
        return 0;
      }
      Sqlite3.PAGERTRACE("COMMIT %d\n", (object) Sqlite3.PAGERID(pPager));
      int rc = Sqlite3.pager_end_transaction(pPager, pPager.setMaster);
      return Sqlite3.pager_error(pPager, rc);
    }

    private static int sqlite3PagerRollback(Sqlite3.Pager pPager)
    {
      Sqlite3.PAGERTRACE("ROLLBACK %d\n", (object) Sqlite3.PAGERID(pPager));
      if (pPager.eState == (byte) 6)
        return pPager.errCode;
      if (pPager.eState <= (byte) 1)
        return 0;
      int rc1;
      if (Sqlite3.pagerUseWal(pPager))
      {
        int rc2 = Sqlite3.sqlite3PagerSavepoint(pPager, 2, -1);
        int num = Sqlite3.pager_end_transaction(pPager, pPager.setMaster);
        if (rc2 == 0)
          rc2 = num;
        rc1 = Sqlite3.pager_error(pPager, rc2);
      }
      else if (!Sqlite3.isOpen(pPager.jfd) || pPager.eState == (byte) 2)
      {
        int eState = (int) pPager.eState;
        rc1 = Sqlite3.pager_end_transaction(pPager, 0);
        if (pPager.memDb == (byte) 0 && eState > 2)
        {
          pPager.errCode = 4;
          pPager.eState = (byte) 6;
          return rc1;
        }
      }
      else
        rc1 = Sqlite3.pager_playback(pPager, 0);
      return Sqlite3.pager_error(pPager, rc1);
    }

    private static bool sqlite3PagerIsreadonly(Sqlite3.Pager pPager) => pPager.readOnly;

    private static int sqlite3PagerRefcount(Sqlite3.Pager pPager) => Sqlite3.sqlite3PcacheRefCount(pPager.pPCache);

    private static int sqlite3PagerMemUsed(Sqlite3.Pager pPager) => (pPager.pageSize + (int) pPager.nExtra + 20) * Sqlite3.sqlite3PcachePagecount(pPager.pPCache) + pPager.pageSize;

    private static int sqlite3PagerPageRefcount(Sqlite3.PgHdr pPage) => Sqlite3.sqlite3PcachePageRefcount(pPage);

    private static bool sqlite3PagerIsMemdb(Sqlite3.Pager pPager) => pPager.memDb > (byte) 0;

    private static int sqlite3PagerOpenSavepoint(Sqlite3.Pager pPager, int nSavepoint)
    {
      int num = 0;
      int nSavepoint1 = pPager.nSavepoint;
      if (nSavepoint > nSavepoint1 && pPager.useJournal != (byte) 0)
      {
        Array.Resize<Sqlite3.PagerSavepoint>(ref pPager.aSavepoint, nSavepoint);
        Sqlite3.PagerSavepoint[] aSavepoint = pPager.aSavepoint;
        for (int index = nSavepoint1; index < nSavepoint; ++index)
        {
          aSavepoint[index] = new Sqlite3.PagerSavepoint();
          aSavepoint[index].nOrig = pPager.dbSize;
          aSavepoint[index].iOffset = !Sqlite3.isOpen(pPager.jfd) || pPager.journalOff <= 0L ? (long) (int) Sqlite3.JOURNAL_HDR_SZ(pPager) : pPager.journalOff;
          aSavepoint[index].iSubRec = pPager.nSubRec;
          aSavepoint[index].pInSavepoint = Sqlite3.sqlite3BitvecCreate(pPager.dbSize);
          if (Sqlite3.pagerUseWal(pPager))
            Sqlite3.sqlite3WalSavepoint((object) pPager.pWal, aSavepoint[index].aWalData);
          pPager.nSavepoint = index + 1;
        }
        Sqlite3.assertTruncateConstraint(pPager);
      }
      return num;
    }

    private static int sqlite3PagerSavepoint(Sqlite3.Pager pPager, int op, int iSavepoint)
    {
      int num1 = pPager.errCode;
      if (num1 == 0 && iSavepoint < pPager.nSavepoint)
      {
        int num2 = iSavepoint + (op == 1 ? 0 : 1);
        for (int index = num2; index < pPager.nSavepoint; ++index)
          Sqlite3.sqlite3BitvecDestroy(ref pPager.aSavepoint[index].pInSavepoint);
        pPager.nSavepoint = num2;
        if (op == 1)
        {
          if (num2 == 0 && Sqlite3.isOpen(pPager.sjfd))
          {
            if (Sqlite3.sqlite3IsMemJournal(pPager.sjfd))
              num1 = Sqlite3.sqlite3OsTruncate(pPager.sjfd, 0L);
            pPager.nSubRec = 0U;
          }
        }
        else if (Sqlite3.pagerUseWal(pPager) || Sqlite3.isOpen(pPager.jfd))
        {
          Sqlite3.PagerSavepoint pSavepoint = num2 == 0 ? (Sqlite3.PagerSavepoint) null : pPager.aSavepoint[num2 - 1];
          num1 = Sqlite3.pagerPlaybackSavepoint(pPager, pSavepoint);
        }
      }
      return num1;
    }

    private static string sqlite3PagerFilename(Sqlite3.Pager pPager) => pPager.zFilename;

    private static Sqlite3.sqlite3_vfs sqlite3PagerVfs(Sqlite3.Pager pPager) => pPager.pVfs;

    private static Sqlite3.sqlite3_file sqlite3PagerFile(Sqlite3.Pager pPager) => pPager.fd;

    private static string sqlite3PagerJournalname(Sqlite3.Pager pPager) => pPager.zJournal;

    private static bool sqlite3PagerNosync(Sqlite3.Pager pPager) => pPager.noSync;

    private static void sqlite3PagerSetCodec(
      Sqlite3.Pager pPager,
      Sqlite3.dxCodec xCodec,
      Sqlite3.dxCodecSizeChng xCodecSizeChng,
      Sqlite3.dxCodecFree xCodecFree,
      Sqlite3.codec_ctx pCodec)
    {
      if (pPager.xCodecFree != null)
        pPager.xCodecFree(ref pPager.pCodec);
      pPager.xCodec = pPager.memDb != (byte) 0 ? (Sqlite3.dxCodec) null : xCodec;
      pPager.xCodecSizeChng = xCodecSizeChng;
      pPager.xCodecFree = xCodecFree;
      pPager.pCodec = pCodec;
      Sqlite3.pagerReportSize(pPager);
    }

    private static object sqlite3PagerGetCodec(Sqlite3.Pager pPager) => (object) pPager.pCodec;

    private static int sqlite3PagerMovepage(
      Sqlite3.Pager pPager,
      Sqlite3.PgHdr pPg,
      uint pgno,
      int isCommit)
    {
      uint num1 = 0;
      if (pPager.memDb != (byte) 0)
      {
        int num2 = Sqlite3.sqlite3PagerWrite(pPg);
        if (num2 != 0)
          return num2;
      }
      int num3;
      if ((pPg.flags & 2) != 0 && Sqlite3.subjRequiresPage(pPg) && (num3 = Sqlite3.subjournalPage(pPg)) != 0)
        return num3;
      Sqlite3.PAGERTRACE("MOVE %d page %d (needSync=%d) moves to %d\n", (object) Sqlite3.PAGERID(pPager), (object) pPg.pgno, (object) ((pPg.flags & 4) != 0 ? 1 : 0), (object) pgno);
      Sqlite3.IOTRACE("MOVE %p %d %d\n", (object) pPager, (object) pPg.pgno, (object) pgno);
      if ((pPg.flags & 4) != 0 && isCommit == 0)
        num1 = pPg.pgno;
      pPg.flags &= -5;
      Sqlite3.PgHdr pgHdr = Sqlite3.pager_lookup(pPager, pgno);
      if (pgHdr != null)
      {
        pPg.flags |= pgHdr.flags & 4;
        if (pPager.memDb != (byte) 0)
          Sqlite3.sqlite3PcacheMove(pgHdr, pPager.dbSize + 1U);
        else
          Sqlite3.sqlite3PcacheDrop(pgHdr);
      }
      uint pgno1 = pPg.pgno;
      Sqlite3.sqlite3PcacheMove(pPg, pgno);
      Sqlite3.sqlite3PcacheMakeDirty(pPg);
      if (pPager.memDb != (byte) 0)
      {
        Sqlite3.sqlite3PcacheMove(pgHdr, pgno1);
        Sqlite3.sqlite3PagerUnref(pgHdr);
      }
      if (num1 != 0U)
      {
        Sqlite3.PgHdr ppPage = (Sqlite3.PgHdr) null;
        int num4 = Sqlite3.sqlite3PagerGet(pPager, num1, ref ppPage);
        if (num4 != 0)
        {
          if (num1 <= pPager.dbOrigSize)
          {
            uint[] pBuf = new uint[pPager.pTmpSpace.Length];
            Sqlite3.sqlite3BitvecClear(pPager.pInJournal, num1, pBuf);
          }
          return num4;
        }
        ppPage.flags |= 4;
        Sqlite3.sqlite3PcacheMakeDirty(ppPage);
        Sqlite3.sqlite3PagerUnref(ppPage);
      }
      return 0;
    }

    private static byte[] sqlite3PagerGetData(Sqlite3.PgHdr pPg) => pPg.pData;

    private static Sqlite3.MemPage sqlite3PagerGetExtra(Sqlite3.PgHdr pPg) => pPg.pExtra;

    private static bool sqlite3PagerLockingMode(Sqlite3.Pager pPager, int eMode)
    {
      if (eMode >= 0 && !pPager.tempFile && !Sqlite3.sqlite3WalHeapMemory((object) pPager.pWal))
        pPager.exclusiveMode = eMode != 0;
      return pPager.exclusiveMode;
    }

    private static int sqlite3PagerSetJournalMode(Sqlite3.Pager pPager, int eMode)
    {
      byte journalMode = pPager.journalMode;
      if ((byte) 1 == pPager.memDb && eMode != 4 && eMode != 2)
        eMode = (int) journalMode;
      if (eMode != (int) journalMode)
      {
        pPager.journalMode = (byte) eMode;
        if (!pPager.exclusiveMode && ((int) journalMode & 5) == 1 && (eMode & 1) == 0)
        {
          Sqlite3.sqlite3OsClose(pPager.jfd);
          if (pPager.eLock >= (byte) 2)
          {
            Sqlite3.sqlite3OsDelete(pPager.pVfs, pPager.zJournal, 0);
          }
          else
          {
            int num = 0;
            int eState = (int) pPager.eState;
            if (eState == 0)
              num = Sqlite3.sqlite3PagerSharedLock(pPager);
            if (pPager.eState == (byte) 1)
              num = Sqlite3.pagerLockDb(pPager, 2);
            if (num == 0)
              Sqlite3.sqlite3OsDelete(pPager.pVfs, pPager.zJournal, 0);
            if (num == 0 && eState == 1)
              Sqlite3.pagerUnlockDb(pPager, 1);
            else if (eState == 0)
              Sqlite3.pager_unlock(pPager);
          }
        }
      }
      return (int) pPager.journalMode;
    }

    private static int sqlite3PagerGetJournalMode(Sqlite3.Pager pPager) => (int) pPager.journalMode;

    private static int sqlite3PagerOkToChangeJournalMode(Sqlite3.Pager pPager) => pPager.eState >= (byte) 3 || Sqlite3.NEVER(Sqlite3.isOpen(pPager.jfd) && pPager.journalOff > 0L) ? 0 : 1;

    private static long sqlite3PagerJournalSizeLimit(Sqlite3.Pager pPager, long iLimit)
    {
      if (iLimit >= -1L)
      {
        pPager.journalSizeLimit = iLimit;
        Sqlite3.sqlite3WalLimit(pPager.pWal, iLimit);
      }
      return pPager.journalSizeLimit;
    }

    private static Sqlite3.sqlite3_backup sqlite3PagerBackupPtr(Sqlite3.Pager pPager) => pPager.pBackup;

    private static uint PAGER_MJ_PGNO(Sqlite3.Pager x) => (uint) (Sqlite3.PENDING_BYTE / x.pageSize + 1);

    private static void yytestcase<T>(T X) => Sqlite3.testcase<T>(X);

    private static void spanSet(Sqlite3.ExprSpan pOut, Sqlite3.Token pStart, Sqlite3.Token pEnd)
    {
      pOut.zStart = pStart.z;
      pOut.zEnd = pEnd.z.Substring(pEnd.n);
    }

    private static void spanExpr(
      Sqlite3.ExprSpan pOut,
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.Token pValue)
    {
      pOut.pExpr = Sqlite3.sqlite3PExpr(pParse, op, 0, 0, pValue);
      pOut.zStart = pValue.z;
      pOut.zEnd = pValue.z.Substring(pValue.n);
    }

    private static void spanBinaryExpr(
      Sqlite3.ExprSpan pOut,
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.ExprSpan pLeft,
      Sqlite3.ExprSpan pRight)
    {
      pOut.pExpr = Sqlite3.sqlite3PExpr(pParse, op, pLeft.pExpr, pRight.pExpr, 0);
      pOut.zStart = pLeft.zStart;
      pOut.zEnd = pRight.zEnd;
    }

    private static void spanUnaryPostfix(
      Sqlite3.ExprSpan pOut,
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.ExprSpan pOperand,
      Sqlite3.Token pPostOp)
    {
      pOut.pExpr = Sqlite3.sqlite3PExpr(pParse, op, pOperand.pExpr, 0, 0);
      pOut.zStart = pOperand.zStart;
      pOut.zEnd = pPostOp.z.Substring(pPostOp.n);
    }

    private static void binaryToUnaryIfNull(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pY,
      Sqlite3.Expr pA,
      int op)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pY.op != (byte) 98)
        return;
      pA.op = (byte) op;
      Sqlite3.sqlite3ExprDelete(db, ref pA.pRight);
      pA.pRight = (Sqlite3.Expr) null;
    }

    private static void spanUnaryPrefix(
      Sqlite3.ExprSpan pOut,
      Sqlite3.Parse pParse,
      int op,
      Sqlite3.ExprSpan pOperand,
      Sqlite3.Token pPreOp)
    {
      pOut.pExpr = Sqlite3.sqlite3PExpr(pParse, op, pOperand.pExpr, 0, 0);
      pOut.zStart = pPreOp.z;
      pOut.zEnd = pOperand.zEnd;
    }

    private static Sqlite3.yyParser sqlite3ParserAlloc()
    {
      Sqlite3.yyParser yyParser = new Sqlite3.yyParser();
      if (yyParser != null)
        yyParser.yyidx = -1;
      return yyParser;
    }

    private static void yy_destructor(
      Sqlite3.yyParser yypParser,
      int yymajor,
      Sqlite3.YYMINORTYPE yypminor)
    {
      Sqlite3.Parse pParse = yypParser.pParse;
      switch (yymajor)
      {
        case 160:
        case 194:
          Sqlite3.sqlite3SelectDelete(pParse.db, ref yypminor.yy387);
          break;
        case 174:
        case 175:
          Sqlite3.sqlite3ExprDelete(pParse.db, ref yypminor.yy118.pExpr);
          break;
        case 179:
        case 187:
        case 197:
        case 200:
        case 202:
        case 204:
        case 214:
        case 216:
        case 217:
        case 220:
        case 221:
        case 226:
          Sqlite3.sqlite3ExprListDelete(pParse.db, ref yypminor.yy322);
          break;
        case 193:
        case 198:
        case 206:
        case 207:
          Sqlite3.sqlite3SrcListDelete(pParse.db, ref yypminor.yy259);
          break;
        case 199:
        case 201:
        case 210:
        case 215:
        case 225:
        case 227:
        case 238:
        case 243:
          Sqlite3.sqlite3ExprDelete(pParse.db, ref yypminor.yy314);
          break;
        case 211:
        case 213:
        case 219:
          Sqlite3.sqlite3IdListDelete(pParse.db, ref yypminor.yy384);
          break;
        case 234:
        case 239:
          Sqlite3.sqlite3DeleteTriggerStep(pParse.db, ref yypminor.yy203);
          break;
        case 236:
          Sqlite3.sqlite3IdListDelete(pParse.db, ref yypminor.yy90.b);
          break;
      }
    }

    private static int yy_pop_parser_stack(Sqlite3.yyParser pParser)
    {
      Sqlite3.yyStackEntry yyStackEntry = pParser.yystack[pParser.yyidx];
      if (Sqlite3.NEVER(pParser.yyidx < 0))
        return 0;
      int major = yyStackEntry.major;
      Sqlite3.yy_destructor(pParser, major, yyStackEntry.minor);
      --pParser.yyidx;
      return major;
    }

    private static void sqlite3ParserFree(Sqlite3.yyParser p, Sqlite3.dxDel freeProc)
    {
      Sqlite3.yyParser pParser = p;
      if (Sqlite3.NEVER(pParser == null))
        return;
      while (pParser.yyidx >= 0)
        Sqlite3.yy_pop_parser_stack(pParser);
    }

    private static int yy_find_shift_action(Sqlite3.yyParser pParser, int iLookAhead)
    {
      int stateno = pParser.yystack[pParser.yyidx].stateno;
      int num;
      if (stateno > 418 || (num = (int) Sqlite3.yy_shift_ofst[stateno]) == -74)
        return Sqlite3.yy_default[stateno];
      int index1 = num + iLookAhead;
      if (index1 >= 0 && index1 < 1557 && Sqlite3.yy_lookahead[index1] == iLookAhead)
        return Sqlite3.yy_action[index1];
      if (iLookAhead > 0)
      {
        int iLookAhead1;
        if (iLookAhead < Sqlite3.yyFallback.Length && (iLookAhead1 = Sqlite3.yyFallback[iLookAhead]) != 0)
          return Sqlite3.yy_find_shift_action(pParser, iLookAhead1);
        int index2 = index1 - iLookAhead + 67;
        if (index2 >= 0 && index2 < 1557 && Sqlite3.yy_lookahead[index2] == 67)
          return Sqlite3.yy_action[index2];
      }
      return Sqlite3.yy_default[stateno];
    }

    private static int yy_find_reduce_action(int stateno, int iLookAhead)
    {
      int index = (int) Sqlite3.yy_reduce_ofst[stateno] + iLookAhead;
      return Sqlite3.yy_action[index];
    }

    private static void yyStackOverflow(Sqlite3.yyParser yypParser, Sqlite3.YYMINORTYPE yypMinor)
    {
      Sqlite3.Parse pParse = yypParser.pParse;
      --yypParser.yyidx;
      while (yypParser.yyidx >= 0)
        Sqlite3.yy_pop_parser_stack(yypParser);
      Sqlite3.UNUSED_PARAMETER<Sqlite3.YYMINORTYPE>(yypMinor);
      Sqlite3.sqlite3ErrorMsg(pParse, "parser stack overflow");
      pParse.parseError = (byte) 1;
      yypParser.pParse = pParse;
    }

    private static void yy_shift(
      Sqlite3.yyParser yypParser,
      int yyNewState,
      int yyMajor,
      Sqlite3.YYMINORTYPE yypMinor)
    {
      Sqlite3.yyStackEntry yyStackEntry = new Sqlite3.yyStackEntry();
      ++yypParser.yyidx;
      if (yypParser.yyidx >= 100)
      {
        Sqlite3.yyStackOverflow(yypParser, yypMinor);
      }
      else
      {
        yypParser.yystack[yypParser.yyidx] = yyStackEntry;
        yyStackEntry.stateno = yyNewState;
        yyStackEntry.major = yyMajor;
        yyStackEntry.minor = yypMinor;
      }
    }

    private static void yy_reduce(Sqlite3.yyParser yypParser, int yyruleno)
    {
      Sqlite3.Parse pParse = yypParser.pParse;
      Sqlite3.yymsp yymsp = new Sqlite3.yymsp(ref yypParser, yypParser.yyidx);
      Sqlite3.YYMINORTYPE yypMinor = new Sqlite3.YYMINORTYPE();
      switch (yyruleno)
      {
        case 5:
          Sqlite3.sqlite3BeginParse(pParse, 0);
          break;
        case 6:
          Sqlite3.sqlite3BeginParse(pParse, 1);
          break;
        case 7:
          Sqlite3.sqlite3BeginParse(pParse, 2);
          break;
        case 8:
          Sqlite3.sqlite3FinishCoding(pParse);
          break;
        case 9:
          Sqlite3.sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy4);
          break;
        case 13:
          yypMinor.yy4 = 7;
          break;
        case 14:
        case 15:
        case 16:
        case 115:
        case 117:
          yypMinor.yy4 = yymsp[0].major;
          break;
        case 17:
        case 18:
          Sqlite3.sqlite3CommitTransaction(pParse);
          break;
        case 19:
          Sqlite3.sqlite3RollbackTransaction(pParse);
          break;
        case 22:
          Sqlite3.sqlite3Savepoint(pParse, 0, yymsp[0].minor.yy0);
          break;
        case 23:
          Sqlite3.sqlite3Savepoint(pParse, 1, yymsp[0].minor.yy0);
          break;
        case 24:
          Sqlite3.sqlite3Savepoint(pParse, 2, yymsp[0].minor.yy0);
          break;
        case 26:
          Sqlite3.sqlite3StartTable(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, yymsp[-4].minor.yy4, 0, 0, yymsp[-2].minor.yy4);
          break;
        case 27:
          pParse.db.lookaside.bEnabled = (byte) 0;
          yypMinor.yy0 = yymsp[0].minor.yy0;
          break;
        case 28:
        case 31:
        case 70:
        case 83:
        case 85:
        case 87:
        case 98:
        case 109:
        case 120:
        case 121:
        case 222:
        case 225:
          yypMinor.yy4 = 0;
          break;
        case 29:
        case 30:
        case 71:
        case 86:
        case 108:
        case 119:
        case 223:
        case 226:
          yypMinor.yy4 = 1;
          break;
        case 32:
          Sqlite3.sqlite3EndTable(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, 0);
          break;
        case 33:
          Sqlite3.sqlite3EndTable(pParse, 0, 0, yymsp[0].minor.yy387);
          Sqlite3.sqlite3SelectDelete(pParse.db, ref yymsp[0].minor.yy387);
          break;
        case 36:
          yypMinor.yy0.n = yymsp[-2].minor.yy0.z.Length - pParse.sLastToken.z.Length + pParse.sLastToken.n;
          yypMinor.yy0.z = yymsp[-2].minor.yy0.z.Substring(0, yypMinor.yy0.n);
          break;
        case 37:
          Sqlite3.sqlite3AddColumn(pParse, yymsp[0].minor.yy0);
          yypMinor.yy0 = yymsp[0].minor.yy0;
          break;
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 46:
        case 49:
        case (int) sbyte.MaxValue:
        case 128:
        case 138:
        case 147:
        case 251:
        case 260:
        case 261:
        case 262:
        case 263:
        case 264:
        case 265:
        case 266:
        case 267:
        case 285:
          yypMinor.yy0 = yymsp[0].minor.yy0;
          break;
        case 45:
          Sqlite3.sqlite3AddColumnType(pParse, yymsp[0].minor.yy0);
          break;
        case 47:
          yypMinor.yy0.n = yymsp[-3].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length + yymsp[0].minor.yy0.n;
          yypMinor.yy0.z = yymsp[-3].minor.yy0.z.Substring(0, yypMinor.yy0.n);
          break;
        case 48:
          yypMinor.yy0.n = yymsp[-5].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length + 1;
          yypMinor.yy0.z = yymsp[-5].minor.yy0.z.Substring(0, yypMinor.yy0.n);
          break;
        case 50:
          yypMinor.yy0.z = yymsp[-1].minor.yy0.z;
          yypMinor.yy0.n = yymsp[0].minor.yy0.n + (yymsp[-1].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length);
          break;
        case 57:
        case 59:
          Sqlite3.sqlite3AddDefaultValue(pParse, yymsp[0].minor.yy118);
          break;
        case 58:
          Sqlite3.sqlite3AddDefaultValue(pParse, yymsp[-1].minor.yy118);
          break;
        case 60:
          Sqlite3.sqlite3AddDefaultValue(pParse, new Sqlite3.ExprSpan()
          {
            pExpr = Sqlite3.sqlite3PExpr(pParse, 156, yymsp[0].minor.yy118.pExpr, 0, 0),
            zStart = yymsp[-1].minor.yy0.z,
            zEnd = yymsp[0].minor.yy118.zEnd
          });
          break;
        case 61:
          Sqlite3.ExprSpan exprSpan = new Sqlite3.ExprSpan();
          Sqlite3.spanExpr(exprSpan, pParse, 94, yymsp[0].minor.yy0);
          Sqlite3.sqlite3AddDefaultValue(pParse, exprSpan);
          break;
        case 63:
          Sqlite3.sqlite3AddNotNull(pParse, yymsp[0].minor.yy4);
          break;
        case 64:
          Sqlite3.sqlite3AddPrimaryKey(pParse, 0, yymsp[-1].minor.yy4, yymsp[0].minor.yy4, yymsp[-2].minor.yy4);
          break;
        case 65:
          Sqlite3.sqlite3CreateIndex(pParse, 0, 0, 0, 0, yymsp[0].minor.yy4, 0, 0, 0, 0);
          break;
        case 66:
          Sqlite3.sqlite3AddCheckConstraint(pParse, yymsp[-1].minor.yy118.pExpr);
          break;
        case 67:
          Sqlite3.sqlite3CreateForeignKey(pParse, 0, yymsp[-2].minor.yy0, yymsp[-1].minor.yy322, yymsp[0].minor.yy4);
          break;
        case 68:
          Sqlite3.sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy4);
          break;
        case 69:
          Sqlite3.sqlite3AddCollateType(pParse, yymsp[0].minor.yy0);
          break;
        case 72:
          yypMinor.yy4 = 0;
          break;
        case 73:
          yypMinor.yy4 = yymsp[-1].minor.yy4 & ~yymsp[0].minor.yy215.mask | yymsp[0].minor.yy215.value;
          break;
        case 74:
        case 75:
          yypMinor.yy215.value = 0;
          yypMinor.yy215.mask = 0;
          break;
        case 76:
          yypMinor.yy215.value = yymsp[0].minor.yy4;
          yypMinor.yy215.mask = (int) byte.MaxValue;
          break;
        case 77:
          yypMinor.yy215.value = yymsp[0].minor.yy4 << 8;
          yypMinor.yy215.mask = 65280;
          break;
        case 78:
          yypMinor.yy4 = 7;
          break;
        case 79:
          yypMinor.yy4 = 8;
          break;
        case 80:
          yypMinor.yy4 = 9;
          break;
        case 81:
          yypMinor.yy4 = 6;
          break;
        case 82:
          yypMinor.yy4 = 0;
          break;
        case 84:
        case 99:
        case 101:
        case 104:
          yypMinor.yy4 = yymsp[0].minor.yy4;
          break;
        case 88:
          yypMinor.yy0.n = 0;
          yypMinor.yy0.z = (string) null;
          break;
        case 89:
          yypMinor.yy0 = yymsp[-1].minor.yy0;
          break;
        case 94:
          Sqlite3.sqlite3AddPrimaryKey(pParse, yymsp[-3].minor.yy322, yymsp[0].minor.yy4, yymsp[-2].minor.yy4, 0);
          break;
        case 95:
          Sqlite3.sqlite3CreateIndex(pParse, 0, 0, 0, yymsp[-2].minor.yy322, yymsp[0].minor.yy4, 0, 0, 0, 0);
          break;
        case 96:
          Sqlite3.sqlite3AddCheckConstraint(pParse, yymsp[-2].minor.yy118.pExpr);
          break;
        case 97:
          Sqlite3.sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy322, yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy4);
          Sqlite3.sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy4);
          break;
        case 100:
          yypMinor.yy4 = 99;
          break;
        case 102:
          yypMinor.yy210 = (byte) 99;
          break;
        case 103:
          yypMinor.yy210 = (byte) yymsp[0].minor.yy4;
          break;
        case 105:
          yypMinor.yy4 = 4;
          break;
        case 106:
          yypMinor.yy4 = 5;
          break;
        case 107:
          Sqlite3.sqlite3DropTable(pParse, yymsp[0].minor.yy259, 0, yymsp[-1].minor.yy4);
          break;
        case 110:
          Sqlite3.sqlite3CreateView(pParse, yymsp[-7].minor.yy0, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy387, yymsp[-6].minor.yy4, yymsp[-4].minor.yy4);
          break;
        case 111:
          Sqlite3.sqlite3DropTable(pParse, yymsp[0].minor.yy259, 1, yymsp[-1].minor.yy4);
          break;
        case 112:
          Sqlite3.SelectDest pDest = new Sqlite3.SelectDest((byte) 5, char.MinValue, 0, 0, 0);
          Sqlite3.sqlite3Select(pParse, yymsp[0].minor.yy387, ref pDest);
          Sqlite3.sqlite3SelectDelete(pParse.db, ref yymsp[0].minor.yy387);
          break;
        case 113:
          yypMinor.yy387 = yymsp[0].minor.yy387;
          break;
        case 114:
          if (yymsp[0].minor.yy387 != null)
          {
            yymsp[0].minor.yy387.op = (byte) yymsp[-1].minor.yy4;
            yymsp[0].minor.yy387.pPrior = yymsp[-2].minor.yy387;
          }
          else
            Sqlite3.sqlite3SelectDelete(pParse.db, ref yymsp[-2].minor.yy387);
          yypMinor.yy387 = yymsp[0].minor.yy387;
          break;
        case 116:
          yypMinor.yy4 = 113;
          break;
        case 118:
          yypMinor.yy387 = Sqlite3.sqlite3SelectNew(pParse, yymsp[-6].minor.yy322, yymsp[-5].minor.yy259, yymsp[-4].minor.yy314, yymsp[-3].minor.yy322, yymsp[-2].minor.yy314, yymsp[-1].minor.yy322, yymsp[-7].minor.yy4, yymsp[0].minor.yy292.pLimit, yymsp[0].minor.yy292.pOffset);
          break;
        case 122:
        case 247:
          yypMinor.yy322 = yymsp[-1].minor.yy322;
          break;
        case 123:
        case 151:
        case 159:
        case 240:
        case 246:
          yypMinor.yy322 = (Sqlite3.ExprList) null;
          break;
        case 124:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[-1].minor.yy118.pExpr);
          if (yymsp[0].minor.yy0.n > 0)
            Sqlite3.sqlite3ExprListSetName(pParse, yypMinor.yy322, yymsp[0].minor.yy0, 1);
          Sqlite3.sqlite3ExprListSetSpan(pParse, yypMinor.yy322, yymsp[-1].minor.yy118);
          break;
        case 125:
          Sqlite3.Expr pExpr1 = Sqlite3.sqlite3Expr(pParse.db, 113, (string) null);
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy322, pExpr1);
          break;
        case 126:
          Sqlite3.Expr pRight1 = Sqlite3.sqlite3PExpr(pParse, 113, 0, 0, yymsp[0].minor.yy0);
          Sqlite3.Expr pLeft1 = Sqlite3.sqlite3PExpr(pParse, 26, 0, 0, yymsp[-2].minor.yy0);
          Sqlite3.Expr pExpr2 = Sqlite3.sqlite3PExpr(pParse, 118, pLeft1, pRight1, 0);
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, pExpr2);
          break;
        case 129:
          yypMinor.yy0.n = 0;
          break;
        case 130:
          yypMinor.yy259 = new Sqlite3.SrcList();
          break;
        case 131:
          yypMinor.yy259 = yymsp[0].minor.yy259;
          Sqlite3.sqlite3SrcListShiftJoinType(yypMinor.yy259);
          break;
        case 132:
          yypMinor.yy259 = yymsp[-1].minor.yy259;
          if (Sqlite3.ALWAYS(yypMinor.yy259 != null && yypMinor.yy259.nSrc > (short) 0))
          {
            yypMinor.yy259.a[(int) yypMinor.yy259.nSrc - 1].jointype = (byte) yymsp[0].minor.yy4;
            break;
          }
          break;
        case 133:
          yypMinor.yy259 = (Sqlite3.SrcList) null;
          break;
        case 134:
          yypMinor.yy259 = Sqlite3.sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy259, yymsp[-5].minor.yy0, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, 0, yymsp[-1].minor.yy314, yymsp[0].minor.yy384);
          Sqlite3.sqlite3SrcListIndexedBy(pParse, yypMinor.yy259, yymsp[-2].minor.yy0);
          break;
        case 135:
          yypMinor.yy259 = Sqlite3.sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy259, 0, 0, yymsp[-2].minor.yy0, yymsp[-4].minor.yy387, yymsp[-1].minor.yy314, yymsp[0].minor.yy384);
          break;
        case 136:
          if (yymsp[-6].minor.yy259 == null && yymsp[-2].minor.yy0.n == 0 && yymsp[-1].minor.yy314 == null && yymsp[0].minor.yy384 == null)
          {
            yypMinor.yy259 = yymsp[-4].minor.yy259;
            break;
          }
          Sqlite3.sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy259);
          Sqlite3.Select pSubquery = Sqlite3.sqlite3SelectNew(pParse, 0, yymsp[-4].minor.yy259, 0, 0, 0, 0, 0, 0, 0);
          yypMinor.yy259 = Sqlite3.sqlite3SrcListAppendFromTerm(pParse, yymsp[-6].minor.yy259, 0, 0, yymsp[-2].minor.yy0, pSubquery, yymsp[-1].minor.yy314, yymsp[0].minor.yy384);
          break;
        case 137:
        case 146:
          yypMinor.yy0.z = (string) null;
          yypMinor.yy0.n = 0;
          break;
        case 139:
          yypMinor.yy259 = Sqlite3.sqlite3SrcListAppend(pParse.db, 0, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 140:
          yypMinor.yy4 = 1;
          break;
        case 141:
          yypMinor.yy4 = Sqlite3.sqlite3JoinType(pParse, yymsp[-1].minor.yy0, 0, 0);
          break;
        case 142:
          yypMinor.yy4 = Sqlite3.sqlite3JoinType(pParse, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0, 0);
          break;
        case 143:
          yypMinor.yy4 = Sqlite3.sqlite3JoinType(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[-1].minor.yy0);
          break;
        case 144:
        case 155:
        case 162:
        case 169:
        case 235:
        case 237:
          yypMinor.yy314 = yymsp[0].minor.yy118.pExpr;
          break;
        case 145:
        case 161:
        case 168:
        case 236:
        case 238:
          yypMinor.yy314 = (Sqlite3.Expr) null;
          break;
        case 148:
          yypMinor.yy0.z = (string) null;
          yypMinor.yy0.n = 1;
          break;
        case 149:
        case 181:
          yypMinor.yy384 = yymsp[-1].minor.yy384;
          break;
        case 150:
        case 180:
          yypMinor.yy384 = (Sqlite3.IdList) null;
          break;
        case 152:
        case 160:
        case 239:
          yypMinor.yy322 = yymsp[0].minor.yy322;
          break;
        case 153:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, yymsp[-1].minor.yy314);
          if (yypMinor.yy322 != null)
          {
            yypMinor.yy322.a[yypMinor.yy322.nExpr - 1].sortOrder = (byte) yymsp[0].minor.yy4;
            break;
          }
          break;
        case 154:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[-1].minor.yy314);
          if (yypMinor.yy322 != null && Sqlite3.ALWAYS(yypMinor.yy322.a != null))
          {
            yypMinor.yy322.a[0].sortOrder = (byte) yymsp[0].minor.yy4;
            break;
          }
          break;
        case 156:
        case 158:
          yypMinor.yy4 = 0;
          break;
        case 157:
          yypMinor.yy4 = 1;
          break;
        case 163:
          yypMinor.yy292.pLimit = (Sqlite3.Expr) null;
          yypMinor.yy292.pOffset = (Sqlite3.Expr) null;
          break;
        case 164:
          yypMinor.yy292.pLimit = yymsp[0].minor.yy118.pExpr;
          yypMinor.yy292.pOffset = (Sqlite3.Expr) null;
          break;
        case 165:
          yypMinor.yy292.pLimit = yymsp[-2].minor.yy118.pExpr;
          yypMinor.yy292.pOffset = yymsp[0].minor.yy118.pExpr;
          break;
        case 166:
          yypMinor.yy292.pOffset = yymsp[-2].minor.yy118.pExpr;
          yypMinor.yy292.pLimit = yymsp[0].minor.yy118.pExpr;
          break;
        case 167:
          Sqlite3.sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy259, yymsp[-1].minor.yy0);
          Sqlite3.sqlite3DeleteFrom(pParse, yymsp[-2].minor.yy259, yymsp[0].minor.yy314);
          break;
        case 170:
          Sqlite3.sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy259, yymsp[-3].minor.yy0);
          Sqlite3.sqlite3ExprListCheckLength(pParse, yymsp[-1].minor.yy322, "set list");
          Sqlite3.sqlite3Update(pParse, yymsp[-4].minor.yy259, yymsp[-1].minor.yy322, yymsp[0].minor.yy314, (int) yymsp[-5].minor.yy210);
          break;
        case 171:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy118.pExpr);
          Sqlite3.sqlite3ExprListSetName(pParse, yypMinor.yy322, yymsp[-2].minor.yy0, 1);
          break;
        case 172:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy118.pExpr);
          Sqlite3.sqlite3ExprListSetName(pParse, yypMinor.yy322, yymsp[-2].minor.yy0, 1);
          break;
        case 173:
          Sqlite3.sqlite3Insert(pParse, yymsp[-5].minor.yy259, yymsp[-1].minor.yy322, 0, yymsp[-4].minor.yy384, (int) yymsp[-7].minor.yy210);
          break;
        case 174:
          Sqlite3.sqlite3Insert(pParse, yymsp[-2].minor.yy259, 0, yymsp[0].minor.yy387, yymsp[-1].minor.yy384, (int) yymsp[-4].minor.yy210);
          break;
        case 175:
          Sqlite3.sqlite3Insert(pParse, yymsp[-3].minor.yy259, 0, 0, yymsp[-2].minor.yy384, (int) yymsp[-5].minor.yy210);
          break;
        case 176:
          yypMinor.yy210 = yymsp[0].minor.yy210;
          break;
        case 177:
          yypMinor.yy210 = (byte) 5;
          break;
        case 178:
        case 241:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[0].minor.yy118.pExpr);
          break;
        case 179:
        case 242:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy118.pExpr);
          break;
        case 182:
          yypMinor.yy384 = Sqlite3.sqlite3IdListAppend(pParse.db, yymsp[-2].minor.yy384, yymsp[0].minor.yy0);
          break;
        case 183:
          yypMinor.yy384 = Sqlite3.sqlite3IdListAppend(pParse.db, 0, yymsp[0].minor.yy0);
          break;
        case 184:
          yypMinor.yy118 = yymsp[0].minor.yy118;
          break;
        case 185:
          yypMinor.yy118.pExpr = yymsp[-1].minor.yy118.pExpr;
          Sqlite3.spanSet(yypMinor.yy118, yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 186:
        case 191:
        case 192:
          Sqlite3.spanExpr(yypMinor.yy118, pParse, yymsp[0].major, yymsp[0].minor.yy0);
          break;
        case 187:
        case 188:
          Sqlite3.spanExpr(yypMinor.yy118, pParse, 26, yymsp[0].minor.yy0);
          break;
        case 189:
          Sqlite3.Expr pLeft2 = Sqlite3.sqlite3PExpr(pParse, 26, 0, 0, yymsp[-2].minor.yy0);
          Sqlite3.Expr pRight2 = Sqlite3.sqlite3PExpr(pParse, 26, 0, 0, yymsp[0].minor.yy0);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 118, pLeft2, pRight2, 0);
          Sqlite3.spanSet(yypMinor.yy118, yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 190:
          Sqlite3.Expr pLeft3 = Sqlite3.sqlite3PExpr(pParse, 26, 0, 0, yymsp[-4].minor.yy0);
          Sqlite3.Expr pLeft4 = Sqlite3.sqlite3PExpr(pParse, 26, 0, 0, yymsp[-2].minor.yy0);
          Sqlite3.Expr pRight3 = Sqlite3.sqlite3PExpr(pParse, 26, 0, 0, yymsp[0].minor.yy0);
          Sqlite3.Expr pRight4 = Sqlite3.sqlite3PExpr(pParse, 118, pLeft4, pRight3, 0);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 118, pLeft3, pRight4, 0);
          Sqlite3.spanSet(yypMinor.yy118, yymsp[-4].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 193:
          if (pParse.nested == (byte) 0)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", (object) yymsp[0].minor.yy0);
            yypMinor.yy118.pExpr = (Sqlite3.Expr) null;
          }
          else
          {
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 132, 0, 0, yymsp[0].minor.yy0);
            if (yypMinor.yy118.pExpr != null)
              Sqlite3.sqlite3GetInt32(yymsp[0].minor.yy0.z, 1, ref yypMinor.yy118.pExpr.iTable);
          }
          Sqlite3.spanSet(yypMinor.yy118, yymsp[0].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 194:
          Sqlite3.spanExpr(yypMinor.yy118, pParse, 133, yymsp[0].minor.yy0);
          Sqlite3.sqlite3ExprAssignVarNumber(pParse, yypMinor.yy118.pExpr);
          Sqlite3.spanSet(yypMinor.yy118, yymsp[0].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 195:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3ExprSetCollByToken(pParse, yymsp[-2].minor.yy118.pExpr, yymsp[0].minor.yy0);
          yypMinor.yy118.zStart = yymsp[-2].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 196:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 37, yymsp[-3].minor.yy118.pExpr, 0, yymsp[-1].minor.yy0);
          Sqlite3.spanSet(yypMinor.yy118, yymsp[-5].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 197:
          if (yymsp[-1].minor.yy322 != null && yymsp[-1].minor.yy322.nExpr > pParse.db.aLimit[6])
            Sqlite3.sqlite3ErrorMsg(pParse, "too many arguments on function %T", (object) yymsp[-4].minor.yy0);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3ExprFunction(pParse, yymsp[-1].minor.yy322, yymsp[-4].minor.yy0);
          Sqlite3.spanSet(yypMinor.yy118, yymsp[-4].minor.yy0, yymsp[0].minor.yy0);
          if (yymsp[-2].minor.yy4 != 0 && yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.flags |= (ushort) 16;
            break;
          }
          break;
        case 198:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3ExprFunction(pParse, 0, yymsp[-3].minor.yy0);
          Sqlite3.spanSet(yypMinor.yy118, yymsp[-3].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 199:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3ExprFunction(pParse, 0, yymsp[0].minor.yy0);
          if (yypMinor.yy118.pExpr != null)
            yypMinor.yy118.pExpr.op = (byte) 155;
          Sqlite3.spanSet(yypMinor.yy118, yymsp[0].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 200:
        case 201:
        case 202:
        case 203:
        case 204:
        case 205:
        case 206:
        case 207:
          Sqlite3.spanBinaryExpr(yypMinor.yy118, pParse, yymsp[-1].major, yymsp[-2].minor.yy118, yymsp[0].minor.yy118);
          break;
        case 208:
        case 210:
          yypMinor.yy342.eOperator = yymsp[0].minor.yy0;
          yypMinor.yy342.not = false;
          break;
        case 209:
        case 211:
          yypMinor.yy342.eOperator = yymsp[0].minor.yy0;
          yypMinor.yy342.not = true;
          break;
        case 212:
          Sqlite3.ExprList pList1 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy118.pExpr);
          Sqlite3.ExprList pList2 = Sqlite3.sqlite3ExprListAppend(pParse, pList1, yymsp[-2].minor.yy118.pExpr);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3ExprFunction(pParse, pList2, yymsp[-1].minor.yy342.eOperator);
          if (yymsp[-1].minor.yy342.not)
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 19, yypMinor.yy118.pExpr, 0, 0);
          yypMinor.yy118.zStart = yymsp[-2].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;
          if (yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.flags |= (ushort) 128;
            break;
          }
          break;
        case 213:
          Sqlite3.ExprList pList3 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy118.pExpr);
          Sqlite3.ExprList pList4 = Sqlite3.sqlite3ExprListAppend(pParse, pList3, yymsp[-4].minor.yy118.pExpr);
          Sqlite3.ExprList pList5 = Sqlite3.sqlite3ExprListAppend(pParse, pList4, yymsp[0].minor.yy118.pExpr);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3ExprFunction(pParse, pList5, yymsp[-3].minor.yy342.eOperator);
          if (yymsp[-3].minor.yy342.not)
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 19, yypMinor.yy118.pExpr, 0, 0);
          yypMinor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;
          if (yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.flags |= (ushort) 128;
            break;
          }
          break;
        case 214:
          Sqlite3.spanUnaryPostfix(yypMinor.yy118, pParse, yymsp[0].major, yymsp[-1].minor.yy118, yymsp[0].minor.yy0);
          break;
        case 215:
          Sqlite3.spanUnaryPostfix(yypMinor.yy118, pParse, 74, yymsp[-2].minor.yy118, yymsp[0].minor.yy0);
          break;
        case 216:
          Sqlite3.spanBinaryExpr(yypMinor.yy118, pParse, 70, yymsp[-2].minor.yy118, yymsp[0].minor.yy118);
          Sqlite3.binaryToUnaryIfNull(pParse, yymsp[0].minor.yy118.pExpr, yypMinor.yy118.pExpr, 73);
          break;
        case 217:
          Sqlite3.spanBinaryExpr(yypMinor.yy118, pParse, 146, yymsp[-3].minor.yy118, yymsp[0].minor.yy118);
          Sqlite3.binaryToUnaryIfNull(pParse, yymsp[0].minor.yy118.pExpr, yypMinor.yy118.pExpr, 74);
          break;
        case 218:
        case 219:
          Sqlite3.spanUnaryPrefix(yypMinor.yy118, pParse, yymsp[-1].major, yymsp[0].minor.yy118, yymsp[-1].minor.yy0);
          break;
        case 220:
          Sqlite3.spanUnaryPrefix(yypMinor.yy118, pParse, 156, yymsp[0].minor.yy118, yymsp[-1].minor.yy0);
          break;
        case 221:
          Sqlite3.spanUnaryPrefix(yypMinor.yy118, pParse, 157, yymsp[0].minor.yy118, yymsp[-1].minor.yy0);
          break;
        case 224:
          Sqlite3.ExprList pList6 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy118.pExpr);
          Sqlite3.ExprList pList7 = Sqlite3.sqlite3ExprListAppend(pParse, pList6, yymsp[0].minor.yy118.pExpr);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 71, yymsp[-4].minor.yy118.pExpr, 0, 0);
          if (yypMinor.yy118.pExpr != null)
            yypMinor.yy118.pExpr.x.pList = pList7;
          else
            Sqlite3.sqlite3ExprListDelete(pParse.db, ref pList7);
          if (yymsp[-3].minor.yy4 != 0)
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 19, yypMinor.yy118.pExpr, 0, 0);
          yypMinor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;
          break;
        case 227:
          if (yymsp[-1].minor.yy322 == null)
          {
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 129, 0, 0, Sqlite3.sqlite3IntTokens[yymsp[-3].minor.yy4]);
            Sqlite3.sqlite3ExprDelete(pParse.db, ref yymsp[-4].minor.yy118.pExpr);
          }
          else
          {
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 72, yymsp[-4].minor.yy118.pExpr, 0, 0);
            if (yypMinor.yy118.pExpr != null)
            {
              yypMinor.yy118.pExpr.x.pList = yymsp[-1].minor.yy322;
              Sqlite3.sqlite3ExprSetHeight(pParse, yypMinor.yy118.pExpr);
            }
            else
              Sqlite3.sqlite3ExprListDelete(pParse.db, ref yymsp[-1].minor.yy322);
            if (yymsp[-3].minor.yy4 != 0)
              yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 19, yypMinor.yy118.pExpr, 0, 0);
          }
          yypMinor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 228:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 116, 0, 0, 0);
          if (yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.x.pSelect = yymsp[-1].minor.yy387;
            Sqlite3.ExprSetProperty(yypMinor.yy118.pExpr, 2048);
            Sqlite3.sqlite3ExprSetHeight(pParse, yypMinor.yy118.pExpr);
          }
          else
            Sqlite3.sqlite3SelectDelete(pParse.db, ref yymsp[-1].minor.yy387);
          yypMinor.yy118.zStart = yymsp[-2].minor.yy0.z;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 229:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 72, yymsp[-4].minor.yy118.pExpr, 0, 0);
          if (yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.x.pSelect = yymsp[-1].minor.yy387;
            Sqlite3.ExprSetProperty(yypMinor.yy118.pExpr, 2048);
            Sqlite3.sqlite3ExprSetHeight(pParse, yypMinor.yy118.pExpr);
          }
          else
            Sqlite3.sqlite3SelectDelete(pParse.db, ref yymsp[-1].minor.yy387);
          if (yymsp[-3].minor.yy4 != 0)
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 19, yypMinor.yy118.pExpr, 0, 0);
          yypMinor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 230:
          Sqlite3.SrcList pList8 = Sqlite3.sqlite3SrcListAppend(pParse.db, 0, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 72, yymsp[-3].minor.yy118.pExpr, 0, 0);
          if (yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.x.pSelect = Sqlite3.sqlite3SelectNew(pParse, 0, pList8, 0, 0, 0, 0, 0, 0, 0);
            Sqlite3.ExprSetProperty(yypMinor.yy118.pExpr, 2048);
            Sqlite3.sqlite3ExprSetHeight(pParse, yypMinor.yy118.pExpr);
          }
          else
            Sqlite3.sqlite3SrcListDelete(pParse.db, ref pList8);
          if (yymsp[-2].minor.yy4 != 0)
            yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 19, yypMinor.yy118.pExpr, 0, 0);
          yypMinor.yy118.zStart = yymsp[-3].minor.yy118.zStart;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z != null ? yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n) : yymsp[-1].minor.yy0.z.Substring(yymsp[-1].minor.yy0.n);
          break;
        case 231:
          Sqlite3.Expr expr = yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 20, 0, 0, 0);
          if (expr != null)
          {
            expr.x.pSelect = yymsp[-1].minor.yy387;
            Sqlite3.ExprSetProperty(expr, 2048);
            Sqlite3.sqlite3ExprSetHeight(pParse, expr);
          }
          else
            Sqlite3.sqlite3SelectDelete(pParse.db, ref yymsp[-1].minor.yy387);
          yypMinor.yy118.zStart = yymsp[-3].minor.yy0.z;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 232:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 134, yymsp[-3].minor.yy314, yymsp[-1].minor.yy314, 0);
          if (yypMinor.yy118.pExpr != null)
          {
            yypMinor.yy118.pExpr.x.pList = yymsp[-2].minor.yy322;
            Sqlite3.sqlite3ExprSetHeight(pParse, yypMinor.yy118.pExpr);
          }
          else
            Sqlite3.sqlite3ExprListDelete(pParse.db, ref yymsp[-2].minor.yy322);
          yypMinor.yy118.zStart = yymsp[-4].minor.yy0.z;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 233:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy118.pExpr);
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yypMinor.yy322, yymsp[0].minor.yy118.pExpr);
          break;
        case 234:
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy118.pExpr);
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yypMinor.yy322, yymsp[0].minor.yy118.pExpr);
          break;
        case 243:
          Sqlite3.sqlite3CreateIndex(pParse, yymsp[-6].minor.yy0, yymsp[-5].minor.yy0, Sqlite3.sqlite3SrcListAppend(pParse.db, 0, yymsp[-3].minor.yy0, 0), yymsp[-1].minor.yy322, yymsp[-9].minor.yy4, yymsp[-10].minor.yy0, yymsp[0].minor.yy0, 0, yymsp[-7].minor.yy4);
          break;
        case 244:
        case 298:
          yypMinor.yy4 = 2;
          break;
        case 245:
          yypMinor.yy4 = 0;
          break;
        case 248:
          Sqlite3.Expr pExpr3 = (Sqlite3.Expr) null;
          if (yymsp[-1].minor.yy0.n > 0)
          {
            pExpr3 = Sqlite3.sqlite3Expr(pParse.db, 152, (string) null);
            Sqlite3.sqlite3ExprSetCollByToken(pParse, pExpr3, yymsp[-1].minor.yy0);
          }
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, pExpr3);
          Sqlite3.sqlite3ExprListSetName(pParse, yypMinor.yy322, yymsp[-2].minor.yy0, 1);
          Sqlite3.sqlite3ExprListCheckLength(pParse, yypMinor.yy322, "index");
          if (yypMinor.yy322 != null)
          {
            yypMinor.yy322.a[yypMinor.yy322.nExpr - 1].sortOrder = (byte) yymsp[0].minor.yy4;
            break;
          }
          break;
        case 249:
          Sqlite3.Expr pExpr4 = (Sqlite3.Expr) null;
          if (yymsp[-1].minor.yy0.n > 0)
          {
            pExpr4 = Sqlite3.sqlite3PExpr(pParse, 152, 0, 0, 0);
            Sqlite3.sqlite3ExprSetCollByToken(pParse, pExpr4, yymsp[-1].minor.yy0);
          }
          yypMinor.yy322 = Sqlite3.sqlite3ExprListAppend(pParse, 0, pExpr4);
          Sqlite3.sqlite3ExprListSetName(pParse, yypMinor.yy322, yymsp[-2].minor.yy0, 1);
          Sqlite3.sqlite3ExprListCheckLength(pParse, yypMinor.yy322, "index");
          if (yypMinor.yy322 != null)
          {
            yypMinor.yy322.a[yypMinor.yy322.nExpr - 1].sortOrder = (byte) yymsp[0].minor.yy4;
            break;
          }
          break;
        case 250:
          yypMinor.yy0.z = (string) null;
          yypMinor.yy0.n = 0;
          break;
        case 252:
          Sqlite3.sqlite3DropIndex(pParse, yymsp[0].minor.yy259, yymsp[-1].minor.yy4);
          break;
        case 253:
        case 254:
          Sqlite3.sqlite3Vacuum(pParse);
          break;
        case (int) byte.MaxValue:
          Sqlite3.sqlite3Pragma(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0, 0, 0);
          break;
        case 256:
          Sqlite3.sqlite3Pragma(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0, 0);
          break;
        case 257:
          Sqlite3.sqlite3Pragma(pParse, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, yymsp[-1].minor.yy0, 0);
          break;
        case 258:
          Sqlite3.sqlite3Pragma(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0, 1);
          break;
        case 259:
          Sqlite3.sqlite3Pragma(pParse, yymsp[-4].minor.yy0, yymsp[-3].minor.yy0, yymsp[-1].minor.yy0, 1);
          break;
        case 270:
          Sqlite3.Token pAll = new Sqlite3.Token()
          {
            n = yymsp[-3].minor.yy0.z.Length - yymsp[0].minor.yy0.z.Length + yymsp[0].minor.yy0.n
          };
          pAll.z = yymsp[-3].minor.yy0.z.Substring(0, pAll.n);
          Sqlite3.sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy203, pAll);
          break;
        case 271:
          Sqlite3.sqlite3BeginTrigger(pParse, yymsp[-7].minor.yy0, yymsp[-6].minor.yy0, yymsp[-5].minor.yy4, yymsp[-4].minor.yy90.a, yymsp[-4].minor.yy90.b, yymsp[-2].minor.yy259, yymsp[0].minor.yy314, yymsp[-10].minor.yy4, yymsp[-8].minor.yy4);
          yypMinor.yy0 = yymsp[-6].minor.yy0.n == 0 ? yymsp[-7].minor.yy0 : yymsp[-6].minor.yy0;
          break;
        case 272:
        case 275:
          yypMinor.yy4 = 34;
          break;
        case 273:
          yypMinor.yy4 = 30;
          break;
        case 274:
          yypMinor.yy4 = 48;
          break;
        case 276:
        case 277:
          yypMinor.yy90.a = yymsp[0].major;
          yypMinor.yy90.b = (Sqlite3.IdList) null;
          break;
        case 278:
          yypMinor.yy90.a = 107;
          yypMinor.yy90.b = yymsp[0].minor.yy384;
          break;
        case 281:
        case 303:
          yypMinor.yy314 = (Sqlite3.Expr) null;
          break;
        case 282:
        case 304:
          yypMinor.yy314 = yymsp[0].minor.yy118.pExpr;
          break;
        case 283:
          yymsp[-2].minor.yy203.pLast.pNext = yymsp[-1].minor.yy203;
          yymsp[-2].minor.yy203.pLast = yymsp[-1].minor.yy203;
          yypMinor.yy203 = yymsp[-2].minor.yy203;
          break;
        case 284:
          yymsp[-1].minor.yy203.pLast = yymsp[-1].minor.yy203;
          yypMinor.yy203 = yymsp[-1].minor.yy203;
          break;
        case 286:
          yypMinor.yy0 = yymsp[0].minor.yy0;
          Sqlite3.sqlite3ErrorMsg(pParse, "qualified table names are not allowed on INSERT, UPDATE, and DELETE statements within triggers");
          break;
        case 288:
          Sqlite3.sqlite3ErrorMsg(pParse, "the INDEXED BY clause is not allowed on UPDATE or DELETE statements within triggers");
          break;
        case 289:
          Sqlite3.sqlite3ErrorMsg(pParse, "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements within triggers");
          break;
        case 290:
          yypMinor.yy203 = Sqlite3.sqlite3TriggerUpdateStep(pParse.db, yymsp[-4].minor.yy0, yymsp[-1].minor.yy322, yymsp[0].minor.yy314, yymsp[-5].minor.yy210);
          break;
        case 291:
          yypMinor.yy203 = Sqlite3.sqlite3TriggerInsertStep(pParse.db, yymsp[-5].minor.yy0, yymsp[-4].minor.yy384, yymsp[-1].minor.yy322, 0, yymsp[-7].minor.yy210);
          break;
        case 292:
          yypMinor.yy203 = Sqlite3.sqlite3TriggerInsertStep(pParse.db, yymsp[-2].minor.yy0, yymsp[-1].minor.yy384, 0, yymsp[0].minor.yy387, yymsp[-4].minor.yy210);
          break;
        case 293:
          yypMinor.yy203 = Sqlite3.sqlite3TriggerDeleteStep(pParse.db, yymsp[-2].minor.yy0, yymsp[0].minor.yy314);
          break;
        case 294:
          yypMinor.yy203 = Sqlite3.sqlite3TriggerSelectStep(pParse.db, yymsp[0].minor.yy387);
          break;
        case 295:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 56, 0, 0, 0);
          if (yypMinor.yy118.pExpr != null)
            yypMinor.yy118.pExpr.affinity = '\u0004';
          yypMinor.yy118.zStart = yymsp[-3].minor.yy0.z;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 296:
          yypMinor.yy118.pExpr = Sqlite3.sqlite3PExpr(pParse, 56, 0, 0, yymsp[-1].minor.yy0);
          if (yypMinor.yy118.pExpr != null)
            yypMinor.yy118.pExpr.affinity = (char) yymsp[-3].minor.yy4;
          yypMinor.yy118.zStart = yymsp[-5].minor.yy0.z;
          yypMinor.yy118.zEnd = yymsp[0].minor.yy0.z.Substring(yymsp[0].minor.yy0.n);
          break;
        case 297:
          yypMinor.yy4 = 1;
          break;
        case 299:
          yypMinor.yy4 = 3;
          break;
        case 300:
          Sqlite3.sqlite3DropTrigger(pParse, yymsp[0].minor.yy259, yymsp[-1].minor.yy4);
          break;
        case 301:
          Sqlite3.sqlite3Attach(pParse, yymsp[-3].minor.yy118.pExpr, yymsp[-1].minor.yy118.pExpr, yymsp[0].minor.yy314);
          break;
        case 302:
          Sqlite3.sqlite3Detach(pParse, yymsp[0].minor.yy118.pExpr);
          break;
        case 307:
          Sqlite3.sqlite3Reindex(pParse, 0, 0);
          break;
        case 308:
          Sqlite3.sqlite3Reindex(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 309:
          Sqlite3.sqlite3Analyze(pParse, 0, 0);
          break;
        case 310:
          Sqlite3.sqlite3Analyze(pParse, yymsp[-1].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 311:
          Sqlite3.sqlite3AlterRenameTable(pParse, yymsp[-3].minor.yy259, yymsp[0].minor.yy0);
          break;
        case 312:
          Sqlite3.sqlite3AlterFinishAddColumn(pParse, yymsp[0].minor.yy0);
          break;
        case 313:
          pParse.db.lookaside.bEnabled = (byte) 0;
          Sqlite3.sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy259);
          break;
        case 316:
          Sqlite3.sqlite3VtabFinishParse<Sqlite3.Token>(pParse, (Sqlite3.Token) null);
          break;
        case 317:
          Sqlite3.sqlite3VtabFinishParse<Sqlite3.Token>(pParse, yymsp[0].minor.yy0);
          break;
        case 318:
          Sqlite3.sqlite3VtabBeginParse(pParse, yymsp[-3].minor.yy0, yymsp[-2].minor.yy0, yymsp[0].minor.yy0);
          break;
        case 321:
          Sqlite3.sqlite3VtabArgInit(pParse);
          break;
        case 323:
        case 324:
        case 325:
          Sqlite3.sqlite3VtabArgExtend(pParse, yymsp[0].minor.yy0);
          break;
      }
      int lhs = Sqlite3.yyRuleInfo[yyruleno].lhs;
      int nrhs = (int) Sqlite3.yyRuleInfo[yyruleno].nrhs;
      yypParser.yyidx -= nrhs;
      int reduceAction = Sqlite3.yy_find_reduce_action(yymsp[-nrhs].stateno, lhs);
      if (reduceAction < 630)
      {
        if (nrhs != 0)
        {
          ++yypParser.yyidx;
          yymsp._yyidx -= nrhs - 1;
          yymsp[0].stateno = reduceAction;
          yymsp[0].major = lhs;
          yymsp[0].minor = yypMinor;
        }
        else
          Sqlite3.yy_shift(yypParser, reduceAction, lhs, yypMinor);
      }
      else
        Sqlite3.yy_accept(yypParser);
    }

    private static void yy_parse_failed(Sqlite3.yyParser yypParser)
    {
      Sqlite3.Parse pParse = yypParser.pParse;
      while (yypParser.yyidx >= 0)
        Sqlite3.yy_pop_parser_stack(yypParser);
      yypParser.pParse = pParse;
    }

    private static void yy_syntax_error(
      Sqlite3.yyParser yypParser,
      int yymajor,
      Sqlite3.YYMINORTYPE yyminor)
    {
      Sqlite3.Parse pParse = yypParser.pParse;
      Sqlite3.UNUSED_PARAMETER<int>(yymajor);
      Sqlite3.sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", (object) yyminor.yy0);
      pParse.parseError = (byte) 1;
      yypParser.pParse = pParse;
    }

    private static void yy_accept(Sqlite3.yyParser yypParser)
    {
      Sqlite3.Parse pParse = yypParser.pParse;
      while (yypParser.yyidx >= 0)
        Sqlite3.yy_pop_parser_stack(yypParser);
      yypParser.pParse = pParse;
    }

    private static void sqlite3Parser(
      Sqlite3.yyParser yyp,
      int yymajor,
      Sqlite3.Token yyminor,
      Sqlite3.Parse pParse)
    {
      Sqlite3.YYMINORTYPE yyminortype = new Sqlite3.YYMINORTYPE();
      Sqlite3.yyParser yyParser = yyp;
      if (yyParser.yyidx < 0)
      {
        yyParser.yyidx = 0;
        yyParser.yyerrcnt = -1;
        yyParser.yystack[0] = new Sqlite3.yyStackEntry();
        yyParser.yystack[0].stateno = 0;
        yyParser.yystack[0].major = 0;
      }
      yyminortype.yy0 = yyminor.Copy();
      bool flag = yymajor == 0;
      yyParser.pParse = pParse;
      do
      {
        int shiftAction = Sqlite3.yy_find_shift_action(yyParser, yymajor);
        if (shiftAction < 630)
        {
          Sqlite3.yy_shift(yyParser, shiftAction, yymajor, yyminortype);
          --yyParser.yyerrcnt;
          yymajor = 253;
        }
        else if (shiftAction < 959)
        {
          Sqlite3.yy_reduce(yyParser, shiftAction - 630);
        }
        else
        {
          if (yyParser.yyerrcnt <= 0)
            Sqlite3.yy_syntax_error(yyParser, yymajor, yyminortype);
          yyParser.yyerrcnt = 3;
          Sqlite3.yy_destructor(yyParser, yymajor, yyminortype);
          if (flag)
            Sqlite3.yy_parse_failed(yyParser);
          yymajor = 253;
        }
      }
      while (yymajor != 253 && yyParser.yyidx >= 0);
    }

    private static Sqlite3.PgHdr PGHDR1_TO_PAGE(Sqlite3.PgHdr1 p) => p.pPgHdr;

    private static Sqlite3.PgHdr1 PAGE_TO_PGHDR1(Sqlite3.PCache1 c, Sqlite3.PgHdr p) => p.pPgHdr1;

    private static void pcache1EnterMutex(Sqlite3.PGroup X) => Sqlite3.sqlite3_mutex_enter(X.mutex);

    private static void pcache1LeaveMutex(Sqlite3.PGroup X) => Sqlite3.sqlite3_mutex_leave(X.mutex);

    private static void sqlite3PCacheBufferSetup(object pBuf, int sz, int n)
    {
      if (!Sqlite3.pcache1.isInit)
        return;
      sz = Sqlite3.ROUNDDOWN8(sz);
      Sqlite3.pcache1.szSlot = sz;
      Sqlite3.pcache1.nSlot = Sqlite3.pcache1.nFreeSlot = n;
      Sqlite3.pcache1.nReserve = n > 90 ? 10 : n / 10 + 1;
      Sqlite3.pcache1.pStart = (object) null;
      Sqlite3.pcache1.pEnd = (object) null;
      Sqlite3.pcache1.pFree = (Sqlite3.PgFreeslot) null;
      Sqlite3.pcache1.bUnderPressure = false;
      while (n-- > 0)
        Sqlite3.pcache1.pFree = new Sqlite3.PgFreeslot()
        {
          _PgHdr = new Sqlite3.PgHdr(),
          pNext = Sqlite3.pcache1.pFree
        };
      Sqlite3.pcache1.pEnd = pBuf;
    }

    private static Sqlite3.PgHdr pcache1Alloc(int nByte)
    {
      Sqlite3.PgHdr X = (Sqlite3.PgHdr) null;
      Sqlite3.sqlite3StatusSet(7, nByte);
      if (nByte <= Sqlite3.pcache1.szSlot)
      {
        Sqlite3.sqlite3_mutex_enter(Sqlite3.pcache1.mutex);
        X = Sqlite3.pcache1.pFree._PgHdr;
        if (X != null)
        {
          Sqlite3.pcache1.pFree = Sqlite3.pcache1.pFree.pNext;
          --Sqlite3.pcache1.nFreeSlot;
          Sqlite3.pcache1.bUnderPressure = Sqlite3.pcache1.nFreeSlot < Sqlite3.pcache1.nReserve;
          Sqlite3.sqlite3StatusAdd(1, 1);
        }
        Sqlite3.sqlite3_mutex_leave(Sqlite3.pcache1.mutex);
      }
      if (X == null)
      {
        X = new Sqlite3.PgHdr();
        int N = nByte;
        Sqlite3.sqlite3_mutex_enter(Sqlite3.pcache1.mutex);
        Sqlite3.sqlite3StatusAdd(2, N);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.pcache1.mutex);
        Sqlite3.sqlite3MemdebugSetType<Sqlite3.PgHdr>(X, 8);
      }
      return X;
    }

    private static void pcache1Free(ref Sqlite3.PgHdr p)
    {
      if (p == null)
        return;
      if (p.CacheAllocated)
      {
        Sqlite3.PgFreeslot pgFreeslot = new Sqlite3.PgFreeslot();
        Sqlite3.sqlite3_mutex_enter(Sqlite3.pcache1.mutex);
        Sqlite3.sqlite3StatusAdd(1, -1);
        pgFreeslot._PgHdr = p;
        pgFreeslot.pNext = Sqlite3.pcache1.pFree;
        Sqlite3.pcache1.pFree = pgFreeslot;
        ++Sqlite3.pcache1.nFreeSlot;
        Sqlite3.pcache1.bUnderPressure = Sqlite3.pcache1.nFreeSlot < Sqlite3.pcache1.nReserve;
        Sqlite3.sqlite3_mutex_leave(Sqlite3.pcache1.mutex);
      }
      else
      {
        Sqlite3.sqlite3MemdebugSetType<Sqlite3.PgHdr>(p, 1);
        int num = Sqlite3.sqlite3MallocSize(p.pData);
        Sqlite3.sqlite3_mutex_enter(Sqlite3.pcache1.mutex);
        Sqlite3.sqlite3StatusAdd(2, -num);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.pcache1.mutex);
        Sqlite3.sqlite3_free(ref p.pData);
      }
    }

    private static Sqlite3.PgHdr1 pcache1AllocPage(Sqlite3.PCache1 pCache)
    {
      Sqlite3.PgHdr pgHdr = Sqlite3.pcache1Alloc(pCache.szPage);
      Sqlite3.PgHdr1 pgHdr1 = new Sqlite3.PgHdr1();
      pgHdr1.pCache = pCache;
      pgHdr1.pPgHdr = pgHdr;
      if (!pCache.bPurgeable)
        return pgHdr1;
      ++pCache.pGroup.nCurrentPage;
      return pgHdr1;
    }

    private static void pcache1FreePage(ref Sqlite3.PgHdr1 p)
    {
      if (!Sqlite3.ALWAYS<Sqlite3.PgHdr1>(p))
        return;
      Sqlite3.PCache1 pCache = p.pCache;
      if (pCache.bPurgeable)
        --pCache.pGroup.nCurrentPage;
      Sqlite3.pcache1Free(ref p.pPgHdr);
    }

    private static Sqlite3.PgHdr sqlite3PageMalloc(int sz) => Sqlite3.pcache1Alloc(sz);

    private static void sqlite3PageFree(ref byte[] p)
    {
      if (p == null)
        return;
      Sqlite3.sqlite3_free(ref p);
      p = (byte[]) null;
    }

    private static void sqlite3PageFree(ref Sqlite3.PgHdr p) => Sqlite3.pcache1Free(ref p);

    private static bool pcache1UnderMemoryPressure(Sqlite3.PCache1 pCache) => Sqlite3.pcache1.nSlot != 0 && pCache.szPage <= Sqlite3.pcache1.szSlot ? Sqlite3.pcache1.bUnderPressure : Sqlite3.sqlite3HeapNearlyFull();

    private static int pcache1ResizeHash(Sqlite3.PCache1 p)
    {
      int length = p.nHash * 2;
      if (length < 256)
        length = 256;
      Sqlite3.pcache1LeaveMutex(p.pGroup);
      if (p.nHash != 0)
        Sqlite3.sqlite3BeginBenignMalloc();
      Sqlite3.PgHdr1[] pgHdr1Array = new Sqlite3.PgHdr1[length];
      if (p.nHash != 0)
        Sqlite3.sqlite3EndBenignMalloc();
      Sqlite3.pcache1EnterMutex(p.pGroup);
      if (pgHdr1Array != null)
      {
        for (int index1 = 0; index1 < p.nHash; ++index1)
        {
          Sqlite3.PgHdr1 pNext = p.apHash[index1];
          Sqlite3.PgHdr1 pgHdr1;
          while ((pgHdr1 = pNext) != null)
          {
            uint index2 = (uint) ((ulong) pgHdr1.iKey % (ulong) length);
            pNext = pgHdr1.pNext;
            pgHdr1.pNext = pgHdr1Array[(int) index2];
            pgHdr1Array[(int) index2] = pgHdr1;
          }
        }
        p.apHash = pgHdr1Array;
        p.nHash = length;
      }
      return p.apHash == null ? 7 : 0;
    }

    private static void pcache1PinPage(Sqlite3.PgHdr1 pPage)
    {
      if (pPage == null)
        return;
      Sqlite3.PGroup pGroup = pPage.pCache.pGroup;
      if (pPage.pLruNext == null && pPage != pGroup.pLruTail)
        return;
      if (pPage.pLruPrev != null)
        pPage.pLruPrev.pLruNext = pPage.pLruNext;
      if (pPage.pLruNext != null)
        pPage.pLruNext.pLruPrev = pPage.pLruPrev;
      if (pGroup.pLruHead == pPage)
        pGroup.pLruHead = pPage.pLruNext;
      if (pGroup.pLruTail == pPage)
        pGroup.pLruTail = pPage.pLruPrev;
      pPage.pLruNext = (Sqlite3.PgHdr1) null;
      pPage.pLruPrev = (Sqlite3.PgHdr1) null;
      --pPage.pCache.nRecyclable;
    }

    private static void pcache1RemoveFromHash(Sqlite3.PgHdr1 pPage)
    {
      Sqlite3.PCache1 pCache = pPage.pCache;
      Sqlite3.PgHdr1 pgHdr1 = (Sqlite3.PgHdr1) null;
      int index = (int) ((long) pPage.iKey % (long) pCache.nHash);
      Sqlite3.PgHdr1 pNext;
      for (pNext = pCache.apHash[index]; pNext != pPage; pNext = pNext.pNext)
        pgHdr1 = pNext;
      if (pgHdr1 == null)
        pCache.apHash[index] = pNext.pNext;
      else
        pgHdr1.pNext = pNext.pNext;
      --pCache.nPage;
    }

    private static void pcache1EnforceMaxPage(Sqlite3.PGroup pGroup)
    {
      while (pGroup.nCurrentPage > pGroup.nMaxPage && pGroup.pLruTail != null)
      {
        Sqlite3.PgHdr1 pLruTail = pGroup.pLruTail;
        Sqlite3.pcache1PinPage(pLruTail);
        Sqlite3.pcache1RemoveFromHash(pLruTail);
        Sqlite3.pcache1FreePage(ref pLruTail);
      }
    }

    private static void pcache1TruncateUnsafe(Sqlite3.PCache1 pCache, uint iLimit)
    {
      for (uint index = 0; (long) index < (long) pCache.nHash; ++index)
      {
        Sqlite3.PgHdr1 pgHdr1 = (Sqlite3.PgHdr1) null;
        Sqlite3.PgHdr1 pNext = pCache.apHash[(int) index];
        Sqlite3.PgHdr1 p;
        while ((p = pNext) != null)
        {
          if (p.iKey >= iLimit)
          {
            --pCache.nPage;
            pNext = p.pNext;
            Sqlite3.pcache1PinPage(p);
            if (pCache.apHash[(int) index] == p)
              pCache.apHash[(int) index] = p.pNext;
            else
              pgHdr1.pNext = pNext;
            Sqlite3.pcache1FreePage(ref p);
          }
          else
            pNext = p.pNext;
          pgHdr1 = p;
        }
      }
    }

    private static int pcache1Init<T>(T NotUsed)
    {
      Sqlite3.UNUSED_PARAMETER<T>(NotUsed);
      Sqlite3.pcache1 = new Sqlite3.PCacheGlobal();
      if (Sqlite3.sqlite3GlobalConfig.bCoreMutex)
      {
        Sqlite3.pcache1.grp.mutex = Sqlite3.sqlite3_mutex_alloc(6);
        Sqlite3.pcache1.mutex = Sqlite3.sqlite3_mutex_alloc(7);
      }
      Sqlite3.pcache1.grp.mxPinned = 10;
      Sqlite3.pcache1.isInit = true;
      return 0;
    }

    private static void pcache1Shutdown<T>(T NotUsed)
    {
      Sqlite3.UNUSED_PARAMETER<T>(NotUsed);
      Sqlite3.pcache1 = new Sqlite3.PCacheGlobal();
    }

    private static Sqlite3.PCache1 pcache1Create(int szPage, bool bPurgeable)
    {
      Sqlite3.PCache1 pcache1 = new Sqlite3.PCache1();
      Sqlite3.PGroup grp = Sqlite3.pcache1.grp;
      pcache1.pGroup = grp;
      pcache1.szPage = szPage;
      pcache1.bPurgeable = bPurgeable;
      if (bPurgeable)
      {
        pcache1.nMin = 10;
        Sqlite3.pcache1EnterMutex(grp);
        grp.nMinPage += pcache1.nMin;
        grp.mxPinned = grp.nMaxPage + 10 - grp.nMinPage;
        Sqlite3.pcache1LeaveMutex(grp);
      }
      return pcache1;
    }

    private static void pcache1Cachesize(Sqlite3.PCache1 p, int nMax)
    {
      Sqlite3.PCache1 pcache1 = p;
      if (!pcache1.bPurgeable)
        return;
      Sqlite3.PGroup pGroup = pcache1.pGroup;
      Sqlite3.pcache1EnterMutex(pGroup);
      pGroup.nMaxPage += nMax - pcache1.nMax;
      pGroup.mxPinned = pGroup.nMaxPage + 10 - pGroup.nMinPage;
      pcache1.nMax = nMax;
      pcache1.n90pct = pcache1.nMax * 9 / 10;
      Sqlite3.pcache1EnforceMaxPage(pGroup);
      Sqlite3.pcache1LeaveMutex(pGroup);
    }

    private static int pcache1Pagecount(Sqlite3.PCache1 p)
    {
      Sqlite3.PCache1 pcache1 = p;
      Sqlite3.pcache1EnterMutex(pcache1.pGroup);
      int nPage = pcache1.nPage;
      Sqlite3.pcache1LeaveMutex(pcache1.pGroup);
      return nPage;
    }

    private static Sqlite3.PgHdr pcache1Fetch(Sqlite3.PCache1 p, uint iKey, int createFlag)
    {
      Sqlite3.PCache1 pcache1 = p;
      Sqlite3.PgHdr1 p1 = (Sqlite3.PgHdr1) null;
      Sqlite3.PGroup pGroup;
      Sqlite3.pcache1EnterMutex(pGroup = pcache1.pGroup);
      if (pcache1.nHash > 0)
      {
        int index = (int) ((long) iKey % (long) pcache1.nHash);
        p1 = pcache1.apHash[index];
        while (p1 != null && (int) p1.iKey != (int) iKey)
          p1 = p1.pNext;
      }
      if (p1 != null || createFlag == 0)
      {
        Sqlite3.pcache1PinPage(p1);
      }
      else
      {
        pGroup = pcache1.pGroup;
        int num = pcache1.nPage - pcache1.nRecyclable;
        if ((createFlag != 1 || num < pGroup.mxPinned && num < pcache1.n90pct && !Sqlite3.pcache1UnderMemoryPressure(pcache1)) && (pcache1.nPage < pcache1.nHash || Sqlite3.pcache1ResizeHash(pcache1) == 0))
        {
          if (pcache1.bPurgeable && pGroup.pLruTail != null && (pcache1.nPage + 1 >= pcache1.nMax || pGroup.nCurrentPage >= pGroup.nMaxPage || Sqlite3.pcache1UnderMemoryPressure(pcache1)))
          {
            p1 = pGroup.pLruTail;
            Sqlite3.pcache1RemoveFromHash(p1);
            Sqlite3.pcache1PinPage(p1);
            Sqlite3.PCache1 pCache;
            if ((pCache = p1.pCache).szPage != pcache1.szPage)
            {
              Sqlite3.pcache1FreePage(ref p1);
              p1 = (Sqlite3.PgHdr1) null;
            }
            else
              pGroup.nCurrentPage -= (pCache.bPurgeable ? 1 : 0) - (pcache1.bPurgeable ? 1 : 0);
          }
          if (p1 == null)
          {
            if (createFlag == 1)
              Sqlite3.sqlite3BeginBenignMalloc();
            Sqlite3.pcache1LeaveMutex(pGroup);
            p1 = Sqlite3.pcache1AllocPage(pcache1);
            Sqlite3.pcache1EnterMutex(pGroup);
            if (createFlag == 1)
              Sqlite3.sqlite3EndBenignMalloc();
          }
          if (p1 != null)
          {
            int index = (int) ((long) iKey % (long) pcache1.nHash);
            ++pcache1.nPage;
            p1.iKey = iKey;
            p1.pNext = pcache1.apHash[index];
            p1.pCache = pcache1;
            p1.pLruPrev = (Sqlite3.PgHdr1) null;
            p1.pLruNext = (Sqlite3.PgHdr1) null;
            Sqlite3.PGHDR1_TO_PAGE(p1).Clear();
            p1.pPgHdr.pPgHdr1 = p1;
            pcache1.apHash[index] = p1;
          }
        }
      }
      if (p1 != null && iKey > pcache1.iMaxKey)
        pcache1.iMaxKey = iKey;
      Sqlite3.pcache1LeaveMutex(pGroup);
      return p1 == null ? (Sqlite3.PgHdr) null : Sqlite3.PGHDR1_TO_PAGE(p1);
    }

    private static void pcache1Unpin(Sqlite3.PCache1 p, Sqlite3.PgHdr pPg, bool reuseUnlikely)
    {
      Sqlite3.PCache1 c = p;
      Sqlite3.PgHdr1 pghdR1 = Sqlite3.PAGE_TO_PGHDR1(c, pPg);
      Sqlite3.PGroup pGroup = c.pGroup;
      Sqlite3.pcache1EnterMutex(pGroup);
      if (reuseUnlikely || pGroup.nCurrentPage > pGroup.nMaxPage)
      {
        Sqlite3.pcache1RemoveFromHash(pghdR1);
        Sqlite3.pcache1FreePage(ref pghdR1);
      }
      else
      {
        if (pGroup.pLruHead != null)
        {
          pGroup.pLruHead.pLruPrev = pghdR1;
          pghdR1.pLruNext = pGroup.pLruHead;
          pGroup.pLruHead = pghdR1;
        }
        else
        {
          pGroup.pLruTail = pghdR1;
          pGroup.pLruHead = pghdR1;
        }
        ++c.nRecyclable;
      }
      Sqlite3.pcache1LeaveMutex(c.pGroup);
    }

    private static void pcache1Rekey(Sqlite3.PCache1 p, Sqlite3.PgHdr pPg, uint iOld, uint iNew)
    {
      Sqlite3.PCache1 c = p;
      Sqlite3.PgHdr1 pghdR1 = Sqlite3.PAGE_TO_PGHDR1(c, pPg);
      Sqlite3.pcache1EnterMutex(c.pGroup);
      int index1 = (int) ((long) iOld % (long) c.nHash);
      Sqlite3.PgHdr1 pNext = c.apHash[index1];
      while (pNext != pghdR1)
        pNext = pNext.pNext;
      if (pNext == c.apHash[index1])
        c.apHash[index1] = pNext.pNext;
      else
        pNext.pNext = pghdR1.pNext;
      int index2 = (int) ((long) iNew % (long) c.nHash);
      pghdR1.iKey = iNew;
      pghdR1.pNext = c.apHash[index2];
      c.apHash[index2] = pghdR1;
      if (iNew > c.iMaxKey)
        c.iMaxKey = iNew;
      Sqlite3.pcache1LeaveMutex(c.pGroup);
    }

    private static void pcache1Truncate(Sqlite3.PCache1 p, uint iLimit)
    {
      Sqlite3.PCache1 pCache = p;
      Sqlite3.pcache1EnterMutex(pCache.pGroup);
      if (iLimit <= pCache.iMaxKey)
      {
        Sqlite3.pcache1TruncateUnsafe(pCache, iLimit);
        pCache.iMaxKey = iLimit - 1U;
      }
      Sqlite3.pcache1LeaveMutex(pCache.pGroup);
    }

    private static void pcache1Destroy(ref Sqlite3.PCache1 p)
    {
      Sqlite3.PCache1 pCache = p;
      Sqlite3.PGroup pGroup = pCache.pGroup;
      Sqlite3.pcache1EnterMutex(pGroup);
      Sqlite3.pcache1TruncateUnsafe(pCache, 0U);
      pGroup.nMaxPage -= pCache.nMax;
      pGroup.nMinPage -= pCache.nMin;
      pGroup.mxPinned = pGroup.nMaxPage + 10 - pGroup.nMinPage;
      Sqlite3.pcache1EnforceMaxPage(pGroup);
      Sqlite3.pcache1LeaveMutex(pGroup);
      p = (Sqlite3.PCache1) null;
    }

    private static void sqlite3PCacheSetDefault() => Sqlite3.sqlite3_config(14, new Sqlite3.sqlite3_pcache_methods((object) 0, new Sqlite3.dxPC_Init(Sqlite3.pcache1Init<object>), new Sqlite3.dxPC_Shutdown(Sqlite3.pcache1Shutdown<object>), new Sqlite3.dxPC_Create(Sqlite3.pcache1Create), new Sqlite3.dxPC_Cachesize(Sqlite3.pcache1Cachesize), new Sqlite3.dxPC_Pagecount(Sqlite3.pcache1Pagecount), new Sqlite3.dxPC_Fetch(Sqlite3.pcache1Fetch), new Sqlite3.dxPC_Unpin(Sqlite3.pcache1Unpin), new Sqlite3.dxPC_Rekey(Sqlite3.pcache1Rekey), new Sqlite3.dxPC_Truncate(Sqlite3.pcache1Truncate), new Sqlite3.dxPC_Destroy(Sqlite3.pcache1Destroy)));

    private static void pcacheRemoveFromDirtyList(Sqlite3.PgHdr pPage)
    {
      Sqlite3.PCache pCache = pPage.pCache;
      if (pCache.pSynced == pPage)
      {
        Sqlite3.PgHdr pDirtyPrev = pPage.pDirtyPrev;
        while (pDirtyPrev != null && (pDirtyPrev.flags & 4) != 0)
          pDirtyPrev = pDirtyPrev.pDirtyPrev;
        pCache.pSynced = pDirtyPrev;
      }
      if (pPage.pDirtyNext != null)
        pPage.pDirtyNext.pDirtyPrev = pPage.pDirtyPrev;
      else
        pCache.pDirtyTail = pPage.pDirtyPrev;
      if (pPage.pDirtyPrev != null)
        pPage.pDirtyPrev.pDirtyNext = pPage.pDirtyNext;
      else
        pCache.pDirty = pPage.pDirtyNext;
      pPage.pDirtyNext = (Sqlite3.PgHdr) null;
      pPage.pDirtyPrev = (Sqlite3.PgHdr) null;
    }

    private static void pcacheAddToDirtyList(Sqlite3.PgHdr pPage)
    {
      Sqlite3.PCache pCache = pPage.pCache;
      pPage.pDirtyNext = pCache.pDirty;
      if (pPage.pDirtyNext != null)
        pPage.pDirtyNext.pDirtyPrev = pPage;
      pCache.pDirty = pPage;
      if (pCache.pDirtyTail == null)
        pCache.pDirtyTail = pPage;
      if (pCache.pSynced != null || (pPage.flags & 4) != 0)
        return;
      pCache.pSynced = pPage;
    }

    private static void pcacheUnpin(Sqlite3.PgHdr p)
    {
      Sqlite3.PCache pCache = p.pCache;
      if (!pCache.bPurgeable)
        return;
      if (p.pgno == 1U)
        pCache.pPage1 = (Sqlite3.PgHdr) null;
      Sqlite3.sqlite3GlobalConfig.pcache.xUnpin(pCache.pCache, p, false);
    }

    private static int sqlite3PcacheInitialize()
    {
      if (Sqlite3.sqlite3GlobalConfig.pcache.xInit == null)
        Sqlite3.sqlite3PCacheSetDefault();
      return Sqlite3.sqlite3GlobalConfig.pcache.xInit(Sqlite3.sqlite3GlobalConfig.pcache.pArg);
    }

    private static void sqlite3PcacheShutdown()
    {
      if (Sqlite3.sqlite3GlobalConfig.pcache.xShutdown == null)
        return;
      Sqlite3.sqlite3GlobalConfig.pcache.xShutdown(Sqlite3.sqlite3GlobalConfig.pcache.pArg);
    }

    private static int sqlite3PcacheSize() => 4;

    private static void sqlite3PcacheOpen(
      int szPage,
      int szExtra,
      bool bPurgeable,
      Sqlite3.dxStress xStress,
      object pStress,
      Sqlite3.PCache p)
    {
      p.Clear();
      p.szPage = szPage;
      p.szExtra = szExtra;
      p.bPurgeable = bPurgeable;
      p.xStress = xStress;
      p.pStress = pStress;
      p.nMax = 100;
    }

    private static void sqlite3PcacheSetPageSize(Sqlite3.PCache pCache, int szPage)
    {
      if (pCache.pCache != null)
      {
        Sqlite3.sqlite3GlobalConfig.pcache.xDestroy(ref pCache.pCache);
        pCache.pCache = (Sqlite3.PCache1) null;
      }
      pCache.szPage = szPage;
    }

    private static int sqlite3PcacheFetch(
      Sqlite3.PCache pCache,
      uint pgno,
      int createFlag,
      ref Sqlite3.PgHdr ppPage)
    {
      Sqlite3.PgHdr pgHdr = (Sqlite3.PgHdr) null;
      if (pCache.pCache == null && createFlag != 0)
      {
        int szPage = pCache.szPage + pCache.szExtra;
        Sqlite3.PCache1 pCache1 = Sqlite3.sqlite3GlobalConfig.pcache.xCreate(szPage, pCache.bPurgeable);
        Sqlite3.sqlite3GlobalConfig.pcache.xCachesize(pCache1, pCache.nMax);
        pCache.pCache = pCache1;
      }
      int createFlag1 = createFlag * (1 + (!pCache.bPurgeable || pCache.pDirty == null ? 1 : 0));
      if (pCache.pCache != null)
        pgHdr = Sqlite3.sqlite3GlobalConfig.pcache.xFetch(pCache.pCache, pgno, createFlag1);
      if (pgHdr == null && createFlag1 == 1)
      {
        Sqlite3.PgHdr pPhHdr = pCache.pSynced;
        while (pPhHdr != null && (pPhHdr.nRef != 0 || (pPhHdr.flags & 4) != 0))
          pPhHdr = pPhHdr.pDirtyPrev;
        pCache.pSynced = pPhHdr;
        if (pPhHdr == null)
        {
          pPhHdr = pCache.pDirtyTail;
          while (pPhHdr != null && pPhHdr.nRef != 0)
            pPhHdr = pPhHdr.pDirtyPrev;
        }
        if (pPhHdr != null)
        {
          int num = pCache.xStress(pCache.pStress, pPhHdr);
          switch (num)
          {
            case 0:
            case 5:
              break;
            default:
              return num;
          }
        }
        pgHdr = Sqlite3.sqlite3GlobalConfig.pcache.xFetch(pCache.pCache, pgno, 2);
      }
      if (pgHdr != null)
      {
        if (pgHdr.pData == null)
        {
          pgHdr.pData = Sqlite3.sqlite3Malloc(pCache.szPage);
          pgHdr.pCache = pCache;
          pgHdr.pgno = pgno;
        }
        if (pgHdr.nRef == 0)
          ++pCache.nRef;
        ++pgHdr.nRef;
        if (pgno == 1U)
          pCache.pPage1 = pgHdr;
      }
      ppPage = pgHdr;
      return pgHdr != null || createFlag1 == 0 ? 0 : 7;
    }

    private static void sqlite3PcacheRelease(Sqlite3.PgHdr p)
    {
      --p.nRef;
      if (p.nRef != 0)
        return;
      --p.pCache.nRef;
      if ((p.flags & 2) == 0)
      {
        Sqlite3.pcacheUnpin(p);
      }
      else
      {
        Sqlite3.pcacheRemoveFromDirtyList(p);
        Sqlite3.pcacheAddToDirtyList(p);
      }
    }

    private static void sqlite3PcacheRef(Sqlite3.PgHdr p) => ++p.nRef;

    private static void sqlite3PcacheDrop(Sqlite3.PgHdr p)
    {
      if ((p.flags & 2) != 0)
        Sqlite3.pcacheRemoveFromDirtyList(p);
      Sqlite3.PCache pCache = p.pCache;
      --pCache.nRef;
      if (p.pgno == 1U)
        pCache.pPage1 = (Sqlite3.PgHdr) null;
      Sqlite3.sqlite3GlobalConfig.pcache.xUnpin(pCache.pCache, p, true);
    }

    private static void sqlite3PcacheMakeDirty(Sqlite3.PgHdr p)
    {
      p.flags &= -33;
      if ((p.flags & 2) != 0)
        return;
      p.flags |= 2;
      Sqlite3.pcacheAddToDirtyList(p);
    }

    private static void sqlite3PcacheMakeClean(Sqlite3.PgHdr p)
    {
      if ((p.flags & 2) == 0)
        return;
      Sqlite3.pcacheRemoveFromDirtyList(p);
      p.flags &= -7;
      if (p.nRef != 0)
        return;
      Sqlite3.pcacheUnpin(p);
    }

    private static void sqlite3PcacheCleanAll(Sqlite3.PCache pCache)
    {
      Sqlite3.PgHdr pDirty;
      while ((pDirty = pCache.pDirty) != null)
        Sqlite3.sqlite3PcacheMakeClean(pDirty);
    }

    private static void sqlite3PcacheClearSyncFlags(Sqlite3.PCache pCache)
    {
      for (Sqlite3.PgHdr pgHdr = pCache.pDirty; pgHdr != null; pgHdr = pgHdr.pDirtyNext)
        pgHdr.flags &= -5;
      pCache.pSynced = pCache.pDirtyTail;
    }

    private static void sqlite3PcacheMove(Sqlite3.PgHdr p, uint newPgno)
    {
      Sqlite3.PCache pCache = p.pCache;
      Sqlite3.sqlite3GlobalConfig.pcache.xRekey(pCache.pCache, p, p.pgno, newPgno);
      p.pgno = newPgno;
      if ((p.flags & 2) == 0 || (p.flags & 4) == 0)
        return;
      Sqlite3.pcacheRemoveFromDirtyList(p);
      Sqlite3.pcacheAddToDirtyList(p);
    }

    private static void sqlite3PcacheTruncate(Sqlite3.PCache pCache, uint pgno)
    {
      if (pCache.pCache == null)
        return;
      Sqlite3.PgHdr pDirtyNext;
      for (Sqlite3.PgHdr p = pCache.pDirty; p != null; p = pDirtyNext)
      {
        pDirtyNext = p.pDirtyNext;
        if (Sqlite3.ALWAYS(p.pgno > pgno))
          Sqlite3.sqlite3PcacheMakeClean(p);
      }
      if (pgno == 0U && pCache.pPage1 != null)
      {
        pCache.pPage1.pData = Sqlite3.sqlite3Malloc(pCache.szPage);
        pgno = 1U;
      }
      Sqlite3.sqlite3GlobalConfig.pcache.xTruncate(pCache.pCache, pgno + 1U);
    }

    private static void sqlite3PcacheClose(Sqlite3.PCache pCache)
    {
      if (pCache.pCache == null)
        return;
      Sqlite3.sqlite3GlobalConfig.pcache.xDestroy(ref pCache.pCache);
    }

    private static void sqlite3PcacheClear(Sqlite3.PCache pCache) => Sqlite3.sqlite3PcacheTruncate(pCache, 0U);

    private static Sqlite3.PgHdr pcacheMergeDirtyList(Sqlite3.PgHdr pA, Sqlite3.PgHdr pB)
    {
      Sqlite3.PgHdr pgHdr1 = new Sqlite3.PgHdr();
      Sqlite3.PgHdr pgHdr2 = pgHdr1;
      while (pA != null && pB != null)
      {
        if (pA.pgno < pB.pgno)
        {
          pgHdr2.pDirty = pA;
          pgHdr2 = pA;
          pA = pA.pDirty;
        }
        else
        {
          pgHdr2.pDirty = pB;
          pgHdr2 = pB;
          pB = pB.pDirty;
        }
      }
      pgHdr2.pDirty = pA == null ? (pB == null ? (Sqlite3.PgHdr) null : pB) : pA;
      return pgHdr1.pDirty;
    }

    private static Sqlite3.PgHdr pcacheSortDirtyList(Sqlite3.PgHdr pIn)
    {
      Sqlite3.PgHdr[] pgHdrArray = new Sqlite3.PgHdr[32];
      while (pIn != null)
      {
        Sqlite3.PgHdr pB = pIn;
        pIn = pB.pDirty;
        pB.pDirty = (Sqlite3.PgHdr) null;
        int index;
        for (index = 0; Sqlite3.ALWAYS(index < 31); ++index)
        {
          if (pgHdrArray[index] == null)
          {
            pgHdrArray[index] = pB;
            break;
          }
          pB = Sqlite3.pcacheMergeDirtyList(pgHdrArray[index], pB);
          pgHdrArray[index] = (Sqlite3.PgHdr) null;
        }
        if (Sqlite3.NEVER(index == 31))
          pgHdrArray[index] = Sqlite3.pcacheMergeDirtyList(pgHdrArray[index], pB);
      }
      Sqlite3.PgHdr pA = pgHdrArray[0];
      for (int index = 1; index < 32; ++index)
        pA = Sqlite3.pcacheMergeDirtyList(pA, pgHdrArray[index]);
      return pA;
    }

    private static Sqlite3.PgHdr sqlite3PcacheDirtyList(Sqlite3.PCache pCache)
    {
      for (Sqlite3.PgHdr pgHdr = pCache.pDirty; pgHdr != null; pgHdr = pgHdr.pDirtyNext)
        pgHdr.pDirty = pgHdr.pDirtyNext;
      return Sqlite3.pcacheSortDirtyList(pCache.pDirty);
    }

    private static int sqlite3PcacheRefCount(Sqlite3.PCache pCache) => pCache.nRef;

    private static int sqlite3PcachePageRefcount(Sqlite3.PgHdr p) => p.nRef;

    private static int sqlite3PcachePagecount(Sqlite3.PCache pCache)
    {
      int num = 0;
      if (pCache.pCache != null)
        num = Sqlite3.sqlite3GlobalConfig.pcache.xPagecount(pCache.pCache);
      return num;
    }

    private static void sqlite3PcacheSetCachesize(Sqlite3.PCache pCache, int mxPage)
    {
      pCache.nMax = mxPage;
      if (pCache.pCache == null)
        return;
      Sqlite3.sqlite3GlobalConfig.pcache.xCachesize(pCache.pCache, mxPage);
    }

    private static byte getSafetyLevel(string z)
    {
      string str = "onoffalseyestruefull";
      int[] numArray1 = new int[7]{ 0, 1, 2, 4, 9, 12, 16 };
      int[] x = new int[7]{ 2, 2, 3, 5, 3, 4, 4 };
      byte[] numArray2 = new byte[7]
      {
        (byte) 1,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 1,
        (byte) 1,
        (byte) 2
      };
      if (Sqlite3.sqlite3Isdigit(z[0]))
        return (byte) Sqlite3.sqlite3Atoi(z);
      int N = Sqlite3.sqlite3Strlen30(z);
      for (int index = 0; index < Sqlite3.ArraySize<int>(x); ++index)
      {
        if (x[index] == N && Sqlite3.sqlite3StrNICmp(str.Substring(numArray1[index]), z, N) == 0)
          return numArray2[index];
      }
      return 1;
    }

    private static byte sqlite3GetBoolean(string z) => (byte) ((uint) Sqlite3.getSafetyLevel(z) & 1U);

    private static int getLockingMode(string z)
    {
      if (z != null)
      {
        if (z.Equals("exclusive", StringComparison.InvariantCultureIgnoreCase))
          return Sqlite3.PAGER_LOCKINGMODE_EXCLUSIVE;
        if (z.Equals("normal", StringComparison.InvariantCultureIgnoreCase))
          return Sqlite3.PAGER_LOCKINGMODE_NORMAL;
      }
      return Sqlite3.PAGER_LOCKINGMODE_QUERY;
    }

    private static byte getAutoVacuum(string z)
    {
      if (z.Equals("none", StringComparison.InvariantCultureIgnoreCase))
        return 0;
      if (z.Equals("full", StringComparison.InvariantCultureIgnoreCase))
        return 1;
      if (z.Equals("incremental", StringComparison.InvariantCultureIgnoreCase))
        return 2;
      int num = Sqlite3.atoi(z);
      return num < 0 || num > 2 ? (byte) 0 : (byte) num;
    }

    private static int getTempStore(string z)
    {
      if (z[0] >= '0' && z[0] <= '2')
        return (int) z[0] - 48;
      if (z.Equals("file", StringComparison.InvariantCultureIgnoreCase))
        return 1;
      return z.Equals("memory", StringComparison.InvariantCultureIgnoreCase) ? 2 : 0;
    }

    private static int invalidateTempStorage(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (db.aDb[1].pBt != null)
      {
        if (db.autoCommit == (byte) 0 || Sqlite3.sqlite3BtreeIsInReadTrans(db.aDb[1].pBt))
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "temporary storage cannot be changed from within a transaction");
          return 1;
        }
        Sqlite3.sqlite3BtreeClose(ref db.aDb[1].pBt);
        db.aDb[1].pBt = (Sqlite3.Btree) null;
        Sqlite3.sqlite3ResetInternalSchema(db, -1);
      }
      return 0;
    }

    private static int changeTempStorage(Sqlite3.Parse pParse, string zStorageType)
    {
      int tempStore = Sqlite3.getTempStore(zStorageType);
      Sqlite3.sqlite3 db = pParse.db;
      if ((int) db.temp_store == tempStore)
        return 0;
      if (Sqlite3.invalidateTempStorage(pParse) != 0)
        return 1;
      db.temp_store = (byte) tempStore;
      return 0;
    }

    private static void returnSingleInt(Sqlite3.Parse pParse, string zLabel, long value)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      int num = ++pParse.nMem;
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 8, 0, num, 0, value, -13);
      Sqlite3.sqlite3VdbeSetNumCols(vdbe, 1);
      Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, zLabel, Sqlite3.SQLITE_STATIC);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, num, 1);
    }

    private static int flagPragma(Sqlite3.Parse pParse, string zLeft, string zRight)
    {
      Sqlite3.sPragmaType[] x = new Sqlite3.sPragmaType[15]
      {
        new Sqlite3.sPragmaType("full_column_names", 1024),
        new Sqlite3.sPragmaType("short_column_names", 2048),
        new Sqlite3.sPragmaType("count_changes", 4096),
        new Sqlite3.sPragmaType("empty_result_callbacks", 8192),
        new Sqlite3.sPragmaType("legacy_file_format", 1048576),
        new Sqlite3.sPragmaType("fullfsync", 2097152),
        new Sqlite3.sPragmaType("checkpoint_fullfsync", 4194304),
        new Sqlite3.sPragmaType("reverse_unordered_selects", 16777216),
        new Sqlite3.sPragmaType("automatic_index", 134217728),
        new Sqlite3.sPragmaType("ignore_check_constraints", 262144),
        new Sqlite3.sPragmaType("writable_schema", 8454144),
        new Sqlite3.sPragmaType("omit_readlock", 131072),
        new Sqlite3.sPragmaType("read_uncommitted", 524288),
        new Sqlite3.sPragmaType("recursive_triggers", 33554432),
        new Sqlite3.sPragmaType("foreign_keys", 67108864)
      };
      for (int index = 0; index < Sqlite3.ArraySize<Sqlite3.sPragmaType>(x); ++index)
      {
        Sqlite3.sPragmaType sPragmaType = x[index];
        if (zLeft.Equals(sPragmaType.zName, StringComparison.InvariantCultureIgnoreCase))
        {
          Sqlite3.sqlite3 db = pParse.db;
          Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
          if (Sqlite3.ALWAYS<Sqlite3.Vdbe>(vdbe))
          {
            if (zRight == null)
            {
              Sqlite3.returnSingleInt(pParse, sPragmaType.zName, (db.flags & sPragmaType.mask) != 0 ? 1L : 0L);
            }
            else
            {
              int mask = sPragmaType.mask;
              if (db.autoCommit == (byte) 0)
                mask &= -67108865;
              if (Sqlite3.sqlite3GetBoolean(zRight) != (byte) 0)
                db.flags |= mask;
              else
                db.flags &= ~mask;
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 122, 0, 0);
            }
          }
          return 1;
        }
      }
      return 0;
    }

    private static string actionName(int action)
    {
      string str;
      switch (action)
      {
        case 6:
          str = "RESTRICT";
          break;
        case 7:
          str = "SET NULL";
          break;
        case 8:
          str = "SET DEFAULT";
          break;
        case 9:
          str = "CASCADE";
          break;
        default:
          str = "NO ACTION";
          break;
      }
      return str;
    }

    private static string sqlite3JournalModename(int eMode)
    {
      string[] x = new string[5]
      {
        "delete",
        "persist",
        "off",
        "truncate",
        "memory"
      };
      return eMode == Sqlite3.ArraySize<string>(x) ? (string) null : x[eMode];
    }

    private static void sqlite3Pragma(
      Sqlite3.Parse pParse,
      Sqlite3.Token pId1,
      Sqlite3.Token pId2,
      int null_4,
      int minusFlag)
    {
      Sqlite3.sqlite3Pragma(pParse, pId1, pId2, (Sqlite3.Token) null, minusFlag);
    }

    private static void sqlite3Pragma(
      Sqlite3.Parse pParse,
      Sqlite3.Token pId1,
      Sqlite3.Token pId2,
      Sqlite3.Token pValue,
      int minusFlag)
    {
      Sqlite3.Token pUnqual = new Sqlite3.Token();
      Sqlite3.sqlite3 db1 = pParse.db;
      Sqlite3.Vdbe p = pParse.pVdbe = Sqlite3.sqlite3VdbeCreate(db1);
      if (p == null)
        return;
      Sqlite3.sqlite3VdbeRunOnlyOnce(p);
      pParse.nMem = 2;
      int index1 = Sqlite3.sqlite3TwoPartName(pParse, pId1, pId2, ref pUnqual);
      if (index1 < 0)
        return;
      Sqlite3.Db db2 = db1.aDb[index1];
      if (index1 == 1 && Sqlite3.sqlite3OpenTempDatabase(pParse) != 0)
        return;
      string pString1 = Sqlite3.sqlite3NameFromToken(db1, pUnqual);
      if (pString1 == "")
        return;
      string pString2;
      if (minusFlag != 0)
      {
        string str;
        if (pValue != null)
          str = Sqlite3.sqlite3MPrintf(db1, "-%T", (object) pValue);
        else
          str = "";
        pString2 = str;
      }
      else
        pString2 = Sqlite3.sqlite3NameFromToken(db1, pValue);
      string str1 = pId2.n > 0 ? db2.zName : (string) null;
      if (pString1.Equals("default_cache_size", StringComparison.InvariantCultureIgnoreCase))
      {
        Sqlite3.VdbeOpList[] aOp = new Sqlite3.VdbeOpList[8]
        {
          new Sqlite3.VdbeOpList((byte) 34, 0, 0, 0),
          new Sqlite3.VdbeOpList((byte) 35, 0, 1, 3),
          new Sqlite3.VdbeOpList((byte) 113, 1, 7, 0),
          new Sqlite3.VdbeOpList((byte) 7, 0, 2, 0),
          new Sqlite3.VdbeOpList((byte) 87, 1, 2, 1),
          new Sqlite3.VdbeOpList((byte) 113, 1, 7, 0),
          new Sqlite3.VdbeOpList((byte) 7, 0, 1, 0),
          new Sqlite3.VdbeOpList((byte) 16, 1, 1, 0)
        };
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          Sqlite3.sqlite3VdbeUsesBtree(p, index1);
          if (pString2 == null)
          {
            Sqlite3.sqlite3VdbeSetNumCols(p, 1);
            Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "cache_size", Sqlite3.SQLITE_STATIC);
            pParse.nMem += 2;
            int addr = Sqlite3.sqlite3VdbeAddOpList(p, aOp.Length, aOp);
            Sqlite3.sqlite3VdbeChangeP1(p, addr, index1);
            Sqlite3.sqlite3VdbeChangeP1(p, addr + 1, index1);
            Sqlite3.sqlite3VdbeChangeP1(p, addr + 6, 2000);
          }
          else
          {
            int p1 = Sqlite3.sqlite3AbsInt32(Sqlite3.sqlite3Atoi(pString2));
            Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index1);
            Sqlite3.sqlite3VdbeAddOp2(p, 7, p1, 1);
            Sqlite3.sqlite3VdbeAddOp3(p, 36, index1, 3, 1);
            db2.pSchema.cache_size = p1;
            Sqlite3.sqlite3BtreeSetCacheSize(db2.pBt, db2.pSchema.cache_size);
          }
        }
        else
          goto label_227;
      }
      else if (pString1.Equals("page_size", StringComparison.InvariantCultureIgnoreCase))
      {
        Sqlite3.Btree pBt = db2.pBt;
        if (pString2 == null)
        {
          int num = Sqlite3.ALWAYS<Sqlite3.Btree>(pBt) ? Sqlite3.sqlite3BtreeGetPageSize(pBt) : 0;
          Sqlite3.returnSingleInt(pParse, "page_size", (long) num);
        }
        else
        {
          db1.nextPagesize = Sqlite3.sqlite3Atoi(pString2);
          if (7 != Sqlite3.sqlite3BtreeSetPageSize(pBt, db1.nextPagesize, -1, 0))
            ;
        }
      }
      else if (pString1.Equals("secure_delete", StringComparison.InvariantCultureIgnoreCase))
      {
        Sqlite3.Btree pBt = db2.pBt;
        int newFlag = -1;
        if (pString2 != null)
          newFlag = (int) Sqlite3.sqlite3GetBoolean(pString2);
        if (pId2.n == 0 && newFlag >= 0)
        {
          for (int index2 = 0; index2 < db1.nDb; ++index2)
            Sqlite3.sqlite3BtreeSecureDelete(db1.aDb[index2].pBt, newFlag);
        }
        int num = Sqlite3.sqlite3BtreeSecureDelete(pBt, newFlag);
        Sqlite3.returnSingleInt(pParse, "secure_delete", (long) num);
      }
      else if (pString1.Equals("page_count", StringComparison.InvariantCultureIgnoreCase) || pString1.Equals("max_page_count", StringComparison.InvariantCultureIgnoreCase))
      {
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          Sqlite3.sqlite3CodeVerifySchema(pParse, index1);
          int num = ++pParse.nMem;
          if (pString1[0] == 'p')
            Sqlite3.sqlite3VdbeAddOp2(p, 134, index1, num);
          else
            Sqlite3.sqlite3VdbeAddOp3(p, 135, index1, num, Sqlite3.sqlite3Atoi(pString2));
          Sqlite3.sqlite3VdbeAddOp2(p, 16, num, 1);
          Sqlite3.sqlite3VdbeSetNumCols(p, 1);
          Sqlite3.sqlite3VdbeSetColName(p, 0, 0, pString1, Sqlite3.SQLITE_TRANSIENT);
        }
        else
          goto label_227;
      }
      else if (pString1 == "page_count")
      {
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
        if (vdbe != null && Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          Sqlite3.sqlite3CodeVerifySchema(pParse, index1);
          int num = ++pParse.nMem;
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 134, index1, num);
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, num, 1);
          Sqlite3.sqlite3VdbeSetNumCols(vdbe, 1);
          Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, "page_count", Sqlite3.SQLITE_STATIC);
        }
        else
          goto label_227;
      }
      else if (pString1.Equals("locking_mode", StringComparison.InvariantCultureIgnoreCase))
      {
        string pP4 = "normal";
        int lockingMode = Sqlite3.getLockingMode(pString2);
        int num;
        if (pId2.n == 0 && lockingMode == Sqlite3.PAGER_LOCKINGMODE_QUERY)
        {
          num = (int) db1.dfltLockMode;
        }
        else
        {
          if (pId2.n == 0)
          {
            for (int index3 = 2; index3 < db1.nDb; ++index3)
              Sqlite3.sqlite3PagerLockingMode(Sqlite3.sqlite3BtreePager(db1.aDb[index3].pBt), lockingMode);
            db1.dfltLockMode = (byte) lockingMode;
          }
          num = Sqlite3.sqlite3PagerLockingMode(Sqlite3.sqlite3BtreePager(db2.pBt), lockingMode) ? 1 : 0;
        }
        if (num == Sqlite3.PAGER_LOCKINGMODE_EXCLUSIVE)
          pP4 = "exclusive";
        Sqlite3.sqlite3VdbeSetNumCols(p, 1);
        Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "locking_mode", Sqlite3.SQLITE_STATIC);
        Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 1, 0, pP4, 0);
        Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 1);
      }
      else if (pString1 == "journal_mode")
      {
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          Sqlite3.sqlite3VdbeSetNumCols(p, 1);
          Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "journal_mode", Sqlite3.SQLITE_STATIC);
          int num;
          if (pString2 == null)
          {
            num = -1;
          }
          else
          {
            int N = Sqlite3.sqlite3Strlen30(pString2);
            num = 0;
            string zRight;
            while ((zRight = Sqlite3.sqlite3JournalModename(num)) != null && Sqlite3.sqlite3StrNICmp(pString2, zRight, N) != 0)
              ++num;
            if (zRight == null)
              num = -1;
          }
          if (num == -1 && pId2.n == 0)
          {
            index1 = 0;
            pId2.n = 1;
          }
          for (int index4 = db1.nDb - 1; index4 >= 0; --index4)
          {
            if (db1.aDb[index4].pBt != null && (index4 == index1 || pId2.n == 0))
            {
              Sqlite3.sqlite3VdbeUsesBtree(p, index4);
              Sqlite3.sqlite3VdbeAddOp3(p, 119, index4, 1, num);
            }
          }
          Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 1);
        }
        else
          goto label_227;
      }
      else if (pString1.Equals("journal_size_limit", StringComparison.InvariantCultureIgnoreCase))
      {
        Sqlite3.Pager pPager = Sqlite3.sqlite3BtreePager(db2.pBt);
        long pNum = -2;
        if (!string.IsNullOrEmpty(pString2))
        {
          Sqlite3.sqlite3Atoi64(pString2, ref pNum, 1000000, (byte) 1);
          if (pNum < -1L)
            pNum = -1L;
        }
        long iLimit = pNum;
        pNum = Sqlite3.sqlite3PagerJournalSizeLimit(pPager, iLimit);
        Sqlite3.returnSingleInt(pParse, "journal_size_limit", pNum);
      }
      else if (pString1.Equals("auto_vacuum", StringComparison.InvariantCultureIgnoreCase))
      {
        Sqlite3.Btree pBt = db2.pBt;
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          if (pString2 == null)
          {
            int num = !Sqlite3.ALWAYS<Sqlite3.Btree>(pBt) ? 0 : Sqlite3.sqlite3BtreeGetAutoVacuum(pBt);
            Sqlite3.returnSingleInt(pParse, "auto_vacuum", (long) num);
          }
          else
          {
            int autoVacuum = (int) Sqlite3.getAutoVacuum(pString2);
            db1.nextAutovac = (int) (byte) autoVacuum;
            if (Sqlite3.ALWAYS(autoVacuum >= 0) && Sqlite3.sqlite3BtreeSetAutoVacuum(pBt, autoVacuum) == 0 && (autoVacuum == 1 || autoVacuum == 2))
            {
              Sqlite3.VdbeOpList[] vdbeOpListArray = new Sqlite3.VdbeOpList[6]
              {
                new Sqlite3.VdbeOpList((byte) 34, 0, 1, 0),
                new Sqlite3.VdbeOpList((byte) 35, 0, 1, 4),
                new Sqlite3.VdbeOpList((byte) 26, 1, 0, 0),
                new Sqlite3.VdbeOpList((byte) 6, 0, 2, 0),
                new Sqlite3.VdbeOpList((byte) 7, 0, 1, 0),
                new Sqlite3.VdbeOpList((byte) 36, 0, 7, 1)
              };
              int addr = Sqlite3.sqlite3VdbeAddOpList(p, Sqlite3.ArraySize<Sqlite3.VdbeOpList>(vdbeOpListArray), vdbeOpListArray);
              Sqlite3.sqlite3VdbeChangeP1(p, addr, index1);
              Sqlite3.sqlite3VdbeChangeP1(p, addr + 1, index1);
              Sqlite3.sqlite3VdbeChangeP2(p, addr + 2, addr + 4);
              Sqlite3.sqlite3VdbeChangeP1(p, addr + 4, autoVacuum - 1);
              Sqlite3.sqlite3VdbeChangeP1(p, addr + 5, index1);
              Sqlite3.sqlite3VdbeUsesBtree(p, index1);
            }
          }
        }
        else
          goto label_227;
      }
      else if (pString1.Equals("incremental_vacuum", StringComparison.InvariantCultureIgnoreCase))
      {
        int pValue1 = 0;
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          if (pString2 == null || !Sqlite3.sqlite3GetInt32(pString2, ref pValue1) || pValue1 <= 0)
            pValue1 = int.MaxValue;
          Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index1);
          Sqlite3.sqlite3VdbeAddOp2(p, 7, pValue1, 1);
          int num = Sqlite3.sqlite3VdbeAddOp1(p, 121, index1);
          Sqlite3.sqlite3VdbeAddOp1(p, 16, 1);
          Sqlite3.sqlite3VdbeAddOp2(p, 20, 1, -1);
          Sqlite3.sqlite3VdbeAddOp2(p, 113, 1, num);
          Sqlite3.sqlite3VdbeJumpHere(p, num);
        }
        else
          goto label_227;
      }
      else if (pString1.Equals("cache_size", StringComparison.InvariantCultureIgnoreCase))
      {
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          if (pString2 == null)
          {
            Sqlite3.returnSingleInt(pParse, "cache_size", (long) db2.pSchema.cache_size);
          }
          else
          {
            int num = Sqlite3.sqlite3AbsInt32(Sqlite3.sqlite3Atoi(pString2));
            db2.pSchema.cache_size = num;
            Sqlite3.sqlite3BtreeSetCacheSize(db2.pBt, db2.pSchema.cache_size);
          }
        }
        else
          goto label_227;
      }
      else if (pString1.Equals("temp_store", StringComparison.InvariantCultureIgnoreCase))
      {
        if (pString2 == null)
          Sqlite3.returnSingleInt(pParse, "temp_store", (long) db1.temp_store);
        else
          Sqlite3.changeTempStorage(pParse, pString2);
      }
      else if (pString1.Equals("temp_store_directory", StringComparison.InvariantCultureIgnoreCase))
      {
        if (pString2 == null)
        {
          if (Sqlite3.sqlite3_temp_directory != "")
          {
            Sqlite3.sqlite3VdbeSetNumCols(p, 1);
            Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "temp_store_directory", Sqlite3.SQLITE_STATIC);
            Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 1, 0, Sqlite3.sqlite3_temp_directory, 0);
            Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 1);
          }
        }
        else
        {
          if (pString2.Length > 0)
          {
            int pResOut = 0;
            if (Sqlite3.sqlite3OsAccess(db1.pVfs, pString2, 1, ref pResOut) != 0 || pResOut == 0)
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "not a writable directory");
              goto label_227;
            }
          }
          if (Sqlite3.SQLITE_TEMP_STORE == 0 || Sqlite3.SQLITE_TEMP_STORE == 1 && db1.temp_store <= (byte) 1 || Sqlite3.SQLITE_TEMP_STORE == 2 && db1.temp_store == (byte) 1)
            Sqlite3.invalidateTempStorage(pParse);
          Sqlite3.sqlite3_temp_directory = pString2.Length <= 0 ? "" : pString2;
        }
      }
      else if (pString1.Equals("synchronous", StringComparison.InvariantCultureIgnoreCase))
      {
        if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
        {
          if (pString2 == null)
            Sqlite3.returnSingleInt(pParse, "synchronous", (long) ((int) db2.safety_level - 1));
          else if (db1.autoCommit == (byte) 0)
            Sqlite3.sqlite3ErrorMsg(pParse, "Safety level may not be changed inside a transaction");
          else
            db2.safety_level = (byte) ((uint) Sqlite3.getSafetyLevel(pString2) + 1U);
        }
        else
          goto label_227;
      }
      else if (Sqlite3.flagPragma(pParse, pString1, pString2) == 0)
      {
        if (pString1.Equals("table_info", StringComparison.InvariantCultureIgnoreCase) && pString2 != null)
        {
          if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
          {
            Sqlite3.Table table = Sqlite3.sqlite3FindTable(db1, pString2, str1);
            if (table != null)
            {
              int num = 0;
              Sqlite3.sqlite3VdbeSetNumCols(p, 6);
              pParse.nMem = 6;
              Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "cid", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 1, 0, "name", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 2, 0, "type", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 3, 0, "notnull", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 4, 0, "dflt_value", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 5, 0, "pk", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3ViewGetColumnNames(pParse, table);
              for (int index5 = 0; index5 < table.nCol; ++index5)
              {
                Sqlite3.Column C = table.aCol[index5];
                if (Sqlite3.IsHiddenColumn(C))
                {
                  ++num;
                }
                else
                {
                  Sqlite3.sqlite3VdbeAddOp2(p, 7, index5 - num, 1);
                  Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 2, 0, C.zName, 0);
                  Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 3, 0, C.zType != null ? C.zType : "", 0);
                  Sqlite3.sqlite3VdbeAddOp2(p, 7, C.notNull != (byte) 0 ? 1 : 0, 4);
                  if (C.zDflt != null)
                    Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 5, 0, C.zDflt, 0);
                  else
                    Sqlite3.sqlite3VdbeAddOp2(p, 10, 0, 5);
                  Sqlite3.sqlite3VdbeAddOp2(p, 7, C.isPrimKey != (byte) 0 ? 1 : 0, 6);
                  Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 6);
                }
              }
            }
          }
          else
            goto label_227;
        }
        else if (pString1.Equals("index_info", StringComparison.InvariantCultureIgnoreCase) && pString2 != null)
        {
          if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
          {
            Sqlite3.Index index6 = Sqlite3.sqlite3FindIndex(db1, pString2, str1);
            if (index6 != null)
            {
              Sqlite3.Table pTable = index6.pTable;
              Sqlite3.sqlite3VdbeSetNumCols(p, 3);
              pParse.nMem = 3;
              Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "seqno", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 1, 0, "cid", Sqlite3.SQLITE_STATIC);
              Sqlite3.sqlite3VdbeSetColName(p, 2, 0, "name", Sqlite3.SQLITE_STATIC);
              for (int p1_1 = 0; p1_1 < index6.nColumn; ++p1_1)
              {
                int p1_2 = index6.aiColumn[p1_1];
                Sqlite3.sqlite3VdbeAddOp2(p, 7, p1_1, 1);
                Sqlite3.sqlite3VdbeAddOp2(p, 7, p1_2, 2);
                Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 3, 0, pTable.aCol[p1_2].zName, 0);
                Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 3);
              }
            }
          }
          else
            goto label_227;
        }
        else if (pString1.Equals("index_list", StringComparison.InvariantCultureIgnoreCase) && pString2 != null)
        {
          if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
          {
            Sqlite3.Table table = Sqlite3.sqlite3FindTable(db1, pString2, str1);
            if (table != null)
            {
              Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
              Sqlite3.Index index7 = table.pIndex;
              if (index7 != null)
              {
                int p1 = 0;
                Sqlite3.sqlite3VdbeSetNumCols(vdbe, 3);
                pParse.nMem = 3;
                Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, "seq", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 1, 0, "name", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 2, 0, "unique", Sqlite3.SQLITE_STATIC);
                for (; index7 != null; index7 = index7.pNext)
                {
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, p1, 1);
                  Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, 2, 0, index7.zName, 0);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, index7.onError != (byte) 0 ? 1 : 0, 3);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, 1, 3);
                  ++p1;
                }
              }
            }
          }
          else
            goto label_227;
        }
        else if (pString1.Equals("database_list", StringComparison.InvariantCultureIgnoreCase))
        {
          if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
          {
            Sqlite3.sqlite3VdbeSetNumCols(p, 3);
            pParse.nMem = 3;
            Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "seq", Sqlite3.SQLITE_STATIC);
            Sqlite3.sqlite3VdbeSetColName(p, 1, 0, "name", Sqlite3.SQLITE_STATIC);
            Sqlite3.sqlite3VdbeSetColName(p, 2, 0, "file", Sqlite3.SQLITE_STATIC);
            for (int p1 = 0; p1 < db1.nDb; ++p1)
            {
              if (db1.aDb[p1].pBt != null)
              {
                Sqlite3.sqlite3VdbeAddOp2(p, 7, p1, 1);
                Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 2, 0, db1.aDb[p1].zName, 0);
                Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 3, 0, Sqlite3.sqlite3BtreeGetFilename(db1.aDb[p1].pBt), 0);
                Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 3);
              }
            }
          }
          else
            goto label_227;
        }
        else if (pString1.Equals("collation_list", StringComparison.InvariantCultureIgnoreCase))
        {
          int num = 0;
          Sqlite3.sqlite3VdbeSetNumCols(p, 2);
          pParse.nMem = 2;
          Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "seq", Sqlite3.SQLITE_STATIC);
          Sqlite3.sqlite3VdbeSetColName(p, 1, 0, "name", Sqlite3.SQLITE_STATIC);
          for (Sqlite3.HashElem hashElem = db1.aCollSeq.first; hashElem != null; hashElem = hashElem.next)
          {
            Sqlite3.CollSeq collSeq = ((Sqlite3.CollSeq[]) hashElem.data)[0];
            Sqlite3.sqlite3VdbeAddOp2(p, 7, num++, 1);
            Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 2, 0, collSeq.zName, 0);
            Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 2);
          }
        }
        else if (pString1.Equals("foreign_key_list", StringComparison.InvariantCultureIgnoreCase) && pString2 != null)
        {
          if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
          {
            Sqlite3.Table table = Sqlite3.sqlite3FindTable(db1, pString2, str1);
            if (table != null)
            {
              Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
              Sqlite3.FKey fkey = table.pFKey;
              if (fkey != null)
              {
                int p1_3 = 0;
                Sqlite3.sqlite3VdbeSetNumCols(vdbe, 8);
                pParse.nMem = 8;
                Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, "id", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 1, 0, "seq", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 2, 0, "table", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 3, 0, "from", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 4, 0, "to", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 5, 0, "on_update", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 6, 0, "on_delete", Sqlite3.SQLITE_STATIC);
                Sqlite3.sqlite3VdbeSetColName(vdbe, 7, 0, "match", Sqlite3.SQLITE_STATIC);
                for (; fkey != null; fkey = fkey.pNextFrom)
                {
                  for (int p1_4 = 0; p1_4 < fkey.nCol; ++p1_4)
                  {
                    string zCol = fkey.aCol[p1_4].zCol;
                    string pP4_1 = Sqlite3.actionName((int) fkey.aAction[0]);
                    string pP4_2 = Sqlite3.actionName((int) fkey.aAction[1]);
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, p1_3, 1);
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, p1_4, 2);
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, 3, 0, fkey.zTo, 0);
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, 4, 0, table.aCol[fkey.aCol[p1_4].iFrom].zName, 0);
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, zCol != null ? 94 : 10, 0, 5, 0, zCol, 0);
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, 6, 0, pP4_2, 0);
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, 7, 0, pP4_1, 0);
                    Sqlite3.sqlite3VdbeAddOp4(vdbe, 94, 0, 8, 0, "NONE", 0);
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, 1, 8);
                  }
                  ++p1_3;
                }
              }
            }
          }
          else
            goto label_227;
        }
        else if (pString1.Equals("case_sensitive_like", StringComparison.InvariantCultureIgnoreCase))
        {
          if (pString2 != null)
            Sqlite3.sqlite3RegisterLikeFunctions(db1, (int) Sqlite3.sqlite3GetBoolean(pString2));
        }
        else if (pString1.Equals("integrity_check", StringComparison.InvariantCultureIgnoreCase) || pString1.Equals("quick_check", StringComparison.InvariantCultureIgnoreCase))
        {
          Sqlite3.VdbeOpList[] vdbeOpListArray1 = new Sqlite3.VdbeOpList[4]
          {
            new Sqlite3.VdbeOpList((byte) 20, 1, 0, 0),
            new Sqlite3.VdbeOpList((byte) 114, 1, 0, 0),
            new Sqlite3.VdbeOpList((byte) 94, 0, 3, 0),
            new Sqlite3.VdbeOpList((byte) 16, 3, 1, 0)
          };
          bool flag = pString1[0] == 'q';
          if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
          {
            pParse.nMem = 6;
            Sqlite3.sqlite3VdbeSetNumCols(p, 1);
            Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "integrity_check", Sqlite3.SQLITE_STATIC);
            int pValue2 = 100;
            if (pString2 != null)
            {
              Sqlite3.sqlite3GetInt32(pString2, ref pValue2);
              if (pValue2 <= 0)
                pValue2 = 100;
            }
            Sqlite3.sqlite3VdbeAddOp2(p, 7, pValue2, 1);
            for (int index8 = 0; index8 < db1.nDb; ++index8)
            {
              int p2 = 0;
              if (Sqlite3.OMIT_TEMPDB == 0 || index8 != 1)
              {
                Sqlite3.sqlite3CodeVerifySchema(pParse, index8);
                int addr1 = Sqlite3.sqlite3VdbeAddOp1(p, 113, 1);
                Sqlite3.sqlite3VdbeAddOp2(p, 6, 0, 0);
                Sqlite3.sqlite3VdbeJumpHere(p, addr1);
                Sqlite3.Hash tblHash = db1.aDb[index8].pSchema.tblHash;
                for (Sqlite3.HashElem hashElem = tblHash.first; hashElem != null; hashElem = hashElem.next)
                {
                  Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
                  Sqlite3.sqlite3VdbeAddOp2(p, 7, data.tnum, 2 + p2);
                  ++p2;
                  for (Sqlite3.Index index9 = data.pIndex; index9 != null; index9 = index9.pNext)
                  {
                    Sqlite3.sqlite3VdbeAddOp2(p, 7, index9.tnum, 2 + p2);
                    ++p2;
                  }
                }
                if (pParse.nMem < p2 + 4)
                  pParse.nMem = p2 + 4;
                Sqlite3.sqlite3VdbeAddOp3(p, 104, 2, p2, 1);
                Sqlite3.sqlite3VdbeChangeP5(p, (byte) index8);
                int addr2 = Sqlite3.sqlite3VdbeAddOp1(p, 73, 2);
                Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 3, 0, Sqlite3.sqlite3MPrintf(db1, "*** in database %s ***\n", (object) db1.aDb[index8].zName), -1);
                Sqlite3.sqlite3VdbeAddOp3(p, 13, 2, 4, 1);
                Sqlite3.sqlite3VdbeAddOp3(p, 91, 4, 3, 2);
                Sqlite3.sqlite3VdbeAddOp2(p, 16, 2, 1);
                Sqlite3.sqlite3VdbeJumpHere(p, addr2);
                for (Sqlite3.HashElem hashElem = tblHash.first; hashElem != null && !flag; hashElem = hashElem.next)
                {
                  Sqlite3.Table data = (Sqlite3.Table) hashElem.data;
                  if (data.pIndex != null)
                  {
                    int addr3 = Sqlite3.sqlite3VdbeAddOp1(p, 113, 1);
                    Sqlite3.sqlite3VdbeAddOp2(p, 6, 0, 0);
                    Sqlite3.sqlite3VdbeJumpHere(p, addr3);
                    Sqlite3.sqlite3OpenTableAndIndices(pParse, data, 1, 38);
                    Sqlite3.sqlite3VdbeAddOp2(p, 7, 0, 2);
                    int addr4 = Sqlite3.sqlite3VdbeAddOp2(p, 65, 1, 0);
                    Sqlite3.sqlite3VdbeAddOp2(p, 20, 2, 1);
                    int num1 = 0;
                    Sqlite3.Index pIdx = data.pIndex;
                    while (pIdx != null)
                    {
                      Sqlite3.VdbeOpList[] vdbeOpListArray2 = new Sqlite3.VdbeOpList[11]
                      {
                        new Sqlite3.VdbeOpList((byte) 20, 1, -1, 0),
                        new Sqlite3.VdbeOpList((byte) 94, 0, 3, 0),
                        new Sqlite3.VdbeOpList((byte) 61, 1, 4, 0),
                        new Sqlite3.VdbeOpList((byte) 94, 0, 5, 0),
                        new Sqlite3.VdbeOpList((byte) 94, 0, 6, 0),
                        new Sqlite3.VdbeOpList((byte) 91, 4, 3, 3),
                        new Sqlite3.VdbeOpList((byte) 91, 5, 3, 3),
                        new Sqlite3.VdbeOpList((byte) 91, 6, 3, 3),
                        new Sqlite3.VdbeOpList((byte) 16, 3, 1, 0),
                        new Sqlite3.VdbeOpList((byte) 113, 1, 0, 0),
                        new Sqlite3.VdbeOpList((byte) 6, 0, 0, 0)
                      };
                      int indexKey = Sqlite3.sqlite3GenerateIndexKey(pParse, pIdx, 1, 3, false);
                      int addr5 = Sqlite3.sqlite3VdbeAddOp4Int(p, 50, num1 + 2, 0, indexKey, pIdx.nColumn + 1);
                      int num2 = Sqlite3.sqlite3VdbeAddOpList(p, Sqlite3.ArraySize<Sqlite3.VdbeOpList>(vdbeOpListArray2), vdbeOpListArray2);
                      Sqlite3.sqlite3VdbeChangeP4(p, num2 + 1, "rowid ", Sqlite3.SQLITE_STATIC);
                      Sqlite3.sqlite3VdbeChangeP4(p, num2 + 3, " missing from index ", Sqlite3.SQLITE_STATIC);
                      Sqlite3.sqlite3VdbeChangeP4(p, num2 + 4, pIdx.zName, 0);
                      Sqlite3.sqlite3VdbeJumpHere(p, num2 + 9);
                      Sqlite3.sqlite3VdbeJumpHere(p, addr5);
                      pIdx = pIdx.pNext;
                      ++num1;
                    }
                    Sqlite3.sqlite3VdbeAddOp2(p, 67, 1, addr4 + 1);
                    Sqlite3.sqlite3VdbeJumpHere(p, addr4);
                    int num3 = 0;
                    Sqlite3.Index index10 = data.pIndex;
                    while (index10 != null)
                    {
                      Sqlite3.VdbeOpList[] vdbeOpListArray3 = new Sqlite3.VdbeOpList[10]
                      {
                        new Sqlite3.VdbeOpList((byte) 7, 0, 3, 0),
                        new Sqlite3.VdbeOpList((byte) 65, 0, 0, 0),
                        new Sqlite3.VdbeOpList((byte) 20, 3, 1, 0),
                        new Sqlite3.VdbeOpList((byte) 67, 0, 0, 0),
                        new Sqlite3.VdbeOpList((byte) 76, 2, 0, 3),
                        new Sqlite3.VdbeOpList((byte) 20, 1, -1, 0),
                        new Sqlite3.VdbeOpList((byte) 94, 0, 2, 0),
                        new Sqlite3.VdbeOpList((byte) 94, 0, 3, 0),
                        new Sqlite3.VdbeOpList((byte) 91, 3, 2, 2),
                        new Sqlite3.VdbeOpList((byte) 16, 2, 1, 0)
                      };
                      int addr6 = Sqlite3.sqlite3VdbeAddOp1(p, 113, 1);
                      Sqlite3.sqlite3VdbeAddOp2(p, 6, 0, 0);
                      Sqlite3.sqlite3VdbeJumpHere(p, addr6);
                      int num4 = Sqlite3.sqlite3VdbeAddOpList(p, Sqlite3.ArraySize<Sqlite3.VdbeOpList>(vdbeOpListArray3), vdbeOpListArray3);
                      Sqlite3.sqlite3VdbeChangeP1(p, num4 + 1, num3 + 2);
                      Sqlite3.sqlite3VdbeChangeP2(p, num4 + 1, num4 + 4);
                      Sqlite3.sqlite3VdbeChangeP1(p, num4 + 3, num3 + 2);
                      Sqlite3.sqlite3VdbeChangeP2(p, num4 + 3, num4 + 2);
                      Sqlite3.sqlite3VdbeJumpHere(p, num4 + 4);
                      Sqlite3.sqlite3VdbeChangeP4(p, num4 + 6, "wrong # of entries in index ", -2);
                      Sqlite3.sqlite3VdbeChangeP4(p, num4 + 7, index10.zName, 0);
                      index10 = index10.pNext;
                      ++num3;
                    }
                  }
                }
              }
            }
            int addr = Sqlite3.sqlite3VdbeAddOpList(p, Sqlite3.ArraySize<Sqlite3.VdbeOpList>(vdbeOpListArray1), vdbeOpListArray1);
            Sqlite3.sqlite3VdbeChangeP2(p, addr, -pValue2);
            Sqlite3.sqlite3VdbeJumpHere(p, addr + 1);
            Sqlite3.sqlite3VdbeChangeP4(p, addr + 2, "ok", -2);
          }
          else
            goto label_227;
        }
        else if (pString1.Equals("encoding", StringComparison.InvariantCultureIgnoreCase))
        {
          if (pString2 == null)
          {
            if (Sqlite3.sqlite3ReadSchema(pParse) != 0)
            {
              pParse.nErr = 0;
              pParse.zErrMsg = (string) null;
              pParse.rc = 0;
            }
            Sqlite3.sqlite3VdbeSetNumCols(p, 1);
            Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "encoding", Sqlite3.SQLITE_STATIC);
            Sqlite3.sqlite3VdbeAddOp2(p, 94, 0, 1);
            Sqlite3.sqlite3VdbeChangeP4(p, -1, Sqlite3.encnames[(int) Sqlite3.ENC(pParse.db)].zName, -2);
            Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 1);
          }
        }
        else if (pString1.Equals("schema_version", StringComparison.InvariantCultureIgnoreCase) || pString1.Equals("user_version", StringComparison.InvariantCultureIgnoreCase) || pString1.Equals("freelist_count", StringComparison.InvariantCultureIgnoreCase))
        {
          Sqlite3.sqlite3VdbeUsesBtree(p, index1);
          int val;
          switch (pString1[0])
          {
            case 'F':
            case 'f':
              val = 0;
              break;
            case 'S':
            case 's':
              val = 1;
              break;
            default:
              val = 6;
              break;
          }
          if (pString2 != null && val != 0)
          {
            Sqlite3.VdbeOpList[] vdbeOpListArray = new Sqlite3.VdbeOpList[3]
            {
              new Sqlite3.VdbeOpList((byte) 34, 0, 1, 0),
              new Sqlite3.VdbeOpList((byte) 7, 0, 1, 0),
              new Sqlite3.VdbeOpList((byte) 36, 0, 0, 1)
            };
            int addr = Sqlite3.sqlite3VdbeAddOpList(p, Sqlite3.ArraySize<Sqlite3.VdbeOpList>(vdbeOpListArray), vdbeOpListArray);
            Sqlite3.sqlite3VdbeChangeP1(p, addr, index1);
            Sqlite3.sqlite3VdbeChangeP1(p, addr + 1, Sqlite3.sqlite3Atoi(pString2));
            Sqlite3.sqlite3VdbeChangeP1(p, addr + 2, index1);
            Sqlite3.sqlite3VdbeChangeP2(p, addr + 2, val);
          }
          else
          {
            Sqlite3.VdbeOpList[] aOp = new Sqlite3.VdbeOpList[3]
            {
              new Sqlite3.VdbeOpList((byte) 34, 0, 0, 0),
              new Sqlite3.VdbeOpList((byte) 35, 0, 1, 0),
              new Sqlite3.VdbeOpList((byte) 16, 1, 1, 0)
            };
            int addr = Sqlite3.sqlite3VdbeAddOpList(p, aOp.Length, aOp);
            Sqlite3.sqlite3VdbeChangeP1(p, addr, index1);
            Sqlite3.sqlite3VdbeChangeP1(p, addr + 1, index1);
            Sqlite3.sqlite3VdbeChangeP3(p, addr + 1, val);
            Sqlite3.sqlite3VdbeSetNumCols(p, 1);
            Sqlite3.sqlite3VdbeSetColName(p, 0, 0, pString1, Sqlite3.SQLITE_TRANSIENT);
          }
        }
        else if (pString1.Equals("reload_schema", StringComparison.InvariantCultureIgnoreCase))
          Sqlite3.sqlite3ResetInternalSchema(db1, -1);
        else if (pString1.Equals("file_format", StringComparison.InvariantCultureIgnoreCase))
        {
          db2.pSchema.file_format = (byte) Sqlite3.atoi(pString2);
          Sqlite3.sqlite3ResetInternalSchema(db1, -1);
        }
        else if (pString1.Equals("compile_options", StringComparison.InvariantCultureIgnoreCase))
        {
          int num = 0;
          Sqlite3.sqlite3VdbeSetNumCols(p, 1);
          pParse.nMem = 1;
          Sqlite3.sqlite3VdbeSetColName(p, 0, 0, "compile_option", Sqlite3.SQLITE_STATIC);
          while (true)
          {
            int N = num++;
            string pP4;
            if ((pP4 = Sqlite3.sqlite3_compileoption_get(N)) != null)
            {
              Sqlite3.sqlite3VdbeAddOp4(p, 94, 0, 1, 0, pP4, 0);
              Sqlite3.sqlite3VdbeAddOp2(p, 16, 1, 1);
            }
            else
              break;
          }
        }
        else if (pString1.Equals("key", StringComparison.InvariantCultureIgnoreCase) && !string.IsNullOrEmpty(pString2))
          Sqlite3.sqlite3_key(db1, pString2, Sqlite3.sqlite3Strlen30(pString2));
        else if (pString1.Equals("rekey", StringComparison.InvariantCultureIgnoreCase) && !string.IsNullOrEmpty(pString2))
          Sqlite3.sqlite3_rekey(db1, pString2, Sqlite3.sqlite3Strlen30(pString2));
        else if (!string.IsNullOrEmpty(pString2) && (pString1.Equals("hexkey", StringComparison.InvariantCultureIgnoreCase) || pString1.Equals("hexrekey", StringComparison.InvariantCultureIgnoreCase)))
        {
          StringBuilder stringBuilder = new StringBuilder(40);
          pString2.ToLower(new CultureInfo("en-us"));
          if (pString2.Length != 34)
            return;
          for (int index11 = 2; index11 < pString2.Length; index11 += 2)
          {
            int num5 = (int) pString2[index11];
            int num6 = (int) pString2[index11 + 1];
            int num7 = num5 + 9 * (1 & num5 >> 6);
            int num8 = num6 + 9 * (1 & num6 >> 6);
            stringBuilder.Append(Convert.ToChar(num8 & 15 | (num7 & 15) << 4));
          }
          if (((int) pString1[3] & 15) == 11)
            Sqlite3.sqlite3_key(db1, stringBuilder.ToString(), stringBuilder.Length);
          else
            Sqlite3.sqlite3_rekey(db1, stringBuilder.ToString(), stringBuilder.Length);
        }
        else if (pString1.Equals("activate_extensions", StringComparison.InvariantCultureIgnoreCase) && !string.IsNullOrEmpty(pString2) && pString2.Length > 4 && Sqlite3.sqlite3StrNICmp(pString2, "see-", 4) == 0)
          Sqlite3.sqlite3_activate_see(pString2.Substring(4));
      }
      if (db1.autoCommit != (byte) 0)
        Sqlite3.sqlite3BtreeSetSafetyLevel(db2.pBt, (int) db2.safety_level, (db1.flags & 2097152) != 0 ? 1 : 0, (db1.flags & 4194304) != 0 ? 1 : 0);
label_227:
      Sqlite3.sqlite3DbFree(db1, ref pString1);
      Sqlite3.sqlite3DbFree(db1, ref pString2);
    }

    private static void corruptSchema(Sqlite3.InitData pData, string zObj, string zExtra)
    {
      Sqlite3.sqlite3 db = pData.db;
      if ((db.flags & 8388608) != 0)
        return;
      if (zObj == null)
      {
        zObj = "?";
        if (Sqlite3.ENC(db) != (byte) 1)
          zObj = Sqlite3.encnames[(int) Sqlite3.ENC(db)].zName;
      }
      Sqlite3.sqlite3SetString(ref pData.pzErrMsg, db, "malformed database schema (%s)", zObj);
      if (!string.IsNullOrEmpty(zExtra))
        pData.pzErrMsg = Sqlite3.sqlite3MAppendf(db, pData.pzErrMsg, "%s - %s", (object) pData.pzErrMsg, (object) zExtra);
      pData.rc = Sqlite3.SQLITE_CORRUPT_BKPT();
    }

    private static int sqlite3InitCallback(object pInit, long argc, object p2, object NotUsed)
    {
      string[] strArray = (string[]) p2;
      Sqlite3.InitData pData = (Sqlite3.InitData) pInit;
      Sqlite3.sqlite3 db = pData.db;
      int iDb = pData.iDb;
      if (string.Equals(strArray[0], "is_transient"))
        return 0;
      Sqlite3.UNUSED_PARAMETER2<object, long>(NotUsed, argc);
      Sqlite3.DbClearProperty(db, iDb, (ushort) 4);
      if (strArray == null)
        return 0;
      if (strArray[1] == null)
        Sqlite3.corruptSchema(pData, strArray[0], "");
      else if (!string.IsNullOrEmpty(strArray[2]))
      {
        Sqlite3.Vdbe ppStmt = (Sqlite3.Vdbe) null;
        db.init.iDb = iDb;
        db.init.newTnum = Sqlite3.sqlite3Atoi(strArray[1]);
        db.init.orphanTrigger = (byte) 0;
        Sqlite3.sqlite3_prepare(db, strArray[2], -1, ref ppStmt, 0);
        int errCode = db.errCode;
        db.init.iDb = 0;
        if (errCode != 0 && db.init.orphanTrigger == (byte) 0)
        {
          pData.rc = errCode;
          if (errCode != 9 && (errCode & (int) byte.MaxValue) != 6)
            Sqlite3.corruptSchema(pData, strArray[0], Sqlite3.sqlite3_errmsg(db));
        }
        Sqlite3.sqlite3_finalize(ppStmt);
      }
      else if (strArray[0] == null || strArray[0] == "")
      {
        Sqlite3.corruptSchema(pData, (string) null, (string) null);
      }
      else
      {
        Sqlite3.Index index = Sqlite3.sqlite3FindIndex(db, strArray[0], db.aDb[iDb].zName);
        if (index != null && !Sqlite3.sqlite3GetInt32(strArray[1], ref index.tnum))
          Sqlite3.corruptSchema(pData, strArray[0], "invalid rootpage");
      }
      return 0;
    }

    private static int sqlite3InitOne(Sqlite3.sqlite3 db, int iDb, ref string pzErrMsg)
    {
      string[] p2 = new string[4];
      uint[] x = new uint[5];
      Sqlite3.InitData initData = new Sqlite3.InitData();
      int num1 = 0;
      string str1 = "CREATE TABLE sqlite_master(\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)";
      string str2 = "CREATE TEMP TABLE sqlite_temp_master(\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)";
      string str3 = Sqlite3.OMIT_TEMPDB != 0 || iDb != 1 ? str1 : str2;
      string zName = Sqlite3.SCHEMA_TABLE(iDb);
      p2[0] = zName;
      p2[1] = "1";
      p2[2] = str3;
      p2[3] = "";
      initData.db = db;
      initData.iDb = iDb;
      initData.rc = 0;
      initData.pzErrMsg = pzErrMsg;
      Sqlite3.sqlite3InitCallback((object) initData, 3L, (object) p2, (object) null);
      int rc;
      if (initData.rc != 0)
      {
        rc = initData.rc;
      }
      else
      {
        Sqlite3.Table table = Sqlite3.sqlite3FindTable(db, zName, db.aDb[iDb].zName);
        if (Sqlite3.ALWAYS<Sqlite3.Table>(table))
          table.tabFlags |= (byte) 1;
        Sqlite3.Db db1 = db.aDb[iDb];
        if (db1.pBt == null)
        {
          if (Sqlite3.OMIT_TEMPDB == 0 && Sqlite3.ALWAYS(iDb == 1))
            Sqlite3.DbSetProperty(db, 1, (ushort) 1);
          return 0;
        }
        Sqlite3.sqlite3BtreeEnter(db1.pBt);
        if (!Sqlite3.sqlite3BtreeIsInReadTrans(db1.pBt))
        {
          rc = Sqlite3.sqlite3BtreeBeginTrans(db1.pBt, 0);
          if (rc != 0)
          {
            Sqlite3.sqlite3SetString(ref pzErrMsg, db, "%s", Sqlite3.sqlite3ErrStr(rc));
            goto label_39;
          }
          else
            num1 = 1;
        }
        for (int index = 0; index < Sqlite3.ArraySize<uint>(x); ++index)
          Sqlite3.sqlite3BtreeGetMeta(db1.pBt, index + 1, ref x[index]);
        db1.pSchema.schema_cookie = (int) x[0];
        if (x[4] != 0U)
        {
          if (iDb == 0)
          {
            byte num2 = (byte) (x[4] & 3U);
            if (num2 == (byte) 0)
              num2 = (byte) 1;
            db.aDb[0].pSchema.enc = num2;
            db.pDfltColl = Sqlite3.sqlite3FindCollSeq(db, (byte) 1, "BINARY", (byte) 0);
          }
          else if ((int) x[4] != (int) Sqlite3.ENC(db))
          {
            Sqlite3.sqlite3SetString(ref pzErrMsg, db, "attached databases must use the same text encoding as main database");
            rc = 1;
            goto label_39;
          }
        }
        else
          Sqlite3.DbSetProperty(db, iDb, (ushort) 4);
        db1.pSchema.enc = Sqlite3.ENC(db);
        if (db1.pSchema.cache_size == 0)
        {
          int num3 = Sqlite3.sqlite3AbsInt32((int) x[2]);
          if (num3 == 0)
            num3 = 2000;
          db1.pSchema.cache_size = num3;
          Sqlite3.sqlite3BtreeSetCacheSize(db1.pBt, db1.pSchema.cache_size);
        }
        db1.pSchema.file_format = (byte) x[1];
        if (db1.pSchema.file_format == (byte) 0)
          db1.pSchema.file_format = (byte) 1;
        if ((int) db1.pSchema.file_format > Sqlite3.SQLITE_MAX_FILE_FORMAT)
        {
          Sqlite3.sqlite3SetString(ref pzErrMsg, db, "unsupported file format");
          rc = 1;
        }
        else
        {
          if (iDb == 0 && x[1] >= 4U)
            db.flags &= -1048577;
          string pString = Sqlite3.sqlite3MPrintf(db, "SELECT name, rootpage, sql FROM '%q'.%s ORDER BY rowid", (object) db.aDb[iDb].zName, (object) zName);
          rc = Sqlite3.sqlite3_exec(db, pString, new Sqlite3.dxCallback(Sqlite3.sqlite3InitCallback), (object) initData, 0);
          pzErrMsg = initData.pzErrMsg;
          if (rc == 0)
            rc = initData.rc;
          Sqlite3.sqlite3DbFree(db, ref pString);
          if (rc == 0)
            Sqlite3.sqlite3AnalysisLoad(db, iDb);
          if (rc == 0 || (db.flags & 8388608) != 0)
          {
            Sqlite3.DbSetProperty(db, iDb, (ushort) 1);
            rc = 0;
          }
        }
label_39:
        if (num1 != 0)
          Sqlite3.sqlite3BtreeCommit(db1.pBt);
        Sqlite3.sqlite3BtreeLeave(db1.pBt);
      }
      if (rc != 7)
        ;
      return rc;
    }

    private static int sqlite3Init(Sqlite3.sqlite3 db, ref string pzErrMsg)
    {
      bool flag = (db.flags & 512) == 0;
      int num = 0;
      db.init.busy = (byte) 1;
      for (int index = 0; num == 0 && index < db.nDb; ++index)
      {
        if (!Sqlite3.DbHasProperty(db, index, (ushort) 1) && index != 1)
        {
          num = Sqlite3.sqlite3InitOne(db, index, ref pzErrMsg);
          if (num != 0)
            Sqlite3.sqlite3ResetInternalSchema(db, index);
        }
      }
      if (num == 0 && Sqlite3.ALWAYS(db.nDb > 1) && !Sqlite3.DbHasProperty(db, 1, (ushort) 1))
      {
        num = Sqlite3.sqlite3InitOne(db, 1, ref pzErrMsg);
        if (num != 0)
          Sqlite3.sqlite3ResetInternalSchema(db, 1);
      }
      db.init.busy = (byte) 0;
      if (num == 0 & flag)
        Sqlite3.sqlite3CommitInternalChanges(db);
      return num;
    }

    private static int sqlite3ReadSchema(Sqlite3.Parse pParse)
    {
      int num = 0;
      Sqlite3.sqlite3 db = pParse.db;
      if (db.init.busy == (byte) 0)
        num = Sqlite3.sqlite3Init(db, ref pParse.zErrMsg);
      if (num != 0)
      {
        pParse.rc = num;
        ++pParse.nErr;
      }
      return num;
    }

    private static void schemaIsValid(Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = pParse.db;
      uint pMeta = 0;
      for (int iDb = 0; iDb < db.nDb; ++iDb)
      {
        int num = 0;
        Sqlite3.Btree pBt = db.aDb[iDb].pBt;
        if (pBt != null)
        {
          if (!Sqlite3.sqlite3BtreeIsInReadTrans(pBt))
          {
            if (Sqlite3.sqlite3BtreeBeginTrans(pBt, 0) != 0)
              break;
            num = 1;
          }
          Sqlite3.sqlite3BtreeGetMeta(pBt, 1, ref pMeta);
          if ((long) pMeta != (long) db.aDb[iDb].pSchema.schema_cookie)
          {
            Sqlite3.sqlite3ResetInternalSchema(db, iDb);
            pParse.rc = 17;
          }
          if (num != 0)
            Sqlite3.sqlite3BtreeCommit(pBt);
        }
      }
    }

    private static int sqlite3SchemaToIndex(Sqlite3.sqlite3 db, Sqlite3.Schema pSchema)
    {
      int index = -1000000;
      if (pSchema != null)
      {
        index = 0;
        while (Sqlite3.ALWAYS(index < db.nDb) && db.aDb[index].pSchema != pSchema)
          ++index;
      }
      return index;
    }

    private static int sqlite3Prepare(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      int saveSqlFlag,
      Sqlite3.Vdbe pReprepare,
      ref Sqlite3.Vdbe ppStmt,
      ref string pzTail)
    {
      string str = "";
      ppStmt = (Sqlite3.Vdbe) null;
      pzTail = (string) null;
      Sqlite3.Parse pParse = new Sqlite3.Parse();
      pParse.pReprepare = pReprepare;
      pParse.sLastToken.z = "";
      int num1;
      for (int index = 0; index < db.nDb; ++index)
      {
        Sqlite3.Btree pBt = db.aDb[index].pBt;
        if (pBt != null)
        {
          num1 = Sqlite3.sqlite3BtreeSchemaLocked(pBt);
          if (num1 != 0)
          {
            string zName = db.aDb[index].zName;
            Sqlite3.sqlite3Error(db, num1, "database schema is locked: %s", (object) zName);
            Sqlite3.testcase<int>(db.flags & 524288);
            goto label_33;
          }
        }
      }
      Sqlite3.sqlite3VtabUnlockList(db);
      pParse.db = db;
      pParse.nQueryLoop = 1.0;
      if (nBytes >= 0 && (nBytes == 0 || zSql[nBytes - 1] != char.MinValue))
      {
        int num2 = db.aLimit[1];
        Sqlite3.testcase<bool>(nBytes == num2);
        Sqlite3.testcase<bool>(nBytes == num2 + 1);
        if (nBytes > num2)
        {
          Sqlite3.sqlite3Error(db, 18, "statement too long");
          num1 = Sqlite3.sqlite3ApiExit(db, 18);
          goto label_33;
        }
        else
        {
          string pString = zSql.Substring(0, nBytes);
          if (pString != null)
          {
            Sqlite3.sqlite3RunParser(pParse, pString, ref str);
            Sqlite3.sqlite3DbFree(db, ref pString);
          }
        }
      }
      else
        Sqlite3.sqlite3RunParser(pParse, zSql, ref str);
      if (pParse.rc == 101)
        pParse.rc = 0;
      if (pParse.checkSchema != (byte) 0)
        Sqlite3.schemaIsValid(pParse);
      pzTail = pParse.zTail == null ? "" : pParse.zTail.ToString();
      num1 = pParse.rc;
      if (num1 == 0 && pParse.pVdbe != null && pParse.explain != (byte) 0)
      {
        string[] strArray = new string[12]
        {
          "addr",
          "opcode",
          "p1",
          "p2",
          "p3",
          "p4",
          "p5",
          "comment",
          "selectid",
          "order",
          "from",
          "detail"
        };
        int num3;
        int num4;
        if (pParse.explain == (byte) 2)
        {
          Sqlite3.sqlite3VdbeSetNumCols(pParse.pVdbe, 4);
          num3 = 8;
          num4 = 12;
        }
        else
        {
          Sqlite3.sqlite3VdbeSetNumCols(pParse.pVdbe, 8);
          num3 = 0;
          num4 = 8;
        }
        for (int index = num3; index < num4; ++index)
          Sqlite3.sqlite3VdbeSetColName(pParse.pVdbe, index - num3, 0, strArray[index], Sqlite3.SQLITE_STATIC);
      }
      if (db.init.busy == (byte) 0)
        Sqlite3.sqlite3VdbeSetSql(pParse.pVdbe, zSql, zSql.Length - (pParse.zTail == null ? 0 : pParse.zTail.Length), saveSqlFlag);
      if (pParse.pVdbe != null && num1 != 0)
        Sqlite3.sqlite3VdbeFinalize(ref pParse.pVdbe);
      else
        ppStmt = pParse.pVdbe;
      if (str != "")
      {
        Sqlite3.sqlite3Error(db, num1, "%s", (object) str);
        Sqlite3.sqlite3DbFree(db, ref str);
      }
      else
        Sqlite3.sqlite3Error(db, num1, 0);
      while (pParse.pTriggerPrg != null)
      {
        Sqlite3.TriggerPrg pTriggerPrg = pParse.pTriggerPrg;
        pParse.pTriggerPrg = pTriggerPrg.pNext;
        Sqlite3.sqlite3DbFree<Sqlite3.TriggerPrg>(db, ref pTriggerPrg);
      }
label_33:
      return Sqlite3.sqlite3ApiExit(db, num1);
    }

    private static int sqlite3LockAndPrepare(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      int saveSqlFlag,
      Sqlite3.Vdbe pOld,
      ref Sqlite3.Vdbe ppStmt,
      int dummy)
    {
      string pzTail = (string) null;
      return Sqlite3.sqlite3LockAndPrepare(db, zSql, nBytes, saveSqlFlag, pOld, ref ppStmt, ref pzTail);
    }

    private static int sqlite3LockAndPrepare(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      int saveSqlFlag,
      Sqlite3.Vdbe pOld,
      ref Sqlite3.Vdbe ppStmt,
      ref string pzTail)
    {
      if (!Sqlite3.sqlite3SafetyCheckOk(db))
      {
        ppStmt = (Sqlite3.Vdbe) null;
        pzTail = (string) null;
        return Sqlite3.SQLITE_MISUSE_BKPT();
      }
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      Sqlite3.sqlite3BtreeEnterAll(db);
      int num = Sqlite3.sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ref ppStmt, ref pzTail);
      if (num == 17)
      {
        Sqlite3.sqlite3_finalize(ppStmt);
        num = Sqlite3.sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ref ppStmt, ref pzTail);
      }
      Sqlite3.sqlite3BtreeLeaveAll(db);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num;
    }

    private static int sqlite3Reprepare(Sqlite3.Vdbe p)
    {
      Sqlite3.Vdbe vdbe = new Sqlite3.Vdbe();
      string zSql = Sqlite3.sqlite3_sql(p);
      int num = Sqlite3.sqlite3LockAndPrepare(Sqlite3.sqlite3VdbeDb(p), zSql, -1, 0, p, ref vdbe, 0);
      if (num != 0)
        return num;
      Sqlite3.sqlite3VdbeSwap(vdbe, p);
      Sqlite3.sqlite3TransferBindings(vdbe, p);
      Sqlite3.sqlite3VdbeResetStepResult(vdbe);
      Sqlite3.sqlite3VdbeFinalize(ref vdbe);
      return 0;
    }

    public static int sqlite3_prepare(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      ref Sqlite3.Vdbe ppStmt,
      int dummy)
    {
      string pzTail = (string) null;
      return Sqlite3.sqlite3_prepare(db, zSql, nBytes, ref ppStmt, ref pzTail);
    }

    public static int sqlite3_prepare(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      ref Sqlite3.Vdbe ppStmt,
      ref string pzTail)
    {
      return Sqlite3.sqlite3LockAndPrepare(db, zSql, nBytes, 0, (Sqlite3.Vdbe) null, ref ppStmt, ref pzTail);
    }

    public static int sqlite3_prepare_v2(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      ref Sqlite3.Vdbe ppStmt,
      int dummy)
    {
      string pzTail = (string) null;
      return Sqlite3.sqlite3LockAndPrepare(db, zSql, nBytes, 1, (Sqlite3.Vdbe) null, ref ppStmt, ref pzTail);
    }

    public static int sqlite3_prepare_v2(
      Sqlite3.sqlite3 db,
      string zSql,
      int nBytes,
      ref Sqlite3.Vdbe ppStmt,
      ref string pzTail)
    {
      return Sqlite3.sqlite3LockAndPrepare(db, zSql, nBytes, 1, (Sqlite3.Vdbe) null, ref ppStmt, ref pzTail);
    }

    private static char et_getdigit(ref double val, ref int cnt)
    {
      if (cnt++ >= 16)
        return char.MinValue;
      int num1;
      double num2 = (double) (num1 = (int) val);
      val = (val - num2) * 10.0;
      return (char) num1;
    }

    private static void appendSpace(Sqlite3.StrAccum pAccum, int N) => pAccum.zText.AppendFormat("{0," + (object) N + "}", (object) "");

    private static void sqlite3VXPrintf(
      Sqlite3.StrAccum pAccum,
      int useExtended,
      string fmt,
      object[] ap)
    {
      char[] destinationArray = new char[350];
      int num1 = 0;
      int index1 = 0;
      int num2;
      for (fmt += "\0"; index1 <= fmt.Length && (num2 = (int) fmt[index1]) != 0; ++index1)
      {
        if (num2 != 37)
        {
          num1 = index1;
          int num3 = 1;
          while (index1 < fmt.Length && (num2 = (int) fmt[++index1]) != 37 && num2 != 0)
            ++num3;
          Sqlite3.sqlite3StrAccumAppend(pAccum, fmt.Substring(num1, num3), num3);
          if (num2 == 0)
            break;
        }
        if (index1 < fmt.Length && (num2 = (int) fmt[++index1]) == 0)
        {
          Sqlite3.sqlite3StrAccumAppend(pAccum, "%", 1);
          break;
        }
        int num4;
        bool flag1 = (num4 = 0) != 0;
        bool flag2 = num4 != 0;
        bool flag3 = num4 != 0;
        bool flag4 = num4 != 0;
        bool flag5 = num4 != 0;
        bool flag6 = num4 != 0;
        bool flag7 = false;
        do
        {
          switch (num2)
          {
            case 32:
              flag4 = true;
              break;
            case 33:
              flag2 = true;
              break;
            case 35:
              flag3 = true;
              break;
            case 43:
              flag5 = true;
              break;
            case 45:
              flag6 = true;
              break;
            case 48:
              flag1 = true;
              break;
            default:
              flag7 = true;
              break;
          }
        }
        while (!flag7 && index1 < fmt.Length - 1 && (num2 = (int) fmt[++index1]) != 0);
        int num5 = 0;
        if (num2 == 42)
        {
          num5 = Sqlite3.va_arg(ap, 0);
          if (num5 < 0)
          {
            flag6 = true;
            num5 = -num5;
          }
          num2 = (int) fmt[++index1];
        }
        else
        {
          for (; num2 >= 48 && num2 <= 57; num2 = (int) fmt[++index1])
            num5 = num5 * 10 + num2 - 48;
        }
        if (num5 > 340)
          num5 = 338;
        int num6;
        if (num2 == 46)
        {
          num6 = 0;
          num2 = (int) fmt[++index1];
          if (num2 == 42)
          {
            num6 = Sqlite3.va_arg(ap, 0);
            if (num6 < 0)
              num6 = -num6;
            num2 = (int) fmt[++index1];
          }
          else
          {
            for (; num2 >= 48 && num2 <= 57; num2 = (int) fmt[++index1])
              num6 = num6 * 10 + num2 - 48;
          }
        }
        else
          num6 = -1;
        bool flag8;
        bool flag9;
        if (num2 == 108)
        {
          flag8 = true;
          num2 = (int) fmt[++index1];
          if (num2 == 108)
          {
            flag9 = true;
            num2 = (int) fmt[++index1];
          }
          else
            flag9 = false;
        }
        else
          flag8 = flag9 = false;
        Sqlite3.et_info etInfo = Sqlite3.fmtinfo[0];
        byte num7 = 0;
        for (int index2 = 0; index2 < Sqlite3.ArraySize<Sqlite3.et_info>(Sqlite3.fmtinfo); ++index2)
        {
          if (num2 == (int) Sqlite3.fmtinfo[index2].fmttype)
          {
            etInfo = Sqlite3.fmtinfo[index2];
            if (useExtended == 0 && ((int) etInfo.flags & 2) != 0)
              return;
            num7 = etInfo.type;
            break;
          }
        }
        if (num6 > 310 && ((int) etInfo.flags & 4) == 0)
          num6 = 310;
        int num8;
        int index3;
        switch (num7)
        {
          case 1:
          case 16:
            long num9;
            char ch1;
            if (((int) etInfo.flags & 1) != 0)
            {
              long num10 = !flag9 ? (!flag8 ? (long) Sqlite3.va_arg(ap, 0) : Sqlite3.va_arg(ap, 0L)) : Sqlite3.va_arg(ap, 0L);
              if (num10 < 0L)
              {
                num9 = num10 != long.MinValue ? -num10 : long.MinValue;
                ch1 = '-';
              }
              else
              {
                num9 = num10;
                ch1 = !flag5 ? (!flag4 ? char.MinValue : ' ') : '+';
              }
            }
            else
            {
              num9 = !flag9 ? (!flag8 ? Sqlite3.va_arg(ap, 0L) : Sqlite3.va_arg(ap, 0L)) : Sqlite3.va_arg(ap, 0L);
              ch1 = char.MinValue;
            }
            if (num9 == 0L)
              flag3 = false;
            if (flag1 && num6 < num5 - (ch1 != char.MinValue ? 1 : 0))
              num6 = num5 - (ch1 != char.MinValue ? 1 : 0);
            num8 = destinationArray.Length;
            char[] chArray1 = (char[]) null;
            if (num7 == (byte) 16)
            {
              char[] charArray = "thstndrd".ToCharArray();
              int num11 = (int) (num9 % 10L);
              if (num11 >= 4 || num9 / 10L % 10L == 1L)
                num11 = 0;
              chArray1 = new char[2]
              {
                charArray[num11 * 2],
                charArray[num11 * 2 + 1]
              };
            }
            char[] sourceArray;
            switch (etInfo._base)
            {
              case 8:
                sourceArray = Convert.ToString(num9, 8).ToCharArray();
                break;
              case 16:
                sourceArray = num9.ToString("x").ToCharArray();
                break;
              default:
                sourceArray = !flag1 ? num9.ToString().ToCharArray() : num9.ToString(new string('0', num5 - (ch1 != char.MinValue ? 1 : 0))).ToCharArray();
                break;
            }
            num1 = destinationArray.Length - sourceArray.Length - (chArray1 == null ? 0 : 2);
            Array.Copy((Array) sourceArray, 0, (Array) destinationArray, num1, sourceArray.Length);
            if (chArray1 != null)
            {
              destinationArray[destinationArray.Length - 1] = chArray1[1];
              destinationArray[destinationArray.Length - 2] = chArray1[0];
            }
            int num12 = destinationArray.Length - num1;
            for (int index4 = num6 - num12; index4 > 0; --index4)
              destinationArray[--num1] = '0';
            if (ch1 != char.MinValue)
              destinationArray[--num1] = ch1;
            if (flag3 && etInfo.prefix != (byte) 0)
            {
              char ch2;
              for (int prefix = (int) etInfo.prefix; (ch2 = Sqlite3.aPrefix[prefix]) != char.MinValue; ++prefix)
                destinationArray[--num1] = ch2;
            }
            index3 = destinationArray.Length - num1;
            break;
          case 2:
          case 3:
          case 4:
            double val = Sqlite3.va_arg(ap, 0.0);
            if (num6 < 0)
              num6 = 6;
            if (num6 > 165)
              num6 = 165;
            char ch3;
            if (val < 0.0)
            {
              val = -val;
              ch3 = '-';
            }
            else
              ch3 = !flag5 ? (!flag4 ? char.MinValue : ' ') : '+';
            if (num7 == (byte) 4 && num6 > 0)
              --num6;
            int num13 = num6;
            double num14 = 0.5;
            while (num13 > 0)
            {
              --num13;
              num14 *= 0.1;
            }
            if (num7 == (byte) 2)
              val += num14;
            int num15 = 0;
            double result = 0.0;
            if (double.IsNaN(val) || !double.TryParse(Convert.ToString(val), out result))
            {
              destinationArray[0] = 'N';
              destinationArray[1] = 'a';
              destinationArray[2] = 'N';
              index3 = 3;
              break;
            }
            if (val > 0.0)
            {
              for (; val >= 1E+32 && num15 <= 350; num15 += 32)
                val *= 1E-32;
              for (; val >= 100000000.0 && num15 <= 350; num15 += 8)
                val *= 1E-08;
              for (; val >= 10.0 && num15 <= 350; ++num15)
                val *= 0.1;
              while (val < 1E-08)
              {
                val *= 100000000.0;
                num15 -= 8;
              }
              while (val < 1.0)
              {
                val *= 10.0;
                --num15;
              }
              if (num15 > 350)
              {
                int z;
                switch (ch3)
                {
                  case '+':
                    destinationArray[0] = '+';
                    destinationArray[1] = 'I';
                    destinationArray[2] = 'n';
                    destinationArray[3] = 'f';
                    z = 4;
                    break;
                  case '-':
                    destinationArray[0] = '-';
                    destinationArray[1] = 'I';
                    destinationArray[2] = 'n';
                    destinationArray[3] = 'f';
                    z = 4;
                    break;
                  default:
                    destinationArray[0] = 'I';
                    destinationArray[1] = 'n';
                    destinationArray[2] = 'f';
                    z = 3;
                    break;
                }
                index3 = Sqlite3.sqlite3Strlen30(z);
                num1 = 0;
                break;
              }
            }
            int num16 = 0;
            bool flag10 = num7 == (byte) 3;
            if (num7 != (byte) 2)
            {
              val += num14;
              if (val >= 10.0)
              {
                val *= 0.1;
                ++num15;
              }
            }
            bool flag11;
            if (num7 == (byte) 4)
            {
              flag11 = !flag3;
              if (num15 < -4 || num15 > num6)
              {
                num7 = (byte) 3;
              }
              else
              {
                num6 -= num15;
                num7 = (byte) 2;
              }
            }
            else
              flag11 = false;
            int num17 = num7 != (byte) 3 ? num15 : 0;
            int cnt = 0;
            bool flag12 = ((num6 > 0 ? 1 : 0) | (flag3 ? 1 : 0) | (flag2 ? 1 : 0)) != 0;
            if (ch3 != char.MinValue)
              destinationArray[num16++] = ch3;
            if (num17 < 0)
            {
              destinationArray[num16++] = '0';
            }
            else
            {
              for (; num17 >= 0; --num17)
                destinationArray[num16++] = (char) ((uint) Sqlite3.et_getdigit(ref val, ref cnt) + 48U);
            }
            if (flag12)
              destinationArray[num16++] = '.';
            for (int index5 = num17 + 1; index5 < 0; ++index5)
            {
              destinationArray[num16++] = '0';
              --num6;
            }
            while (num6-- > 0)
              destinationArray[num16++] = (char) ((uint) Sqlite3.et_getdigit(ref val, ref cnt) + 48U);
            if (flag11 & flag12)
            {
              while (destinationArray[num16 - 1] == '0')
                destinationArray[--num16] = char.MinValue;
              if (destinationArray[num16 - 1] == '.')
              {
                if (flag2)
                  destinationArray[num16++] = '0';
                else
                  destinationArray[--num16] = '0';
              }
            }
            if (flag10 || num7 == (byte) 3)
            {
              char[] chArray2 = destinationArray;
              int index6 = num16;
              int num18 = index6 + 1;
              int aDigit = (int) Sqlite3.aDigits[(int) etInfo.charset];
              chArray2[index6] = (char) aDigit;
              int num19;
              if (num15 < 0)
              {
                char[] chArray3 = destinationArray;
                int index7 = num18;
                num19 = index7 + 1;
                chArray3[index7] = '-';
                num15 = -num15;
              }
              else
              {
                char[] chArray4 = destinationArray;
                int index8 = num18;
                num19 = index8 + 1;
                chArray4[index8] = '+';
              }
              if (num15 >= 100)
              {
                destinationArray[num19++] = (char) (num15 / 100 + 48);
                num15 %= 100;
              }
              char[] chArray5 = destinationArray;
              int index9 = num19;
              int num20 = index9 + 1;
              int num21 = (int) (ushort) (num15 / 10 + 48);
              chArray5[index9] = (char) num21;
              char[] chArray6 = destinationArray;
              int index10 = num20;
              num16 = index10 + 1;
              int num22 = (int) (ushort) (num15 % 10 + 48);
              chArray6[index10] = (char) num22;
            }
            index3 = num16;
            num1 = 0;
            if (flag1 && !flag6 && index3 < num5)
            {
              int num23 = num5 - index3;
              for (int index11 = num5; index11 >= num23; --index11)
                destinationArray[num1 + index11] = destinationArray[num1 + index11 - num23];
              int num24 = ch3 != char.MinValue ? 1 : 0;
              while (num23-- != 0)
                destinationArray[num1++ + num24] = '0';
              index3 = num5;
              num1 = 0;
              break;
            }
            break;
          case 5:
            ap[0] = (object) pAccum.nChar;
            index3 = num5 = 0;
            break;
          case 6:
          case 7:
            num8 = 0;
            string str1 = Sqlite3.va_arg(ap, "string");
            if (str1.Length > destinationArray.Length)
              destinationArray = new char[str1.Length];
            str1.ToCharArray().CopyTo((Array) destinationArray, 0);
            int length1 = str1.Length;
            if (length1 == 0)
              destinationArray[0] = char.MinValue;
            if (num6 >= 0)
            {
              index3 = 0;
              while (index3 < num6 && index3 < str1.Length && destinationArray[index3] != char.MinValue)
                ++index3;
            }
            else
              index3 = Sqlite3.sqlite3Strlen30(length1);
            num1 = 0;
            break;
          case 8:
            destinationArray[0] = '%';
            num1 = 0;
            index3 = 1;
            break;
          case 9:
            int num25 = (int) Sqlite3.va_arg(ap, char.MinValue);
            destinationArray[0] = (char) num25;
            if (num6 >= 0)
            {
              for (int index12 = 1; index12 < num6; ++index12)
                destinationArray[index12] = (char) num25;
              index3 = num6;
            }
            else
              index3 = 1;
            num1 = 0;
            break;
          case 10:
          case 11:
          case 15:
            char ch4 = num7 == (byte) 15 ? '"' : '\'';
            string str2 = Sqlite3.va_arg(ap, "char*") + "\0";
            bool flag13 = str2 == "" || str2 == "NULL\0";
            if (flag13)
              str2 = num7 == (byte) 11 ? "NULL\0" : "(NULL)\0";
            int num26 = num6;
            int num27;
            int index13;
            char ch5;
            for (index13 = num27 = 0; num26 != 0 && (ch5 = str2[index13]) != char.MinValue; --num26)
            {
              if ((int) ch5 == (int) ch4)
                ++num27;
              ++index13;
            }
            bool flag14 = !flag13 && num7 == (byte) 11;
            int length2 = num27 + (index13 + 1 + (flag14 ? 2 : 0));
            if (length2 > 350)
            {
              destinationArray = new char[length2];
              num1 = 0;
            }
            else
              num1 = 0;
            int num28 = 0;
            if (flag14)
              destinationArray[num1 + num28++] = ch4;
            int num29 = index13;
            for (int index14 = 0; index14 < num29; ++index14)
            {
              char ch6;
              destinationArray[num1 + num28++] = ch6 = str2[index14];
              if ((int) ch6 == (int) ch4)
                destinationArray[num1 + num28++] = ch6;
            }
            if (flag14)
              destinationArray[num1 + num28++] = ch4;
            destinationArray[num1 + num28] = char.MinValue;
            index3 = num28;
            break;
          case 12:
            Sqlite3.Token token;
            if (ap[Sqlite3.vaNEXT] is string)
            {
              token = new Sqlite3.Token()
              {
                z = Sqlite3.va_arg(ap, (string) null)
              };
              token.n = token.z.Length;
            }
            else
              token = Sqlite3.va_arg(ap, (Sqlite3.Token) null);
            if (token != null)
              Sqlite3.sqlite3StrAccumAppend(pAccum, token.z.ToString(), token.n);
            index3 = num5 = 0;
            break;
          case 13:
            Sqlite3.SrcList_item srcListItem = Sqlite3.va_arg(ap, (Sqlite3.SrcList) null).a[Sqlite3.va_arg(ap, 0)];
            if (srcListItem.zDatabase != null)
            {
              Sqlite3.sqlite3StrAccumAppend(pAccum, srcListItem.zDatabase, -1);
              Sqlite3.sqlite3StrAccumAppend(pAccum, ".", 1);
            }
            Sqlite3.sqlite3StrAccumAppend(pAccum, srcListItem.zName, -1);
            index3 = num5 = 0;
            break;
          case 14:
            flag9 = true;
            flag8 = false;
            goto case 1;
          default:
            return;
        }
        if (!flag6)
        {
          int N = num5 - index3;
          if (N > 0)
            Sqlite3.appendSpace(pAccum, N);
        }
        if (index3 > 0)
          Sqlite3.sqlite3StrAccumAppend(pAccum, new string(destinationArray, num1, index3), index3);
        if (flag6)
        {
          int N = num5 - index3;
          if (N > 0)
            Sqlite3.appendSpace(pAccum, N);
        }
      }
    }

    private static void sqlite3StrAccumAppend(Sqlite3.StrAccum p, string z, int N)
    {
      if (p.tooBig)
      {
        Sqlite3.testcase<bool>(p.tooBig);
      }
      else
      {
        if (N < 0)
          N = Sqlite3.sqlite3Strlen30(z);
        if (N == 0 || Sqlite3.NEVER(z == null))
          return;
        p.zText.Append(z.Substring(0, N <= z.Length ? N : z.Length));
      }
    }

    private static string sqlite3StrAccumFinish(Sqlite3.StrAccum p) => p.zText.ToString();

    private static void sqlite3StrAccumReset(Sqlite3.StrAccum p) => p.zText.Length = 0;

    private static void sqlite3StrAccumInit(
      Sqlite3.StrAccum p,
      StringBuilder zBase,
      int n,
      int mx)
    {
      p.zText.Length = 0;
      if (p.zText.Capacity < n)
        p.zText.Capacity = n;
      p.db = (Sqlite3.sqlite3) null;
      p.mxAlloc = mx;
    }

    private static string sqlite3VMPrintf(Sqlite3.sqlite3 db, string zFormat, params object[] ap)
    {
      if (zFormat == null)
        return (string) null;
      if (ap.Length == 0)
        return zFormat;
      Sqlite3.sqlite3StrAccumInit(Sqlite3.acc, (StringBuilder) null, 350, db.aLimit[0]);
      Sqlite3.acc.db = db;
      Sqlite3.acc.zText.Length = 0;
      Sqlite3.sqlite3VXPrintf(Sqlite3.acc, 1, zFormat, ap);
      return Sqlite3.sqlite3StrAccumFinish(Sqlite3.acc);
    }

    private static string sqlite3MPrintf(Sqlite3.sqlite3 db, string zFormat, params object[] ap)
    {
      string str;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        str = Sqlite3.sqlite3VMPrintf(db, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
      return str;
    }

    private static string sqlite3MAppendf(
      Sqlite3.sqlite3 db,
      string zStr,
      string zFormat,
      params object[] ap)
    {
      string str;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        str = Sqlite3.sqlite3VMPrintf(db, zFormat, ap);
        Sqlite3.va_end(ref ap);
        Sqlite3.sqlite3DbFree(db, ref zStr);
      }
      return str;
    }

    private static string sqlite3_vmprintf(string zFormat, params object[] ap)
    {
      if (Sqlite3.sqlite3_initialize() != 0)
        return "";
      Sqlite3.sqlite3StrAccumInit(Sqlite3.acc, (StringBuilder) null, 350, 350);
      Sqlite3.sqlite3VXPrintf(Sqlite3.acc, 0, zFormat, ap);
      return Sqlite3.sqlite3StrAccumFinish(Sqlite3.acc);
    }

    public static string sqlite3_mprintf(string zFormat, params object[] ap)
    {
      if (Sqlite3.sqlite3_initialize() != 0)
        return "";
      string str;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        str = Sqlite3.sqlite3_vmprintf(zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
      return str;
    }

    public static void sqlite3_vsnprintf(
      int n,
      StringBuilder zBuf,
      string zFormat,
      params object[] ap)
    {
      if (n <= 0)
        return;
      Sqlite3.sqlite3StrAccumInit(Sqlite3.acc, (StringBuilder) null, n, 0);
      Sqlite3.sqlite3VXPrintf(Sqlite3.acc, 0, zFormat, ap);
      zBuf.Length = 0;
      if (n > 1 && n <= Sqlite3.acc.zText.Length)
        Sqlite3.acc.zText.Length = n - 1;
      zBuf.Append(Sqlite3.sqlite3StrAccumFinish(Sqlite3.acc));
    }

    public static void sqlite3_snprintf(
      int n,
      StringBuilder zBuf,
      string zFormat,
      params object[] ap)
    {
      lock (Sqlite3.lock_va_list)
      {
        zBuf.EnsureCapacity(350);
        Sqlite3.va_start(ap, zFormat);
        Sqlite3.sqlite3_vsnprintf(n, zBuf, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
    }

    private static void renderLogMsg(int iErrCode, string zFormat, params object[] ap)
    {
      Sqlite3.sqlite3StrAccumInit(Sqlite3.acc, (StringBuilder) null, 1050, 0);
      Sqlite3.sqlite3VXPrintf(Sqlite3.acc, 0, zFormat, ap);
      Sqlite3.sqlite3GlobalConfig.xLog(Sqlite3.sqlite3GlobalConfig.pLogArg, iErrCode, Sqlite3.sqlite3StrAccumFinish(Sqlite3.acc));
    }

    private static void sqlite3_log(int iErrCode, string zFormat, params object[] ap)
    {
      if (Sqlite3.sqlite3GlobalConfig.xLog == null)
        return;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        Sqlite3.renderLogMsg(iErrCode, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
    }

    private static void sqlite3XPrintf(Sqlite3.StrAccum p, string zFormat, params object[] ap)
    {
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        Sqlite3.sqlite3VXPrintf(p, 1, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
    }

    private static byte randomu8()
    {
      Sqlite3.sqlite3PrngType sqlite3Prng = Sqlite3.sqlite3Prng;
      if (!sqlite3Prng.isInit)
      {
        byte[] zBufOut = new byte[256];
        sqlite3Prng.j = 0;
        sqlite3Prng.i = 0;
        Sqlite3.sqlite3OsRandomness(Sqlite3.sqlite3_vfs_find(""), 256, zBufOut);
        for (int index = 0; index < (int) byte.MaxValue; ++index)
          sqlite3Prng.s[index] = (byte) index;
        for (int index = 0; index < (int) byte.MaxValue; ++index)
        {
          sqlite3Prng.j = (int) (byte) ((uint) sqlite3Prng.j + (uint) sqlite3Prng.s[index] + (uint) zBufOut[index]);
          byte num = sqlite3Prng.s[sqlite3Prng.j];
          sqlite3Prng.s[sqlite3Prng.j] = sqlite3Prng.s[index];
          sqlite3Prng.s[index] = num;
        }
        sqlite3Prng.isInit = true;
      }
      ++sqlite3Prng.i;
      byte num1 = sqlite3Prng.s[(int) (byte) sqlite3Prng.i];
      sqlite3Prng.j = (int) (byte) ((uint) sqlite3Prng.j + (uint) num1);
      sqlite3Prng.s[(int) (byte) sqlite3Prng.i] = sqlite3Prng.s[sqlite3Prng.j];
      sqlite3Prng.s[sqlite3Prng.j] = num1;
      byte index1 = (byte) ((uint) num1 + (uint) sqlite3Prng.s[(int) (byte) sqlite3Prng.i]);
      return sqlite3Prng.s[(int) index1];
    }

    private static void sqlite3_randomness(int N, ref long pBuf)
    {
      byte[] numArray = new byte[N];
      pBuf = 0L;
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mutex);
      while (N-- > 0)
        pBuf = (long) (uint) ((ulong) (pBuf << 8) + (ulong) Sqlite3.randomu8());
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mutex);
    }

    private static void sqlite3_randomness(byte[] pBuf, int Offset, int N)
    {
      long num = System.DateTime.Now.Ticks;
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mutex);
      while (N-- > 0)
      {
        num = (long) (uint) ((ulong) (num << 8) + (ulong) Sqlite3.randomu8());
        pBuf[Offset++] = (byte) num;
      }
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mutex);
    }

    private static void sqlite3PrngSaveState() => Sqlite3.sqlite3SavedPrng = Sqlite3.sqlite3Prng.Copy();

    private static void sqlite3PrngRestoreState() => Sqlite3.sqlite3Prng = Sqlite3.sqlite3SavedPrng.Copy();

    private static void sqlite3PrngResetState() => Sqlite3.sqlite3Prng.isInit = false;

    private static void resolveAlias(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pEList,
      int iCol,
      Sqlite3.Expr pExpr,
      string zType)
    {
      Sqlite3.Expr pExpr1 = pEList.a[iCol].pExpr;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Expr pT;
      if (pExpr1.op != (byte) 152 && (zType.Length == 0 || zType[0] != 'G'))
      {
        Sqlite3.Expr pLeft = Sqlite3.sqlite3ExprDup(db, pExpr1, 0);
        pT = Sqlite3.sqlite3PExpr(pParse, 24, pLeft, (Sqlite3.Expr) null, (Sqlite3.Token) null);
        if (pT == null)
          return;
        if (pEList.a[iCol].iAlias == (ushort) 0)
          pEList.a[iCol].iAlias = (ushort) ++pParse.nAlias;
        pT.iTable = (int) pEList.a[iCol].iAlias;
      }
      else if (Sqlite3.ExprHasProperty(pExpr1, 1024) || pExpr1.u.zToken == null)
      {
        pT = Sqlite3.sqlite3ExprDup(db, pExpr1, 0);
        if (pT == null)
          return;
      }
      else
      {
        string zToken = pExpr1.u.zToken;
        pExpr1.u.zToken = (string) null;
        pT = Sqlite3.sqlite3ExprDup(db, pExpr1, 0);
        pExpr1.u.zToken = zToken;
        if (pT == null)
          return;
        pT.flags2 |= (byte) 1;
        pT.u.zToken = zToken;
      }
      if (((int) pExpr.flags & 256) != 0)
      {
        pT.pColl = pExpr.pColl;
        pT.flags |= (ushort) 256;
      }
      Sqlite3.ExprSetProperty(pExpr, 16384);
      Sqlite3.sqlite3ExprDelete(db, ref pExpr);
      pExpr.CopyFrom(pT);
      Sqlite3.sqlite3DbFree<Sqlite3.Expr>(db, ref pT);
    }

    private static int lookupName(
      Sqlite3.Parse pParse,
      string zDb,
      string zTab,
      string zCol,
      Sqlite3.NameContext pNC,
      Sqlite3.Expr pExpr)
    {
      int num1 = 0;
      int num2 = 0;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.SrcList_item srcListItem1 = (Sqlite3.SrcList_item) null;
      Sqlite3.NameContext nameContext = pNC;
      Sqlite3.Schema c = (Sqlite3.Schema) null;
      int num3 = 0;
      pExpr.iTable = -1;
      pExpr.pTab = (Sqlite3.Table) null;
      Sqlite3.ExprSetIrreducible(pExpr);
      while (pNC != null && num1 == 0)
      {
        Sqlite3.SrcList pSrcList = pNC.pSrcList;
        if (pSrcList != null)
        {
          for (int index1 = 0; index1 < (int) pSrcList.nSrc; ++index1)
          {
            Sqlite3.SrcList_item srcListItem2 = pSrcList.a[index1];
            Sqlite3.Table pTab = srcListItem2.pTab;
            int index2 = Sqlite3.sqlite3SchemaToIndex(db, pTab.pSchema);
            if (zTab != null)
            {
              if (srcListItem2.zAlias != null)
              {
                if (!srcListItem2.zAlias.Equals(zTab, StringComparison.InvariantCultureIgnoreCase))
                  continue;
              }
              else
              {
                string zName = pTab.zName;
                if (Sqlite3.NEVER(zName == null) || !zName.Equals(zTab, StringComparison.InvariantCultureIgnoreCase) || zDb != null && !db.aDb[index2].zName.Equals(zDb, StringComparison.InvariantCultureIgnoreCase))
                  continue;
              }
            }
            if (num2++ == 0)
            {
              pExpr.iTable = srcListItem2.iCursor;
              pExpr.pTab = pTab;
              c = pTab.pSchema;
              srcListItem1 = srcListItem2;
            }
            for (int index3 = 0; index3 < pTab.nCol; ++index3)
            {
              if (pTab.aCol[index3].zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase))
              {
                ++num1;
                pExpr.iTable = srcListItem2.iCursor;
                pExpr.pTab = pTab;
                srcListItem1 = srcListItem2;
                c = pTab.pSchema;
                pExpr.iColumn = index3 == pTab.iPKey ? (short) -1 : (short) index3;
                if (index1 < (int) pSrcList.nSrc - 1)
                {
                  if (((int) pSrcList.a[index1 + 1].jointype & 4) != 0)
                  {
                    ++index1;
                    break;
                  }
                  Sqlite3.IdList pUsing;
                  if ((pUsing = pSrcList.a[index1 + 1].pUsing) != null)
                  {
                    for (int index4 = 0; index4 < pUsing.nId; ++index4)
                    {
                      if (pUsing.a[index4].zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase))
                      {
                        ++index1;
                        break;
                      }
                    }
                    break;
                  }
                  break;
                }
                break;
              }
            }
          }
        }
        if (zDb == null && zTab != null && num1 == 0 && pParse.pTriggerTab != null)
        {
          int eTriggerOp = (int) pParse.eTriggerOp;
          Sqlite3.Table table = (Sqlite3.Table) null;
          if (eTriggerOp != 106 && "new".Equals(zTab, StringComparison.InvariantCultureIgnoreCase))
          {
            pExpr.iTable = 1;
            table = pParse.pTriggerTab;
          }
          else if (eTriggerOp != 105 && "old".Equals(zTab, StringComparison.InvariantCultureIgnoreCase))
          {
            pExpr.iTable = 0;
            table = pParse.pTriggerTab;
          }
          if (table != null)
          {
            c = table.pSchema;
            ++num2;
            int index;
            for (index = 0; index < table.nCol; ++index)
            {
              if (table.aCol[index].zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase))
              {
                if (index == table.iPKey)
                {
                  index = -1;
                  break;
                }
                break;
              }
            }
            if (index >= table.nCol && Sqlite3.sqlite3IsRowid(zCol))
              index = -1;
            if (index < table.nCol)
            {
              ++num1;
              if (index < 0)
                pExpr.affinity = 'd';
              else if (pExpr.iTable == 0)
              {
                Sqlite3.testcase<bool>(index == 31);
                Sqlite3.testcase<bool>(index == 32);
                pParse.oldmask |= index >= 32 ? uint.MaxValue : (uint) (1 << index);
              }
              else
              {
                Sqlite3.testcase<bool>(index == 31);
                Sqlite3.testcase<bool>(index == 32);
                pParse.newmask |= index >= 32 ? uint.MaxValue : (uint) (1 << index);
              }
              pExpr.iColumn = (short) index;
              pExpr.pTab = table;
              num3 = 1;
            }
          }
        }
        if (num1 == 0 && num2 == 1 && Sqlite3.sqlite3IsRowid(zCol))
        {
          num1 = 1;
          pExpr.iColumn = (short) -1;
          pExpr.affinity = 'd';
        }
        Sqlite3.ExprList pElist;
        if (num1 == 0 && (pElist = pNC.pEList) != null && zTab == null)
        {
          for (int iCol = 0; iCol < pElist.nExpr; ++iCol)
          {
            string zName = pElist.a[iCol].zName;
            if (zName != null && zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase))
            {
              Sqlite3.Expr pExpr1 = pElist.a[iCol].pExpr;
              if (pNC.allowAgg == (byte) 0 && Sqlite3.ExprHasProperty(pExpr1, 2))
              {
                Sqlite3.sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", (object) zName);
                return 2;
              }
              Sqlite3.resolveAlias(pParse, pElist, iCol, pExpr, "");
              num1 = 1;
              goto label_74;
            }
          }
        }
        if (num1 == 0)
          pNC = pNC.pNext;
      }
      if (num1 == 0 && zTab == null && Sqlite3.ExprHasProperty(pExpr, 64))
      {
        pExpr.op = (byte) 94;
        pExpr.pTab = (Sqlite3.Table) null;
        return 1;
      }
      string str1;
      switch (num1)
      {
        case 0:
          str1 = "no such column";
          break;
        case 1:
label_69:
          if (pExpr.iColumn >= (short) 0 && srcListItem1 != null)
          {
            int num4 = (int) pExpr.iColumn;
            Sqlite3.testcase<bool>(num4 == 63);
            if (num4 >= 64)
              num4 = 63;
            srcListItem1.colUsed |= (ulong) (1L << num4);
          }
          Sqlite3.sqlite3ExprDelete(db, ref pExpr.pLeft);
          pExpr.pLeft = (Sqlite3.Expr) null;
          Sqlite3.sqlite3ExprDelete(db, ref pExpr.pRight);
          pExpr.pRight = (Sqlite3.Expr) null;
          pExpr.op = num3 != 0 ? (byte) 60 : (byte) 152;
          goto label_74;
        default:
          str1 = "ambiguous column name";
          break;
      }
      string str2 = str1;
      if (zDb != null)
        Sqlite3.sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", (object) str2, (object) zDb, (object) zTab, (object) zCol);
      else if (zTab != null)
        Sqlite3.sqlite3ErrorMsg(pParse, "%s: %s.%s", (object) str2, (object) zTab, (object) zCol);
      else
        Sqlite3.sqlite3ErrorMsg(pParse, "%s: %s", (object) str2, (object) zCol);
      pParse.checkSchema = (byte) 1;
      ++nameContext.nErr;
      goto label_69;
label_74:
      if (num1 != 1)
        return 2;
      Sqlite3.sqlite3AuthRead(pParse, pExpr, c, pNC.pSrcList);
      while (true)
      {
        ++nameContext.nRef;
        if (nameContext != pNC)
          nameContext = nameContext.pNext;
        else
          break;
      }
      return 1;
    }

    private static Sqlite3.Expr sqlite3CreateColumnExpr(
      Sqlite3.sqlite3 db,
      Sqlite3.SrcList pSrc,
      int iSrc,
      int iCol)
    {
      Sqlite3.Expr E = Sqlite3.sqlite3ExprAlloc(db, 152, (Sqlite3.Token) null, 0);
      if (E != null)
      {
        Sqlite3.SrcList_item srcListItem = pSrc.a[iSrc];
        E.pTab = srcListItem.pTab;
        E.iTable = srcListItem.iCursor;
        if (E.pTab.iPKey == iCol)
        {
          E.iColumn = (short) -1;
        }
        else
        {
          E.iColumn = (short) iCol;
          Sqlite3.testcase<bool>(iCol == 64);
          Sqlite3.testcase<bool>(iCol == 63);
          srcListItem.colUsed |= (ulong) (1L << (iCol >= 64 ? 63 : iCol));
        }
        Sqlite3.ExprSetProperty(E, 4);
      }
      return E;
    }

    private static int resolveExprStep(Sqlite3.Walker pWalker, ref Sqlite3.Expr pExpr)
    {
      Sqlite3.NameContext pNc = pWalker.u.pNC;
      Sqlite3.Parse pParse = pNc.pParse;
      if (Sqlite3.ExprHasAnyProperty(pExpr, 4))
        return 1;
      Sqlite3.ExprSetProperty(pExpr, 4);
      switch (pExpr.op)
      {
        case 20:
        case 116:
          Sqlite3.testcase<bool>(pExpr.op == (byte) 20);
          goto case 72;
        case 26:
          return Sqlite3.lookupName(pParse, (string) null, (string) null, pExpr.u.zToken, pNc, pExpr);
        case 72:
          Sqlite3.testcase<bool>(pExpr.op == (byte) 72);
          if (Sqlite3.ExprHasProperty(pExpr, 2048))
          {
            int nRef = pNc.nRef;
            if (pNc.isCheck != (byte) 0)
              Sqlite3.sqlite3ErrorMsg(pParse, "subqueries prohibited in CHECK constraints");
            Sqlite3.sqlite3WalkSelect(pWalker, pExpr.x.pSelect);
            if (nRef != pNc.nRef)
            {
              Sqlite3.ExprSetProperty(pExpr, 32);
              break;
            }
            break;
          }
          break;
        case 118:
          Sqlite3.Expr pRight = pExpr.pRight;
          string zDb;
          string zToken1;
          string zToken2;
          if (pRight.op == (byte) 26)
          {
            zDb = (string) null;
            zToken1 = pExpr.pLeft.u.zToken;
            zToken2 = pRight.u.zToken;
          }
          else
          {
            zDb = pExpr.pLeft.u.zToken;
            zToken1 = pRight.pLeft.u.zToken;
            zToken2 = pRight.pRight.u.zToken;
          }
          return Sqlite3.lookupName(pParse, zDb, zToken1, zToken2, pNc, pExpr);
        case 133:
          if (pNc.isCheck != (byte) 0)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "parameters prohibited in CHECK constraints");
            break;
          }
          break;
        case 151:
        case 155:
          Sqlite3.ExprList pList = pExpr.x.pList;
          int nArg = pList != null ? pList.nExpr : 0;
          bool flag1 = false;
          bool flag2 = false;
          bool flag3 = false;
          byte enc = pParse.db.aDbStatic[0].pSchema.enc;
          Sqlite3.testcase<bool>(pExpr.op == (byte) 155);
          string zToken3 = pExpr.u.zToken;
          int nName = Sqlite3.sqlite3Strlen30(zToken3);
          Sqlite3.FuncDef function = Sqlite3.sqlite3FindFunction(pParse.db, zToken3, nName, nArg, enc, (byte) 0);
          if (function == null)
          {
            if (Sqlite3.sqlite3FindFunction(pParse.db, zToken3, nName, -1, enc, (byte) 0) == null)
              flag1 = true;
            else
              flag2 = true;
          }
          else
            flag3 = function.xFunc == null;
          if (flag3 && pNc.allowAgg == (byte) 0)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", (object) nName, (object) zToken3);
            ++pNc.nErr;
            flag3 = false;
          }
          else if (flag1)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "no such function: %.*s", (object) nName, (object) zToken3);
            ++pNc.nErr;
          }
          else if (flag2)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "wrong number of arguments to function %.*s()", (object) nName, (object) zToken3);
            ++pNc.nErr;
          }
          if (flag3)
          {
            pExpr.op = (byte) 153;
            pNc.hasAgg = (byte) 1;
          }
          if (flag3)
            pNc.allowAgg = (byte) 0;
          Sqlite3.sqlite3WalkExprList(pWalker, pList);
          if (flag3)
            pNc.allowAgg = (byte) 1;
          return 1;
      }
      return pParse.nErr == 0 ? 0 : 2;
    }

    private static int resolveAsName(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pEList,
      Sqlite3.Expr pE)
    {
      Sqlite3.UNUSED_PARAMETER<Sqlite3.Parse>(pParse);
      if (pE.op == (byte) 26)
      {
        string zToken = pE.u.zToken;
        for (int index = 0; index < pEList.nExpr; ++index)
        {
          string zName = pEList.a[index].zName;
          if (zName != null && zName.Equals(zToken, StringComparison.InvariantCultureIgnoreCase))
            return index + 1;
        }
      }
      return 0;
    }

    private static int resolveOrderByTermToExprList(
      Sqlite3.Parse pParse,
      Sqlite3.Select pSelect,
      Sqlite3.Expr pE)
    {
      Sqlite3.ExprList pElist = pSelect.pEList;
      Sqlite3.NameContext pNC = new Sqlite3.NameContext();
      pNC.pParse = pParse;
      pNC.pSrcList = pSelect.pSrc;
      pNC.pEList = pElist;
      pNC.allowAgg = (byte) 1;
      pNC.nErr = 0;
      Sqlite3.sqlite3 db = pParse.db;
      byte suppressErr = db.suppressErr;
      db.suppressErr = (byte) 1;
      int num = Sqlite3.sqlite3ResolveExprNames(pNC, ref pE);
      db.suppressErr = suppressErr;
      if (num != 0)
        return 0;
      for (int index = 0; index < pElist.nExpr; ++index)
      {
        if (Sqlite3.sqlite3ExprCompare(pElist.a[index].pExpr, pE) < 2)
          return index + 1;
      }
      return 0;
    }

    private static void resolveOutOfRangeError(Sqlite3.Parse pParse, string zType, int i, int mx) => Sqlite3.sqlite3ErrorMsg(pParse, "%r %s BY term out of range - should be between 1 and %d", (object) i, (object) zType, (object) mx);

    private static int resolveCompoundOrderBy(Sqlite3.Parse pParse, Sqlite3.Select pSelect)
    {
      int num1 = 1;
      Sqlite3.ExprList pOrderBy = pSelect.pOrderBy;
      if (pOrderBy == null)
        return 0;
      Sqlite3.sqlite3 db = pParse.db;
      if (pOrderBy.nExpr > db.aLimit[2])
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
        return 1;
      }
      for (int index = 0; index < pOrderBy.nExpr; ++index)
        pOrderBy.a[index].done = (byte) 0;
      pSelect.pNext = (Sqlite3.Select) null;
      for (; pSelect.pPrior != null; pSelect = pSelect.pPrior)
        pSelect.pPrior.pNext = pSelect;
      for (; pSelect != null && num1 != 0; pSelect = pSelect.pNext)
      {
        num1 = 0;
        Sqlite3.ExprList pElist = pSelect.pEList;
        for (int index = 0; index < pOrderBy.nExpr; ++index)
        {
          Sqlite3.ExprList_item exprListItem = pOrderBy.a[index];
          int pValue = -1;
          if (exprListItem.done == (byte) 0)
          {
            Sqlite3.Expr pExpr = exprListItem.pExpr;
            if (Sqlite3.sqlite3ExprIsInteger(pExpr, ref pValue) != 0)
            {
              if (pValue <= 0 || pValue > pElist.nExpr)
              {
                Sqlite3.resolveOutOfRangeError(pParse, "ORDER", index + 1, pElist.nExpr);
                return 1;
              }
            }
            else
            {
              pValue = Sqlite3.resolveAsName(pParse, pElist, pExpr);
              if (pValue == 0)
              {
                Sqlite3.Expr p = Sqlite3.sqlite3ExprDup(db, pExpr, 0);
                pValue = Sqlite3.resolveOrderByTermToExprList(pParse, pSelect, p);
                Sqlite3.sqlite3ExprDelete(db, ref p);
              }
            }
            if (pValue > 0)
            {
              Sqlite3.CollSeq pColl = pExpr.pColl;
              int num2 = (int) pExpr.flags & 256;
              Sqlite3.sqlite3ExprDelete(db, ref pExpr);
              Sqlite3.Expr expr;
              exprListItem.pExpr = expr = Sqlite3.sqlite3Expr(db, 129, (string) null);
              if (expr == null)
                return 1;
              expr.pColl = pColl;
              expr.flags = (ushort) ((int) expr.flags | 1024 | num2);
              expr.u.iValue = pValue;
              exprListItem.iCol = (ushort) pValue;
              exprListItem.done = (byte) 1;
            }
            else
              num1 = 1;
          }
        }
      }
      for (int index = 0; index < pOrderBy.nExpr; ++index)
      {
        if (pOrderBy.a[index].done == (byte) 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any column in the result set", (object) (index + 1));
          return 1;
        }
      }
      return 0;
    }

    private static int sqlite3ResolveOrderGroupBy(
      Sqlite3.Parse pParse,
      Sqlite3.Select pSelect,
      Sqlite3.ExprList pOrderBy,
      string zType)
    {
      Sqlite3.sqlite3 db = pParse.db;
      if (pOrderBy == null)
        return 0;
      if (pOrderBy.nExpr > db.aLimit[2])
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", (object) zType);
        return 1;
      }
      Sqlite3.ExprList pElist = pSelect.pEList;
      for (int index = 0; index < pOrderBy.nExpr; ++index)
      {
        Sqlite3.ExprList_item exprListItem = pOrderBy.a[index];
        if (exprListItem.iCol != (ushort) 0)
        {
          if ((int) exprListItem.iCol > pElist.nExpr)
          {
            Sqlite3.resolveOutOfRangeError(pParse, zType, index + 1, pElist.nExpr);
            return 1;
          }
          Sqlite3.resolveAlias(pParse, pElist, (int) exprListItem.iCol - 1, exprListItem.pExpr, zType);
        }
      }
      return 0;
    }

    private static int resolveOrderGroupBy(
      Sqlite3.NameContext pNC,
      Sqlite3.Select pSelect,
      Sqlite3.ExprList pOrderBy,
      string zType)
    {
      if (pOrderBy == null)
        return 0;
      int nExpr = pSelect.pEList.nExpr;
      Sqlite3.Parse pParse = pNC.pParse;
      for (int index = 0; index < pOrderBy.nExpr; ++index)
      {
        Sqlite3.ExprList_item exprListItem = pOrderBy.a[index];
        Sqlite3.Expr pExpr = exprListItem.pExpr;
        int pValue = Sqlite3.resolveAsName(pParse, pSelect.pEList, pExpr);
        if (pValue > 0)
          exprListItem.iCol = (ushort) pValue;
        else if (Sqlite3.sqlite3ExprIsInteger(pExpr, ref pValue) != 0)
        {
          if (pValue < 1)
          {
            Sqlite3.resolveOutOfRangeError(pParse, zType, index + 1, nExpr);
            return 1;
          }
          exprListItem.iCol = (ushort) pValue;
        }
        else
        {
          exprListItem.iCol = (ushort) 0;
          if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pExpr) != 0)
            return 1;
        }
      }
      return Sqlite3.sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
    }

    private static int resolveSelectStep(Sqlite3.Walker pWalker, Sqlite3.Select p)
    {
      if (((int) p.selFlags & 2) != 0)
        return 1;
      Sqlite3.NameContext pNc = pWalker.u.pNC;
      Sqlite3.Parse pParse = pWalker.pParse;
      Sqlite3.sqlite3 db = pParse.db;
      if (((int) p.selFlags & 16) == 0)
      {
        Sqlite3.sqlite3SelectPrep(pParse, p, pNc);
        return pParse.nErr == 0 ? 1 : 2;
      }
      bool flag = p.pPrior != null;
      int num = 0;
      Sqlite3.Select pSelect = p;
      while (p != null)
      {
        p.selFlags |= (ushort) 2;
        Sqlite3.NameContext pNC = new Sqlite3.NameContext();
        pNC.pParse = pParse;
        if (Sqlite3.sqlite3ResolveExprNames(pNC, ref p.pLimit) != 0 || Sqlite3.sqlite3ResolveExprNames(pNC, ref p.pOffset) != 0)
          return 2;
        pNC.allowAgg = (byte) 1;
        pNC.pSrcList = p.pSrc;
        pNC.pNext = pNc;
        Sqlite3.ExprList pElist = p.pEList;
        for (int index = 0; index < pElist.nExpr; ++index)
        {
          Sqlite3.Expr pExpr = pElist.a[index].pExpr;
          if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pExpr) != 0)
            return 2;
        }
        for (int index = 0; index < (int) p.pSrc.nSrc; ++index)
        {
          Sqlite3.SrcList_item srcListItem = p.pSrc.a[index];
          if (srcListItem.pSelect != null)
          {
            string zAuthContext = pParse.zAuthContext;
            if (srcListItem.zName != null)
              pParse.zAuthContext = srcListItem.zName;
            Sqlite3.sqlite3ResolveSelectNames(pParse, srcListItem.pSelect, pNc);
            pParse.zAuthContext = zAuthContext;
            if (pParse.nErr != 0)
              return 2;
          }
        }
        Sqlite3.ExprList pGroupBy = p.pGroupBy;
        if (pGroupBy != null || pNC.hasAgg != (byte) 0)
          p.selFlags |= (ushort) 4;
        else
          pNC.allowAgg = (byte) 0;
        if (p.pHaving != null && pGroupBy == null)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
          return 2;
        }
        pNC.pEList = p.pEList;
        if (Sqlite3.sqlite3ResolveExprNames(pNC, ref p.pWhere) != 0 || Sqlite3.sqlite3ResolveExprNames(pNC, ref p.pHaving) != 0)
          return 2;
        pNC.pNext = (Sqlite3.NameContext) null;
        pNC.allowAgg = (byte) 1;
        if (!flag && Sqlite3.resolveOrderGroupBy(pNC, p, p.pOrderBy, "ORDER") != 0)
          return 2;
        if (pGroupBy != null)
        {
          if (Sqlite3.resolveOrderGroupBy(pNC, p, pGroupBy, "GROUP") != 0)
            return 2;
          for (int index = 0; index < pGroupBy.nExpr; ++index)
          {
            if (((int) pGroupBy.a[index].pExpr.flags & 2) != 0)
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in the GROUP BY clause");
              return 2;
            }
          }
        }
        p = p.pPrior;
        ++num;
      }
      return flag && Sqlite3.resolveCompoundOrderBy(pParse, pSelect) != 0 ? 2 : 1;
    }

    private static int sqlite3ResolveExprNames(Sqlite3.NameContext pNC, ref Sqlite3.Expr pExpr)
    {
      Sqlite3.Walker pWalker = new Sqlite3.Walker();
      if (pExpr == null)
        return 0;
      byte hasAgg = pNC.hasAgg;
      pNC.hasAgg = (byte) 0;
      pWalker.xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.resolveExprStep);
      pWalker.xSelectCallback = new Sqlite3.dxSelectCallback(Sqlite3.resolveSelectStep);
      pWalker.pParse = pNC.pParse;
      pWalker.u.pNC = pNC;
      Sqlite3.sqlite3WalkExpr(pWalker, ref pExpr);
      if (pNC.nErr > 0 || pWalker.pParse.nErr > 0)
        Sqlite3.ExprSetProperty(pExpr, 8);
      if (pNC.hasAgg != (byte) 0)
        Sqlite3.ExprSetProperty(pExpr, 2);
      else if (hasAgg != (byte) 0)
        pNC.hasAgg = (byte) 1;
      return !Sqlite3.ExprHasProperty(pExpr, 8) ? 0 : 1;
    }

    private static void sqlite3ResolveSelectNames(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.NameContext pOuterNC)
    {
      Sqlite3.sqlite3WalkSelect(new Sqlite3.Walker()
      {
        xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.resolveExprStep),
        xSelectCallback = new Sqlite3.dxSelectCallback(Sqlite3.resolveSelectStep),
        pParse = pParse,
        u = {
          pNC = pOuterNC
        }
      }, p);
    }

    private static Sqlite3.RowSet sqlite3RowSetInit(
      Sqlite3.sqlite3 db,
      object pSpace,
      uint N)
    {
      return new Sqlite3.RowSet(db, (int) N);
    }

    private static void sqlite3RowSetClear(Sqlite3.RowSet p)
    {
      Sqlite3.RowSetChunk pNextChunk;
      for (Sqlite3.RowSetChunk pT = p.pChunk; pT != null; pT = pNextChunk)
      {
        pNextChunk = pT.pNextChunk;
        Sqlite3.sqlite3DbFree<Sqlite3.RowSetChunk>(p.db, ref pT);
      }
      p.pChunk = (Sqlite3.RowSetChunk) null;
      p.nFresh = 0;
      p.pEntry = (Sqlite3.RowSetEntry) null;
      p.pLast = (Sqlite3.RowSetEntry) null;
      p.pTree = (Sqlite3.RowSetEntry) null;
      p.isSorted = true;
    }

    private static void sqlite3RowSetInsert(Sqlite3.RowSet p, long rowid)
    {
      if (p.nFresh == 0)
      {
        Sqlite3.RowSetChunk rowSetChunk = new Sqlite3.RowSetChunk();
        if (rowSetChunk == null)
          return;
        rowSetChunk.pNextChunk = p.pChunk;
        p.pChunk = rowSetChunk;
        p.pFresh = rowSetChunk.aEntry;
        p.nFresh = 63;
      }
      p.pFresh[p.pFresh.Length - p.nFresh] = new Sqlite3.RowSetEntry();
      Sqlite3.RowSetEntry rowSetEntry = p.pFresh[p.pFresh.Length - p.nFresh];
      --p.nFresh;
      rowSetEntry.v = rowid;
      rowSetEntry.pRight = (Sqlite3.RowSetEntry) null;
      Sqlite3.RowSetEntry pLast = p.pLast;
      if (pLast != null)
      {
        if (p.isSorted && rowid <= pLast.v)
          p.isSorted = false;
        pLast.pRight = rowSetEntry;
      }
      else
        p.pEntry = rowSetEntry;
      p.pLast = rowSetEntry;
    }

    private static Sqlite3.RowSetEntry rowSetMerge(
      Sqlite3.RowSetEntry pA,
      Sqlite3.RowSetEntry pB)
    {
      Sqlite3.RowSetEntry rowSetEntry1 = new Sqlite3.RowSetEntry();
      Sqlite3.RowSetEntry rowSetEntry2 = rowSetEntry1;
      while (pA != null && pB != null)
      {
        if (pA.v < pB.v)
        {
          rowSetEntry2.pRight = pA;
          pA = pA.pRight;
          rowSetEntry2 = rowSetEntry2.pRight;
        }
        else if (pB.v < pA.v)
        {
          rowSetEntry2.pRight = pB;
          pB = pB.pRight;
          rowSetEntry2 = rowSetEntry2.pRight;
        }
        else
          pA = pA.pRight;
      }
      rowSetEntry2.pRight = pA == null ? pB : pA;
      return rowSetEntry1.pRight;
    }

    private static void rowSetSort(Sqlite3.RowSet p)
    {
      Sqlite3.RowSetEntry[] rowSetEntryArray = new Sqlite3.RowSetEntry[40];
      while (p.pEntry != null)
      {
        Sqlite3.RowSetEntry pB = p.pEntry;
        p.pEntry = pB.pRight;
        pB.pRight = (Sqlite3.RowSetEntry) null;
        uint index;
        for (index = 0U; rowSetEntryArray[(int) index] != null; ++index)
        {
          pB = Sqlite3.rowSetMerge(rowSetEntryArray[(int) index], pB);
          rowSetEntryArray[(int) index] = (Sqlite3.RowSetEntry) null;
        }
        rowSetEntryArray[(int) index] = pB;
      }
      Sqlite3.RowSetEntry pA = (Sqlite3.RowSetEntry) null;
      for (uint index = 0; (long) index < (long) rowSetEntryArray.Length; ++index)
        pA = Sqlite3.rowSetMerge(pA, rowSetEntryArray[(int) index]);
      p.pEntry = pA;
      p.pLast = (Sqlite3.RowSetEntry) null;
      p.isSorted = true;
    }

    private static void rowSetTreeToList(
      Sqlite3.RowSetEntry pIn,
      ref Sqlite3.RowSetEntry ppFirst,
      ref Sqlite3.RowSetEntry ppLast)
    {
      if (pIn.pLeft != null)
      {
        Sqlite3.RowSetEntry ppLast1 = new Sqlite3.RowSetEntry();
        Sqlite3.rowSetTreeToList(pIn.pLeft, ref ppFirst, ref ppLast1);
        ppLast1.pRight = pIn;
      }
      else
        ppFirst = pIn;
      if (pIn.pRight != null)
        Sqlite3.rowSetTreeToList(pIn.pRight, ref pIn.pRight, ref ppLast);
      else
        ppLast = pIn;
    }

    private static Sqlite3.RowSetEntry rowSetNDeepTree(
      ref Sqlite3.RowSetEntry ppList,
      int iDepth)
    {
      if (ppList == null)
        return (Sqlite3.RowSetEntry) null;
      if (iDepth == 1)
      {
        Sqlite3.RowSetEntry rowSetEntry = ppList;
        ppList = rowSetEntry.pRight;
        rowSetEntry.pLeft = rowSetEntry.pRight = (Sqlite3.RowSetEntry) null;
        return rowSetEntry;
      }
      Sqlite3.RowSetEntry rowSetEntry1 = Sqlite3.rowSetNDeepTree(ref ppList, iDepth - 1);
      Sqlite3.RowSetEntry rowSetEntry2 = ppList;
      if (rowSetEntry2 == null)
        return rowSetEntry1;
      rowSetEntry2.pLeft = rowSetEntry1;
      ppList = rowSetEntry2.pRight;
      rowSetEntry2.pRight = Sqlite3.rowSetNDeepTree(ref ppList, iDepth - 1);
      return rowSetEntry2;
    }

    private static Sqlite3.RowSetEntry rowSetListToTree(Sqlite3.RowSetEntry pList)
    {
      Sqlite3.RowSetEntry tree = pList;
      pList = tree.pRight;
      tree.pLeft = tree.pRight = (Sqlite3.RowSetEntry) null;
      int iDepth = 1;
      while (pList != null)
      {
        Sqlite3.RowSetEntry rowSetEntry = tree;
        tree = pList;
        pList = tree.pRight;
        tree.pLeft = rowSetEntry;
        tree.pRight = Sqlite3.rowSetNDeepTree(ref pList, iDepth);
        ++iDepth;
      }
      return tree;
    }

    private static void rowSetToList(Sqlite3.RowSet p)
    {
      if (!p.isSorted)
        Sqlite3.rowSetSort(p);
      if (p.pTree == null)
        return;
      Sqlite3.RowSetEntry ppFirst = new Sqlite3.RowSetEntry();
      Sqlite3.RowSetEntry ppLast = new Sqlite3.RowSetEntry();
      Sqlite3.rowSetTreeToList(p.pTree, ref ppFirst, ref ppLast);
      p.pTree = (Sqlite3.RowSetEntry) null;
      p.pEntry = Sqlite3.rowSetMerge(p.pEntry, ppFirst);
    }

    private static int sqlite3RowSetNext(Sqlite3.RowSet p, ref long pRowid)
    {
      Sqlite3.rowSetToList(p);
      if (p.pEntry == null)
        return 0;
      pRowid = p.pEntry.v;
      p.pEntry = p.pEntry.pRight;
      if (p.pEntry == null)
        Sqlite3.sqlite3RowSetClear(p);
      return 1;
    }

    private static int sqlite3RowSetTest(Sqlite3.RowSet pRowSet, byte iBatch, long iRowid)
    {
      if ((int) iBatch != (int) pRowSet.iBatch)
      {
        if (pRowSet.pEntry != null)
        {
          Sqlite3.rowSetToList(pRowSet);
          pRowSet.pTree = Sqlite3.rowSetListToTree(pRowSet.pEntry);
          pRowSet.pEntry = (Sqlite3.RowSetEntry) null;
          pRowSet.pLast = (Sqlite3.RowSetEntry) null;
        }
        pRowSet.iBatch = iBatch;
      }
      Sqlite3.RowSetEntry rowSetEntry = pRowSet.pTree;
      while (rowSetEntry != null)
      {
        if (rowSetEntry.v < iRowid)
        {
          rowSetEntry = rowSetEntry.pRight;
        }
        else
        {
          if (rowSetEntry.v <= iRowid)
            return 1;
          rowSetEntry = rowSetEntry.pLeft;
        }
      }
      return 0;
    }

    private static void clearSelect(Sqlite3.sqlite3 db, Sqlite3.Select p)
    {
      Sqlite3.sqlite3ExprListDelete(db, ref p.pEList);
      Sqlite3.sqlite3SrcListDelete(db, ref p.pSrc);
      Sqlite3.sqlite3ExprDelete(db, ref p.pWhere);
      Sqlite3.sqlite3ExprListDelete(db, ref p.pGroupBy);
      Sqlite3.sqlite3ExprDelete(db, ref p.pHaving);
      Sqlite3.sqlite3ExprListDelete(db, ref p.pOrderBy);
      Sqlite3.sqlite3SelectDelete(db, ref p.pPrior);
      Sqlite3.sqlite3ExprDelete(db, ref p.pLimit);
      Sqlite3.sqlite3ExprDelete(db, ref p.pOffset);
    }

    private static void sqlite3SelectDestInit(Sqlite3.SelectDest pDest, int eDest, int iParm)
    {
      pDest.eDest = (byte) eDest;
      pDest.iParm = iParm;
      pDest.affinity = char.MinValue;
      pDest.iMem = 0;
      pDest.nMem = 0;
    }

    private static Sqlite3.Select sqlite3SelectNew(
      Sqlite3.Parse pParse,
      int null_2,
      Sqlite3.SrcList pSrc,
      int null_4,
      int null_5,
      int null_6,
      int null_7,
      int isDistinct,
      int null_9,
      int null_10)
    {
      return Sqlite3.sqlite3SelectNew(pParse, (Sqlite3.ExprList) null, pSrc, (Sqlite3.Expr) null, (Sqlite3.ExprList) null, (Sqlite3.Expr) null, (Sqlite3.ExprList) null, isDistinct, (Sqlite3.Expr) null, (Sqlite3.Expr) null);
    }

    private static Sqlite3.Select sqlite3SelectNew(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pEList,
      Sqlite3.SrcList pSrc,
      Sqlite3.Expr pWhere,
      Sqlite3.ExprList pGroupBy,
      Sqlite3.Expr pHaving,
      Sqlite3.ExprList pOrderBy,
      int isDistinct,
      Sqlite3.Expr pLimit,
      Sqlite3.Expr pOffset)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Select select = new Sqlite3.Select();
      if (pEList == null)
        pEList = Sqlite3.sqlite3ExprListAppend(pParse, (Sqlite3.ExprList) null, Sqlite3.sqlite3Expr(db, 113, (string) null));
      select.pEList = pEList;
      select.pSrc = pSrc;
      select.pWhere = pWhere;
      select.pGroupBy = pGroupBy;
      select.pHaving = pHaving;
      select.pOrderBy = pOrderBy;
      select.selFlags = isDistinct != 0 ? (ushort) 1 : (ushort) 0;
      select.op = (byte) 116;
      select.pLimit = pLimit;
      select.pOffset = pOffset;
      select.addrOpenEphm[0] = -1;
      select.addrOpenEphm[1] = -1;
      select.addrOpenEphm[2] = -1;
      return select;
    }

    private static void sqlite3SelectDelete(Sqlite3.sqlite3 db, ref Sqlite3.Select p)
    {
      if (p == null)
        return;
      Sqlite3.clearSelect(db, p);
      Sqlite3.sqlite3DbFree<Sqlite3.Select>(db, ref p);
    }

    private static int sqlite3JoinType(
      Sqlite3.Parse pParse,
      Sqlite3.Token pA,
      int null_3,
      int null_4)
    {
      return Sqlite3.sqlite3JoinType(pParse, pA, (Sqlite3.Token) null, (Sqlite3.Token) null);
    }

    private static int sqlite3JoinType(
      Sqlite3.Parse pParse,
      Sqlite3.Token pA,
      Sqlite3.Token pB,
      int null_4)
    {
      return Sqlite3.sqlite3JoinType(pParse, pA, pB, (Sqlite3.Token) null);
    }

    private static int sqlite3JoinType(
      Sqlite3.Parse pParse,
      Sqlite3.Token pA,
      Sqlite3.Token pB,
      Sqlite3.Token pC)
    {
      int num = 0;
      Sqlite3.Token[] tokenArray = new Sqlite3.Token[3];
      string str1 = "naturaleftouterightfullinnercross";
      Sqlite3.Keyword[] x = new Sqlite3.Keyword[7]
      {
        new Sqlite3.Keyword((byte) 0, (byte) 7, (byte) 4),
        new Sqlite3.Keyword((byte) 6, (byte) 4, (byte) 40),
        new Sqlite3.Keyword((byte) 10, (byte) 5, (byte) 32),
        new Sqlite3.Keyword((byte) 14, (byte) 5, (byte) 48),
        new Sqlite3.Keyword((byte) 19, (byte) 4, (byte) 56),
        new Sqlite3.Keyword((byte) 23, (byte) 5, (byte) 1),
        new Sqlite3.Keyword((byte) 28, (byte) 5, (byte) 3)
      };
      tokenArray[0] = pA;
      tokenArray[1] = pB;
      tokenArray[2] = pC;
      for (int index1 = 0; index1 < 3 && tokenArray[index1] != null; ++index1)
      {
        Sqlite3.Token token = tokenArray[index1];
        int index2;
        for (index2 = 0; index2 < Sqlite3.ArraySize<Sqlite3.Keyword>(x); ++index2)
        {
          if (token.n == (int) x[index2].nChar && token.z.StartsWith(str1.Substring((int) x[index2].i, (int) x[index2].nChar), StringComparison.InvariantCultureIgnoreCase))
          {
            num |= (int) x[index2].code;
            break;
          }
        }
        Sqlite3.testcase<bool>(index2 == 0 || index2 == 1 || index2 == 2 || index2 == 3 || index2 == 4 || index2 == 5 || index2 == 6);
        if (index2 >= Sqlite3.ArraySize<Sqlite3.Keyword>(x))
        {
          num |= 64;
          break;
        }
      }
      if ((num & 33) == 33 || (num & 64) != 0)
      {
        string str2 = " ";
        if (pC == null)
          str2 = "";
        Sqlite3.sqlite3ErrorMsg(pParse, "unknown or unsupported join type: %T %T%s%T", (object) pA, (object) pB, (object) str2, (object) pC);
        num = 1;
      }
      else if ((num & 32) != 0 && (num & 24) != 8)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "RIGHT and FULL OUTER JOINs are not currently supported");
        num = 1;
      }
      return num;
    }

    private static int columnIndex(Sqlite3.Table pTab, string zCol)
    {
      for (int index = 0; index < pTab.nCol; ++index)
      {
        if (pTab.aCol[index].zName.Equals(zCol, StringComparison.InvariantCultureIgnoreCase))
          return index;
      }
      return -1;
    }

    private static int tableAndColumnIndex(
      Sqlite3.SrcList pSrc,
      int N,
      string zCol,
      ref int piTab,
      ref int piCol)
    {
      for (int index = 0; index < N; ++index)
      {
        int num = Sqlite3.columnIndex(pSrc.a[index].pTab, zCol);
        if (num >= 0)
        {
          piTab = index;
          piCol = num;
          return 1;
        }
      }
      return 0;
    }

    private static void addWhereTerm(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pSrc,
      int iLeft,
      int iColLeft,
      int iRight,
      int iColRight,
      int isOuterJoin,
      ref Sqlite3.Expr ppWhere)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Expr columnExpr1 = Sqlite3.sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);
      Sqlite3.Expr columnExpr2 = Sqlite3.sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);
      Sqlite3.Expr expr = Sqlite3.sqlite3PExpr(pParse, 76, columnExpr1, columnExpr2, 0);
      if (expr != null && isOuterJoin != 0)
      {
        Sqlite3.ExprSetProperty(expr, 1);
        Sqlite3.ExprSetIrreducible(expr);
        expr.iRightJoinTable = (short) columnExpr2.iTable;
      }
      ppWhere = Sqlite3.sqlite3ExprAnd(db, ppWhere, expr);
    }

    private static void setJoinExpr(Sqlite3.Expr p, int iTable)
    {
      for (; p != null; p = p.pRight)
      {
        Sqlite3.ExprSetProperty(p, 1);
        Sqlite3.ExprSetIrreducible(p);
        p.iRightJoinTable = (short) iTable;
        Sqlite3.setJoinExpr(p.pLeft, iTable);
      }
    }

    private static int sqliteProcessJoin(Sqlite3.Parse pParse, Sqlite3.Select p)
    {
      Sqlite3.SrcList pSrc = p.pSrc;
      for (int index1 = 0; index1 < (int) pSrc.nSrc - 1; ++index1)
      {
        Sqlite3.SrcList_item srcListItem1 = pSrc.a[index1];
        Sqlite3.SrcList_item srcListItem2 = pSrc.a[index1 + 1];
        Sqlite3.Table pTab1 = srcListItem1.pTab;
        Sqlite3.Table pTab2 = srcListItem2.pTab;
        if (!Sqlite3.NEVER(pTab1 == null || pTab2 == null))
        {
          bool flag = ((uint) srcListItem2.jointype & 32U) > 0U;
          if (((int) srcListItem2.jointype & 4) != 0)
          {
            if (srcListItem2.pOn != null || srcListItem2.pUsing != null)
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "a NATURAL join may not have an ON or USING clause", (object) "");
              return 1;
            }
            for (int iColRight = 0; iColRight < pTab2.nCol; ++iColRight)
            {
              int piTab = 0;
              int piCol = 0;
              string zName = pTab2.aCol[iColRight].zName;
              Sqlite3.columnIndex(pTab2, zName);
              if (Sqlite3.tableAndColumnIndex(pSrc, index1 + 1, zName, ref piTab, ref piCol) != 0)
                Sqlite3.addWhereTerm(pParse, pSrc, piTab, piCol, index1 + 1, iColRight, flag ? 1 : 0, ref p.pWhere);
            }
          }
          if (srcListItem2.pOn != null && srcListItem2.pUsing != null)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "cannot have both ON and USING clauses in the same join");
            return 1;
          }
          if (srcListItem2.pOn != null)
          {
            if (flag)
              Sqlite3.setJoinExpr(srcListItem2.pOn, srcListItem2.iCursor);
            p.pWhere = Sqlite3.sqlite3ExprAnd(pParse.db, p.pWhere, srcListItem2.pOn);
            srcListItem2.pOn = (Sqlite3.Expr) null;
          }
          if (srcListItem2.pUsing != null)
          {
            Sqlite3.IdList pUsing = srcListItem2.pUsing;
            for (int index2 = 0; index2 < pUsing.nId; ++index2)
            {
              int piTab = 0;
              int piCol = 0;
              string zName = pUsing.a[index2].zName;
              int iColRight = Sqlite3.columnIndex(pTab2, zName);
              if (iColRight < 0 || Sqlite3.tableAndColumnIndex(pSrc, index1 + 1, zName, ref piTab, ref piCol) == 0)
              {
                Sqlite3.sqlite3ErrorMsg(pParse, "cannot join using column %s - column not present in both tables", (object) zName);
                return 1;
              }
              Sqlite3.addWhereTerm(pParse, pSrc, piTab, piCol, index1 + 1, iColRight, flag ? 1 : 0, ref p.pWhere);
            }
          }
        }
      }
      return 0;
    }

    private static void pushOntoSorter(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pOrderBy,
      Sqlite3.Select pSelect,
      int regData)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int nExpr = pOrderBy.nExpr;
      int tempRange = Sqlite3.sqlite3GetTempRange(pParse, nExpr + 2);
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3ExprCacheClear(pParse);
      Sqlite3.sqlite3ExprCodeExprList(pParse, pOrderBy, tempRange, false);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 53, pOrderBy.iECursor, tempRange + nExpr);
      Sqlite3.sqlite3ExprCodeMove(pParse, regData, tempRange + nExpr + 1, 1);
      Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, tempRange, nExpr + 2, tempReg);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 70, pOrderBy.iECursor, tempReg);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, nExpr + 2);
      if (pSelect.iLimit == 0)
        return;
      int p1 = pSelect.iOffset == 0 ? pSelect.iLimit : pSelect.iOffset + 1;
      int addr1 = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 115, p1);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 20, p1, -1);
      int addr2 = Sqlite3.sqlite3VdbeAddOp0(pVdbe, 1);
      Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr1);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 63, pOrderBy.iECursor);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 57, pOrderBy.iECursor);
      Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr2);
    }

    private static void codeOffset(Sqlite3.Vdbe v, Sqlite3.Select p, int iContinue)
    {
      if (p.iOffset == 0 || iContinue == 0)
        return;
      Sqlite3.sqlite3VdbeAddOp2(v, 20, p.iOffset, -1);
      int addr = Sqlite3.sqlite3VdbeAddOp1(v, 114, p.iOffset);
      Sqlite3.sqlite3VdbeAddOp2(v, 1, 0, iContinue);
      Sqlite3.sqlite3VdbeJumpHere(v, addr);
    }

    private static void codeDistinct(
      Sqlite3.Parse pParse,
      int iTab,
      int addrRepeat,
      int N,
      int iMem)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, 50, iTab, addrRepeat, iMem, N);
      Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, iMem, N, tempReg);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 70, iTab, tempReg);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
    }

    private static bool checkForMultiColumnSelectError(
      Sqlite3.Parse pParse,
      Sqlite3.SelectDest pDest,
      int nExpr)
    {
      int eDest = (int) pDest.eDest;
      if (nExpr <= 1 || eDest != 6 && eDest != 7)
        return false;
      Sqlite3.sqlite3ErrorMsg(pParse, "only a single result allowed for a SELECT that is part of an expression");
      return true;
    }

    private static void selectInnerLoop(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.ExprList pEList,
      int srcTab,
      int nColumn,
      Sqlite3.ExprList pOrderBy,
      int distinct,
      Sqlite3.SelectDest pDest,
      int iContinue,
      int iBreak)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int eDest = (int) pDest.eDest;
      int iParm = pDest.iParm;
      if (Sqlite3.NEVER(pVdbe == null))
        return;
      bool flag = distinct >= 0;
      if (pOrderBy == null && !flag)
        Sqlite3.codeOffset(pVdbe, p, iContinue);
      int num = nColumn <= 0 ? pEList.nExpr : nColumn;
      if (pDest.iMem == 0)
      {
        pDest.iMem = pParse.nMem + 1;
        pDest.nMem = num;
        pParse.nMem += num;
      }
      int iMem = pDest.iMem;
      if (nColumn > 0)
      {
        for (int p2 = 0; p2 < nColumn; ++p2)
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, srcTab, p2, iMem + p2);
      }
      else if (eDest != 3)
      {
        Sqlite3.sqlite3ExprCacheClear(pParse);
        Sqlite3.sqlite3ExprCodeExprList(pParse, pEList, iMem, eDest == 5);
      }
      nColumn = num;
      if (flag)
      {
        Sqlite3.codeDistinct(pParse, distinct, iContinue, nColumn, iMem);
        if (pOrderBy == null)
          Sqlite3.codeOffset(pVdbe, p, iContinue);
      }
      switch (eDest)
      {
        case 1:
          int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, iMem, nColumn, tempReg1);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 70, iParm, tempReg1);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
          break;
        case 2:
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 71, iParm, iMem, nColumn);
          break;
        case 3:
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, iParm);
          break;
        case 5:
        case 10:
          Sqlite3.testcase<bool>(eDest == 10);
          Sqlite3.testcase<bool>(eDest == 5);
          if (pOrderBy != null)
          {
            int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
            Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, iMem, nColumn, tempReg2);
            Sqlite3.pushOntoSorter(pParse, pOrderBy, p, tempReg2);
            Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
            break;
          }
          if (eDest == 10)
          {
            Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, pDest.iParm);
            break;
          }
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 16, iMem, nColumn);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, iMem, nColumn);
          break;
        case 6:
          if (pOrderBy != null)
          {
            Sqlite3.pushOntoSorter(pParse, pOrderBy, p, iMem);
            break;
          }
          Sqlite3.sqlite3ExprCodeMove(pParse, iMem, iParm, 1);
          break;
        case 7:
          p.affinity = Sqlite3.sqlite3CompareAffinity(pEList.a[0].pExpr, pDest.affinity);
          if (pOrderBy != null)
          {
            Sqlite3.pushOntoSorter(pParse, pOrderBy, p, iMem);
            break;
          }
          int tempReg3 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 30, iMem, 1, tempReg3, p.affinity, 1);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, iMem, 1);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 70, iParm, tempReg3);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg3);
          break;
        case 8:
        case 9:
          int tempReg4 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.testcase<bool>(eDest == 8);
          Sqlite3.testcase<bool>(eDest == 9);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, iMem, nColumn, tempReg4);
          if (pOrderBy != null)
          {
            Sqlite3.pushOntoSorter(pParse, pOrderBy, p, tempReg4);
          }
          else
          {
            int tempReg5 = Sqlite3.sqlite3GetTempReg(pParse);
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 54, iParm, tempReg5);
            Sqlite3.sqlite3VdbeAddOp3(pVdbe, 55, iParm, tempReg4, tempReg5);
            Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 8);
            Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg5);
          }
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg4);
          break;
      }
      if (pOrderBy != null || p.iLimit == 0)
        return;
      Sqlite3.sqlite3VdbeAddOp3(pVdbe, 115, p.iLimit, iBreak, -1);
    }

    private static Sqlite3.KeyInfo keyInfoFromExprList(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pList)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int nExpr = pList.nExpr;
      Sqlite3.KeyInfo keyInfo = new Sqlite3.KeyInfo();
      if (keyInfo != null)
      {
        keyInfo.aSortOrder = new byte[nExpr];
        keyInfo.aColl = new Sqlite3.CollSeq[nExpr];
        keyInfo.nField = (ushort) nExpr;
        keyInfo.enc = db.aDbStatic[0].pSchema.enc;
        keyInfo.db = db;
        for (int index = 0; index < nExpr; ++index)
        {
          Sqlite3.ExprList_item exprListItem = pList.a[index];
          Sqlite3.CollSeq collSeq = Sqlite3.sqlite3ExprCollSeq(pParse, exprListItem.pExpr) ?? db.pDfltColl;
          keyInfo.aColl[index] = collSeq;
          keyInfo.aSortOrder[index] = exprListItem.sortOrder;
        }
      }
      return keyInfo;
    }

    private static string selectOpName(int id)
    {
      string str;
      switch (id)
      {
        case 113:
          str = "UNION ALL";
          break;
        case 114:
          str = "EXCEPT";
          break;
        case 115:
          str = "INTERSECT";
          break;
        default:
          str = "UNION";
          break;
      }
      return str;
    }

    private static void explainTempTable(Sqlite3.Parse pParse, string zUsage)
    {
      if (pParse.explain != (byte) 2)
        return;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      string pP4 = Sqlite3.sqlite3MPrintf(pParse.db, "USE TEMP B-TREE FOR %s", (object) zUsage);
      Sqlite3.sqlite3VdbeAddOp4(pVdbe, 138, pParse.iSelectId, 0, 0, pP4, -1);
    }

    private static void explainSetInteger(ref int a, int b) => a = b;

    private static void explainSetInteger(ref byte a, int b) => a = (byte) b;

    private static void explainComposite(
      Sqlite3.Parse pParse,
      int op,
      int iSub1,
      int iSub2,
      bool bUseTmp)
    {
      if (pParse.explain != (byte) 2)
        return;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      string pP4 = Sqlite3.sqlite3MPrintf(pParse.db, "COMPOUND SUBQUERIES %d AND %d %s(%s)", (object) iSub1, (object) iSub2, bUseTmp ? (object) "USING TEMP B-TREE " : (object) "", (object) Sqlite3.selectOpName(op));
      Sqlite3.sqlite3VdbeAddOp4(pVdbe, 138, pParse.iSelectId, 0, 0, pP4, -1);
    }

    private static void generateSortTail(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.Vdbe v,
      int nColumn,
      Sqlite3.SelectDest pDest)
    {
      int num1 = Sqlite3.sqlite3VdbeMakeLabel(v);
      int num2 = Sqlite3.sqlite3VdbeMakeLabel(v);
      int p1 = 0;
      Sqlite3.ExprList pOrderBy = p.pOrderBy;
      int eDest = (int) pDest.eDest;
      int iParm = pDest.iParm;
      int iEcursor = pOrderBy.iECursor;
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      int num3;
      if (eDest == 5 || eDest == 10)
      {
        p1 = pParse.nTab++;
        Sqlite3.sqlite3VdbeAddOp3(v, 42, p1, tempReg, nColumn);
        num3 = 0;
      }
      else
        num3 = Sqlite3.sqlite3GetTempReg(pParse);
      int p2_1 = 1 + Sqlite3.sqlite3VdbeAddOp2(v, 64, iEcursor, num1);
      Sqlite3.codeOffset(v, p, num2);
      Sqlite3.sqlite3VdbeAddOp3(v, 28, iEcursor, pOrderBy.nExpr + 1, tempReg);
      switch (eDest)
      {
        case 6:
          Sqlite3.sqlite3ExprCodeMove(pParse, tempReg, iParm, 1);
          break;
        case 7:
          Sqlite3.sqlite3VdbeAddOp4(v, 30, tempReg, 1, num3, p.affinity, 1);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, tempReg, 1);
          Sqlite3.sqlite3VdbeAddOp2(v, 70, iParm, num3);
          break;
        case 8:
        case 9:
          Sqlite3.testcase<bool>(eDest == 8);
          Sqlite3.testcase<bool>(eDest == 9);
          Sqlite3.sqlite3VdbeAddOp2(v, 54, iParm, num3);
          Sqlite3.sqlite3VdbeAddOp3(v, 55, iParm, tempReg, num3);
          Sqlite3.sqlite3VdbeChangeP5(v, (byte) 8);
          break;
        default:
          Sqlite3.testcase<bool>(eDest == 5);
          Sqlite3.testcase<bool>(eDest == 10);
          for (int p2_2 = 0; p2_2 < nColumn; ++p2_2)
          {
            Sqlite3.sqlite3VdbeAddOp3(v, 28, p1, p2_2, pDest.iMem + p2_2);
            if (p2_2 == 0)
              Sqlite3.sqlite3VdbeChangeP5(v, (byte) 32);
          }
          if (eDest == 5)
          {
            Sqlite3.sqlite3VdbeAddOp2(v, 16, pDest.iMem, nColumn);
            Sqlite3.sqlite3ExprCacheAffinityChange(pParse, pDest.iMem, nColumn);
            break;
          }
          Sqlite3.sqlite3VdbeAddOp1(v, 4, pDest.iParm);
          break;
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      Sqlite3.sqlite3ReleaseTempReg(pParse, num3);
      Sqlite3.sqlite3VdbeResolveLabel(v, num2);
      Sqlite3.sqlite3VdbeAddOp2(v, 67, iEcursor, p2_1);
      Sqlite3.sqlite3VdbeResolveLabel(v, num1);
      if (eDest != 5 && eDest != 10)
        return;
      Sqlite3.sqlite3VdbeAddOp2(v, 43, p1, 0);
    }

    private static string columnType(
      Sqlite3.NameContext pNC,
      Sqlite3.Expr pExpr,
      ref string pzOriginDb,
      ref string pzOriginTab,
      ref string pzOriginCol)
    {
      string str = (string) null;
      string pzOriginDb1 = (string) null;
      string pzOriginTab1 = (string) null;
      string pzOriginCol1 = (string) null;
      if (Sqlite3.NEVER(pExpr == null) || pNC.pSrcList == null)
        return (string) null;
      switch (pExpr.op)
      {
        case 116:
          Sqlite3.NameContext pNC1 = new Sqlite3.NameContext();
          Sqlite3.Select pSelect = pExpr.x.pSelect;
          Sqlite3.Expr pExpr1 = pSelect.pEList.a[0].pExpr;
          pNC1.pSrcList = pSelect.pSrc;
          pNC1.pNext = pNC;
          pNC1.pParse = pNC.pParse;
          str = Sqlite3.columnType(pNC1, pExpr1, ref pzOriginDb1, ref pzOriginTab1, ref pzOriginCol1);
          break;
        case 152:
        case 154:
          Sqlite3.Table table = (Sqlite3.Table) null;
          Sqlite3.Select select = (Sqlite3.Select) null;
          int index1 = (int) pExpr.iColumn;
          Sqlite3.testcase<bool>(pExpr.op == (byte) 154);
          Sqlite3.testcase<bool>(pExpr.op == (byte) 152);
          while (pNC != null && table == null)
          {
            Sqlite3.SrcList pSrcList = pNC.pSrcList;
            int index2 = 0;
            while (index2 < (int) pSrcList.nSrc && pSrcList.a[index2].iCursor != pExpr.iTable)
              ++index2;
            if (index2 < (int) pSrcList.nSrc)
            {
              table = pSrcList.a[index2].pTab;
              select = pSrcList.a[index2].pSelect;
            }
            else
              pNC = pNC.pNext;
          }
          if (table != null)
          {
            if (select != null)
            {
              if (index1 >= 0 && Sqlite3.ALWAYS(index1 < select.pEList.nExpr))
              {
                Sqlite3.NameContext pNC2 = new Sqlite3.NameContext();
                Sqlite3.Expr pExpr2 = select.pEList.a[index1].pExpr;
                pNC2.pSrcList = select.pSrc;
                pNC2.pNext = pNC;
                pNC2.pParse = pNC.pParse;
                str = Sqlite3.columnType(pNC2, pExpr2, ref pzOriginDb1, ref pzOriginTab1, ref pzOriginCol1);
                break;
              }
              break;
            }
            if (Sqlite3.ALWAYS<Sqlite3.Schema>(table.pSchema))
            {
              if (index1 < 0)
                index1 = table.iPKey;
              if (index1 < 0)
              {
                str = "INTEGER";
                pzOriginCol1 = "rowid";
              }
              else
              {
                str = table.aCol[index1].zType;
                pzOriginCol1 = table.aCol[index1].zName;
              }
              pzOriginTab1 = table.zName;
              if (pNC.pParse != null)
              {
                int index3 = Sqlite3.sqlite3SchemaToIndex(pNC.pParse.db, table.pSchema);
                pzOriginDb1 = pNC.pParse.db.aDb[index3].zName;
                break;
              }
              break;
            }
            break;
          }
          break;
      }
      pzOriginDb = pzOriginDb1;
      pzOriginTab = pzOriginTab1;
      pzOriginCol = pzOriginCol1;
      return str;
    }

    private static void generateColumnTypes(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.ExprList pEList)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.NameContext pNC = new Sqlite3.NameContext();
      pNC.pSrcList = pTabList;
      pNC.pParse = pParse;
      for (int idx = 0; idx < pEList.nExpr; ++idx)
      {
        Sqlite3.Expr pExpr = pEList.a[idx].pExpr;
        string str = (string) null;
        string zName = Sqlite3.columnType(pNC, pExpr, ref str, ref str, ref str);
        Sqlite3.sqlite3VdbeSetColName(pVdbe, idx, 1, zName, Sqlite3.SQLITE_TRANSIENT);
      }
    }

    private static void generateColumnNames(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.ExprList pEList)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.explain != (byte) 0 || pParse.colNamesSet != (byte) 0 || Sqlite3.NEVER(pVdbe == null))
        return;
      pParse.colNamesSet = (byte) 1;
      bool flag1 = (db.flags & 1024) != 0;
      bool flag2 = (db.flags & 2048) != 0;
      Sqlite3.sqlite3VdbeSetNumCols(pVdbe, pEList.nExpr);
      for (int idx = 0; idx < pEList.nExpr; ++idx)
      {
        Sqlite3.Expr pExpr = pEList.a[idx].pExpr;
        if (!Sqlite3.NEVER(pExpr == null))
        {
          if (pEList.a[idx].zName != null)
          {
            string zName = pEList.a[idx].zName;
            Sqlite3.sqlite3VdbeSetColName(pVdbe, idx, 0, zName, Sqlite3.SQLITE_TRANSIENT);
          }
          else if ((pExpr.op == (byte) 152 || pExpr.op == (byte) 154) && pTabList != null)
          {
            int index1 = (int) pExpr.iColumn;
            int index2 = 0;
            while (Sqlite3.ALWAYS(index2 < (int) pTabList.nSrc) && pTabList.a[index2].iCursor != pExpr.iTable)
              ++index2;
            Sqlite3.Table pTab = pTabList.a[index2].pTab;
            if (index1 < 0)
              index1 = pTab.iPKey;
            string zName1 = index1 >= 0 ? pTab.aCol[index1].zName : "rowid";
            if (!flag2 && !flag1)
              Sqlite3.sqlite3VdbeSetColName(pVdbe, idx, 0, pEList.a[idx].zSpan, Sqlite3.SQLITE_DYNAMIC);
            else if (flag1)
            {
              string zName2 = Sqlite3.sqlite3MPrintf(db, "%s.%s", (object) pTab.zName, (object) zName1);
              Sqlite3.sqlite3VdbeSetColName(pVdbe, idx, 0, zName2, Sqlite3.SQLITE_DYNAMIC);
            }
            else
              Sqlite3.sqlite3VdbeSetColName(pVdbe, idx, 0, zName1, Sqlite3.SQLITE_TRANSIENT);
          }
          else
            Sqlite3.sqlite3VdbeSetColName(pVdbe, idx, 0, pEList.a[idx].zSpan, Sqlite3.SQLITE_DYNAMIC);
        }
      }
      Sqlite3.generateColumnTypes(pParse, pTabList, pEList);
    }

    private static int selectColumnsFromExprList(
      Sqlite3.Parse pParse,
      Sqlite3.ExprList pEList,
      ref int pnCol,
      ref Sqlite3.Column[] paCol)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int nExpr;
      pnCol = nExpr = pEList.nExpr;
      Sqlite3.Column[] columnArray = paCol = new Sqlite3.Column[nExpr];
      for (int index1 = 0; index1 < nExpr; ++index1)
      {
        if (columnArray[index1] == null)
          columnArray[index1] = new Sqlite3.Column();
        Sqlite3.Column column = columnArray[index1];
        Sqlite3.Expr pExpr = pEList.a[index1].pExpr;
        string pString;
        if (pEList.a[index1].zName == null || !((pString = pEList.a[index1].zName) != ""))
        {
          Sqlite3.Expr expr = pExpr;
          while (expr.op == (byte) 118)
            expr = expr.pRight;
          if (expr.op == (byte) 152 && Sqlite3.ALWAYS(expr.pTab != null))
          {
            int index2 = (int) expr.iColumn;
            Sqlite3.Table pTab = expr.pTab;
            if (index2 < 0)
              index2 = pTab.iPKey;
            pString = Sqlite3.sqlite3MPrintf(db, "%s", index2 >= 0 ? (object) pTab.aCol[index2].zName : (object) "rowid");
          }
          else if (expr.op == (byte) 26)
            pString = Sqlite3.sqlite3MPrintf(db, "%s", (object) expr.u.zToken);
          else
            pString = Sqlite3.sqlite3MPrintf(db, "%s", (object) pEList.a[index1].zSpan);
        }
        int length = Sqlite3.sqlite3Strlen30(pString);
        int num;
        for (int index3 = num = 0; index3 < index1; ++index3)
        {
          if (columnArray[index3].zName.Equals(pString, StringComparison.InvariantCultureIgnoreCase))
          {
            string str = Sqlite3.sqlite3MPrintf(db, "%s:%d", (object) pString.Substring(0, length), (object) ++num);
            Sqlite3.sqlite3DbFree(db, ref pString);
            pString = str;
            index3 = -1;
            if (pString == "")
              break;
          }
        }
        column.zName = pString;
      }
      return 0;
    }

    private static void selectAddColumnTypeAndCollation(
      Sqlite3.Parse pParse,
      int nCol,
      Sqlite3.Column[] aCol,
      Sqlite3.Select pSelect)
    {
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.NameContext pNC = new Sqlite3.NameContext();
      pNC.pSrcList = pSelect.pSrc;
      Sqlite3.ExprList_item[] a = pSelect.pEList.a;
      for (int index = 0; index < nCol; ++index)
      {
        Sqlite3.Column column = aCol[index];
        Sqlite3.Expr pExpr = a[index].pExpr;
        string str = (string) null;
        column.zType = Sqlite3.columnType(pNC, pExpr, ref str, ref str, ref str);
        column.affinity = Sqlite3.sqlite3ExprAffinity(pExpr);
        if (column.affinity == char.MinValue)
          column.affinity = 'b';
        Sqlite3.CollSeq collSeq = Sqlite3.sqlite3ExprCollSeq(pParse, pExpr);
        if (collSeq != null)
          column.zColl = collSeq.zName;
      }
    }

    private static Sqlite3.Table sqlite3ResultSetOfSelect(
      Sqlite3.Parse pParse,
      Sqlite3.Select pSelect)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int flags = db.flags;
      db.flags &= -1025;
      db.flags |= 2048;
      Sqlite3.sqlite3SelectPrep(pParse, pSelect, (Sqlite3.NameContext) null);
      if (pParse.nErr != 0)
        return (Sqlite3.Table) null;
      while (pSelect.pPrior != null)
        pSelect = pSelect.pPrior;
      db.flags = flags;
      Sqlite3.Table table = new Sqlite3.Table();
      if (table == null)
        return (Sqlite3.Table) null;
      table.nRef = (ushort) 1;
      table.zName = (string) null;
      table.nRowEst = 1000000U;
      Sqlite3.selectColumnsFromExprList(pParse, pSelect.pEList, ref table.nCol, ref table.aCol);
      Sqlite3.selectAddColumnTypeAndCollation(pParse, table.nCol, table.aCol, pSelect);
      table.iPKey = -1;
      return table;
    }

    private static Sqlite3.Vdbe sqlite3GetVdbe(Sqlite3.Parse pParse)
    {
      Sqlite3.Vdbe p = pParse.pVdbe;
      if (p == null)
      {
        p = pParse.pVdbe = Sqlite3.sqlite3VdbeCreate(pParse.db);
        if (p != null)
          Sqlite3.sqlite3VdbeAddOp0(p, 136);
      }
      return p;
    }

    private static void computeLimitRegisters(Sqlite3.Parse pParse, Sqlite3.Select p, int iBreak)
    {
      int pValue = 0;
      if (p.iLimit != 0)
        return;
      Sqlite3.sqlite3ExprCacheClear(pParse);
      if (p.pLimit == null)
        return;
      Sqlite3.Select select1 = p;
      int num1 = ++pParse.nMem;
      int num2;
      int num3 = num2 = num1;
      select1.iLimit = num2;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (Sqlite3.NEVER(vdbe == null))
        return;
      if (Sqlite3.sqlite3ExprIsInteger(p.pLimit, ref pValue) != 0)
      {
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, pValue, num3);
        Sqlite3.VdbeComment(vdbe, "LIMIT counter");
        if (pValue == 0)
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, iBreak);
        else if (p.nSelectRow > (double) pValue)
          p.nSelectRow = (double) pValue;
      }
      else
      {
        Sqlite3.sqlite3ExprCode(pParse, p.pLimit, num3);
        Sqlite3.sqlite3VdbeAddOp1(vdbe, 21, num3);
        Sqlite3.sqlite3VdbeAddOp2(vdbe, 115, num3, iBreak);
      }
      if (p.pOffset == null)
        return;
      Sqlite3.Select select2 = p;
      int num4 = ++pParse.nMem;
      int num5;
      int num6 = num5 = num4;
      select2.iOffset = num5;
      ++pParse.nMem;
      Sqlite3.sqlite3ExprCode(pParse, p.pOffset, num6);
      Sqlite3.sqlite3VdbeAddOp1(vdbe, 21, num6);
      int addr1 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 113, num6);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num6);
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 86, num3, num6, num6 + 1);
      int addr2 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 113, num3);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, -1, num6 + 1);
      Sqlite3.sqlite3VdbeJumpHere(vdbe, addr2);
    }

    private static Sqlite3.CollSeq multiSelectCollSeq(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      int iCol)
    {
      Sqlite3.CollSeq collSeq = p.pPrior == null ? (Sqlite3.CollSeq) null : Sqlite3.multiSelectCollSeq(pParse, p.pPrior, iCol);
      if (collSeq == null && iCol < p.pEList.nExpr)
        collSeq = Sqlite3.sqlite3ExprCollSeq(pParse, p.pEList.a[iCol].pExpr);
      return collSeq;
    }

    private static int multiSelect(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.SelectDest pDest)
    {
      Sqlite3.SelectDest selectDest = new Sqlite3.SelectDest();
      Sqlite3.Select p1 = (Sqlite3.Select) null;
      int a1 = 0;
      int a2 = 0;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Select pPrior = p.pPrior;
      Sqlite3.SelectDest pDest1 = pDest;
      int num1;
      if (pPrior.pOrderBy != null)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "ORDER BY clause should come after %s not before", (object) Sqlite3.selectOpName((int) p.op));
        num1 = 1;
      }
      else if (pPrior.pLimit != null)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "LIMIT clause should come after %s not before", (object) Sqlite3.selectOpName((int) p.op));
        num1 = 1;
      }
      else
      {
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
        if (pDest1.eDest == (byte) 9)
        {
          Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, pDest1.iParm, p.pEList.nExpr);
          Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 16);
          pDest1.eDest = (byte) 8;
        }
        if (p.pEList.nExpr != pPrior.pEList.nExpr)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s do not have the same number of result columns", (object) Sqlite3.selectOpName((int) p.op));
          num1 = 1;
        }
        else
        {
          if (p.pOrderBy != null)
            return Sqlite3.multiSelectOrderBy(pParse, p, pDest);
          switch (p.op)
          {
            case 112:
            case 114:
              Sqlite3.SelectDest pDest2 = new Sqlite3.SelectDest();
              Sqlite3.testcase<bool>(p.op == (byte) 114);
              Sqlite3.testcase<bool>(p.op == (byte) 112);
              int eDest = 1;
              int num2;
              if ((int) pDest1.eDest == eDest && Sqlite3.ALWAYS(p.pLimit == null && p.pOffset == null))
              {
                num2 = pDest1.iParm;
              }
              else
              {
                num2 = pParse.nTab++;
                int num3 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, num2, 0);
                p.addrOpenEphm[0] = num3;
                p.pRightmost.selFlags |= (ushort) 8;
              }
              Sqlite3.sqlite3SelectDestInit(pDest2, eDest, num2);
              Sqlite3.explainSetInteger(ref a1, pParse.iNextSelectId);
              num1 = Sqlite3.sqlite3Select(pParse, pPrior, ref pDest2);
              if (num1 == 0)
              {
                byte num4 = p.op != (byte) 114 ? (byte) 1 : (byte) 2;
                p.pPrior = (Sqlite3.Select) null;
                Sqlite3.Expr pLimit = p.pLimit;
                p.pLimit = (Sqlite3.Expr) null;
                Sqlite3.Expr pOffset = p.pOffset;
                p.pOffset = (Sqlite3.Expr) null;
                pDest2.eDest = num4;
                Sqlite3.explainSetInteger(ref a2, pParse.iNextSelectId);
                num1 = Sqlite3.sqlite3Select(pParse, p, ref pDest2);
                Sqlite3.testcase<bool>(num1 != 0);
                Sqlite3.sqlite3ExprListDelete(db, ref p.pOrderBy);
                p1 = p.pPrior;
                p.pPrior = pPrior;
                p.pOrderBy = (Sqlite3.ExprList) null;
                if (p.op == (byte) 112)
                  p.nSelectRow += pPrior.nSelectRow;
                Sqlite3.sqlite3ExprDelete(db, ref p.pLimit);
                p.pLimit = pLimit;
                p.pOffset = pOffset;
                p.iLimit = 0;
                p.iOffset = 0;
                if ((int) pDest1.eDest != eDest)
                {
                  if (pDest1.eDest == (byte) 5)
                  {
                    Sqlite3.Select select = p;
                    while (select.pPrior != null)
                      select = select.pPrior;
                    Sqlite3.generateColumnNames(pParse, (Sqlite3.SrcList) null, select.pEList);
                  }
                  int num5 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
                  int num6 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
                  Sqlite3.computeLimitRegisters(pParse, p, num5);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, num2, num5);
                  int p2 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                  Sqlite3.selectInnerLoop(pParse, p, p.pEList, num2, p.pEList.nExpr, (Sqlite3.ExprList) null, -1, pDest1, num6, num5);
                  Sqlite3.sqlite3VdbeResolveLabel(vdbe, num6);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, num2, p2);
                  Sqlite3.sqlite3VdbeResolveLabel(vdbe, num5);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num2, 0);
                  break;
                }
                break;
              }
              goto label_52;
            case 113:
              int addr1 = 0;
              int pValue = 0;
              pPrior.pLimit = p.pLimit;
              pPrior.pOffset = p.pOffset;
              Sqlite3.explainSetInteger(ref a1, pParse.iNextSelectId);
              num1 = Sqlite3.sqlite3Select(pParse, pPrior, ref pDest1);
              p.pLimit = (Sqlite3.Expr) null;
              p.pOffset = (Sqlite3.Expr) null;
              if (num1 == 0)
              {
                p.pPrior = (Sqlite3.Select) null;
                p.iLimit = pPrior.iLimit;
                p.iOffset = pPrior.iOffset;
                if (p.iLimit != 0)
                  addr1 = Sqlite3.sqlite3VdbeAddOp1(vdbe, 115, p.iLimit);
                Sqlite3.explainSetInteger(ref a2, pParse.iNextSelectId);
                num1 = Sqlite3.sqlite3Select(pParse, p, ref pDest1);
                Sqlite3.testcase<bool>(num1 != 0);
                p1 = p.pPrior;
                p.pPrior = pPrior;
                p.nSelectRow += pPrior.nSelectRow;
                if (pPrior.pLimit != null && Sqlite3.sqlite3ExprIsInteger(pPrior.pLimit, ref pValue) != 0 && p.nSelectRow > (double) pValue)
                  p.nSelectRow = (double) pValue;
                if (addr1 != 0)
                {
                  Sqlite3.sqlite3VdbeJumpHere(vdbe, addr1);
                  break;
                }
                break;
              }
              goto label_52;
            default:
              Sqlite3.SelectDest pDest3 = new Sqlite3.SelectDest();
              int num7 = pParse.nTab++;
              int p1_1 = pParse.nTab++;
              int num8 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, num7, 0);
              p.addrOpenEphm[0] = num8;
              p.pRightmost.selFlags |= (ushort) 8;
              Sqlite3.sqlite3SelectDestInit(pDest3, 1, num7);
              Sqlite3.explainSetInteger(ref a1, pParse.iNextSelectId);
              num1 = Sqlite3.sqlite3Select(pParse, pPrior, ref pDest3);
              if (num1 == 0)
              {
                int num9 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, p1_1, 0);
                p.addrOpenEphm[1] = num9;
                p.pPrior = (Sqlite3.Select) null;
                Sqlite3.Expr pLimit = p.pLimit;
                p.pLimit = (Sqlite3.Expr) null;
                Sqlite3.Expr pOffset = p.pOffset;
                p.pOffset = (Sqlite3.Expr) null;
                pDest3.iParm = p1_1;
                Sqlite3.explainSetInteger(ref a2, pParse.iNextSelectId);
                num1 = Sqlite3.sqlite3Select(pParse, p, ref pDest3);
                Sqlite3.testcase<bool>(num1 != 0);
                p.pPrior = pPrior;
                if (p.nSelectRow > pPrior.nSelectRow)
                  p.nSelectRow = pPrior.nSelectRow;
                Sqlite3.sqlite3ExprDelete(db, ref p.pLimit);
                p.pLimit = pLimit;
                p.pOffset = pOffset;
                if (pDest1.eDest == (byte) 5)
                {
                  Sqlite3.Select select = p;
                  while (select.pPrior != null)
                    select = select.pPrior;
                  Sqlite3.generateColumnNames(pParse, (Sqlite3.SrcList) null, select.pEList);
                }
                int num10 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
                int num11 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
                Sqlite3.computeLimitRegisters(pParse, p, num10);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 65, num7, num10);
                int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
                int p2 = Sqlite3.sqlite3VdbeAddOp2(vdbe, 59, num7, tempReg);
                Sqlite3.sqlite3VdbeAddOp4Int(vdbe, 49, p1_1, num11, tempReg, 0);
                Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
                Sqlite3.selectInnerLoop(pParse, p, p.pEList, num7, p.pEList.nExpr, (Sqlite3.ExprList) null, -1, pDest1, num11, num10);
                Sqlite3.sqlite3VdbeResolveLabel(vdbe, num11);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, num7, p2);
                Sqlite3.sqlite3VdbeResolveLabel(vdbe, num10);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, p1_1, 0);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num7, 0);
                break;
              }
              goto label_52;
          }
          Sqlite3.explainComposite(pParse, (int) p.op, a1, a2, p.op != (byte) 113);
          if (((int) p.selFlags & 8) != 0)
          {
            int nExpr = p.pEList.nExpr;
            Sqlite3.KeyInfo pT = new Sqlite3.KeyInfo();
            pT.aColl = new Sqlite3.CollSeq[nExpr];
            pT.enc = db.aDbStatic[0].pSchema.enc;
            pT.nField = (ushort) nExpr;
            for (int iCol = 0; iCol < nExpr; ++iCol)
            {
              Sqlite3.CollSeq collSeq = Sqlite3.multiSelectCollSeq(pParse, p, iCol) ?? db.pDfltColl;
              pT.aColl[iCol] = collSeq;
            }
            for (Sqlite3.Select select = p; select != null; select = select.pPrior)
            {
              for (int index = 0; index < 2; ++index)
              {
                int addr2 = select.addrOpenEphm[index];
                if (addr2 >= 0)
                {
                  Sqlite3.sqlite3VdbeChangeP2(vdbe, addr2, nExpr);
                  Sqlite3.sqlite3VdbeChangeP4(vdbe, addr2, pT, -6);
                  select.addrOpenEphm[index] = -1;
                }
                else
                  break;
              }
            }
            Sqlite3.sqlite3DbFree<Sqlite3.KeyInfo>(db, ref pT);
          }
        }
      }
label_52:
      pDest.iMem = pDest1.iMem;
      pDest.nMem = pDest1.nMem;
      Sqlite3.sqlite3SelectDelete(db, ref p1);
      return num1;
    }

    private static int generateOutputSubroutine(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.SelectDest pIn,
      Sqlite3.SelectDest pDest,
      int regReturn,
      int regPrev,
      Sqlite3.KeyInfo pKeyInfo,
      int p4type,
      int iBreak)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int outputSubroutine = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
      int num1 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      if (regPrev != 0)
      {
        int addr = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 27, regPrev);
        int num2 = Sqlite3.sqlite3VdbeAddOp4(pVdbe, 24, pIn.iMem, regPrev + 1, pIn.nMem, pKeyInfo, p4type);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 25, num2 + 2, num1, num2 + 2);
        Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr);
        Sqlite3.sqlite3ExprCodeCopy(pParse, pIn.iMem, regPrev + 1, pIn.nMem);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, regPrev);
      }
      Sqlite3.codeOffset(pVdbe, p, num1);
      switch (pDest.eDest)
      {
        case 6:
          Sqlite3.sqlite3ExprCodeMove(pParse, pIn.iMem, pDest.iParm, 1);
          break;
        case 7:
          p.affinity = Sqlite3.sqlite3CompareAffinity(p.pEList.a[0].pExpr, pDest.affinity);
          int tempReg1 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 30, pIn.iMem, 1, tempReg1, p.affinity, 1);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, pIn.iMem, 1);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 70, pDest.iParm, tempReg1);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg1);
          break;
        case 8:
        case 9:
          int tempReg2 = Sqlite3.sqlite3GetTempReg(pParse);
          int tempReg3 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.testcase<bool>(pDest.eDest == (byte) 8);
          Sqlite3.testcase<bool>(pDest.eDest == (byte) 9);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 30, pIn.iMem, pIn.nMem, tempReg2);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 54, pDest.iParm, tempReg3);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 55, pDest.iParm, tempReg2, tempReg3);
          Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 8);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg3);
          Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg2);
          break;
        case 10:
          if (pDest.iMem == 0)
          {
            pDest.iMem = Sqlite3.sqlite3GetTempRange(pParse, pIn.nMem);
            pDest.nMem = pIn.nMem;
          }
          Sqlite3.sqlite3ExprCodeMove(pParse, pIn.iMem, pDest.iMem, pDest.nMem);
          Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, pDest.iParm);
          break;
        default:
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 16, pIn.iMem, pIn.nMem);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, pIn.iMem, pIn.nMem);
          break;
      }
      if (p.iLimit != 0)
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 115, p.iLimit, iBreak, -1);
      Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num1);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 3, regReturn);
      return outputSubroutine;
    }

    private static int multiSelectOrderBy(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.SelectDest pDest)
    {
      Sqlite3.SelectDest pDest1 = new Sqlite3.SelectDest();
      Sqlite3.SelectDest pDest2 = new Sqlite3.SelectDest();
      int p2_1 = 0;
      Sqlite3.KeyInfo pKeyInfo = (Sqlite3.KeyInfo) null;
      int a1 = 0;
      int a2 = 0;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int num1 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      int num2 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      int op = (int) p.op;
      Sqlite3.Select pPrior = p.pPrior;
      Sqlite3.ExprList exprList = p.pOrderBy;
      int nExpr1 = exprList.nExpr;
      if (op != 113)
      {
        for (int index1 = 1; index1 <= p.pEList.nExpr; ++index1)
        {
          int index2 = 0;
          while (index2 < nExpr1 && (int) exprList.a[index2].iCol != index1)
            ++index2;
          if (index2 == nExpr1)
          {
            Sqlite3.Expr pExpr = Sqlite3.sqlite3Expr(db, 129, (string) null);
            pExpr.flags |= (ushort) 1024;
            pExpr.u.iValue = index1;
            exprList = Sqlite3.sqlite3ExprListAppend(pParse, exprList, pExpr);
            exprList.a[nExpr1++].iCol = (ushort) index1;
          }
        }
      }
      int[] pP4_1 = new int[nExpr1];
      Sqlite3.KeyInfo pP4_2;
      if (pP4_1 != null)
      {
        for (int index = 0; index < nExpr1; ++index)
        {
          Sqlite3.ExprList_item exprListItem = exprList.a[index];
          pP4_1[index] = (int) exprListItem.iCol - 1;
        }
        pP4_2 = new Sqlite3.KeyInfo();
        if (pP4_2 != null)
        {
          pP4_2.aColl = new Sqlite3.CollSeq[nExpr1];
          pP4_2.aSortOrder = new byte[nExpr1];
          pP4_2.nField = (ushort) nExpr1;
          pP4_2.enc = Sqlite3.ENC(db);
          for (int index = 0; index < nExpr1; ++index)
          {
            Sqlite3.Expr pExpr = exprList.a[index].pExpr;
            Sqlite3.CollSeq collSeq;
            if (((int) pExpr.flags & 256) != 0)
            {
              collSeq = pExpr.pColl;
            }
            else
            {
              collSeq = Sqlite3.multiSelectCollSeq(pParse, p, pP4_1[index]);
              pExpr.flags |= (ushort) 256;
              pExpr.pColl = collSeq;
            }
            pP4_2.aColl[index] = collSeq;
            pP4_2.aSortOrder[index] = exprList.a[index].sortOrder;
          }
        }
      }
      else
        pP4_2 = (Sqlite3.KeyInfo) null;
      p.pOrderBy = exprList;
      pPrior.pOrderBy = Sqlite3.sqlite3ExprListDup(pParse.db, exprList, 0);
      int num3;
      if (op == 113)
      {
        num3 = 0;
      }
      else
      {
        int nExpr2 = p.pEList.nExpr;
        num3 = Sqlite3.sqlite3GetTempRange(pParse, nExpr2 + 1);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, num3);
        pKeyInfo = new Sqlite3.KeyInfo();
        if (pKeyInfo != null)
        {
          pKeyInfo.aColl = new Sqlite3.CollSeq[nExpr2];
          pKeyInfo.aSortOrder = new byte[nExpr2];
          pKeyInfo.nField = (ushort) nExpr2;
          pKeyInfo.enc = Sqlite3.ENC(db);
          for (int iCol = 0; iCol < nExpr2; ++iCol)
          {
            pKeyInfo.aColl[iCol] = Sqlite3.multiSelectCollSeq(pParse, p, iCol);
            pKeyInfo.aSortOrder[iCol] = (byte) 0;
          }
        }
      }
      p.pPrior = (Sqlite3.Select) null;
      Sqlite3.sqlite3ResolveOrderGroupBy(pParse, p, p.pOrderBy, "ORDER");
      if (pPrior.pPrior == null)
        Sqlite3.sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior.pOrderBy, "ORDER");
      Sqlite3.computeLimitRegisters(pParse, p, num1);
      int num4;
      int p2_2;
      if (p.iLimit != 0 && op == 113)
      {
        num4 = ++pParse.nMem;
        p2_2 = ++pParse.nMem;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 14, p.iOffset != 0 ? p.iOffset + 1 : p.iLimit, num4);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 14, num4, p2_2);
      }
      else
        num4 = p2_2 = 0;
      Sqlite3.sqlite3ExprDelete(db, ref p.pLimit);
      p.pLimit = (Sqlite3.Expr) null;
      Sqlite3.sqlite3ExprDelete(db, ref p.pOffset);
      p.pOffset = (Sqlite3.Expr) null;
      int num5 = ++pParse.nMem;
      int num6 = ++pParse.nMem;
      int num7 = ++pParse.nMem;
      int num8 = ++pParse.nMem;
      int num9 = ++pParse.nMem;
      int num10 = ++pParse.nMem;
      Sqlite3.sqlite3SelectDestInit(pDest1, 10, num5);
      Sqlite3.sqlite3SelectDestInit(pDest2, 10, num7);
      int addr = Sqlite3.sqlite3VdbeAddOp0(pVdbe, 1);
      int p2_3 = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
      Sqlite3.VdbeNoopComment(pVdbe, "Begin coroutine for left SELECT");
      pPrior.iLimit = num4;
      Sqlite3.explainSetInteger(ref a1, pParse.iNextSelectId);
      Sqlite3.sqlite3Select(pParse, pPrior, ref pDest1);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, num6);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num5);
      Sqlite3.VdbeNoopComment(pVdbe, "End coroutine for left SELECT");
      int p2_4 = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
      Sqlite3.VdbeNoopComment(pVdbe, "Begin coroutine for right SELECT");
      int iLimit = p.iLimit;
      int iOffset = p.iOffset;
      p.iLimit = p2_2;
      p.iOffset = 0;
      Sqlite3.explainSetInteger(ref a2, pParse.iNextSelectId);
      Sqlite3.sqlite3Select(pParse, p, ref pDest2);
      p.iLimit = iLimit;
      p.iOffset = iOffset;
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, num8);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num7);
      Sqlite3.VdbeNoopComment(pVdbe, "End coroutine for right SELECT");
      Sqlite3.VdbeNoopComment(pVdbe, "Output routine for A");
      int outputSubroutine = Sqlite3.generateOutputSubroutine(pParse, p, pDest1, pDest, num9, num3, pKeyInfo, -16, num1);
      if (op == 113 || op == 112)
      {
        Sqlite3.VdbeNoopComment(pVdbe, "Output routine for B");
        p2_1 = Sqlite3.generateOutputSubroutine(pParse, p, pDest2, pDest, num10, num3, pKeyInfo, -17, num1);
      }
      Sqlite3.VdbeNoopComment(pVdbe, "eof-A subroutine");
      int p2_5;
      if (op == 114 || op == 115)
      {
        p2_5 = Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, num1);
      }
      else
      {
        p2_5 = Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num8, num1);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num10, p2_1);
        Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num7);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, p2_5);
        p.nSelectRow += pPrior.nSelectRow;
      }
      int p2_6;
      if (op == 115)
      {
        p2_6 = p2_5;
        if (p.nSelectRow > pPrior.nSelectRow)
          p.nSelectRow = pPrior.nSelectRow;
      }
      else
      {
        Sqlite3.VdbeNoopComment(pVdbe, "eof-B subroutine");
        p2_6 = Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num6, num1);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num9, outputSubroutine);
        Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num5);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, p2_6);
      }
      Sqlite3.VdbeNoopComment(pVdbe, "A-lt-B subroutine");
      int p1 = Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num9, outputSubroutine);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num5);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num6, p2_5);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, num2);
      int p2_7;
      switch (op)
      {
        case 113:
          p2_7 = p1;
          break;
        case 115:
          p2_7 = p1;
          ++p1;
          break;
        default:
          Sqlite3.VdbeNoopComment(pVdbe, "A-eq-B subroutine");
          p2_7 = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num5);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num6, p2_5);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, num2);
          break;
      }
      Sqlite3.VdbeNoopComment(pVdbe, "A-gt-B subroutine");
      int p3 = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
      if (op == 113 || op == 112)
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num10, p2_1);
      Sqlite3.sqlite3VdbeAddOp1(pVdbe, 4, num7);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num8, p2_6);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, num2);
      Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, num6);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, num8);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num5, p2_3);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num7, p2_4);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num6, p2_5);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 26, num8, p2_6);
      Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num2);
      Sqlite3.sqlite3VdbeAddOp4(pVdbe, 23, 0, 0, 0, pP4_1, -15);
      Sqlite3.sqlite3VdbeAddOp4(pVdbe, 24, pDest1.iMem, pDest2.iMem, nExpr1, pP4_2, -16);
      Sqlite3.sqlite3VdbeAddOp3(pVdbe, 25, p1, p2_7, p3);
      if (num3 != 0)
        Sqlite3.sqlite3ReleaseTempRange(pParse, num3, nExpr1 + 1);
      Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num1);
      if (pDest.eDest == (byte) 5)
      {
        Sqlite3.Select select = pPrior;
        while (select.pPrior != null)
          select = select.pPrior;
        Sqlite3.generateColumnNames(pParse, (Sqlite3.SrcList) null, select.pEList);
      }
      if (p.pPrior != null)
        Sqlite3.sqlite3SelectDelete(db, ref p.pPrior);
      p.pPrior = pPrior;
      Sqlite3.explainComposite(pParse, (int) p.op, a1, a2, false);
      return 0;
    }

    private static Sqlite3.Expr substExpr(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr pExpr,
      int iTable,
      Sqlite3.ExprList pEList)
    {
      if (pExpr == null)
        return (Sqlite3.Expr) null;
      if (pExpr.op == (byte) 152 && pExpr.iTable == iTable)
      {
        if (pExpr.iColumn < (short) 0)
        {
          pExpr.op = (byte) 98;
        }
        else
        {
          Sqlite3.Expr expr = Sqlite3.sqlite3ExprDup(db, pEList.a[(int) pExpr.iColumn].pExpr, 0);
          if (pExpr.pColl != null)
            expr.pColl = pExpr.pColl;
          Sqlite3.sqlite3ExprDelete(db, ref pExpr);
          pExpr = expr;
        }
      }
      else
      {
        pExpr.pLeft = Sqlite3.substExpr(db, pExpr.pLeft, iTable, pEList);
        pExpr.pRight = Sqlite3.substExpr(db, pExpr.pRight, iTable, pEList);
        if (Sqlite3.ExprHasProperty(pExpr, 2048))
          Sqlite3.substSelect(db, pExpr.x.pSelect, iTable, pEList);
        else
          Sqlite3.substExprList(db, pExpr.x.pList, iTable, pEList);
      }
      return pExpr;
    }

    private static void substExprList(
      Sqlite3.sqlite3 db,
      Sqlite3.ExprList pList,
      int iTable,
      Sqlite3.ExprList pEList)
    {
      if (pList == null)
        return;
      for (int index = 0; index < pList.nExpr; ++index)
        pList.a[index].pExpr = Sqlite3.substExpr(db, pList.a[index].pExpr, iTable, pEList);
    }

    private static void substSelect(
      Sqlite3.sqlite3 db,
      Sqlite3.Select p,
      int iTable,
      Sqlite3.ExprList pEList)
    {
      if (p == null)
        return;
      Sqlite3.substExprList(db, p.pEList, iTable, pEList);
      Sqlite3.substExprList(db, p.pGroupBy, iTable, pEList);
      Sqlite3.substExprList(db, p.pOrderBy, iTable, pEList);
      p.pHaving = Sqlite3.substExpr(db, p.pHaving, iTable, pEList);
      p.pWhere = Sqlite3.substExpr(db, p.pWhere, iTable, pEList);
      Sqlite3.substSelect(db, p.pPrior, iTable, pEList);
      Sqlite3.SrcList pSrc = p.pSrc;
      if (!Sqlite3.ALWAYS<Sqlite3.SrcList>(pSrc))
        return;
      for (int nSrc = (int) pSrc.nSrc; nSrc > 0; --nSrc)
      {
        Sqlite3.SrcList_item srcListItem = pSrc.a[(int) pSrc.nSrc - nSrc];
        Sqlite3.substSelect(db, srcListItem.pSelect, iTable, pEList);
      }
    }

    private static int flattenSubquery(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      int iFrom,
      bool isAgg,
      bool subqueryIsAgg)
    {
      string zAuthContext = pParse.zAuthContext;
      Sqlite3.sqlite3 db = pParse.db;
      if ((db.flags & 1) != 0)
        return 0;
      Sqlite3.SrcList pSrc1 = p.pSrc;
      Sqlite3.SrcList_item srcListItem = pSrc1.a[iFrom];
      int iCursor = srcListItem.iCursor;
      Sqlite3.Select pSelect1 = srcListItem.pSelect;
      if (isAgg & subqueryIsAgg || subqueryIsAgg && pSrc1.nSrc > (short) 1)
        return 0;
      Sqlite3.SrcList pSrc2 = pSelect1.pSrc;
      if (pSelect1.pLimit != null && p.pLimit != null || pSelect1.pOffset != null || p.pRightmost != null && pSelect1.pLimit != null || pSrc2.nSrc == (short) 0 || ((int) pSelect1.selFlags & 1) != 0 || pSelect1.pLimit != null && pSrc1.nSrc > (short) 1 | isAgg || ((uint) p.selFlags & 1U) > 0U & subqueryIsAgg || p.pOrderBy != null && pSelect1.pOrderBy != null || isAgg && pSelect1.pOrderBy != null || pSelect1.pLimit != null && p.pWhere != null || pSelect1.pLimit != null && ((int) p.selFlags & 1) != 0 || ((int) srcListItem.jointype & 32) != 0)
        return 0;
      if (pSelect1.pPrior != null)
      {
        if (pSelect1.pOrderBy != null || isAgg || ((int) p.selFlags & 1) != 0 || pSrc1.nSrc != (short) 1)
          return 0;
        for (Sqlite3.Select select = pSelect1; select != null; select = select.pPrior)
        {
          Sqlite3.testcase<bool>(((int) select.selFlags & 5) == 1);
          Sqlite3.testcase<bool>(((int) select.selFlags & 5) == 4);
          if (((int) select.selFlags & 5) != 0 || select.pPrior != null && select.op != (byte) 113 || Sqlite3.NEVER(select.pSrc == null) || select.pSrc.nSrc != (short) 1)
            return 0;
        }
        if (p.pOrderBy != null)
        {
          for (int index = 0; index < p.pOrderBy.nExpr; ++index)
          {
            if (p.pOrderBy.a[index].iCol == (ushort) 0)
              return 0;
          }
        }
      }
      pParse.zAuthContext = srcListItem.zName;
      Sqlite3.sqlite3AuthCheck(pParse, 21, (string) null, (byte[]) null, (byte[]) null);
      pParse.zAuthContext = zAuthContext;
      for (Sqlite3.Select pPrior1 = pSelect1.pPrior; pPrior1 != null; pPrior1 = pPrior1.pPrior)
      {
        Sqlite3.ExprList pOrderBy = p.pOrderBy;
        Sqlite3.Expr pLimit = p.pLimit;
        Sqlite3.Select pPrior2 = p.pPrior;
        p.pOrderBy = (Sqlite3.ExprList) null;
        p.pSrc = (Sqlite3.SrcList) null;
        p.pPrior = (Sqlite3.Select) null;
        p.pLimit = (Sqlite3.Expr) null;
        Sqlite3.Select select = Sqlite3.sqlite3SelectDup(db, p, 0);
        p.pLimit = pLimit;
        p.pOrderBy = pOrderBy;
        p.pSrc = pSrc1;
        p.op = (byte) 113;
        p.pRightmost = (Sqlite3.Select) null;
        if (select == null)
        {
          select = pPrior2;
        }
        else
        {
          select.pPrior = pPrior2;
          select.pRightmost = (Sqlite3.Select) null;
        }
        p.pPrior = select;
      }
      Sqlite3.Select pSelect2;
      Sqlite3.Select p1 = pSelect2 = srcListItem.pSelect;
      Sqlite3.sqlite3DbFree(db, ref srcListItem.zDatabase);
      Sqlite3.sqlite3DbFree(db, ref srcListItem.zName);
      Sqlite3.sqlite3DbFree(db, ref srcListItem.zAlias);
      srcListItem.zDatabase = (string) null;
      srcListItem.zName = (string) null;
      srcListItem.zAlias = (string) null;
      srcListItem.pSelect = (Sqlite3.Select) null;
      if (Sqlite3.ALWAYS(srcListItem.pTab != null))
      {
        Sqlite3.Table pTab = srcListItem.pTab;
        if (pTab.nRef == (ushort) 1)
        {
          Sqlite3.Parse toplevel = Sqlite3.sqlite3ParseToplevel(pParse);
          pTab.pNextZombie = toplevel.pZombieTab;
          toplevel.pZombieTab = pTab;
        }
        else
          --pTab.nRef;
        srcListItem.pTab = (Sqlite3.Table) null;
      }
      Sqlite3.Select select1 = p;
      while (select1 != null)
      {
        byte num = 0;
        Sqlite3.SrcList pSrc3 = p1.pSrc;
        int nSrc = (int) pSrc3.nSrc;
        Sqlite3.SrcList pSrc4 = select1.pSrc;
        if (pSrc4 != null)
          num = srcListItem.jointype;
        else
          pSrc4 = select1.pSrc = Sqlite3.sqlite3SrcListAppend(db, (Sqlite3.SrcList) null, (Sqlite3.Token) null, (Sqlite3.Token) null);
        if (nSrc > 1)
          select1.pSrc = pSrc4 = Sqlite3.sqlite3SrcListEnlarge(db, pSrc4, nSrc - 1, iFrom + 1);
        for (int index = 0; index < nSrc; ++index)
        {
          Sqlite3.sqlite3IdListDelete(db, ref pSrc4.a[index + iFrom].pUsing);
          pSrc4.a[index + iFrom] = pSrc3.a[index];
          pSrc3.a[index] = new Sqlite3.SrcList_item();
        }
        srcListItem = pSrc4.a[iFrom];
        pSrc4.a[iFrom].jointype = num;
        Sqlite3.ExprList pElist = select1.pEList;
        for (int index = 0; index < pElist.nExpr; ++index)
        {
          if (pElist.a[index].zName == null)
          {
            string zSpan = pElist.a[index].zSpan;
            if (Sqlite3.ALWAYS<string>(zSpan))
              pElist.a[index].zName = zSpan;
          }
        }
        Sqlite3.substExprList(db, select1.pEList, iCursor, p1.pEList);
        if (isAgg)
        {
          Sqlite3.substExprList(db, select1.pGroupBy, iCursor, p1.pEList);
          select1.pHaving = Sqlite3.substExpr(db, select1.pHaving, iCursor, p1.pEList);
        }
        if (p1.pOrderBy != null)
        {
          select1.pOrderBy = p1.pOrderBy;
          p1.pOrderBy = (Sqlite3.ExprList) null;
        }
        else if (select1.pOrderBy != null)
          Sqlite3.substExprList(db, select1.pOrderBy, iCursor, p1.pEList);
        Sqlite3.Expr pRight = p1.pWhere == null ? (Sqlite3.Expr) null : Sqlite3.sqlite3ExprDup(db, p1.pWhere, 0);
        if (subqueryIsAgg)
        {
          select1.pHaving = select1.pWhere;
          select1.pWhere = pRight;
          select1.pHaving = Sqlite3.substExpr(db, select1.pHaving, iCursor, p1.pEList);
          select1.pHaving = Sqlite3.sqlite3ExprAnd(db, select1.pHaving, Sqlite3.sqlite3ExprDup(db, p1.pHaving, 0));
          select1.pGroupBy = Sqlite3.sqlite3ExprListDup(db, p1.pGroupBy, 0);
        }
        else
        {
          select1.pWhere = Sqlite3.substExpr(db, select1.pWhere, iCursor, p1.pEList);
          select1.pWhere = Sqlite3.sqlite3ExprAnd(db, select1.pWhere, pRight);
        }
        select1.selFlags |= (ushort) ((uint) p1.selFlags & 1U);
        if (p1.pLimit != null)
        {
          select1.pLimit = p1.pLimit;
          p1.pLimit = (Sqlite3.Expr) null;
        }
        select1 = select1.pPrior;
        p1 = p1.pPrior;
      }
      Sqlite3.sqlite3SelectDelete(db, ref p1);
      Sqlite3.sqlite3SelectDelete(db, ref pSelect2);
      return 1;
    }

    private static byte minMaxQuery(Sqlite3.Select p)
    {
      Sqlite3.ExprList pElist = p.pEList;
      if (pElist.nExpr != 1)
        return 0;
      Sqlite3.Expr pExpr = pElist.a[0].pExpr;
      if (pExpr.op != (byte) 153 || Sqlite3.NEVER(Sqlite3.ExprHasProperty(pExpr, 2048)))
        return 0;
      Sqlite3.ExprList pList = pExpr.x.pList;
      if (pList == null || pList.nExpr != 1 || pList.a[0].pExpr.op != (byte) 154)
        return 0;
      if (pExpr.u.zToken.Equals("min", StringComparison.InvariantCultureIgnoreCase))
        return 1;
      return pExpr.u.zToken.Equals("max", StringComparison.InvariantCultureIgnoreCase) ? (byte) 2 : (byte) 0;
    }

    private static Sqlite3.Table isSimpleCount(Sqlite3.Select p, Sqlite3.AggInfo pAggInfo)
    {
      if (p.pWhere != null || p.pEList.nExpr != 1 || p.pSrc.nSrc != (short) 1 || p.pSrc.a[0].pSelect != null)
        return (Sqlite3.Table) null;
      Sqlite3.Table pTab = p.pSrc.a[0].pTab;
      Sqlite3.Expr pExpr = p.pEList.a[0].pExpr;
      if (Sqlite3.IsVirtual(pTab))
        return (Sqlite3.Table) null;
      if (pExpr.op != (byte) 153)
        return (Sqlite3.Table) null;
      if (((int) pAggInfo.aFunc[0].pFunc.flags & 32) == 0)
        return (Sqlite3.Table) null;
      return ((int) pExpr.flags & 16) != 0 ? (Sqlite3.Table) null : pTab;
    }

    private static int sqlite3IndexedByLookup(Sqlite3.Parse pParse, Sqlite3.SrcList_item pFrom)
    {
      if (pFrom.pTab != null && pFrom.zIndex != null && pFrom.zIndex.Length != 0)
      {
        Sqlite3.Table pTab = pFrom.pTab;
        string zIndex = pFrom.zIndex;
        Sqlite3.Index index = pTab.pIndex;
        while (index != null && !index.zName.Equals(zIndex, StringComparison.InvariantCultureIgnoreCase))
          index = index.pNext;
        if (index == null)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "no such index: %s", (object) zIndex);
          pParse.checkSchema = (byte) 1;
          return 1;
        }
        pFrom.pIndex = index;
      }
      return 0;
    }

    private static int selectExpander(Sqlite3.Walker pWalker, Sqlite3.Select p)
    {
      Sqlite3.Parse pParse = pWalker.pParse;
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.NEVER(p.pSrc == null) || ((int) p.selFlags & 16) != 0)
        return 1;
      p.selFlags |= (ushort) 16;
      Sqlite3.SrcList pSrc = p.pSrc;
      Sqlite3.ExprList pElist = p.pEList;
      Sqlite3.sqlite3SrcListAssignCursors(pParse, pSrc);
      for (int index = 0; index < (int) pSrc.nSrc; ++index)
      {
        Sqlite3.SrcList_item pFrom = pSrc.a[index];
        if (pFrom.pTab != null)
          return 1;
        if (pFrom.zName == null)
        {
          Sqlite3.Select p1 = pFrom.pSelect;
          Sqlite3.sqlite3WalkSelect(pWalker, p1);
          Sqlite3.Table table;
          pFrom.pTab = table = new Sqlite3.Table();
          if (table == null)
            return 2;
          table.nRef = (ushort) 1;
          table.zName = Sqlite3.sqlite3MPrintf(db, "sqlite_subquery_%p_", (object) table);
          while (p1.pPrior != null)
            p1 = p1.pPrior;
          Sqlite3.selectColumnsFromExprList(pParse, p1.pEList, ref table.nCol, ref table.aCol);
          table.iPKey = -1;
          table.nRowEst = 1000000U;
          table.tabFlags |= (byte) 2;
        }
        else
        {
          Sqlite3.Table table;
          pFrom.pTab = table = Sqlite3.sqlite3LocateTable(pParse, 0, pFrom.zName, pFrom.zDatabase);
          if (table == null)
            return 2;
          ++table.nRef;
          if (table.pSelect != null || Sqlite3.IsVirtual(table))
          {
            if (Sqlite3.sqlite3ViewGetColumnNames(pParse, table) != 0)
              return 2;
            pFrom.pSelect = Sqlite3.sqlite3SelectDup(db, table.pSelect, 0);
            Sqlite3.sqlite3WalkSelect(pWalker, pFrom.pSelect);
          }
        }
        if (Sqlite3.sqlite3IndexedByLookup(pParse, pFrom) != 0)
          return 2;
      }
      if (Sqlite3.sqliteProcessJoin(pParse, p) != 0)
        return 2;
      int index1;
      for (index1 = 0; index1 < pElist.nExpr; ++index1)
      {
        Sqlite3.Expr pExpr = pElist.a[index1].pExpr;
        if (pExpr.op == (byte) 113 || pExpr.op == (byte) 118 && pExpr.pRight.op == (byte) 113)
          break;
      }
      if (index1 < pElist.nExpr)
      {
        Sqlite3.ExprList_item[] a = pElist.a;
        Sqlite3.ExprList pList = (Sqlite3.ExprList) null;
        int flags = pParse.db.flags;
        bool flag = (flags & 1024) != 0 && (flags & 2048) == 0;
        for (int index2 = 0; index2 < pElist.nExpr; ++index2)
        {
          Sqlite3.Expr pExpr1 = a[index2].pExpr;
          if (pExpr1.op != (byte) 113 && (pExpr1.op != (byte) 118 || pExpr1.pRight.op != (byte) 113))
          {
            pList = Sqlite3.sqlite3ExprListAppend(pParse, pList, a[index2].pExpr);
            if (pList != null)
            {
              pList.a[pList.nExpr - 1].zName = a[index2].zName;
              pList.a[pList.nExpr - 1].zSpan = a[index2].zSpan;
              a[index2].zName = (string) null;
              a[index2].zSpan = (string) null;
            }
            a[index2].pExpr = (Sqlite3.Expr) null;
          }
          else
          {
            int num1 = 0;
            string str = pExpr1.op != (byte) 118 ? (string) null : pExpr1.pLeft.u.zToken;
            for (int N = 0; N < (int) pSrc.nSrc; ++N)
            {
              Sqlite3.SrcList_item srcListItem = pSrc.a[N];
              Sqlite3.Table pTab = srcListItem.pTab;
              string zToken = srcListItem.zAlias ?? pTab.zName;
              if (str == null || str.Equals(zToken, StringComparison.InvariantCultureIgnoreCase))
              {
                num1 = 1;
                for (int index3 = 0; index3 < pTab.nCol; ++index3)
                {
                  string zName = pTab.aCol[index3].zName;
                  Sqlite3.Token pName = new Sqlite3.Token();
                  if (!Sqlite3.IsHiddenColumn(pTab.aCol[index3]))
                  {
                    if (N > 0 && (str == null || str.Length == 0))
                    {
                      int num2 = 0;
                      if (((int) srcListItem.jointype & 4) != 0 && Sqlite3.tableAndColumnIndex(pSrc, N, zName, ref num2, ref num2) != 0 || Sqlite3.sqlite3IdListIndex(srcListItem.pUsing, zName) >= 0)
                        continue;
                    }
                    Sqlite3.Expr pRight = Sqlite3.sqlite3Expr(db, 26, zName);
                    string z = zName;
                    string pString = "";
                    Sqlite3.Expr pExpr2;
                    if (flag || pSrc.nSrc > (short) 1)
                    {
                      Sqlite3.Expr pLeft = Sqlite3.sqlite3Expr(db, 26, zToken);
                      pExpr2 = Sqlite3.sqlite3PExpr(pParse, 118, pLeft, pRight, 0);
                      if (flag)
                      {
                        z = Sqlite3.sqlite3MPrintf(db, "%s.%s", (object) zToken, (object) zName);
                        pString = z;
                      }
                    }
                    else
                      pExpr2 = pRight;
                    pList = Sqlite3.sqlite3ExprListAppend(pParse, pList, pExpr2);
                    pName.z = z;
                    pName.n = Sqlite3.sqlite3Strlen30(z);
                    Sqlite3.sqlite3ExprListSetName(pParse, pList, pName, 0);
                    Sqlite3.sqlite3DbFree(db, ref pString);
                  }
                }
              }
            }
            if (num1 == 0)
            {
              if (str != null)
                Sqlite3.sqlite3ErrorMsg(pParse, "no such table: %s", (object) str);
              else
                Sqlite3.sqlite3ErrorMsg(pParse, "no tables specified");
            }
          }
        }
        Sqlite3.sqlite3ExprListDelete(db, ref pElist);
        p.pEList = pList;
      }
      if (p.pEList != null && p.pEList.nExpr > db.aLimit[2])
        Sqlite3.sqlite3ErrorMsg(pParse, "too many columns in result set");
      return 0;
    }

    private static int exprWalkNoop(Sqlite3.Walker NotUsed, ref Sqlite3.Expr NotUsed2)
    {
      Sqlite3.UNUSED_PARAMETER2<Sqlite3.Walker, Sqlite3.Expr>(NotUsed, NotUsed2);
      return 0;
    }

    private static void sqlite3SelectExpand(Sqlite3.Parse pParse, Sqlite3.Select pSelect) => Sqlite3.sqlite3WalkSelect(new Sqlite3.Walker()
    {
      xSelectCallback = new Sqlite3.dxSelectCallback(Sqlite3.selectExpander),
      xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.exprWalkNoop),
      pParse = pParse
    }, pSelect);

    private static int selectAddSubqueryTypeInfo(Sqlite3.Walker pWalker, Sqlite3.Select p)
    {
      if (((int) p.selFlags & 32) == 0)
      {
        p.selFlags |= (ushort) 32;
        Sqlite3.Parse pParse = pWalker.pParse;
        Sqlite3.SrcList pSrc = p.pSrc;
        for (int index = 0; index < (int) pSrc.nSrc; ++index)
        {
          Sqlite3.SrcList_item srcListItem = pSrc.a[index];
          Sqlite3.Table pTab = srcListItem.pTab;
          if (Sqlite3.ALWAYS(pTab != null) && ((int) pTab.tabFlags & 2) != 0)
          {
            Sqlite3.Select pSelect = srcListItem.pSelect;
            while (pSelect.pPrior != null)
              pSelect = pSelect.pPrior;
            Sqlite3.selectAddColumnTypeAndCollation(pParse, pTab.nCol, pTab.aCol, pSelect);
          }
        }
      }
      return 0;
    }

    private static void sqlite3SelectAddTypeInfo(Sqlite3.Parse pParse, Sqlite3.Select pSelect) => Sqlite3.sqlite3WalkSelect(new Sqlite3.Walker()
    {
      xSelectCallback = new Sqlite3.dxSelectCallback(Sqlite3.selectAddSubqueryTypeInfo),
      xExprCallback = new Sqlite3.dxExprCallback(Sqlite3.exprWalkNoop),
      pParse = pParse
    }, pSelect);

    private static void sqlite3SelectPrep(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      Sqlite3.NameContext pOuterNC)
    {
      if (Sqlite3.NEVER(p == null))
        return;
      Sqlite3.sqlite3 db = pParse.db;
      if (((int) p.selFlags & 32) != 0)
        return;
      Sqlite3.sqlite3SelectExpand(pParse, p);
      if (pParse.nErr != 0)
        return;
      Sqlite3.sqlite3ResolveSelectNames(pParse, p, pOuterNC);
      if (pParse.nErr != 0)
        return;
      Sqlite3.sqlite3SelectAddTypeInfo(pParse, p);
    }

    private static void resetAccumulator(Sqlite3.Parse pParse, Sqlite3.AggInfo pAggInfo)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      if (pAggInfo.nFunc + pAggInfo.nColumn == 0)
        return;
      for (int index = 0; index < pAggInfo.nColumn; ++index)
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, pAggInfo.aCol[index].iMem);
      for (int index = 0; index < pAggInfo.nFunc; ++index)
      {
        Sqlite3.AggInfo_func aggInfoFunc = pAggInfo.aFunc[index];
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, aggInfoFunc.iMem);
        if (aggInfoFunc.iDistinct >= 0)
        {
          Sqlite3.Expr pExpr = aggInfoFunc.pExpr;
          if (pExpr.x.pList == null || pExpr.x.pList.nExpr != 1)
          {
            Sqlite3.sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one argument");
            aggInfoFunc.iDistinct = -1;
          }
          else
          {
            Sqlite3.KeyInfo pP4 = Sqlite3.keyInfoFromExprList(pParse, pExpr.x.pList);
            Sqlite3.sqlite3VdbeAddOp4(pVdbe, 41, aggInfoFunc.iDistinct, 0, 0, pP4, -16);
          }
        }
      }
    }

    private static void finalizeAggFunctions(Sqlite3.Parse pParse, Sqlite3.AggInfo pAggInfo)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      for (int index = 0; index < pAggInfo.nFunc; ++index)
      {
        Sqlite3.AggInfo_func aggInfoFunc = pAggInfo.aFunc[index];
        Sqlite3.ExprList pList = aggInfoFunc.pExpr.x.pList;
        Sqlite3.sqlite3VdbeAddOp4(pVdbe, 117, aggInfoFunc.iMem, pList != null ? pList.nExpr : 0, 0, aggInfoFunc.pFunc, -5);
      }
    }

    private static void updateAccumulator(Sqlite3.Parse pParse, Sqlite3.AggInfo pAggInfo)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      pAggInfo.directMode = (byte) 1;
      Sqlite3.sqlite3ExprCacheClear(pParse);
      for (int index1 = 0; index1 < pAggInfo.nFunc; ++index1)
      {
        Sqlite3.AggInfo_func aggInfoFunc = pAggInfo.aFunc[index1];
        int num1 = 0;
        Sqlite3.ExprList pList = aggInfoFunc.pExpr.x.pList;
        int num2;
        int num3;
        if (pList != null)
        {
          num2 = pList.nExpr;
          num3 = Sqlite3.sqlite3GetTempRange(pParse, num2);
          Sqlite3.sqlite3ExprCodeExprList(pParse, pList, num3, true);
        }
        else
        {
          num2 = 0;
          num3 = 0;
        }
        if (aggInfoFunc.iDistinct >= 0)
        {
          num1 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
          Sqlite3.codeDistinct(pParse, aggInfoFunc.iDistinct, num1, 1, num3);
        }
        if (((int) aggInfoFunc.pFunc.flags & 8) != 0)
        {
          Sqlite3.CollSeq pP4 = (Sqlite3.CollSeq) null;
          for (int index2 = 0; pP4 == null && index2 < num2; ++index2)
          {
            Sqlite3.ExprList_item exprListItem = pList.a[index2];
            pP4 = Sqlite3.sqlite3ExprCollSeq(pParse, exprListItem.pExpr);
          }
          if (pP4 == null)
            pP4 = pParse.db.pDfltColl;
          Sqlite3.sqlite3VdbeAddOp4(pVdbe, 17, 0, 0, 0, pP4, -4);
        }
        Sqlite3.sqlite3VdbeAddOp4(pVdbe, 116, 0, num3, aggInfoFunc.iMem, aggInfoFunc.pFunc, -5);
        Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) num2);
        Sqlite3.sqlite3ExprCacheAffinityChange(pParse, num3, num2);
        Sqlite3.sqlite3ReleaseTempRange(pParse, num3, num2);
        if (num1 != 0)
        {
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num1);
          Sqlite3.sqlite3ExprCacheClear(pParse);
        }
      }
      Sqlite3.sqlite3ExprCacheClear(pParse);
      for (int index = 0; index < pAggInfo.nAccumulator; ++index)
      {
        Sqlite3.AggInfo_col aggInfoCol = pAggInfo.aCol[index];
        Sqlite3.sqlite3ExprCode(pParse, aggInfoCol.pExpr, aggInfoCol.iMem);
      }
      pAggInfo.directMode = (byte) 0;
      Sqlite3.sqlite3ExprCacheClear(pParse);
    }

    private static void explainSimpleCount(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      Sqlite3.Index pIdx)
    {
      if (pParse.explain != (byte) 2)
        return;
      string pP4 = Sqlite3.sqlite3MPrintf(pParse.db, "SCAN TABLE %s %s%s(~%d rows)", (object) pTab.zName, pIdx != null ? (object) "USING COVERING INDEX " : (object) "", pIdx != null ? (object) pIdx.zName : (object) "", (object) pTab.nRowEst);
      Sqlite3.sqlite3VdbeAddOp4(pParse.pVdbe, 138, pParse.iSelectId, 0, 0, pP4, -1);
    }

    private static int sqlite3Select(
      Sqlite3.Parse pParse,
      Sqlite3.Select p,
      ref Sqlite3.SelectDest pDest)
    {
      Sqlite3.ExprList exprList = new Sqlite3.ExprList();
      Sqlite3.SrcList srcList = new Sqlite3.SrcList();
      int num1 = 1;
      int iSelectId = pParse.iSelectId;
      pParse.iSelectId = pParse.iNextSelectId++;
      Sqlite3.sqlite3 db = pParse.db;
      if (p == null || pParse.nErr != 0)
        return 1;
      Sqlite3.AggInfo pAggInfo = new Sqlite3.AggInfo();
      if (pDest.eDest <= (byte) 4)
      {
        Sqlite3.sqlite3ExprListDelete(db, ref p.pOrderBy);
        p.pOrderBy = (Sqlite3.ExprList) null;
        p.selFlags &= (ushort) 65534;
      }
      Sqlite3.sqlite3SelectPrep(pParse, p, (Sqlite3.NameContext) null);
      Sqlite3.ExprList ppOrderBy1 = p.pOrderBy;
      Sqlite3.SrcList pSrc = p.pSrc;
      Sqlite3.ExprList pElist = p.pEList;
      if (pParse.nErr == 0)
      {
        bool isAgg = ((uint) p.selFlags & 4U) > 0U;
        Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
        if (vdbe != null && !Sqlite3.checkForMultiColumnSelectError(pParse, pDest, pElist.nExpr))
        {
          for (int iFrom = 0; p.pPrior == null && iFrom < (int) pSrc.nSrc; ++iFrom)
          {
            Sqlite3.SrcList_item srcListItem = pSrc.a[iFrom];
            Sqlite3.SelectDest pDest1 = new Sqlite3.SelectDest();
            Sqlite3.Select pSelect = srcListItem.pSelect;
            if (pSelect != null && srcListItem.isPopulated == (byte) 0)
            {
              pParse.nHeight += Sqlite3.sqlite3SelectExprHeight(p);
              bool subqueryIsAgg = ((uint) pSelect.selFlags & 4U) > 0U;
              if (Sqlite3.flattenSubquery(pParse, p, iFrom, isAgg, subqueryIsAgg) != 0)
              {
                if (subqueryIsAgg)
                {
                  isAgg = true;
                  p.selFlags |= (ushort) 4;
                }
                iFrom = -1;
              }
              else
              {
                Sqlite3.sqlite3SelectDestInit(pDest1, 9, srcListItem.iCursor);
                Sqlite3.explainSetInteger(ref srcListItem.iSelectId, pParse.iNextSelectId);
                Sqlite3.sqlite3Select(pParse, pSelect, ref pDest1);
                srcListItem.isPopulated = (byte) 1;
                srcListItem.pTab.nRowEst = (uint) pSelect.nSelectRow;
              }
              pParse.nHeight -= Sqlite3.sqlite3SelectExprHeight(p);
              pSrc = p.pSrc;
              if (pDest.eDest > (byte) 4)
                ppOrderBy1 = p.pOrderBy;
            }
          }
          pElist = p.pEList;
          Sqlite3.Expr pWhere = p.pWhere;
          Sqlite3.ExprList pGroupBy = p.pGroupBy;
          Sqlite3.Expr pHaving = p.pHaving;
          bool flag = ((uint) p.selFlags & 1U) > 0U;
          if (p.pPrior != null)
          {
            if (p.pRightmost == null)
            {
              Sqlite3.Select select1 = (Sqlite3.Select) null;
              int num2 = 0;
              Sqlite3.Select select2 = p;
              while (select2 != null)
              {
                select2.pRightmost = p;
                select2.pNext = select1;
                select1 = select2;
                select2 = select2.pPrior;
                ++num2;
              }
              int num3 = db.aLimit[4];
              if (num3 != 0 && num2 > num3)
              {
                Sqlite3.sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
                goto label_112;
              }
            }
            int num4 = Sqlite3.multiSelect(pParse, p, pDest);
            Sqlite3.explainSetInteger(ref pParse.iSelectId, iSelectId);
            return num4;
          }
          if (((int) p.selFlags & 5) == 1)
          {
            p.pGroupBy = Sqlite3.sqlite3ExprListDup(db, p.pEList, 0);
            pGroupBy = p.pGroupBy;
            p.selFlags &= (ushort) 65534;
          }
          if (Sqlite3.sqlite3ExprListCompare(p.pGroupBy, ppOrderBy1) == 0 && (db.flags & 32) == 0)
            ppOrderBy1 = (Sqlite3.ExprList) null;
          int addr1;
          if (ppOrderBy1 != null)
          {
            Sqlite3.KeyInfo pP4 = Sqlite3.keyInfoFromExprList(pParse, ppOrderBy1);
            ppOrderBy1.iECursor = pParse.nTab++;
            p.addrOpenEphm[2] = addr1 = Sqlite3.sqlite3VdbeAddOp4(vdbe, 41, ppOrderBy1.iECursor, ppOrderBy1.nExpr + 2, 0, pP4, -16);
          }
          else
            addr1 = -1;
          if (pDest.eDest == (byte) 9)
            Sqlite3.sqlite3VdbeAddOp2(vdbe, 41, pDest.iParm, pElist.nExpr);
          int num5 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
          p.nSelectRow = (double) long.MaxValue;
          Sqlite3.computeLimitRegisters(pParse, p, num5);
          int num6;
          if (((int) p.selFlags & 1) != 0)
          {
            num6 = pParse.nTab++;
            Sqlite3.KeyInfo pP4 = Sqlite3.keyInfoFromExprList(pParse, p.pEList);
            Sqlite3.sqlite3VdbeAddOp4(vdbe, 41, num6, 0, 0, pP4, -16);
            Sqlite3.sqlite3VdbeChangeP5(vdbe, (byte) 16);
          }
          else
            num6 = -1;
          if (!isAgg && pGroupBy == null)
          {
            Sqlite3.WhereInfo pWInfo = Sqlite3.sqlite3WhereBegin(pParse, pSrc, pWhere, ref ppOrderBy1, (ushort) 0);
            if (pWInfo != null)
            {
              if (pWInfo.nRowOut < p.nSelectRow)
                p.nSelectRow = pWInfo.nRowOut;
              if (addr1 >= 0 && ppOrderBy1 == null)
              {
                Sqlite3.sqlite3VdbeChangeToNoop(vdbe, addr1, 1);
                p.addrOpenEphm[2] = -1;
              }
              Sqlite3.selectInnerLoop(pParse, p, pElist, 0, 0, ppOrderBy1, -1, pDest, pWInfo.iContinue, pWInfo.iBreak);
              Sqlite3.sqlite3WhereEnd(pWInfo);
            }
            else
              goto label_112;
          }
          else
          {
            if (pGroupBy != null)
            {
              for (int nExpr = p.pEList.nExpr; nExpr > 0; --nExpr)
                p.pEList.a[p.pEList.nExpr - nExpr].iAlias = (ushort) 0;
              for (int nExpr = pGroupBy.nExpr; nExpr > 0; --nExpr)
                pGroupBy.a[pGroupBy.nExpr - nExpr].iAlias = (ushort) 0;
              if (p.nSelectRow > 100.0)
                p.nSelectRow = 100.0;
            }
            else
              p.nSelectRow = 1.0;
            int num7 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
            Sqlite3.NameContext pNC = new Sqlite3.NameContext();
            pNC.pParse = pParse;
            pNC.pSrcList = pSrc;
            pNC.pAggInfo = pAggInfo;
            pAggInfo.nSortingColumn = pGroupBy != null ? pGroupBy.nExpr + 1 : 0;
            pAggInfo.pGroupBy = pGroupBy;
            Sqlite3.sqlite3ExprAnalyzeAggList(pNC, pElist);
            Sqlite3.sqlite3ExprAnalyzeAggList(pNC, ppOrderBy1);
            if (pHaving != null)
              Sqlite3.sqlite3ExprAnalyzeAggregates(pNC, ref pHaving);
            pAggInfo.nAccumulator = pAggInfo.nColumn;
            for (int index = 0; index < pAggInfo.nFunc; ++index)
              Sqlite3.sqlite3ExprAnalyzeAggList(pNC, pAggInfo.aFunc[index].pExpr.x.pList);
            if (pGroupBy != null)
            {
              pAggInfo.sortingIdx = pParse.nTab++;
              Sqlite3.KeyInfo pP4 = Sqlite3.keyInfoFromExprList(pParse, pGroupBy);
              int addr2 = Sqlite3.sqlite3VdbeAddOp4(vdbe, 41, pAggInfo.sortingIdx, pAggInfo.nSortingColumn, 0, pP4, -16);
              int num8 = ++pParse.nMem;
              int num9 = ++pParse.nMem;
              int p1_1 = ++pParse.nMem;
              int num10 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
              int p1_2 = ++pParse.nMem;
              int num11 = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
              int num12 = pParse.nMem + 1;
              pParse.nMem += pGroupBy.nExpr;
              int num13 = pParse.nMem + 1;
              pParse.nMem += pGroupBy.nExpr;
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num9);
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num8);
              Sqlite3.sqlite3VdbeAddOp2(vdbe, 2, p1_2, num11);
              Sqlite3.WhereInfo pWInfo = Sqlite3.sqlite3WhereBegin(pParse, pSrc, pWhere, ref pGroupBy, (ushort) 0);
              if (pWInfo != null)
              {
                int num14;
                if (pGroupBy == null)
                {
                  pGroupBy = p.pGroupBy;
                  num14 = 0;
                }
                else
                {
                  Sqlite3.explainTempTable(pParse, !flag || ((int) p.selFlags & 1) != 0 ? "GROUP BY" : "DISTINCT");
                  num14 = 1;
                  int nExpr = pGroupBy.nExpr;
                  int num15 = nExpr + 1;
                  int num16 = nExpr + 1;
                  for (int index = 0; index < pAggInfo.nColumn; ++index)
                  {
                    if (pAggInfo.aCol[index].iSorterColumn >= num16)
                    {
                      ++num15;
                      ++num16;
                    }
                  }
                  int tempRange = Sqlite3.sqlite3GetTempRange(pParse, num15);
                  Sqlite3.sqlite3ExprCacheClear(pParse);
                  Sqlite3.sqlite3ExprCodeExprList(pParse, pGroupBy, tempRange, false);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 53, pAggInfo.sortingIdx, tempRange + nExpr);
                  int num17 = nExpr + 1;
                  for (int index = 0; index < pAggInfo.nColumn; ++index)
                  {
                    Sqlite3.AggInfo_col aggInfoCol = pAggInfo.aCol[index];
                    if (aggInfoCol.iSorterColumn >= num17)
                    {
                      int num18 = num17 + tempRange;
                      int column = Sqlite3.sqlite3ExprCodeGetColumn(pParse, aggInfoCol.pTab, aggInfoCol.iColumn, aggInfoCol.iTable, num18);
                      if (num18 != column)
                        Sqlite3.sqlite3VdbeAddOp2(vdbe, 15, column, num18);
                      ++num17;
                    }
                  }
                  int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
                  Sqlite3.sqlite3VdbeAddOp3(vdbe, 30, tempRange, num15, tempReg);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 70, pAggInfo.sortingIdx, tempReg);
                  Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
                  Sqlite3.sqlite3ReleaseTempRange(pParse, tempRange, num15);
                  Sqlite3.sqlite3WhereEnd(pWInfo);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 64, pAggInfo.sortingIdx, num7);
                  pAggInfo.useSortingIdx = (byte) 1;
                  Sqlite3.sqlite3ExprCacheClear(pParse);
                }
                int p2_1 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                Sqlite3.sqlite3ExprCacheClear(pParse);
                for (int p2_2 = 0; p2_2 < pGroupBy.nExpr; ++p2_2)
                {
                  if (num14 != 0)
                  {
                    Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, pAggInfo.sortingIdx, p2_2, num13 + p2_2);
                  }
                  else
                  {
                    pAggInfo.directMode = (byte) 1;
                    Sqlite3.sqlite3ExprCode(pParse, pGroupBy.a[p2_2].pExpr, num13 + p2_2);
                  }
                }
                Sqlite3.sqlite3VdbeAddOp4(vdbe, 24, num12, num13, pGroupBy.nExpr, pP4, -6);
                int addr3 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                Sqlite3.sqlite3VdbeAddOp3(vdbe, 25, addr3 + 1, 0, addr3 + 1);
                Sqlite3.sqlite3ExprCodeMove(pParse, num13, num12, pGroupBy.nExpr);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 2, p1_1, num10);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 113, num9, num7);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 2, p1_2, num11);
                Sqlite3.sqlite3VdbeJumpHere(vdbe, addr3);
                Sqlite3.updateAccumulator(pParse, pAggInfo);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 1, num8);
                if (num14 != 0)
                {
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 67, pAggInfo.sortingIdx, p2_1);
                }
                else
                {
                  Sqlite3.sqlite3WhereEnd(pWInfo);
                  Sqlite3.sqlite3VdbeChangeToNoop(vdbe, addr2, 1);
                }
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 2, p1_1, num10);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, num7);
                int iBreak = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 1, num9);
                Sqlite3.VdbeComment(vdbe, "set abort flag");
                Sqlite3.sqlite3VdbeAddOp1(vdbe, 3, p1_1);
                Sqlite3.sqlite3VdbeResolveLabel(vdbe, num10);
                int num19 = Sqlite3.sqlite3VdbeCurrentAddr(vdbe);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 113, num8, num19 + 2);
                Sqlite3.VdbeComment(vdbe, "Groupby result generator entry point");
                Sqlite3.sqlite3VdbeAddOp1(vdbe, 3, p1_1);
                Sqlite3.finalizeAggFunctions(pParse, pAggInfo);
                Sqlite3.sqlite3ExprIfFalse(pParse, pHaving, num19 + 1, 8);
                Sqlite3.selectInnerLoop(pParse, p, p.pEList, 0, 0, ppOrderBy1, num6, pDest, num19 + 1, iBreak);
                Sqlite3.sqlite3VdbeAddOp1(vdbe, 3, p1_1);
                Sqlite3.VdbeComment(vdbe, "end groupby result generator");
                Sqlite3.sqlite3VdbeResolveLabel(vdbe, num11);
                Sqlite3.resetAccumulator(pParse, pAggInfo);
                Sqlite3.sqlite3VdbeAddOp1(vdbe, 3, p1_2);
              }
              else
                goto label_112;
            }
            else
            {
              Sqlite3.ExprList pList = (Sqlite3.ExprList) null;
              Sqlite3.Table pTab;
              if ((pTab = Sqlite3.isSimpleCount(p, pAggInfo)) != null)
              {
                int index1 = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTab.pSchema);
                int p1 = pParse.nTab++;
                Sqlite3.KeyInfo pKeyInfo = (Sqlite3.KeyInfo) null;
                Sqlite3.Index pIdx = (Sqlite3.Index) null;
                int tnum = pTab.tnum;
                Sqlite3.sqlite3CodeVerifySchema(pParse, index1);
                Sqlite3.sqlite3TableLock(pParse, index1, pTab.tnum, (byte) 0, pTab.zName);
                for (Sqlite3.Index index2 = pTab.pIndex; index2 != null; index2 = index2.pNext)
                {
                  if (index2.bUnordered == (byte) 0 && (pIdx == null || index2.nColumn < pIdx.nColumn))
                    pIdx = index2;
                }
                if (pIdx != null && pIdx.nColumn < pTab.nCol)
                {
                  tnum = pIdx.tnum;
                  pKeyInfo = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
                }
                Sqlite3.sqlite3VdbeAddOp3(vdbe, 38, p1, tnum, index1);
                if (pKeyInfo != null)
                  Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, pKeyInfo, -16);
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 31, p1, pAggInfo.aFunc[0].iMem);
                Sqlite3.sqlite3VdbeAddOp1(vdbe, 43, p1);
                Sqlite3.explainSimpleCount(pParse, pTab, pIdx);
              }
              else
              {
                Sqlite3.ExprList ppOrderBy2 = (Sqlite3.ExprList) null;
                int wctrlFlags = (int) Sqlite3.minMaxQuery(p);
                if (wctrlFlags != 0)
                {
                  ppOrderBy2 = Sqlite3.sqlite3ExprListDup(db, p.pEList.a[0].pExpr.x.pList, 0);
                  pList = ppOrderBy2;
                  if (ppOrderBy2 != null)
                  {
                    ppOrderBy2.a[0].sortOrder = wctrlFlags != 1 ? (byte) 1 : (byte) 0;
                    ppOrderBy2.a[0].pExpr.op = (byte) 152;
                  }
                }
                Sqlite3.resetAccumulator(pParse, pAggInfo);
                Sqlite3.WhereInfo pWInfo = Sqlite3.sqlite3WhereBegin(pParse, pSrc, pWhere, ref ppOrderBy2, (ushort) (byte) wctrlFlags);
                if (pWInfo == null)
                {
                  Sqlite3.sqlite3ExprListDelete(db, ref pList);
                  goto label_112;
                }
                else
                {
                  Sqlite3.updateAccumulator(pParse, pAggInfo);
                  if (ppOrderBy2 == null && wctrlFlags != 0)
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, pWInfo.iBreak);
                  Sqlite3.sqlite3WhereEnd(pWInfo);
                  Sqlite3.finalizeAggFunctions(pParse, pAggInfo);
                }
              }
              ppOrderBy1 = (Sqlite3.ExprList) null;
              Sqlite3.sqlite3ExprIfFalse(pParse, pHaving, num7, 8);
              Sqlite3.selectInnerLoop(pParse, p, p.pEList, 0, 0, (Sqlite3.ExprList) null, -1, pDest, num7, num7);
              Sqlite3.sqlite3ExprListDelete(db, ref pList);
            }
            Sqlite3.sqlite3VdbeResolveLabel(vdbe, num7);
          }
          if (num6 >= 0)
            Sqlite3.explainTempTable(pParse, "DISTINCT");
          if (ppOrderBy1 != null)
          {
            Sqlite3.explainTempTable(pParse, "ORDER BY");
            Sqlite3.generateSortTail(pParse, p, vdbe, pElist.nExpr, pDest);
          }
          Sqlite3.sqlite3VdbeResolveLabel(vdbe, num5);
          num1 = 0;
        }
      }
label_112:
      Sqlite3.explainSetInteger(ref pParse.iSelectId, iSelectId);
      if (num1 == 0 && pDest.eDest == (byte) 5)
        Sqlite3.generateColumnNames(pParse, pSrc, pElist);
      Sqlite3.sqlite3DbFree<Sqlite3.AggInfo_col[]>(db, ref pAggInfo.aCol);
      Sqlite3.sqlite3DbFree<Sqlite3.AggInfo_func[]>(db, ref pAggInfo.aFunc);
      return num1;
    }

    private static void testcase<T>(T X)
    {
    }

    private static bool ALWAYS(bool X) => X;

    private static byte ALWAYS(byte X) => X;

    private static int ALWAYS(int X) => X;

    private static bool ALWAYS<T>(T X) => true;

    private static bool NEVER(bool X) => X;

    private static byte NEVER(byte X) => X;

    private static int NEVER(int X) => X;

    private static bool NEVER<T>(T X) => false;

    private static bool IS_BIG_INT(long X) => (X & -4294967296L) != 0L;

    private static bool likely(bool X) => X;

    private static bool unlikely(bool X) => X;

    private static int ROUND8(int x) => x + 7 & -8;

    private static int ROUNDDOWN8(int x) => x & -8;

    private static string SCHEMA_TABLE(int x) => Sqlite3.OMIT_TEMPDB != 0 || x != 1 ? "sqlite_master" : "sqlite_temp_master";

    private static int ArraySize<T>(T[] x) => x.Length;

    private static void UNUSED_PARAMETER<T>(T x)
    {
    }

    private static void UNUSED_PARAMETER2<T1, T2>(T1 x, T2 y)
    {
      Sqlite3.UNUSED_PARAMETER<T1>(x);
      Sqlite3.UNUSED_PARAMETER<T2>(y);
    }

    private static bool DbHasProperty(Sqlite3.sqlite3 D, int I, ushort P) => ((int) D.aDb[I].pSchema.flags & (int) P) == (int) P;

    private static void DbSetProperty(Sqlite3.sqlite3 D, int I, ushort P) => D.aDb[I].pSchema.flags |= P;

    private static void DbClearProperty(Sqlite3.sqlite3 D, int I, ushort P) => D.aDb[I].pSchema.flags &= ~P;

    private static byte ENC(Sqlite3.sqlite3 db) => db.aDb[0].pSchema.enc;

    private static Sqlite3.FuncDef FUNCTION(
      string zName,
      short nArg,
      int iArg,
      byte bNC,
      Sqlite3.dxFunc xFunc)
    {
      return new Sqlite3.FuncDef(zName, (byte) 1, nArg, iArg, (byte) ((uint) bNC * 8U), xFunc);
    }

    private static Sqlite3.FuncDef LIKEFUNC(
      string zName,
      short nArg,
      object arg,
      byte flags)
    {
      return new Sqlite3.FuncDef(zName, (byte) 1, nArg, arg, new Sqlite3.dxFunc(Sqlite3.likeFunc), flags);
    }

    private static Sqlite3.FuncDef AGGREGATE(
      string zName,
      short nArg,
      int arg,
      byte nc,
      Sqlite3.dxStep xStep,
      Sqlite3.dxFinal xFinal)
    {
      return new Sqlite3.FuncDef(zName, (byte) 1, nArg, arg, (byte) ((uint) nc * 8U), xStep, xFinal);
    }

    private static bool IsVirtual(Sqlite3.Table T) => false;

    private static bool IsHiddenColumn(Sqlite3.Column C) => false;

    private static void ExprSetIrreducible(Sqlite3.Expr X)
    {
    }

    private static bool ExprHasProperty(Sqlite3.Expr E, int P) => ((int) E.flags & P) == P;

    private static bool ExprHasAnyProperty(Sqlite3.Expr E, int P) => ((uint) E.flags & (uint) P) > 0U;

    private static void ExprSetProperty(Sqlite3.Expr E, int P) => E.flags |= (ushort) P;

    private static void ExprClearProperty(Sqlite3.Expr E, int P) => E.flags &= (ushort) ~P;

    private static bool IN_DECLARE_VTAB(Sqlite3.Parse pParse) => false;

    private static void SQLITE_SKIP_UTF8(string zIn, ref int iz)
    {
      ++iz;
      if (iz >= zIn.Length || zIn[iz - 1] < 'À')
        return;
      while (iz < zIn.Length && ((int) zIn[iz] & 192) == 128)
        ++iz;
    }

    private static void SQLITE_SKIP_UTF8(byte[] zIn, ref int iz)
    {
      ++iz;
      if (iz >= zIn.Length || zIn[iz - 1] < (byte) 192)
        return;
      while (iz < zIn.Length && ((int) zIn[iz] & 192) == 128)
        ++iz;
    }

    private static int SQLITE_CORRUPT_BKPT() => 11;

    private static int SQLITE_MISUSE_BKPT() => 21;

    private static int SQLITE_CANTOPEN_BKPT() => 14;

    private static bool sqlite3Isspace(byte x) => ((uint) Sqlite3.sqlite3CtypeMap[(int) x] & 1U) > 0U;

    private static bool sqlite3Isspace(char x) => x < 'Ā' && ((uint) Sqlite3.sqlite3CtypeMap[(int) (byte) x] & 1U) > 0U;

    private static bool sqlite3Isalnum(byte x) => ((uint) Sqlite3.sqlite3CtypeMap[(int) x] & 6U) > 0U;

    private static bool sqlite3Isalnum(char x) => x < 'Ā' && ((uint) Sqlite3.sqlite3CtypeMap[(int) (byte) x] & 6U) > 0U;

    private static bool sqlite3Isdigit(byte x) => ((uint) Sqlite3.sqlite3CtypeMap[(int) x] & 4U) > 0U;

    private static bool sqlite3Isdigit(char x) => x < 'Ā' && ((uint) Sqlite3.sqlite3CtypeMap[(int) (byte) x] & 4U) > 0U;

    private static bool sqlite3Isxdigit(byte x) => ((uint) Sqlite3.sqlite3CtypeMap[(int) x] & 8U) > 0U;

    private static bool sqlite3Isxdigit(char x) => x < 'Ā' && ((uint) Sqlite3.sqlite3CtypeMap[(int) (byte) x] & 8U) > 0U;

    private static Sqlite3.Parse sqlite3ParseToplevel(Sqlite3.Parse p) => p.pToplevel == null ? p : p.pToplevel;

    private static void sqlite3AuthRead(
      Sqlite3.Parse a,
      Sqlite3.Expr b,
      Sqlite3.Schema c,
      Sqlite3.SrcList d)
    {
    }

    private static int sqlite3AuthCheck(Sqlite3.Parse a, int b, string c, byte[] d, byte[] e) => 0;

    private static void sqlite3AuthContextPush(Sqlite3.Parse a, Sqlite3.AuthContext b, string c)
    {
    }

    private static Sqlite3.Parse sqlite3AuthContextPop(Sqlite3.Parse a) => a;

    private static void sqlite3FileSuffix3(string X, string Y)
    {
    }

    private static void sqlite3TableLock(Sqlite3.Parse p, int p1, int p2, byte p3, byte[] p4)
    {
    }

    private static void sqlite3TableLock(Sqlite3.Parse p, int p1, int p2, byte p3, string p4)
    {
    }

    private static void sqlite3VtabClear(Sqlite3.sqlite3 db, Sqlite3.Table Y)
    {
    }

    private static int sqlite3VtabSync(Sqlite3.sqlite3 X, ref string Y) => 0;

    private static void sqlite3VtabRollback(Sqlite3.sqlite3 X)
    {
    }

    private static void sqlite3VtabCommit(Sqlite3.sqlite3 X)
    {
    }

    private static void sqlite3VtabLock(Sqlite3.VTable X)
    {
    }

    private static void sqlite3VtabUnlock(Sqlite3.VTable X)
    {
    }

    private static void sqlite3VtabUnlockList(Sqlite3.sqlite3 X)
    {
    }

    private static int sqlite3VtabSavepoint(Sqlite3.sqlite3 X, int Y, int Z) => 0;

    private static bool sqlite3VtabInSync(Sqlite3.sqlite3 db) => false;

    private static void sqlite3VtabArgExtend(Sqlite3.Parse P, Sqlite3.Token T)
    {
    }

    private static void sqlite3VtabArgInit(Sqlite3.Parse P)
    {
    }

    private static void sqlite3VtabBeginParse(
      Sqlite3.Parse P,
      Sqlite3.Token T,
      Sqlite3.Token T1,
      Sqlite3.Token T2)
    {
    }

    private static void sqlite3VtabFinishParse<T>(Sqlite3.Parse P, T t)
    {
    }

    private static Sqlite3.VTable sqlite3GetVTable(Sqlite3.sqlite3 db, Sqlite3.Table T) => (Sqlite3.VTable) null;

    private static int sqlite3JournalSize(Sqlite3.sqlite3_vfs pVfs) => pVfs.szOsFile;

    private static void sqlite3ConnectionBlocked(Sqlite3.sqlite3 x, Sqlite3.sqlite3 y)
    {
    }

    private static void sqlite3ConnectionUnlocked(Sqlite3.sqlite3 x)
    {
    }

    private static void sqlite3ConnectionClosed(Sqlite3.sqlite3 x)
    {
    }

    private static void IOTRACE(string F, params object[] ap)
    {
    }

    private static void sqlite3VdbeIOTraceSql(Sqlite3.Vdbe X)
    {
    }

    private static void sqlite3MemdebugSetType<T>(T X, int Y)
    {
    }

    private static bool sqlite3MemdebugHasType<T>(T X, int Y) => true;

    private static bool sqlite3MemdebugNoType<T>(T X, int Y) => true;

    private static void wsdStatInit()
    {
    }

    private static int sqlite3StatusValue(int op)
    {
      Sqlite3.wsdStatInit();
      return Sqlite3.wsdStat.nowValue[op];
    }

    private static void sqlite3StatusAdd(int op, int N)
    {
      Sqlite3.wsdStatInit();
      Sqlite3.wsdStat.nowValue[op] += N;
      if (Sqlite3.wsdStat.nowValue[op] <= Sqlite3.wsdStat.mxValue[op])
        return;
      Sqlite3.wsdStat.mxValue[op] = Sqlite3.wsdStat.nowValue[op];
    }

    private static void sqlite3StatusSet(int op, int X)
    {
      Sqlite3.wsdStatInit();
      Sqlite3.wsdStat.nowValue[op] = X;
      if (Sqlite3.wsdStat.nowValue[op] <= Sqlite3.wsdStat.mxValue[op])
        return;
      Sqlite3.wsdStat.mxValue[op] = Sqlite3.wsdStat.nowValue[op];
    }

    private static int sqlite3_status(int op, ref int pCurrent, ref int pHighwater, int resetFlag)
    {
      Sqlite3.wsdStatInit();
      if (op < 0 || op >= Sqlite3.ArraySize<int>(Sqlite3.wsdStat.nowValue))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      pCurrent = Sqlite3.wsdStat.nowValue[op];
      pHighwater = Sqlite3.wsdStat.mxValue[op];
      if (resetFlag != 0)
        Sqlite3.wsdStat.mxValue[op] = Sqlite3.wsdStat.nowValue[op];
      return 0;
    }

    private static int sqlite3_db_status(
      Sqlite3.sqlite3 db,
      int op,
      ref int pCurrent,
      ref int pHighwater,
      int resetFlag)
    {
      int num1 = 0;
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      switch (op)
      {
        case 0:
          pCurrent = db.lookaside.nOut;
          pHighwater = db.lookaside.mxOut;
          if (resetFlag != 0)
          {
            db.lookaside.mxOut = db.lookaside.nOut;
            break;
          }
          break;
        case 1:
          int num2 = 0;
          Sqlite3.sqlite3BtreeEnterAll(db);
          for (int index = 0; index < db.nDb; ++index)
          {
            Sqlite3.Btree pBt = db.aDb[index].pBt;
            if (pBt != null)
            {
              Sqlite3.Pager pPager = Sqlite3.sqlite3BtreePager(pBt);
              num2 += Sqlite3.sqlite3PagerMemUsed(pPager);
            }
          }
          Sqlite3.sqlite3BtreeLeaveAll(db);
          pCurrent = num2;
          pHighwater = 0;
          break;
        case 2:
          int num3 = 0;
          Sqlite3.sqlite3BtreeEnterAll(db);
          for (int index = 0; index < db.nDb; ++index)
          {
            Sqlite3.Schema pSchema = db.aDb[index].pSchema;
            if (Sqlite3.ALWAYS(pSchema != null))
            {
              for (Sqlite3.HashElem E = Sqlite3.sqliteHashFirst(pSchema.trigHash); E != null; E = Sqlite3.sqliteHashNext(E))
              {
                Sqlite3.Trigger pTrigger = (Sqlite3.Trigger) Sqlite3.sqliteHashData(E);
                Sqlite3.sqlite3DeleteTrigger(db, ref pTrigger);
              }
              for (Sqlite3.HashElem E = Sqlite3.sqliteHashFirst(pSchema.tblHash); E != null; E = Sqlite3.sqliteHashNext(E))
              {
                Sqlite3.Table pTable = (Sqlite3.Table) Sqlite3.sqliteHashData(E);
                Sqlite3.sqlite3DeleteTable(db, ref pTable);
              }
            }
          }
          db.pnBytesFreed = 0;
          Sqlite3.sqlite3BtreeLeaveAll(db);
          pHighwater = 0;
          pCurrent = num3;
          break;
        case 3:
          int num4 = 0;
          for (Sqlite3.Vdbe p = db.pVdbe; p != null; p = p.pNext)
            Sqlite3.sqlite3VdbeDeleteObject(db, ref p);
          db.pnBytesFreed = 0;
          pHighwater = 0;
          pCurrent = num4;
          break;
        case 4:
        case 5:
        case 6:
          Sqlite3.testcase<bool>(op == 4);
          Sqlite3.testcase<bool>(op == 5);
          Sqlite3.testcase<bool>(op == 6);
          pCurrent = 0;
          pHighwater = db.lookaside.anStat[op - 4];
          if (resetFlag != 0)
          {
            db.lookaside.anStat[op - 4] = 0;
            break;
          }
          break;
        default:
          num1 = 1;
          break;
      }
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num1;
    }

    private static int sqlite3GetToken(string z, int iOffset, ref int tokenType)
    {
      byte num1 = 0;
      switch (z[iOffset])
      {
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case ' ':
          Sqlite3.testcase<bool>(z[iOffset] == ' ');
          Sqlite3.testcase<bool>(z[iOffset] == '\t');
          Sqlite3.testcase<bool>(z[iOffset] == '\n');
          Sqlite3.testcase<bool>(z[iOffset] == '\f');
          Sqlite3.testcase<bool>(z[iOffset] == '\r');
          int token1 = 1;
          while (z.Length > iOffset + token1 && Sqlite3.sqlite3Isspace(z[iOffset + token1]))
            ++token1;
          tokenType = 149;
          return token1;
        case '!':
          if (z[iOffset + 1] != '=')
          {
            tokenType = 148;
            return 2;
          }
          tokenType = 75;
          return 2;
        case '"':
        case '\'':
        case '`':
          int num2 = (int) z[iOffset];
          Sqlite3.testcase<bool>(num2 == 96);
          Sqlite3.testcase<bool>(num2 == 39);
          Sqlite3.testcase<bool>(num2 == 34);
          int token2;
          for (token2 = 1; iOffset + token2 < z.Length && (num1 = (byte) z[iOffset + token2]) != (byte) 0; ++token2)
          {
            if ((int) num1 == num2)
            {
              if (z.Length > iOffset + token2 + 1 && (int) z[iOffset + token2 + 1] == num2)
                ++token2;
              else
                break;
            }
          }
          if (iOffset + token2 == z.Length && (int) num1 != num2 || (int) z[iOffset + token2] != num2)
          {
            tokenType = 148;
            return token2 + 1;
          }
          if (num1 == (byte) 39)
          {
            tokenType = 94;
            return token2 + 1;
          }
          if (num1 != (byte) 0)
          {
            tokenType = 26;
            return token2 + 1;
          }
          tokenType = 148;
          return token2;
        case '#':
          int token3 = 1;
          while (z.Length > iOffset + token3 && Sqlite3.sqlite3Isdigit(z[iOffset + token3]))
            ++token3;
          if (token3 > 1)
          {
            tokenType = 132;
            return token3;
          }
          goto case '$';
        case '$':
        case ':':
        case '@':
          int num3 = 0;
          Sqlite3.testcase<bool>(z[iOffset] == '$');
          Sqlite3.testcase<bool>(z[iOffset] == '@');
          Sqlite3.testcase<bool>(z[iOffset] == ':');
          tokenType = 133;
          int token4;
          byte num4;
          for (token4 = 1; z.Length > iOffset + token4 && (num4 = (byte) z[iOffset + token4]) != (byte) 0; ++token4)
          {
            if (Sqlite3.IdChar(num4))
            {
              ++num3;
            }
            else
            {
              if (num4 == (byte) 40 && num3 > 0)
              {
                do
                {
                  ++token4;
                }
                while (iOffset + token4 < z.Length && (num4 = (byte) z[iOffset + token4]) != (byte) 0 && !Sqlite3.sqlite3Isspace(num4) && num4 != (byte) 41);
                if (num4 == (byte) 41)
                {
                  ++token4;
                  break;
                }
                tokenType = 148;
                break;
              }
              if (num4 == (byte) 58 && z[iOffset + token4 + 1] == ':')
                ++token4;
              else
                break;
            }
          }
          if (num3 == 0)
            tokenType = 148;
          return token4;
        case '%':
          tokenType = 90;
          return 1;
        case '&':
          tokenType = 82;
          return 1;
        case '(':
          tokenType = 22;
          return 1;
        case ')':
          tokenType = 23;
          return 1;
        case '*':
          tokenType = 88;
          return 1;
        case '+':
          tokenType = 86;
          return 1;
        case ',':
          tokenType = 25;
          return 1;
        case '-':
          if (z.Length > iOffset + 1 && z[iOffset + 1] == '-')
          {
            int token5 = 2;
            byte num5;
            while (z.Length > iOffset + token5 && (num5 = (byte) z[iOffset + token5]) != (byte) 0 && num5 != (byte) 10)
              ++token5;
            tokenType = 149;
            return token5;
          }
          tokenType = 87;
          return 1;
        case '.':
          if (!Sqlite3.sqlite3Isdigit(z[iOffset + 1]))
          {
            tokenType = 118;
            return 1;
          }
          goto case '0';
        case '/':
          if (iOffset + 2 >= z.Length || z[iOffset + 1] != '*')
          {
            tokenType = 89;
            return 1;
          }
          int token6 = 3;
          byte num6;
          for (num6 = (byte) z[iOffset + 2]; iOffset + token6 < z.Length && (num6 != (byte) 42 || z[iOffset + token6] != '/' && num6 != (byte) 0); ++token6)
            num6 = (byte) z[iOffset + token6];
          if (iOffset + token6 == z.Length)
            num6 = (byte) 0;
          if (num6 != (byte) 0)
            ++token6;
          tokenType = 149;
          return token6;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          Sqlite3.testcase<bool>(z[iOffset] == '0');
          Sqlite3.testcase<bool>(z[iOffset] == '1');
          Sqlite3.testcase<bool>(z[iOffset] == '2');
          Sqlite3.testcase<bool>(z[iOffset] == '3');
          Sqlite3.testcase<bool>(z[iOffset] == '4');
          Sqlite3.testcase<bool>(z[iOffset] == '5');
          Sqlite3.testcase<bool>(z[iOffset] == '6');
          Sqlite3.testcase<bool>(z[iOffset] == '7');
          Sqlite3.testcase<bool>(z[iOffset] == '8');
          Sqlite3.testcase<bool>(z[iOffset] == '9');
          tokenType = 129;
          int token7 = 0;
          while (z.Length > iOffset + token7 && Sqlite3.sqlite3Isdigit(z[iOffset + token7]))
            ++token7;
          if (z.Length > iOffset + token7 && z[iOffset + token7] == '.')
          {
            ++token7;
            while (z.Length > iOffset + token7 && Sqlite3.sqlite3Isdigit(z[iOffset + token7]))
              ++token7;
            tokenType = 130;
          }
          if (z.Length > iOffset + token7 + 1 && (z[iOffset + token7] == 'e' || z[iOffset + token7] == 'E') && (Sqlite3.sqlite3Isdigit(z[iOffset + token7 + 1]) || z.Length > iOffset + token7 + 2 && (z[iOffset + token7 + 1] == '+' || z[iOffset + token7 + 1] == '-') && Sqlite3.sqlite3Isdigit(z[iOffset + token7 + 2])))
          {
            token7 += 2;
            while (z.Length > iOffset + token7 && Sqlite3.sqlite3Isdigit(z[iOffset + token7]))
              ++token7;
            tokenType = 130;
          }
          for (; iOffset + token7 < z.Length && Sqlite3.IdChar((byte) z[iOffset + token7]); ++token7)
            tokenType = 148;
          return token7;
        case ';':
          tokenType = 1;
          return 1;
        case '<':
          byte num7;
          if ((num7 = (byte) z[iOffset + 1]) == (byte) 61)
          {
            tokenType = 78;
            return 2;
          }
          if (num7 == (byte) 62)
          {
            tokenType = 75;
            return 2;
          }
          if (num7 == (byte) 60)
          {
            tokenType = 84;
            return 2;
          }
          tokenType = 79;
          return 1;
        case '=':
          tokenType = 76;
          return 1 + (z[iOffset + 1] == '=' ? 1 : 0);
        case '>':
          if (z.Length > iOffset + 1 && (num1 = (byte) z[iOffset + 1]) == (byte) 61)
          {
            tokenType = 80;
            return 2;
          }
          if (num1 == (byte) 62)
          {
            tokenType = 85;
            return 2;
          }
          tokenType = 77;
          return 1;
        case '?':
          tokenType = 133;
          int token8 = 1;
          while (z.Length > iOffset + token8 && Sqlite3.sqlite3Isdigit(z[iOffset + token8]))
            ++token8;
          return token8;
        case 'X':
        case 'x':
          Sqlite3.testcase<bool>(z[iOffset] == 'x');
          Sqlite3.testcase<bool>(z[iOffset] == 'X');
          if (z.Length > iOffset + 1 && z[iOffset + 1] == '\'')
          {
            tokenType = 131;
            int token9 = 2;
            while (z.Length > iOffset + token9 && Sqlite3.sqlite3Isxdigit(z[iOffset + token9]))
              ++token9;
            if (iOffset + token9 == z.Length || z[iOffset + token9] != '\'' || token9 % 2 != 0)
            {
              tokenType = 148;
              while (z.Length > iOffset + token9 && z[iOffset + token9] != '\'')
                ++token9;
            }
            if (z.Length > iOffset + token9)
              ++token9;
            return token9;
          }
          break;
        case '[':
          int token10 = 1;
          byte num8 = (byte) z[iOffset];
          while (num8 != (byte) 93 && iOffset + token10 < z.Length && (num8 = (byte) z[iOffset + token10]) != (byte) 0)
            ++token10;
          tokenType = num8 == (byte) 93 ? 26 : 148;
          return token10;
        case '|':
          if (z[iOffset + 1] != '|')
          {
            tokenType = 83;
            return 1;
          }
          tokenType = 91;
          return 2;
        case '~':
          tokenType = 93;
          return 1;
      }
      if (Sqlite3.IdChar((byte) z[iOffset]))
      {
        int n = 1;
        while (n < z.Length - iOffset && Sqlite3.IdChar((byte) z[iOffset + n]))
          ++n;
        tokenType = Sqlite3.keywordCode(z, iOffset, n);
        return n;
      }
      tokenType = 148;
      return 1;
    }

    private static int sqlite3RunParser(Sqlite3.Parse pParse, string zSql, ref string pzErrMsg)
    {
      int num1 = 0;
      int tokenType = 0;
      int num2 = -1;
      Sqlite3.sqlite3 db = pParse.db;
      int num3 = db.aLimit[1];
      if (db.activeVdbeCnt == 0)
        db.u1.isInterrupted = false;
      pParse.rc = 0;
      pParse.zTail = new StringBuilder(zSql);
      int num4 = 0;
      Sqlite3.yyParser yyParser = Sqlite3.sqlite3ParserAlloc();
      byte bEnabled = db.lookaside.bEnabled;
      if (db.lookaside.pStart != 0)
        db.lookaside.bEnabled = (byte) 1;
      while (num4 < zSql.Length)
      {
        pParse.sLastToken.n = Sqlite3.sqlite3GetToken(zSql, num4, ref tokenType);
        pParse.sLastToken.z = zSql.Substring(num4);
        num4 += pParse.sLastToken.n;
        if (num4 > num3)
        {
          pParse.rc = 18;
          break;
        }
        switch (tokenType)
        {
          case 148:
            Sqlite3.sqlite3DbFree(db, ref pzErrMsg);
            pzErrMsg = Sqlite3.sqlite3MPrintf(db, "unrecognized token: \"%T\"", (object) pParse.sLastToken);
            ++num1;
            goto label_12;
          case 149:
            if (db.u1.isInterrupted)
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "interrupt");
              pParse.rc = 9;
              goto label_12;
            }
            else
              continue;
          default:
            Sqlite3.sqlite3Parser(yyParser, tokenType, pParse.sLastToken, pParse);
            num2 = tokenType;
            if (pParse.rc != 0)
              goto label_12;
            else
              continue;
        }
      }
label_12:
      pParse.zTail = new StringBuilder(zSql.Length <= num4 ? "" : zSql.Substring(num4, zSql.Length - num4));
      if (zSql.Length >= num4 && num1 == 0 && pParse.rc == 0)
      {
        if (num2 != 1)
          Sqlite3.sqlite3Parser(yyParser, 1, pParse.sLastToken, pParse);
        Sqlite3.sqlite3Parser(yyParser, 0, pParse.sLastToken, pParse);
      }
      Sqlite3.sqlite3ParserFree(yyParser, (Sqlite3.dxDel) null);
      db.lookaside.bEnabled = bEnabled;
      if (pParse.rc != 0 && pParse.rc != 101 && pParse.zErrMsg == "")
        Sqlite3.sqlite3SetString(ref pParse.zErrMsg, db, Sqlite3.sqlite3ErrStr(pParse.rc));
      if (pParse.zErrMsg != null)
      {
        pzErrMsg = pParse.zErrMsg;
        Sqlite3.sqlite3_log(pParse.rc, "%s", (object) pzErrMsg);
        pParse.zErrMsg = "";
        ++num1;
      }
      if (pParse.pVdbe != null && pParse.nErr > 0 && pParse.nested == (byte) 0)
      {
        Sqlite3.sqlite3VdbeDelete(ref pParse.pVdbe);
        pParse.pVdbe = (Sqlite3.Vdbe) null;
      }
      if (!Sqlite3.IN_DECLARE_VTAB(pParse))
        Sqlite3.sqlite3DeleteTable(db, ref pParse.pNewTable);
      Sqlite3.sqlite3DeleteTrigger(db, ref pParse.pNewTrigger);
      Sqlite3.sqlite3DbFree<string[]>(db, ref pParse.azVar);
      Sqlite3.sqlite3DbFree(db, ref pParse.aAlias);
      while (pParse.pAinc != null)
      {
        Sqlite3.AutoincInfo pAinc = pParse.pAinc;
        pParse.pAinc = pAinc.pNext;
        Sqlite3.sqlite3DbFree<Sqlite3.AutoincInfo>(db, ref pAinc);
      }
      while (pParse.pZombieTab != null)
      {
        Sqlite3.Table pZombieTab = pParse.pZombieTab;
        pParse.pZombieTab = pZombieTab.pNextZombie;
        Sqlite3.sqlite3DeleteTable(db, ref pZombieTab);
      }
      if (num1 > 0 && pParse.rc == 0)
        pParse.rc = 1;
      return num1;
    }

    private static void sqlite3DeleteTriggerStep(
      Sqlite3.sqlite3 db,
      ref Sqlite3.TriggerStep pTriggerStep)
    {
      while (pTriggerStep != null)
      {
        Sqlite3.TriggerStep pT = pTriggerStep;
        pTriggerStep = pTriggerStep.pNext;
        Sqlite3.sqlite3ExprDelete(db, ref pT.pWhere);
        Sqlite3.sqlite3ExprListDelete(db, ref pT.pExprList);
        Sqlite3.sqlite3SelectDelete(db, ref pT.pSelect);
        Sqlite3.sqlite3IdListDelete(db, ref pT.pIdList);
        pTriggerStep = (Sqlite3.TriggerStep) null;
        Sqlite3.sqlite3DbFree<Sqlite3.TriggerStep>(db, ref pT);
      }
    }

    private static Sqlite3.Trigger sqlite3TriggerList(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab)
    {
      Sqlite3.Schema pSchema = pParse.db.aDb[1].pSchema;
      Sqlite3.Trigger trigger1 = (Sqlite3.Trigger) null;
      if (pParse.disableTriggers != (byte) 0)
        return (Sqlite3.Trigger) null;
      if (pSchema != pTab.pSchema)
      {
        for (Sqlite3.HashElem E = Sqlite3.sqliteHashFirst(pSchema.trigHash); E != null; E = Sqlite3.sqliteHashNext(E))
        {
          Sqlite3.Trigger trigger2 = (Sqlite3.Trigger) Sqlite3.sqliteHashData(E);
          if (trigger2.pTabSchema == pTab.pSchema && trigger2.table.Equals(pTab.zName, StringComparison.InvariantCultureIgnoreCase))
          {
            trigger2.pNext = trigger1 ?? pTab.pTrigger;
            trigger1 = trigger2;
          }
        }
      }
      return trigger1 ?? pTab.pTrigger;
    }

    private static void sqlite3BeginTrigger(
      Sqlite3.Parse pParse,
      Sqlite3.Token pName1,
      Sqlite3.Token pName2,
      int tr_tm,
      int op,
      Sqlite3.IdList pColumns,
      Sqlite3.SrcList pTableName,
      Sqlite3.Expr pWhen,
      int isTemp,
      int noErr)
    {
      Sqlite3.Trigger pTrigger = (Sqlite3.Trigger) null;
      string pString = (string) null;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Token pUnqual = (Sqlite3.Token) null;
      Sqlite3.DbFixer pFix = new Sqlite3.DbFixer();
      int iDb;
      if (isTemp != 0)
      {
        if (pName2.n > 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
          goto label_32;
        }
        else
        {
          iDb = 1;
          pUnqual = pName1;
        }
      }
      else
      {
        iDb = Sqlite3.sqlite3TwoPartName(pParse, pName1, pName2, ref pUnqual);
        if (iDb < 0)
          goto label_32;
      }
      if (pTableName != null)
      {
        if (db.init.busy != (byte) 0 && iDb != 1)
          pTableName.a[0].zDatabase = (string) null;
        if (pTableName != null)
        {
          Sqlite3.Table table = Sqlite3.sqlite3SrcListLookup(pParse, pTableName);
          if (db.init.busy == (byte) 0 && pName2.n == 0 && table != null && table.pSchema == db.aDb[1].pSchema)
            iDb = 1;
          if (Sqlite3.sqlite3FixInit(pFix, pParse, iDb, "trigger", pUnqual) == 0 || Sqlite3.sqlite3FixSrcList(pFix, pTableName) == 0)
          {
            Sqlite3.Table T = Sqlite3.sqlite3SrcListLookup(pParse, pTableName);
            if (T == null)
            {
              if (db.init.iDb == 1)
                db.init.orphanTrigger = (byte) 1;
            }
            else if (Sqlite3.IsVirtual(T))
            {
              Sqlite3.sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
            }
            else
            {
              pString = Sqlite3.sqlite3NameFromToken(db, pUnqual);
              if (pString != null && Sqlite3.sqlite3CheckObjectName(pParse, pString) == 0)
              {
                if (Sqlite3.sqlite3HashFind<Sqlite3.Trigger>(db.aDb[iDb].pSchema.trigHash, pString, Sqlite3.sqlite3Strlen30(pString), (Sqlite3.Trigger) null) != null)
                {
                  if (noErr == 0)
                    Sqlite3.sqlite3ErrorMsg(pParse, "trigger %T already exists", (object) pUnqual);
                  else
                    Sqlite3.sqlite3CodeVerifySchema(pParse, iDb);
                }
                else if (T.zName.StartsWith("sqlite_", StringComparison.InvariantCultureIgnoreCase))
                {
                  Sqlite3.sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
                  ++pParse.nErr;
                }
                else if (T.pSelect != null && tr_tm != 48)
                  Sqlite3.sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S", tr_tm == 34 ? (object) "BEFORE" : (object) "AFTER", (object) pTableName, (object) 0);
                else if (T.pSelect == null && tr_tm == 48)
                {
                  Sqlite3.sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF trigger on table: %S", (object) pTableName, (object) 0);
                }
                else
                {
                  Sqlite3.sqlite3SchemaToIndex(db, T.pSchema);
                  if (tr_tm == 48)
                    tr_tm = 34;
                  pTrigger = new Sqlite3.Trigger();
                  if (pTrigger != null)
                  {
                    pTrigger.zName = pString;
                    pTrigger.table = pTableName.a[0].zName;
                    pTrigger.pSchema = db.aDb[iDb].pSchema;
                    pTrigger.pTabSchema = T.pSchema;
                    pTrigger.op = (byte) op;
                    pTrigger.tr_tm = tr_tm == 34 ? (byte) 1 : (byte) 2;
                    pTrigger.pWhen = Sqlite3.sqlite3ExprDup(db, pWhen, 1);
                    pTrigger.pColumns = Sqlite3.sqlite3IdListDup(db, pColumns);
                    pParse.pNewTrigger = pTrigger;
                  }
                }
              }
            }
          }
        }
      }
label_32:
      Sqlite3.sqlite3DbFree(db, ref pString);
      Sqlite3.sqlite3SrcListDelete(db, ref pTableName);
      Sqlite3.sqlite3IdListDelete(db, ref pColumns);
      Sqlite3.sqlite3ExprDelete(db, ref pWhen);
      if (pParse.pNewTrigger != null)
        return;
      Sqlite3.sqlite3DeleteTrigger(db, ref pTrigger);
    }

    private static void sqlite3FinishTrigger(
      Sqlite3.Parse pParse,
      Sqlite3.TriggerStep pStepList,
      Sqlite3.Token pAll)
    {
      Sqlite3.Trigger pTrigger = pParse.pNewTrigger;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.DbFixer pFix = new Sqlite3.DbFixer();
      Sqlite3.Token pName = new Sqlite3.Token();
      pParse.pNewTrigger = (Sqlite3.Trigger) null;
      if (!Sqlite3.NEVER(pParse.nErr != 0) && pTrigger != null)
      {
        string zName = pTrigger.zName;
        int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTrigger.pSchema);
        pTrigger.step_list = pStepList;
        for (; pStepList != null; pStepList = pStepList.pNext)
          pStepList.pTrig = pTrigger;
        pName.z = pTrigger.zName;
        pName.n = Sqlite3.sqlite3Strlen30(pName.z);
        if (Sqlite3.sqlite3FixInit(pFix, pParse, index, "trigger", pName) == 0 || Sqlite3.sqlite3FixTriggerStep(pFix, pTrigger.step_list) == 0)
        {
          if (db.init.busy == (byte) 0)
          {
            Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
            if (vdbe != null)
            {
              Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index);
              string pString = pAll.z.Substring(0, pAll.n);
              Sqlite3.sqlite3NestedParse(pParse, "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')", (object) db.aDb[index].zName, (object) Sqlite3.SCHEMA_TABLE(index), (object) zName, (object) pTrigger.table, (object) pString);
              Sqlite3.sqlite3DbFree(db, ref pString);
              Sqlite3.sqlite3ChangeCookie(pParse, index);
              Sqlite3.sqlite3VdbeAddParseSchemaOp(vdbe, index, Sqlite3.sqlite3MPrintf(db, "type='trigger' AND name='%q'", (object) zName));
            }
            else
              goto label_11;
          }
          if (db.init.busy != (byte) 0)
          {
            Sqlite3.Trigger trigger = pTrigger;
            Sqlite3.Hash trigHash = db.aDb[index].pSchema.trigHash;
            pTrigger = Sqlite3.sqlite3HashInsert<Sqlite3.Trigger>(ref trigHash, zName, Sqlite3.sqlite3Strlen30(zName), pTrigger);
            if (pTrigger == null && trigger.pSchema == trigger.pTabSchema)
            {
              int nKey = Sqlite3.sqlite3Strlen30(trigger.table);
              Sqlite3.Table table = Sqlite3.sqlite3HashFind<Sqlite3.Table>(trigger.pTabSchema.tblHash, trigger.table, nKey, (Sqlite3.Table) null);
              trigger.pNext = table.pTrigger;
              table.pTrigger = trigger;
            }
          }
        }
      }
label_11:
      Sqlite3.sqlite3DeleteTrigger(db, ref pTrigger);
      Sqlite3.sqlite3DeleteTriggerStep(db, ref pStepList);
    }

    private static Sqlite3.TriggerStep sqlite3TriggerSelectStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Select pSelect)
    {
      Sqlite3.TriggerStep triggerStep = new Sqlite3.TriggerStep();
      if (triggerStep == null)
      {
        Sqlite3.sqlite3SelectDelete(db, ref pSelect);
        return (Sqlite3.TriggerStep) null;
      }
      triggerStep.op = (byte) 116;
      triggerStep.pSelect = pSelect;
      triggerStep.orconf = (byte) 99;
      return triggerStep;
    }

    private static Sqlite3.TriggerStep triggerStepAllocate(
      Sqlite3.sqlite3 db,
      byte op,
      Sqlite3.Token pName)
    {
      return new Sqlite3.TriggerStep()
      {
        target = {
          z = pName.z,
          n = pName.n
        },
        op = op
      };
    }

    private static Sqlite3.TriggerStep sqlite3TriggerInsertStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Token pTableName,
      Sqlite3.IdList pColumn,
      int null_4,
      int null_5,
      byte orconf)
    {
      return Sqlite3.sqlite3TriggerInsertStep(db, pTableName, pColumn, (Sqlite3.ExprList) null, (Sqlite3.Select) null, orconf);
    }

    private static Sqlite3.TriggerStep sqlite3TriggerInsertStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Token pTableName,
      Sqlite3.IdList pColumn,
      Sqlite3.ExprList pEList,
      int null_5,
      byte orconf)
    {
      return Sqlite3.sqlite3TriggerInsertStep(db, pTableName, pColumn, pEList, (Sqlite3.Select) null, orconf);
    }

    private static Sqlite3.TriggerStep sqlite3TriggerInsertStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Token pTableName,
      Sqlite3.IdList pColumn,
      int null_4,
      Sqlite3.Select pSelect,
      byte orconf)
    {
      return Sqlite3.sqlite3TriggerInsertStep(db, pTableName, pColumn, (Sqlite3.ExprList) null, pSelect, orconf);
    }

    private static Sqlite3.TriggerStep sqlite3TriggerInsertStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Token pTableName,
      Sqlite3.IdList pColumn,
      Sqlite3.ExprList pEList,
      Sqlite3.Select pSelect,
      byte orconf)
    {
      Sqlite3.TriggerStep triggerStep = Sqlite3.triggerStepAllocate(db, (byte) 105, pTableName);
      triggerStep.pSelect = Sqlite3.sqlite3SelectDup(db, pSelect, 1);
      triggerStep.pIdList = pColumn;
      triggerStep.pExprList = Sqlite3.sqlite3ExprListDup(db, pEList, 1);
      triggerStep.orconf = orconf;
      Sqlite3.sqlite3ExprListDelete(db, ref pEList);
      Sqlite3.sqlite3SelectDelete(db, ref pSelect);
      return triggerStep;
    }

    private static Sqlite3.TriggerStep sqlite3TriggerUpdateStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Token pTableName,
      Sqlite3.ExprList pEList,
      Sqlite3.Expr pWhere,
      byte orconf)
    {
      Sqlite3.TriggerStep triggerStep = Sqlite3.triggerStepAllocate(db, (byte) 107, pTableName);
      triggerStep.pExprList = Sqlite3.sqlite3ExprListDup(db, pEList, 1);
      triggerStep.pWhere = Sqlite3.sqlite3ExprDup(db, pWhere, 1);
      triggerStep.orconf = orconf;
      Sqlite3.sqlite3ExprListDelete(db, ref pEList);
      Sqlite3.sqlite3ExprDelete(db, ref pWhere);
      return triggerStep;
    }

    private static Sqlite3.TriggerStep sqlite3TriggerDeleteStep(
      Sqlite3.sqlite3 db,
      Sqlite3.Token pTableName,
      Sqlite3.Expr pWhere)
    {
      Sqlite3.TriggerStep triggerStep = Sqlite3.triggerStepAllocate(db, (byte) 106, pTableName);
      triggerStep.pWhere = Sqlite3.sqlite3ExprDup(db, pWhere, 1);
      triggerStep.orconf = (byte) 99;
      Sqlite3.sqlite3ExprDelete(db, ref pWhere);
      return triggerStep;
    }

    private static void sqlite3DeleteTrigger(Sqlite3.sqlite3 db, ref Sqlite3.Trigger pTrigger)
    {
      if (pTrigger == null)
        return;
      Sqlite3.sqlite3DeleteTriggerStep(db, ref pTrigger.step_list);
      Sqlite3.sqlite3DbFree(db, ref pTrigger.zName);
      Sqlite3.sqlite3DbFree(db, ref pTrigger.table);
      Sqlite3.sqlite3ExprDelete(db, ref pTrigger.pWhen);
      Sqlite3.sqlite3IdListDelete(db, ref pTrigger.pColumns);
      pTrigger = (Sqlite3.Trigger) null;
      Sqlite3.sqlite3DbFree<Sqlite3.Trigger>(db, ref pTrigger);
    }

    private static void sqlite3DropTrigger(Sqlite3.Parse pParse, Sqlite3.SrcList pName, int noErr)
    {
      Sqlite3.Trigger pTrigger = (Sqlite3.Trigger) null;
      Sqlite3.sqlite3 db = pParse.db;
      if (Sqlite3.sqlite3ReadSchema(pParse) == 0)
      {
        string zDatabase = pName.a[0].zDatabase;
        string zName = pName.a[0].zName;
        int nKey = Sqlite3.sqlite3Strlen30(zName);
        for (int omitTempdb = Sqlite3.OMIT_TEMPDB; omitTempdb < db.nDb; ++omitTempdb)
        {
          int index = omitTempdb < 2 ? omitTempdb ^ 1 : omitTempdb;
          if (zDatabase == null || db.aDb[index].zName.Equals(zDatabase, StringComparison.InvariantCultureIgnoreCase))
          {
            pTrigger = Sqlite3.sqlite3HashFind<Sqlite3.Trigger>(db.aDb[index].pSchema.trigHash, zName, nKey, (Sqlite3.Trigger) null);
            if (pTrigger != null)
              break;
          }
        }
        if (pTrigger == null)
        {
          if (noErr == 0)
            Sqlite3.sqlite3ErrorMsg(pParse, "no such trigger: %S", (object) pName, (object) 0);
          else
            Sqlite3.sqlite3CodeVerifyNamedSchema(pParse, zDatabase);
          pParse.checkSchema = (byte) 1;
        }
        else
          Sqlite3.sqlite3DropTriggerPtr(pParse, pTrigger);
      }
      Sqlite3.sqlite3SrcListDelete(db, ref pName);
    }

    private static Sqlite3.Table tableOfTrigger(Sqlite3.Trigger pTrigger)
    {
      int nKey = Sqlite3.sqlite3Strlen30(pTrigger.table);
      return Sqlite3.sqlite3HashFind<Sqlite3.Table>(pTrigger.pTabSchema.tblHash, pTrigger.table, nKey, (Sqlite3.Table) null);
    }

    private static void sqlite3DropTriggerPtr(Sqlite3.Parse pParse, Sqlite3.Trigger pTrigger)
    {
      Sqlite3.sqlite3 db = pParse.db;
      int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pTrigger.pSchema);
      Sqlite3.tableOfTrigger(pTrigger);
      Sqlite3.Vdbe vdbe;
      if ((vdbe = Sqlite3.sqlite3GetVdbe(pParse)) == null)
        return;
      Sqlite3.VdbeOpList[] aOp = new Sqlite3.VdbeOpList[9]
      {
        new Sqlite3.VdbeOpList((byte) 65, 0, Sqlite3.ADDR(9), 0),
        new Sqlite3.VdbeOpList((byte) 94, 0, 1, 0),
        new Sqlite3.VdbeOpList((byte) 28, 0, 1, 2),
        new Sqlite3.VdbeOpList((byte) 75, 2, Sqlite3.ADDR(8), 1),
        new Sqlite3.VdbeOpList((byte) 94, 0, 1, 0),
        new Sqlite3.VdbeOpList((byte) 28, 0, 0, 2),
        new Sqlite3.VdbeOpList((byte) 75, 2, Sqlite3.ADDR(8), 1),
        new Sqlite3.VdbeOpList((byte) 57, 0, 0, 0),
        new Sqlite3.VdbeOpList((byte) 67, 0, Sqlite3.ADDR(1), 0)
      };
      Sqlite3.sqlite3BeginWriteOperation(pParse, 0, index);
      Sqlite3.sqlite3OpenMasterTable(pParse, index);
      int num = Sqlite3.sqlite3VdbeAddOpList(vdbe, aOp.Length, aOp);
      Sqlite3.sqlite3VdbeChangeP4(vdbe, num + 1, pTrigger.zName, 0);
      Sqlite3.sqlite3VdbeChangeP4(vdbe, num + 4, "trigger", -2);
      Sqlite3.sqlite3ChangeCookie(pParse, index);
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, 0, 0);
      Sqlite3.sqlite3VdbeAddOp4(vdbe, 103, index, 0, 0, pTrigger.zName, 0);
      if (pParse.nMem >= 3)
        return;
      pParse.nMem = 3;
    }

    private static void sqlite3UnlinkAndDeleteTrigger(Sqlite3.sqlite3 db, int iDb, string zName)
    {
      Sqlite3.Hash trigHash = db.aDb[iDb].pSchema.trigHash;
      Sqlite3.Trigger pTrigger = Sqlite3.sqlite3HashInsert<Sqlite3.Trigger>(ref trigHash, zName, Sqlite3.sqlite3Strlen30(zName), (Sqlite3.Trigger) null);
      if (!Sqlite3.ALWAYS(pTrigger != null))
        return;
      if (pTrigger.pSchema == pTrigger.pTabSchema)
      {
        Sqlite3.Table table = Sqlite3.tableOfTrigger(pTrigger);
        if (table.pTrigger == pTrigger)
        {
          table.pTrigger = pTrigger.pNext;
        }
        else
        {
          for (Sqlite3.Trigger trigger = table.pTrigger; trigger != null; trigger = trigger.pNext)
          {
            if (trigger.pNext == pTrigger)
            {
              trigger.pNext = trigger.pNext.pNext;
              break;
            }
          }
        }
      }
      Sqlite3.sqlite3DeleteTrigger(db, ref pTrigger);
      db.flags |= 512;
    }

    private static int checkColumnOverlap(Sqlite3.IdList pIdList, Sqlite3.ExprList pEList)
    {
      if (pIdList == null || Sqlite3.NEVER(pEList == null))
        return 1;
      for (int index = 0; index < pEList.nExpr; ++index)
      {
        if (Sqlite3.sqlite3IdListIndex(pIdList, pEList.a[index].zName) >= 0)
          return 1;
      }
      return 0;
    }

    private static Sqlite3.Trigger sqlite3TriggersExist(
      Sqlite3.Parse pParse,
      Sqlite3.Table pTab,
      int op,
      Sqlite3.ExprList pChanges,
      out int pMask)
    {
      int num = 0;
      Sqlite3.Trigger trigger1 = (Sqlite3.Trigger) null;
      if ((pParse.db.flags & 1073741824) != 0)
        trigger1 = Sqlite3.sqlite3TriggerList(pParse, pTab);
      for (Sqlite3.Trigger trigger2 = trigger1; trigger2 != null; trigger2 = trigger2.pNext)
      {
        if ((int) trigger2.op == op && Sqlite3.checkColumnOverlap(trigger2.pColumns, pChanges) != 0)
          num |= (int) trigger2.tr_tm;
      }
      pMask = num;
      return num == 0 ? (Sqlite3.Trigger) null : trigger1;
    }

    private static Sqlite3.SrcList targetSrcList(
      Sqlite3.Parse pParse,
      Sqlite3.TriggerStep pStep)
    {
      Sqlite3.SrcList srcList = Sqlite3.sqlite3SrcListAppend(pParse.db, 0, pStep.target, 0);
      int index = Sqlite3.sqlite3SchemaToIndex(pParse.db, pStep.pTrig.pSchema);
      if (index == 0 || index >= 2)
      {
        Sqlite3.sqlite3 db = pParse.db;
        srcList.a[(int) srcList.nSrc - 1].zDatabase = db.aDb[index].zName;
      }
      return srcList;
    }

    private static int codeTriggerProgram(
      Sqlite3.Parse pParse,
      Sqlite3.TriggerStep pStepList,
      int orconf)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.sqlite3 db = pParse.db;
      for (Sqlite3.TriggerStep pStep = pStepList; pStep != null; pStep = pStep.pNext)
      {
        pParse.eOrconf = orconf == 99 ? pStep.orconf : (byte) orconf;
        switch (pStep.op)
        {
          case 105:
            Sqlite3.sqlite3Insert(pParse, Sqlite3.targetSrcList(pParse, pStep), Sqlite3.sqlite3ExprListDup(db, pStep.pExprList, 0), Sqlite3.sqlite3SelectDup(db, pStep.pSelect, 0), Sqlite3.sqlite3IdListDup(db, pStep.pIdList), (int) pParse.eOrconf);
            break;
          case 106:
            Sqlite3.sqlite3DeleteFrom(pParse, Sqlite3.targetSrcList(pParse, pStep), Sqlite3.sqlite3ExprDup(db, pStep.pWhere, 0));
            break;
          case 107:
            Sqlite3.sqlite3Update(pParse, Sqlite3.targetSrcList(pParse, pStep), Sqlite3.sqlite3ExprListDup(db, pStep.pExprList, 0), Sqlite3.sqlite3ExprDup(db, pStep.pWhere, 0), (int) pParse.eOrconf);
            break;
          default:
            Sqlite3.SelectDest pDest = new Sqlite3.SelectDest();
            Sqlite3.Select p = Sqlite3.sqlite3SelectDup(db, pStep.pSelect, 0);
            Sqlite3.sqlite3SelectDestInit(pDest, 4, 0);
            Sqlite3.sqlite3Select(pParse, p, ref pDest);
            Sqlite3.sqlite3SelectDelete(db, ref p);
            break;
        }
        if (pStep.op != (byte) 116)
          Sqlite3.sqlite3VdbeAddOp0(pVdbe, 58);
      }
      return 0;
    }

    private static void transferParseError(Sqlite3.Parse pTo, Sqlite3.Parse pFrom)
    {
      if (pTo.nErr == 0)
      {
        pTo.zErrMsg = pFrom.zErrMsg;
        pTo.nErr = pFrom.nErr;
      }
      else
        Sqlite3.sqlite3DbFree(pFrom.db, ref pFrom.zErrMsg);
    }

    private static Sqlite3.TriggerPrg codeRowTrigger(
      Sqlite3.Parse pParse,
      Sqlite3.Trigger pTrigger,
      Sqlite3.Table pTab,
      int orconf)
    {
      Sqlite3.Parse toplevel = Sqlite3.sqlite3ParseToplevel(pParse);
      Sqlite3.sqlite3 db = pParse.db;
      int num = 0;
      Sqlite3.TriggerPrg triggerPrg = new Sqlite3.TriggerPrg();
      triggerPrg.pNext = toplevel.pTriggerPrg;
      toplevel.pTriggerPrg = triggerPrg;
      Sqlite3.SubProgram p;
      triggerPrg.pProgram = p = new Sqlite3.SubProgram();
      Sqlite3.sqlite3VdbeLinkSubProgram(toplevel.pVdbe, p);
      triggerPrg.pTrigger = pTrigger;
      triggerPrg.orconf = orconf;
      triggerPrg.aColmask[0] = uint.MaxValue;
      triggerPrg.aColmask[1] = uint.MaxValue;
      Sqlite3.Parse parse = new Sqlite3.Parse();
      Sqlite3.NameContext pNC = new Sqlite3.NameContext();
      pNC.pParse = parse;
      parse.db = db;
      parse.pTriggerTab = pTab;
      parse.pToplevel = toplevel;
      parse.zAuthContext = pTrigger.zName;
      parse.eTriggerOp = pTrigger.op;
      parse.nQueryLoop = pParse.nQueryLoop;
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(parse);
      if (vdbe != null)
      {
        Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, Sqlite3.sqlite3MPrintf(db, "-- TRIGGER %s", (object) pTrigger.zName), -1);
        if (pTrigger.pWhen != null)
        {
          Sqlite3.Expr pExpr = Sqlite3.sqlite3ExprDup(db, pTrigger.pWhen, 0);
          if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pExpr) == 0)
          {
            num = Sqlite3.sqlite3VdbeMakeLabel(vdbe);
            Sqlite3.sqlite3ExprIfFalse(parse, pExpr, num, 8);
          }
          Sqlite3.sqlite3ExprDelete(db, ref pExpr);
        }
        Sqlite3.codeTriggerProgram(parse, pTrigger.step_list, orconf);
        if (num != 0)
          Sqlite3.sqlite3VdbeResolveLabel(vdbe, num);
        Sqlite3.sqlite3VdbeAddOp0(vdbe, 6);
        Sqlite3.transferParseError(pParse, parse);
        p.aOp = Sqlite3.sqlite3VdbeTakeOpArray(vdbe, ref p.nOp, ref toplevel.nMaxArg);
        p.nMem = parse.nMem;
        p.nCsr = parse.nTab;
        p.token = pTrigger.GetHashCode();
        triggerPrg.aColmask[0] = parse.oldmask;
        triggerPrg.aColmask[1] = parse.newmask;
        Sqlite3.sqlite3VdbeDelete(ref vdbe);
      }
      return triggerPrg;
    }

    private static Sqlite3.TriggerPrg getRowTrigger(
      Sqlite3.Parse pParse,
      Sqlite3.Trigger pTrigger,
      Sqlite3.Table pTab,
      int orconf)
    {
      Sqlite3.TriggerPrg rowTrigger = Sqlite3.sqlite3ParseToplevel(pParse).pTriggerPrg;
      while (rowTrigger != null && (rowTrigger.pTrigger != pTrigger || rowTrigger.orconf != orconf))
        rowTrigger = rowTrigger.pNext;
      if (rowTrigger == null)
        rowTrigger = Sqlite3.codeRowTrigger(pParse, pTrigger, pTab, orconf);
      return rowTrigger;
    }

    private static void sqlite3CodeRowTriggerDirect(
      Sqlite3.Parse pParse,
      Sqlite3.Trigger p,
      Sqlite3.Table pTab,
      int reg,
      int orconf,
      int ignoreJump)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      Sqlite3.TriggerPrg rowTrigger = Sqlite3.getRowTrigger(pParse, p, pTab, orconf);
      if (rowTrigger == null)
        return;
      bool flag = !string.IsNullOrEmpty(p.zName) && (pParse.db.flags & 33554432) == 0;
      Sqlite3.sqlite3VdbeAddOp3(vdbe, 108, reg, ignoreJump, ++pParse.nMem);
      Sqlite3.sqlite3VdbeChangeP4(vdbe, -1, rowTrigger.pProgram, -18);
      Sqlite3.sqlite3VdbeChangeP5(vdbe, flag ? (byte) 1 : (byte) 0);
    }

    private static void sqlite3CodeRowTrigger(
      Sqlite3.Parse pParse,
      Sqlite3.Trigger pTrigger,
      int op,
      Sqlite3.ExprList pChanges,
      int tr_tm,
      Sqlite3.Table pTab,
      int reg,
      int orconf,
      int ignoreJump)
    {
      for (Sqlite3.Trigger p = pTrigger; p != null; p = p.pNext)
      {
        if ((int) p.op == op && (int) p.tr_tm == tr_tm && Sqlite3.checkColumnOverlap(p.pColumns, pChanges) != 0)
          Sqlite3.sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
      }
    }

    private static uint sqlite3TriggerColmask(
      Sqlite3.Parse pParse,
      Sqlite3.Trigger pTrigger,
      Sqlite3.ExprList pChanges,
      int isNew,
      int tr_tm,
      Sqlite3.Table pTab,
      int orconf)
    {
      int num1 = pChanges != null ? 107 : 106;
      uint num2 = 0;
      for (Sqlite3.Trigger pTrigger1 = pTrigger; pTrigger1 != null; pTrigger1 = pTrigger1.pNext)
      {
        if ((int) pTrigger1.op == num1 && (tr_tm & (int) pTrigger1.tr_tm) != 0 && Sqlite3.checkColumnOverlap(pTrigger1.pColumns, pChanges) != 0)
        {
          Sqlite3.TriggerPrg rowTrigger = Sqlite3.getRowTrigger(pParse, pTrigger1, pTab, orconf);
          if (rowTrigger != null)
            num2 |= rowTrigger.aColmask[isNew];
        }
      }
      return num2;
    }

    private static void sqlite3ColumnDefault(Sqlite3.Vdbe v, Sqlite3.Table pTab, int i, int iReg)
    {
      if (pTab.pSelect != null)
        return;
      Sqlite3.Mem ppVal = new Sqlite3.Mem();
      int enc = (int) Sqlite3.ENC(Sqlite3.sqlite3VdbeDb(v));
      Sqlite3.Column column = pTab.aCol[i];
      Sqlite3.sqlite3ValueFromExpr(Sqlite3.sqlite3VdbeDb(v), column.pDflt, enc, column.affinity, ref ppVal);
      if (ppVal != null)
        Sqlite3.sqlite3VdbeChangeP4(v, -1, ppVal, -8);
      if (iReg < 0 || pTab.aCol[i].affinity != 'e')
        return;
      Sqlite3.sqlite3VdbeAddOp1(v, 22, iReg);
    }

    private static void sqlite3Update(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.ExprList pChanges,
      Sqlite3.Expr pWhere,
      int onError)
    {
      int[] pPrior1 = (int[]) null;
      int[] pPrior2 = (int[]) null;
      Sqlite3.Expr pExpr = (Sqlite3.Expr) null;
      bool flag1 = false;
      int pMask = 0;
      int num1 = 0;
      int num2 = 0;
      int p1_1 = 0;
      Sqlite3.AuthContext b = new Sqlite3.AuthContext();
      Sqlite3.sqlite3 db = pParse.db;
      if (pParse.nErr == 0)
      {
        Sqlite3.Table table = Sqlite3.sqlite3SrcListLookup(pParse, pTabList);
        if (table != null)
        {
          int index1 = Sqlite3.sqlite3SchemaToIndex(pParse.db, table.pSchema);
          Sqlite3.Trigger pTrigger = Sqlite3.sqlite3TriggersExist(pParse, table, 107, pChanges, out pMask);
          bool flag2 = table.pSelect != null;
          if (Sqlite3.sqlite3ViewGetColumnNames(pParse, table) == 0 && !Sqlite3.sqlite3IsReadOnly(pParse, table, pMask))
          {
            pPrior2 = new int[table.nCol];
            for (int index2 = 0; index2 < table.nCol; ++index2)
              pPrior2[index2] = -1;
            Sqlite3.SrcList_item srcListItem = pTabList.a[0];
            int num3 = pParse.nTab++;
            int num4;
            int num5 = num4 = num3;
            srcListItem.iCursor = num4;
            for (Sqlite3.Index index3 = table.pIndex; index3 != null; index3 = index3.pNext)
              ++pParse.nTab;
            Sqlite3.NameContext pNC = new Sqlite3.NameContext();
            pNC.pParse = pParse;
            pNC.pSrcList = pTabList;
            bool flag3 = false;
            for (int index4 = 0; index4 < pChanges.nExpr; ++index4)
            {
              if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pChanges.a[index4].pExpr) == 0)
              {
                int index5;
                for (index5 = 0; index5 < table.nCol; ++index5)
                {
                  if (table.aCol[index5].zName.Equals(pChanges.a[index4].zName, StringComparison.InvariantCultureIgnoreCase))
                  {
                    if (index5 == table.iPKey)
                    {
                      flag3 = true;
                      pExpr = pChanges.a[index4].pExpr;
                    }
                    pPrior2[index5] = index4;
                    break;
                  }
                }
                if (index5 >= table.nCol)
                {
                  if (Sqlite3.sqlite3IsRowid(pChanges.a[index4].zName))
                  {
                    flag3 = true;
                    pExpr = pChanges.a[index4].pExpr;
                  }
                  else
                  {
                    Sqlite3.sqlite3ErrorMsg(pParse, "no such column: %s", (object) pChanges.a[index4].zName);
                    pParse.checkSchema = (byte) 1;
                    goto label_120;
                  }
                }
              }
              else
                goto label_120;
            }
            bool flag4 = Sqlite3.sqlite3FkRequired(pParse, table, pPrior2, flag3 ? 1 : 0) != 0;
            int length = 0;
            Sqlite3.Index index6 = table.pIndex;
            while (index6 != null)
            {
              index6 = index6.pNext;
              ++length;
            }
            if (length > 0)
            {
              pPrior1 = new int[length];
              if (pPrior1 == null)
                goto label_120;
            }
            int index7 = 0;
            Sqlite3.Index index8 = table.pIndex;
            while (index8 != null)
            {
              int num6;
              if (flag4 | flag3)
              {
                num6 = ++pParse.nMem;
              }
              else
              {
                num6 = 0;
                for (int index9 = 0; index9 < index8.nColumn; ++index9)
                {
                  if (pPrior2[index8.aiColumn[index9]] >= 0)
                  {
                    num6 = ++pParse.nMem;
                    break;
                  }
                }
              }
              pPrior1[index7] = num6;
              index8 = index8.pNext;
              ++index7;
            }
            Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
            if (vdbe != null)
            {
              if (pParse.nested == (byte) 0)
                Sqlite3.sqlite3VdbeCountChanges(vdbe);
              Sqlite3.sqlite3BeginWriteOperation(pParse, 1, index1);
              int num7 = ++pParse.nMem;
              int num8;
              int num9 = num8 = num7;
              if (pTrigger != null | flag4)
              {
                num2 = pParse.nMem + 1;
                pParse.nMem += table.nCol;
              }
              if (((flag3 ? 1 : (pTrigger != null ? 1 : 0)) | (flag4 ? 1 : 0)) != 0)
                num8 = ++pParse.nMem;
              int p1_2 = pParse.nMem + 1;
              pParse.nMem += table.nCol;
              if (flag2)
                Sqlite3.sqlite3AuthContextPush(pParse, b, table.zName);
              if (flag2)
                Sqlite3.sqlite3MaterializeView(pParse, table, pWhere, num5);
              if (Sqlite3.sqlite3ResolveExprNames(pNC, ref pWhere) == 0)
              {
                Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num9);
                Sqlite3.ExprList ppOrderBy = (Sqlite3.ExprList) null;
                Sqlite3.WhereInfo pWInfo = Sqlite3.sqlite3WhereBegin(pParse, pTabList, pWhere, ref ppOrderBy, (ushort) 4);
                if (pWInfo != null)
                {
                  bool flag5 = pWInfo.okOnePass > (byte) 0;
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 61, num5, num9);
                  if (!flag5)
                  {
                    p1_1 = ++pParse.nMem;
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 105, p1_1, num9);
                  }
                  Sqlite3.sqlite3WhereEnd(pWInfo);
                  if ((db.flags & 4096) != 0 && pParse.pTriggerTab == null)
                  {
                    num1 = ++pParse.nMem;
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 7, 0, num1);
                  }
                  if (!flag2)
                  {
                    if (!flag5)
                      Sqlite3.sqlite3OpenTable(pParse, num5, index1, table, 39);
                    if (onError == 5)
                    {
                      flag1 = true;
                    }
                    else
                    {
                      flag1 = false;
                      for (Sqlite3.Index index10 = table.pIndex; index10 != null; index10 = index10.pNext)
                      {
                        if (index10.onError == (byte) 5)
                        {
                          flag1 = true;
                          break;
                        }
                      }
                    }
                    int index11 = 0;
                    Sqlite3.Index pIdx = table.pIndex;
                    while (pIdx != null)
                    {
                      if (flag1 || pPrior1[index11] > 0)
                      {
                        Sqlite3.KeyInfo pP4 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
                        Sqlite3.sqlite3VdbeAddOp4(vdbe, 39, num5 + index11 + 1, pIdx.tnum, index1, pP4, -16);
                      }
                      pIdx = pIdx.pNext;
                      ++index11;
                    }
                  }
                  int num10;
                  if (flag5)
                  {
                    int addr = Sqlite3.sqlite3VdbeAddOp1(vdbe, 74, num9);
                    num10 = Sqlite3.sqlite3VdbeAddOp0(vdbe, 1);
                    Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
                  }
                  else
                    num10 = Sqlite3.sqlite3VdbeAddOp3(vdbe, 106, p1_1, 0, num9);
                  Sqlite3.sqlite3VdbeAddOp3(vdbe, 52, num5, num10, num9);
                  if (flag3)
                  {
                    Sqlite3.sqlite3ExprCode(pParse, pExpr, num8);
                    Sqlite3.sqlite3VdbeAddOp1(vdbe, 21, num8);
                  }
                  if (flag4 || pTrigger != null)
                  {
                    uint num11 = (flag4 ? Sqlite3.sqlite3FkOldmask(pParse, table) : 0U) | Sqlite3.sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, 3, table, onError);
                    for (int iCol = 0; iCol < table.nCol; ++iCol)
                    {
                      if (pPrior2[iCol] < 0 || num11 == uint.MaxValue || iCol < 32 && ((long) num11 & (long) (1 << iCol)) != 0L)
                        Sqlite3.sqlite3ExprCodeGetColumnOfTable(vdbe, table, num5, iCol, num2 + iCol);
                      else
                        Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, num2 + iCol);
                    }
                    if (!flag3)
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 14, num9, num8);
                  }
                  int num12 = (int) Sqlite3.sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, table, onError);
                  for (int index12 = 0; index12 < table.nCol; ++index12)
                  {
                    if (index12 == table.iPKey)
                    {
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 10, 0, p1_2 + index12);
                    }
                    else
                    {
                      int index13 = pPrior2[index12];
                      if (index13 >= 0)
                        Sqlite3.sqlite3ExprCode(pParse, pChanges.a[index13].pExpr, p1_2 + index12);
                      else if ((pMask & 1) == 0 || index12 > 31 || (num12 & 1 << index12) != 0)
                      {
                        Sqlite3.testcase<bool>(index12 == 31);
                        Sqlite3.testcase<bool>(index12 == 32);
                        Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, num5, index12, p1_2 + index12);
                        Sqlite3.sqlite3ColumnDefault(vdbe, table, index12, p1_2 + index12);
                      }
                    }
                  }
                  if ((pMask & 1) != 0)
                  {
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 29, p1_2, table.nCol);
                    Sqlite3.sqlite3TableAffinityStr(vdbe, table);
                    Sqlite3.sqlite3CodeRowTrigger(pParse, pTrigger, 107, pChanges, 1, table, num9, onError, num10);
                    Sqlite3.sqlite3VdbeAddOp3(vdbe, 52, num5, num10, num9);
                    for (int index14 = 0; index14 < table.nCol; ++index14)
                    {
                      if (pPrior2[index14] < 0 && index14 != table.iPKey)
                      {
                        Sqlite3.sqlite3VdbeAddOp3(vdbe, 28, num5, index14, p1_2 + index14);
                        Sqlite3.sqlite3ColumnDefault(vdbe, table, index14, p1_2 + index14);
                      }
                    }
                  }
                  if (!flag2)
                  {
                    Sqlite3.sqlite3GenerateConstraintChecks(pParse, table, num5, num8, pPrior1, flag3 ? num9 : 0, true, onError, num10, out int _);
                    if (flag4)
                      Sqlite3.sqlite3FkCheck(pParse, table, num9, 0);
                    int addr = Sqlite3.sqlite3VdbeAddOp3(vdbe, 52, num5, 0, num9);
                    Sqlite3.sqlite3GenerateRowIndexDelete(pParse, table, num5, pPrior1);
                    if (flag4 | flag3)
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 57, num5, 0);
                    Sqlite3.sqlite3VdbeJumpHere(vdbe, addr);
                    if (flag4)
                      Sqlite3.sqlite3FkCheck(pParse, table, 0, num8);
                    Sqlite3.sqlite3CompleteInsertion(pParse, table, num5, num8, pPrior1, true, false, false);
                    if (flag4)
                      Sqlite3.sqlite3FkActions(pParse, table, pChanges, num9);
                  }
                  if ((db.flags & 4096) != 0 && pParse.pTriggerTab == null)
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 20, num1, 1);
                  Sqlite3.sqlite3CodeRowTrigger(pParse, pTrigger, 107, pChanges, 2, table, num9, onError, num10);
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 1, 0, num10);
                  Sqlite3.sqlite3VdbeJumpHere(vdbe, num10);
                  int index15 = 0;
                  Sqlite3.Index index16 = table.pIndex;
                  while (index16 != null)
                  {
                    if (flag1 || pPrior1[index15] > 0)
                      Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num5 + index15 + 1, 0);
                    index16 = index16.pNext;
                    ++index15;
                  }
                  Sqlite3.sqlite3VdbeAddOp2(vdbe, 43, num5, 0);
                  if (pParse.nested == (byte) 0 && pParse.pTriggerTab == null)
                    Sqlite3.sqlite3AutoincrementEnd(pParse);
                  if ((db.flags & 4096) != 0 && pParse.pTriggerTab == null && pParse.nested == (byte) 0)
                  {
                    Sqlite3.sqlite3VdbeAddOp2(vdbe, 16, num1, 1);
                    Sqlite3.sqlite3VdbeSetNumCols(vdbe, 1);
                    Sqlite3.sqlite3VdbeSetColName(vdbe, 0, 0, "rows updated", Sqlite3.SQLITE_STATIC);
                  }
                }
              }
            }
          }
        }
      }
label_120:
      Sqlite3.sqlite3DbFree(db, ref pPrior1);
      Sqlite3.sqlite3DbFree(db, ref pPrior2);
      Sqlite3.sqlite3SrcListDelete(db, ref pTabList);
      Sqlite3.sqlite3ExprListDelete(db, ref pChanges);
      Sqlite3.sqlite3ExprDelete(db, ref pWhere);
    }

    private static uint sqlite3Utf8Read(string zIn, ref string pzNext)
    {
      if (string.IsNullOrEmpty(zIn))
        return 0;
      int num1 = 0;
      string str = zIn;
      int index = num1;
      int num2 = index + 1;
      uint num3 = (uint) str[index];
      if (num3 >= 192U)
      {
        while (num2 != zIn.Length && ((int) zIn[num2] & 192) == 128)
          num3 = (uint) ((long) (num3 << 6) + (long) (63 & (int) zIn[num2++]));
        if (num3 < 128U || ((int) num3 & -2048) == 55296 || ((int) num3 & -2) == 65534)
          num3 = 65533U;
      }
      pzNext = zIn.Substring(num2);
      return num3;
    }

    private static int sqlite3Utf8CharLen(string zIn, int nByte)
    {
      if (zIn.Length == 0)
        return 0;
      int length = zIn.Length;
      int num = nByte < 0 || nByte > length ? length : nByte;
      return num == length ? length - (zIn[num - 1] == char.MinValue ? 1 : 0) : nByte;
    }

    private static bool sqlite3IsNaN(double x)
    {
      double num1;
      int num2 = (num1 = x) != num1 ? 1 : 0;
      Sqlite3.testcase<bool>(num2 != 0);
      return num2 != 0;
    }

    private static int sqlite3Strlen30(int z) => 1073741823 & z;

    private static int sqlite3Strlen30(StringBuilder z)
    {
      if (z == null)
        return 0;
      int num = z.ToString().IndexOf(char.MinValue);
      return 1073741823 & (num == -1 ? z.Length : num);
    }

    private static int sqlite3Strlen30(string z)
    {
      if (z == null)
        return 0;
      int num = z.IndexOf(char.MinValue);
      return 1073741823 & (num == -1 ? z.Length : num);
    }

    private static void sqlite3Error(Sqlite3.sqlite3 db, int err_code, int noString) => Sqlite3.sqlite3Error(db, err_code, err_code == 0 ? (string) null : "");

    private static void sqlite3Error(
      Sqlite3.sqlite3 db,
      int err_code,
      string zFormat,
      params object[] ap)
    {
      if (db == null || db.pErr == null && (db.pErr = Sqlite3.sqlite3ValueNew(db)) == null)
        return;
      db.errCode = err_code;
      if (zFormat != null)
      {
        lock (Sqlite3.lock_va_list)
        {
          Sqlite3.va_start(ap, zFormat);
          string z = Sqlite3.sqlite3VMPrintf(db, zFormat, ap);
          Sqlite3.va_end(ref ap);
          Sqlite3.sqlite3ValueSetStr(db.pErr, -1, z, (byte) 1, Sqlite3.SQLITE_DYNAMIC);
        }
      }
      else
        Sqlite3.sqlite3ValueSetStr(db.pErr, 0, (string) null, (byte) 1, Sqlite3.SQLITE_STATIC);
    }

    private static void sqlite3ErrorMsg(Sqlite3.Parse pParse, string zFormat, params object[] ap)
    {
      Sqlite3.sqlite3 db = pParse.db;
      string pString;
      lock (Sqlite3.lock_va_list)
      {
        Sqlite3.va_start(ap, zFormat);
        pString = Sqlite3.sqlite3VMPrintf(db, zFormat, ap);
        Sqlite3.va_end(ref ap);
      }
      if (db.suppressErr != (byte) 0)
      {
        Sqlite3.sqlite3DbFree(db, ref pString);
      }
      else
      {
        ++pParse.nErr;
        Sqlite3.sqlite3DbFree(db, ref pParse.zErrMsg);
        pParse.zErrMsg = pString;
        pParse.rc = 1;
      }
    }

    private static int sqlite3Dequote(ref string z)
    {
      if (z == null || z == "")
        return -1;
      char ch = z[0];
      switch (ch)
      {
        case '"':
        case '\'':
        case '`':
          StringBuilder stringBuilder = new StringBuilder(z.Length);
          for (int index = 1; index < z.Length; ++index)
          {
            if ((int) z[index] == (int) ch)
            {
              if (index < z.Length - 1 && (int) z[index + 1] == (int) ch)
              {
                stringBuilder.Append(ch);
                ++index;
              }
              else
                break;
            }
            else
              stringBuilder.Append(z[index]);
          }
          z = stringBuilder.ToString();
          return stringBuilder.Length;
        case '[':
          ch = ']';
          goto case '"';
        default:
          return -1;
      }
    }

    private static int sqlite3StrNICmp(string zLeft, int offsetLeft, string zRight, int N)
    {
      int num = 0;
      int index;
      for (index = 0; N-- > 0 && num < zLeft.Length - offsetLeft && index < zRight.Length && zLeft[num + offsetLeft] != char.MinValue && Sqlite3.UpperToLower[(int) zLeft[num + offsetLeft]] == Sqlite3.UpperToLower[(int) zRight[index]]; ++index)
        ++num;
      return N >= 0 ? (num < zLeft.Length - offsetLeft ? Sqlite3.UpperToLower[(int) zLeft[num + offsetLeft]] : 0) - Sqlite3.UpperToLower[(int) zRight[index]] : 0;
    }

    private static int sqlite3StrNICmp(string zLeft, string zRight, int N)
    {
      int index1 = 0;
      int index2;
      for (index2 = 0; N-- > 0 && index1 < zLeft.Length && index2 < zRight.Length && ((int) zLeft[index1] == (int) zRight[index2] || zLeft[index1] != char.MinValue && zLeft[index1] < 'Ā' && zRight[index2] < 'Ā' && Sqlite3.UpperToLower[(int) zLeft[index1]] == Sqlite3.UpperToLower[(int) zRight[index2]]); ++index2)
        ++index1;
      if (N < 0 || index1 == zLeft.Length && index2 == zRight.Length)
        return 0;
      if (index1 == zLeft.Length)
        return -Sqlite3.UpperToLower[(int) zRight[index2]];
      return index2 == zRight.Length ? Sqlite3.UpperToLower[(int) zLeft[index1]] : (zLeft[index1] < 'Ā' ? Sqlite3.UpperToLower[(int) zLeft[index1]] : (int) zLeft[index1]) - (zRight[index2] < 'Ā' ? Sqlite3.UpperToLower[(int) zRight[index2]] : (int) zRight[index2]);
    }

    private static bool sqlite3AtoF(string z, ref double pResult, int length, byte enc)
    {
      if (string.IsNullOrEmpty(z))
      {
        pResult = 0.0;
        return false;
      }
      int num1 = enc == (byte) 1 ? 1 : 2;
      int num2 = 1;
      long num3 = 0;
      int num4 = 0;
      int num5 = 1;
      int num6 = 0;
      int num7 = 1;
      int num8 = 0;
      pResult = 0.0;
      int index = 0;
      if (enc == (byte) 3)
        ++index;
      while (index < length && Sqlite3.sqlite3Isspace(z[index]))
        ++index;
      if (index >= length)
        return false;
      if (z[index] == '-')
      {
        num2 = -1;
        index += num1;
      }
      else if (z[index] == '+')
        index += num1;
      while (index < z.Length && z[index] == '0')
      {
        index += num1;
        ++num8;
      }
      while (index < length && Sqlite3.sqlite3Isdigit(z[index]) && num3 < 922337203685477579L)
      {
        num3 = num3 * 10L + (long) ((int) z[index] - 48);
        index += num1;
        ++num8;
      }
      while (index < length && Sqlite3.sqlite3Isdigit(z[index]))
      {
        index += num1;
        ++num8;
        ++num4;
      }
      if (index < length)
      {
        if (z[index] == '.')
        {
          index += num1;
          while (index < length && Sqlite3.sqlite3Isdigit(z[index]) && num3 < 922337203685477579L)
          {
            num3 = num3 * 10L + (long) ((int) z[index] - 48);
            index += num1;
            ++num8;
            --num4;
          }
          while (index < length && Sqlite3.sqlite3Isdigit(z[index]))
          {
            index += num1;
            ++num8;
          }
          if (index >= length)
            goto label_37;
        }
        if (z[index] == 'e' || z[index] == 'E')
        {
          index += num1;
          num7 = 0;
          if (index < length)
          {
            if (z[index] == '-')
            {
              num5 = -1;
              index += num1;
            }
            else if (z[index] == '+')
              index += num1;
            while (index < length && Sqlite3.sqlite3Isdigit(z[index]))
            {
              num6 = num6 * 10 + ((int) z[index] - 48);
              index += num1;
              num7 = 1;
            }
          }
          else
            goto label_37;
        }
        if (num8 > 0 && num7 > 0)
        {
          while (index < length && Sqlite3.sqlite3Isspace(z[index]))
            index += num1;
        }
      }
label_37:
      int num9 = num6 * num5 + num4;
      int num10;
      if (num9 < 0)
      {
        num10 = -1;
        num9 *= -1;
      }
      else
        num10 = 1;
      double num11;
      if (num3 == 0L)
      {
        num11 = num2 >= 0 || num8 == 0 ? 0.0 : -0.0;
      }
      else
      {
        if (num10 > 0)
        {
          for (; num3 < 922337203685477580L && num9 > 0; num3 *= 10L)
            --num9;
        }
        else
        {
          for (; num3 % 10L == 0L && num9 > 0; num3 /= 10L)
            --num9;
        }
        long num12 = num2 < 0 ? -num3 : num3;
        if (num9 != 0)
        {
          double num13 = 1.0;
          if (num9 > 307 && num9 < 342)
          {
            for (; num9 % 308 != 0; --num9)
              num13 *= 10.0;
            num11 = num10 >= 0 ? (double) num12 * num13 * 1E+308 : (double) num12 / num13 / 1E+308;
          }
          else
          {
            for (; num9 % 22 != 0; --num9)
              num13 *= 10.0;
            for (; num9 > 0; num9 -= 22)
              num13 *= 1E+22;
            num11 = num10 >= 0 ? (double) num12 * num13 : (double) num12 / num13;
          }
        }
        else
          num11 = (double) num12;
      }
      pResult = num11;
      return index >= length && num8 > 0 && num7 != 0;
    }

    private static int compare2pow63(string zNum, int incr)
    {
      int num = 0;
      string str = "922337203685477580";
      for (int index = 0; num == 0 && index < 18; ++index)
        num = ((int) zNum[index * incr] - (int) str[index]) * 10;
      if (num == 0)
      {
        num = (int) zNum[18 * incr] - 56;
        Sqlite3.testcase<bool>(num == -1);
        Sqlite3.testcase<bool>(num == 0);
        Sqlite3.testcase<bool>(num == 1);
      }
      return num;
    }

    private static int sqlite3Atoi64(string zNum, ref long pNum, int length, byte enc)
    {
      if (zNum == null)
      {
        pNum = 0L;
        return 1;
      }
      int incr = enc == (byte) 1 ? 1 : 2;
      ulong num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int num4 = 0;
      if (enc == (byte) 3)
        ++num4;
      while (num4 < length && Sqlite3.sqlite3Isspace(zNum[num4]))
        num4 += incr;
      if (num4 < length)
      {
        if (zNum[num4] == '-')
        {
          num2 = 1;
          num4 += incr;
        }
        else if (zNum[num4] == '+')
          num4 += incr;
      }
      if (length > zNum.Length)
        length = zNum.Length;
      while (num4 < length - 1 && zNum[num4] == '0')
        num4 += incr;
      int index;
      for (index = num4; index < length && (num3 = (int) zNum[index]) >= 48 && num3 <= 57; index += incr)
        num1 = num1 * 10UL + (ulong) (num3 - 48);
      pNum = num1 <= (ulong) long.MaxValue ? (num2 == 0 ? (long) num1 : -(long) num1) : long.MinValue;
      Sqlite3.testcase<bool>(index - num4 == 18);
      Sqlite3.testcase<bool>(index - num4 == 19);
      Sqlite3.testcase<bool>(index - num4 == 20);
      if (num3 != 0 && index < length || index == num4 || index - num4 > 19 * incr)
        return 1;
      if (index - num4 < 19 * incr)
        return 0;
      int num5 = Sqlite3.compare2pow63(zNum.Substring(num4), incr);
      if (num5 < 0)
        return 0;
      if (num5 > 0)
        return 1;
      return num2 == 0 ? 2 : 0;
    }

    private static bool sqlite3GetInt32(string zNum, ref int pValue) => Sqlite3.sqlite3GetInt32(zNum, 0, ref pValue);

    private static bool sqlite3GetInt32(string zNum, int iZnum, ref int pValue)
    {
      long num1 = 0;
      int num2 = 0;
      if (zNum[iZnum] == '-')
      {
        num2 = 1;
        ++iZnum;
      }
      else if (zNum[iZnum] == '+')
        ++iZnum;
      while (iZnum < zNum.Length && zNum[iZnum] == '0')
        ++iZnum;
      int num3;
      int num4;
      for (num3 = 0; num3 < 11 && num3 + iZnum < zNum.Length && (num4 = (int) zNum[iZnum + num3] - 48) >= 0 && num4 <= 9; ++num3)
        num1 = num1 * 10L + (long) num4;
      Sqlite3.testcase<bool>(num3 == 10);
      if (num3 > 10)
        return false;
      Sqlite3.testcase<bool>(num1 - (long) num2 == (long) int.MaxValue);
      if (num1 - (long) num2 > (long) int.MaxValue)
        return false;
      if (num2 != 0)
        num1 = -num1;
      pValue = (int) num1;
      return true;
    }

    private static int sqlite3Atoi(string z)
    {
      int pValue = 0;
      if (!string.IsNullOrEmpty(z))
        Sqlite3.sqlite3GetInt32(z, ref pValue);
      return pValue;
    }

    private static int getVarint(byte[] p, out uint v)
    {
      v = (uint) p[0];
      if (v <= (uint) sbyte.MaxValue)
        return 1;
      ulong v1 = 0;
      int varint = (int) Sqlite3.sqlite3GetVarint(p, 0, out v1);
      v = (uint) v1;
      return varint;
    }

    private static int getVarint(byte[] p, int offset, out uint v)
    {
      v = (uint) p[offset];
      if (v <= (uint) sbyte.MaxValue)
        return 1;
      ulong v1 = 0;
      int varint = (int) Sqlite3.sqlite3GetVarint(p, offset, out v1);
      v = (uint) v1;
      return varint;
    }

    private static int getVarint(byte[] p, int offset, out int v)
    {
      v = (int) p[offset];
      if (v <= (int) sbyte.MaxValue)
        return 1;
      ulong v1 = 0;
      int varint = (int) Sqlite3.sqlite3GetVarint(p, offset, out v1);
      v = (int) v1;
      return varint;
    }

    private static int getVarint(byte[] p, int offset, out long v)
    {
      v = offset >= p.Length ? 0L : (long) p[offset];
      if (v <= (long) sbyte.MaxValue)
        return 1;
      if (offset + 1 >= p.Length)
      {
        v = (long) ushort.MaxValue;
        return 2;
      }
      ulong v1 = 0;
      int varint = (int) Sqlite3.sqlite3GetVarint(p, offset, out v1);
      v = (long) v1;
      return varint;
    }

    private static int getVarint(byte[] p, int offset, out ulong v)
    {
      v = (ulong) p[offset];
      return v <= (ulong) sbyte.MaxValue ? 1 : (int) Sqlite3.sqlite3GetVarint(p, offset, out v);
    }

    private static int getVarint32(byte[] p, out uint v)
    {
      v = (uint) p[0];
      return v <= (uint) sbyte.MaxValue ? 1 : (int) Sqlite3.sqlite3GetVarint32(p, 0, out v);
    }

    private static int getVarint32(string s, uint offset, out int v)
    {
      v = (int) s[(int) offset];
      if (v <= (int) sbyte.MaxValue)
        return 1;
      Sqlite3.pByte4[0] = (byte) s[(int) offset];
      Sqlite3.pByte4[1] = (byte) s[(int) offset + 1];
      Sqlite3.pByte4[2] = (byte) s[(int) offset + 2];
      Sqlite3.pByte4[3] = (byte) s[(int) offset + 3];
      uint v1 = 0;
      int varint32 = (int) Sqlite3.sqlite3GetVarint32(Sqlite3.pByte4, 0, out v1);
      v = (int) v1;
      return (int) Sqlite3.sqlite3GetVarint32(Sqlite3.pByte4, 0, out v);
    }

    private static int getVarint32(string s, uint offset, out uint v)
    {
      v = (uint) s[(int) offset];
      if (v <= (uint) sbyte.MaxValue)
        return 1;
      Sqlite3.pByte4[0] = (byte) s[(int) offset];
      Sqlite3.pByte4[1] = (byte) s[(int) offset + 1];
      Sqlite3.pByte4[2] = (byte) s[(int) offset + 2];
      Sqlite3.pByte4[3] = (byte) s[(int) offset + 3];
      return (int) Sqlite3.sqlite3GetVarint32(Sqlite3.pByte4, 0, out v);
    }

    private static int getVarint32(byte[] p, uint offset, out uint v)
    {
      v = (uint) p[(int) offset];
      return v <= (uint) sbyte.MaxValue ? 1 : (int) Sqlite3.sqlite3GetVarint32(p, (int) offset, out v);
    }

    private static int getVarint32(byte[] p, int offset, out uint v)
    {
      v = offset >= p.Length ? 0U : (uint) p[offset];
      return v <= (uint) sbyte.MaxValue ? 1 : (int) Sqlite3.sqlite3GetVarint32(p, offset, out v);
    }

    private static int getVarint32(byte[] p, int offset, out int v)
    {
      v = (int) p[offset];
      if (v <= (int) sbyte.MaxValue)
        return 1;
      uint v1 = 0;
      int varint32 = (int) Sqlite3.sqlite3GetVarint32(p, offset, out v1);
      v = (int) v1;
      return varint32;
    }

    private static int putVarint(byte[] p, int offset, int v) => Sqlite3.putVarint(p, offset, (ulong) v);

    private static int putVarint(byte[] p, int offset, ulong v) => Sqlite3.sqlite3PutVarint(p, offset, v);

    private static int sqlite3PutVarint(byte[] p, int offset, int v) => Sqlite3.sqlite3PutVarint(p, offset, (ulong) v);

    private static int sqlite3PutVarint(byte[] p, int offset, ulong v)
    {
      if (((long) v & -72057594037927936L) != 0L)
      {
        p[offset + 8] = (byte) v;
        v >>= 8;
        for (int index = 7; index >= 0; --index)
        {
          p[offset + index] = (byte) (v & (ulong) sbyte.MaxValue | 128UL);
          v >>= 7;
        }
        return 9;
      }
      int num1 = 0;
      do
      {
        Sqlite3.bufByte10[num1++] = (byte) (v & (ulong) sbyte.MaxValue | 128UL);
        v >>= 7;
      }
      while (v != 0UL);
      Sqlite3.bufByte10[0] &= (byte) 127;
      int num2 = 0;
      int index1 = num1 - 1;
      while (index1 >= 0)
      {
        p[offset + num2] = Sqlite3.bufByte10[index1];
        --index1;
        ++num2;
      }
      return num1;
    }

    private static int putVarint32(byte[] p, int offset, int v)
    {
      if ((v & (int) sbyte.MinValue) == 0)
      {
        p[offset] = (byte) v;
        return 1;
      }
      if ((v & -16384) != 0)
        return Sqlite3.sqlite3PutVarint(p, offset, v);
      p[offset] = (byte) (v >> 7 | 128);
      p[offset + 1] = (byte) (v & (int) sbyte.MaxValue);
      return 2;
    }

    private static int putVarint32(byte[] p, int v)
    {
      if ((v & (int) sbyte.MinValue) == 0)
      {
        p[0] = (byte) v;
        return 1;
      }
      if ((v & -16384) != 0)
        return Sqlite3.sqlite3PutVarint(p, 0, v);
      p[0] = (byte) (v >> 7 | 128);
      p[1] = (byte) (v & (int) sbyte.MaxValue);
      return 2;
    }

    private static byte sqlite3GetVarint(byte[] p, int offset, out ulong v)
    {
      uint num1 = (uint) p[offset];
      if (((int) num1 & 128) == 0)
      {
        v = (ulong) num1;
        return 1;
      }
      uint num2 = (uint) p[offset + 1];
      if (((int) num2 & 128) == 0)
      {
        uint num3 = (num1 & (uint) sbyte.MaxValue) << 7 | num2;
        v = (ulong) num3;
        return 2;
      }
      uint num4 = num1 << 14 | (uint) p[offset + 2];
      if (((int) num4 & 128) == 0)
      {
        uint num5 = num4 & 2080895U | (num2 & (uint) sbyte.MaxValue) << 7;
        v = (ulong) num5;
        return 3;
      }
      uint num6 = num4 & 2080895U;
      uint num7 = num2 << 14 | (uint) p[offset + 3];
      if (((int) num7 & 128) == 0)
      {
        uint num8 = num7 & 2080895U;
        uint num9 = num6 << 7 | num8;
        v = (ulong) num9;
        return 4;
      }
      uint num10 = num7 & 2080895U;
      uint num11 = num6;
      uint num12 = num6 << 14 | (uint) p[offset + 4];
      if (((int) num12 & 128) == 0)
      {
        uint num13 = num10 << 7;
        uint num14 = num12 | num13;
        uint num15 = num11 >> 18;
        v = (ulong) num15 << 32 | (ulong) num14;
        return 5;
      }
      uint num16 = num11 << 7 | num10;
      uint num17 = num10 << 14 | (uint) p[offset + 5];
      if (((int) num17 & 128) == 0)
      {
        uint num18 = (num12 & 2080895U) << 7 | num17;
        uint num19 = num16 >> 18;
        v = (ulong) num19 << 32 | (ulong) num18;
        return 6;
      }
      uint num20 = num12 << 14 | (uint) p[offset + 6];
      if (((int) num20 & 128) == 0)
      {
        uint num21 = num20 & 4028612735U | (num17 & 2080895U) << 7;
        uint num22 = num16 >> 11;
        v = (ulong) num22 << 32 | (ulong) num21;
        return 7;
      }
      uint num23 = num20 & 2080895U;
      uint num24 = num17 << 14 | (uint) p[offset + 7];
      if (((int) num24 & 128) == 0)
      {
        uint num25 = num24 & 4028612735U;
        uint num26 = num23 << 7 | num25;
        uint num27 = num16 >> 4;
        v = (ulong) num27 << 32 | (ulong) num26;
        return 8;
      }
      uint num28 = num23 << 15 | (uint) p[offset + 8] | (num24 & 2080895U) << 8;
      uint num29 = num16 << 4 | ((uint) p[offset + 4] & (uint) sbyte.MaxValue) >> 3;
      v = (ulong) num29 << 32 | (ulong) num28;
      return 9;
    }

    private static byte sqlite3GetVarint32(byte[] p, out int v)
    {
      uint v1 = 0;
      int varint32 = (int) Sqlite3.sqlite3GetVarint32(p, 0, out v1);
      v = (int) v1;
      return (byte) varint32;
    }

    private static byte sqlite3GetVarint32(byte[] p, int offset, out int v)
    {
      uint v1 = 0;
      int varint32 = (int) Sqlite3.sqlite3GetVarint32(p, offset, out v1);
      v = (int) v1;
      return (byte) varint32;
    }

    private static byte sqlite3GetVarint32(byte[] p, out uint v) => Sqlite3.sqlite3GetVarint32(p, 0, out v);

    private static byte sqlite3GetVarint32(byte[] p, int offset, out uint v)
    {
      uint num1 = (uint) p[offset];
      uint num2 = offset + 1 < p.Length ? (uint) p[offset + 1] : 0U;
      if (((int) num2 & 128) == 0)
      {
        uint num3 = (num1 & (uint) sbyte.MaxValue) << 7;
        v = num3 | num2;
        return 2;
      }
      uint num4 = num1 << 14 | (offset + 2 < p.Length ? (uint) p[offset + 2] : 0U);
      if (((int) num4 & 128) == 0)
      {
        uint num5 = num4 & 2080895U;
        uint num6 = (num2 & (uint) sbyte.MaxValue) << 7;
        v = num5 | num6;
        return 3;
      }
      ulong v1 = 0;
      int varint = (int) Sqlite3.sqlite3GetVarint(p, offset, out v1);
      if (((long) v1 & (long) uint.MaxValue) != (long) v1)
      {
        v = uint.MaxValue;
        return (byte) varint;
      }
      v = (uint) v1;
      return (byte) varint;
    }

    private static int sqlite3VarintLen(ulong v)
    {
      int num = 0;
      do
      {
        ++num;
        v >>= 7;
      }
      while (v != 0UL && Sqlite3.ALWAYS(num < 9));
      return num;
    }

    private static uint sqlite3Get4byte(byte[] p, int p_offset, int offset)
    {
      offset += p_offset;
      return offset + 3 <= p.Length ? (uint) ((int) p[offset] << 24 | (int) p[1 + offset] << 16 | (int) p[2 + offset] << 8) | (uint) p[3 + offset] : 0U;
    }

    private static uint sqlite3Get4byte(byte[] p, int offset) => offset + 3 <= p.Length ? (uint) ((int) p[offset] << 24 | (int) p[1 + offset] << 16 | (int) p[2 + offset] << 8) | (uint) p[3 + offset] : 0U;

    private static uint sqlite3Get4byte(byte[] p, uint offset) => (long) (offset + 3U) <= (long) p.Length ? (uint) ((int) p[(int) offset] << 24 | (int) p[1 + (int) offset] << 16 | (int) p[2 + (int) offset] << 8) | (uint) p[3 + (int) offset] : 0U;

    private static uint sqlite3Get4byte(byte[] p) => (uint) ((int) p[0] << 24 | (int) p[1] << 16 | (int) p[2] << 8) | (uint) p[3];

    private static void sqlite3Put4byte(byte[] p, int v)
    {
      p[0] = (byte) (v >> 24 & (int) byte.MaxValue);
      p[1] = (byte) (v >> 16 & (int) byte.MaxValue);
      p[2] = (byte) (v >> 8 & (int) byte.MaxValue);
      p[3] = (byte) (v & (int) byte.MaxValue);
    }

    private static void sqlite3Put4byte(byte[] p, int offset, int v)
    {
      p[offset] = (byte) (v >> 24 & (int) byte.MaxValue);
      p[1 + offset] = (byte) (v >> 16 & (int) byte.MaxValue);
      p[2 + offset] = (byte) (v >> 8 & (int) byte.MaxValue);
      p[3 + offset] = (byte) (v & (int) byte.MaxValue);
    }

    private static void sqlite3Put4byte(byte[] p, uint offset, uint v)
    {
      p[(int) offset] = (byte) (v >> 24 & (uint) byte.MaxValue);
      p[1 + (int) offset] = (byte) (v >> 16 & (uint) byte.MaxValue);
      p[2 + (int) offset] = (byte) (v >> 8 & (uint) byte.MaxValue);
      p[3 + (int) offset] = (byte) (v & (uint) byte.MaxValue);
    }

    private static void sqlite3Put4byte(byte[] p, int offset, ulong v)
    {
      p[offset] = (byte) (v >> 24 & (ulong) byte.MaxValue);
      p[1 + offset] = (byte) (v >> 16 & (ulong) byte.MaxValue);
      p[2 + offset] = (byte) (v >> 8 & (ulong) byte.MaxValue);
      p[3 + offset] = (byte) (v & (ulong) byte.MaxValue);
    }

    private static void sqlite3Put4byte(byte[] p, ulong v)
    {
      p[0] = (byte) (v >> 24 & (ulong) byte.MaxValue);
      p[1] = (byte) (v >> 16 & (ulong) byte.MaxValue);
      p[2] = (byte) (v >> 8 & (ulong) byte.MaxValue);
      p[3] = (byte) (v & (ulong) byte.MaxValue);
    }

    private static int sqlite3HexToInt(int h)
    {
      h += 9 * (1 & h >> 6);
      return h & 15;
    }

    private static byte[] sqlite3HexToBlob(Sqlite3.sqlite3 db, string z, int n)
    {
      StringBuilder stringBuilder = new StringBuilder(n / 2 + 1);
      --n;
      if (stringBuilder != null)
      {
        for (int index = 0; index < n; index += 2)
          stringBuilder.Append(Convert.ToChar(Sqlite3.sqlite3HexToInt((int) z[index]) << 4 | Sqlite3.sqlite3HexToInt((int) z[index + 1])));
      }
      return Encoding.UTF8.GetBytes(stringBuilder.ToString());
    }

    private static void logBadConnection(string zType) => Sqlite3.sqlite3_log(21, "API call with %s database connection pointer", (object) zType);

    private static bool sqlite3SafetyCheckOk(Sqlite3.sqlite3 db)
    {
      if (db == null)
      {
        Sqlite3.logBadConnection("NULL");
        return false;
      }
      if (db.magic == 271165079U)
        return true;
      if (Sqlite3.sqlite3SafetyCheckSickOrOk(db))
      {
        Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
        Sqlite3.logBadConnection("unopened");
      }
      return false;
    }

    private static bool sqlite3SafetyCheckSickOrOk(Sqlite3.sqlite3 db)
    {
      switch (db.magic)
      {
        case 271165079:
        case 997659280:
        case 1077639430:
          return true;
        default:
          Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
          Sqlite3.logBadConnection("invalid");
          return false;
      }
    }

    private static int sqlite3AddInt64(ref long pA, long iB)
    {
      long num = pA;
      Sqlite3.testcase<bool>(num == 0L);
      Sqlite3.testcase<bool>(num == 1L);
      Sqlite3.testcase<bool>(iB == -1L);
      Sqlite3.testcase<bool>(iB == 0L);
      if (iB >= 0L)
      {
        Sqlite3.testcase<bool>(num > 0L && long.MaxValue - num == iB);
        Sqlite3.testcase<bool>(num > 0L && long.MaxValue - num == iB - 1L);
        if (num > 0L && long.MaxValue - num < iB)
          return 1;
        pA += iB;
      }
      else
      {
        Sqlite3.testcase<bool>(num < 0L && -(num + long.MaxValue) == iB + 1L);
        Sqlite3.testcase<bool>(num < 0L && -(num + long.MaxValue) == iB + 2L);
        if (num < 0L && -(num + long.MaxValue) > iB + 1L)
          return 1;
        pA += iB;
      }
      return 0;
    }

    private static int sqlite3SubInt64(ref long pA, long iB)
    {
      Sqlite3.testcase<bool>(iB == -9223372036854775807L);
      if (iB != long.MinValue)
        return Sqlite3.sqlite3AddInt64(ref pA, -iB);
      Sqlite3.testcase<bool>(pA == -1L);
      Sqlite3.testcase<bool>(pA == 0L);
      if (pA >= 0L)
        return 1;
      pA -= iB;
      return 0;
    }

    private static int sqlite3MulInt64(ref long pA, long iB)
    {
      long num1 = pA;
      long num2 = num1 / 4294967296L;
      long num3 = num1 % 4294967296L;
      long num4 = iB / 4294967296L;
      long num5 = iB % 4294967296L;
      if (num2 * num4 != 0L)
        return 1;
      long num6 = num2 * num5 + num3 * num4;
      Sqlite3.testcase<bool>(num6 == -2147483649L);
      Sqlite3.testcase<bool>(num6 == (long) int.MinValue);
      Sqlite3.testcase<bool>(num6 == 2147483648L);
      Sqlite3.testcase<bool>(num6 == (long) int.MaxValue);
      if (num6 < (long) int.MinValue || num6 >= 2147483648L)
        return 1;
      long pA1 = num6 * 4294967296L;
      if (Sqlite3.sqlite3AddInt64(ref pA1, num3 * num5) != 0)
        return 1;
      pA = pA1;
      return 0;
    }

    private static int sqlite3AbsInt32(int x)
    {
      if (x >= 0)
        return x;
      return x == int.MinValue ? int.MaxValue : -x;
    }

    private static int vacuumFinalize(Sqlite3.sqlite3 db, Sqlite3.Vdbe pStmt, string pzErrMsg)
    {
      int num = Sqlite3.sqlite3VdbeFinalize(ref pStmt);
      if (num != 0)
        Sqlite3.sqlite3SetString(ref pzErrMsg, db, Sqlite3.sqlite3_errmsg(db));
      return num;
    }

    private static int execSql(Sqlite3.sqlite3 db, string pzErrMsg, string zSql)
    {
      Sqlite3.Vdbe ppStmt = (Sqlite3.Vdbe) null;
      if (zSql == null)
        return 7;
      if (Sqlite3.sqlite3_prepare(db, zSql, -1, ref ppStmt, 0) != 0)
      {
        Sqlite3.sqlite3SetString(ref pzErrMsg, db, Sqlite3.sqlite3_errmsg(db));
        return Sqlite3.sqlite3_errcode(db);
      }
      Sqlite3.sqlite3_step(ppStmt);
      return Sqlite3.vacuumFinalize(db, ppStmt, pzErrMsg);
    }

    private static int execExecSql(Sqlite3.sqlite3 db, string pzErrMsg, string zSql)
    {
      Sqlite3.Vdbe ppStmt = (Sqlite3.Vdbe) null;
      int num1 = Sqlite3.sqlite3_prepare(db, zSql, -1, ref ppStmt, 0);
      if (num1 != 0)
        return num1;
      while (100 == Sqlite3.sqlite3_step(ppStmt))
      {
        int num2 = Sqlite3.execSql(db, pzErrMsg, Sqlite3.sqlite3_column_text(ppStmt, 0));
        if (num2 != 0)
        {
          Sqlite3.vacuumFinalize(db, ppStmt, pzErrMsg);
          return num2;
        }
      }
      return Sqlite3.vacuumFinalize(db, ppStmt, pzErrMsg);
    }

    private static void sqlite3Vacuum(Sqlite3.Parse pParse)
    {
      Sqlite3.Vdbe vdbe = Sqlite3.sqlite3GetVdbe(pParse);
      if (vdbe == null)
        return;
      Sqlite3.sqlite3VdbeAddOp2(vdbe, 120, 0, 0);
    }

    private static int sqlite3RunVacuum(ref string pzErrMsg, Sqlite3.sqlite3 db)
    {
      Sqlite3.Db db1 = (Sqlite3.Db) null;
      if (db.autoCommit == (byte) 0)
      {
        Sqlite3.sqlite3SetString(ref pzErrMsg, db, "cannot VACUUM from within a transaction");
        return 1;
      }
      if (db.activeVdbeCnt > 1)
      {
        Sqlite3.sqlite3SetString(ref pzErrMsg, db, "cannot VACUUM - SQL statements in progress");
        return 1;
      }
      int flags = db.flags;
      int nChange = db.nChange;
      int nTotalChange = db.nTotalChange;
      Sqlite3.dxTrace xTrace = db.xTrace;
      db.flags |= 268763136;
      db.flags &= -83886081;
      db.xTrace = (Sqlite3.dxTrace) null;
      Sqlite3.Btree pBt1 = db.aDb[0].pBt;
      bool flag = Sqlite3.sqlite3PagerIsMemdb(Sqlite3.sqlite3BtreePager(pBt1));
      int nDb = db.nDb;
      string zSql = !Sqlite3.sqlite3TempInMemory(db) ? "ATTACH '' AS vacuum_db;" : "ATTACH ':memory:' AS vacuum_db;";
      int num = Sqlite3.execSql(db, pzErrMsg, zSql);
      if (db.nDb > nDb)
        db1 = db.aDb[db.nDb - 1];
      if (num == 0)
      {
        db1 = db.aDb[db.nDb - 1];
        Sqlite3.Btree pBt2 = db.aDb[db.nDb - 1].pBt;
        Sqlite3.sqlite3BtreeCommit(pBt2);
        int reserve = Sqlite3.sqlite3BtreeGetReserve(pBt1);
        if (db.nextPagesize != 0)
        {
          int nKey;
          Sqlite3.sqlite3CodecGetKey(db, 0, out string _, out nKey);
          if (nKey != 0)
            db.nextPagesize = 0;
        }
        if (Sqlite3.sqlite3PagerGetJournalMode(Sqlite3.sqlite3BtreePager(pBt1)) == 5)
          db.nextPagesize = 0;
        if (Sqlite3.sqlite3BtreeSetPageSize(pBt2, Sqlite3.sqlite3BtreeGetPageSize(pBt1), reserve, 0) != 0 || !flag && Sqlite3.sqlite3BtreeSetPageSize(pBt2, db.nextPagesize, reserve, 0) != 0)
        {
          num = 7;
        }
        else
        {
          num = Sqlite3.execSql(db, pzErrMsg, "PRAGMA vacuum_db.synchronous=OFF");
          if (num == 0)
          {
            Sqlite3.sqlite3BtreeSetAutoVacuum(pBt2, db.nextAutovac >= 0 ? db.nextAutovac : Sqlite3.sqlite3BtreeGetAutoVacuum(pBt1));
            num = Sqlite3.execSql(db, pzErrMsg, "BEGIN EXCLUSIVE;");
            if (num == 0)
            {
              num = Sqlite3.execExecSql(db, pzErrMsg, "SELECT 'CREATE TABLE vacuum_db.' || substr(sql,14)   FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'   AND rootpage>0");
              if (num == 0)
              {
                num = Sqlite3.execExecSql(db, pzErrMsg, "SELECT 'CREATE INDEX vacuum_db.' || substr(sql,14)  FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' ");
                if (num == 0)
                {
                  num = Sqlite3.execExecSql(db, pzErrMsg, "SELECT 'CREATE UNIQUE INDEX vacuum_db.' || substr(sql,21)   FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'");
                  if (num == 0)
                  {
                    num = Sqlite3.execExecSql(db, pzErrMsg, "SELECT 'INSERT INTO vacuum_db.' || quote(name) || ' SELECT * FROM main.' || quote(name) || ';'FROM main.sqlite_master WHERE type = 'table' AND name!='sqlite_sequence'   AND rootpage>0");
                    if (num == 0)
                    {
                      num = Sqlite3.execExecSql(db, pzErrMsg, "SELECT 'DELETE FROM vacuum_db.' || quote(name) || ';' FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' ");
                      if (num == 0)
                      {
                        num = Sqlite3.execExecSql(db, pzErrMsg, "SELECT 'INSERT INTO vacuum_db.' || quote(name) || ' SELECT * FROM main.' || quote(name) || ';' FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence';");
                        if (num == 0)
                        {
                          num = Sqlite3.execSql(db, pzErrMsg, "INSERT INTO vacuum_db.sqlite_master   SELECT type, name, tbl_name, rootpage, sql    FROM main.sqlite_master   WHERE type='view' OR type='trigger'      OR (type='table' AND rootpage=0)");
                          if (num == 0)
                          {
                            uint pMeta = 0;
                            byte[] x = new byte[8]
                            {
                              (byte) 1,
                              (byte) 1,
                              (byte) 3,
                              (byte) 0,
                              (byte) 5,
                              (byte) 0,
                              (byte) 6,
                              (byte) 0
                            };
                            for (int index = 0; index < Sqlite3.ArraySize<byte>(x); index += 2)
                            {
                              Sqlite3.sqlite3BtreeGetMeta(pBt1, (int) x[index], ref pMeta);
                              num = Sqlite3.sqlite3BtreeUpdateMeta(pBt2, (int) x[index], pMeta + (uint) x[index + 1]);
                              if (Sqlite3.NEVER(num != 0))
                                goto label_30;
                            }
                            num = Sqlite3.sqlite3BtreeCopyFile(pBt1, pBt2);
                            if (num == 0)
                            {
                              num = Sqlite3.sqlite3BtreeCommit(pBt2);
                              if (num == 0)
                              {
                                Sqlite3.sqlite3BtreeSetAutoVacuum(pBt1, Sqlite3.sqlite3BtreeGetAutoVacuum(pBt2));
                                num = Sqlite3.sqlite3BtreeSetPageSize(pBt1, Sqlite3.sqlite3BtreeGetPageSize(pBt2), reserve, 1);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
label_30:
      db.flags = flags;
      db.nChange = nChange;
      db.nTotalChange = nTotalChange;
      db.xTrace = xTrace;
      Sqlite3.sqlite3BtreeSetPageSize(pBt1, -1, -1, 1);
      db.autoCommit = (byte) 1;
      if (db1 != null)
      {
        Sqlite3.sqlite3BtreeClose(ref db1.pBt);
        db1.pBt = (Sqlite3.Btree) null;
        db1.pSchema = (Sqlite3.Schema) null;
      }
      Sqlite3.sqlite3ResetInternalSchema(db, -1);
      return num;
    }

    private static bool vdbeSafety(Sqlite3.Vdbe p)
    {
      if (p.db != null)
        return false;
      Sqlite3.sqlite3_log(21, "API called with finalized prepared statement");
      return true;
    }

    private static bool vdbeSafetyNotNull(Sqlite3.Vdbe p)
    {
      if (p != null)
        return Sqlite3.vdbeSafety(p);
      Sqlite3.sqlite3_log(21, "API called with NULL prepared statement");
      return true;
    }

    public static int sqlite3_finalize(Sqlite3.Vdbe pStmt)
    {
      int num;
      if (pStmt == null)
      {
        num = 0;
      }
      else
      {
        Sqlite3.Vdbe p = pStmt;
        Sqlite3.sqlite3 db = p.db;
        if (Sqlite3.vdbeSafety(p))
          return Sqlite3.SQLITE_MISUSE_BKPT();
        Sqlite3.sqlite3_mutex_enter(Sqlite3.mutex);
        int rc = Sqlite3.sqlite3VdbeFinalize(ref p);
        num = Sqlite3.sqlite3ApiExit(db, rc);
        Sqlite3.sqlite3_mutex_leave(Sqlite3.mutex);
      }
      return num;
    }

    public static int sqlite3_reset(Sqlite3.Vdbe pStmt)
    {
      int num;
      if (pStmt == null)
      {
        num = 0;
      }
      else
      {
        Sqlite3.Vdbe p = pStmt;
        Sqlite3.sqlite3_mutex_enter(p.db.mutex);
        int rc = Sqlite3.sqlite3VdbeReset(p);
        Sqlite3.sqlite3VdbeRewind(p);
        num = Sqlite3.sqlite3ApiExit(p.db, rc);
        Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      }
      return num;
    }

    public static int sqlite3_clear_bindings(Sqlite3.Vdbe pStmt)
    {
      int num = 0;
      Sqlite3.Vdbe vdbe = pStmt;
      Sqlite3.sqlite3_mutex_enter(Sqlite3.mutex);
      for (int index = 0; index < (int) vdbe.nVar; ++index)
      {
        Sqlite3.sqlite3VdbeMemRelease(vdbe.aVar[index]);
        vdbe.aVar[index].flags = (ushort) 1;
      }
      if (vdbe.isPrepareV2 && vdbe.expmask != 0U)
        vdbe.expired = true;
      Sqlite3.sqlite3_mutex_leave(Sqlite3.mutex);
      return num;
    }

    public static byte[] sqlite3_value_blob(Sqlite3.Mem pVal)
    {
      Sqlite3.Mem x = pVal;
      if (((int) x.flags & 18) != 0)
      {
        Sqlite3.sqlite3VdbeMemExpandBlob(x);
        if (x.zBLOB == null && x.z != null)
        {
          if (x.z.Length == 0)
          {
            x.zBLOB = Sqlite3.sqlite3Malloc(1);
          }
          else
          {
            x.zBLOB = Sqlite3.sqlite3Malloc(x.z.Length);
            for (int index = 0; index < x.zBLOB.Length; ++index)
              x.zBLOB[index] = (byte) x.z[index];
          }
          x.z = (string) null;
        }
        x.flags &= (ushort) 65533;
        x.flags |= (ushort) 16;
        return x.n <= 0 ? (byte[]) null : x.zBLOB;
      }
      return Sqlite3.sqlite3_value_text(pVal) != null ? Encoding.UTF8.GetBytes(Sqlite3.sqlite3_value_text(pVal)) : (byte[]) null;
    }

    public static int sqlite3_value_bytes(Sqlite3.Mem pVal) => Sqlite3.sqlite3ValueBytes(pVal, 1);

    public static int sqlite3_value_bytes16(Sqlite3.Mem pVal) => Sqlite3.sqlite3ValueBytes(pVal, (int) Sqlite3.SQLITE_UTF16NATIVE);

    public static double sqlite3_value_double(Sqlite3.Mem pVal) => Sqlite3.sqlite3VdbeRealValue(pVal);

    public static int sqlite3_value_int(Sqlite3.Mem pVal) => (int) Sqlite3.sqlite3VdbeIntValue(pVal);

    public static long sqlite3_value_int64(Sqlite3.Mem pVal) => Sqlite3.sqlite3VdbeIntValue(pVal);

    public static string sqlite3_value_text(Sqlite3.Mem pVal) => Sqlite3.sqlite3ValueText(pVal, 1);

    public static int sqlite3_value_type(Sqlite3.Mem pval) => (int) pval.type;

    private static void setResultStrOrError(
      Sqlite3.sqlite3_context pCtx,
      string z,
      int o,
      int n,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      if (Sqlite3.sqlite3VdbeMemSetStr(pCtx.s, z, o, n, enc, xDel) != 18)
        return;
      Sqlite3.sqlite3_result_error_toobig(pCtx);
    }

    private static void setResultStrOrError(
      Sqlite3.sqlite3_context pCtx,
      string z,
      int n,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      if (Sqlite3.sqlite3VdbeMemSetStr(pCtx.s, z, n, enc, xDel) != 18)
        return;
      Sqlite3.sqlite3_result_error_toobig(pCtx);
    }

    public static void sqlite3_result_blob(
      Sqlite3.sqlite3_context pCtx,
      string z,
      int n,
      Sqlite3.dxDel xDel)
    {
      Sqlite3.setResultStrOrError(pCtx, z, n, (byte) 0, xDel);
    }

    public static void sqlite3_result_double(Sqlite3.sqlite3_context pCtx, double rVal) => Sqlite3.sqlite3VdbeMemSetDouble(pCtx.s, rVal);

    public static void sqlite3_result_error(Sqlite3.sqlite3_context pCtx, string z, int n)
    {
      Sqlite3.setResultStrOrError(pCtx, z, n, (byte) 1, Sqlite3.SQLITE_TRANSIENT);
      pCtx.isError = 1;
    }

    public static void sqlite3_result_int(Sqlite3.sqlite3_context pCtx, int iVal) => Sqlite3.sqlite3VdbeMemSetInt64(pCtx.s, (long) iVal);

    public static void sqlite3_result_int64(Sqlite3.sqlite3_context pCtx, long iVal) => Sqlite3.sqlite3VdbeMemSetInt64(pCtx.s, iVal);

    public static void sqlite3_result_null(Sqlite3.sqlite3_context pCtx) => Sqlite3.sqlite3VdbeMemSetNull(pCtx.s);

    public static void sqlite3_result_text(
      Sqlite3.sqlite3_context pCtx,
      string z,
      int o,
      int n,
      Sqlite3.dxDel xDel)
    {
      Sqlite3.setResultStrOrError(pCtx, z, o, n, (byte) 1, xDel);
    }

    public static void sqlite3_result_text(
      Sqlite3.sqlite3_context pCtx,
      StringBuilder z,
      int n,
      Sqlite3.dxDel xDel)
    {
      Sqlite3.setResultStrOrError(pCtx, z.ToString(), n, (byte) 1, xDel);
    }

    public static void sqlite3_result_text(
      Sqlite3.sqlite3_context pCtx,
      string z,
      int n,
      Sqlite3.dxDel xDel)
    {
      Sqlite3.setResultStrOrError(pCtx, z, n, (byte) 1, xDel);
    }

    public static void sqlite3_result_value(Sqlite3.sqlite3_context pCtx, Sqlite3.Mem pValue) => Sqlite3.sqlite3VdbeMemCopy(pCtx.s, pValue);

    public static void sqlite3_result_zeroblob(Sqlite3.sqlite3_context pCtx, int n) => Sqlite3.sqlite3VdbeMemSetZeroBlob(pCtx.s, n);

    public static void sqlite3_result_error_code(Sqlite3.sqlite3_context pCtx, int errCode)
    {
      pCtx.isError = errCode;
      if (((int) pCtx.s.flags & 1) == 0)
        return;
      Sqlite3.setResultStrOrError(pCtx, Sqlite3.sqlite3ErrStr(errCode), -1, (byte) 1, Sqlite3.SQLITE_STATIC);
    }

    public static void sqlite3_result_error_toobig(Sqlite3.sqlite3_context pCtx)
    {
      pCtx.isError = 1;
      Sqlite3.setResultStrOrError(pCtx, "string or blob too big", -1, (byte) 1, Sqlite3.SQLITE_STATIC);
    }

    public static void sqlite3_result_error_nomem(Sqlite3.sqlite3_context pCtx)
    {
      Sqlite3.sqlite3VdbeMemSetNull(pCtx.s);
      pCtx.isError = 7;
    }

    private static int doWalCallbacks(Sqlite3.sqlite3 db) => 0;

    private static int sqlite3Step(Sqlite3.Vdbe p)
    {
      if (p.magic != 3186757027U)
        Sqlite3.sqlite3_reset(p);
      Sqlite3.sqlite3 db = p.db;
      int num;
      if (p.pc <= 0 && p.expired)
      {
        p.rc = 17;
        num = 1;
      }
      else
      {
        if (p.pc < 0)
        {
          if (db.activeVdbeCnt == 0)
            db.u1.isInterrupted = false;
          if (db.xProfile != null && db.init.busy == (byte) 0)
            Sqlite3.sqlite3OsCurrentTimeInt64(db.pVfs, ref p.startTime);
          ++db.activeVdbeCnt;
          if (!p.readOnly)
            ++db.writeVdbeCnt;
          p.pc = 0;
        }
        if (p.explain != 0)
        {
          num = Sqlite3.sqlite3VdbeList(p);
        }
        else
        {
          ++db.vdbeExecCnt;
          num = Sqlite3.sqlite3VdbeExec(p);
          --db.vdbeExecCnt;
        }
        if (num != 100 && db.xProfile != null && db.init.busy == (byte) 0 && p.zSql != null)
        {
          long pTimeOut = 0;
          Sqlite3.sqlite3OsCurrentTimeInt64(db.pVfs, ref pTimeOut);
          db.xProfile(db.pProfileArg, p.zSql, (pTimeOut - p.startTime) * 1000000L);
        }
        if (num == 101)
        {
          p.rc = Sqlite3.doWalCallbacks(db);
          if (p.rc != 0)
            num = 1;
        }
        db.errCode = num;
        if (7 == Sqlite3.sqlite3ApiExit(p.db, p.rc))
          p.rc = 7;
      }
      if (p.isPrepareV2 && num != 100 && num != 101)
        num = db.errCode = p.rc;
      return num & db.errMask;
    }

    public static int sqlite3_step(Sqlite3.Vdbe pStmt)
    {
      int num1 = 0;
      Sqlite3.Vdbe p = pStmt;
      int num2 = 0;
      if (Sqlite3.vdbeSafetyNotNull(p))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      Sqlite3.sqlite3 db = p.db;
      Sqlite3.sqlite3_mutex_enter(db.mutex);
      int rc;
      while ((rc = Sqlite3.sqlite3Step(p)) == 17 && num2++ < 5)
      {
        int num3;
        rc = num3 = Sqlite3.sqlite3Reprepare(p);
        num1 = num3;
        if (num3 == 0)
        {
          Sqlite3.sqlite3_reset(pStmt);
          p.expired = false;
        }
        else
          break;
      }
      if (num1 != 0 && Sqlite3.ALWAYS(p.isPrepareV2) && Sqlite3.ALWAYS(db.pErr != null))
      {
        string str = Sqlite3.sqlite3_value_text(db.pErr);
        Sqlite3.sqlite3DbFree(db, ref p.zErrMsg);
        p.zErrMsg = str;
        p.rc = num1;
      }
      int num4 = Sqlite3.sqlite3ApiExit(db, rc);
      Sqlite3.sqlite3_mutex_leave(db.mutex);
      return num4;
    }

    public static object sqlite3_user_data(Sqlite3.sqlite3_context p) => p.pFunc.pUserData;

    public static Sqlite3.sqlite3 sqlite3_context_db_handle(Sqlite3.sqlite3_context p) => p.s.db;

    public static void sqlite3InvalidFunction(
      Sqlite3.sqlite3_context context,
      int NotUsed,
      Sqlite3.Mem[] NotUsed2)
    {
      string zName = context.pFunc.zName;
      Sqlite3.UNUSED_PARAMETER2<int, Sqlite3.Mem[]>(NotUsed, NotUsed2);
      string z = Sqlite3.sqlite3_mprintf("unable to use function %s in the requested context", (object) zName);
      Sqlite3.sqlite3_result_error(context, z, -1);
    }

    public static Sqlite3.Mem sqlite3_aggregate_context(Sqlite3.sqlite3_context p, int nByte)
    {
      Sqlite3.Mem pMem = p.pMem;
      Sqlite3.testcase<bool>(nByte < 0);
      if (((int) pMem.flags & 8192) == 0)
      {
        if (nByte <= 0)
        {
          Sqlite3.sqlite3VdbeMemReleaseExternal(pMem);
          pMem.flags = (ushort) 0;
          pMem.z = (string) null;
        }
        else
        {
          Sqlite3.sqlite3VdbeMemGrow(pMem, nByte, 0);
          pMem.flags = (ushort) 8192;
          pMem.u.pDef = p.pFunc;
          if (pMem.z != null)
            pMem.z = (string) null;
          pMem._Mem = Sqlite3.sqlite3Malloc(pMem._Mem);
          pMem._Mem.flags = (ushort) 0;
          pMem._Mem.z = (string) null;
        }
      }
      return pMem._Mem;
    }

    public static object sqlite3_get_auxdata(Sqlite3.sqlite3_context pCtx, int iArg)
    {
      Sqlite3.VdbeFunc pVdbeFunc = pCtx.pVdbeFunc;
      return pVdbeFunc == null || iArg >= pVdbeFunc.nAux || iArg < 0 ? (object) null : pVdbeFunc.apAux[iArg].pAux;
    }

    public static void sqlite3_set_auxdata(Sqlite3.sqlite3_context pCtx, int iArg, object pAux)
    {
      if (iArg >= 0)
      {
        Sqlite3.VdbeFunc vdbeFunc = pCtx.pVdbeFunc;
        if (vdbeFunc == null || vdbeFunc.nAux <= iArg)
        {
          int index = vdbeFunc != null ? vdbeFunc.nAux : 0;
          if (vdbeFunc == null)
          {
            vdbeFunc = new Sqlite3.VdbeFunc();
            if (vdbeFunc != null)
              pCtx.pVdbeFunc = vdbeFunc;
            else
              goto label_9;
          }
          vdbeFunc.apAux[index] = new Sqlite3.AuxData();
          vdbeFunc.nAux = iArg + 1;
          vdbeFunc.pFunc = pCtx.pFunc;
        }
        Sqlite3.AuxData auxData = vdbeFunc.apAux[iArg];
        if (auxData.pAux != null && auxData.pAux is IDisposable)
          (auxData.pAux as IDisposable).Dispose();
        auxData.pAux = pAux;
        return;
      }
label_9:
      if (pAux == null || !(pAux is IDisposable))
        return;
      (pAux as IDisposable).Dispose();
    }

    public static int sqlite3_column_count(Sqlite3.Vdbe pStmt)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      return vdbe == null ? 0 : (int) vdbe.nResColumn;
    }

    public static int sqlite3_data_count(Sqlite3.Vdbe pStmt)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      return vdbe == null || vdbe.pResultSet == null ? 0 : (int) vdbe.nResColumn;
    }

    private static Sqlite3.Mem columnMem(Sqlite3.Vdbe pStmt, int i)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      Sqlite3.Mem mem1;
      if (vdbe != null && vdbe.pResultSet != null && i < (int) vdbe.nResColumn && i >= 0)
      {
        Sqlite3.sqlite3_mutex_enter(vdbe.db.mutex);
        mem1 = vdbe.pResultSet[i];
      }
      else
      {
        Sqlite3.Mem mem2 = new Sqlite3.Mem((Sqlite3.sqlite3) null, "", 0.0, 0, 0, (ushort) 1, (byte) 5, (byte) 0);
        if (vdbe != null && Sqlite3.ALWAYS(vdbe.db != null))
        {
          Sqlite3.sqlite3_mutex_enter(vdbe.db.mutex);
          Sqlite3.sqlite3Error(vdbe.db, 25, 0);
        }
        mem1 = mem2;
      }
      return mem1;
    }

    private static void columnMallocFailure(Sqlite3.Vdbe pStmt)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      if (vdbe == null)
        return;
      vdbe.rc = Sqlite3.sqlite3ApiExit(vdbe.db, vdbe.rc);
      Sqlite3.sqlite3_mutex_leave(vdbe.db.mutex);
    }

    public static byte[] sqlite3_column_blob(Sqlite3.Vdbe pStmt, int i)
    {
      byte[] numArray = Sqlite3.sqlite3_value_blob(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return numArray;
    }

    public static int sqlite3_column_bytes(Sqlite3.Vdbe pStmt, int i)
    {
      int num = Sqlite3.sqlite3_value_bytes(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return num;
    }

    public static int sqlite3_column_bytes16(Sqlite3.Vdbe pStmt, int i)
    {
      int num = Sqlite3.sqlite3_value_bytes16(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return num;
    }

    public static double sqlite3_column_double(Sqlite3.Vdbe pStmt, int i)
    {
      double num = Sqlite3.sqlite3_value_double(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return num;
    }

    public static int sqlite3_column_int(Sqlite3.Vdbe pStmt, int i)
    {
      int num = Sqlite3.sqlite3_value_int(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return num;
    }

    public static long sqlite3_column_int64(Sqlite3.Vdbe pStmt, int i)
    {
      long num = Sqlite3.sqlite3_value_int64(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return num;
    }

    public static string sqlite3_column_text(Sqlite3.Vdbe pStmt, int i)
    {
      string str = Sqlite3.sqlite3_value_text(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return str;
    }

    public static Sqlite3.Mem sqlite3_column_value(Sqlite3.Vdbe pStmt, int i)
    {
      Sqlite3.Mem mem = Sqlite3.columnMem(pStmt, i);
      if (((int) mem.flags & 2048) != 0)
      {
        mem.flags &= (ushort) 63487;
        mem.flags |= (ushort) 4096;
      }
      Sqlite3.columnMallocFailure(pStmt);
      return mem;
    }

    public static int sqlite3_column_type(Sqlite3.Vdbe pStmt, int i)
    {
      int num = Sqlite3.sqlite3_value_type(Sqlite3.columnMem(pStmt, i));
      Sqlite3.columnMallocFailure(pStmt);
      return num;
    }

    public static string columnName(
      Sqlite3.Vdbe pStmt,
      int N,
      Sqlite3.dxColname xFunc,
      int useType)
    {
      string str = (string) null;
      Sqlite3.Vdbe vdbe = pStmt;
      Sqlite3.sqlite3 db = vdbe.db;
      int num = Sqlite3.sqlite3_column_count(pStmt);
      if (N < num && N >= 0)
      {
        N += useType * num;
        Sqlite3.sqlite3_mutex_enter(db.mutex);
        str = xFunc(vdbe.aColName[N]);
        Sqlite3.sqlite3_mutex_leave(db.mutex);
      }
      return str;
    }

    public static string sqlite3_column_name(Sqlite3.Vdbe pStmt, int N) => Sqlite3.columnName(pStmt, N, new Sqlite3.dxColname(Sqlite3.sqlite3_value_text), 0);

    public static string sqlite3_column_decltype(Sqlite3.Vdbe pStmt, int N) => Sqlite3.columnName(pStmt, N, new Sqlite3.dxColname(Sqlite3.sqlite3_value_text), 1);

    public static int vdbeUnbind(Sqlite3.Vdbe p, int i)
    {
      if (Sqlite3.vdbeSafetyNotNull(p))
        return Sqlite3.SQLITE_MISUSE_BKPT();
      Sqlite3.sqlite3_mutex_enter(p.db.mutex);
      if (p.magic != 3186757027U || p.pc >= 0)
      {
        Sqlite3.sqlite3Error(p.db, 21, 0);
        Sqlite3.sqlite3_mutex_leave(p.db.mutex);
        Sqlite3.sqlite3_log(21, "bind on a busy prepared statement: [%s]", (object) p.zSql);
        return Sqlite3.SQLITE_MISUSE_BKPT();
      }
      if (i < 1 || i > (int) p.nVar)
      {
        Sqlite3.sqlite3Error(p.db, 25, 0);
        Sqlite3.sqlite3_mutex_leave(p.db.mutex);
        return 25;
      }
      --i;
      Sqlite3.Mem p1 = p.aVar[i];
      Sqlite3.sqlite3VdbeMemRelease(p1);
      p1.flags = (ushort) 1;
      Sqlite3.sqlite3Error(p.db, 0, 0);
      if (p.isPrepareV2 && (i < 32 && p.expmask > 0U & 1 << i != 0 || p.expmask == uint.MaxValue))
        p.expired = true;
      return 0;
    }

    private static int bindBlob(
      Sqlite3.Vdbe pStmt,
      int i,
      byte[] zData,
      int nData,
      Sqlite3.dxDel xDel,
      byte encoding)
    {
      Sqlite3.Vdbe p = pStmt;
      int num1 = Sqlite3.vdbeUnbind(p, i);
      if (num1 == 0)
      {
        if (zData != null)
        {
          Sqlite3.Mem pMem = p.aVar[i - 1];
          int num2 = Sqlite3.sqlite3VdbeMemSetBlob(pMem, zData, nData, encoding, xDel);
          if (num2 == 0 && encoding != (byte) 0)
            num2 = Sqlite3.sqlite3VdbeChangeEncoding(pMem, (int) Sqlite3.ENC(p.db));
          Sqlite3.sqlite3Error(p.db, num2, 0);
          num1 = Sqlite3.sqlite3ApiExit(p.db, num2);
        }
        Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      }
      return num1;
    }

    public static int bindText(
      Sqlite3.Vdbe pStmt,
      int i,
      string zData,
      int nData,
      Sqlite3.dxDel xDel,
      byte encoding)
    {
      Sqlite3.Vdbe p = pStmt;
      int num1 = Sqlite3.vdbeUnbind(p, i);
      if (num1 == 0)
      {
        if (zData != null)
        {
          Sqlite3.Mem pMem = p.aVar[i - 1];
          int num2 = Sqlite3.sqlite3VdbeMemSetStr(pMem, zData, nData, encoding, xDel);
          if (num2 == 0 && encoding != (byte) 0)
            num2 = Sqlite3.sqlite3VdbeChangeEncoding(pMem, (int) Sqlite3.ENC(p.db));
          Sqlite3.sqlite3Error(p.db, num2, 0);
          num1 = Sqlite3.sqlite3ApiExit(p.db, num2);
        }
        Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      }
      else if (xDel != Sqlite3.SQLITE_STATIC && xDel != Sqlite3.SQLITE_TRANSIENT)
        xDel(ref zData);
      return num1;
    }

    public static int sqlite3_bind_double(Sqlite3.Vdbe pStmt, int i, double rValue)
    {
      Sqlite3.Vdbe p = pStmt;
      int num = Sqlite3.vdbeUnbind(p, i);
      if (num != 0)
        return num;
      Sqlite3.sqlite3VdbeMemSetDouble(p.aVar[i - 1], rValue);
      Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      return num;
    }

    public static int sqlite3_bind_int(Sqlite3.Vdbe p, int i, int iValue) => Sqlite3.sqlite3_bind_int64(p, i, (long) iValue);

    public static int sqlite3_bind_int64(Sqlite3.Vdbe pStmt, int i, long iValue)
    {
      Sqlite3.Vdbe p = pStmt;
      int num = Sqlite3.vdbeUnbind(p, i);
      if (num != 0)
        return num;
      Sqlite3.sqlite3VdbeMemSetInt64(p.aVar[i - 1], iValue);
      Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      return num;
    }

    public static int sqlite3_bind_null(Sqlite3.Vdbe pStmt, int i)
    {
      Sqlite3.Vdbe p = pStmt;
      int num = Sqlite3.vdbeUnbind(p, i);
      if (num != 0)
        return num;
      Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      return num;
    }

    public static int sqlite3_bind_text(
      Sqlite3.Vdbe pStmt,
      int i,
      string zData,
      int nData,
      Sqlite3.dxDel xDel)
    {
      return Sqlite3.bindText(pStmt, i, zData, nData, xDel, (byte) 1);
    }

    public static int sqlite3_bind_blob(
      Sqlite3.Vdbe pStmt,
      int i,
      byte[] zData,
      int nData,
      Sqlite3.dxDel xDel)
    {
      return Sqlite3.bindBlob(pStmt, i, zData, nData >= 0 ? nData : zData.Length, xDel, (byte) 0);
    }

    public static int sqlite3_bind_value(Sqlite3.Vdbe pStmt, int i, Sqlite3.Mem pValue)
    {
      int num;
      switch (pValue.type)
      {
        case 1:
          num = Sqlite3.sqlite3_bind_int64(pStmt, i, pValue.u.i);
          break;
        case 2:
          num = Sqlite3.sqlite3_bind_double(pStmt, i, pValue.r);
          break;
        case 3:
          num = Sqlite3.bindText(pStmt, i, pValue.z, pValue.n, Sqlite3.SQLITE_TRANSIENT, pValue.enc);
          break;
        case 4:
          num = ((int) pValue.flags & 0) == 0 ? Sqlite3.sqlite3_bind_blob(pStmt, i, pValue.zBLOB, pValue.n, Sqlite3.SQLITE_TRANSIENT) : Sqlite3.sqlite3_bind_zeroblob(pStmt, i, pValue.u.nZero);
          break;
        default:
          num = Sqlite3.sqlite3_bind_null(pStmt, i);
          break;
      }
      return num;
    }

    public static int sqlite3_bind_zeroblob(Sqlite3.Vdbe pStmt, int i, int n)
    {
      Sqlite3.Vdbe p = pStmt;
      int num = Sqlite3.vdbeUnbind(p, i);
      if (num != 0)
        return num;
      Sqlite3.sqlite3VdbeMemSetZeroBlob(p.aVar[i - 1], n);
      Sqlite3.sqlite3_mutex_leave(p.db.mutex);
      return num;
    }

    public static int sqlite3_bind_parameter_count(Sqlite3.Vdbe pStmt)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      return vdbe == null ? 0 : (int) vdbe.nVar;
    }

    public static string sqlite3_bind_parameter_name(Sqlite3.Vdbe pStmt, int i)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      return vdbe == null || i < 1 || i > (int) vdbe.nzVar ? "" : vdbe.azVar[i - 1];
    }

    public static int sqlite3VdbeParameterIndex(Sqlite3.Vdbe p, string zName, int nName)
    {
      if (p == null || zName == null || !(zName != ""))
        return 0;
      for (int index = 0; index < (int) p.nzVar; ++index)
      {
        string str = p.azVar[index];
        if (str != null && str == zName)
          return index + 1;
      }
      return 0;
    }

    public static int sqlite3_bind_parameter_index(Sqlite3.Vdbe pStmt, string zName) => Sqlite3.sqlite3VdbeParameterIndex(pStmt, zName, Sqlite3.sqlite3Strlen30(zName));

    public static int sqlite3TransferBindings(Sqlite3.Vdbe pFromStmt, Sqlite3.Vdbe pToStmt)
    {
      Sqlite3.Vdbe vdbe1 = pFromStmt;
      Sqlite3.Vdbe vdbe2 = pToStmt;
      Sqlite3.sqlite3_mutex_enter(vdbe2.db.mutex);
      for (int index = 0; index < (int) vdbe1.nVar; ++index)
        Sqlite3.sqlite3VdbeMemMove(vdbe2.aVar[index], vdbe1.aVar[index]);
      Sqlite3.sqlite3_mutex_leave(vdbe2.db.mutex);
      return 0;
    }

    public static Sqlite3.sqlite3 sqlite3_db_handle(Sqlite3.Vdbe pStmt) => pStmt?.db;

    private static bool sqlite3_stmt_readonly(Sqlite3.Vdbe pStmt) => pStmt == null || pStmt.readOnly;

    public static Sqlite3.Vdbe sqlite3_next_stmt(Sqlite3.sqlite3 pDb, Sqlite3.Vdbe pStmt)
    {
      Sqlite3.sqlite3_mutex_enter(pDb.mutex);
      Sqlite3.Vdbe vdbe = pStmt != null ? pStmt.pNext : pDb.pVdbe;
      Sqlite3.sqlite3_mutex_leave(pDb.mutex);
      return vdbe;
    }

    public static int sqlite3_stmt_status(Sqlite3.Vdbe pStmt, int op, int resetFlag)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      int num = vdbe.aCounter[op - 1];
      if (resetFlag == 0)
        return num;
      vdbe.aCounter[op - 1] = 0;
      return num;
    }

    private static Sqlite3.Vdbe sqlite3VdbeCreate(Sqlite3.sqlite3 db)
    {
      Sqlite3.Vdbe vdbe = new Sqlite3.Vdbe();
      if (vdbe == null)
        return (Sqlite3.Vdbe) null;
      vdbe.db = db;
      if (db.pVdbe != null)
        db.pVdbe.pPrev = vdbe;
      vdbe.pNext = db.pVdbe;
      vdbe.pPrev = (Sqlite3.Vdbe) null;
      db.pVdbe = vdbe;
      vdbe.magic = 649915045U;
      return vdbe;
    }

    private static void sqlite3VdbeSetSql(Sqlite3.Vdbe p, string z, int n, int isPrepareV2)
    {
      if (p == null)
        return;
      p.zSql = z.Substring(0, n);
      p.isPrepareV2 = isPrepareV2 != 0;
    }

    private static string sqlite3_sql(Sqlite3.Vdbe pStmt)
    {
      Sqlite3.Vdbe vdbe = pStmt;
      return vdbe == null || !vdbe.isPrepareV2 ? "" : vdbe.zSql;
    }

    private static void sqlite3VdbeSwap(Sqlite3.Vdbe pA, Sqlite3.Vdbe pB)
    {
      Sqlite3.Vdbe ct = new Sqlite3.Vdbe();
      Sqlite3.Vdbe vdbe = new Sqlite3.Vdbe();
      pA.CopyTo(ct);
      pB.CopyTo(pA);
      ct.CopyTo(pB);
      Sqlite3.Vdbe pNext = pA.pNext;
      pA.pNext = pB.pNext;
      pB.pNext = pNext;
      Sqlite3.Vdbe pPrev = pA.pPrev;
      pA.pPrev = pB.pPrev;
      pB.pPrev = pPrev;
      string zSql = pA.zSql;
      pA.zSql = pB.zSql;
      pB.zSql = zSql;
      pB.isPrepareV2 = pA.isPrepareV2;
    }

    private static int growOpArray(Sqlite3.Vdbe p)
    {
      int newSize = p.nOpAlloc != 0 ? p.nOpAlloc * 2 : 256;
      p.nOpAlloc = newSize;
      if (p.aOp == null)
        p.aOp = new Sqlite3.VdbeOp[newSize];
      else
        Array.Resize<Sqlite3.VdbeOp>(ref p.aOp, newSize);
      return p.aOp == null ? 7 : 0;
    }

    private static int sqlite3VdbeAddOp3(Sqlite3.Vdbe p, int op, int p1, int p2, int p3)
    {
      int nOp = p.nOp;
      if (p.nOpAlloc <= nOp && Sqlite3.growOpArray(p) != 0)
        return 1;
      ++p.nOp;
      if (p.aOp[nOp] == null)
        p.aOp[nOp] = new Sqlite3.VdbeOp();
      Sqlite3.VdbeOp vdbeOp = p.aOp[nOp];
      vdbeOp.opcode = (byte) op;
      vdbeOp.p5 = (byte) 0;
      vdbeOp.p1 = p1;
      vdbeOp.p2 = p2;
      vdbeOp.p3 = p3;
      vdbeOp.p4.p = (object) null;
      vdbeOp.p4type = 0;
      return nOp;
    }

    private static int sqlite3VdbeAddOp0(Sqlite3.Vdbe p, int op) => Sqlite3.sqlite3VdbeAddOp3(p, op, 0, 0, 0);

    private static int sqlite3VdbeAddOp1(Sqlite3.Vdbe p, int op, int p1) => Sqlite3.sqlite3VdbeAddOp3(p, op, p1, 0, 0);

    private static int sqlite3VdbeAddOp2(Sqlite3.Vdbe p, int op, int p1, bool b2) => Sqlite3.sqlite3VdbeAddOp2(p, op, p1, b2 ? 1 : 0);

    private static int sqlite3VdbeAddOp2(Sqlite3.Vdbe p, int op, int p1, int p2) => Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, 0);

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      int pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.i = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      char pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.z = pP4.ToString();
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      StringBuilder pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.z = pP4.ToString();
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      string pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.z = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      byte[] pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.z = Encoding.UTF8.GetString(pP4, 0, pP4.Length);
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      int[] pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.ai = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      long pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.pI64 = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      double pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.pReal = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      Sqlite3.FuncDef pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.pFunc = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      Sqlite3.CollSeq pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.pColl = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static int sqlite3VdbeAddOp4(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      Sqlite3.KeyInfo pP4,
      int p4type)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.pKeyInfo = pP4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, p4type);
      return addr;
    }

    private static void sqlite3VdbeAddParseSchemaOp(Sqlite3.Vdbe p, int iDb, string zWhere)
    {
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, 99, iDb, 0, 0);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, zWhere, -1);
      for (int i = 0; i < p.db.nDb; ++i)
        Sqlite3.sqlite3VdbeUsesBtree(p, i);
    }

    private static int sqlite3VdbeAddOp4Int(
      Sqlite3.Vdbe p,
      int op,
      int p1,
      int p2,
      int p3,
      int p4)
    {
      Sqlite3.union_p4 _p4 = new Sqlite3.union_p4();
      _p4.i = p4;
      int addr = Sqlite3.sqlite3VdbeAddOp3(p, op, p1, p2, p3);
      Sqlite3.sqlite3VdbeChangeP4(p, addr, _p4, -14);
      return addr;
    }

    private static int sqlite3VdbeMakeLabel(Sqlite3.Vdbe p)
    {
      int index = p.nLabel++;
      if (index >= p.nLabelAlloc)
      {
        int num = p.nLabelAlloc == 0 ? 15 : p.nLabelAlloc * 2 + 5;
        if (p.aLabel == null)
          p.aLabel = Sqlite3.sqlite3Malloc(p.aLabel, num);
        else
          Array.Resize<int>(ref p.aLabel, num);
        p.nLabelAlloc = p.aLabel.Length;
      }
      if (p.aLabel != null)
        p.aLabel[index] = -1;
      return -1 - index;
    }

    private static void sqlite3VdbeResolveLabel(Sqlite3.Vdbe p, int x)
    {
      int index = -1 - x;
      if (p.aLabel == null)
        return;
      p.aLabel[index] = p.nOp;
    }

    private static void sqlite3VdbeRunOnlyOnce(Sqlite3.Vdbe p) => p.runOnlyOnce = (byte) 1;

    private static void resolveP2Values(Sqlite3.Vdbe p, ref int pMaxFuncArgs)
    {
      int num = pMaxFuncArgs;
      int[] aLabel = p.aLabel;
      p.readOnly = true;
      for (int index = 0; index < p.nOp; ++index)
      {
        Sqlite3.VdbeOp vdbeOp = p.aOp[index];
        byte opcode = vdbeOp.opcode;
        vdbeOp.opflags = (byte) Sqlite3.sqlite3OpcodeProperty[(int) opcode];
        if (opcode == (byte) 18 || opcode == (byte) 116)
        {
          if ((int) vdbeOp.p5 > num)
            num = (int) vdbeOp.p5;
        }
        else if (opcode == (byte) 34 && vdbeOp.p2 != 0 || opcode == (byte) 120)
          p.readOnly = false;
        if (((int) vdbeOp.opflags & 1) != 0 && vdbeOp.p2 < 0)
          vdbeOp.p2 = aLabel[-1 - vdbeOp.p2];
      }
      Sqlite3.sqlite3DbFree(p.db, ref p.aLabel);
      pMaxFuncArgs = num;
    }

    private static int sqlite3VdbeCurrentAddr(Sqlite3.Vdbe p) => p.nOp;

    private static Sqlite3.VdbeOp[] sqlite3VdbeTakeOpArray(
      Sqlite3.Vdbe p,
      ref int pnOp,
      ref int pnMaxArg)
    {
      Sqlite3.VdbeOp[] aOp = p.aOp;
      Sqlite3.resolveP2Values(p, ref pnMaxArg);
      pnOp = p.nOp;
      p.aOp = (Sqlite3.VdbeOp[]) null;
      return aOp;
    }

    private static int sqlite3VdbeAddOpList(Sqlite3.Vdbe p, int nOp, Sqlite3.VdbeOpList[] aOp)
    {
      if (p.nOp + nOp > p.nOpAlloc && Sqlite3.growOpArray(p) != 0)
        return 0;
      int nOp1 = p.nOp;
      if (Sqlite3.ALWAYS(nOp > 0))
      {
        for (int index = 0; index < nOp; ++index)
        {
          Sqlite3.VdbeOpList vdbeOpList = aOp[index];
          int p2 = vdbeOpList.p2;
          if (p.aOp[index + nOp1] == null)
            p.aOp[index + nOp1] = new Sqlite3.VdbeOp();
          Sqlite3.VdbeOp vdbeOp = p.aOp[index + nOp1];
          vdbeOp.opcode = vdbeOpList.opcode;
          vdbeOp.p1 = vdbeOpList.p1;
          vdbeOp.p2 = p2 >= 0 || (Sqlite3.sqlite3OpcodeProperty[(int) vdbeOp.opcode] & 1) == 0 ? p2 : nOp1 + (-1 - p2);
          vdbeOp.p3 = vdbeOpList.p3;
          vdbeOp.p4type = 0;
          vdbeOp.p4.p = (object) null;
          vdbeOp.p5 = (byte) 0;
        }
        p.nOp += nOp;
      }
      return nOp1;
    }

    private static void sqlite3VdbeChangeP1(Sqlite3.Vdbe p, int addr, int val)
    {
      if (p.nOp <= addr)
        return;
      p.aOp[addr].p1 = val;
    }

    private static void sqlite3VdbeChangeP2(Sqlite3.Vdbe p, int addr, int val)
    {
      if (p.nOp <= addr)
        return;
      p.aOp[addr].p2 = val;
    }

    private static void sqlite3VdbeChangeP3(Sqlite3.Vdbe p, int addr, int val)
    {
      if (p.nOp <= addr)
        return;
      p.aOp[addr].p3 = val;
    }

    private static void sqlite3VdbeChangeP5(Sqlite3.Vdbe p, byte val)
    {
      if (p.aOp == null)
        return;
      p.aOp[p.nOp - 1].p5 = val;
    }

    private static void sqlite3VdbeJumpHere(Sqlite3.Vdbe p, int addr) => Sqlite3.sqlite3VdbeChangeP2(p, addr, p.nOp);

    private static void freeEphemeralFunction(Sqlite3.sqlite3 db, Sqlite3.FuncDef pDef)
    {
      if (!Sqlite3.ALWAYS<Sqlite3.FuncDef>(pDef) || ((int) pDef.flags & 4) == 0)
        return;
      pDef = (Sqlite3.FuncDef) null;
      Sqlite3.sqlite3DbFree<Sqlite3.FuncDef>(db, ref pDef);
    }

    private static void freeP4(Sqlite3.sqlite3 db, int p4type, object p4)
    {
      if (p4 == null)
        return;
      switch (p4type)
      {
        case -16:
        case -15:
        case -13:
        case -12:
        case -6:
        case -1:
          Sqlite3.sqlite3DbFree<object>(db, ref p4);
          break;
        case -11:
          if (db.pnBytesFreed != 0)
            break;
          p4 = (object) null;
          break;
        case -10:
          if (db.pnBytesFreed != 0)
            break;
          Sqlite3.sqlite3VtabUnlock((Sqlite3.VTable) p4);
          break;
        case -8:
          if (db.pnBytesFreed == 0)
          {
            p4 = (object) null;
            break;
          }
          Sqlite3.Mem pPrior = (Sqlite3.Mem) p4;
          Sqlite3.sqlite3DbFree(db, ref pPrior);
          break;
        case -7:
          Sqlite3.VdbeFunc pT = (Sqlite3.VdbeFunc) p4;
          Sqlite3.freeEphemeralFunction(db, pT.pFunc);
          if (db.pnBytesFreed == 0)
            Sqlite3.sqlite3VdbeDeleteAuxData(pT, 0);
          Sqlite3.sqlite3DbFree<Sqlite3.VdbeFunc>(db, ref pT);
          break;
        case -5:
          Sqlite3.freeEphemeralFunction(db, (Sqlite3.FuncDef) p4);
          break;
      }
    }

    private static void vdbeFreeOpArray(Sqlite3.sqlite3 db, ref Sqlite3.VdbeOp[] aOp, int nOp)
    {
      if (aOp == null)
        return;
      aOp = (Sqlite3.VdbeOp[]) null;
    }

    private static void sqlite3VdbeLinkSubProgram(Sqlite3.Vdbe pVdbe, Sqlite3.SubProgram p)
    {
      p.pNext = pVdbe.pProgram;
      pVdbe.pProgram = p;
    }

    private static void sqlite3VdbeChangeToNoop(Sqlite3.Vdbe p, int addr, int N)
    {
      if (p.aOp == null)
        return;
      Sqlite3.sqlite3 db = p.db;
      while (N-- > 0)
      {
        Sqlite3.VdbeOp vdbeOp = p.aOp[addr + N];
        Sqlite3.freeP4(db, vdbeOp.p4type, vdbeOp.p4.p);
        (p.aOp[addr + N] = new Sqlite3.VdbeOp()).opcode = (byte) 137;
      }
    }

    private static void sqlite3VdbeChangeP4(
      Sqlite3.Vdbe p,
      int addr,
      Sqlite3.CollSeq pColl,
      int n)
    {
      Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
      {
        pColl = pColl
      }, n);
    }

    private static void sqlite3VdbeChangeP4(
      Sqlite3.Vdbe p,
      int addr,
      Sqlite3.FuncDef pFunc,
      int n)
    {
      Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
      {
        pFunc = pFunc
      }, n);
    }

    private static void sqlite3VdbeChangeP4(Sqlite3.Vdbe p, int addr, int i32n, int n) => Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
    {
      i = i32n
    }, n);

    private static void sqlite3VdbeChangeP4(
      Sqlite3.Vdbe p,
      int addr,
      Sqlite3.KeyInfo pKeyInfo,
      int n)
    {
      Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
      {
        pKeyInfo = pKeyInfo
      }, n);
    }

    private static void sqlite3VdbeChangeP4(Sqlite3.Vdbe p, int addr, char c, int n) => Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
    {
      z = c.ToString()
    }, n);

    private static void sqlite3VdbeChangeP4(Sqlite3.Vdbe p, int addr, Sqlite3.Mem m, int n) => Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
    {
      pMem = m
    }, n);

    private static void sqlite3VdbeChangeP4(
      Sqlite3.Vdbe p,
      int addr,
      string z,
      Sqlite3.dxDel P4_Type)
    {
      Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
      {
        z = z
      }, -1);
    }

    private static void sqlite3VdbeChangeP4(
      Sqlite3.Vdbe p,
      int addr,
      Sqlite3.SubProgram pProgram,
      int n)
    {
      Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
      {
        pProgram = pProgram
      }, n);
    }

    private static void sqlite3VdbeChangeP4(Sqlite3.Vdbe p, int addr, string z, int n) => Sqlite3.sqlite3VdbeChangeP4(p, addr, new Sqlite3.union_p4()
    {
      z = n <= 0 || n > z.Length ? z : z.Substring(0, n)
    }, n);

    private static void sqlite3VdbeChangeP4(Sqlite3.Vdbe p, int addr, Sqlite3.union_p4 _p4, int n)
    {
      Sqlite3.sqlite3 db = p.db;
      if (p.aOp == null)
      {
        if (n == -6 || n == -10)
          return;
        Sqlite3.freeP4(db, n, (object) _p4);
      }
      else
      {
        if (addr < 0)
          addr = p.nOp - 1;
        Sqlite3.VdbeOp vdbeOp = p.aOp[addr];
        Sqlite3.freeP4(db, vdbeOp.p4type, vdbeOp.p4.p);
        vdbeOp.p4.p = (object) null;
        switch (n)
        {
          case -14:
            vdbeOp.p4.i = _p4.i;
            vdbeOp.p4type = -14;
            break;
          case -13:
            vdbeOp.p4.pI64 = _p4.pI64;
            vdbeOp.p4type = n;
            break;
          case -12:
            vdbeOp.p4.pReal = _p4.pReal;
            vdbeOp.p4type = n;
            break;
          default:
            if (_p4 == null)
            {
              vdbeOp.p4.p = (object) null;
              vdbeOp.p4type = 0;
              break;
            }
            switch (n)
            {
              case -18:
                vdbeOp.p4.pProgram = _p4.pProgram;
                vdbeOp.p4type = -18;
                return;
              case -17:
              case -16:
                vdbeOp.p4.pKeyInfo = _p4.pKeyInfo;
                vdbeOp.p4type = -6;
                return;
              case -15:
                vdbeOp.p4.ai = _p4.ai;
                vdbeOp.p4type = -15;
                return;
              case -11:
              case -2:
              case -1:
                vdbeOp.p4.z = _p4.z;
                vdbeOp.p4type = -1;
                return;
              case -10:
                vdbeOp.p4.pVtab = _p4.pVtab;
                vdbeOp.p4type = -10;
                Sqlite3.sqlite3VtabLock(_p4.pVtab);
                return;
              case -8:
                vdbeOp.p4.pMem = _p4.pMem;
                vdbeOp.p4type = -8;
                return;
              case -6:
                int nField = (int) _p4.pKeyInfo.nField;
                Sqlite3.KeyInfo keyInfo = new Sqlite3.KeyInfo();
                vdbeOp.p4.pKeyInfo = keyInfo;
                if (keyInfo != null)
                {
                  _p4.pKeyInfo.Copy();
                  vdbeOp.p4type = -6;
                }
                else
                  vdbeOp.p4type = 0;
                vdbeOp.p4.pKeyInfo = _p4.pKeyInfo;
                vdbeOp.p4type = -6;
                return;
              case -5:
                vdbeOp.p4.pFunc = _p4.pFunc;
                vdbeOp.p4type = -5;
                return;
              case -4:
                vdbeOp.p4.pColl = _p4.pColl;
                vdbeOp.p4type = -4;
                return;
              default:
                if (n < 0)
                {
                  vdbeOp.p4.p = _p4.p;
                  vdbeOp.p4type = n;
                  return;
                }
                vdbeOp.p4.z = _p4.z;
                vdbeOp.p4type = -1;
                return;
            }
        }
      }
    }

    private static Sqlite3.VdbeOp sqlite3VdbeGetOp(Sqlite3.Vdbe p, int addr)
    {
      if (addr < 0)
        addr = p.nOp - 1;
      return p.aOp[addr];
    }

    private static string displayP4(Sqlite3.VdbeOp pOp, string zBuffer, int nTemp)
    {
      Sqlite3.zTemp.Length = 0;
      switch (pOp.p4type)
      {
        case -18:
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "program");
          break;
        case -17:
        case -6:
          Sqlite3.KeyInfo pKeyInfo = pOp.p4.pKeyInfo;
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "keyinfo(%d", (object) pKeyInfo.nField);
          int num1 = Sqlite3.sqlite3Strlen30(Sqlite3.zTemp);
          for (int index = 0; index < (int) pKeyInfo.nField; ++index)
          {
            Sqlite3.CollSeq collSeq = pKeyInfo.aColl[index];
            if (collSeq != null)
            {
              int num2 = Sqlite3.sqlite3Strlen30(collSeq.zName);
              if (num1 + num2 > nTemp)
              {
                Sqlite3.zTemp.Append(",...");
                break;
              }
              Sqlite3.zTemp.Append(",");
              if (pKeyInfo.aSortOrder != null && pKeyInfo.aSortOrder[index] != (byte) 0)
                Sqlite3.zTemp.Append("-");
              Sqlite3.zTemp.Append(collSeq.zName);
              num1 += num2;
            }
            else if (num1 + 4 < nTemp)
            {
              Sqlite3.zTemp.Append(",nil");
              num1 += 4;
            }
          }
          Sqlite3.zTemp.Append(")");
          break;
        case -15:
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "intarray");
          break;
        case -14:
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "%d", (object) pOp.p4.i);
          break;
        case -13:
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "%lld", (object) pOp.p4.pI64);
          break;
        case -12:
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "%.16g", (object) pOp.p4.pReal);
          break;
        case -8:
          Sqlite3.Mem pMem = pOp.p4.pMem;
          if (((int) pMem.flags & 2) != 0)
          {
            Sqlite3.zTemp.Append(pMem.z);
            break;
          }
          if (((int) pMem.flags & 4) != 0)
          {
            Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "%lld", (object) pMem.u.i);
            break;
          }
          if (((int) pMem.flags & 8) != 0)
          {
            Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "%.16g", (object) pMem.r);
            break;
          }
          Sqlite3.zTemp = new StringBuilder("(blob)");
          break;
        case -5:
          Sqlite3.FuncDef pFunc = pOp.p4.pFunc;
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "%s(%d)", (object) pFunc.zName, (object) pFunc.nArg);
          break;
        case -4:
          Sqlite3.CollSeq pColl = pOp.p4.pColl;
          Sqlite3.sqlite3_snprintf(nTemp, Sqlite3.zTemp, "collseq(%.20s)", pColl != null ? (object) pColl.zName : (object) "null");
          break;
        default:
          if (pOp.p4.z != null)
          {
            Sqlite3.zTemp.Append(pOp.p4.z);
            break;
          }
          break;
      }
      return Sqlite3.zTemp.ToString();
    }

    private static void sqlite3VdbeUsesBtree(Sqlite3.Vdbe p, int i)
    {
      p.btreeMask |= 1 << i;
      if (i == 1 || !Sqlite3.sqlite3BtreeSharable(p.db.aDb[i].pBt))
        return;
      p.lockMask |= 1 << i;
    }

    private static void releaseMemArray(Sqlite3.Mem[] p, int N) => Sqlite3.releaseMemArray(p, 0, N);

    private static void releaseMemArray(Sqlite3.Mem[] p, int starting, int N)
    {
      if (p == null || p.Length <= starting || p[starting] == null || N == 0)
        return;
      Sqlite3.sqlite3 db = p[starting].db;
      for (int index = starting; index < N; ++index)
      {
        Sqlite3.Mem p1 = p[index];
        if (p1 != null)
        {
          if (((int) p1.flags & 9312) != 0)
            Sqlite3.sqlite3VdbeMemRelease(p1);
          p1.z = (string) null;
          p1.n = 0;
          p1.flags = (ushort) 1;
          Sqlite3.sqlite3_free(ref p1._Mem);
          Sqlite3.sqlite3_free(ref p1.zBLOB);
        }
      }
    }

    private static void sqlite3VdbeFrameDelete(Sqlite3.VdbeFrame p)
    {
      Sqlite3.VdbeCursor[] aChildCsr = p.aChildCsr;
      for (int index = 0; index < p.nChildCsr; ++index)
        Sqlite3.sqlite3VdbeFreeCursor(p.v, aChildCsr[index]);
      Sqlite3.releaseMemArray(p.aChildMem, p.nChildMem);
      p = (Sqlite3.VdbeFrame) null;
    }

    private static int sqlite3VdbeList(Sqlite3.Vdbe p)
    {
      int num1 = 0;
      Sqlite3.SubProgram[] array = (Sqlite3.SubProgram[]) null;
      Sqlite3.Mem mem1 = (Sqlite3.Mem) null;
      Sqlite3.sqlite3 db = p.db;
      if (p.pResultSet == null)
        p.pResultSet = new Sqlite3.Mem[0];
      Sqlite3.releaseMemArray(p.pResultSet, 8);
      int nOp = p.nOp;
      if (p.explain == 1)
      {
        mem1 = p.aMem[9];
        if (((int) mem1.flags & 16) != 0)
        {
          array = p.aMem[9]._SubProgram;
          num1 = array.Length;
        }
        for (int index = 0; index < num1; ++index)
          nOp += array[index].nOp;
      }
      int index1 = 0;
      if (index1 >= p.pResultSet.Length)
        Array.Resize<Sqlite3.Mem>(ref p.pResultSet, 8 + p.pResultSet.Length);
      p.pResultSet[index1] = Sqlite3.sqlite3Malloc(p.pResultSet[index1]);
      Sqlite3.Mem[] pResultSet1 = p.pResultSet;
      int index2 = index1;
      int index3 = index2 + 1;
      Sqlite3.Mem mem2 = pResultSet1[index2];
      int index4;
      do
      {
        index4 = p.pc++;
      }
      while (index4 < nOp && p.explain == 2 && p.aOp[index4].opcode != (byte) 138);
      int num2;
      if (index4 >= nOp)
      {
        p.rc = 0;
        num2 = 101;
      }
      else if (db.u1.isInterrupted)
      {
        p.rc = 9;
        num2 = 1;
        Sqlite3.sqlite3SetString(ref p.zErrMsg, db, Sqlite3.sqlite3ErrStr(p.rc));
      }
      else
      {
        Sqlite3.VdbeOp pOp;
        if (index4 < p.nOp)
        {
          pOp = p.aOp[index4];
        }
        else
        {
          index4 -= p.nOp;
          int index5;
          for (index5 = 0; index4 >= array[index5].nOp; ++index5)
            index4 -= array[index5].nOp;
          pOp = array[index5].aOp[index4];
        }
        if (p.explain == 1)
        {
          mem2.flags = (ushort) 4;
          mem2.type = (byte) 1;
          mem2.u.i = (long) index4;
          if (p.pResultSet[index3] == null)
            p.pResultSet[index3] = Sqlite3.sqlite3Malloc(p.pResultSet[index3]);
          Sqlite3.Mem[] pResultSet2 = p.pResultSet;
          int index6 = index3;
          int index7 = index6 + 1;
          Sqlite3.Mem mem3 = pResultSet2[index6];
          mem3.flags = (ushort) 2562;
          mem3.z = Sqlite3.sqlite3OpcodeName((int) pOp.opcode);
          mem3.n = Sqlite3.sqlite3Strlen30(mem3.z);
          mem3.type = (byte) 3;
          mem3.enc = (byte) 1;
          if (p.pResultSet[index7] == null)
            p.pResultSet[index7] = Sqlite3.sqlite3Malloc(p.pResultSet[index7]);
          Sqlite3.Mem[] pResultSet3 = p.pResultSet;
          int index8 = index7;
          index3 = index8 + 1;
          mem2 = pResultSet3[index8];
          if (pOp.p4type == -18)
          {
            int index9 = 0;
            while (index9 < num1 && array[index9] != pOp.p4.pProgram)
              ++index9;
            if (index9 == num1)
            {
              Array.Resize<Sqlite3.SubProgram>(ref array, num1 + 1);
              mem1._SubProgram = array;
              Sqlite3.SubProgram[] subProgramArray = array;
              int index10 = num1;
              int num3 = index10 + 1;
              Sqlite3.SubProgram pProgram = pOp.p4.pProgram;
              subProgramArray[index10] = pProgram;
              mem1.flags |= (ushort) 16;
              mem1.n = 0;
            }
          }
        }
        mem2.flags = (ushort) 4;
        mem2.u.i = (long) pOp.p1;
        mem2.type = (byte) 1;
        if (p.pResultSet[index3] == null)
          p.pResultSet[index3] = Sqlite3.sqlite3Malloc(p.pResultSet[index3]);
        Sqlite3.Mem[] pResultSet4 = p.pResultSet;
        int index11 = index3;
        int index12 = index11 + 1;
        Sqlite3.Mem mem4 = pResultSet4[index11];
        mem4.flags = (ushort) 4;
        mem4.u.i = (long) pOp.p2;
        mem4.type = (byte) 1;
        if (p.pResultSet[index12] == null)
          p.pResultSet[index12] = Sqlite3.sqlite3Malloc(p.pResultSet[index12]);
        Sqlite3.Mem[] pResultSet5 = p.pResultSet;
        int index13 = index12;
        int index14 = index13 + 1;
        Sqlite3.Mem mem5 = pResultSet5[index13];
        mem5.flags = (ushort) 4;
        mem5.u.i = (long) pOp.p3;
        mem5.type = (byte) 1;
        if (p.pResultSet[index14] == null)
          p.pResultSet[index14] = Sqlite3.sqlite3Malloc(p.pResultSet[index14]);
        Sqlite3.Mem[] pResultSet6 = p.pResultSet;
        int index15 = index14;
        int index16 = index15 + 1;
        Sqlite3.Mem pMem = pResultSet6[index15];
        pMem.flags = (ushort) 1538;
        string z = Sqlite3.displayP4(pOp, pMem.z, 32);
        if (z != pMem.z)
        {
          Sqlite3.sqlite3VdbeMemSetStr(pMem, z, -1, (byte) 1, (Sqlite3.dxDel) null);
        }
        else
        {
          pMem.n = Sqlite3.sqlite3Strlen30(pMem.z);
          pMem.enc = (byte) 1;
        }
        pMem.type = (byte) 3;
        if (p.pResultSet[index16] == null)
          p.pResultSet[index16] = Sqlite3.sqlite3Malloc(p.pResultSet[index16]);
        Sqlite3.Mem[] pResultSet7 = p.pResultSet;
        int index17 = index16;
        int index18 = index17 + 1;
        Sqlite3.Mem mem6 = pResultSet7[index17];
        if (p.explain == 1)
        {
          mem6.flags = (ushort) 1538;
          mem6.n = 2;
          mem6.z = pOp.p5.ToString("x2");
          mem6.type = (byte) 3;
          mem6.enc = (byte) 1;
          if (p.pResultSet[index18] == null)
            p.pResultSet[index18] = Sqlite3.sqlite3Malloc(p.pResultSet[index18]);
          Sqlite3.Mem[] pResultSet8 = p.pResultSet;
          int index19 = index18;
          int num4 = index19 + 1;
          Sqlite3.Mem mem7 = pResultSet8[index19];
          mem7.flags = (ushort) 1;
          mem7.type = (byte) 5;
        }
        p.nResColumn = (ushort) (8 - 4 * (p.explain - 1));
        p.rc = 0;
        num2 = 100;
      }
      return num2;
    }

    private static void sqlite3VdbeRewind(Sqlite3.Vdbe p)
    {
      p.magic = 3186757027U;
      p.pc = -1;
      p.rc = 0;
      p.errorAction = (byte) 2;
      p.magic = 3186757027U;
      p.nChange = 0;
      p.cacheCtr = 1U;
      p.minWriteFileFormat = (int) byte.MaxValue;
      p.iStatement = 0;
      p.nFkConstraint = 0L;
    }

    private static void sqlite3VdbeMakeReady(Sqlite3.Vdbe p, Sqlite3.Parse pParse)
    {
      Sqlite3.sqlite3 db = p.db;
      int nVar = pParse.nVar;
      int nMem = pParse.nMem;
      int nTab = pParse.nTab;
      int nMaxArg = pParse.nMaxArg;
      int num = nMem + nTab;
      Sqlite3.resolveP2Values(p, ref nMaxArg);
      p.usesStmtJournal = pParse.isMultiWrite != (byte) 0 && pParse.mayAbort > (byte) 0;
      if (pParse.explain != (byte) 0 && num < 10)
        num = 10;
      p.expired = false;
      p.nzVar = (short) pParse.nzVar;
      p.azVar = new string[p.nzVar == (short) 0 ? 1 : (int) p.nzVar];
      for (int index = 0; index < (int) p.nzVar; ++index)
        p.azVar[index] = pParse.azVar[index];
      p.aMem = new Sqlite3.Mem[num + 1];
      for (int index = 0; index <= num; ++index)
      {
        p.aMem[index] = Sqlite3.sqlite3Malloc(p.aMem[index]);
        p.aMem[index].db = db;
      }
      p.nMem = num;
      p.aVar = new Sqlite3.Mem[nVar == 0 ? 1 : nVar];
      for (int index = 0; index < nVar; ++index)
        p.aVar[index] = Sqlite3.sqlite3Malloc(p.aVar[index]);
      p.nVar = (short) nVar;
      p.apArg = new Sqlite3.Mem[nMaxArg == 0 ? 1 : nMaxArg];
      p.apCsr = new Sqlite3.VdbeCursor[nTab == 0 ? 1 : nTab];
      p.apCsr[0] = new Sqlite3.VdbeCursor();
      p.nCursor = (ushort) nTab;
      if (p.aVar != null)
      {
        p.nVar = (short) nVar;
        for (int index = 0; index < nVar; ++index)
        {
          p.aVar[index].flags = (ushort) 1;
          p.aVar[index].db = db;
        }
      }
      if (p.aMem != null)
      {
        p.nMem = num;
        for (int index = 0; index <= num; ++index)
        {
          p.aMem[index].flags = (ushort) 1;
          p.aMem[index].n = 0;
          p.aMem[index].z = (string) null;
          p.aMem[index].zBLOB = (byte[]) null;
          p.aMem[index].db = db;
        }
      }
      p.explain = (int) pParse.explain;
      Sqlite3.sqlite3VdbeRewind(p);
    }

    private static void sqlite3VdbeFreeCursor(Sqlite3.Vdbe p, Sqlite3.VdbeCursor pCx)
    {
      if (pCx == null)
        return;
      if (pCx.pBt != null)
      {
        Sqlite3.sqlite3BtreeClose(ref pCx.pBt);
      }
      else
      {
        if (pCx.pCursor == null)
          return;
        Sqlite3.sqlite3BtreeCloseCursor(pCx.pCursor);
      }
    }

    private static int sqlite3VdbeFrameRestore(Sqlite3.VdbeFrame pFrame)
    {
      Sqlite3.Vdbe v = pFrame.v;
      v.aOp = pFrame.aOp;
      v.nOp = pFrame.nOp;
      v.aMem = pFrame.aMem;
      v.nMem = pFrame.nMem;
      v.apCsr = pFrame.apCsr;
      v.nCursor = pFrame.nCursor;
      v.db.lastRowid = pFrame.lastRowid;
      v.nChange = pFrame.nChange;
      return pFrame.pc;
    }

    private static void closeAllCursors(Sqlite3.Vdbe p)
    {
      if (p.pFrame != null)
      {
        Sqlite3.VdbeFrame pFrame = p.pFrame;
        while (pFrame.pParent != null)
          pFrame = pFrame.pParent;
        Sqlite3.sqlite3VdbeFrameRestore(pFrame);
      }
      p.pFrame = (Sqlite3.VdbeFrame) null;
      p.nFrame = 0;
      if (p.apCsr != null)
      {
        for (int index = 0; index < (int) p.nCursor; ++index)
        {
          Sqlite3.VdbeCursor pCx = p.apCsr[index];
          if (pCx != null)
          {
            Sqlite3.sqlite3VdbeFreeCursor(p, pCx);
            p.apCsr[index] = (Sqlite3.VdbeCursor) null;
          }
        }
      }
      if (p.aMem != null)
        Sqlite3.releaseMemArray(p.aMem, 1, p.nMem);
      while (p.pDelFrame != null)
      {
        Sqlite3.VdbeFrame pDelFrame = p.pDelFrame;
        p.pDelFrame = pDelFrame.pParent;
        Sqlite3.sqlite3VdbeFrameDelete(pDelFrame);
      }
    }

    private static void Cleanup(Sqlite3.Vdbe p)
    {
      Sqlite3.sqlite3DbFree(p.db, ref p.zErrMsg);
      p.pResultSet = (Sqlite3.Mem[]) null;
    }

    private static void sqlite3VdbeSetNumCols(Sqlite3.Vdbe p, int nResColumn)
    {
      Sqlite3.sqlite3 db = p.db;
      Sqlite3.releaseMemArray(p.aColName, (int) p.nResColumn * 2);
      ref Sqlite3.Mem[] local = ref p.aColName;
      Sqlite3.sqlite3DbFree(db, ref local);
      int length = nResColumn * 2;
      p.nResColumn = (ushort) nResColumn;
      p.aColName = new Sqlite3.Mem[length];
      while (length-- > 0)
      {
        p.aColName[length] = Sqlite3.sqlite3Malloc(p.aColName[length]);
        Sqlite3.Mem mem = p.aColName[length];
        mem.flags = (ushort) 1;
        mem.db = p.db;
      }
    }

    private static int sqlite3VdbeSetColName(
      Sqlite3.Vdbe p,
      int idx,
      int var,
      string zName,
      Sqlite3.dxDel xDel)
    {
      return Sqlite3.sqlite3VdbeMemSetStr(p.aColName[idx + var * (int) p.nResColumn], zName, -1, (byte) 1, xDel);
    }

    private static int vdbeCommit(Sqlite3.sqlite3 db, Sqlite3.Vdbe p)
    {
      int num1 = 0;
      bool flag1 = false;
      Sqlite3.UNUSED_PARAMETER<Sqlite3.Vdbe>(p);
      int num2 = Sqlite3.sqlite3VtabSync(db, ref p.zErrMsg);
      for (int index = 0; num2 == 0 && index < db.nDb; ++index)
      {
        Sqlite3.Btree pBt = db.aDb[index].pBt;
        if (Sqlite3.sqlite3BtreeIsInTrans(pBt))
        {
          flag1 = true;
          if (index != 1)
            ++num1;
          num2 = Sqlite3.sqlite3PagerExclusiveLock(Sqlite3.sqlite3BtreePager(pBt));
        }
      }
      if (num2 != 0)
        return num2;
      if (flag1 && db.xCommitCallback != null)
      {
        num2 = db.xCommitCallback(db.pCommitArg);
        if (num2 != 0)
          return 19;
      }
      if (Sqlite3.sqlite3Strlen30(Sqlite3.sqlite3BtreeGetFilename(db.aDb[0].pBt)) == 0 || num1 <= 1)
      {
        for (int index = 0; num2 == 0 && index < db.nDb; ++index)
        {
          Sqlite3.Btree pBt = db.aDb[index].pBt;
          if (pBt != null)
            num2 = Sqlite3.sqlite3BtreeCommitPhaseOne(pBt, (string) null);
        }
        for (int index = 0; num2 == 0 && index < db.nDb; ++index)
        {
          Sqlite3.Btree pBt = db.aDb[index].pBt;
          if (pBt != null)
            num2 = Sqlite3.sqlite3BtreeCommitPhaseTwo(pBt, 0);
        }
        if (num2 == 0)
          Sqlite3.sqlite3VtabCommit(db);
      }
      else
      {
        Sqlite3.sqlite3_vfs pVfs = db.pVfs;
        bool flag2 = false;
        string pString = "";
        string filename = Sqlite3.sqlite3BtreeGetFilename(db.aDb[0].pBt);
        Sqlite3.sqlite3_file ppFile = (Sqlite3.sqlite3_file) null;
        long offset = 0;
        int pResOut = 0;
        int pOutFlags;
        do
        {
          long pBuf = 0;
          Sqlite3.sqlite3DbFree(db, ref pString);
          Sqlite3.sqlite3_randomness(4, ref pBuf);
          pString = Sqlite3.sqlite3MPrintf(db, "%s-mj%08X", (object) filename, (object) (pBuf & (long) int.MaxValue));
          Sqlite3.sqlite3FileSuffix3(filename, pString);
          pOutFlags = Sqlite3.sqlite3OsAccess(pVfs, pString, 0, ref pResOut);
        }
        while (pOutFlags == 0 && pResOut == 1);
        if (pOutFlags == 0)
          pOutFlags = Sqlite3.sqlite3OsOpenMalloc(ref pVfs, pString, ref ppFile, 16406, ref pOutFlags);
        if (pOutFlags != 0)
        {
          Sqlite3.sqlite3DbFree(db, ref pString);
          return pOutFlags;
        }
        for (int index = 0; index < db.nDb; ++index)
        {
          Sqlite3.Btree pBt = db.aDb[index].pBt;
          if (Sqlite3.sqlite3BtreeIsInTrans(pBt))
          {
            string journalname = Sqlite3.sqlite3BtreeGetJournalname(pBt);
            if (journalname != null)
            {
              if (!flag2 && Sqlite3.sqlite3BtreeSyncDisabled(pBt) == 0)
                flag2 = true;
              pOutFlags = Sqlite3.sqlite3OsWrite(ppFile, Encoding.UTF8.GetBytes(journalname), Sqlite3.sqlite3Strlen30(journalname), offset);
              offset += (long) Sqlite3.sqlite3Strlen30(journalname);
              if (pOutFlags != 0)
              {
                Sqlite3.sqlite3OsCloseFree(ppFile);
                Sqlite3.sqlite3OsDelete(pVfs, pString, 0);
                Sqlite3.sqlite3DbFree(db, ref pString);
                return pOutFlags;
              }
            }
          }
        }
        if (flag2 && (Sqlite3.sqlite3OsDeviceCharacteristics(ppFile) & 1024) == 0 && (pOutFlags = Sqlite3.sqlite3OsSync(ppFile, 2)) != 0)
        {
          Sqlite3.sqlite3OsCloseFree(ppFile);
          Sqlite3.sqlite3OsDelete(pVfs, pString, 0);
          Sqlite3.sqlite3DbFree(db, ref pString);
          return pOutFlags;
        }
        for (int index = 0; pOutFlags == 0 && index < db.nDb; ++index)
        {
          Sqlite3.Btree pBt = db.aDb[index].pBt;
          if (pBt != null)
            pOutFlags = Sqlite3.sqlite3BtreeCommitPhaseOne(pBt, pString);
        }
        Sqlite3.sqlite3OsCloseFree(ppFile);
        if (pOutFlags != 0)
        {
          Sqlite3.sqlite3DbFree(db, ref pString);
          return pOutFlags;
        }
        num2 = Sqlite3.sqlite3OsDelete(pVfs, pString, 1);
        Sqlite3.sqlite3DbFree(db, ref pString);
        if (num2 != 0)
          return num2;
        Sqlite3.sqlite3BeginBenignMalloc();
        for (int index = 0; index < db.nDb; ++index)
        {
          Sqlite3.Btree pBt = db.aDb[index].pBt;
          if (pBt != null)
            Sqlite3.sqlite3BtreeCommitPhaseTwo(pBt, 0);
        }
        Sqlite3.sqlite3EndBenignMalloc();
        Sqlite3.sqlite3VtabCommit(db);
      }
      return num2;
    }

    private static void checkActiveVdbeCnt(Sqlite3.sqlite3 db)
    {
    }

    private static void invalidateCursorsOnModifiedBtrees(Sqlite3.sqlite3 db)
    {
      for (int index = 0; index < db.nDb; ++index)
      {
        Sqlite3.Btree pBt = db.aDb[index].pBt;
        if (pBt != null && Sqlite3.sqlite3BtreeIsInTrans(pBt))
          Sqlite3.sqlite3BtreeTripAllCursors(pBt, 4);
      }
    }

    private static int sqlite3VdbeCloseStatement(Sqlite3.Vdbe p, int eOp)
    {
      Sqlite3.sqlite3 db = p.db;
      int num1 = 0;
      if (db.nStatement != 0 && p.iStatement != 0)
      {
        int num2 = p.iStatement - 1;
        for (int index = 0; index < db.nDb; ++index)
        {
          int num3 = 0;
          Sqlite3.Btree pBt = db.aDb[index].pBt;
          if (pBt != null)
          {
            if (eOp == 2)
              num3 = Sqlite3.sqlite3BtreeSavepoint(pBt, 2, num2);
            if (num3 == 0)
              num3 = Sqlite3.sqlite3BtreeSavepoint(pBt, 1, num2);
            if (num1 == 0)
              num1 = num3;
          }
        }
        --db.nStatement;
        p.iStatement = 0;
        if (num1 == 0)
        {
          if (eOp == 2)
            num1 = Sqlite3.sqlite3VtabSavepoint(db, 2, num2);
          if (num1 == 0)
            num1 = Sqlite3.sqlite3VtabSavepoint(db, 1, num2);
        }
        if (eOp == 2)
          db.nDeferredCons = p.nStmtDefCons;
      }
      return num1;
    }

    private static int sqlite3VdbeCheckFk(Sqlite3.Vdbe p, int deferred)
    {
      Sqlite3.sqlite3 db = p.db;
      if ((deferred == 0 || db.nDeferredCons <= 0L) && (deferred != 0 || p.nFkConstraint <= 0L))
        return 0;
      p.rc = 19;
      p.errorAction = (byte) 2;
      Sqlite3.sqlite3SetString(ref p.zErrMsg, db, "foreign key constraint failed");
      return 1;
    }

    private static int sqlite3VdbeHalt(Sqlite3.Vdbe p)
    {
      Sqlite3.sqlite3 db = p.db;
      Sqlite3.closeAllCursors(p);
      if (p.magic != 3186757027U)
        return 0;
      Sqlite3.checkActiveVdbeCnt(db);
      if (p.pc >= 0)
      {
        int eOp = 0;
        Sqlite3.sqlite3VdbeEnter(p);
        int num1 = p.rc & (int) byte.MaxValue;
        int num2;
        switch (num1)
        {
          case 7:
          case 9:
          case 10:
            num2 = 1;
            break;
          default:
            num2 = num1 == 13 ? 1 : 0;
            break;
        }
        bool flag = num2 != 0;
        if (flag && (!p.readOnly || num1 != 9))
        {
          if ((num1 == 7 || num1 == 13) && p.usesStmtJournal)
          {
            eOp = 2;
          }
          else
          {
            Sqlite3.invalidateCursorsOnModifiedBtrees(db);
            Sqlite3.sqlite3RollbackAll(db);
            Sqlite3.sqlite3CloseSavepoints(db);
            db.autoCommit = (byte) 1;
          }
        }
        if (p.rc == 0)
          Sqlite3.sqlite3VdbeCheckFk(p, 0);
        if (!Sqlite3.sqlite3VtabInSync(db) && db.autoCommit != (byte) 0 && db.writeVdbeCnt == (!p.readOnly ? 1 : 0))
        {
          if (p.rc == 0 || p.errorAction == (byte) 3 && !flag)
          {
            int num3;
            if (Sqlite3.sqlite3VdbeCheckFk(p, 1) != 0)
            {
              if (Sqlite3.NEVER(p.readOnly))
              {
                Sqlite3.sqlite3VdbeLeave(p);
                return 1;
              }
              num3 = 19;
            }
            else
              num3 = Sqlite3.vdbeCommit(db, p);
            if (num3 == 5 && p.readOnly)
            {
              Sqlite3.sqlite3VdbeLeave(p);
              return 5;
            }
            if (num3 != 0)
            {
              p.rc = num3;
              Sqlite3.sqlite3RollbackAll(db);
            }
            else
            {
              db.nDeferredCons = 0L;
              Sqlite3.sqlite3CommitInternalChanges(db);
            }
          }
          else
            Sqlite3.sqlite3RollbackAll(db);
          db.nStatement = 0;
        }
        else if (eOp == 0)
        {
          if (p.rc == 0 || p.errorAction == (byte) 3)
            eOp = 1;
          else if (p.errorAction == (byte) 2)
          {
            eOp = 2;
          }
          else
          {
            Sqlite3.invalidateCursorsOnModifiedBtrees(db);
            Sqlite3.sqlite3RollbackAll(db);
            Sqlite3.sqlite3CloseSavepoints(db);
            db.autoCommit = (byte) 1;
          }
        }
        if (eOp != 0)
        {
          int num4 = Sqlite3.sqlite3VdbeCloseStatement(p, eOp);
          if (num4 != 0)
          {
            if (p.rc == 0 || p.rc == 19)
            {
              p.rc = num4;
              Sqlite3.sqlite3DbFree(db, ref p.zErrMsg);
              p.zErrMsg = (string) null;
            }
            Sqlite3.invalidateCursorsOnModifiedBtrees(db);
            Sqlite3.sqlite3RollbackAll(db);
            Sqlite3.sqlite3CloseSavepoints(db);
            db.autoCommit = (byte) 1;
          }
        }
        if (p.changeCntOn)
        {
          if (eOp != 2)
            Sqlite3.sqlite3VdbeSetChanges(db, p.nChange);
          else
            Sqlite3.sqlite3VdbeSetChanges(db, 0);
          p.nChange = 0;
        }
        if (p.rc != 0 && (db.flags & 512) != 0)
        {
          Sqlite3.sqlite3ResetInternalSchema(db, -1);
          db.flags |= 512;
        }
        Sqlite3.sqlite3VdbeLeave(p);
      }
      if (p.pc >= 0)
      {
        --db.activeVdbeCnt;
        if (!p.readOnly)
          --db.writeVdbeCnt;
      }
      p.magic = 1369188723U;
      Sqlite3.checkActiveVdbeCnt(db);
      if (db.autoCommit != (byte) 0)
        Sqlite3.sqlite3ConnectionUnlocked(db);
      return p.rc != 5 ? 0 : 5;
    }

    private static void sqlite3VdbeResetStepResult(Sqlite3.Vdbe p) => p.rc = 0;

    private static int sqlite3VdbeReset(Sqlite3.Vdbe p)
    {
      Sqlite3.sqlite3 db = p.db;
      Sqlite3.sqlite3VdbeHalt(p);
      if (p.pc >= 0)
      {
        Sqlite3.sqlite3BeginBenignMalloc();
        Sqlite3.sqlite3ValueSetStr(db.pErr, -1, p.zErrMsg == null ? "" : p.zErrMsg, (byte) 1, Sqlite3.SQLITE_TRANSIENT);
        Sqlite3.sqlite3EndBenignMalloc();
        db.errCode = p.rc;
        Sqlite3.sqlite3DbFree(db, ref p.zErrMsg);
        p.zErrMsg = "";
        if (p.runOnlyOnce != (byte) 0)
          p.expired = true;
      }
      else if (p.rc != 0 && p.expired)
      {
        Sqlite3.sqlite3Error(db, p.rc, 0);
        Sqlite3.sqlite3ValueSetStr(db.pErr, -1, p.zErrMsg, (byte) 1, Sqlite3.SQLITE_TRANSIENT);
        Sqlite3.sqlite3DbFree(db, ref p.zErrMsg);
        p.zErrMsg = "";
      }
      Sqlite3.Cleanup(p);
      p.magic = 649915045U;
      return p.rc & db.errMask;
    }

    private static int sqlite3VdbeFinalize(ref Sqlite3.Vdbe p)
    {
      int num = 0;
      if (p.magic == 3186757027U || p.magic == 1369188723U)
        num = Sqlite3.sqlite3VdbeReset(p);
      Sqlite3.sqlite3VdbeDelete(ref p);
      return num;
    }

    private static void sqlite3VdbeDeleteAuxData(Sqlite3.VdbeFunc pVdbeFunc, int mask)
    {
      for (int index = 0; index < pVdbeFunc.nAux; ++index)
      {
        Sqlite3.AuxData auxData = pVdbeFunc.apAux[index];
        if (index > 31 || ((long) mask & (long) (uint) (1 << index)) == 0L && auxData.pAux != null)
        {
          if (auxData.pAux != null && auxData.pAux is IDisposable)
            (auxData.pAux as IDisposable).Dispose();
          auxData.pAux = (object) null;
        }
      }
    }

    private static void sqlite3VdbeDeleteObject(Sqlite3.sqlite3 db, ref Sqlite3.Vdbe p)
    {
      Sqlite3.releaseMemArray(p.aVar, (int) p.nVar);
      Sqlite3.releaseMemArray(p.aColName, (int) p.nResColumn, 2);
      Sqlite3.SubProgram pNext;
      for (Sqlite3.SubProgram pT = p.pProgram; pT != null; pT = pNext)
      {
        pNext = pT.pNext;
        Sqlite3.vdbeFreeOpArray(db, ref pT.aOp, pT.nOp);
        Sqlite3.sqlite3DbFree<Sqlite3.SubProgram>(db, ref pT);
      }
      Sqlite3.vdbeFreeOpArray(db, ref p.aOp, p.nOp);
      Sqlite3.sqlite3DbFree(db, ref p.aLabel);
      Sqlite3.sqlite3DbFree(db, ref p.aColName);
      Sqlite3.sqlite3DbFree(db, ref p.zSql);
      Sqlite3.sqlite3DbFree<object>(db, ref p.pFree);
    }

    private static void sqlite3VdbeDelete(ref Sqlite3.Vdbe p)
    {
      if (Sqlite3.NEVER(p == null))
        return;
      Sqlite3.Cleanup(p);
      Sqlite3.sqlite3 db = p.db;
      if (p.pPrev != null)
        p.pPrev.pNext = p.pNext;
      else
        db.pVdbe = p.pNext;
      if (p.pNext != null)
        p.pNext.pPrev = p.pPrev;
      p.magic = 3053896648U;
      p.db = (Sqlite3.sqlite3) null;
      Sqlite3.sqlite3VdbeDeleteObject(db, ref p);
    }

    private static int sqlite3VdbeCursorMoveto(Sqlite3.VdbeCursor p)
    {
      if (p.deferredMoveto)
      {
        int pRes = 0;
        int num = Sqlite3.sqlite3BtreeMovetoUnpacked(p.pCursor, (Sqlite3.UnpackedRecord) null, p.movetoTarget, 0, ref pRes);
        if (num != 0)
          return num;
        p.lastRowid = p.movetoTarget;
        if (pRes != 0)
          return Sqlite3.SQLITE_CORRUPT_BKPT();
        p.rowidIsValid = true;
        p.deferredMoveto = false;
        p.cacheStatus = 0U;
      }
      else if (Sqlite3.ALWAYS(p.pCursor != null))
      {
        int pHasMoved = 0;
        int num = Sqlite3.sqlite3BtreeCursorHasMoved(p.pCursor, ref pHasMoved);
        if (num != 0)
          return num;
        if (pHasMoved != 0)
        {
          p.cacheStatus = 0U;
          p.nullRow = true;
        }
      }
      return 0;
    }

    private static uint sqlite3VdbeSerialType(Sqlite3.Mem pMem, int file_format)
    {
      int flags = (int) pMem.flags;
      if ((flags & 1) != 0)
        return 0;
      if ((flags & 4) != 0)
      {
        long i = pMem.u.i;
        if (file_format >= 4 && (i & 1L) == i)
          return 8U + (uint) i;
        ulong num;
        if (i < 0L)
        {
          if (i < -140737488355327L)
            return 6;
          num = (ulong) -i;
        }
        else
          num = (ulong) i;
        if (num <= (ulong) sbyte.MaxValue)
          return 1;
        if (num <= (ulong) short.MaxValue)
          return 2;
        if (num <= 8388607UL)
          return 3;
        if (num <= (ulong) int.MaxValue)
          return 4;
        return num <= 140737488355327UL ? 5U : 6U;
      }
      if ((flags & 8) != 0)
        return 7;
      int n = pMem.n;
      int num1;
      if ((flags & 0) != 0)
        num1 = n + pMem.u.nZero;
      else if ((flags & 16) != 0)
      {
        num1 = pMem.zBLOB != null ? pMem.zBLOB.Length : (pMem.z != null ? pMem.z.Length : 0);
      }
      else
      {
        num1 = pMem.z == null ? pMem.zBLOB.Length : Encoding.UTF8.GetByteCount(pMem.n < pMem.z.Length ? pMem.z.Substring(0, pMem.n) : pMem.z);
        pMem.n = num1;
      }
      return (uint) (num1 * 2 + 12 + ((flags & 2) != 0 ? 1 : 0));
    }

    private static uint sqlite3VdbeSerialTypeLen(uint serial_type) => serial_type >= 12U ? (serial_type - 12U) / 2U : Sqlite3.aSize[(int) serial_type];

    private static uint sqlite3VdbeSerialPut(
      byte[] buf,
      int offset,
      int nBuf,
      Sqlite3.Mem pMem,
      int file_format)
    {
      uint serial_type = Sqlite3.sqlite3VdbeSerialType(pMem, file_format);
      if (serial_type <= 7U && serial_type > 0U)
      {
        ulong num1 = serial_type != 7U ? (ulong) pMem.u.i : (ulong) BitConverter.ToInt64(BitConverter.GetBytes(pMem.r), 0);
        uint num2;
        uint num3 = num2 = Sqlite3.sqlite3VdbeSerialTypeLen(serial_type);
        while (num2-- != 0U)
        {
          buf[(long) offset + (long) num2] = (byte) (num1 & (ulong) byte.MaxValue);
          num1 >>= 8;
        }
        return num3;
      }
      if (serial_type < 12U)
        return 0;
      uint count;
      if ((count = (uint) pMem.n) != 0U && (pMem.zBLOB != null || !string.IsNullOrEmpty(pMem.z)))
      {
        if (pMem.zBLOB != null && (((int) pMem.flags & 16) != 0 || pMem.z == null))
          Buffer.BlockCopy((Array) pMem.zBLOB, 0, (Array) buf, offset, (int) count);
        else
          Buffer.BlockCopy((Array) Encoding.UTF8.GetBytes(pMem.z), 0, (Array) buf, offset, (int) count);
      }
      if (((int) pMem.flags & 0) != 0)
      {
        count += (uint) pMem.u.nZero;
        if (count > (uint) nBuf)
          count = (uint) nBuf;
        Array.Clear((Array) buf, offset + pMem.n, (int) ((long) count - (long) pMem.n));
      }
      return count;
    }

    private static uint sqlite3VdbeSerialGet(
      byte[] buf,
      int offset,
      uint serial_type,
      Sqlite3.Mem pMem)
    {
      switch (serial_type)
      {
        case 0:
        case 10:
        case 11:
          pMem.flags = (ushort) 1;
          pMem.n = 0;
          pMem.z = (string) null;
          pMem.zBLOB = (byte[]) null;
          return 0;
        case 1:
          pMem.u.i = (long) (sbyte) buf[offset];
          pMem.flags = (ushort) 4;
          return 1;
        case 2:
          pMem.u.i = (long) ((int) (sbyte) buf[offset] << 8 | (int) buf[offset + 1]);
          pMem.flags = (ushort) 4;
          return 2;
        case 3:
          pMem.u.i = (long) ((int) (sbyte) buf[offset] << 16 | (int) buf[offset + 1] << 8 | (int) buf[offset + 2]);
          pMem.flags = (ushort) 4;
          return 3;
        case 4:
          pMem.u.i = (long) ((int) (sbyte) buf[offset] << 24 | (int) buf[offset + 1] << 16 | (int) buf[offset + 2] << 8 | (int) buf[offset + 3]);
          pMem.flags = (ushort) 4;
          return 4;
        case 5:
          ulong num1 = (ulong) ((int) (sbyte) buf[offset] << 8 | (int) buf[offset + 1]) << 32 | (ulong) ((uint) ((int) buf[offset + 2] << 24 | (int) buf[offset + 3] << 16 | (int) buf[offset + 4] << 8) | (uint) buf[offset + 5]);
          pMem.u.i = (long) num1;
          pMem.flags = (ushort) 4;
          return 6;
        case 6:
        case 7:
          ulong num2 = (ulong) ((int) buf[offset] << 24 | (int) buf[offset + 1] << 16 | (int) buf[offset + 2] << 8 | (int) buf[offset + 3]) << 32 | (ulong) ((uint) ((int) buf[offset + 4] << 24 | (int) buf[offset + 5] << 16 | (int) buf[offset + 6] << 8) | (uint) buf[offset + 7]);
          if (serial_type == 6U)
          {
            pMem.u.i = (long) num2;
            pMem.flags = (ushort) 4;
          }
          else
          {
            pMem.r = BitConverter.ToDouble(BitConverter.GetBytes((long) num2), 0);
            pMem.flags = Sqlite3.sqlite3IsNaN(pMem.r) ? (ushort) 1 : (ushort) 8;
          }
          return 8;
        case 8:
        case 9:
          pMem.u.i = (long) (serial_type - 8U);
          pMem.flags = (ushort) 4;
          return 0;
        default:
          uint num3 = (serial_type - 12U) / 2U;
          pMem.n = (int) num3;
          pMem.xDel = (Sqlite3.dxDel) null;
          if (((int) serial_type & 1) != 0)
          {
            pMem.flags = (ushort) 4098;
            if ((long) num3 <= (long) (buf.Length - offset))
            {
              pMem.z = Encoding.UTF8.GetString(buf, offset, (int) num3);
              pMem.n = pMem.z.Length;
            }
            else
            {
              pMem.z = "";
              pMem.n = 0;
            }
            pMem.zBLOB = (byte[]) null;
          }
          else
          {
            pMem.z = (string) null;
            pMem.zBLOB = Sqlite3.sqlite3Malloc((int) num3);
            pMem.flags = (ushort) 4112;
            if ((long) num3 <= (long) (buf.Length - offset))
              Buffer.BlockCopy((Array) buf, offset, (Array) pMem.zBLOB, 0, (int) num3);
            else
              Buffer.BlockCopy((Array) buf, offset, (Array) pMem.zBLOB, 0, buf.Length - offset - 1);
          }
          return num3;
      }
    }

    private static int sqlite3VdbeSerialGet(byte[] buf, uint serial_type, Sqlite3.Mem pMem)
    {
      switch (serial_type)
      {
        case 0:
        case 10:
        case 11:
          pMem.flags = (ushort) 1;
          return 0;
        case 1:
          pMem.u.i = (long) (sbyte) buf[0];
          pMem.flags = (ushort) 4;
          return 1;
        case 2:
          pMem.u.i = (long) ((int) buf[0] << 8 | (int) buf[1]);
          pMem.flags = (ushort) 4;
          return 2;
        case 3:
          pMem.u.i = (long) ((int) buf[0] << 16 | (int) buf[1] << 8 | (int) buf[2]);
          pMem.flags = (ushort) 4;
          return 3;
        case 4:
          pMem.u.i = (long) ((int) buf[0] << 24 | (int) buf[1] << 16 | (int) buf[2] << 8 | (int) buf[3]);
          pMem.flags = (ushort) 4;
          return 4;
        case 5:
          ulong num1 = (ulong) ((int) buf[0] << 8 | (int) buf[1]) << 32 | (ulong) ((uint) ((int) buf[2] << 24 | (int) buf[3] << 16 | (int) buf[4] << 8) | (uint) buf[5]);
          pMem.u.i = (long) num1;
          pMem.flags = (ushort) 4;
          return 6;
        case 6:
        case 7:
          ulong num2 = (ulong) ((int) buf[0] << 24 | (int) buf[1] << 16 | (int) buf[2] << 8 | (int) buf[3]) << 32 | (ulong) ((uint) ((int) buf[4] << 24 | (int) buf[5] << 16 | (int) buf[6] << 8) | (uint) buf[7]);
          if (serial_type == 6U)
          {
            pMem.u.i = (long) num2;
            pMem.flags = (ushort) 4;
          }
          else
          {
            pMem.r = BitConverter.ToDouble(BitConverter.GetBytes((long) num2), 0);
            pMem.flags = (ushort) 8;
          }
          return 8;
        case 8:
        case 9:
          pMem.u.i = (long) (serial_type - 8U);
          pMem.flags = (ushort) 4;
          return 0;
        default:
          int num3 = (int) ((serial_type - 12U) / 2U);
          pMem.xDel = (Sqlite3.dxDel) null;
          if (((int) serial_type & 1) != 0)
          {
            pMem.flags = (ushort) 4098;
            pMem.z = Encoding.UTF8.GetString(buf, 0, num3);
            pMem.n = pMem.z.Length;
            pMem.zBLOB = (byte[]) null;
          }
          else
          {
            pMem.flags = (ushort) 4112;
            pMem.zBLOB = Sqlite3.sqlite3Malloc(num3);
            buf.CopyTo((Array) pMem.zBLOB, 0);
            pMem.n = num3;
            pMem.z = (string) null;
          }
          return num3;
      }
    }

    private static Sqlite3.UnpackedRecord sqlite3VdbeRecordUnpack(
      Sqlite3.KeyInfo pKeyInfo,
      int nKey,
      byte[] pKey,
      Sqlite3.UnpackedRecord pSpace,
      int szSpace)
    {
      byte[] numArray = pKey;
      int v1 = 0;
      Sqlite3.UnpackedRecord unpackedRecord = pSpace;
      unpackedRecord.flags = (ushort) 2;
      unpackedRecord.pKeyInfo = pKeyInfo;
      unpackedRecord.nField = (ushort) ((uint) pKeyInfo.nField + 1U);
      unpackedRecord.aMem = new Sqlite3.Mem[(int) unpackedRecord.nField + 1];
      uint varint32 = (uint) Sqlite3.getVarint32(numArray, 0, out v1);
      int offset = v1;
      int index;
      for (index = 0; (long) varint32 < (long) v1 && index < (int) unpackedRecord.nField && offset <= nKey; ++index)
      {
        unpackedRecord.aMem[index] = Sqlite3.sqlite3Malloc(unpackedRecord.aMem[index]);
        Sqlite3.Mem pMem = unpackedRecord.aMem[index];
        uint v2 = 0;
        varint32 += (uint) Sqlite3.getVarint32(numArray, varint32, out v2);
        pMem.enc = pKeyInfo.enc;
        pMem.db = pKeyInfo.db;
        offset += (int) Sqlite3.sqlite3VdbeSerialGet(numArray, offset, v2, pMem);
      }
      unpackedRecord.nField = (ushort) index;
      return unpackedRecord;
    }

    private static void sqlite3VdbeDeleteUnpackedRecord(Sqlite3.UnpackedRecord p)
    {
      if (((int) p.flags & 1) == 0)
        return;
      Sqlite3.sqlite3DbFree(p.pKeyInfo.db, ref p.aMem);
      p = (Sqlite3.UnpackedRecord) null;
    }

    private static int sqlite3VdbeRecordCompare(
      int nKey1,
      byte[] pKey1,
      Sqlite3.UnpackedRecord pPKey2)
    {
      return Sqlite3.sqlite3VdbeRecordCompare(nKey1, pKey1, 0, pPKey2);
    }

    private static int sqlite3VdbeRecordCompare(
      int nKey1,
      byte[] pKey1,
      int offset,
      Sqlite3.UnpackedRecord pPKey2)
    {
      int index = 0;
      int num1 = 0;
      byte[] numArray = new byte[pKey1.Length - offset];
      Sqlite3.KeyInfo pKeyInfo = pPKey2.pKeyInfo;
      Sqlite3.mem1.enc = pKeyInfo.enc;
      Sqlite3.mem1.db = pKeyInfo.db;
      uint v1;
      uint num2 = (v1 = (uint) pKey1[offset]) <= (uint) sbyte.MaxValue ? 1U : (uint) Sqlite3.getVarint32(pKey1, offset, out v1);
      int num3 = (int) v1;
      if (((int) pPKey2.flags & 4) != 0)
        --v1;
      int nField = (int) pKeyInfo.nField;
      for (; num2 < v1 && index < (int) pPKey2.nField; ++index)
      {
        uint v2;
        num2 += (v2 = (uint) pKey1[(long) offset + (long) num2]) <= (uint) sbyte.MaxValue ? 1U : (uint) Sqlite3.getVarint32(pKey1, (uint) ((ulong) offset + (ulong) num2), out v2);
        if (num3 > 0 && (num3 < nKey1 || Sqlite3.sqlite3VdbeSerialTypeLen(v2) <= 0U))
        {
          num3 += (int) Sqlite3.sqlite3VdbeSerialGet(pKey1, offset + num3, v2, Sqlite3.mem1);
          num1 = Sqlite3.sqlite3MemCompare(Sqlite3.mem1, pPKey2.aMem[index], index < nField ? pKeyInfo.aColl[index] : (Sqlite3.CollSeq) null);
          if (num1 != 0)
          {
            if (pKeyInfo.aSortOrder != null && index < nField && pKeyInfo.aSortOrder[index] != (byte) 0)
              num1 = -num1;
            if (((int) pPKey2.flags & 32) != 0 && index == (int) pPKey2.nField - 1)
            {
              pPKey2.flags &= (ushort) 65503;
              pPKey2.rowid = Sqlite3.mem1.u.i;
            }
            return num1;
          }
        }
        else
          break;
      }
      if (((int) pPKey2.flags & 8) != 0)
        num1 = -1;
      else if (((int) pPKey2.flags & 16) == 0 && num2 < v1)
        num1 = 1;
      return num1;
    }

    private static int sqlite3VdbeIdxRowid(
      Sqlite3.sqlite3 db,
      Sqlite3.BtCursor pCur,
      ref long rowid)
    {
      long pSize = 0;
      uint v1 = 0;
      uint v2 = 0;
      Sqlite3.Mem pMem1 = (Sqlite3.Mem) null;
      Sqlite3.Mem pMem2 = Sqlite3.sqlite3Malloc((Sqlite3.Mem) null);
      Sqlite3.UNUSED_PARAMETER<Sqlite3.sqlite3>(db);
      Sqlite3.sqlite3BtreeKeySize(pCur, ref pSize);
      Sqlite3.Mem mem = Sqlite3.sqlite3Malloc(pMem1);
      int num1 = Sqlite3.sqlite3VdbeMemFromBtree(pCur, 0, (int) pSize, true, mem);
      if (num1 != 0)
        return num1;
      Sqlite3.getVarint32(mem.zBLOB, 0, out v1);
      Sqlite3.testcase<bool>(v1 == 3U);
      Sqlite3.testcase<bool>((long) v1 == (long) mem.n);
      if (!Sqlite3.unlikely(v1 < 3U || (int) v1 > mem.n))
      {
        Sqlite3.getVarint32(mem.zBLOB, v1 - 1U, out v2);
        Sqlite3.testcase<bool>(v2 == 1U);
        Sqlite3.testcase<bool>(v2 == 2U);
        Sqlite3.testcase<bool>(v2 == 3U);
        Sqlite3.testcase<bool>(v2 == 4U);
        Sqlite3.testcase<bool>(v2 == 5U);
        Sqlite3.testcase<bool>(v2 == 6U);
        Sqlite3.testcase<bool>(v2 == 8U);
        Sqlite3.testcase<bool>(v2 == 9U);
        if (!Sqlite3.unlikely(v2 < 1U || v2 > 9U || v2 == 7U))
        {
          uint num2 = Sqlite3.sqlite3VdbeSerialTypeLen(v2);
          Sqlite3.testcase<bool>(mem.n == (int) v1 + (int) num2);
          if (!Sqlite3.unlikely((uint) mem.n < v1 + num2))
          {
            int num3 = (int) Sqlite3.sqlite3VdbeSerialGet(mem.zBLOB, (int) ((long) mem.n - (long) num2), v2, pMem2);
            rowid = pMem2.u.i;
            Sqlite3.sqlite3VdbeMemRelease(mem);
            return 0;
          }
        }
      }
      Sqlite3.sqlite3VdbeMemRelease(mem);
      return Sqlite3.SQLITE_CORRUPT_BKPT();
    }

    private static int sqlite3VdbeIdxKeyCompare(
      Sqlite3.VdbeCursor pC,
      Sqlite3.UnpackedRecord pUnpacked,
      ref int res)
    {
      long amt = 0;
      Sqlite3.BtCursor pCursor = pC.pCursor;
      Sqlite3.Mem pMem = (Sqlite3.Mem) null;
      ref long local = ref amt;
      Sqlite3.sqlite3BtreeKeySize(pCursor, ref local);
      if (amt <= 0L || amt > (long) int.MaxValue)
      {
        res = 0;
        return Sqlite3.SQLITE_CORRUPT_BKPT();
      }
      Sqlite3.Mem mem = Sqlite3.sqlite3Malloc(pMem);
      int num = Sqlite3.sqlite3VdbeMemFromBtree(pC.pCursor, 0, (int) amt, true, mem);
      if (num != 0)
        return num;
      res = Sqlite3.sqlite3VdbeRecordCompare(mem.n, mem.zBLOB, pUnpacked);
      Sqlite3.sqlite3VdbeMemRelease(mem);
      return 0;
    }

    private static void sqlite3VdbeSetChanges(Sqlite3.sqlite3 db, int nChange)
    {
      db.nChange = nChange;
      db.nTotalChange += nChange;
    }

    private static void sqlite3VdbeCountChanges(Sqlite3.Vdbe v) => v.changeCntOn = true;

    private static void sqlite3ExpirePreparedStatements(Sqlite3.sqlite3 db)
    {
      for (Sqlite3.Vdbe vdbe = db.pVdbe; vdbe != null; vdbe = vdbe.pNext)
        vdbe.expired = true;
    }

    private static Sqlite3.sqlite3 sqlite3VdbeDb(Sqlite3.Vdbe v) => v.db;

    private static Sqlite3.Mem sqlite3VdbeGetValue(Sqlite3.Vdbe v, int iVar, byte aff)
    {
      if (v != null)
      {
        Sqlite3.Mem pFrom = v.aVar[iVar - 1];
        if (((int) pFrom.flags & 1) == 0)
        {
          Sqlite3.Mem mem = Sqlite3.sqlite3ValueNew(v.db);
          if (mem != null)
          {
            Sqlite3.sqlite3VdbeMemCopy(mem, pFrom);
            Sqlite3.sqlite3ValueApplyAffinity(mem, (char) aff, 1);
            Sqlite3.sqlite3VdbeMemStoreType(mem);
          }
          return mem;
        }
      }
      return (Sqlite3.Mem) null;
    }

    private static void sqlite3VdbeSetVarmask(Sqlite3.Vdbe v, int iVar)
    {
      if (iVar > 32)
        v.expmask = uint.MaxValue;
      else
        v.expmask |= (uint) (1 << iVar - 1);
    }

    private static void MemSetTypeFlag(Sqlite3.Mem p, int f) => p.flags = (ushort) ((int) p.flags & -256 | f);

    private static bool memIsValid(Sqlite3.Mem M) => true;

    private static void sqlite3VdbeEnter(Sqlite3.Vdbe p)
    {
    }

    private static void sqlite3VdbeLeave(Sqlite3.Vdbe p)
    {
    }

    private static int sqlite3VdbeMemExpandBlob(Sqlite3.Mem x) => 0;

    private static void expandBlob(Sqlite3.Mem P)
    {
      if (((int) P.flags & 0) == 0)
        return;
      Sqlite3.sqlite3VdbeMemExpandBlob(P);
    }

    private static int sqlite3VdbeChangeEncoding(Sqlite3.Mem pMem, int desiredEnc)
    {
      if (((int) pMem.flags & 2) != 0 && (int) pMem.enc != desiredEnc)
        return 1;
      if (string.IsNullOrEmpty(pMem.z) && pMem.zBLOB != null)
        pMem.z = Encoding.UTF8.GetString(pMem.zBLOB, 0, pMem.zBLOB.Length);
      return 0;
    }

    private static int sqlite3VdbeMemGrow(Sqlite3.Mem pMem, int n, int preserve)
    {
      if (preserve != 0)
      {
        if (pMem.z == null)
          pMem.z = "";
        else if (n < pMem.z.Length)
          pMem.z = pMem.z.Substring(0, n);
        preserve = 0;
      }
      else
        pMem.z = "";
      if (((int) pMem.flags & 1024) != 0 && pMem.xDel != null)
        pMem.xDel(ref pMem.z);
      if (pMem.z == null)
        pMem.flags = (ushort) 1;
      else
        pMem.flags &= (ushort) 59391;
      pMem.xDel = (Sqlite3.dxDel) null;
      return pMem.z == null ? 7 : 0;
    }

    private static int sqlite3VdbeMemMakeWriteable(Sqlite3.Mem pMem)
    {
      Sqlite3.expandBlob(pMem);
      if (((int) pMem.flags & 18) != 0 && Sqlite3.sqlite3VdbeMemGrow(pMem, pMem.n + 2, 1) != 0)
        pMem.flags |= (ushort) 512;
      return 0;
    }

    private static int sqlite3VdbeMemNulTerminate(Sqlite3.Mem pMem)
    {
      if (((int) pMem.flags & 512) != 0 || ((int) pMem.flags & 2) == 0)
        return 0;
      if (pMem.z != null && pMem.n < pMem.z.Length)
        pMem.z = pMem.z.Substring(0, pMem.n);
      pMem.flags |= (ushort) 512;
      return 0;
    }

    private static int sqlite3VdbeMemStringify(Sqlite3.Mem pMem, int enc)
    {
      int num = 0;
      int flags = (int) pMem.flags;
      if (Sqlite3.sqlite3VdbeMemGrow(pMem, 32, 0) != 0)
        return 7;
      pMem.z = (flags & 4) == 0 ? (!double.IsNegativeInfinity(pMem.r) ? (!double.IsInfinity(pMem.r) ? (!double.IsPositiveInfinity(pMem.r) ? (!pMem.r.ToString((IFormatProvider) CultureInfo.InvariantCulture).Contains(".") ? pMem.r.ToString((IFormatProvider) CultureInfo.InvariantCulture) + ".0" : pMem.r.ToString((IFormatProvider) CultureInfo.InvariantCulture).ToLower()) : "+Inf") : "Inf") : "-Inf") : pMem.u.i.ToString();
      pMem.n = Sqlite3.sqlite3Strlen30(pMem.z);
      pMem.enc = (byte) 1;
      pMem.flags |= (ushort) 514;
      Sqlite3.sqlite3VdbeChangeEncoding(pMem, enc);
      return num;
    }

    private static int sqlite3VdbeMemFinalize(Sqlite3.Mem pMem, Sqlite3.FuncDef pFunc)
    {
      int num = 0;
      if (Sqlite3.ALWAYS(pFunc != null && pFunc.xFinalize != null))
      {
        Sqlite3.sqlite3_context ctx = new Sqlite3.sqlite3_context();
        ctx.s.flags = (ushort) 1;
        ctx.s.db = pMem.db;
        ctx.pMem = pMem;
        ctx.pFunc = pFunc;
        pFunc.xFinalize(ctx);
        Sqlite3.sqlite3DbFree(pMem.db, ref pMem.zBLOB);
        ctx.s.CopyTo(ref pMem);
        num = ctx.isError;
      }
      return num;
    }

    private static void sqlite3VdbeMemReleaseExternal(Sqlite3.Mem p)
    {
      Sqlite3.testcase<int>((int) p.flags & 8192);
      Sqlite3.testcase<int>((int) p.flags & 1024);
      Sqlite3.testcase<int>((int) p.flags & 32);
      Sqlite3.testcase<int>((int) p.flags & 64);
      if (((int) p.flags & 9312) != 0)
      {
        if (((int) p.flags & 8192) != 0)
        {
          Sqlite3.sqlite3VdbeMemFinalize(p, p.u.pDef);
          Sqlite3.sqlite3VdbeMemRelease(p);
        }
        else if (((int) p.flags & 1024) != 0 && p.xDel != null)
        {
          p.xDel(ref p.z);
          p.xDel = (Sqlite3.dxDel) null;
        }
        else if (((int) p.flags & 32) != 0)
          Sqlite3.sqlite3RowSetClear(p.u.pRowSet);
        else if (((int) p.flags & 64) != 0)
          Sqlite3.sqlite3VdbeMemSetNull(p);
      }
      p.n = 0;
      p.z = (string) null;
      p.zBLOB = (byte[]) null;
    }

    private static void sqlite3VdbeMemRelease(Sqlite3.Mem p)
    {
      Sqlite3.sqlite3VdbeMemReleaseExternal(p);
      Sqlite3.sqlite3DbFree(p.db, ref p.zBLOB);
      p.z = (string) null;
      p.xDel = (Sqlite3.dxDel) null;
    }

    private static long doubleToInt64(double r) => r < (double) long.MinValue || r > (double) long.MaxValue ? long.MinValue : (long) r;

    private static long sqlite3VdbeIntValue(Sqlite3.Mem pMem)
    {
      int flags = (int) pMem.flags;
      if ((flags & 4) != 0)
        return pMem.u.i;
      if ((flags & 8) != 0)
        return Sqlite3.doubleToInt64(pMem.r);
      if ((flags & 2) != 0)
      {
        long pNum = 0;
        Sqlite3.testcase<bool>(pMem.z == null);
        Sqlite3.sqlite3Atoi64(pMem.z, ref pNum, pMem.n, pMem.enc);
        return pNum;
      }
      if ((flags & 16) == 0)
        return 0;
      long pNum1 = 0;
      Sqlite3.testcase<bool>(pMem.zBLOB == null);
      Sqlite3.sqlite3Atoi64(Encoding.UTF8.GetString(pMem.zBLOB, 0, pMem.n), ref pNum1, pMem.n, pMem.enc);
      return pNum1;
    }

    private static double sqlite3VdbeRealValue(Sqlite3.Mem pMem)
    {
      if (((int) pMem.flags & 8) != 0)
        return pMem.r;
      if (((int) pMem.flags & 4) != 0)
        return (double) pMem.u.i;
      if (((int) pMem.flags & 2) != 0)
      {
        double pResult = 0.0;
        Sqlite3.sqlite3AtoF(pMem.z, ref pResult, pMem.n, pMem.enc);
        return pResult;
      }
      if (((int) pMem.flags & 16) == 0)
        return 0.0;
      double pResult1 = 0.0;
      Sqlite3.sqlite3AtoF(Encoding.UTF8.GetString(pMem.zBLOB, 0, pMem.n), ref pResult1, pMem.n, pMem.enc);
      return pResult1;
    }

    private static void sqlite3VdbeIntegerAffinity(Sqlite3.Mem pMem)
    {
      pMem.u.i = Sqlite3.doubleToInt64(pMem.r);
      if (pMem.r != (double) pMem.u.i || pMem.u.i <= long.MinValue || !Sqlite3.ALWAYS(pMem.u.i < long.MaxValue))
        return;
      pMem.flags |= (ushort) 4;
    }

    private static int sqlite3VdbeMemIntegerify(Sqlite3.Mem pMem)
    {
      pMem.u.i = Sqlite3.sqlite3VdbeIntValue(pMem);
      Sqlite3.MemSetTypeFlag(pMem, 4);
      return 0;
    }

    private static int sqlite3VdbeMemRealify(Sqlite3.Mem pMem)
    {
      pMem.r = Sqlite3.sqlite3VdbeRealValue(pMem);
      Sqlite3.MemSetTypeFlag(pMem, 8);
      return 0;
    }

    private static int sqlite3VdbeMemNumerify(Sqlite3.Mem pMem)
    {
      if (((int) pMem.flags & 13) == 0)
      {
        if (((int) pMem.flags & 16) != 0 && pMem.z == null)
        {
          if (Sqlite3.sqlite3Atoi64(Encoding.UTF8.GetString(pMem.zBLOB, 0, pMem.zBLOB.Length), ref pMem.u.i, pMem.n, pMem.enc) == 0)
          {
            Sqlite3.MemSetTypeFlag(pMem, 4);
          }
          else
          {
            pMem.r = Sqlite3.sqlite3VdbeRealValue(pMem);
            Sqlite3.MemSetTypeFlag(pMem, 8);
            Sqlite3.sqlite3VdbeIntegerAffinity(pMem);
          }
        }
        else if (Sqlite3.sqlite3Atoi64(pMem.z, ref pMem.u.i, pMem.n, pMem.enc) == 0)
        {
          Sqlite3.MemSetTypeFlag(pMem, 4);
        }
        else
        {
          pMem.r = Sqlite3.sqlite3VdbeRealValue(pMem);
          Sqlite3.MemSetTypeFlag(pMem, 8);
          Sqlite3.sqlite3VdbeIntegerAffinity(pMem);
        }
      }
      pMem.flags &= (ushort) 65517;
      return 0;
    }

    private static void sqlite3VdbeMemSetNull(Sqlite3.Mem pMem)
    {
      if (((int) pMem.flags & 64) != 0)
      {
        Sqlite3.VdbeFrame pFrame = pMem.u.pFrame;
        pFrame.pParent = pFrame.v.pDelFrame;
        pFrame.v.pDelFrame = pFrame;
      }
      if (((int) pMem.flags & 32) != 0)
        Sqlite3.sqlite3RowSetClear(pMem.u.pRowSet);
      Sqlite3.MemSetTypeFlag(pMem, 1);
      Sqlite3.sqlite3_free(ref pMem.zBLOB);
      pMem.z = (string) null;
      pMem.type = (byte) 5;
    }

    private static void sqlite3VdbeMemSetZeroBlob(Sqlite3.Mem pMem, int n)
    {
      Sqlite3.sqlite3VdbeMemRelease(pMem);
      pMem.flags = (ushort) 16;
      pMem.type = (byte) 4;
      pMem.n = 0;
      if (n < 0)
        n = 0;
      pMem.u.nZero = n;
      pMem.enc = (byte) 1;
      Sqlite3.sqlite3VdbeMemGrow(pMem, n, 0);
      pMem.n = n;
      pMem.z = (string) null;
      pMem.zBLOB = Sqlite3.sqlite3Malloc(n);
    }

    private static void sqlite3VdbeMemSetInt64(Sqlite3.Mem pMem, long val)
    {
      Sqlite3.sqlite3VdbeMemRelease(pMem);
      pMem.u.i = val;
      pMem.flags = (ushort) 4;
      pMem.type = (byte) 1;
    }

    private static void sqlite3VdbeMemSetDouble(Sqlite3.Mem pMem, double val)
    {
      if (Sqlite3.sqlite3IsNaN(val))
      {
        Sqlite3.sqlite3VdbeMemSetNull(pMem);
      }
      else
      {
        Sqlite3.sqlite3VdbeMemRelease(pMem);
        pMem.r = val;
        pMem.flags = (ushort) 8;
        pMem.type = (byte) 2;
      }
    }

    private static void sqlite3VdbeMemSetRowSet(Sqlite3.Mem pMem)
    {
      Sqlite3.sqlite3 db = pMem.db;
      Sqlite3.sqlite3VdbeMemRelease(pMem);
      pMem.u.pRowSet = new Sqlite3.RowSet(db, 5);
      pMem.flags = (ushort) 32;
    }

    private static bool sqlite3VdbeMemTooBig(Sqlite3.Mem p)
    {
      if (((int) p.flags & 18) == 0)
        return false;
      int n = p.n;
      if (((int) p.flags & 0) != 0)
        n += p.u.nZero;
      return n > p.db.aLimit[0];
    }

    private static void sqlite3VdbeMemShallowCopy(Sqlite3.Mem pTo, Sqlite3.Mem pFrom, int srcType)
    {
      Sqlite3.sqlite3VdbeMemReleaseExternal(pTo);
      pFrom.CopyTo(ref pTo);
      pTo.xDel = (Sqlite3.dxDel) null;
      if (((int) pFrom.flags & 2048) == 0)
        return;
      pTo.flags = (ushort) ((uint) pFrom.flags & 4294960127U);
      pTo.flags |= (ushort) srcType;
    }

    private static int sqlite3VdbeMemCopy(Sqlite3.Mem pTo, Sqlite3.Mem pFrom)
    {
      int num = 0;
      Sqlite3.sqlite3VdbeMemReleaseExternal(pTo);
      pFrom.CopyTo(ref pTo);
      pTo.flags &= (ushort) 64511;
      if (((int) pTo.flags & 18) != 0 && ((int) pFrom.flags & 2048) == 0)
      {
        pTo.flags |= (ushort) 4096;
        num = Sqlite3.sqlite3VdbeMemMakeWriteable(pTo);
      }
      return num;
    }

    private static void sqlite3VdbeMemMove(Sqlite3.Mem pTo, Sqlite3.Mem pFrom)
    {
      Sqlite3.sqlite3VdbeMemRelease(pTo);
      pFrom.CopyTo(ref pTo);
      pFrom.flags = (ushort) 1;
      pFrom.xDel = (Sqlite3.dxDel) null;
      pFrom.z = (string) null;
      Sqlite3.sqlite3_free(ref pFrom.zBLOB);
    }

    private static int sqlite3VdbeMemSetBlob(
      Sqlite3.Mem pMem,
      byte[] zBlob,
      int n,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      return Sqlite3.sqlite3VdbeMemSetBlob(pMem, zBlob, 0, n >= 0 ? n : zBlob.Length, enc, xDel);
    }

    private static int sqlite3VdbeMemSetBlob(
      Sqlite3.Mem pMem,
      byte[] zBlob,
      int offset,
      int n,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      int num1 = n;
      if (zBlob == null || zBlob.Length < offset)
      {
        Sqlite3.sqlite3VdbeMemSetNull(pMem);
        return 0;
      }
      int num2 = pMem.db == null ? 1000000000 : pMem.db.aLimit[0];
      if (num1 < 0)
      {
        if (enc == (byte) 1)
        {
          num1 = 0;
          while (num1 <= num2 && num1 < zBlob.Length - offset && zBlob[offset + num1] != (byte) 0)
            ++num1;
        }
        else
        {
          num1 = 0;
          while (num1 <= num2 && zBlob[num1 + offset] != (byte) 0 || zBlob[offset + num1 + 1] != (byte) 0)
            num1 += 2;
        }
      }
      pMem.z = (string) null;
      pMem.zBLOB = Sqlite3.sqlite3Malloc(n);
      Buffer.BlockCopy((Array) zBlob, offset, (Array) pMem.zBLOB, 0, n);
      pMem.n = num1;
      pMem.flags = (ushort) 528;
      pMem.enc = enc == (byte) 0 ? (byte) 1 : enc;
      pMem.type = enc == (byte) 0 ? (byte) 4 : (byte) 3;
      return num1 > num2 ? 18 : 0;
    }

    private static int sqlite3VdbeMemSetStr(
      Sqlite3.Mem pMem,
      string z,
      int n,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      return Sqlite3.sqlite3VdbeMemSetStr(pMem, z, 0, n, enc, xDel);
    }

    private static int sqlite3VdbeMemSetStr(
      Sqlite3.Mem pMem,
      string z,
      int offset,
      int n,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      int num1 = n;
      if (z == null || z.Length < offset)
      {
        Sqlite3.sqlite3VdbeMemSetNull(pMem);
        return 0;
      }
      int num2 = pMem.db == null ? 1000000000 : pMem.db.aLimit[0];
      ushort num3 = enc == (byte) 0 ? (ushort) 16 : (ushort) 2;
      if (num1 < 0)
      {
        if (enc == (byte) 1)
        {
          num1 = 0;
          while (num1 <= num2 && num1 < z.Length - offset && z[offset + num1] != char.MinValue)
            ++num1;
        }
        else
        {
          num1 = 0;
          while (num1 <= num2 && z[num1 + offset] != char.MinValue || z[offset + num1 + 1] != char.MinValue)
            num1 += 2;
        }
        num3 |= (ushort) 512;
      }
      if (xDel == Sqlite3.SQLITE_TRANSIENT)
      {
        uint n1 = (uint) num1;
        if (((int) num3 & 512) != 0)
          n1 += enc == (byte) 1 ? 1U : 2U;
        if (num1 > num2)
          return 18;
        if (Sqlite3.sqlite3VdbeMemGrow(pMem, (int) n1, 0) != 0)
          return 7;
        if (enc == (byte) 0)
        {
          pMem.z = (string) null;
          pMem.zBLOB = Sqlite3.sqlite3Malloc(n);
          for (int index = 0; index < n && index < z.Length - offset; ++index)
            pMem.zBLOB[index] = (byte) z[offset + index];
        }
        else
        {
          pMem.z = n <= 0 || z.Length - offset <= n ? z.Substring(offset) : z.Substring(offset, n);
          Sqlite3.sqlite3_free(ref pMem.zBLOB);
        }
      }
      else if (xDel == Sqlite3.SQLITE_DYNAMIC)
      {
        Sqlite3.sqlite3VdbeMemRelease(pMem);
        if (enc == (byte) 0)
        {
          pMem.z = (string) null;
          if (pMem.zBLOB != null)
            Sqlite3.sqlite3_free(ref pMem.zBLOB);
          pMem.zBLOB = Encoding.UTF8.GetBytes(offset == 0 ? z : (z.Length + offset < n ? z.Substring(offset, n) : z.Substring(offset)));
        }
        else
        {
          pMem.z = n <= 0 || z.Length - offset <= n ? z.Substring(offset) : z.Substring(offset, n);
          Sqlite3.sqlite3_free(ref pMem.zBLOB);
        }
        pMem.xDel = (Sqlite3.dxDel) null;
      }
      else
      {
        Sqlite3.sqlite3VdbeMemRelease(pMem);
        if (enc == (byte) 0)
        {
          pMem.z = (string) null;
          if (pMem.zBLOB != null)
            Sqlite3.sqlite3_free(ref pMem.zBLOB);
          pMem.zBLOB = Encoding.UTF8.GetBytes(offset == 0 ? z : (z.Length + offset < n ? z.Substring(offset, n) : z.Substring(offset)));
        }
        else
        {
          pMem.z = n <= 0 || z.Length - offset <= n ? z.Substring(offset) : z.Substring(offset, n);
          Sqlite3.sqlite3_free(ref pMem.zBLOB);
        }
        pMem.xDel = xDel;
        num3 |= xDel == Sqlite3.SQLITE_STATIC ? (ushort) 2048 : (ushort) 1024;
      }
      pMem.n = num1;
      pMem.flags = num3;
      pMem.enc = enc == (byte) 0 ? (byte) 1 : enc;
      pMem.type = enc == (byte) 0 ? (byte) 4 : (byte) 3;
      return num1 > num2 ? 18 : 0;
    }

    private static int sqlite3MemCompare(
      Sqlite3.Mem pMem1,
      Sqlite3.Mem pMem2,
      Sqlite3.CollSeq pColl)
    {
      int flags1 = (int) pMem1.flags;
      int flags2 = (int) pMem2.flags;
      int num1 = flags1 | flags2;
      if ((num1 & 1) != 0)
        return (flags2 & 1) - (flags1 & 1);
      if ((num1 & 12) != 0)
      {
        if ((flags1 & 12) == 0)
          return 1;
        if ((flags2 & 12) == 0)
          return -1;
        if ((flags1 & flags2 & 4) == 0)
        {
          double num2 = (flags1 & 8) != 0 ? pMem1.r : (double) pMem1.u.i;
          double num3 = (flags2 & 8) != 0 ? pMem2.r : (double) pMem2.u.i;
          if (num2 < num3)
            return -1;
          return num2 > num3 ? 1 : 0;
        }
        if (pMem1.u.i < pMem2.u.i)
          return -1;
        return pMem1.u.i > pMem2.u.i ? 1 : 0;
      }
      if ((num1 & 2) != 0)
      {
        if ((flags1 & 2) == 0)
          return 1;
        if ((flags2 & 2) == 0)
          return -1;
        if (pColl != null)
        {
          if ((int) pMem1.enc == (int) pColl.enc)
            return pColl.xCmp(pColl.pUser, pMem1.n, pMem1.z, pMem2.n, pMem2.z);
          Sqlite3.Mem pMem3 = (Sqlite3.Mem) null;
          Sqlite3.Mem pMem4 = (Sqlite3.Mem) null;
          Sqlite3.Mem mem1 = Sqlite3.sqlite3Malloc(pMem3);
          Sqlite3.Mem mem2 = Sqlite3.sqlite3Malloc(pMem4);
          Sqlite3.sqlite3VdbeMemShallowCopy(mem1, pMem1, 4096);
          Sqlite3.sqlite3VdbeMemShallowCopy(mem2, pMem2, 4096);
          string Key1 = Sqlite3.sqlite3ValueText(mem1, (int) pColl.enc);
          int size1 = Key1 == null ? 0 : mem1.n;
          string Key2 = Sqlite3.sqlite3ValueText(mem2, (int) pColl.enc);
          int size2 = Key2 == null ? 0 : mem2.n;
          int num4 = pColl.xCmp(pColl.pUser, size1, Key1, size2, Key2);
          Sqlite3.sqlite3VdbeMemRelease(mem1);
          Sqlite3.sqlite3VdbeMemRelease(mem2);
          return num4;
        }
      }
      int num5 = ((int) pMem1.flags & 16) == 0 ? Sqlite3.memcmp(pMem1.z, pMem2.z, pMem1.n > pMem2.n ? pMem2.n : pMem1.n) : (pMem1.zBLOB == null ? Sqlite3.memcmp(pMem1.z, pMem2.zBLOB, pMem1.n > pMem2.n ? pMem2.n : pMem1.n) : Sqlite3.memcmp(pMem1.zBLOB, pMem2.zBLOB, pMem1.n > pMem2.n ? pMem2.n : pMem1.n));
      if (num5 == 0)
        num5 = pMem1.n - pMem2.n;
      return num5;
    }

    private static int sqlite3VdbeMemFromBtree(
      Sqlite3.BtCursor pCur,
      int offset,
      int amt,
      bool key,
      Sqlite3.Mem pMem)
    {
      int pAmt = 0;
      int num = 0;
      int outOffset = -1;
      byte[] p = !key ? Sqlite3.sqlite3BtreeDataFetch(pCur, ref pAmt, ref outOffset) : Sqlite3.sqlite3BtreeKeyFetch(pCur, ref pAmt, ref outOffset);
      if (offset + amt <= pAmt && ((int) pMem.flags & 1024) == 0)
      {
        Sqlite3.sqlite3VdbeMemRelease(pMem);
        pMem.zBLOB = Sqlite3.sqlite3Malloc(amt);
        Buffer.BlockCopy((Array) p, offset, (Array) pMem.zBLOB, 0, amt);
        pMem.flags = (ushort) 4112;
      }
      else if ((num = Sqlite3.sqlite3VdbeMemGrow(pMem, amt + 2, 0)) == 0)
      {
        pMem.enc = (byte) 0;
        pMem.type = (byte) 4;
        pMem.z = (string) null;
        pMem.zBLOB = Sqlite3.sqlite3Malloc(amt);
        pMem.flags = (ushort) 1552;
        num = !key ? Sqlite3.sqlite3BtreeData(pCur, (uint) offset, (uint) amt, pMem.zBLOB) : Sqlite3.sqlite3BtreeKey(pCur, (uint) offset, (uint) amt, pMem.zBLOB);
        if (num != 0)
          Sqlite3.sqlite3VdbeMemRelease(pMem);
      }
      pMem.n = amt;
      Sqlite3.sqlite3_free(ref p);
      return num;
    }

    private static string sqlite3ValueText(Sqlite3.Mem pVal, int enc)
    {
      if (pVal == null)
        return (string) null;
      if (((int) pVal.flags & 1) != 0)
        return (string) null;
      pVal.flags |= (ushort) (((int) pVal.flags & 16) >> 3);
      if (((int) pVal.flags & 0) != 0)
        Sqlite3.sqlite3VdbeMemExpandBlob(pVal);
      if (((int) pVal.flags & 2) != 0)
      {
        if (Sqlite3.sqlite3VdbeChangeEncoding(pVal, enc & -9) != 0)
          return (string) null;
        if ((enc & 8) != 0 && 1 == (1 & (int) pVal.z[0]) && Sqlite3.sqlite3VdbeMemMakeWriteable(pVal) != 0)
          return (string) null;
        Sqlite3.sqlite3VdbeMemNulTerminate(pVal);
      }
      else
        Sqlite3.sqlite3VdbeMemStringify(pVal, enc);
      return (int) pVal.enc == (enc & -9) ? pVal.z : (string) null;
    }

    private static Sqlite3.Mem sqlite3ValueNew(Sqlite3.sqlite3 db)
    {
      Sqlite3.Mem m = (Sqlite3.Mem) null;
      Sqlite3.Mem mem = Sqlite3.sqlite3DbMallocZero(db, m);
      mem.flags = (ushort) 1;
      mem.type = (byte) 5;
      mem.db = db;
      return mem;
    }

    private static int sqlite3ValueFromExpr(
      Sqlite3.sqlite3 db,
      Sqlite3.Expr pExpr,
      int enc,
      char affinity,
      ref Sqlite3.Mem ppVal)
    {
      string pString = "";
      Sqlite3.Mem ppVal1 = (Sqlite3.Mem) null;
      int num1 = 1;
      string str = "";
      if (pExpr == null)
      {
        ppVal = (Sqlite3.Mem) null;
        return 0;
      }
      int num2 = (int) pExpr.op;
      if (Sqlite3.NEVER(num2 == 132))
        num2 = (int) pExpr.op2;
      if (num2 == 156 && (pExpr.pLeft.op == (byte) 129 || pExpr.pLeft.op == (byte) 130))
      {
        pExpr = pExpr.pLeft;
        num2 = (int) pExpr.op;
        num1 = -1;
        str = "-";
      }
      if (num2 == 94 || num2 == 130 || num2 == 129)
      {
        ppVal1 = Sqlite3.sqlite3ValueNew(db);
        if (ppVal1 != null)
        {
          if (Sqlite3.ExprHasProperty(pExpr, 1024))
          {
            Sqlite3.sqlite3VdbeMemSetInt64(ppVal1, (long) pExpr.u.iValue * (long) num1);
          }
          else
          {
            pString = Sqlite3.sqlite3MPrintf(db, "%s%s", (object) str, (object) pExpr.u.zToken);
            Sqlite3.sqlite3ValueSetStr(ppVal1, -1, pString, (byte) 1, Sqlite3.SQLITE_DYNAMIC);
            if (num2 == 130)
              ppVal1.type = (byte) 2;
          }
          if ((num2 == 129 || num2 == 130) && affinity == 'b')
            Sqlite3.sqlite3ValueApplyAffinity(ppVal1, 'c', 1);
          else
            Sqlite3.sqlite3ValueApplyAffinity(ppVal1, affinity, 1);
          if (((int) ppVal1.flags & 12) != 0)
            ppVal1.flags &= (ushort) 65533;
          if (enc != 1)
            Sqlite3.sqlite3VdbeChangeEncoding(ppVal1, enc);
        }
        else
          goto label_33;
      }
      if (enc != 1)
      {
        Sqlite3.sqlite3VdbeChangeEncoding(ppVal1, enc);
      }
      else
      {
        switch (num2)
        {
          case 98:
            ppVal1 = Sqlite3.sqlite3ValueNew(db);
            if (ppVal1 != null)
              break;
            goto label_33;
          case 131:
            ppVal1 = Sqlite3.sqlite3ValueNew(db);
            if (ppVal1 != null)
            {
              string z = pExpr.u.zToken.Substring(2);
              int n = Sqlite3.sqlite3Strlen30(z) - 1;
              byte[] blob = Sqlite3.sqlite3HexToBlob(db, z, n);
              Sqlite3.sqlite3VdbeMemSetStr(ppVal1, Encoding.UTF8.GetString(blob, 0, blob.Length), n / 2, (byte) 0, Sqlite3.SQLITE_DYNAMIC);
              break;
            }
            goto label_33;
          case 156:
            if (Sqlite3.sqlite3ValueFromExpr(db, pExpr.pLeft, enc, affinity, ref ppVal1) == 0)
            {
              Sqlite3.sqlite3VdbeMemNumerify(ppVal1);
              if (ppVal1.u.i == long.MinValue)
              {
                ppVal1.flags &= (ushort) 4;
                ppVal1.flags |= (ushort) 8;
                ppVal1.r = (double) long.MaxValue;
              }
              else
                ppVal1.u.i = -ppVal1.u.i;
              ppVal1.r = -ppVal1.r;
              Sqlite3.sqlite3ValueApplyAffinity(ppVal1, affinity, enc);
              break;
            }
            break;
        }
      }
      if (ppVal1 != null)
        Sqlite3.sqlite3VdbeMemStoreType(ppVal1);
      ppVal = ppVal1;
      return 0;
label_33:
      Sqlite3.sqlite3DbFree(db, ref pString);
      ppVal = (Sqlite3.Mem) null;
      return 7;
    }

    private static void sqlite3ValueSetStr(
      Sqlite3.Mem v,
      int n,
      string z,
      byte enc,
      Sqlite3.dxDel xDel)
    {
      if (v == null)
        return;
      Sqlite3.sqlite3VdbeMemSetStr(v, z, n, enc, xDel);
    }

    private static void sqlite3ValueFree(ref Sqlite3.Mem v)
    {
      if (v == null)
        return;
      Sqlite3.sqlite3VdbeMemRelease(v);
      Sqlite3.sqlite3DbFree(v.db, ref v);
    }

    private static int sqlite3ValueBytes(Sqlite3.Mem pVal, int enc)
    {
      Sqlite3.Mem mem = pVal;
      if (((int) mem.flags & 16) == 0 && Sqlite3.sqlite3ValueText(pVal, enc) == null)
        return 0;
      if (((int) mem.flags & 0) != 0)
        return mem.n + mem.u.nZero;
      return mem.z != null ? mem.n : mem.zBLOB.Length;
    }

    private static int findNextHostParameter(string zSql, int iOffset, ref int pnToken)
    {
      int tokenType = 0;
      int nextHostParameter = 0;
      pnToken = 0;
      int token;
      for (; iOffset < zSql.Length; iOffset += token)
      {
        token = Sqlite3.sqlite3GetToken(zSql, iOffset, ref tokenType);
        if (tokenType == 133)
        {
          pnToken = token;
          break;
        }
        nextHostParameter += token;
      }
      return nextHostParameter;
    }

    private static string sqlite3VdbeExpandSql(Sqlite3.Vdbe p, string zRawSql)
    {
      int pValue = 0;
      int num1 = 1;
      int pnToken = 0;
      Sqlite3.StrAccum p1 = new Sqlite3.StrAccum(1000);
      StringBuilder stringBuilder = new StringBuilder(100);
      int num2 = 0;
      Sqlite3.sqlite3 db = p.db;
      Sqlite3.sqlite3StrAccumInit(p1, (StringBuilder) null, 100, db.aLimit[0]);
      p1.db = db;
      if (db.vdbeExecCnt > 1)
      {
        while (num2 < zRawSql.Length)
        {
          do
            ;
          while (zRawSql[num2++] != '\n' && num2 < zRawSql.Length);
          Sqlite3.sqlite3StrAccumAppend(p1, "-- ", 3);
          Sqlite3.sqlite3StrAccumAppend(p1, zRawSql, num2);
        }
      }
      else
      {
        while (num2 < zRawSql.Length)
        {
          int nextHostParameter = Sqlite3.findNextHostParameter(zRawSql, num2, ref pnToken);
          Sqlite3.sqlite3StrAccumAppend(p1, zRawSql.Substring(num2, nextHostParameter), nextHostParameter);
          int num3 = num2 + nextHostParameter;
          if (pnToken != 0)
          {
            if (zRawSql[num3] == '?')
            {
              if (pnToken > 1)
                Sqlite3.sqlite3GetInt32(zRawSql, num3 + 1, ref pValue);
              else
                pValue = num1;
            }
            else
            {
              Sqlite3.testcase<bool>(zRawSql[num3] == ':');
              Sqlite3.testcase<bool>(zRawSql[num3] == '$');
              Sqlite3.testcase<bool>(zRawSql[num3] == '@');
              pValue = Sqlite3.sqlite3VdbeParameterIndex(p, zRawSql.Substring(num3, pnToken), pnToken);
            }
            num2 = num3 + pnToken;
            num1 = pValue + 1;
            Sqlite3.Mem mem = p.aVar[pValue - 1];
            if (((int) mem.flags & 1) != 0)
              Sqlite3.sqlite3StrAccumAppend(p1, "NULL", 4);
            else if (((int) mem.flags & 4) != 0)
              Sqlite3.sqlite3XPrintf(p1, "%lld", (object) mem.u.i);
            else if (((int) mem.flags & 8) != 0)
              Sqlite3.sqlite3XPrintf(p1, "%!.15g", (object) mem.r);
            else if (((int) mem.flags & 2) != 0)
              Sqlite3.sqlite3XPrintf(p1, "'%.*q'", (object) mem.n, (object) mem.z);
            else if (((int) mem.flags & 0) != 0)
            {
              Sqlite3.sqlite3XPrintf(p1, "zeroblob(%d)", (object) mem.u.nZero);
            }
            else
            {
              Sqlite3.sqlite3StrAccumAppend(p1, "x'", 2);
              for (int index = 0; index < mem.n; ++index)
                Sqlite3.sqlite3XPrintf(p1, "%02x", (object) ((int) mem.zBLOB[index] & (int) byte.MaxValue));
              Sqlite3.sqlite3StrAccumAppend(p1, "'", 1);
            }
          }
          else
            break;
        }
      }
      return Sqlite3.sqlite3StrAccumFinish(p1);
    }

    private static void memAboutToChange(Sqlite3.Vdbe P, Sqlite3.Mem M)
    {
    }

    private static void UPDATE_MAX_BLOBSIZE(Sqlite3.Mem P)
    {
    }

    private static void Deephemeralize(Sqlite3.Mem P)
    {
    }

    private static int ExpandBlob(Sqlite3.Mem P) => ((int) P.flags & 0) == 0 ? 0 : Sqlite3.sqlite3VdbeMemExpandBlob(P);

    private static void sqlite3VdbeMemStoreType(Sqlite3.Mem pMem)
    {
      int flags = (int) pMem.flags;
      if ((flags & 1) != 0)
      {
        pMem.type = (byte) 5;
        pMem.z = (string) null;
        pMem.zBLOB = (byte[]) null;
      }
      else if ((flags & 4) != 0)
        pMem.type = (byte) 1;
      else if ((flags & 8) != 0)
        pMem.type = (byte) 2;
      else if ((flags & 2) != 0)
        pMem.type = (byte) 3;
      else
        pMem.type = (byte) 4;
    }

    private static Sqlite3.VdbeCursor allocateCursor(
      Sqlite3.Vdbe p,
      int iCur,
      int nField,
      int iDb,
      int isBtreeCursor)
    {
      if (p.apCsr[iCur] != null)
      {
        Sqlite3.sqlite3VdbeFreeCursor(p, p.apCsr[iCur]);
        p.apCsr[iCur] = (Sqlite3.VdbeCursor) null;
      }
      Sqlite3.VdbeCursor vdbeCursor;
      p.apCsr[iCur] = vdbeCursor = new Sqlite3.VdbeCursor();
      vdbeCursor.iDb = iDb;
      vdbeCursor.nField = nField;
      if (nField != 0)
        vdbeCursor.aType = new uint[nField];
      if (isBtreeCursor != 0)
      {
        vdbeCursor.pCursor = Sqlite3.sqlite3MemMallocBtCursor(vdbeCursor.pCursor);
        Sqlite3.sqlite3BtreeCursorZero(vdbeCursor.pCursor);
      }
      return vdbeCursor;
    }

    private static void applyNumericAffinity(Sqlite3.Mem pRec)
    {
      if (((int) pRec.flags & 12) != 0)
        return;
      double pResult = 0.0;
      long pNum = 0;
      byte enc = pRec.enc;
      if (((int) pRec.flags & 2) == 0 || !Sqlite3.sqlite3AtoF(pRec.z, ref pResult, pRec.n, enc))
        return;
      if (Sqlite3.sqlite3Atoi64(pRec.z, ref pNum, pRec.n, enc) == 0)
      {
        pRec.u.i = pNum;
        pRec.flags |= (ushort) 4;
      }
      else
      {
        pRec.r = pResult;
        pRec.flags |= (ushort) 8;
      }
    }

    private static void applyAffinity(Sqlite3.Mem pRec, char affinity, int enc)
    {
      switch (affinity)
      {
        case 'a':
          if (((int) pRec.flags & 2) == 0 && ((int) pRec.flags & 12) != 0)
            Sqlite3.sqlite3VdbeMemStringify(pRec, enc);
          if (((int) pRec.flags & 18) == 18)
          {
            StringBuilder stringBuilder = new StringBuilder(pRec.zBLOB.Length);
            for (int index = 0; index < pRec.zBLOB.Length; ++index)
              stringBuilder.Append((char) pRec.zBLOB[index]);
            pRec.z = stringBuilder.ToString();
            Sqlite3.sqlite3_free(ref pRec.zBLOB);
            pRec.flags &= (ushort) 65519;
          }
          pRec.flags &= (ushort) 65523;
          break;
        case 'b':
          break;
        default:
          Sqlite3.applyNumericAffinity(pRec);
          if (((int) pRec.flags & 8) == 0)
            break;
          Sqlite3.sqlite3VdbeIntegerAffinity(pRec);
          break;
      }
    }

    private static int sqlite3_value_numeric_type(Sqlite3.Mem pVal)
    {
      Sqlite3.Mem mem = pVal;
      if (mem.type == (byte) 3)
      {
        Sqlite3.applyNumericAffinity(mem);
        Sqlite3.sqlite3VdbeMemStoreType(mem);
      }
      return (int) mem.type;
    }

    private static void sqlite3ValueApplyAffinity(Sqlite3.Mem pVal, char affinity, int enc) => Sqlite3.applyAffinity(pVal, affinity, enc);

    private static void REGISTER_TRACE(Sqlite3.Vdbe p, int R, Sqlite3.Mem M)
    {
    }

    private static int checkSavepointCount(Sqlite3.sqlite3 db) => 1;

    private static void importVtabErrMsg(Sqlite3.Vdbe p, Sqlite3.sqlite3_vtab pVtab)
    {
      Sqlite3.sqlite3DbFree(p.db, ref p.zErrMsg);
      p.zErrMsg = pVtab.zErrMsg;
      pVtab.zErrMsg = (string) null;
    }

    private static int sqlite3VdbeExec(Sqlite3.Vdbe p)
    {
      int index1 = 0;
      Sqlite3.VdbeOp[] aOp = p.aOp;
      int num1 = 0;
      Sqlite3.sqlite3 db1 = p.db;
      byte num2 = 0;
      byte num3 = Sqlite3.ENC(db1);
      int num4 = 0;
      Sqlite3.Mem[] memArray1 = p.aMem;
      Sqlite3.Mem mem1 = (Sqlite3.Mem) null;
      Sqlite3.Mem mem2 = (Sqlite3.Mem) null;
      int num5 = 0;
      int[] numArray1 = (int[]) null;
      long num6 = db1.lastRowid;
      Sqlite3.sqlite3VdbeEnter(p);
      int num7;
      if (p.rc != 7)
      {
        p.rc = 0;
        p.pResultSet = (Sqlite3.Mem[]) null;
        db1.busyHandler.nBusy = 0;
        if (!db1.u1.isInterrupted)
        {
          bool flag1 = db1.xProgress != null;
          index1 = p.pc;
          while (num1 == 0)
          {
            Sqlite3.VdbeOp vdbeOp = aOp[index1];
            if (flag1)
            {
              if (db1.nProgressOps == num4)
              {
                if (db1.xProgress(db1.pProgressArg) != 0)
                {
                  num1 = 9;
                  break;
                }
                num4 = 0;
              }
              ++num4;
            }
            if (((int) vdbeOp.opflags & 2) != 0)
            {
              mem2 = memArray1[vdbeOp.p2];
              Sqlite3.memAboutToChange(p, mem2);
              Sqlite3.sqlite3VdbeMemReleaseExternal(mem2);
              mem2.flags = (ushort) 4;
            }
            switch (vdbeOp.opcode)
            {
              case 1:
                if (!db1.u1.isInterrupted)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto label_681;
              case 2:
                Sqlite3.Mem M1 = memArray1[vdbeOp.p1];
                Sqlite3.memAboutToChange(p, M1);
                M1.flags = (ushort) 4;
                M1.u.i = (long) index1;
                Sqlite3.REGISTER_TRACE(p, vdbeOp.p1, M1);
                index1 = vdbeOp.p2 - 1;
                goto default;
              case 3:
                index1 = (int) memArray1[vdbeOp.p1].u.i;
                goto default;
              case 4:
                Sqlite3.Mem M2 = memArray1[vdbeOp.p1];
                M2.flags = (ushort) 4;
                int i1 = (int) M2.u.i;
                M2.u.i = (long) index1;
                Sqlite3.REGISTER_TRACE(p, vdbeOp.p1, M2);
                index1 = i1;
                goto default;
              case 5:
                if (((int) memArray1[vdbeOp.p3].flags & 1) == 0)
                  goto default;
                else
                  goto case 6;
              case 6:
                mem1 = memArray1[vdbeOp.p3];
                if (vdbeOp.p1 == 0 && p.pFrame != null)
                {
                  Sqlite3.VdbeFrame pFrame = p.pFrame;
                  p.pFrame = pFrame.pParent;
                  --p.nFrame;
                  Sqlite3.sqlite3VdbeSetChanges(db1, p.nChange);
                  index1 = Sqlite3.sqlite3VdbeFrameRestore(pFrame);
                  num6 = db1.lastRowid;
                  if (vdbeOp.p2 == 4)
                    index1 = p.aOp[index1].p2 - 1;
                  aOp = p.aOp;
                  memArray1 = p.aMem;
                  goto default;
                }
                else
                {
                  p.rc = vdbeOp.p1;
                  p.errorAction = (byte) vdbeOp.p2;
                  p.pc = index1;
                  if (vdbeOp.p4.z != null)
                  {
                    Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "%s", vdbeOp.p4.z);
                    Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
                    Sqlite3.sqlite3_log(vdbeOp.p1, "abort at %d in [%s]: %s", (object) index1, (object) p.zSql, (object) vdbeOp.p4.z);
                  }
                  else if (p.rc != 0)
                  {
                    Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
                    Sqlite3.sqlite3_log(vdbeOp.p1, "constraint failed at %d in [%s]", (object) index1, (object) p.zSql);
                  }
                  if (Sqlite3.sqlite3VdbeHalt(p) == 5)
                  {
                    p.rc = num7 = 5;
                    goto label_676;
                  }
                  else
                  {
                    num7 = p.rc != 0 ? 1 : 101;
                    goto label_676;
                  }
                }
              case 7:
                mem2.u.i = (long) vdbeOp.p1;
                goto default;
              case 8:
                mem2.u.i = vdbeOp.p4.pI64;
                goto default;
              case 9:
                mem2.flags = (ushort) 2562;
                Sqlite3.sqlite3_free(ref mem2.zBLOB);
                mem2.z = vdbeOp.p4.z;
                mem2.n = vdbeOp.p1;
                mem2.enc = (byte) 1;
                goto default;
              case 10:
                mem2.flags = (ushort) 1;
                goto default;
              case 11:
                Sqlite3.sqlite3VdbeMemSetStr(mem2, vdbeOp.p4.z, vdbeOp.p1, (byte) 0, (Sqlite3.dxDel) null);
                mem2.enc = num3;
                goto default;
              case 12:
                Sqlite3.Mem mem3 = p.aVar[vdbeOp.p1 - 1];
                if (!Sqlite3.sqlite3VdbeMemTooBig(mem3))
                {
                  Sqlite3.sqlite3VdbeMemShallowCopy(mem2, mem3, 2048);
                  goto default;
                }
                else
                  break;
              case 13:
                int p3_1 = vdbeOp.p3;
                int p1_1 = vdbeOp.p1;
                int p2_1 = vdbeOp.p2;
                while (p3_1-- != 0)
                {
                  Sqlite3.Mem pFrom = memArray1[p1_1 + vdbeOp.p3 - p3_1 - 1];
                  mem2 = memArray1[p2_1];
                  Sqlite3.memAboutToChange(p, mem2);
                  Sqlite3.sqlite3VdbeMemMove(mem2, pFrom);
                  Sqlite3.REGISTER_TRACE(p, p2_1++, mem2);
                }
                goto default;
              case 14:
                Sqlite3.Mem pFrom1 = memArray1[vdbeOp.p1];
                mem2 = memArray1[vdbeOp.p2];
                Sqlite3.sqlite3VdbeMemShallowCopy(mem2, pFrom1, 4096);
                if (((int) mem2.flags & 4096) == 0 || Sqlite3.sqlite3VdbeMemMakeWriteable(mem2) == 0)
                {
                  Sqlite3.REGISTER_TRACE(p, vdbeOp.p2, mem2);
                  goto default;
                }
                else
                  goto label_678;
              case 15:
                Sqlite3.Mem pFrom2 = memArray1[vdbeOp.p1];
                mem2 = memArray1[vdbeOp.p2];
                Sqlite3.sqlite3VdbeMemShallowCopy(mem2, pFrom2, 4096);
                Sqlite3.REGISTER_TRACE(p, vdbeOp.p2, mem2);
                goto default;
              case 16:
                if ((num1 = Sqlite3.sqlite3VdbeCheckFk(p, 0)) == 0)
                {
                  num1 = Sqlite3.sqlite3VdbeCloseStatement(p, 1);
                  if (!Sqlite3.NEVER(num1 != 0))
                  {
                    p.cacheCtr = (uint) ((int) p.cacheCtr + 2 | 1);
                    p.pResultSet = new Sqlite3.Mem[vdbeOp.p2];
                    for (int index2 = 0; index2 < vdbeOp.p2; ++index2)
                    {
                      p.pResultSet[index2] = memArray1[vdbeOp.p1 + index2];
                      Sqlite3.sqlite3VdbeMemNulTerminate(p.pResultSet[index2]);
                      Sqlite3.sqlite3VdbeMemStoreType(p.pResultSet[index2]);
                      Sqlite3.REGISTER_TRACE(p, vdbeOp.p1 + index2, p.pResultSet[index2]);
                    }
                    p.pc = index1 + 1;
                    num7 = 100;
                    goto label_676;
                  }
                  else
                    goto default;
                }
                else
                  goto default;
              case 18:
                Sqlite3.sqlite3_context ctx1 = new Sqlite3.sqlite3_context();
                int p5_1 = (int) vdbeOp.p5;
                Sqlite3.Mem[] apArg1 = p.apArg;
                mem2 = memArray1[vdbeOp.p3];
                Sqlite3.memAboutToChange(p, mem2);
                for (int index3 = 0; index3 < p5_1; ++index3)
                {
                  Sqlite3.Mem mem4 = memArray1[vdbeOp.p2 + index3];
                  apArg1[index3] = mem4;
                  Sqlite3.Deephemeralize(mem4);
                  Sqlite3.sqlite3VdbeMemStoreType(mem4);
                  Sqlite3.REGISTER_TRACE(p, vdbeOp.p2 + index3, mem4);
                }
                if (vdbeOp.p4type == -5)
                {
                  ctx1.pFunc = vdbeOp.p4.pFunc;
                  ctx1.pVdbeFunc = (Sqlite3.VdbeFunc) null;
                }
                else
                {
                  ctx1.pVdbeFunc = vdbeOp.p4.pVdbeFunc;
                  ctx1.pFunc = ctx1.pVdbeFunc.pFunc;
                }
                ctx1.s.flags = (ushort) 1;
                ctx1.s.db = db1;
                ctx1.s.xDel = (Sqlite3.dxDel) null;
                Sqlite3.sqlite3VdbeMemMove(ctx1.s, mem2);
                Sqlite3.MemSetTypeFlag(ctx1.s, 1);
                ctx1.isError = 0;
                if (((int) ctx1.pFunc.flags & 8) != 0)
                  ctx1.pColl = p.aOp[index1 - 1].p4.pColl;
                db1.lastRowid = num6;
                ctx1.pFunc.xFunc(ctx1, p5_1, apArg1);
                num6 = db1.lastRowid;
                if (ctx1.pVdbeFunc != null)
                {
                  Sqlite3.sqlite3VdbeDeleteAuxData(ctx1.pVdbeFunc, vdbeOp.p1);
                  vdbeOp.p4.pVdbeFunc = ctx1.pVdbeFunc;
                  vdbeOp.p4type = -7;
                }
                if (ctx1.isError != 0)
                {
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, Sqlite3.sqlite3_value_text(ctx1.s));
                  num1 = ctx1.isError;
                }
                Sqlite3.sqlite3VdbeChangeEncoding(ctx1.s, (int) num3);
                Sqlite3.sqlite3VdbeMemMove(mem2, ctx1.s);
                if (!Sqlite3.sqlite3VdbeMemTooBig(mem2))
                {
                  Sqlite3.REGISTER_TRACE(p, vdbeOp.p3, mem2);
                  goto default;
                }
                else
                  break;
              case 19:
                Sqlite3.Mem pMem1 = memArray1[vdbeOp.p1];
                mem2 = memArray1[vdbeOp.p2];
                if (((int) pMem1.flags & 1) != 0)
                {
                  Sqlite3.sqlite3VdbeMemSetNull(mem2);
                  goto default;
                }
                else
                {
                  Sqlite3.sqlite3VdbeMemSetInt64(mem2, Sqlite3.sqlite3VdbeIntValue(pMem1) == 0L ? 1L : 0L);
                  goto default;
                }
              case 20:
                Sqlite3.Mem mem5 = memArray1[vdbeOp.p1];
                Sqlite3.memAboutToChange(p, mem5);
                Sqlite3.sqlite3VdbeMemIntegerify(mem5);
                mem5.u.i += (long) vdbeOp.p2;
                goto default;
              case 21:
                Sqlite3.Mem mem6 = memArray1[vdbeOp.p1];
                Sqlite3.applyAffinity(mem6, 'c', (int) num3);
                if (((int) mem6.flags & 4) == 0)
                {
                  if (vdbeOp.p2 == 0)
                  {
                    num1 = 20;
                    goto label_679;
                  }
                  else
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                }
                else
                {
                  Sqlite3.MemSetTypeFlag(mem6, 4);
                  goto default;
                }
              case 22:
                Sqlite3.Mem pMem2 = memArray1[vdbeOp.p1];
                if (((int) pMem2.flags & 4) != 0)
                {
                  Sqlite3.sqlite3VdbeMemRealify(pMem2);
                  goto default;
                }
                else
                  goto default;
              case 23:
                numArray1 = vdbeOp.p4.ai;
                goto default;
              case 24:
                int p3_2 = vdbeOp.p3;
                Sqlite3.KeyInfo pKeyInfo1 = vdbeOp.p4.pKeyInfo;
                int p1_2 = vdbeOp.p1;
                int p2_2 = vdbeOp.p2;
                for (int index4 = 0; index4 < p3_2; ++index4)
                {
                  int num8 = numArray1 != null ? numArray1[index4] : index4;
                  Sqlite3.REGISTER_TRACE(p, p1_2 + num8, memArray1[p1_2 + num8]);
                  Sqlite3.REGISTER_TRACE(p, p2_2 + num8, memArray1[p2_2 + num8]);
                  Sqlite3.CollSeq pColl = pKeyInfo1.aColl[index4];
                  int num9 = (int) pKeyInfo1.aSortOrder[index4];
                  num5 = Sqlite3.sqlite3MemCompare(memArray1[p1_2 + num8], memArray1[p2_2 + num8], pColl);
                  if (num5 != 0)
                  {
                    if (num9 != 0)
                    {
                      num5 = -num5;
                      break;
                    }
                    break;
                  }
                }
                numArray1 = (int[]) null;
                goto default;
              case 25:
                index1 = num5 >= 0 ? (num5 != 0 ? vdbeOp.p3 - 1 : vdbeOp.p2 - 1) : vdbeOp.p1 - 1;
                goto default;
              case 26:
              case 27:
                Sqlite3.Mem pMem3 = memArray1[vdbeOp.p1];
                int num10;
                if (((int) pMem3.flags & 1) != 0)
                {
                  num10 = vdbeOp.p3;
                }
                else
                {
                  num10 = Sqlite3.sqlite3VdbeRealValue(pMem3) != 0.0 ? 1 : 0;
                  if (vdbeOp.opcode == (byte) 27)
                    num10 = num10 == 0 ? 1 : 0;
                }
                if (num10 != 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 28:
                byte[] p1 = (byte[]) null;
                Sqlite3.Mem pMem4 = (Sqlite3.Mem) null;
                int p1_3 = vdbeOp.p1;
                int p2_3 = vdbeOp.p2;
                uint pSize1 = 0;
                long pSize2 = 0;
                uint v1 = 0;
                Sqlite3.Mem p2 = Sqlite3.sqlite3Malloc(pMem4);
                Sqlite3.Mem mem7 = memArray1[vdbeOp.p3];
                Sqlite3.memAboutToChange(p, mem7);
                Sqlite3.MemSetTypeFlag(mem7, 1);
                byte[] numArray2 = (byte[]) null;
                Sqlite3.VdbeCursor p3 = p.apCsr[p1_3];
                Sqlite3.BtCursor pCursor1 = p3.pCursor;
                if (pCursor1 != null)
                {
                  num1 = Sqlite3.sqlite3VdbeCursorMoveto(p3);
                  if (num1 == 0)
                  {
                    if (p3.nullRow)
                      pSize1 = 0U;
                    else if ((int) p3.cacheStatus == (int) p.cacheCtr && p3.aRow != -1)
                    {
                      pSize1 = p3.payloadSize;
                      numArray2 = Sqlite3.sqlite3Malloc((int) pSize1);
                      Buffer.BlockCopy((Array) pCursor1.info.pCell, p3.aRow, (Array) numArray2, 0, (int) pSize1);
                    }
                    else if (p3.isIndex)
                    {
                      num1 = Sqlite3.sqlite3BtreeKeySize(pCursor1, ref pSize2);
                      pSize1 = (uint) pSize2;
                    }
                    else
                      num1 = Sqlite3.sqlite3BtreeDataSize(pCursor1, ref pSize1);
                  }
                  else
                    goto label_679;
                }
                else if (p3.pseudoTableReg > 0)
                {
                  Sqlite3.Mem mem8 = memArray1[p3.pseudoTableReg];
                  pSize1 = (uint) mem8.n;
                  numArray2 = mem8.zBLOB;
                  p3.cacheStatus = ((int) vdbeOp.p5 & 32) != 0 ? 0U : p.cacheCtr;
                }
                else
                  pSize1 = 0U;
                if (pSize1 != 0U)
                {
                  if (pSize1 <= (uint) db1.aLimit[0])
                  {
                    int nField = p3.nField;
                    uint[] aType = p3.aType;
                    uint[] numArray3;
                    if ((int) p3.cacheStatus == (int) p.cacheCtr)
                    {
                      numArray3 = p3.aOffset;
                    }
                    else
                    {
                      int pAmt = 0;
                      numArray3 = new uint[nField];
                      p3.aOffset = numArray3;
                      p3.payloadSize = pSize1;
                      p3.cacheStatus = p.cacheCtr;
                      if (numArray2 != null)
                      {
                        p1 = numArray2;
                      }
                      else
                      {
                        p1 = !p3.isIndex ? Sqlite3.sqlite3BtreeDataFetch(pCursor1, ref pAmt, ref p3.aRow) : Sqlite3.sqlite3BtreeKeyFetch(pCursor1, ref pAmt, ref p3.aRow);
                        if (pSize1 <= (uint) pAmt)
                          numArray2 = p1;
                        else
                          p3.aRow = -1;
                      }
                      int varint32 = Sqlite3.getVarint32(p1, out v1);
                      if (v1 > 98307U)
                      {
                        num1 = Sqlite3.SQLITE_CORRUPT_BKPT();
                        goto label_246;
                      }
                      else
                      {
                        int amt = nField * 5 + 3;
                        if (amt > (int) v1)
                          amt = (int) v1;
                        if (numArray2 == null && pAmt < amt)
                        {
                          p2.db = (Sqlite3.sqlite3) null;
                          p2.flags = (ushort) 0;
                          num1 = Sqlite3.sqlite3VdbeMemFromBtree(pCursor1, 0, amt, p3.isIndex, p2);
                          if (num1 == 0)
                            p1 = p2.zBLOB;
                          else
                            goto label_246;
                        }
                        int num11 = amt;
                        int offset = varint32;
                        for (int index5 = 0; index5 < nField; ++index5)
                        {
                          if (offset < num11)
                          {
                            numArray3[index5] = v1;
                            offset += Sqlite3.getVarint32(p1, offset, out aType[index5]);
                            uint num12 = Sqlite3.sqlite3VdbeSerialTypeLen(aType[index5]);
                            v1 += num12;
                            if (v1 < num12)
                            {
                              offset = int.MaxValue;
                              break;
                            }
                          }
                          else
                            numArray3[index5] = 0U;
                        }
                        Sqlite3.sqlite3VdbeMemRelease(p2);
                        p2.flags = (ushort) 1;
                        if (offset > num11 || v1 > pSize1 || offset == num11 && (int) v1 != (int) pSize1)
                        {
                          num1 = Sqlite3.SQLITE_CORRUPT_BKPT();
                          goto label_246;
                        }
                      }
                    }
                    if (numArray3[p2_3] != 0U)
                    {
                      if (numArray2 != null)
                      {
                        Sqlite3.sqlite3VdbeMemReleaseExternal(mem7);
                        int num13 = (int) Sqlite3.sqlite3VdbeSerialGet(numArray2, (int) numArray3[p2_3], aType[p2_3], mem7);
                      }
                      else
                      {
                        int amt = (int) Sqlite3.sqlite3VdbeSerialTypeLen(aType[p2_3]);
                        Sqlite3.sqlite3VdbeMemMove(p2, mem7);
                        num1 = Sqlite3.sqlite3VdbeMemFromBtree(pCursor1, (int) numArray3[p2_3], amt, p3.isIndex, p2);
                        if (num1 == 0)
                        {
                          p1 = p2.zBLOB;
                          p2.zBLOB = (byte[]) null;
                          Sqlite3.sqlite3VdbeSerialGet(p1, aType[p2_3], mem7);
                        }
                        else
                          goto label_246;
                      }
                      mem7.enc = num3;
                    }
                    else if (vdbeOp.p4type == -8)
                      Sqlite3.sqlite3VdbeMemShallowCopy(mem7, vdbeOp.p4.pMem, 2048);
                    num1 = Sqlite3.sqlite3VdbeMemMakeWriteable(mem7);
                  }
                  else
                    break;
                }
label_246:
                Sqlite3.REGISTER_TRACE(p, vdbeOp.p3, mem7);
                if (p1 != null && p1 != numArray2)
                  Sqlite3.sqlite3_free(ref p1);
                Sqlite3.sqlite3_free(ref p2);
                goto default;
              case 29:
                string z1 = vdbeOp.p4.z;
                for (int index6 = 0; index6 < z1.Length; ++index6)
                {
                  char affinity = z1[index6];
                  Sqlite3.Mem mem9 = memArray1[vdbeOp.p1 + index6];
                  Sqlite3.ExpandBlob(mem9);
                  Sqlite3.applyAffinity(mem9, affinity, (int) num3);
                }
                goto default;
              case 30:
                ulong num14 = 0;
                int v2 = 0;
                int num15 = 0;
                int p1_4 = vdbeOp.p1;
                string str1 = vdbeOp.p4.z == null || vdbeOp.p4.z.Length == 0 ? "" : vdbeOp.p4.z;
                int p2_4 = vdbeOp.p2;
                int minWriteFileFormat = p.minWriteFileFormat;
                mem2 = memArray1[vdbeOp.p3];
                Sqlite3.memAboutToChange(p, mem2);
                for (int index7 = 0; index7 < p2_4; ++index7)
                {
                  Sqlite3.Mem mem10 = p.aMem[vdbeOp.p1 + index7];
                  if (index7 < str1.Length && str1[index7] != char.MinValue)
                    Sqlite3.applyAffinity(mem10, str1[index7], (int) num3);
                  if (((int) mem10.flags & 0) != 0 && mem10.n > 0)
                    Sqlite3.sqlite3VdbeMemExpandBlob(mem10);
                  uint num16 = Sqlite3.sqlite3VdbeSerialType(mem10, minWriteFileFormat);
                  int num17 = (int) Sqlite3.sqlite3VdbeSerialTypeLen(num16);
                  num14 += (ulong) num17;
                  v2 += Sqlite3.sqlite3VarintLen((ulong) num16);
                  if (((int) mem10.flags & 0) != 0)
                    num15 += mem10.u.nZero;
                  else if (num17 != 0)
                    num15 = 0;
                }
                int num18;
                int v3 = v2 + (num18 = Sqlite3.sqlite3VarintLen((ulong) v2));
                if (num18 < Sqlite3.sqlite3VarintLen((ulong) v3))
                  ++v3;
                long n1 = (long) v3 + (long) num14 - (long) num15;
                if (n1 <= (long) db1.aLimit[0])
                {
                  byte[] numArray4 = Sqlite3.sqlite3Malloc((int) n1);
                  int offset = Sqlite3.putVarint32(numArray4, v3);
                  for (int index8 = 0; index8 < p2_4; ++index8)
                  {
                    uint v4 = Sqlite3.sqlite3VdbeSerialType(p.aMem[vdbeOp.p1 + index8], minWriteFileFormat);
                    offset += Sqlite3.putVarint32(numArray4, offset, (int) v4);
                  }
                  for (int index9 = 0; index9 < p2_4; ++index9)
                  {
                    Sqlite3.Mem pMem5 = p.aMem[vdbeOp.p1 + index9];
                    offset += (int) Sqlite3.sqlite3VdbeSerialPut(numArray4, offset, (int) n1 - offset, pMem5, minWriteFileFormat);
                  }
                  mem2.zBLOB = numArray4;
                  mem2.z = (string) null;
                  mem2.n = (int) n1;
                  mem2.flags = (ushort) 1040;
                  mem2.xDel = (Sqlite3.dxDel) null;
                  if (num15 != 0)
                  {
                    mem2.u.nZero = num15;
                    mem2.flags |= (ushort) 0;
                  }
                  mem2.enc = (byte) 1;
                  Sqlite3.REGISTER_TRACE(p, vdbeOp.p3, mem2);
                  goto default;
                }
                else
                  break;
              case 31:
                long pnEntry = 0;
                Sqlite3.BtCursor pCursor2 = p.apCsr[vdbeOp.p1].pCursor;
                if (pCursor2 != null)
                  num1 = Sqlite3.sqlite3BtreeCount(pCursor2, ref pnEntry);
                else
                  pnEntry = 0L;
                mem2.u.i = pnEntry;
                goto default;
              case 32:
                int p1_5 = vdbeOp.p1;
                string z2 = vdbeOp.p4.z;
                if (p1_5 == 0)
                {
                  if (db1.writeVdbeCnt > 0)
                  {
                    Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "cannot open savepoint - ", "SQL statements in progress");
                    num1 = 5;
                    goto default;
                  }
                  else
                  {
                    Sqlite3.sqlite3Strlen30(z2);
                    Sqlite3.Savepoint savepoint = new Sqlite3.Savepoint();
                    if (savepoint != null)
                    {
                      savepoint.zName = z2;
                      if (db1.autoCommit != (byte) 0)
                      {
                        db1.autoCommit = (byte) 0;
                        db1.isTransactionSavepoint = (byte) 1;
                      }
                      else
                        ++db1.nSavepoint;
                      savepoint.pNext = db1.pSavepoint;
                      db1.pSavepoint = savepoint;
                      savepoint.nDeferredCons = db1.nDeferredCons;
                      goto default;
                    }
                    else
                      goto default;
                  }
                }
                else
                {
                  int num19 = 0;
                  Sqlite3.Savepoint pT;
                  for (pT = db1.pSavepoint; pT != null && !pT.zName.Equals(z2, StringComparison.InvariantCultureIgnoreCase); pT = pT.pNext)
                    ++num19;
                  if (pT == null)
                  {
                    Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "no such savepoint: %s", z2);
                    num1 = 1;
                    goto default;
                  }
                  else if (db1.writeVdbeCnt > 0 || p1_5 == 2 && db1.activeVdbeCnt > 1)
                  {
                    Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "cannot %s savepoint - SQL statements in progress", p1_5 == 2 ? "rollback" : "release");
                    num1 = 5;
                    goto default;
                  }
                  else
                  {
                    int num20 = pT.pNext != null || db1.isTransactionSavepoint == (byte) 0 ? 0 : 1;
                    if (num20 != 0 && p1_5 == 1)
                    {
                      if ((num7 = Sqlite3.sqlite3VdbeCheckFk(p, 1)) == 0)
                      {
                        db1.autoCommit = (byte) 1;
                        if (Sqlite3.sqlite3VdbeHalt(p) == 5)
                        {
                          p.pc = index1;
                          db1.autoCommit = (byte) 0;
                          p.rc = num7 = 5;
                          goto label_676;
                        }
                        else
                        {
                          db1.isTransactionSavepoint = (byte) 0;
                          num1 = p.rc;
                        }
                      }
                      else
                        goto label_676;
                    }
                    else
                    {
                      num19 = db1.nSavepoint - num19 - 1;
                      for (int index10 = 0; index10 < db1.nDb; ++index10)
                      {
                        num1 = Sqlite3.sqlite3BtreeSavepoint(db1.aDb[index10].pBt, p1_5, num19);
                        if (num1 != 0)
                          goto label_679;
                      }
                      if (p1_5 == 2 && (db1.flags & 512) != 0)
                      {
                        Sqlite3.sqlite3ExpirePreparedStatements(db1);
                        Sqlite3.sqlite3ResetInternalSchema(db1, -1);
                        db1.flags |= 512;
                      }
                    }
                    while (db1.pSavepoint != pT)
                    {
                      Sqlite3.Savepoint pSavepoint = db1.pSavepoint;
                      db1.pSavepoint = pSavepoint.pNext;
                      Sqlite3.sqlite3DbFree<Sqlite3.Savepoint>(db1, ref pSavepoint);
                      --db1.nSavepoint;
                    }
                    if (p1_5 == 1)
                    {
                      db1.pSavepoint = pT.pNext;
                      Sqlite3.sqlite3DbFree<Sqlite3.Savepoint>(db1, ref pT);
                      if (num20 == 0)
                        --db1.nSavepoint;
                    }
                    else
                      db1.nDeferredCons = pT.nDeferredCons;
                    if (num20 == 0)
                    {
                      num1 = Sqlite3.sqlite3VtabSavepoint(db1, p1_5, num19);
                      if (num1 == 0)
                        goto default;
                      else
                        goto label_679;
                    }
                    else
                      goto default;
                  }
                }
              case 33:
                int p1_6 = (int) (byte) vdbeOp.p1;
                int p2_5 = vdbeOp.p2;
                int num21 = p1_6 == 0 || db1.autoCommit != (byte) 0 ? 0 : 1;
                if (num21 != 0 && p2_5 != 0 && db1.activeVdbeCnt > 1)
                {
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "cannot rollback transaction - SQL statements in progress");
                  num1 = 5;
                  goto default;
                }
                else if (num21 != 0 && p2_5 == 0 && db1.writeVdbeCnt > 0)
                {
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "cannot commit transaction - SQL statements in progress");
                  num1 = 5;
                  goto default;
                }
                else if (p1_6 != (int) db1.autoCommit)
                {
                  if (p2_5 != 0)
                  {
                    Sqlite3.sqlite3RollbackAll(db1);
                    db1.autoCommit = (byte) 1;
                  }
                  else if ((num7 = Sqlite3.sqlite3VdbeCheckFk(p, 1)) == 0)
                  {
                    db1.autoCommit = (byte) p1_6;
                    if (Sqlite3.sqlite3VdbeHalt(p) == 5)
                    {
                      p.pc = index1;
                      db1.autoCommit = p1_6 == 0 ? (byte) 1 : (byte) 0;
                      p.rc = num7 = 5;
                      goto label_676;
                    }
                  }
                  else
                    goto label_676;
                  Sqlite3.sqlite3CloseSavepoints(db1);
                  num7 = p.rc != 0 ? 1 : 101;
                  goto label_676;
                }
                else
                {
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, p1_6 == 0 ? "cannot start a transaction within a transaction" : (p2_5 != 0 ? "cannot rollback - no transaction is active" : "cannot commit - no transaction is active"));
                  num1 = 1;
                  goto default;
                }
              case 34:
                Sqlite3.Btree pBt1 = db1.aDb[vdbeOp.p1].pBt;
                if (pBt1 != null)
                {
                  num1 = Sqlite3.sqlite3BtreeBeginTrans(pBt1, vdbeOp.p2);
                  if (num1 == 5)
                  {
                    p.pc = index1;
                    p.rc = num7 = 5;
                    goto label_676;
                  }
                  else if (num1 == 0)
                  {
                    if (vdbeOp.p2 != 0 && p.usesStmtJournal && (db1.autoCommit == (byte) 0 || db1.activeVdbeCnt > 1))
                    {
                      if (p.iStatement == 0)
                      {
                        ++db1.nStatement;
                        p.iStatement = db1.nSavepoint + db1.nStatement;
                      }
                      num1 = Sqlite3.sqlite3VtabSavepoint(db1, 0, p.iStatement - 1);
                      if (num1 == 0)
                        num1 = Sqlite3.sqlite3BtreeBeginStmt(pBt1, p.iStatement);
                      p.nStmtDefCons = db1.nDeferredCons;
                      goto default;
                    }
                    else
                      goto default;
                  }
                  else
                    goto label_679;
                }
                else
                  goto default;
              case 35:
                uint pMeta1 = 0;
                int p1_7 = vdbeOp.p1;
                int p3_3 = vdbeOp.p3;
                Sqlite3.sqlite3BtreeGetMeta(db1.aDb[p1_7].pBt, p3_3, ref pMeta1);
                mem2.u.i = (long) (int) pMeta1;
                goto default;
              case 36:
                Sqlite3.Db db2 = db1.aDb[vdbeOp.p1];
                Sqlite3.Mem pMem6 = memArray1[vdbeOp.p3];
                Sqlite3.sqlite3VdbeMemIntegerify(pMem6);
                num1 = Sqlite3.sqlite3BtreeUpdateMeta(db2.pBt, vdbeOp.p2, (uint) pMem6.u.i);
                if (vdbeOp.p2 == 1)
                {
                  db2.pSchema.schema_cookie = (int) pMem6.u.i;
                  db1.flags |= 512;
                }
                else if (vdbeOp.p2 == 2)
                  db2.pSchema.file_format = (byte) pMem6.u.i;
                if (vdbeOp.p1 == 1)
                {
                  Sqlite3.sqlite3ExpirePreparedStatements(db1);
                  p.expired = false;
                  goto default;
                }
                else
                  goto default;
              case 37:
                uint pMeta2 = 0;
                Sqlite3.Btree pBt2 = db1.aDb[vdbeOp.p1].pBt;
                uint num22;
                if (pBt2 != null)
                {
                  Sqlite3.sqlite3BtreeGetMeta(pBt2, 1, ref pMeta2);
                  num22 = db1.aDb[vdbeOp.p1].pSchema.iGeneration;
                }
                else
                  num22 = pMeta2 = 0U;
                if ((long) pMeta2 != (long) vdbeOp.p2 || (long) num22 != (long) vdbeOp.p3)
                {
                  Sqlite3.sqlite3DbFree(db1, ref p.zErrMsg);
                  p.zErrMsg = "database schema has changed";
                  if ((long) db1.aDb[vdbeOp.p1].pSchema.schema_cookie != (long) pMeta2)
                    Sqlite3.sqlite3ResetInternalSchema(db1, vdbeOp.p1);
                  p.expired = true;
                  num1 = 17;
                  goto default;
                }
                else
                  goto default;
              case 38:
              case 39:
                if (p.expired)
                {
                  num1 = 4;
                  goto default;
                }
                else
                {
                  int nField = 0;
                  Sqlite3.KeyInfo pKeyInfo2 = (Sqlite3.KeyInfo) null;
                  int iTable = vdbeOp.p2;
                  int p3_4 = vdbeOp.p3;
                  Sqlite3.Db db3 = db1.aDb[p3_4];
                  Sqlite3.Btree pBt3 = db3.pBt;
                  int wrFlag;
                  if (vdbeOp.opcode == (byte) 39)
                  {
                    wrFlag = 1;
                    if ((int) db3.pSchema.file_format < p.minWriteFileFormat)
                      p.minWriteFileFormat = (int) db3.pSchema.file_format;
                  }
                  else
                    wrFlag = 0;
                  if (vdbeOp.p5 != (byte) 0)
                  {
                    Sqlite3.Mem pMem7 = memArray1[iTable];
                    Sqlite3.sqlite3VdbeMemIntegerify(pMem7);
                    iTable = (int) pMem7.u.i;
                    if (Sqlite3.NEVER(iTable < 2))
                    {
                      num1 = Sqlite3.SQLITE_CORRUPT_BKPT();
                      goto label_679;
                    }
                  }
                  if (vdbeOp.p4type == -6)
                  {
                    pKeyInfo2 = vdbeOp.p4.pKeyInfo;
                    pKeyInfo2.enc = Sqlite3.ENC(p.db);
                    nField = (int) pKeyInfo2.nField + 1;
                  }
                  else if (vdbeOp.p4type == -14)
                    nField = vdbeOp.p4.i;
                  Sqlite3.VdbeCursor vdbeCursor = Sqlite3.allocateCursor(p, vdbeOp.p1, nField, p3_4, 1);
                  if (vdbeCursor != null)
                  {
                    vdbeCursor.nullRow = true;
                    vdbeCursor.isOrdered = true;
                    num1 = Sqlite3.sqlite3BtreeCursor(pBt3, iTable, wrFlag, pKeyInfo2, vdbeCursor.pCursor);
                    vdbeCursor.pKeyInfo = pKeyInfo2;
                    if (num1 == 16)
                    {
                      Sqlite3.sqlite3MemFreeBtCursor(ref vdbeCursor.pCursor);
                      num1 = 0;
                    }
                    vdbeCursor.isTable = vdbeOp.p4type != -6;
                    vdbeCursor.isIndex = !vdbeCursor.isTable;
                    goto default;
                  }
                  else
                    goto label_678;
                }
              case 40:
              case 41:
                Sqlite3.VdbeCursor vdbeCursor1 = Sqlite3.allocateCursor(p, vdbeOp.p1, vdbeOp.p2, -1, 1);
                if (vdbeCursor1 != null)
                {
                  vdbeCursor1.nullRow = true;
                  num1 = Sqlite3.sqlite3BtreeOpen(db1.pVfs, (string) null, db1, ref vdbeCursor1.pBt, 9 | (int) vdbeOp.p5, 1054);
                  if (num1 == 0)
                    num1 = Sqlite3.sqlite3BtreeBeginTrans(vdbeCursor1.pBt, 1);
                  if (num1 == 0)
                  {
                    if (vdbeOp.p4.pKeyInfo != null)
                    {
                      int piTable = 0;
                      num1 = Sqlite3.sqlite3BtreeCreateTable(vdbeCursor1.pBt, ref piTable, 2);
                      if (num1 == 0)
                      {
                        num1 = Sqlite3.sqlite3BtreeCursor(vdbeCursor1.pBt, piTable, 1, vdbeOp.p4.pKeyInfo, vdbeCursor1.pCursor);
                        vdbeCursor1.pKeyInfo = vdbeOp.p4.pKeyInfo;
                        vdbeCursor1.pKeyInfo.enc = Sqlite3.ENC(p.db);
                      }
                      vdbeCursor1.isTable = false;
                    }
                    else
                    {
                      num1 = Sqlite3.sqlite3BtreeCursor(vdbeCursor1.pBt, 1, 1, (Sqlite3.KeyInfo) null, vdbeCursor1.pCursor);
                      vdbeCursor1.isTable = true;
                    }
                  }
                  vdbeCursor1.isOrdered = vdbeOp.p5 != (byte) 16;
                  vdbeCursor1.isIndex = !vdbeCursor1.isTable;
                  goto default;
                }
                else
                  goto label_678;
              case 42:
                Sqlite3.VdbeCursor vdbeCursor2 = Sqlite3.allocateCursor(p, vdbeOp.p1, vdbeOp.p3, -1, 0);
                if (vdbeCursor2 != null)
                {
                  vdbeCursor2.nullRow = true;
                  vdbeCursor2.pseudoTableReg = vdbeOp.p2;
                  vdbeCursor2.isTable = true;
                  vdbeCursor2.isIndex = false;
                  goto default;
                }
                else
                  goto label_678;
              case 43:
                Sqlite3.sqlite3VdbeFreeCursor(p, p.apCsr[vdbeOp.p1]);
                p.apCsr[vdbeOp.p1] = (Sqlite3.VdbeCursor) null;
                goto default;
              case 44:
              case 45:
              case 46:
              case 47:
                int pRes1 = 0;
                Sqlite3.UnpackedRecord pIdxKey1 = new Sqlite3.UnpackedRecord();
                Sqlite3.VdbeCursor vdbeCursor3 = p.apCsr[vdbeOp.p1];
                if (vdbeCursor3.pCursor != null)
                {
                  int opcode = (int) vdbeOp.opcode;
                  vdbeCursor3.nullRow = false;
                  if (vdbeCursor3.isTable)
                  {
                    Sqlite3.Mem mem11 = memArray1[vdbeOp.p3];
                    Sqlite3.applyNumericAffinity(mem11);
                    long intKey = Sqlite3.sqlite3VdbeIntValue(mem11);
                    vdbeCursor3.rowidIsValid = false;
                    if (((int) mem11.flags & 4) == 0)
                    {
                      if (((int) mem11.flags & 8) == 0)
                      {
                        index1 = vdbeOp.p2 - 1;
                        goto default;
                      }
                      else if (intKey == long.MinValue && (mem11.r < (double) intKey || mem11.r > 0.0))
                      {
                        int pRes2 = 1;
                        if (mem11.r < 0.0)
                        {
                          if (opcode >= 46)
                          {
                            num1 = Sqlite3.sqlite3BtreeFirst(vdbeCursor3.pCursor, ref pRes2);
                            if (num1 != 0)
                              goto label_679;
                          }
                        }
                        else if (opcode <= 45)
                        {
                          num1 = Sqlite3.sqlite3BtreeLast(vdbeCursor3.pCursor, ref pRes2);
                          if (num1 != 0)
                            goto label_679;
                        }
                        if (pRes2 != 0)
                        {
                          index1 = vdbeOp.p2 - 1;
                          goto default;
                        }
                        else
                          goto default;
                      }
                      else if (opcode == 44 || opcode == 46)
                      {
                        if (mem11.r > (double) intKey)
                          ++intKey;
                      }
                      else if (mem11.r < (double) intKey)
                        --intKey;
                    }
                    num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(vdbeCursor3.pCursor, (Sqlite3.UnpackedRecord) null, intKey, 0, ref pRes1);
                    if (num1 == 0)
                    {
                      if (pRes1 == 0)
                      {
                        vdbeCursor3.rowidIsValid = true;
                        vdbeCursor3.lastRowid = intKey;
                      }
                    }
                    else
                      goto label_679;
                  }
                  else
                  {
                    int i2 = vdbeOp.p4.i;
                    pIdxKey1.pKeyInfo = vdbeCursor3.pKeyInfo;
                    pIdxKey1.nField = (ushort) i2;
                    pIdxKey1.flags = (ushort) (8 * (1 & opcode - 44));
                    pIdxKey1.aMem = new Sqlite3.Mem[(int) pIdxKey1.nField];
                    for (int index11 = 0; index11 < (int) pIdxKey1.nField; ++index11)
                      pIdxKey1.aMem[index11] = memArray1[vdbeOp.p3 + index11];
                    Sqlite3.ExpandBlob(pIdxKey1.aMem[0]);
                    num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(vdbeCursor3.pCursor, pIdxKey1, 0L, 0, ref pRes1);
                    if (num1 == 0)
                      vdbeCursor3.rowidIsValid = false;
                    else
                      goto label_679;
                  }
                  vdbeCursor3.deferredMoveto = false;
                  vdbeCursor3.cacheStatus = 0U;
                  if (opcode >= 46)
                  {
                    if (pRes1 < 0 || pRes1 == 0 && opcode == 47)
                    {
                      num1 = Sqlite3.sqlite3BtreeNext(vdbeCursor3.pCursor, ref pRes1);
                      if (num1 == 0)
                        vdbeCursor3.rowidIsValid = false;
                      else
                        goto label_679;
                    }
                    else
                      pRes1 = 0;
                  }
                  else if (pRes1 > 0 || pRes1 == 0 && opcode == 44)
                  {
                    num1 = Sqlite3.sqlite3BtreePrevious(vdbeCursor3.pCursor, ref pRes1);
                    if (num1 == 0)
                      vdbeCursor3.rowidIsValid = false;
                    else
                      goto label_679;
                  }
                  else
                    pRes1 = Sqlite3.sqlite3BtreeEof(vdbeCursor3.pCursor) ? 1 : 0;
                  if (pRes1 != 0)
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                    goto default;
                }
                else
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
              case 48:
                Sqlite3.VdbeCursor vdbeCursor4 = p.apCsr[vdbeOp.p1];
                if (vdbeCursor4.pCursor != null)
                {
                  vdbeCursor4.nullRow = false;
                  Sqlite3.Mem pMem8 = memArray1[vdbeOp.p2];
                  vdbeCursor4.movetoTarget = Sqlite3.sqlite3VdbeIntValue(pMem8);
                  vdbeCursor4.rowidIsValid = false;
                  vdbeCursor4.deferredMoveto = true;
                  goto default;
                }
                else
                  goto default;
              case 49:
              case 50:
                int pRes3 = 0;
                Sqlite3.UnpackedRecord unpackedRecord1 = new Sqlite3.UnpackedRecord();
                Sqlite3.UnpackedRecord pSpace = new Sqlite3.UnpackedRecord();
                int num23 = 0;
                Sqlite3.VdbeCursor vdbeCursor5 = p.apCsr[vdbeOp.p1];
                Sqlite3.Mem mem12 = memArray1[vdbeOp.p3];
                if (Sqlite3.ALWAYS(vdbeCursor5.pCursor != null))
                {
                  Sqlite3.UnpackedRecord unpackedRecord2;
                  if (vdbeOp.p4.i > 0)
                  {
                    unpackedRecord1.pKeyInfo = vdbeCursor5.pKeyInfo;
                    unpackedRecord1.nField = (ushort) vdbeOp.p4.i;
                    unpackedRecord1.aMem = new Sqlite3.Mem[(int) unpackedRecord1.nField];
                    for (int index12 = 0; index12 < unpackedRecord1.aMem.Length; ++index12)
                      unpackedRecord1.aMem[index12] = memArray1[vdbeOp.p3 + index12];
                    unpackedRecord1.flags = (ushort) 16;
                    unpackedRecord2 = unpackedRecord1;
                  }
                  else
                  {
                    unpackedRecord2 = Sqlite3.sqlite3VdbeRecordUnpack(vdbeCursor5.pKeyInfo, mem12.n, mem12.zBLOB, pSpace, 0);
                    if (unpackedRecord2 != null)
                      unpackedRecord2.flags |= (ushort) 16;
                    else
                      goto label_678;
                  }
                  num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(vdbeCursor5.pCursor, unpackedRecord2, 0L, 0, ref pRes3);
                  if (vdbeOp.p4.i == 0)
                    Sqlite3.sqlite3VdbeDeleteUnpackedRecord(unpackedRecord2);
                  if (num1 == 0)
                  {
                    num23 = pRes3 == 0 ? 1 : 0;
                    vdbeCursor5.deferredMoveto = false;
                    vdbeCursor5.cacheStatus = 0U;
                  }
                  else
                    goto default;
                }
                if (vdbeOp.opcode == (byte) 50)
                {
                  if (num23 != 0)
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                    goto default;
                }
                else if (num23 == 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 51:
                Sqlite3.VdbeCursor vdbeCursor6 = new Sqlite3.VdbeCursor();
                Sqlite3.UnpackedRecord pIdxKey2 = new Sqlite3.UnpackedRecord();
                Sqlite3.Mem pMem9 = memArray1[vdbeOp.p3];
                Sqlite3.VdbeCursor vdbeCursor7 = p.apCsr[vdbeOp.p1];
                vdbeCursor7.seekResult = 0;
                vdbeCursor7.cacheStatus = 0U;
                Sqlite3.BtCursor pCur = vdbeCursor7.pCursor;
                ushort nField1 = vdbeCursor7.pKeyInfo.nField;
                Sqlite3.Mem[] memArray2 = new Sqlite3.Mem[(int) nField1 + 1];
                for (ushort index13 = 0; (int) index13 < (int) nField1; ++index13)
                {
                  memArray2[(int) index13] = memArray1[vdbeOp.p4.i + (int) index13];
                  if (((int) memArray2[(int) index13].flags & 1) != 0)
                  {
                    index1 = vdbeOp.p2 - 1;
                    pCur = (Sqlite3.BtCursor) null;
                    break;
                  }
                }
                memArray2[(int) nField1] = new Sqlite3.Mem();
                if (pCur != null)
                {
                  pIdxKey2.pKeyInfo = vdbeCursor7.pKeyInfo;
                  pIdxKey2.nField = (ushort) ((uint) nField1 + 1U);
                  pIdxKey2.flags = (ushort) 32;
                  pIdxKey2.aMem = memArray2;
                  Sqlite3.sqlite3VdbeMemIntegerify(pMem9);
                  long i3 = pMem9.u.i;
                  num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(pCur, pIdxKey2, 0L, 0, ref vdbeCursor7.seekResult);
                  if (((int) pIdxKey2.flags & 32) != 0 || pIdxKey2.rowid == i3)
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                  {
                    pMem9.u.i = pIdxKey2.rowid;
                    goto default;
                  }
                }
                else
                  goto default;
              case 52:
                Sqlite3.Mem mem13 = memArray1[vdbeOp.p3];
                Sqlite3.VdbeCursor vdbeCursor8 = p.apCsr[vdbeOp.p1];
                Sqlite3.BtCursor pCursor3 = vdbeCursor8.pCursor;
                if (pCursor3 != null)
                {
                  int pRes4 = 0;
                  long i4 = mem13.u.i;
                  num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(pCursor3, (Sqlite3.UnpackedRecord) null, i4, 0, ref pRes4);
                  vdbeCursor8.lastRowid = mem13.u.i;
                  vdbeCursor8.rowidIsValid = pRes4 == 0;
                  vdbeCursor8.nullRow = false;
                  vdbeCursor8.cacheStatus = 0U;
                  vdbeCursor8.deferredMoveto = false;
                  if (pRes4 != 0)
                    index1 = vdbeOp.p2 - 1;
                  vdbeCursor8.seekResult = pRes4;
                  goto default;
                }
                else
                {
                  index1 = vdbeOp.p2 - 1;
                  vdbeCursor8.seekResult = 0;
                  goto default;
                }
              case 53:
                mem2.u.i = p.apCsr[vdbeOp.p1].seqCount++;
                goto default;
              case 54:
                long intKey1 = 0;
                int pRes5 = 0;
                Sqlite3.VdbeCursor vdbeCursor9 = p.apCsr[vdbeOp.p1];
                if (!Sqlite3.NEVER(vdbeCursor9.pCursor == null))
                {
                  if (!vdbeCursor9.useRandomRowid)
                  {
                    intKey1 = Sqlite3.sqlite3BtreeGetCachedRowid(vdbeCursor9.pCursor);
                    if (intKey1 == 0L)
                    {
                      num1 = Sqlite3.sqlite3BtreeLast(vdbeCursor9.pCursor, ref pRes5);
                      if (num1 == 0)
                      {
                        if (pRes5 != 0)
                        {
                          intKey1 = 1L;
                        }
                        else
                        {
                          num1 = Sqlite3.sqlite3BtreeKeySize(vdbeCursor9.pCursor, ref intKey1);
                          if (intKey1 == long.MaxValue)
                            vdbeCursor9.useRandomRowid = true;
                          else
                            ++intKey1;
                        }
                      }
                      else
                        goto label_679;
                    }
                    if (vdbeOp.p3 != 0)
                    {
                      Sqlite3.Mem mem14;
                      if (p.pFrame != null)
                      {
                        Sqlite3.VdbeFrame vdbeFrame = p.pFrame;
                        while (vdbeFrame.pParent != null)
                          vdbeFrame = vdbeFrame.pParent;
                        mem14 = vdbeFrame.aMem[vdbeOp.p3];
                      }
                      else
                      {
                        mem14 = memArray1[vdbeOp.p3];
                        Sqlite3.memAboutToChange(p, mem14);
                      }
                      Sqlite3.REGISTER_TRACE(p, vdbeOp.p3, mem14);
                      Sqlite3.sqlite3VdbeMemIntegerify(mem14);
                      if (mem14.u.i == long.MaxValue || vdbeCursor9.useRandomRowid)
                      {
                        num1 = 13;
                        goto label_679;
                      }
                      else
                      {
                        if (intKey1 < mem14.u.i + 1L)
                          intKey1 = (long) (int) (mem14.u.i + 1L);
                        mem14.u.i = intKey1;
                      }
                    }
                    Sqlite3.sqlite3BtreeSetCachedRowid(vdbeCursor9.pCursor, intKey1 < long.MaxValue ? intKey1 + 1L : 0L);
                  }
                  if (vdbeCursor9.useRandomRowid)
                  {
                    intKey1 = num6;
                    intKey1 &= 4611686018427387903L;
                    ++intKey1;
                    for (int index14 = 0; (num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(vdbeCursor9.pCursor, (Sqlite3.UnpackedRecord) null, intKey1, 0, ref pRes5)) == 0 && pRes5 == 0 && ++index14 < 100; ++intKey1)
                    {
                      Sqlite3.sqlite3_randomness(8, ref intKey1);
                      if (index14 < 5)
                        intKey1 &= 16777215L;
                      else
                        intKey1 &= 4611686018427387903L;
                    }
                    if (num1 == 0 && pRes5 == 0)
                    {
                      num1 = 13;
                      goto label_679;
                    }
                  }
                  vdbeCursor9.rowidIsValid = false;
                  vdbeCursor9.deferredMoveto = false;
                  vdbeCursor9.cacheStatus = 0U;
                }
                mem2.u.i = intKey1;
                goto default;
              case 55:
              case 56:
                Sqlite3.Mem M3 = memArray1[vdbeOp.p2];
                Sqlite3.VdbeCursor vdbeCursor10 = p.apCsr[vdbeOp.p1];
                Sqlite3.REGISTER_TRACE(p, vdbeOp.p2, M3);
                long num24;
                if (vdbeOp.opcode == (byte) 55)
                {
                  Sqlite3.Mem M4 = memArray1[vdbeOp.p3];
                  Sqlite3.REGISTER_TRACE(p, vdbeOp.p3, M4);
                  num24 = M4.u.i;
                }
                else
                  num24 = (long) vdbeOp.p3;
                if (((int) vdbeOp.p5 & 1) != 0)
                  ++p.nChange;
                if (((int) vdbeOp.p5 & 2) != 0)
                  db1.lastRowid = num6 = num24;
                if (((int) M3.flags & 1) != 0)
                {
                  Sqlite3.sqlite3_free(ref M3.zBLOB);
                  M3.z = (string) null;
                  M3.n = 0;
                }
                int seekResult = ((int) vdbeOp.p5 & 16) != 0 ? vdbeCursor10.seekResult : 0;
                int nZero = ((int) M3.flags & 0) == 0 ? 0 : M3.u.nZero;
                num1 = Sqlite3.sqlite3BtreeInsert(vdbeCursor10.pCursor, (byte[]) null, num24, M3.zBLOB, M3.n, nZero, ((int) vdbeOp.p5 & 8) != 0 ? 1 : 0, seekResult);
                vdbeCursor10.rowidIsValid = false;
                vdbeCursor10.deferredMoveto = false;
                vdbeCursor10.cacheStatus = 0U;
                if (num1 == 0 && db1.xUpdateCallback != null && vdbeOp.p4.z != null)
                {
                  string zName = db1.aDb[vdbeCursor10.iDb].zName;
                  string z3 = vdbeOp.p4.z;
                  int b = ((int) vdbeOp.p5 & 4) != 0 ? 23 : 18;
                  db1.xUpdateCallback(db1.pUpdateArg, b, zName, z3, num24);
                  goto default;
                }
                else
                  goto default;
              case 57:
                long e = 0;
                Sqlite3.VdbeCursor p4 = p.apCsr[vdbeOp.p1];
                if (db1.xUpdateCallback != null && vdbeOp.p4.z != null)
                  e = p4.lastRowid;
                num1 = Sqlite3.sqlite3VdbeCursorMoveto(p4);
                if (!Sqlite3.NEVER(num1 != 0))
                {
                  Sqlite3.sqlite3BtreeSetCachedRowid(p4.pCursor, 0L);
                  num1 = Sqlite3.sqlite3BtreeDelete(p4.pCursor);
                  p4.cacheStatus = 0U;
                  if (num1 == 0 && db1.xUpdateCallback != null && vdbeOp.p4.z != null)
                  {
                    string zName = db1.aDb[p4.iDb].zName;
                    string z4 = vdbeOp.p4.z;
                    db1.xUpdateCallback(db1.pUpdateArg, 9, zName, z4, e);
                  }
                  if ((vdbeOp.p2 & 1) != 0)
                  {
                    ++p.nChange;
                    goto default;
                  }
                  else
                    goto default;
                }
                else
                  goto label_679;
              case 58:
                Sqlite3.sqlite3VdbeSetChanges(db1, p.nChange);
                p.nChange = 0;
                goto default;
              case 59:
              case 60:
                uint pSize3 = 0;
                long pSize4 = 0;
                mem2 = memArray1[vdbeOp.p2];
                Sqlite3.memAboutToChange(p, mem2);
                Sqlite3.VdbeCursor p5 = p.apCsr[vdbeOp.p1];
                Sqlite3.BtCursor pCursor4 = p5.pCursor;
                num1 = Sqlite3.sqlite3VdbeCursorMoveto(p5);
                if (!Sqlite3.NEVER(num1 != 0))
                {
                  int num25;
                  if (p5.isIndex)
                  {
                    num25 = Sqlite3.sqlite3BtreeKeySize(pCursor4, ref pSize4);
                    if (pSize4 <= (long) db1.aLimit[0])
                      pSize3 = (uint) pSize4;
                    else
                      break;
                  }
                  else
                  {
                    num25 = Sqlite3.sqlite3BtreeDataSize(pCursor4, ref pSize3);
                    if (pSize3 <= (uint) db1.aLimit[0])
                    {
                      if (Sqlite3.sqlite3VdbeMemGrow(mem2, (int) pSize3, 0) != 0)
                        goto label_678;
                    }
                    else
                      break;
                  }
                  mem2.n = (int) pSize3;
                  if (p5.isIndex)
                  {
                    mem2.zBLOB = Sqlite3.sqlite3Malloc((int) pSize3);
                    num1 = Sqlite3.sqlite3BtreeKey(pCursor4, 0U, pSize3, mem2.zBLOB);
                  }
                  else
                  {
                    mem2.zBLOB = Sqlite3.sqlite3Malloc((int) pCursor4.info.nData);
                    num1 = Sqlite3.sqlite3BtreeData(pCursor4, 0U, pSize3, mem2.zBLOB);
                  }
                  Sqlite3.MemSetTypeFlag(mem2, 16);
                  mem2.enc = (byte) 1;
                  goto default;
                }
                else
                  goto label_679;
              case 61:
                long pSize5 = 0;
                Sqlite3.VdbeCursor p6 = p.apCsr[vdbeOp.p1];
                if (p6.nullRow)
                {
                  mem2.flags = (ushort) 1;
                  goto default;
                }
                else
                {
                  if (p6.deferredMoveto)
                  {
                    pSize5 = p6.movetoTarget;
                  }
                  else
                  {
                    num1 = Sqlite3.sqlite3VdbeCursorMoveto(p6);
                    if (num1 == 0)
                    {
                      if (p6.rowidIsValid)
                        pSize5 = p6.lastRowid;
                      else
                        num1 = Sqlite3.sqlite3BtreeKeySize(p6.pCursor, ref pSize5);
                    }
                    else
                      goto label_679;
                  }
                  mem2.u.i = pSize5;
                  goto default;
                }
              case 62:
                Sqlite3.VdbeCursor vdbeCursor11 = p.apCsr[vdbeOp.p1];
                vdbeCursor11.nullRow = true;
                vdbeCursor11.rowidIsValid = false;
                if (vdbeCursor11.pCursor != null)
                {
                  Sqlite3.sqlite3BtreeClearCursor(vdbeCursor11.pCursor);
                  goto default;
                }
                else
                  goto default;
              case 63:
                int pRes6 = 0;
                Sqlite3.VdbeCursor vdbeCursor12 = p.apCsr[vdbeOp.p1];
                Sqlite3.BtCursor pCursor5 = vdbeCursor12.pCursor;
                if (pCursor5 == null)
                  pRes6 = 1;
                else
                  num1 = Sqlite3.sqlite3BtreeLast(pCursor5, ref pRes6);
                vdbeCursor12.nullRow = pRes6 == 1;
                vdbeCursor12.deferredMoveto = false;
                vdbeCursor12.rowidIsValid = false;
                vdbeCursor12.cacheStatus = 0U;
                if (vdbeOp.p2 > 0 && pRes6 != 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 64:
                ++p.aCounter[1];
                goto case 65;
              case 65:
                int pRes7 = 0;
                Sqlite3.VdbeCursor vdbeCursor13 = p.apCsr[vdbeOp.p1];
                pRes7 = 1;
                Sqlite3.BtCursor pCursor6;
                if ((pCursor6 = vdbeCursor13.pCursor) != null)
                {
                  num1 = Sqlite3.sqlite3BtreeFirst(pCursor6, ref pRes7);
                  vdbeCursor13.atFirst = pRes7 == 0;
                  vdbeCursor13.deferredMoveto = false;
                  vdbeCursor13.cacheStatus = 0U;
                  vdbeCursor13.rowidIsValid = false;
                }
                vdbeCursor13.nullRow = pRes7 == 1;
                if (pRes7 != 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 66:
              case 67:
                if (!db1.u1.isInterrupted)
                {
                  Sqlite3.VdbeCursor vdbeCursor14 = p.apCsr[vdbeOp.p1];
                  if (vdbeCursor14 != null)
                  {
                    Sqlite3.BtCursor pCursor7 = vdbeCursor14.pCursor;
                    if (pCursor7 == null)
                    {
                      vdbeCursor14.nullRow = true;
                      goto default;
                    }
                    else
                    {
                      int pRes8 = 1;
                      num1 = vdbeOp.opcode == (byte) 67 ? Sqlite3.sqlite3BtreeNext(pCursor7, ref pRes8) : Sqlite3.sqlite3BtreePrevious(pCursor7, ref pRes8);
                      vdbeCursor14.nullRow = pRes8 == 1;
                      vdbeCursor14.cacheStatus = 0U;
                      if (pRes8 == 0)
                      {
                        index1 = vdbeOp.p2 - 1;
                        if (vdbeOp.p5 != (byte) 0)
                          ++p.aCounter[(int) vdbeOp.p5 - 1];
                      }
                      vdbeCursor14.rowidIsValid = false;
                      goto default;
                    }
                  }
                  else
                    goto default;
                }
                else
                  goto label_681;
              case 68:
              case 69:
                Sqlite3.Mem pMem10 = memArray1[vdbeOp.p1];
                int num26 = ((int) pMem10.flags & 1) == 0 ? (Sqlite3.sqlite3VdbeIntValue(pMem10) != 0L ? 1 : 0) : 2;
                Sqlite3.Mem pMem11 = memArray1[vdbeOp.p2];
                int num27 = ((int) pMem11.flags & 1) == 0 ? (Sqlite3.sqlite3VdbeIntValue(pMem11) != 0L ? 1 : 0) : 2;
                int num28;
                if (vdbeOp.opcode == (byte) 69)
                  num28 = (int) new byte[9]
                  {
                    (byte) 0,
                    (byte) 0,
                    (byte) 0,
                    (byte) 0,
                    (byte) 1,
                    (byte) 2,
                    (byte) 0,
                    (byte) 2,
                    (byte) 2
                  }[num26 * 3 + num27];
                else
                  num28 = (int) new byte[9]
                  {
                    (byte) 0,
                    (byte) 1,
                    (byte) 2,
                    (byte) 1,
                    (byte) 1,
                    (byte) 1,
                    (byte) 2,
                    (byte) 1,
                    (byte) 2
                  }[num26 * 3 + num27];
                mem2 = memArray1[vdbeOp.p3];
                if (num28 == 2)
                {
                  Sqlite3.MemSetTypeFlag(mem2, 1);
                  goto default;
                }
                else
                {
                  mem2.u.i = (long) num28;
                  Sqlite3.MemSetTypeFlag(mem2, 4);
                  goto default;
                }
              case 70:
                Sqlite3.VdbeCursor vdbeCursor15 = p.apCsr[vdbeOp.p1];
                Sqlite3.Mem P = memArray1[vdbeOp.p2];
                Sqlite3.BtCursor pCursor8 = vdbeCursor15.pCursor;
                if (Sqlite3.ALWAYS(pCursor8 != null))
                {
                  Sqlite3.ExpandBlob(P);
                  if (num1 == 0)
                  {
                    int n2 = P.n;
                    byte[] pKey = ((int) P.flags & 16) != 0 ? P.zBLOB : Encoding.UTF8.GetBytes(P.z);
                    num1 = Sqlite3.sqlite3BtreeInsert(pCursor8, pKey, (long) n2, (byte[]) null, 0, 0, vdbeOp.p3 != 0 ? 1 : 0, ((int) vdbeOp.p5 & 16) != 0 ? vdbeCursor15.seekResult : 0);
                    vdbeCursor15.cacheStatus = 0U;
                    goto default;
                  }
                  else
                    goto default;
                }
                else
                  goto default;
              case 71:
                int pRes9 = 0;
                Sqlite3.UnpackedRecord pIdxKey3 = new Sqlite3.UnpackedRecord();
                Sqlite3.VdbeCursor vdbeCursor16 = p.apCsr[vdbeOp.p1];
                Sqlite3.BtCursor pCursor9 = vdbeCursor16.pCursor;
                if (Sqlite3.ALWAYS(pCursor9 != null))
                {
                  pIdxKey3.pKeyInfo = vdbeCursor16.pKeyInfo;
                  pIdxKey3.nField = (ushort) vdbeOp.p3;
                  pIdxKey3.flags = (ushort) 0;
                  pIdxKey3.aMem = new Sqlite3.Mem[(int) pIdxKey3.nField];
                  for (int index15 = 0; index15 < (int) pIdxKey3.nField; ++index15)
                    pIdxKey3.aMem[index15] = memArray1[vdbeOp.p2 + index15];
                  num1 = Sqlite3.sqlite3BtreeMovetoUnpacked(pCursor9, pIdxKey3, 0L, 0, ref pRes9);
                  if (num1 == 0 && pRes9 == 0)
                    num1 = Sqlite3.sqlite3BtreeDelete(pCursor9);
                  vdbeCursor16.cacheStatus = 0U;
                  goto default;
                }
                else
                  goto default;
              case 72:
                long rowid = 0;
                Sqlite3.VdbeCursor p7 = p.apCsr[vdbeOp.p1];
                Sqlite3.BtCursor pCursor10 = p7.pCursor;
                mem2.flags = (ushort) 1;
                if (Sqlite3.ALWAYS(pCursor10 != null))
                {
                  num1 = Sqlite3.sqlite3VdbeCursorMoveto(p7);
                  if (!Sqlite3.NEVER(num1 != 0))
                  {
                    if (!p7.nullRow)
                    {
                      num1 = Sqlite3.sqlite3VdbeIdxRowid(db1, pCursor10, ref rowid);
                      if (num1 == 0)
                      {
                        mem2.u.i = rowid;
                        mem2.flags = (ushort) 4;
                        goto default;
                      }
                      else
                        goto label_679;
                    }
                    else
                      goto default;
                  }
                  else
                    goto label_679;
                }
                else
                  goto default;
              case 73:
                if (((int) memArray1[vdbeOp.p1].flags & 1) != 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 74:
                if (((int) memArray1[vdbeOp.p1].flags & 1) == 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 75:
              case 76:
              case 77:
              case 78:
              case 79:
              case 80:
                Sqlite3.Mem mem15 = memArray1[vdbeOp.p1];
                Sqlite3.Mem mem16 = memArray1[vdbeOp.p3];
                ushort flags1 = mem15.flags;
                ushort flags2 = mem16.flags;
                int num29;
                if ((((int) mem15.flags | (int) mem16.flags) & 1) != 0)
                {
                  if (((int) vdbeOp.p5 & 128) != 0)
                    num29 = ((int) mem15.flags & (int) mem16.flags & 1) == 0 ? 1 : 0;
                  else if (((int) vdbeOp.p5 & 16) != 0)
                  {
                    mem2 = memArray1[vdbeOp.p2];
                    Sqlite3.MemSetTypeFlag(mem2, 1);
                    Sqlite3.REGISTER_TRACE(p, vdbeOp.p2, mem2);
                    goto default;
                  }
                  else if (((int) vdbeOp.p5 & 8) != 0)
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                    goto default;
                }
                else
                {
                  char affinity = (char) ((uint) vdbeOp.p5 & 103U);
                  if (affinity != char.MinValue)
                  {
                    Sqlite3.applyAffinity(mem15, affinity, (int) num3);
                    Sqlite3.applyAffinity(mem16, affinity, (int) num3);
                  }
                  Sqlite3.ExpandBlob(mem15);
                  Sqlite3.ExpandBlob(mem16);
                  num29 = Sqlite3.sqlite3MemCompare(mem16, mem15, vdbeOp.p4.pColl);
                }
                int num30;
                switch (vdbeOp.opcode)
                {
                  case 75:
                    num30 = num29 != 0 ? 1 : 0;
                    break;
                  case 76:
                    num30 = num29 == 0 ? 1 : 0;
                    break;
                  case 77:
                    num30 = num29 > 0 ? 1 : 0;
                    break;
                  case 78:
                    num30 = num29 <= 0 ? 1 : 0;
                    break;
                  case 79:
                    num30 = num29 < 0 ? 1 : 0;
                    break;
                  default:
                    num30 = num29 >= 0 ? 1 : 0;
                    break;
                }
                if (((int) vdbeOp.p5 & 16) != 0)
                {
                  mem2 = memArray1[vdbeOp.p2];
                  Sqlite3.memAboutToChange(p, mem2);
                  Sqlite3.MemSetTypeFlag(mem2, 4);
                  mem2.u.i = (long) num30;
                  Sqlite3.REGISTER_TRACE(p, vdbeOp.p2, mem2);
                }
                else if (num30 != 0)
                  index1 = vdbeOp.p2 - 1;
                mem15.flags = (ushort) ((int) mem15.flags & -256 | (int) flags1 & (int) byte.MaxValue);
                mem16.flags = (ushort) ((int) mem16.flags & -256 | (int) flags2 & (int) byte.MaxValue);
                goto default;
              case 81:
              case 92:
                int res = 0;
                Sqlite3.UnpackedRecord pUnpacked = new Sqlite3.UnpackedRecord();
                Sqlite3.VdbeCursor pC = p.apCsr[vdbeOp.p1];
                if (Sqlite3.ALWAYS(pC.pCursor != null))
                {
                  pUnpacked.pKeyInfo = pC.pKeyInfo;
                  pUnpacked.nField = (ushort) vdbeOp.p4.i;
                  pUnpacked.flags = vdbeOp.p5 == (byte) 0 ? (ushort) 4 : (ushort) 12;
                  pUnpacked.aMem = new Sqlite3.Mem[(int) pUnpacked.nField];
                  for (int index16 = 0; index16 < (int) pUnpacked.nField; ++index16)
                    pUnpacked.aMem[index16] = memArray1[vdbeOp.p3 + index16];
                  num1 = Sqlite3.sqlite3VdbeIdxKeyCompare(pC, pUnpacked, ref res);
                  if ((vdbeOp.opcode != (byte) 81 ? res + 1 : -res) > 0)
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                    goto default;
                }
                else
                  goto default;
              case 82:
              case 83:
              case 84:
              case 85:
                Sqlite3.Mem pMem12 = memArray1[vdbeOp.p1];
                Sqlite3.Mem pMem13 = memArray1[vdbeOp.p2];
                mem2 = memArray1[vdbeOp.p3];
                if ((((int) pMem12.flags | (int) pMem13.flags) & 1) != 0)
                {
                  Sqlite3.sqlite3VdbeMemSetNull(mem2);
                  goto default;
                }
                else
                {
                  long num31 = Sqlite3.sqlite3VdbeIntValue(pMem13);
                  long num32 = Sqlite3.sqlite3VdbeIntValue(pMem12);
                  byte num33 = vdbeOp.opcode;
                  switch (num33)
                  {
                    case 82:
                      num31 &= num32;
                      break;
                    case 83:
                      num31 |= num32;
                      break;
                    default:
                      if (num32 != 0L)
                      {
                        if (num32 < 0L)
                        {
                          num33 = (byte) (169U - (uint) num33);
                          num32 = num32 > -64L ? -num32 : 64L;
                        }
                        if (num32 >= 64L)
                        {
                          num31 = num31 >= 0L || num33 == (byte) 84 ? 0L : -1L;
                          break;
                        }
                        if (num33 == (byte) 84)
                        {
                          num31 <<= (int) num32;
                          break;
                        }
                        num31 >>= (int) num32;
                        break;
                      }
                      break;
                  }
                  mem2.u.i = num31;
                  Sqlite3.MemSetTypeFlag(mem2, 4);
                  goto default;
                }
              case 86:
              case 87:
              case 88:
              case 89:
              case 90:
                long pA = 0;
                Sqlite3.Mem mem17 = memArray1[vdbeOp.p1];
                Sqlite3.applyNumericAffinity(mem17);
                Sqlite3.Mem mem18 = memArray1[vdbeOp.p2];
                Sqlite3.applyNumericAffinity(mem18);
                mem2 = memArray1[vdbeOp.p3];
                int num34 = (int) mem17.flags | (int) mem18.flags;
                if ((num34 & 1) == 0)
                {
                  bool flag2;
                  if (!(flag2 = ((int) mem17.flags & (int) mem18.flags & 4) != 4))
                  {
                    long iB = mem17.u.i;
                    pA = mem18.u.i;
                    switch (vdbeOp.opcode)
                    {
                      case 86:
                        if (Sqlite3.sqlite3AddInt64(ref pA, iB) != 0)
                        {
                          flag2 = true;
                          break;
                        }
                        break;
                      case 87:
                        if (Sqlite3.sqlite3SubInt64(ref pA, iB) != 0)
                        {
                          flag2 = true;
                          break;
                        }
                        break;
                      case 88:
                        if (Sqlite3.sqlite3MulInt64(ref pA, iB) != 0)
                        {
                          flag2 = true;
                          break;
                        }
                        break;
                      case 89:
                        switch (iB)
                        {
                          case -1:
                            if (pA == long.MinValue)
                            {
                              flag2 = true;
                              goto label_85;
                            }
                            else
                              break;
                          case 0:
                            goto label_99;
                        }
                        pA /= iB;
                        break;
                      default:
                        switch (iB)
                        {
                          case -1:
                            iB = 1L;
                            break;
                          case 0:
                            goto label_99;
                        }
                        pA %= iB;
                        break;
                    }
                  }
label_85:
                  if (!flag2)
                  {
                    mem2.u.i = pA;
                    Sqlite3.MemSetTypeFlag(mem2, 4);
                    goto default;
                  }
                  else
                  {
                    double num35 = Sqlite3.sqlite3VdbeRealValue(mem17);
                    double num36 = Sqlite3.sqlite3VdbeRealValue(mem18);
                    double x;
                    switch (vdbeOp.opcode)
                    {
                      case 86:
                        x = num36 + num35;
                        break;
                      case 87:
                        x = num36 - num35;
                        break;
                      case 88:
                        x = num36 * num35;
                        break;
                      case 89:
                        if (num35 != 0.0)
                        {
                          x = num36 / num35;
                          break;
                        }
                        goto label_99;
                      default:
                        long num37 = (long) num35;
                        long num38 = (long) num36;
                        switch (num37)
                        {
                          case -1:
                            num37 = 1L;
                            break;
                          case 0:
                            goto label_99;
                        }
                        x = (double) (num38 % num37);
                        break;
                    }
                    if (!Sqlite3.sqlite3IsNaN(x))
                    {
                      mem2.r = x;
                      Sqlite3.MemSetTypeFlag(mem2, 8);
                      if ((num34 & 8) == 0)
                      {
                        Sqlite3.sqlite3VdbeIntegerAffinity(mem2);
                        goto default;
                      }
                      else
                        goto default;
                    }
                  }
                }
label_99:
                Sqlite3.sqlite3VdbeMemSetNull(mem2);
                goto default;
              case 91:
                Sqlite3.Mem mem19 = memArray1[vdbeOp.p1];
                Sqlite3.Mem mem20 = memArray1[vdbeOp.p2];
                mem2 = memArray1[vdbeOp.p3];
                if ((((int) mem19.flags | (int) mem20.flags) & 1) != 0)
                {
                  Sqlite3.sqlite3VdbeMemSetNull(mem2);
                  goto default;
                }
                else if (Sqlite3.ExpandBlob(mem19) == 0 && Sqlite3.ExpandBlob(mem20) == 0 && (((int) mem19.flags & 18) != 0 || Sqlite3.sqlite3VdbeMemStringify(mem19, (int) num3) == 0) && (((int) mem20.flags & 18) != 0 || Sqlite3.sqlite3VdbeMemStringify(mem20, (int) num3) == 0))
                {
                  long num39 = (long) (mem19.n + mem20.n);
                  if (num39 <= (long) db1.aLimit[0])
                  {
                    Sqlite3.MemSetTypeFlag(mem2, 2);
                    if (mem20.z != null && mem20.z.Length >= mem20.n)
                    {
                      if (mem19.z != null)
                        mem2.z = mem20.z.Substring(0, mem20.n) + (mem19.n < mem19.z.Length ? mem19.z.Substring(0, mem19.n) : mem19.z);
                      else if (((int) mem19.flags & 16) == 0)
                      {
                        StringBuilder stringBuilder = new StringBuilder(mem19.n);
                        for (int index17 = 0; index17 < mem19.n; ++index17)
                          stringBuilder.Append(mem19.zBLOB[index17]);
                        mem2.z = mem20.z.Substring(0, mem20.n) + stringBuilder.ToString();
                      }
                      else
                        mem2.z = mem20.z.Substring(0, mem20.n) + Encoding.UTF8.GetString(mem19.zBLOB, 0, mem19.zBLOB.Length);
                    }
                    else
                    {
                      mem2.zBLOB = Sqlite3.sqlite3Malloc(mem19.n + mem20.n);
                      Buffer.BlockCopy((Array) mem20.zBLOB, 0, (Array) mem2.zBLOB, 0, mem20.n);
                      if (mem19.zBLOB != null)
                      {
                        Buffer.BlockCopy((Array) mem19.zBLOB, 0, (Array) mem2.zBLOB, mem20.n, mem19.n);
                      }
                      else
                      {
                        for (int index18 = 0; index18 < mem19.n; ++index18)
                          mem2.zBLOB[mem20.n + index18] = (byte) mem19.z[index18];
                      }
                    }
                    mem2.flags |= (ushort) 512;
                    mem2.n = (int) num39;
                    mem2.enc = num3;
                    goto default;
                  }
                  else
                    break;
                }
                else
                  goto label_678;
              case 93:
                Sqlite3.Mem pMem14 = memArray1[vdbeOp.p1];
                mem2 = memArray1[vdbeOp.p2];
                if (((int) pMem14.flags & 1) != 0)
                {
                  Sqlite3.sqlite3VdbeMemSetNull(mem2);
                  goto default;
                }
                else
                {
                  Sqlite3.sqlite3VdbeMemSetInt64(mem2, ~Sqlite3.sqlite3VdbeIntValue(pMem14));
                  goto default;
                }
              case 94:
                vdbeOp.opcode = (byte) 9;
                vdbeOp.p1 = Sqlite3.sqlite3Strlen30(vdbeOp.p4.z);
                if (vdbeOp.p1 > db1.aLimit[0])
                  break;
                goto case 9;
              case 95:
                int piMoved = 0;
                int activeVdbeCnt = db1.activeVdbeCnt;
                mem2.flags = (ushort) 1;
                if (activeVdbeCnt > 1)
                {
                  num1 = 6;
                  p.errorAction = (byte) 2;
                  goto default;
                }
                else
                {
                  int p3_5 = vdbeOp.p3;
                  num1 = Sqlite3.sqlite3BtreeDropTable(db1.aDb[p3_5].pBt, vdbeOp.p1, ref piMoved);
                  mem2.flags = (ushort) 4;
                  mem2.u.i = (long) piMoved;
                  if (num1 == 0 && piMoved != 0)
                  {
                    Sqlite3.sqlite3RootPageMoved(db1, p3_5, piMoved, vdbeOp.p1);
                    num2 = (byte) (p3_5 + 1);
                    goto default;
                  }
                  else
                    goto default;
                }
              case 96:
                int pnChange1 = 0;
                int pnChange2 = 0;
                num1 = vdbeOp.p3 == 0 ? Sqlite3.sqlite3BtreeClearTable(db1.aDb[vdbeOp.p2].pBt, vdbeOp.p1, ref pnChange2) : Sqlite3.sqlite3BtreeClearTable(db1.aDb[vdbeOp.p2].pBt, vdbeOp.p1, ref pnChange1);
                if (vdbeOp.p3 != 0)
                {
                  p.nChange += pnChange1;
                  if (vdbeOp.p3 > 0)
                  {
                    Sqlite3.memAboutToChange(p, memArray1[vdbeOp.p3]);
                    memArray1[vdbeOp.p3].u.i += (long) pnChange1;
                    goto default;
                  }
                  else
                    goto default;
                }
                else
                  goto default;
              case 97:
              case 98:
                int piTable1 = 0;
                Sqlite3.Db db4 = db1.aDb[vdbeOp.p1];
                int flags3 = vdbeOp.opcode != (byte) 98 ? 2 : 1;
                num1 = Sqlite3.sqlite3BtreeCreateTable(db4.pBt, ref piTable1, flags3);
                mem2.u.i = (long) piTable1;
                goto default;
              case 99:
                int p1_8 = vdbeOp.p1;
                string str2 = Sqlite3.SCHEMA_TABLE(p1_8);
                Sqlite3.InitData pArg = new Sqlite3.InitData();
                pArg.db = db1;
                pArg.iDb = vdbeOp.p1;
                pArg.pzErrMsg = p.zErrMsg;
                string pString = Sqlite3.sqlite3MPrintf(db1, "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid", (object) db1.aDb[p1_8].zName, (object) str2, (object) vdbeOp.p4.z);
                if (string.IsNullOrEmpty(pString))
                {
                  num1 = 7;
                }
                else
                {
                  db1.init.busy = (byte) 1;
                  pArg.rc = 0;
                  num1 = Sqlite3.sqlite3_exec(db1, pString, new Sqlite3.dxCallback(Sqlite3.sqlite3InitCallback), (object) pArg, 0);
                  if (num1 == 0)
                    num1 = pArg.rc;
                  Sqlite3.sqlite3DbFree(db1, ref pString);
                  db1.init.busy = (byte) 0;
                }
                if (num1 != 7)
                  goto default;
                else
                  goto label_678;
              case 100:
                num1 = Sqlite3.sqlite3AnalysisLoad(db1, vdbeOp.p1);
                goto default;
              case 101:
                Sqlite3.sqlite3UnlinkAndDeleteTable(db1, vdbeOp.p1, vdbeOp.p4.z);
                goto default;
              case 102:
                Sqlite3.sqlite3UnlinkAndDeleteIndex(db1, vdbeOp.p1, vdbeOp.p4.z);
                goto default;
              case 103:
                Sqlite3.sqlite3UnlinkAndDeleteTrigger(db1, vdbeOp.p1, vdbeOp.p4.z);
                goto default;
              case 104:
                int[] pInt = (int[]) null;
                int pnErr = 0;
                int p2_6 = vdbeOp.p2;
                int[] pPrior = Sqlite3.sqlite3Malloc(pInt, p2_6 + 1);
                if (pPrior != null)
                {
                  Sqlite3.Mem mem21 = memArray1[vdbeOp.p3];
                  Sqlite3.Mem pMem15 = memArray1[vdbeOp.p1];
                  int index19;
                  for (index19 = 0; index19 < p2_6; ++index19)
                    pPrior[index19] = (int) Sqlite3.sqlite3VdbeIntValue(p.aMem[vdbeOp.p1 + index19]);
                  pPrior[index19] = 0;
                  string z5 = Sqlite3.sqlite3BtreeIntegrityCheck(db1.aDb[(int) vdbeOp.p5].pBt, pPrior, p2_6, (int) mem21.u.i, ref pnErr);
                  Sqlite3.sqlite3DbFree(db1, ref pPrior);
                  mem21.u.i -= (long) pnErr;
                  Sqlite3.sqlite3VdbeMemSetNull(pMem15);
                  if (pnErr != 0)
                  {
                    if (!string.IsNullOrEmpty(z5))
                      Sqlite3.sqlite3VdbeMemSetStr(pMem15, z5, -1, (byte) 1, (Sqlite3.dxDel) null);
                    else
                      goto label_678;
                  }
                  Sqlite3.sqlite3VdbeChangeEncoding(pMem15, (int) num3);
                  goto default;
                }
                else
                  goto label_678;
              case 105:
                Sqlite3.Mem pMem16 = memArray1[vdbeOp.p1];
                Sqlite3.Mem mem22 = memArray1[vdbeOp.p2];
                if (((int) pMem16.flags & 32) == 0)
                {
                  Sqlite3.sqlite3VdbeMemSetRowSet(pMem16);
                  if (((int) pMem16.flags & 32) == 0)
                    goto label_678;
                }
                Sqlite3.sqlite3RowSetInsert(pMem16.u.pRowSet, mem22.u.i);
                goto default;
              case 106:
                long pRowid = 0;
                if (!db1.u1.isInterrupted)
                {
                  Sqlite3.Mem pMem17 = memArray1[vdbeOp.p1];
                  if (((int) pMem17.flags & 32) == 0 || Sqlite3.sqlite3RowSetNext(pMem17.u.pRowSet, ref pRowid) == 0)
                  {
                    Sqlite3.sqlite3VdbeMemSetNull(pMem17);
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                  {
                    Sqlite3.sqlite3VdbeMemSetInt64(memArray1[vdbeOp.p3], pRowid);
                    goto default;
                  }
                }
                else
                  goto label_681;
              case 107:
                Sqlite3.Mem pMem18 = memArray1[vdbeOp.p1];
                Sqlite3.Mem mem23 = memArray1[vdbeOp.p3];
                int i5 = vdbeOp.p4.i;
                if (((int) pMem18.flags & 32) == 0)
                {
                  Sqlite3.sqlite3VdbeMemSetRowSet(pMem18);
                  if (((int) pMem18.flags & 32) == 0)
                    goto label_678;
                }
                if (i5 != 0 && Sqlite3.sqlite3RowSetTest(pMem18.u.pRowSet, i5 >= 0 ? (byte) (i5 & 15) : byte.MaxValue, mem23.u.i) != 0)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else if (i5 >= 0)
                {
                  Sqlite3.sqlite3RowSetInsert(pMem18.u.pRowSet, mem23.u.i);
                  goto default;
                }
                else
                  goto default;
              case 108:
                Sqlite3.Mem pMem19 = (Sqlite3.Mem) null;
                Sqlite3.SubProgram pProgram = vdbeOp.p4.pProgram;
                Sqlite3.Mem p8 = memArray1[vdbeOp.p3];
                if (vdbeOp.p5 != (byte) 0)
                {
                  int token = pProgram.token;
                  Sqlite3.VdbeFrame vdbeFrame = p.pFrame;
                  while (vdbeFrame != null && vdbeFrame.token != token)
                    vdbeFrame = vdbeFrame.pParent;
                  if (vdbeFrame != null)
                    goto default;
                }
                if (p.nFrame >= db1.aLimit[10])
                {
                  num1 = 1;
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "too many levels of trigger recursion");
                  goto default;
                }
                else
                {
                  Sqlite3.VdbeFrame vdbeFrame;
                  if (((int) p8.flags & 64) == 0)
                  {
                    int num40 = pProgram.nMem + pProgram.nCsr;
                    vdbeFrame = new Sqlite3.VdbeFrame();
                    Sqlite3.sqlite3VdbeMemRelease(p8);
                    p8.flags = (ushort) 64;
                    p8.u.pFrame = vdbeFrame;
                    vdbeFrame.v = p;
                    vdbeFrame.nChildMem = num40;
                    vdbeFrame.nChildCsr = pProgram.nCsr;
                    vdbeFrame.pc = index1;
                    vdbeFrame.aMem = p.aMem;
                    vdbeFrame.nMem = p.nMem;
                    vdbeFrame.apCsr = p.apCsr;
                    vdbeFrame.nCursor = p.nCursor;
                    vdbeFrame.aOp = p.aOp;
                    vdbeFrame.nOp = p.nOp;
                    vdbeFrame.token = pProgram.token;
                    vdbeFrame.aChildMem = new Sqlite3.Mem[vdbeFrame.nChildMem + 1];
                    for (int index20 = 0; index20 < vdbeFrame.aChildMem.Length; ++index20)
                    {
                      pMem19 = Sqlite3.sqlite3Malloc(pMem19);
                      pMem19.flags = (ushort) 1;
                      pMem19.db = db1;
                      vdbeFrame.aChildMem[index20] = pMem19;
                    }
                    vdbeFrame.aChildCsr = new Sqlite3.VdbeCursor[vdbeFrame.nChildCsr];
                    for (int index21 = 0; index21 < vdbeFrame.nChildCsr; ++index21)
                      vdbeFrame.aChildCsr[index21] = new Sqlite3.VdbeCursor();
                  }
                  else
                    vdbeFrame = p8.u.pFrame;
                  ++p.nFrame;
                  vdbeFrame.pParent = p.pFrame;
                  vdbeFrame.lastRowid = num6;
                  vdbeFrame.nChange = p.nChange;
                  p.nChange = 0;
                  p.pFrame = vdbeFrame;
                  p.aMem = memArray1 = vdbeFrame.aChildMem;
                  p.nMem = vdbeFrame.nChildMem;
                  p.nCursor = (ushort) vdbeFrame.nChildCsr;
                  p.apCsr = vdbeFrame.aChildCsr;
                  p.aOp = aOp = pProgram.aOp;
                  p.nOp = pProgram.nOp;
                  index1 = -1;
                  goto default;
                }
              case 109:
                Sqlite3.VdbeFrame pFrame1 = p.pFrame;
                Sqlite3.Mem pFrom3 = pFrame1.aMem[vdbeOp.p1 + pFrame1.aOp[pFrame1.pc].p1];
                Sqlite3.sqlite3VdbeMemShallowCopy(mem2, pFrom3, 4096);
                goto default;
              case 110:
                if (vdbeOp.p1 != 0)
                {
                  db1.nDeferredCons += (long) vdbeOp.p2;
                  goto default;
                }
                else
                {
                  p.nFkConstraint += (long) vdbeOp.p2;
                  goto default;
                }
              case 111:
                if (vdbeOp.p1 != 0)
                {
                  if (db1.nDeferredCons == 0L)
                  {
                    index1 = vdbeOp.p2 - 1;
                    goto default;
                  }
                  else
                    goto default;
                }
                else if (p.nFkConstraint == 0L)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 112:
                Sqlite3.Mem pMem20;
                if (p.pFrame != null)
                {
                  Sqlite3.VdbeFrame vdbeFrame = p.pFrame;
                  while (vdbeFrame.pParent != null)
                    vdbeFrame = vdbeFrame.pParent;
                  pMem20 = vdbeFrame.aMem[vdbeOp.p1];
                }
                else
                  pMem20 = memArray1[vdbeOp.p1];
                Sqlite3.sqlite3VdbeMemIntegerify(pMem20);
                Sqlite3.Mem pMem21 = memArray1[vdbeOp.p2];
                Sqlite3.sqlite3VdbeMemIntegerify(pMem21);
                if (pMem20.u.i < pMem21.u.i)
                {
                  pMem20.u.i = pMem21.u.i;
                  goto default;
                }
                else
                  goto default;
              case 113:
                if (memArray1[vdbeOp.p1].u.i > 0L)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 114:
                if (memArray1[vdbeOp.p1].u.i < 0L)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 115:
                Sqlite3.Mem mem24 = memArray1[vdbeOp.p1];
                mem24.u.i += (long) vdbeOp.p3;
                if (mem24.u.i == 0L)
                {
                  index1 = vdbeOp.p2 - 1;
                  goto default;
                }
                else
                  goto default;
              case 116:
                Sqlite3.sqlite3_context ctx2 = new Sqlite3.sqlite3_context();
                int p5_2 = (int) vdbeOp.p5;
                Sqlite3.Mem[] apArg2 = p.apArg;
                for (int index22 = 0; index22 < p5_2; ++index22)
                {
                  Sqlite3.Mem mem25 = memArray1[vdbeOp.p2 + index22];
                  apArg2[index22] = mem25;
                  Sqlite3.memAboutToChange(p, mem25);
                  Sqlite3.sqlite3VdbeMemStoreType(mem25);
                }
                ctx2.pFunc = vdbeOp.p4.pFunc;
                ++(ctx2.pMem = memArray1[vdbeOp.p3]).n;
                ctx2.s.flags = (ushort) 1;
                ctx2.s.z = (string) null;
                ctx2.s.xDel = (Sqlite3.dxDel) null;
                ctx2.s.db = db1;
                ctx2.isError = 0;
                ctx2.pColl = (Sqlite3.CollSeq) null;
                if (((int) ctx2.pFunc.flags & 8) != 0)
                  ctx2.pColl = p.aOp[index1 - 1].p4.pColl;
                ctx2.pFunc.xStep(ctx2, p5_2, apArg2);
                if (ctx2.isError != 0)
                {
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, Sqlite3.sqlite3_value_text(ctx2.s));
                  num1 = ctx2.isError;
                }
                Sqlite3.sqlite3VdbeMemRelease(ctx2.s);
                goto default;
              case 117:
                Sqlite3.Mem mem26 = memArray1[vdbeOp.p1];
                num1 = Sqlite3.sqlite3VdbeMemFinalize(mem26, vdbeOp.p4.pFunc);
                p.aMem[vdbeOp.p1] = mem26;
                if (num1 != 0)
                  Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, Sqlite3.sqlite3_value_text(mem26));
                Sqlite3.sqlite3VdbeChangeEncoding(mem26, (int) num3);
                if (!Sqlite3.sqlite3VdbeMemTooBig(mem26))
                  goto default;
                else
                  break;
              case 119:
                int eMode1 = vdbeOp.p3;
                Sqlite3.Pager pPager = Sqlite3.sqlite3BtreePager(db1.aDb[vdbeOp.p1].pBt);
                int journalMode = Sqlite3.sqlite3PagerGetJournalMode(pPager);
                if (eMode1 == -1)
                  eMode1 = journalMode;
                if (Sqlite3.sqlite3PagerOkToChangeJournalMode(pPager) == 0)
                  eMode1 = journalMode;
                if (num1 != 0)
                  eMode1 = journalMode;
                int eMode2 = Sqlite3.sqlite3PagerSetJournalMode(pPager, eMode1);
                mem2 = memArray1[vdbeOp.p2];
                mem2.flags = (ushort) 2562;
                mem2.z = Sqlite3.sqlite3JournalModename(eMode2);
                mem2.n = Sqlite3.sqlite3Strlen30(mem2.z);
                mem2.enc = (byte) 1;
                Sqlite3.sqlite3VdbeChangeEncoding(mem2, (int) num3);
                goto default;
              case 120:
                num1 = Sqlite3.sqlite3RunVacuum(ref p.zErrMsg, db1);
                goto default;
              case 121:
                num1 = Sqlite3.sqlite3BtreeIncrVacuum(db1.aDb[vdbeOp.p1].pBt);
                if (num1 == 101)
                {
                  index1 = vdbeOp.p2 - 1;
                  num1 = 0;
                  goto default;
                }
                else
                  goto default;
              case 122:
                if (vdbeOp.p1 == 0)
                {
                  Sqlite3.sqlite3ExpirePreparedStatements(db1);
                  goto default;
                }
                else
                {
                  p.expired = true;
                  goto default;
                }
              case 130:
                mem2.flags = (ushort) 8;
                mem2.r = vdbeOp.p4.pReal;
                goto default;
              case 134:
                mem2.u.i = (long) Sqlite3.sqlite3BtreeLastPage(db1.aDb[vdbeOp.p1].pBt);
                goto default;
              case 135:
                Sqlite3.Btree pBt4 = db1.aDb[vdbeOp.p1].pBt;
                long mxPage = 0;
                if (vdbeOp.p3 != 0)
                {
                  mxPage = (long) Sqlite3.sqlite3BtreeLastPage(pBt4);
                  if (mxPage < (long) vdbeOp.p3)
                    mxPage = (long) vdbeOp.p3;
                }
                mem2.u.i = (long) Sqlite3.sqlite3BtreeMaxPageCount(pBt4, (int) mxPage);
                goto default;
              case 136:
                string zRawSql;
                if (db1.xTrace != null && !string.IsNullOrEmpty(zRawSql = vdbeOp.p4.z != null ? vdbeOp.p4.z : p.zSql))
                {
                  string msg = Sqlite3.sqlite3VdbeExpandSql(p, zRawSql);
                  db1.xTrace(db1.pTraceArg, msg);
                  goto default;
                }
                else
                  goto default;
              case 141:
                Sqlite3.Mem mem27 = memArray1[vdbeOp.p1];
                Sqlite3.memAboutToChange(p, mem27);
                if (((int) mem27.flags & 1) == 0)
                {
                  mem27.flags |= (ushort) (((int) mem27.flags & 16) >> 3);
                  Sqlite3.applyAffinity(mem27, 'a', (int) num3);
                  num1 = Sqlite3.ExpandBlob(mem27);
                  mem27.flags &= (ushort) 65507;
                  goto default;
                }
                else
                  goto default;
              case 142:
                Sqlite3.Mem mem28 = memArray1[vdbeOp.p1];
                if (((int) mem28.flags & 1) == 0)
                {
                  if (((int) mem28.flags & 16) == 0)
                  {
                    Sqlite3.applyAffinity(mem28, 'a', (int) num3);
                    Sqlite3.MemSetTypeFlag(mem28, 16);
                    goto default;
                  }
                  else
                  {
                    mem28.flags &= (ushort) 65296;
                    goto default;
                  }
                }
                else
                  goto default;
              case 143:
                Sqlite3.sqlite3VdbeMemNumerify(memArray1[vdbeOp.p1]);
                goto default;
              case 144:
                Sqlite3.Mem pMem22 = memArray1[vdbeOp.p1];
                if (((int) pMem22.flags & 1) == 0)
                {
                  Sqlite3.sqlite3VdbeMemIntegerify(pMem22);
                  goto default;
                }
                else
                  goto default;
              case 145:
                Sqlite3.Mem mem29 = memArray1[vdbeOp.p1];
                Sqlite3.memAboutToChange(p, mem29);
                if (((int) mem29.flags & 1) == 0)
                {
                  Sqlite3.sqlite3VdbeMemRealify(mem29);
                  goto default;
                }
                else
                  goto default;
              default:
                ++index1;
                continue;
            }
            Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "string or blob too big");
            num1 = 18;
            break;
label_679:
            if (num1 != 3082)
            {
              Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "%s", Sqlite3.sqlite3ErrStr(num1));
              break;
            }
            break;
          }
          goto label_674;
        }
label_681:
        num1 = 9;
        p.rc = num1;
        Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, Sqlite3.sqlite3ErrStr(num1));
      }
      else
        goto label_678;
label_674:
      p.rc = num1;
      Sqlite3.testcase<bool>(Sqlite3.sqlite3GlobalConfig.xLog != null);
      Sqlite3.sqlite3_log(num1, "statement aborts at %d: [%s] %s", (object) index1, (object) p.zSql, (object) p.zErrMsg);
      Sqlite3.sqlite3VdbeHalt(p);
      num7 = 1;
      if (num2 > (byte) 0)
        Sqlite3.sqlite3ResetInternalSchema(db1, (int) num2 - 1);
label_676:
      db1.lastRowid = num6;
      Sqlite3.sqlite3VdbeLeave(p);
      return num7;
label_678:
      Sqlite3.sqlite3SetString(ref p.zErrMsg, db1, "out of memory");
      num1 = 7;
      goto label_674;
    }

    private static int ADDR(int x) => -1 - x;

    private static void VdbeComment(Sqlite3.Vdbe v, string zFormat, params object[] ap)
    {
    }

    private static void VdbeNoopComment(Sqlite3.Vdbe v, string zFormat, params object[] ap)
    {
    }

    private static int sqlite3WalkExpr(Sqlite3.Walker pWalker, ref Sqlite3.Expr pExpr)
    {
      if (pExpr == null)
        return 0;
      Sqlite3.testcase<bool>(Sqlite3.ExprHasProperty(pExpr, 8192));
      Sqlite3.testcase<bool>(Sqlite3.ExprHasProperty(pExpr, 4096));
      int num = pWalker.xExprCallback(pWalker, ref pExpr);
      if (num == 0 && !Sqlite3.ExprHasAnyProperty(pExpr, 8192))
      {
        if (Sqlite3.sqlite3WalkExpr(pWalker, ref pExpr.pLeft) != 0 || Sqlite3.sqlite3WalkExpr(pWalker, ref pExpr.pRight) != 0)
          return 2;
        if (Sqlite3.ExprHasProperty(pExpr, 2048))
        {
          if (Sqlite3.sqlite3WalkSelect(pWalker, pExpr.x.pSelect) != 0)
            return 2;
        }
        else if (Sqlite3.sqlite3WalkExprList(pWalker, pExpr.x.pList) != 0)
          return 2;
      }
      return num & 2;
    }

    private static int sqlite3WalkExprList(Sqlite3.Walker pWalker, Sqlite3.ExprList p)
    {
      if (p != null)
      {
        for (int nExpr = p.nExpr; nExpr > 0; --nExpr)
        {
          Sqlite3.ExprList_item exprListItem = p.a[p.nExpr - nExpr];
          if (Sqlite3.sqlite3WalkExpr(pWalker, ref exprListItem.pExpr) != 0)
            return 2;
        }
      }
      return 0;
    }

    private static int sqlite3WalkSelectExpr(Sqlite3.Walker pWalker, Sqlite3.Select p) => Sqlite3.sqlite3WalkExprList(pWalker, p.pEList) != 0 || Sqlite3.sqlite3WalkExpr(pWalker, ref p.pWhere) != 0 || Sqlite3.sqlite3WalkExprList(pWalker, p.pGroupBy) != 0 || Sqlite3.sqlite3WalkExpr(pWalker, ref p.pHaving) != 0 || Sqlite3.sqlite3WalkExprList(pWalker, p.pOrderBy) != 0 || Sqlite3.sqlite3WalkExpr(pWalker, ref p.pLimit) != 0 || Sqlite3.sqlite3WalkExpr(pWalker, ref p.pOffset) != 0 ? 2 : 0;

    private static int sqlite3WalkSelectFrom(Sqlite3.Walker pWalker, Sqlite3.Select p)
    {
      Sqlite3.SrcList pSrc = p.pSrc;
      if (Sqlite3.ALWAYS<Sqlite3.SrcList>(pSrc))
      {
        for (int nSrc = (int) pSrc.nSrc; nSrc > 0; --nSrc)
        {
          Sqlite3.SrcList_item srcListItem = pSrc.a[(int) pSrc.nSrc - nSrc];
          if (Sqlite3.sqlite3WalkSelect(pWalker, srcListItem.pSelect) != 0)
            return 2;
        }
      }
      return 0;
    }

    private static int sqlite3WalkSelect(Sqlite3.Walker pWalker, Sqlite3.Select p)
    {
      if (p == null || pWalker.xSelectCallback == null)
        return 0;
      int num = 0;
      for (; p != null; p = p.pPrior)
      {
        num = pWalker.xSelectCallback(pWalker, p);
        if (num == 0)
        {
          if (Sqlite3.sqlite3WalkSelectExpr(pWalker, p) != 0 || Sqlite3.sqlite3WalkSelectFrom(pWalker, p) != 0)
            return 2;
        }
        else
          break;
      }
      return num & 2;
    }

    private static int sqlite3WalOpen(Sqlite3.sqlite3_vfs x, Sqlite3.sqlite3_file y, string z) => 0;

    private static void sqlite3WalLimit(Sqlite3.sqlite3_vfs x, long y)
    {
    }

    private static int sqlite3WalClose(object w, int x, int y, byte z) => 0;

    private static int sqlite3WalBeginReadTransaction(object y, int z) => 0;

    private static void sqlite3WalEndReadTransaction(object z)
    {
    }

    private static int sqlite3WalRead(object v, uint w, ref int x, int y, byte[] z) => 0;

    private static uint sqlite3WalDbsize(object y) => 0;

    private static int sqlite3WalBeginWriteTransaction(object y) => 0;

    private static int sqlite3WalEndWriteTransaction(object x) => 0;

    private static int sqlite3WalUndo(object x, int y, object z) => 0;

    private static void sqlite3WalSavepoint(object y, object z)
    {
    }

    private static int sqlite3WalSavepointUndo(object y, object z) => 0;

    private static int sqlite3WalFrames(object u, int v, Sqlite3.PgHdr w, uint x, int y, int z) => 0;

    private static int sqlite3WalCheckpoint(
      object r,
      int s,
      int t,
      byte[] u,
      int v,
      int w,
      byte[] x,
      ref int y,
      ref int z)
    {
      y = 0;
      z = 0;
      return 0;
    }

    private static int sqlite3WalCallback(object z) => 0;

    private static bool sqlite3WalExclusiveMode(object y, int z) => false;

    private static bool sqlite3WalHeapMemory(object z) => false;

    private static void WHERETRACE(string X, params object[] ap)
    {
    }

    private static void whereClauseInit(
      Sqlite3.WhereClause pWC,
      Sqlite3.Parse pParse,
      Sqlite3.WhereMaskSet pMaskSet)
    {
      pWC.pParse = pParse;
      pWC.pMaskSet = pMaskSet;
      pWC.nTerm = 0;
      pWC.nSlot = Sqlite3.ArraySize<Sqlite3.WhereTerm>(pWC.aStatic) - 1;
      pWC.a = pWC.aStatic;
      pWC.vmask = 0UL;
    }

    private static void whereOrInfoDelete(Sqlite3.sqlite3 db, Sqlite3.WhereOrInfo p)
    {
      Sqlite3.whereClauseClear(p.wc);
      Sqlite3.sqlite3DbFree<Sqlite3.WhereOrInfo>(db, ref p);
    }

    private static void whereAndInfoDelete(Sqlite3.sqlite3 db, Sqlite3.WhereAndInfo p)
    {
      Sqlite3.whereClauseClear(p.wc);
      Sqlite3.sqlite3DbFree<Sqlite3.WhereAndInfo>(db, ref p);
    }

    private static void whereClauseClear(Sqlite3.WhereClause pWC)
    {
      Sqlite3.sqlite3 db = pWC.pParse.db;
      for (int index = pWC.nTerm - 1; index >= 0; --index)
      {
        Sqlite3.WhereTerm whereTerm = pWC.a[index];
        if (((int) whereTerm.wtFlags & 1) != 0)
          Sqlite3.sqlite3ExprDelete(db, ref whereTerm.pExpr);
        if (((int) whereTerm.wtFlags & 16) != 0)
          Sqlite3.whereOrInfoDelete(db, whereTerm.u.pOrInfo);
        else if (((int) whereTerm.wtFlags & 32) != 0)
          Sqlite3.whereAndInfoDelete(db, whereTerm.u.pAndInfo);
      }
      if (pWC.a == pWC.aStatic)
        return;
      Sqlite3.sqlite3DbFree<Sqlite3.WhereTerm[]>(db, ref pWC.a);
    }

    private static int whereClauseInsert(Sqlite3.WhereClause pWC, Sqlite3.Expr p, byte wtFlags)
    {
      Sqlite3.testcase<int>((int) wtFlags & 2);
      if (pWC.nTerm >= pWC.nSlot)
      {
        Sqlite3.sqlite3 db = pWC.pParse.db;
        Array.Resize<Sqlite3.WhereTerm>(ref pWC.a, pWC.nSlot * 2);
        pWC.nSlot = pWC.a.Length - 1;
      }
      Sqlite3.WhereTerm[] a = pWC.a;
      int num = pWC.nTerm++;
      int index1;
      int index2 = index1 = num;
      Sqlite3.WhereTerm whereTerm1 = new Sqlite3.WhereTerm();
      a[index1] = whereTerm1;
      Sqlite3.WhereTerm whereTerm2 = pWC.a[index2];
      whereTerm2.pExpr = p;
      whereTerm2.wtFlags = wtFlags;
      whereTerm2.pWC = pWC;
      whereTerm2.iParent = -1;
      return index2;
    }

    private static void whereSplit(Sqlite3.WhereClause pWC, Sqlite3.Expr pExpr, int op)
    {
      pWC.op = (byte) op;
      if (pExpr == null)
        return;
      if ((int) pExpr.op != op)
      {
        Sqlite3.whereClauseInsert(pWC, pExpr, (byte) 0);
      }
      else
      {
        Sqlite3.whereSplit(pWC, pExpr.pLeft, op);
        Sqlite3.whereSplit(pWC, pExpr.pRight, op);
      }
    }

    private static ulong getMask(Sqlite3.WhereMaskSet pMaskSet, int iCursor)
    {
      for (int index = 0; index < pMaskSet.n; ++index)
      {
        if (pMaskSet.ix[index] == iCursor)
          return 1UL << index;
      }
      return 0;
    }

    private static void createMask(Sqlite3.WhereMaskSet pMaskSet, int iCursor) => pMaskSet.ix[pMaskSet.n++] = iCursor;

    private static ulong exprTableUsage(Sqlite3.WhereMaskSet pMaskSet, Sqlite3.Expr p)
    {
      if (p == null)
        return 0;
      if (p.op == (byte) 152)
        return Sqlite3.getMask(pMaskSet, p.iTable);
      ulong num = Sqlite3.exprTableUsage(pMaskSet, p.pRight) | Sqlite3.exprTableUsage(pMaskSet, p.pLeft);
      return !Sqlite3.ExprHasProperty(p, 2048) ? num | Sqlite3.exprListTableUsage(pMaskSet, p.x.pList) : num | Sqlite3.exprSelectTableUsage(pMaskSet, p.x.pSelect);
    }

    private static ulong exprListTableUsage(Sqlite3.WhereMaskSet pMaskSet, Sqlite3.ExprList pList)
    {
      ulong num = 0;
      if (pList != null)
      {
        for (int index = 0; index < pList.nExpr; ++index)
          num |= Sqlite3.exprTableUsage(pMaskSet, pList.a[index].pExpr);
      }
      return num;
    }

    private static ulong exprSelectTableUsage(Sqlite3.WhereMaskSet pMaskSet, Sqlite3.Select pS)
    {
      ulong num = 0;
      for (; pS != null; pS = pS.pPrior)
        num = num | Sqlite3.exprListTableUsage(pMaskSet, pS.pEList) | Sqlite3.exprListTableUsage(pMaskSet, pS.pGroupBy) | Sqlite3.exprListTableUsage(pMaskSet, pS.pOrderBy) | Sqlite3.exprTableUsage(pMaskSet, pS.pWhere) | Sqlite3.exprTableUsage(pMaskSet, pS.pHaving);
      return num;
    }

    private static bool allowedOp(int op) => op == 72 || op >= 76 && op <= 80 || op == 73;

    private static void exprCommute(Sqlite3.Parse pParse, Sqlite3.Expr pExpr)
    {
      ushort num1 = (ushort) ((uint) pExpr.pRight.flags & 256U);
      ushort num2 = (ushort) ((uint) pExpr.pLeft.flags & 256U);
      pExpr.pRight.pColl = Sqlite3.sqlite3ExprCollSeq(pParse, pExpr.pRight);
      pExpr.pLeft.pColl = Sqlite3.sqlite3ExprCollSeq(pParse, pExpr.pLeft);
      Sqlite3.SWAP<Sqlite3.CollSeq>(ref pExpr.pRight.pColl, ref pExpr.pLeft.pColl);
      pExpr.pRight.flags = (ushort) ((uint) pExpr.pRight.flags & 4294967039U | (uint) num2);
      pExpr.pLeft.flags = (ushort) ((uint) pExpr.pLeft.flags & 4294967039U | (uint) num1);
      Sqlite3.SWAP<Sqlite3.Expr>(ref pExpr.pRight, ref pExpr.pLeft);
      if (pExpr.op < (byte) 77)
        return;
      pExpr.op = (byte) (((int) pExpr.op - 77 ^ 2) + 77);
    }

    private static ushort operatorMask(int op)
    {
      ushort num;
      switch (op)
      {
        case 72:
          num = (ushort) 1;
          break;
        case 73:
          num = (ushort) 128;
          break;
        default:
          num = (ushort) (2 << op - 76);
          break;
      }
      return num;
    }

    private static Sqlite3.WhereTerm findTerm(
      Sqlite3.WhereClause pWC,
      int iCur,
      int iColumn,
      ulong notReady,
      uint op,
      Sqlite3.Index pIdx)
    {
      op &= 4095U;
      for (int nTerm = pWC.nTerm; nTerm != 0; --nTerm)
      {
        Sqlite3.WhereTerm term = pWC.a[pWC.nTerm - nTerm];
        if (term.leftCursor == iCur && ((long) term.prereqRight & (long) notReady) == 0L && term.u.leftColumn == iColumn && ((int) term.eOperator & (int) op) != 0)
        {
          if (pIdx != null && term.eOperator != (ushort) 128)
          {
            Sqlite3.Expr pExpr = term.pExpr;
            Sqlite3.Parse pParse = pWC.pParse;
            char affinity = pIdx.pTable.aCol[iColumn].affinity;
            if (Sqlite3.sqlite3IndexAffinityOk(pExpr, affinity))
            {
              Sqlite3.CollSeq collSeq = Sqlite3.sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pExpr.pRight);
              int index;
              for (index = 0; pIdx.aiColumn[index] != iColumn; ++index)
              {
                if (Sqlite3.NEVER(index >= pIdx.nColumn))
                  return (Sqlite3.WhereTerm) null;
              }
              if (collSeq != null && !collSeq.zName.Equals(pIdx.azColl[index], StringComparison.InvariantCultureIgnoreCase))
                continue;
            }
            else
              continue;
          }
          return term;
        }
      }
      return (Sqlite3.WhereTerm) null;
    }

    private static void exprAnalyzeAll(Sqlite3.SrcList pTabList, Sqlite3.WhereClause pWC)
    {
      for (int idxTerm = pWC.nTerm - 1; idxTerm >= 0; --idxTerm)
        Sqlite3.exprAnalyze(pTabList, pWC, idxTerm);
    }

    private static int isLikeOrGlob(
      Sqlite3.Parse pParse,
      Sqlite3.Expr pExpr,
      ref Sqlite3.Expr ppPrefix,
      ref bool pisComplete,
      ref bool pnoCase)
    {
      string zToken = (string) null;
      int num1 = 0;
      char[] aWc = new char[3];
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.Mem v = (Sqlite3.Mem) null;
      if (!Sqlite3.sqlite3IsLikeFunction(db, pExpr, ref pnoCase, aWc))
        return 0;
      Sqlite3.ExprList pList = pExpr.x.pList;
      Sqlite3.Expr pExpr1 = pList.a[1].pExpr;
      if (pExpr1.op != (byte) 152 || Sqlite3.sqlite3ExprAffinity(pExpr1) != 'a')
        return 0;
      Sqlite3.Expr pExpr2 = pList.a[0].pExpr;
      int num2 = (int) pExpr2.op;
      if (num2 == 132)
        num2 = (int) pExpr2.op2;
      if (num2 == 133)
      {
        Sqlite3.Vdbe pReprepare = pParse.pReprepare;
        int iColumn = (int) pExpr2.iColumn;
        int iVar = iColumn;
        v = Sqlite3.sqlite3VdbeGetValue(pReprepare, iVar, (byte) 98);
        if (v != null && Sqlite3.sqlite3_value_type(v) == 3)
          zToken = Sqlite3.sqlite3_value_text(v);
        Sqlite3.sqlite3VdbeSetVarmask(pParse.pVdbe, iColumn);
      }
      else if (num2 == 94)
        zToken = pExpr2.u.zToken;
      if (!string.IsNullOrEmpty(zToken))
      {
        int num3 = 0;
        while (num3 < zToken.Length && (num1 = (int) zToken[num3]) != 0 && num1 != (int) aWc[0] && num1 != (int) aWc[1] && num1 != (int) aWc[2])
          ++num3;
        if (num3 != 0 && byte.MaxValue != (byte) zToken[num3 - 1])
        {
          pisComplete = num1 == (int) aWc[0] && num3 == zToken.Length - 1;
          Sqlite3.Expr expr = Sqlite3.sqlite3Expr(db, 94, zToken);
          if (expr != null)
            expr.u.zToken = expr.u.zToken.Substring(0, num3);
          ppPrefix = expr;
          if (num2 == 133)
          {
            Sqlite3.Vdbe pVdbe = pParse.pVdbe;
            Sqlite3.sqlite3VdbeSetVarmask(pVdbe, (int) pExpr2.iColumn);
            if (pisComplete && pExpr2.u.zToken.Length > 1)
            {
              int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
              Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr2, tempReg);
              Sqlite3.sqlite3VdbeChangeP3(pVdbe, Sqlite3.sqlite3VdbeCurrentAddr(pVdbe) - 1, 0);
              Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
            }
          }
        }
        else
          zToken = (string) null;
      }
      Sqlite3.sqlite3ValueFree(ref v);
      return zToken == null ? 0 : 1;
    }

    private static void transferJoinMarkings(Sqlite3.Expr pDerived, Sqlite3.Expr pBase)
    {
      pDerived.flags |= (ushort) ((uint) pBase.flags & 1U);
      pDerived.iRightJoinTable = pBase.iRightJoinTable;
    }

    private static void exprAnalyzeOrTerm(
      Sqlite3.SrcList pSrc,
      Sqlite3.WhereClause pWC,
      int idxTerm)
    {
      Sqlite3.Parse pParse = pWC.pParse;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.WhereTerm whereTerm1 = pWC.a[idxTerm];
      Sqlite3.Expr pExpr1 = whereTerm1.pExpr;
      Sqlite3.WhereMaskSet pMaskSet = pWC.pMaskSet;
      Sqlite3.WhereOrInfo whereOrInfo;
      whereTerm1.u.pOrInfo = whereOrInfo = new Sqlite3.WhereOrInfo();
      if (whereOrInfo == null)
        return;
      whereTerm1.wtFlags |= (byte) 16;
      Sqlite3.WhereClause wc1 = whereOrInfo.wc;
      Sqlite3.whereClauseInit(wc1, pWC.pParse, pMaskSet);
      Sqlite3.whereSplit(wc1, pExpr1, 68);
      Sqlite3.exprAnalyzeAll(pSrc, wc1);
      ulong maxValue = ulong.MaxValue;
      ulong num1 = ~pWC.vmask;
      for (int index1 = wc1.nTerm - 1; index1 >= 0 && maxValue != 0UL; --index1)
      {
        Sqlite3.WhereTerm whereTerm2 = wc1.a[index1];
        if (((int) whereTerm2.eOperator & (int) byte.MaxValue) == 0)
        {
          num1 = 0UL;
          Sqlite3.WhereAndInfo whereAndInfo = new Sqlite3.WhereAndInfo();
          if (whereAndInfo != null)
          {
            ulong num2 = 0;
            whereTerm2.u.pAndInfo = whereAndInfo;
            whereTerm2.wtFlags |= (byte) 32;
            whereTerm2.eOperator = (ushort) 512;
            Sqlite3.WhereClause wc2 = whereAndInfo.wc;
            Sqlite3.whereClauseInit(wc2, pWC.pParse, pMaskSet);
            Sqlite3.whereSplit(wc2, whereTerm2.pExpr, 69);
            Sqlite3.exprAnalyzeAll(pSrc, wc2);
            for (int index2 = 0; index2 < wc2.nTerm; ++index2)
            {
              Sqlite3.WhereTerm whereTerm3 = wc2.a[index2];
              if (Sqlite3.allowedOp((int) whereTerm3.pExpr.op))
                num2 |= Sqlite3.getMask(pMaskSet, whereTerm3.leftCursor);
            }
            maxValue &= num2;
          }
        }
        else if (((int) whereTerm2.wtFlags & 8) == 0)
        {
          ulong mask = Sqlite3.getMask(pMaskSet, whereTerm2.leftCursor);
          if (((int) whereTerm2.wtFlags & 2) != 0)
          {
            Sqlite3.WhereTerm whereTerm4 = wc1.a[whereTerm2.iParent];
            mask |= Sqlite3.getMask(pMaskSet, whereTerm4.leftCursor);
          }
          maxValue &= mask;
          if (whereTerm2.eOperator != (ushort) 2)
            num1 = 0UL;
          else
            num1 &= mask;
        }
      }
      whereOrInfo.indexable = maxValue;
      whereTerm1.eOperator = maxValue == 0UL ? (ushort) 0 : (ushort) 256;
      if (num1 == 0UL)
        return;
      int num3 = 0;
      int num4 = -1;
      int num5 = -1;
      for (int index = 0; index < 2 && num3 == 0; ++index)
      {
        int num6;
        for (num6 = wc1.nTerm - 1; num6 >= 0; --num6)
        {
          Sqlite3.WhereTerm whereTerm5 = wc1.a[wc1.nTerm - 1 - num6];
          whereTerm5.wtFlags &= (byte) 191;
          if (whereTerm5.leftCursor != num5)
          {
            if (((long) num1 & (long) Sqlite3.getMask(pMaskSet, whereTerm5.leftCursor)) == 0L)
            {
              Sqlite3.testcase<int>((int) whereTerm5.wtFlags & 8);
              Sqlite3.testcase<int>((int) whereTerm5.wtFlags & 2);
            }
            else
            {
              num4 = whereTerm5.u.leftColumn;
              num5 = whereTerm5.leftCursor;
              break;
            }
          }
        }
        if (num6 >= 0)
        {
          Sqlite3.testcase<bool>(index == 1);
          for (num3 = 1; num6 >= 0 && num3 != 0; --num6)
          {
            Sqlite3.WhereTerm whereTerm6 = wc1.a[wc1.nTerm - 1 - num6];
            if (whereTerm6.leftCursor != num5)
              whereTerm6.wtFlags &= (byte) 191;
            else if (whereTerm6.u.leftColumn != num4)
            {
              num3 = 0;
            }
            else
            {
              int num7 = (int) Sqlite3.sqlite3ExprAffinity(whereTerm6.pExpr.pRight);
              int num8 = (int) Sqlite3.sqlite3ExprAffinity(whereTerm6.pExpr.pLeft);
              if (num7 != 0 && num7 != num8)
                num3 = 0;
              else
                whereTerm6.wtFlags |= (byte) 64;
            }
          }
        }
        else
          break;
      }
      if (num3 == 0)
        return;
      Sqlite3.ExprList pList = (Sqlite3.ExprList) null;
      Sqlite3.Expr p = (Sqlite3.Expr) null;
      for (int index = wc1.nTerm - 1; index >= 0; --index)
      {
        Sqlite3.WhereTerm whereTerm7 = wc1.a[wc1.nTerm - 1 - index];
        if (((int) whereTerm7.wtFlags & 64) != 0)
        {
          Sqlite3.Expr pExpr2 = Sqlite3.sqlite3ExprDup(db, whereTerm7.pExpr.pRight, 0);
          pList = Sqlite3.sqlite3ExprListAppend(pWC.pParse, pList, pExpr2);
          p = whereTerm7.pExpr.pLeft;
        }
      }
      Sqlite3.Expr pLeft = Sqlite3.sqlite3ExprDup(db, p, 0);
      Sqlite3.Expr expr = Sqlite3.sqlite3PExpr(pParse, 72, pLeft, (Sqlite3.Expr) null, (Sqlite3.Token) null);
      if (expr != null)
      {
        Sqlite3.transferJoinMarkings(expr, pExpr1);
        expr.x.pList = pList;
        int idxTerm1 = Sqlite3.whereClauseInsert(pWC, expr, (byte) 3);
        Sqlite3.testcase<bool>(idxTerm1 == 0);
        Sqlite3.exprAnalyze(pSrc, pWC, idxTerm1);
        whereTerm1 = pWC.a[idxTerm];
        pWC.a[idxTerm1].iParent = idxTerm;
        whereTerm1.nChild = (byte) 1;
      }
      else
        Sqlite3.sqlite3ExprListDelete(db, ref pList);
      whereTerm1.eOperator = (ushort) 2048;
    }

    private static void exprAnalyze(Sqlite3.SrcList pSrc, Sqlite3.WhereClause pWC, int idxTerm)
    {
      ulong num1 = 0;
      Sqlite3.Expr ppPrefix = (Sqlite3.Expr) null;
      bool pisComplete = false;
      bool pnoCase = false;
      Sqlite3.Parse pParse = pWC.pParse;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.WhereTerm whereTerm1 = pWC.a[idxTerm];
      Sqlite3.WhereMaskSet pMaskSet = pWC.pMaskSet;
      Sqlite3.Expr pExpr1 = whereTerm1.pExpr;
      ulong num2 = Sqlite3.exprTableUsage(pMaskSet, pExpr1.pLeft);
      int op = (int) pExpr1.op;
      switch (op)
      {
        case 72:
          whereTerm1.prereqRight = !Sqlite3.ExprHasProperty(pExpr1, 2048) ? Sqlite3.exprListTableUsage(pMaskSet, pExpr1.x.pList) : Sqlite3.exprSelectTableUsage(pMaskSet, pExpr1.x.pSelect);
          break;
        case 73:
          whereTerm1.prereqRight = 0UL;
          break;
        default:
          whereTerm1.prereqRight = Sqlite3.exprTableUsage(pMaskSet, pExpr1.pRight);
          break;
      }
      ulong num3 = Sqlite3.exprTableUsage(pMaskSet, pExpr1);
      if (Sqlite3.ExprHasProperty(pExpr1, 1))
      {
        ulong mask = Sqlite3.getMask(pMaskSet, (int) pExpr1.iRightJoinTable);
        num3 |= mask;
        num1 = mask - 1UL;
      }
      whereTerm1.prereqAll = num3;
      whereTerm1.leftCursor = -1;
      whereTerm1.iParent = -1;
      whereTerm1.eOperator = (ushort) 0;
      if (Sqlite3.allowedOp(op) && ((long) whereTerm1.prereqRight & (long) num2) == 0L)
      {
        Sqlite3.Expr pLeft1 = pExpr1.pLeft;
        Sqlite3.Expr pRight = pExpr1.pRight;
        if (pLeft1.op == (byte) 152)
        {
          whereTerm1.leftCursor = pLeft1.iTable;
          whereTerm1.u.leftColumn = (int) pLeft1.iColumn;
          whereTerm1.eOperator = Sqlite3.operatorMask(op);
        }
        if (pRight != null && pRight.op == (byte) 152)
        {
          Sqlite3.Expr expr;
          Sqlite3.WhereTerm whereTerm2;
          if (whereTerm1.leftCursor >= 0)
          {
            expr = Sqlite3.sqlite3ExprDup(db, pExpr1, 0);
            int index = Sqlite3.whereClauseInsert(pWC, expr, (byte) 3);
            if (index == 0)
              return;
            whereTerm2 = pWC.a[index];
            whereTerm2.iParent = idxTerm;
            whereTerm1 = pWC.a[idxTerm];
            whereTerm1.nChild = (byte) 1;
            whereTerm1.wtFlags |= (byte) 8;
          }
          else
          {
            expr = pExpr1;
            whereTerm2 = whereTerm1;
          }
          Sqlite3.exprCommute(pParse, expr);
          Sqlite3.Expr pLeft2 = expr.pLeft;
          whereTerm2.leftCursor = pLeft2.iTable;
          whereTerm2.u.leftColumn = (int) pLeft2.iColumn;
          Sqlite3.testcase<bool>(((long) num2 | (long) num1) != (long) num2);
          whereTerm2.prereqRight = num2 | num1;
          whereTerm2.prereqAll = num3;
          whereTerm2.eOperator = Sqlite3.operatorMask((int) expr.op);
        }
      }
      else if (pExpr1.op == (byte) 71 && pWC.op == (byte) 69)
      {
        Sqlite3.ExprList pList = pExpr1.x.pList;
        byte[] numArray = new byte[2]
        {
          (byte) 80,
          (byte) 78
        };
        for (int index = 0; index < 2; ++index)
        {
          Sqlite3.Expr p = Sqlite3.sqlite3PExpr(pParse, (int) numArray[index], Sqlite3.sqlite3ExprDup(db, pExpr1.pLeft, 0), Sqlite3.sqlite3ExprDup(db, pList.a[index].pExpr, 0), (Sqlite3.Token) null);
          int idxTerm1 = Sqlite3.whereClauseInsert(pWC, p, (byte) 3);
          Sqlite3.testcase<bool>(idxTerm1 == 0);
          Sqlite3.exprAnalyze(pSrc, pWC, idxTerm1);
          whereTerm1 = pWC.a[idxTerm];
          pWC.a[idxTerm1].iParent = idxTerm;
        }
        whereTerm1.nChild = (byte) 2;
      }
      else if (pExpr1.op == (byte) 68)
      {
        Sqlite3.exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
        whereTerm1 = pWC.a[idxTerm];
      }
      if (pWC.op == (byte) 69 && Sqlite3.isLikeOrGlob(pParse, pExpr1, ref ppPrefix, ref pisComplete, ref pnoCase) != 0)
      {
        Sqlite3.Expr pExpr2 = pExpr1.x.pList.a[1].pExpr;
        Sqlite3.Expr pRight = Sqlite3.sqlite3ExprDup(db, ppPrefix, 0);
        int index = (int) pRight.u.zToken[Sqlite3.sqlite3Strlen30(pRight.u.zToken) - 1];
        if (pnoCase)
        {
          if (index == 64)
            pisComplete = false;
          index = Sqlite3.sqlite3UpperToLower[index];
        }
        pRight.u.zToken = pRight.u.zToken.Substring(0, Sqlite3.sqlite3Strlen30(pRight.u.zToken) - 1) + ((char) (index + 1)).ToString();
        Sqlite3.CollSeq collSeq = Sqlite3.sqlite3FindCollSeq(db, (byte) 1, pnoCase ? "NOCASE" : "BINARY", (byte) 0);
        Sqlite3.Expr p1 = Sqlite3.sqlite3PExpr(pParse, 80, Sqlite3.sqlite3ExprSetColl(Sqlite3.sqlite3ExprDup(db, pExpr2, 0), collSeq), ppPrefix, 0);
        int idxTerm2 = Sqlite3.whereClauseInsert(pWC, p1, (byte) 3);
        Sqlite3.testcase<bool>(idxTerm2 == 0);
        Sqlite3.exprAnalyze(pSrc, pWC, idxTerm2);
        Sqlite3.Expr p2 = Sqlite3.sqlite3PExpr(pParse, 79, Sqlite3.sqlite3ExprSetColl(Sqlite3.sqlite3ExprDup(db, pExpr2, 0), collSeq), pRight, (Sqlite3.Token) null);
        int idxTerm3 = Sqlite3.whereClauseInsert(pWC, p2, (byte) 3);
        Sqlite3.testcase<bool>(idxTerm3 == 0);
        Sqlite3.exprAnalyze(pSrc, pWC, idxTerm3);
        whereTerm1 = pWC.a[idxTerm];
        if (pisComplete)
        {
          pWC.a[idxTerm2].iParent = idxTerm;
          pWC.a[idxTerm3].iParent = idxTerm;
          whereTerm1.nChild = (byte) 2;
        }
      }
      whereTerm1.prereqRight |= num1;
    }

    private static bool referencesOtherTables(
      Sqlite3.ExprList pList,
      Sqlite3.WhereMaskSet pMaskSet,
      int iFirst,
      int iBase)
    {
      ulong num = ~Sqlite3.getMask(pMaskSet, iBase);
      while (iFirst < pList.nExpr)
      {
        if (((long) Sqlite3.exprTableUsage(pMaskSet, pList.a[iFirst++].pExpr) & (long) num) != 0L)
          return true;
      }
      return false;
    }

    private static bool isSortingIndex(
      Sqlite3.Parse pParse,
      Sqlite3.WhereMaskSet pMaskSet,
      Sqlite3.Index pIdx,
      int _base,
      Sqlite3.ExprList pOrderBy,
      int nEqCol,
      int wsFlags,
      ref int pbRev)
    {
      int num1 = 0;
      Sqlite3.sqlite3 db = pParse.db;
      int nExpr = pOrderBy.nExpr;
      int iFirst;
      int index;
      for (index = iFirst = 0; iFirst < nExpr && index <= pIdx.nColumn; ++index)
      {
        Sqlite3.ExprList_item exprListItem = pOrderBy.a[iFirst];
        Sqlite3.Expr pExpr = exprListItem.pExpr;
        if (pExpr.op == (byte) 152 && pExpr.iTable == _base)
        {
          Sqlite3.CollSeq collSeq = Sqlite3.sqlite3ExprCollSeq(pParse, pExpr) ?? db.pDfltColl;
          int num2;
          int num3;
          string zName;
          if (!string.IsNullOrEmpty(pIdx.zName) && index < pIdx.nColumn)
          {
            num2 = pIdx.aiColumn[index];
            if (num2 == pIdx.pTable.iPKey)
              num2 = -1;
            num3 = (int) pIdx.aSortOrder[index];
            zName = pIdx.azColl[index];
          }
          else
          {
            num2 = -1;
            num3 = 0;
            zName = collSeq.zName;
          }
          if ((int) pExpr.iColumn != num2 || !collSeq.zName.Equals(zName, StringComparison.InvariantCultureIgnoreCase))
          {
            if (index >= nEqCol)
            {
              if (index != pIdx.nColumn)
                return false;
              break;
            }
          }
          else
          {
            int num4 = num3 ^ (int) exprListItem.sortOrder;
            if (index > nEqCol)
            {
              if (num4 != num1)
                return false;
            }
            else
              num1 = num4;
            ++iFirst;
            if (num2 < 0 && !Sqlite3.referencesOtherTables(pOrderBy, pMaskSet, iFirst, _base))
              iFirst = nExpr;
          }
        }
        else
          break;
      }
      pbRev = num1 != 0 ? 1 : 0;
      return iFirst >= nExpr || pIdx.onError != (byte) 0 && index == pIdx.nColumn && (wsFlags & 524288) == 0 && !Sqlite3.referencesOtherTables(pOrderBy, pMaskSet, iFirst, _base);
    }

    private static double estLog(double N)
    {
      double num1 = 1.0;
      for (double num2 = 10.0; N > num2; num2 *= 10.0)
        ++num1;
      return num1;
    }

    private static void TRACE_IDX_INPUTS(Sqlite3.sqlite3_index_info p)
    {
    }

    private static void TRACE_IDX_OUTPUTS(Sqlite3.sqlite3_index_info p)
    {
    }

    private static void bestOrClauseIndex(
      Sqlite3.Parse pParse,
      Sqlite3.WhereClause pWC,
      Sqlite3.SrcList_item pSrc,
      ulong notReady,
      ulong notValid,
      Sqlite3.ExprList pOrderBy,
      Sqlite3.WhereCost pCost)
    {
      int iCursor = pSrc.iCursor;
      ulong mask = Sqlite3.getMask(pWC.pMaskSet, iCursor);
      Sqlite3.WhereTerm whereTerm1 = pWC.a[pWC.nTerm];
      if (pSrc.notIndexed != (byte) 0 || pSrc.pIndex != null)
        return;
      for (int index1 = 0; index1 < pWC.nTerm; ++index1)
      {
        Sqlite3.WhereTerm whereTerm2 = pWC.a[index1];
        if (whereTerm2.eOperator == (ushort) 256 && ((long) whereTerm2.prereqAll & ~(long) mask & (long) notReady) == 0L && ((long) whereTerm2.u.pOrInfo.indexable & (long) mask) != 0L)
        {
          Sqlite3.WhereClause wc1 = whereTerm2.u.pOrInfo.wc;
          Sqlite3.WhereTerm whereTerm3 = wc1.a[wc1.nTerm];
          int num1 = 268435456;
          double num2 = 0.0;
          double N = 0.0;
          ulong num3 = 0;
          for (int index2 = 0; index2 < wc1.nTerm; ++index2)
          {
            Sqlite3.WhereTerm whereTerm4 = wc1.a[index2];
            Sqlite3.WhereCost pCost1 = (Sqlite3.WhereCost) null;
            if (whereTerm4.eOperator == (ushort) 512)
            {
              Sqlite3.WhereClause wc2 = whereTerm4.u.pAndInfo.wc;
              Sqlite3.bestIndex(pParse, wc2, pSrc, notReady, notValid, (Sqlite3.ExprList) null, ref pCost1);
            }
            else if (whereTerm4.leftCursor == iCursor)
            {
              Sqlite3.WhereClause pWC1 = new Sqlite3.WhereClause();
              pWC1.pParse = pWC.pParse;
              pWC1.pMaskSet = pWC.pMaskSet;
              pWC1.op = (byte) 69;
              pWC1.a = new Sqlite3.WhereTerm[2];
              pWC1.a[0] = whereTerm4;
              pWC1.nTerm = 1;
              Sqlite3.bestIndex(pParse, pWC1, pSrc, notReady, notValid, (Sqlite3.ExprList) null, ref pCost1);
            }
            else
              continue;
            num2 += pCost1.rCost;
            N += pCost1.plan.nRow;
            num3 |= pCost1.used;
            if (num2 >= pCost.rCost)
              break;
          }
          if (pOrderBy != null)
            num2 += N * Sqlite3.estLog(N);
          if (num2 < pCost.rCost)
          {
            pCost.rCost = num2;
            pCost.used = num3;
            pCost.plan.nRow = N;
            pCost.plan.wsFlags = (uint) num1;
            pCost.plan.u.pTerm = whereTerm2;
          }
        }
      }
    }

    private static int termCanDriveIndex(
      Sqlite3.WhereTerm pTerm,
      Sqlite3.SrcList_item pSrc,
      ulong notReady)
    {
      if (pTerm.leftCursor != pSrc.iCursor || pTerm.eOperator != (ushort) 2 || ((long) pTerm.prereqRight & (long) notReady) != 0L)
        return 0;
      char affinity = pSrc.pTab.aCol[pTerm.u.leftColumn].affinity;
      return !Sqlite3.sqlite3IndexAffinityOk(pTerm.pExpr, affinity) ? 0 : 1;
    }

    private static void bestAutomaticIndex(
      Sqlite3.Parse pParse,
      Sqlite3.WhereClause pWC,
      Sqlite3.SrcList_item pSrc,
      ulong notReady,
      Sqlite3.WhereCost pCost)
    {
      if (pParse.nQueryLoop <= 1.0 || (pParse.db.flags & 134217728) == 0 || ((int) pCost.plan.wsFlags & 269430784) != 0 || pSrc.notIndexed != (byte) 0)
        return;
      double nRowEst = (double) pSrc.pTab.nRowEst;
      double num1 = Sqlite3.estLog(nRowEst);
      double num2 = 2.0 * num1 * (nRowEst / pParse.nQueryLoop + 1.0);
      if (num2 >= pCost.rCost)
        return;
      for (int index = 0; index < pWC.nTerm; ++index)
      {
        Sqlite3.WhereTerm pTerm = pWC.a[index];
        if (Sqlite3.termCanDriveIndex(pTerm, pSrc, notReady) != 0)
        {
          pCost.rCost = num2;
          pCost.plan.nRow = num1 + 1.0;
          pCost.plan.wsFlags = 536870912U;
          pCost.used = pTerm.prereqRight;
          break;
        }
      }
    }

    private static void constructAutomaticIndex(
      Sqlite3.Parse pParse,
      Sqlite3.WhereClause pWC,
      Sqlite3.SrcList_item pSrc,
      ulong notReady,
      Sqlite3.WhereLevel pLevel)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int num1 = ++pParse.nMem;
      int addr1 = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 26, num1);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, num1);
      int num2 = 0;
      Sqlite3.Table pTab = pSrc.pTab;
      ulong num3 = 0;
      for (int index = 0; index < pWC.nTerm; ++index)
      {
        Sqlite3.WhereTerm pTerm = pWC.a[index];
        if (Sqlite3.termCanDriveIndex(pTerm, pSrc, notReady) != 0)
        {
          int leftColumn = pTerm.u.leftColumn;
          ulong num4 = leftColumn >= 64 ? 9223372036854775808UL : (ulong) (1L << leftColumn);
          Sqlite3.testcase<bool>(leftColumn == 64);
          Sqlite3.testcase<bool>(leftColumn == 63);
          if (((long) num3 & (long) num4) == 0L)
          {
            ++num2;
            num3 |= num4;
          }
        }
      }
      pLevel.plan.nEq = (uint) num2;
      ulong num5 = pSrc.colUsed & (ulong) (~(long) num3 | long.MinValue);
      int num6 = pTab.nCol >= 63 ? 63 : pTab.nCol;
      Sqlite3.testcase<bool>(pTab.nCol == 63);
      Sqlite3.testcase<bool>(pTab.nCol == 62);
      for (int index = 0; index < num6; ++index)
      {
        if (((long) num5 & 1L << index) != 0L)
          ++num2;
      }
      if (((long) pSrc.colUsed & long.MinValue) != 0L)
        num2 += pTab.nCol - 64 + 1;
      pLevel.plan.wsFlags |= 8454146U;
      Sqlite3.Index pIdx = new Sqlite3.Index();
      pLevel.plan.u.pIdx = pIdx;
      pIdx.azColl = new string[num2 + 1];
      pIdx.aiColumn = new int[num2 + 1];
      pIdx.aSortOrder = new byte[num2 + 1];
      pIdx.zName = "auto-index";
      pIdx.nColumn = num2;
      pIdx.pTable = pTab;
      int index1 = 0;
      ulong num7 = 0;
      for (int index2 = 0; index2 < pWC.nTerm; ++index2)
      {
        Sqlite3.WhereTerm pTerm = pWC.a[index2];
        if (Sqlite3.termCanDriveIndex(pTerm, pSrc, notReady) != 0)
        {
          int leftColumn = pTerm.u.leftColumn;
          ulong num8 = leftColumn >= 64 ? 9223372036854775808UL : (ulong) (1L << leftColumn);
          if (((long) num7 & (long) num8) == 0L)
          {
            Sqlite3.Expr pExpr = pTerm.pExpr;
            num7 |= num8;
            pIdx.aiColumn[index1] = pTerm.u.leftColumn;
            Sqlite3.CollSeq collSeq = Sqlite3.sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pExpr.pRight);
            pIdx.azColl[index1] = Sqlite3.ALWAYS(collSeq != null) ? collSeq.zName : "BINARY";
            ++index1;
          }
        }
      }
      for (int index3 = 0; index3 < num6; ++index3)
      {
        if (((long) num5 & 1L << index3) != 0L)
        {
          pIdx.aiColumn[index1] = index3;
          pIdx.azColl[index1] = "BINARY";
          ++index1;
        }
      }
      if (((long) pSrc.colUsed & long.MinValue) != 0L)
      {
        for (int index4 = 63; index4 < pTab.nCol; ++index4)
        {
          pIdx.aiColumn[index1] = index4;
          pIdx.azColl[index1] = "BINARY";
          ++index1;
        }
      }
      Sqlite3.KeyInfo pP4 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
      Sqlite3.sqlite3VdbeAddOp4(pVdbe, 40, pLevel.iIdxCur, num2 + 1, 0, pP4, -16);
      Sqlite3.VdbeComment(pVdbe, "for %s", (object) pTab.zName);
      int addr2 = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 65, pLevel.iTabCur);
      int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
      Sqlite3.sqlite3GenerateIndexKey(pParse, pIdx, pLevel.iTabCur, tempReg, true);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 70, pLevel.iIdxCur, tempReg);
      Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 16);
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 67, pLevel.iTabCur, addr2 + 1);
      Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 3);
      Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr2);
      Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
      Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr1);
    }

    private static int whereRangeScanEst(
      Sqlite3.Parse pParse,
      Sqlite3.Index p,
      int nEq,
      Sqlite3.WhereTerm pLower,
      Sqlite3.WhereTerm pUpper,
      out int piEst)
    {
      int num = 0;
      Sqlite3.UNUSED_PARAMETER<Sqlite3.Parse>(pParse);
      Sqlite3.UNUSED_PARAMETER<Sqlite3.Index>(p);
      Sqlite3.UNUSED_PARAMETER<int>(nEq);
      piEst = 100;
      if (pLower != null && ((int) pLower.wtFlags & 0) == 0)
        piEst /= 4;
      if (pUpper == null)
        return num;
      piEst /= 4;
      return num;
    }

    private static void bestBtreeIndex(
      Sqlite3.Parse pParse,
      Sqlite3.WhereClause pWC,
      Sqlite3.SrcList_item pSrc,
      ulong notReady,
      ulong notValid,
      Sqlite3.ExprList pOrderBy,
      ref Sqlite3.WhereCost pCost)
    {
      int iCursor = pSrc.iCursor;
      int[] numArray = new int[2];
      int num1 = -1;
      if (pCost == null)
        pCost = new Sqlite3.WhereCost();
      else
        pCost.Clear();
      pCost.rCost = 1.15292150460685E+18;
      uint num2 = ((int) pSrc.jointype & 8) == 0 ? 131U : 3U;
      Sqlite3.Index index1;
      Sqlite3.Index pIdx;
      int num3;
      uint op;
      if (pSrc.pIndex != null)
      {
        pIdx = index1 = pSrc.pIndex;
        num3 = -12289;
        op = num2;
      }
      else
      {
        Sqlite3.Index index2 = new Sqlite3.Index();
        index2.aSortOrder = new byte[1];
        index2.azColl = new string[1];
        index2.azColl[0] = "";
        index2.nColumn = 1;
        index2.aiColumn = new int[1];
        index2.aiColumn[0] = num1;
        index2.aiRowEst = numArray;
        index2.onError = (byte) 5;
        index2.pTable = pSrc.pTab;
        numArray[0] = (int) pSrc.pTab.nRowEst;
        numArray[1] = 1;
        Sqlite3.Index pIndex = pSrc.pTab.pIndex;
        if (pSrc.notIndexed == (byte) 0)
          index2.pNext = pIndex;
        index1 = index2;
        num3 = -983041;
        op = 3U;
        pIdx = (Sqlite3.Index) null;
      }
      for (; index1 != null; pIdx = index1 = index1.pNext)
      {
        int[] aiRowEst = index1.aiRowEst;
        int pbRev = 0;
        int wsFlags = 0;
        ulong num4 = 0;
        int num5 = 0;
        int num6 = 1;
        int piEst = 100;
        int num7 = 0;
        int num8 = 0;
        int num9 = 0;
        int index3;
        for (index3 = 0; index3 < index1.nColumn; ++index3)
        {
          int iColumn = index1.aiColumn[index3];
          Sqlite3.WhereTerm term = Sqlite3.findTerm(pWC, iCursor, iColumn, notReady, op, pIdx);
          if (term != null)
          {
            wsFlags |= 69632;
            if (((int) term.eOperator & 1) != 0)
            {
              Sqlite3.Expr pExpr = term.pExpr;
              wsFlags |= 262144;
              if (Sqlite3.ExprHasProperty(pExpr, 2048))
              {
                num6 *= 25;
                num5 = 1;
              }
              else if (Sqlite3.ALWAYS(pExpr.x.pList != null) && pExpr.x.pList.nExpr != 0)
                num6 *= pExpr.x.pList.nExpr;
            }
            else if (((int) term.eOperator & 128) != 0)
              wsFlags |= 524288;
            num4 |= term.prereqRight;
          }
          else
            break;
        }
        if (index3 < index1.nColumn && index1.bUnordered == (byte) 0)
        {
          int iColumn = index1.aiColumn[index3];
          if (Sqlite3.findTerm(pWC, iCursor, iColumn, notReady, 60U, pIdx) != null)
          {
            Sqlite3.WhereTerm term1 = Sqlite3.findTerm(pWC, iCursor, iColumn, notReady, 24U, pIdx);
            Sqlite3.WhereTerm term2 = Sqlite3.findTerm(pWC, iCursor, iColumn, notReady, 36U, pIdx);
            Sqlite3.whereRangeScanEst(pParse, index1, index3, term2, term1, out piEst);
            if (term1 != null)
            {
              num7 = 1;
              wsFlags |= 1048576;
              num4 |= term1.prereqRight;
            }
            if (term2 != null)
            {
              ++num7;
              wsFlags |= 2097152;
              num4 |= term2.prereqRight;
            }
            wsFlags |= 139264;
          }
        }
        else if (index1.onError != (byte) 0)
        {
          Sqlite3.testcase<int>(wsFlags & 262144);
          Sqlite3.testcase<int>(wsFlags & 524288);
          if ((wsFlags & 786432) == 0)
            wsFlags |= 67108864;
        }
        if (pOrderBy != null)
        {
          if ((wsFlags & 262144) == 0 && index1.bUnordered == (byte) 0 && Sqlite3.isSortingIndex(pParse, pWC.pMaskSet, index1, iCursor, pOrderBy, index3, wsFlags, ref pbRev))
            wsFlags = wsFlags | 16916480 | (pbRev != 0 ? 33554432 : 0);
          else
            num8 = 1;
        }
        if (pIdx != null && wsFlags != 0)
        {
          ulong colUsed = pSrc.colUsed;
          for (int index4 = 0; index4 < pIdx.nColumn; ++index4)
          {
            int num10 = pIdx.aiColumn[index4];
            if (num10 < 63)
              colUsed &= (ulong) ~(1L << num10);
          }
          if (colUsed == 0UL)
            wsFlags |= 8388608;
          else
            num9 = 1;
        }
        double num11 = (double) (aiRowEst[index3] * num6);
        if (num5 != 0 && num11 * 2.0 > (double) aiRowEst[0])
        {
          num11 = (double) (aiRowEst[0] / 2);
          num6 = (int) (num11 / (double) aiRowEst[index3]);
        }
        double N = num11 * (double) piEst / 100.0;
        if (N < 1.0)
          N = 1.0;
        double num12;
        if ((wsFlags & 269430784) == 0)
        {
          num12 = (double) (aiRowEst[0] * 4);
        }
        else
        {
          double num13 = Sqlite3.estLog((double) aiRowEst[0]);
          double num14 = N;
          num12 = pIdx == null ? num14 + (double) num6 * num13 : (num9 == 0 ? num14 + (double) num6 * num13 : num14 + ((double) num6 + N) * num13);
        }
        if (num8 != 0)
          num12 += N * Sqlite3.estLog(N) * 3.0;
        if (N > 2.0 && num12 <= pCost.rCost)
        {
          int num15 = index3;
          int num16 = num7;
          ulong mask = Sqlite3.getMask(pWC.pMaskSet, iCursor);
          int index5 = 0;
          int nTerm = pWC.nTerm;
          while (N > 2.0 && nTerm != 0)
          {
            Sqlite3.WhereTerm whereTerm = pWC.a[index5];
            if (((int) whereTerm.wtFlags & 2) == 0 && ((long) whereTerm.prereqAll & (long) notValid) == (long) mask)
            {
              if (((int) whereTerm.eOperator & 131) != 0)
              {
                if (num15 != 0)
                  --num15;
                else
                  N /= 10.0;
              }
              else if (((int) whereTerm.eOperator & 60) != 0)
              {
                if (num16 != 0)
                  --num16;
                else
                  N /= 3.0;
              }
              else if (whereTerm.eOperator != (ushort) 2048)
                N /= 2.0;
            }
            --nTerm;
            ++index5;
          }
          if (N < 2.0)
            N = 2.0;
        }
        if ((pIdx == null || wsFlags != 0) && (num12 < pCost.rCost || num12 <= pCost.rCost && N < pCost.plan.nRow))
        {
          pCost.rCost = num12;
          pCost.used = num4;
          pCost.plan.nRow = N;
          pCost.plan.wsFlags = (uint) (wsFlags & num3);
          pCost.plan.nEq = (uint) index3;
          pCost.plan.u.pIdx = pIdx;
        }
        if (pSrc.pIndex == null)
        {
          num3 = -12289;
          op = num2;
        }
        else
          break;
      }
      if (pOrderBy == null && (pParse.db.flags & 16777216) != 0)
        pCost.plan.wsFlags |= 33554432U;
      Sqlite3.bestOrClauseIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);
      Sqlite3.bestAutomaticIndex(pParse, pWC, pSrc, notReady, pCost);
      pCost.plan.wsFlags |= op;
    }

    private static void bestIndex(
      Sqlite3.Parse pParse,
      Sqlite3.WhereClause pWC,
      Sqlite3.SrcList_item pSrc,
      ulong notReady,
      ulong notValid,
      Sqlite3.ExprList pOrderBy,
      ref Sqlite3.WhereCost pCost)
    {
      Sqlite3.bestBtreeIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, ref pCost);
    }

    private static void disableTerm(Sqlite3.WhereLevel pLevel, Sqlite3.WhereTerm pTerm)
    {
      if (pTerm == null || ((int) pTerm.wtFlags & 4) != 0 || pLevel.iLeftJoin != 0 && !Sqlite3.ExprHasProperty(pTerm.pExpr, 1))
        return;
      pTerm.wtFlags |= (byte) 4;
      if (pTerm.iParent < 0)
        return;
      Sqlite3.WhereTerm pTerm1 = pTerm.pWC.a[pTerm.iParent];
      if (--pTerm1.nChild != (byte) 0)
        return;
      Sqlite3.disableTerm(pLevel, pTerm1);
    }

    private static void codeApplyAffinity(Sqlite3.Parse pParse, int _base, int n, string zAff)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      for (; n > 0 && zAff[0] == 'b'; zAff = zAff.Substring(1))
      {
        --n;
        ++_base;
      }
      while (n > 1 && zAff[n - 1] == 'b')
        --n;
      if (n <= 0)
        return;
      Sqlite3.sqlite3VdbeAddOp2(pVdbe, 29, _base, n);
      Sqlite3.sqlite3VdbeChangeP4(pVdbe, -1, zAff, n);
      Sqlite3.sqlite3ExprCacheAffinityChange(pParse, _base, n);
    }

    private static int codeEqualityTerm(
      Sqlite3.Parse pParse,
      Sqlite3.WhereTerm pTerm,
      Sqlite3.WhereLevel pLevel,
      int iTarget)
    {
      Sqlite3.Expr pExpr = pTerm.pExpr;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int num;
      if (pExpr.op == (byte) 76)
        num = Sqlite3.sqlite3ExprCodeTarget(pParse, pExpr.pRight, iTarget);
      else if (pExpr.op == (byte) 73)
      {
        num = iTarget;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, num);
      }
      else
      {
        num = iTarget;
        int prNotFound = -1;
        int inIndex = Sqlite3.sqlite3FindInIndex(pParse, pExpr, ref prNotFound);
        int iTable = pExpr.iTable;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 65, iTable, 0);
        if (pLevel.u._in.nIn == 0)
          pLevel.addrNxt = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
        ++pLevel.u._in.nIn;
        if (pLevel.u._in.aInLoop == null)
          pLevel.u._in.aInLoop = new Sqlite3.InLoop[pLevel.u._in.nIn];
        else
          Array.Resize<Sqlite3.InLoop>(ref pLevel.u._in.aInLoop, pLevel.u._in.nIn);
        if (pLevel.u._in.aInLoop != null)
        {
          pLevel.u._in.aInLoop[pLevel.u._in.nIn - 1] = new Sqlite3.InLoop();
          Sqlite3.InLoop inLoop = pLevel.u._in.aInLoop[pLevel.u._in.nIn - 1];
          inLoop.iCur = iTable;
          inLoop.addrInTop = inIndex != 1 ? Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, iTable, 0, num) : Sqlite3.sqlite3VdbeAddOp2(pVdbe, 61, iTable, num);
          Sqlite3.sqlite3VdbeAddOp1(pVdbe, 73, num);
        }
        else
          pLevel.u._in.nIn = 0;
      }
      Sqlite3.disableTerm(pLevel, pTerm);
      return num;
    }

    private static int codeAllEqualityTerms(
      Sqlite3.Parse pParse,
      Sqlite3.WhereLevel pLevel,
      Sqlite3.WhereClause pWC,
      ulong notReady,
      int nExtraReg,
      out StringBuilder pzAff)
    {
      int nEq = (int) pLevel.plan.nEq;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      int iTabCur = pLevel.iTabCur;
      Sqlite3.Index pIdx = pLevel.plan.u.pIdx;
      int iReg = pParse.nMem + 1;
      int num = (int) ((long) pLevel.plan.nEq + (long) nExtraReg);
      pParse.nMem += num;
      StringBuilder stringBuilder = new StringBuilder(Sqlite3.sqlite3IndexAffinityStr(pVdbe, pIdx));
      for (int index = 0; index < nEq; ++index)
      {
        int iColumn = pIdx.aiColumn[index];
        Sqlite3.WhereTerm term = Sqlite3.findTerm(pWC, iTabCur, iColumn, notReady, pLevel.plan.wsFlags, pIdx);
        if (!Sqlite3.NEVER(term == null))
        {
          Sqlite3.testcase<bool>(((uint) term.wtFlags & 4U) > 0U);
          Sqlite3.testcase<int>((int) term.wtFlags & 2);
          int p1 = Sqlite3.codeEqualityTerm(pParse, term, pLevel, iReg + index);
          if (p1 != iReg + index)
          {
            if (num == 1)
            {
              Sqlite3.sqlite3ReleaseTempReg(pParse, iReg);
              iReg = p1;
            }
            else
              Sqlite3.sqlite3VdbeAddOp2(pVdbe, 15, p1, iReg + index);
          }
          Sqlite3.testcase<int>((int) term.eOperator & 128);
          Sqlite3.testcase<int>((int) term.eOperator & 1);
          if (((int) term.eOperator & 129) == 0)
          {
            Sqlite3.Expr pRight = term.pExpr.pRight;
            Sqlite3.sqlite3ExprCodeIsNullJump(pVdbe, pRight, iReg + index, pLevel.addrBrk);
            if (stringBuilder.Length > 0)
            {
              if (Sqlite3.sqlite3CompareAffinity(pRight, stringBuilder[index]) == 'b')
                stringBuilder[index] = 'b';
              if (Sqlite3.sqlite3ExprNeedsNoAffinityChange(pRight, stringBuilder[index]) != 0)
                stringBuilder[index] = 'b';
            }
          }
        }
        else
          break;
      }
      pzAff = stringBuilder;
      return iReg;
    }

    private static void explainAppendTerm(
      Sqlite3.StrAccum pStr,
      int iTerm,
      string zColumn,
      string zOp)
    {
      if (iTerm != 0)
        Sqlite3.sqlite3StrAccumAppend(pStr, " AND ", 5);
      Sqlite3.sqlite3StrAccumAppend(pStr, zColumn, -1);
      Sqlite3.sqlite3StrAccumAppend(pStr, zOp, 1);
      Sqlite3.sqlite3StrAccumAppend(pStr, "?", 1);
    }

    private static string explainIndexRange(
      Sqlite3.sqlite3 db,
      Sqlite3.WhereLevel pLevel,
      Sqlite3.Table pTab)
    {
      Sqlite3.WherePlan plan = pLevel.plan;
      Sqlite3.Index pIdx = plan.u.pIdx;
      uint nEq = plan.nEq;
      Sqlite3.Column[] aCol = pTab.aCol;
      int[] aiColumn = pIdx.aiColumn;
      Sqlite3.StrAccum strAccum = new Sqlite3.StrAccum(100);
      if (nEq == 0U && ((int) plan.wsFlags & 3145728) == 0)
        return (string) null;
      Sqlite3.sqlite3StrAccumInit(strAccum, (StringBuilder) null, 0, 1000000000);
      strAccum.db = db;
      Sqlite3.sqlite3StrAccumAppend(strAccum, " (", 2);
      int iTerm;
      for (iTerm = 0; (long) iTerm < (long) nEq; ++iTerm)
        Sqlite3.explainAppendTerm(strAccum, iTerm, aCol[aiColumn[iTerm]].zName, "=");
      int index = iTerm;
      if (((int) plan.wsFlags & 2097152) != 0)
        Sqlite3.explainAppendTerm(strAccum, iTerm++, aCol[aiColumn[index]].zName, ">");
      if (((int) plan.wsFlags & 1048576) != 0)
        Sqlite3.explainAppendTerm(strAccum, iTerm, aCol[aiColumn[index]].zName, "<");
      Sqlite3.sqlite3StrAccumAppend(strAccum, ")", 1);
      return Sqlite3.sqlite3StrAccumFinish(strAccum);
    }

    private static void explainOneScan(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.WhereLevel pLevel,
      int iLevel,
      int iFrom,
      ushort wctrlFlags)
    {
      if (pParse.explain != (byte) 2)
        return;
      uint wsFlags = pLevel.plan.wsFlags;
      Sqlite3.SrcList_item srcListItem = pTabList.a[(int) pLevel.iFrom];
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.sqlite3 db = pParse.db;
      StringBuilder pP4 = new StringBuilder(1000);
      int iSelectId = pParse.iSelectId;
      if (((int) wsFlags & 268435456) != 0 || ((int) wctrlFlags & 128) != 0)
        return;
      bool flag = pLevel.plan.nEq > 0U || ((int) wsFlags & 3145728) != 0 || ((uint) wctrlFlags & 3U) > 0U;
      pP4.Append(Sqlite3.sqlite3MPrintf(db, "%s", flag ? (object) "SEARCH" : (object) "SCAN"));
      if (srcListItem.pSelect != null)
        pP4.Append(Sqlite3.sqlite3MAppendf(db, (string) null, " SUBQUERY %d", (object) srcListItem.iSelectId));
      else
        pP4.Append(Sqlite3.sqlite3MAppendf(db, (string) null, " TABLE %s", (object) srcListItem.zName));
      if (srcListItem.zAlias != null)
        pP4.Append(Sqlite3.sqlite3MAppendf(db, (string) null, " AS %s", (object) srcListItem.zAlias));
      if (((int) wsFlags & 983040) != 0)
      {
        string pString = Sqlite3.explainIndexRange(db, pLevel, srcListItem.pTab);
        pP4.Append(Sqlite3.sqlite3MAppendf(db, (string) null, " USING %s%sINDEX%s%s%s", ((int) wsFlags & 536870912) != 0 ? (object) "AUTOMATIC " : (object) "", ((int) wsFlags & 8388608) != 0 ? (object) "COVERING " : (object) "", ((int) wsFlags & 536870912) != 0 ? (object) "" : (object) " ", ((int) wsFlags & 536870912) != 0 ? (object) "" : (object) pLevel.plan.u.pIdx.zName, (object) (pString ?? "")));
        Sqlite3.sqlite3DbFree(db, ref pString);
      }
      else if (((int) wsFlags & 12288) != 0)
      {
        pP4.Append(" USING INTEGER PRIMARY KEY");
        if (((int) wsFlags & 4096) != 0)
          pP4.Append(" (rowid=?)");
        else if (((int) wsFlags & 3145728) == 3145728)
          pP4.Append(" (rowid>? AND rowid<?)");
        else if (((int) wsFlags & 2097152) != 0)
          pP4.Append(" (rowid>?)");
        else if (((int) wsFlags & 1048576) != 0)
          pP4.Append(" (rowid<?)");
      }
      long num;
      if (((int) wctrlFlags & 3) != 0)
      {
        Sqlite3.testcase<int>((int) wctrlFlags & 1);
        num = 1L;
      }
      else
        num = (long) pLevel.plan.nRow;
      pP4.Append(Sqlite3.sqlite3MAppendf(db, (string) null, " (~%lld rows)", (object) num));
      Sqlite3.sqlite3VdbeAddOp4(pVdbe, 138, iSelectId, iLevel, iFrom, pP4, -1);
    }

    private static ulong codeOneLoopStart(
      Sqlite3.WhereInfo pWInfo,
      int iLevel,
      ushort wctrlFlags,
      ulong notReady)
    {
      int num1 = 0;
      Sqlite3.Parse pParse = pWInfo.pParse;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.WhereClause pWc = pWInfo.pWC;
      Sqlite3.WhereLevel pLevel = pWInfo.a[iLevel];
      Sqlite3.SrcList_item srcListItem = pWInfo.pTabList.a[(int) pLevel.iFrom];
      int iCursor = srcListItem.iCursor;
      int index1 = ((int) pLevel.plan.wsFlags & 33554432) != 0 ? 1 : 0;
      int num2 = ((int) pLevel.plan.wsFlags & 8388608) == 0 || ((int) wctrlFlags & 64) != 0 ? 0 : 1;
      int p2 = pLevel.addrBrk = pLevel.addrNxt = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      int num3 = pLevel.addrCont = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      if (pLevel.iFrom > (byte) 0 && ((int) srcListItem.jointype & 8) != 0)
      {
        pLevel.iLeftJoin = ++pParse.nMem;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, pLevel.iLeftJoin);
      }
      if (((int) pLevel.plan.wsFlags & 4096) != 0)
      {
        num1 = Sqlite3.sqlite3GetTempReg(pParse);
        Sqlite3.WhereTerm term = Sqlite3.findTerm(pWc, iCursor, -1, notReady, 3U, (Sqlite3.Index) null);
        Sqlite3.testcase<int>((int) term.wtFlags & 2);
        int num4 = Sqlite3.codeEqualityTerm(pParse, term, pLevel, num1);
        int addrNxt = pLevel.addrNxt;
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 21, num4, addrNxt);
        Sqlite3.sqlite3VdbeAddOp3(pVdbe, 52, iCursor, addrNxt, num4);
        Sqlite3.sqlite3ExprCacheStore(pParse, iCursor, -1, num4);
        pLevel.op = (byte) 137;
      }
      else if (((int) pLevel.plan.wsFlags & 8192) != 0)
      {
        int op = 137;
        int num5 = 0;
        Sqlite3.WhereTerm pTerm1 = Sqlite3.findTerm(pWc, iCursor, -1, notReady, 36U, (Sqlite3.Index) null);
        Sqlite3.WhereTerm pTerm2 = Sqlite3.findTerm(pWc, iCursor, -1, notReady, 24U, (Sqlite3.Index) null);
        if (index1 != 0)
        {
          Sqlite3.WhereTerm whereTerm = pTerm1;
          pTerm1 = pTerm2;
          pTerm2 = whereTerm;
        }
        if (pTerm1 != null)
        {
          int pReg = 0;
          byte[] numArray = new byte[4]
          {
            (byte) 47,
            (byte) 45,
            (byte) 44,
            (byte) 46
          };
          Sqlite3.testcase<int>((int) pTerm1.wtFlags & 2);
          Sqlite3.Expr pExpr = pTerm1.pExpr;
          int num6 = Sqlite3.sqlite3ExprCodeTemp(pParse, pExpr.pRight, ref pReg);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, (int) numArray[(int) pExpr.op - 77], iCursor, p2, num6);
          Sqlite3.sqlite3ExprCacheAffinityChange(pParse, num6, 1);
          Sqlite3.sqlite3ReleaseTempReg(pParse, pReg);
          Sqlite3.disableTerm(pLevel, pTerm1);
        }
        else
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, index1 != 0 ? 63 : 65, iCursor, p2);
        if (pTerm2 != null)
        {
          Sqlite3.Expr pExpr = pTerm2.pExpr;
          Sqlite3.testcase<int>((int) pTerm2.wtFlags & 2);
          num5 = ++pParse.nMem;
          Sqlite3.sqlite3ExprCode(pParse, pExpr.pRight, num5);
          op = pExpr.op == (byte) 79 || pExpr.op == (byte) 77 ? (index1 != 0 ? 78 : 80) : (index1 != 0 ? 79 : 77);
          Sqlite3.disableTerm(pLevel, pTerm2);
        }
        int num7 = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
        pLevel.op = index1 != 0 ? (byte) 66 : (byte) 67;
        pLevel.p1 = iCursor;
        pLevel.p2 = num7;
        if (pTerm1 == null && pTerm2 == null)
          pLevel.p5 = (byte) 1;
        if (op != 137)
        {
          int num8 = num1 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 61, iCursor, num8);
          Sqlite3.sqlite3ExprCacheStore(pParse, iCursor, -1, num8);
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, op, num5, p2, num8);
          Sqlite3.sqlite3VdbeChangeP5(pVdbe, (byte) 107);
        }
      }
      else if (((int) pLevel.plan.wsFlags & 196608) != 0)
      {
        byte[] numArray1 = new byte[8]
        {
          (byte) 0,
          (byte) 0,
          (byte) 65,
          (byte) 63,
          (byte) 47,
          (byte) 44,
          (byte) 46,
          (byte) 45
        };
        byte[] numArray2 = new byte[3]
        {
          (byte) 137,
          (byte) 92,
          (byte) 81
        };
        int nEq = (int) pLevel.plan.nEq;
        int num9 = 0;
        Sqlite3.WhereTerm B = (Sqlite3.WhereTerm) null;
        Sqlite3.WhereTerm A = (Sqlite3.WhereTerm) null;
        int nExtraReg = 0;
        StringBuilder pzAff = new StringBuilder("");
        Sqlite3.Index pIdx = pLevel.plan.u.pIdx;
        int iIdxCur = pLevel.iIdxCur;
        int iColumn = pIdx.aiColumn[nEq];
        if (((int) wctrlFlags & 1) != 0 && ((int) pLevel.plan.wsFlags & 16777216) != 0 && pIdx.nColumn > nEq)
        {
          num9 = 1;
          nExtraReg = 1;
        }
        if (((int) pLevel.plan.wsFlags & 1048576) != 0)
        {
          A = Sqlite3.findTerm(pWc, iCursor, iColumn, notReady, 24U, pIdx);
          nExtraReg = 1;
        }
        if (((int) pLevel.plan.wsFlags & 2097152) != 0)
        {
          B = Sqlite3.findTerm(pWc, iCursor, iColumn, notReady, 36U, pIdx);
          nExtraReg = 1;
        }
        int num10 = Sqlite3.codeAllEqualityTerms(pParse, pLevel, pWc, notReady, nExtraReg, out pzAff);
        StringBuilder pT = new StringBuilder(pzAff.ToString());
        int addrNxt = pLevel.addrNxt;
        if (nEq < pIdx.nColumn && index1 == (pIdx.aSortOrder[nEq] == (byte) 0 ? 1 : 0))
          Sqlite3.SWAP<Sqlite3.WhereTerm>(ref A, ref B);
        Sqlite3.testcase<bool>(B != null && ((uint) B.eOperator & 8U) > 0U);
        Sqlite3.testcase<bool>(B != null && ((uint) B.eOperator & 32U) > 0U);
        Sqlite3.testcase<bool>(A != null && ((uint) A.eOperator & 8U) > 0U);
        Sqlite3.testcase<bool>(A != null && ((uint) A.eOperator & 32U) > 0U);
        int num11 = B == null || ((int) B.eOperator & 40) != 0 ? 1 : 0;
        int num12 = A == null || ((int) A.eOperator & 40) != 0 ? 1 : 0;
        int num13 = B != null || nEq > 0 ? 1 : 0;
        int num14 = nEq;
        if (B != null)
        {
          Sqlite3.Expr pRight = B.pExpr.pRight;
          Sqlite3.sqlite3ExprCode(pParse, pRight, num10 + nEq);
          if (((int) B.wtFlags & 0) == 0)
            Sqlite3.sqlite3ExprCodeIsNullJump(pVdbe, pRight, num10 + nEq, addrNxt);
          if (pzAff.Length != 0)
          {
            if (Sqlite3.sqlite3CompareAffinity(pRight, pzAff[nEq]) == 'b')
              pzAff[nEq] = 'b';
            if (Sqlite3.sqlite3ExprNeedsNoAffinityChange(pRight, pzAff[nEq]) != 0)
              pzAff[nEq] = 'b';
          }
          ++num14;
          Sqlite3.testcase<int>((int) B.wtFlags & 2);
        }
        else if (num9 != 0)
        {
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, num10 + nEq);
          ++num14;
          num11 = 0;
          num13 = 1;
        }
        Sqlite3.codeApplyAffinity(pParse, num10, num14, pzAff.ToString());
        int op1 = (int) numArray1[(num13 << 2) + (num11 << 1) + index1];
        Sqlite3.testcase<bool>(op1 == 65);
        Sqlite3.testcase<bool>(op1 == 63);
        Sqlite3.testcase<bool>(op1 == 47);
        Sqlite3.testcase<bool>(op1 == 46);
        Sqlite3.testcase<bool>(op1 == 45);
        Sqlite3.testcase<bool>(op1 == 44);
        Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, op1, iIdxCur, addrNxt, num10, num14);
        int p4 = nEq;
        if (A != null)
        {
          Sqlite3.Expr pRight = A.pExpr.pRight;
          Sqlite3.sqlite3ExprCacheRemove(pParse, num10 + nEq, 1);
          Sqlite3.sqlite3ExprCode(pParse, pRight, num10 + nEq);
          if (((int) A.wtFlags & 0) == 0)
            Sqlite3.sqlite3ExprCodeIsNullJump(pVdbe, pRight, num10 + nEq, addrNxt);
          if (pT.Length > 0)
          {
            if (Sqlite3.sqlite3CompareAffinity(pRight, pT[nEq]) == 'b')
              pT[nEq] = 'b';
            if (Sqlite3.sqlite3ExprNeedsNoAffinityChange(pRight, pT[nEq]) != 0)
              pT[nEq] = 'b';
          }
          Sqlite3.codeApplyAffinity(pParse, num10, nEq + 1, pT.ToString());
          ++p4;
          Sqlite3.testcase<int>((int) A.wtFlags & 2);
        }
        Sqlite3.sqlite3DbFree<StringBuilder>(pParse.db, ref pzAff);
        Sqlite3.sqlite3DbFree<StringBuilder>(pParse.db, ref pT);
        pLevel.p2 = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
        int op2 = (int) numArray2[(A != null || nEq != 0 ? 1 : 0) * (1 + index1)];
        Sqlite3.testcase<bool>(op2 == 137);
        Sqlite3.testcase<bool>(op2 == 92);
        Sqlite3.testcase<bool>(op2 == 81);
        if (op2 != 137)
        {
          Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, op2, iIdxCur, addrNxt, num10, p4);
          Sqlite3.sqlite3VdbeChangeP5(pVdbe, num12 != index1 ? (byte) 1 : (byte) 0);
        }
        int tempReg = Sqlite3.sqlite3GetTempReg(pParse);
        Sqlite3.testcase<uint>(pLevel.plan.wsFlags & 2097152U);
        Sqlite3.testcase<uint>(pLevel.plan.wsFlags & 1048576U);
        if (((int) pLevel.plan.wsFlags & 3145728) != 0)
        {
          Sqlite3.sqlite3VdbeAddOp3(pVdbe, 28, iIdxCur, nEq, tempReg);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 73, tempReg, num3);
        }
        Sqlite3.sqlite3ReleaseTempReg(pParse, tempReg);
        Sqlite3.disableTerm(pLevel, B);
        Sqlite3.disableTerm(pLevel, A);
        if (num2 == 0)
        {
          int num15 = num1 = Sqlite3.sqlite3GetTempReg(pParse);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 72, iIdxCur, num15);
          Sqlite3.sqlite3ExprCacheStore(pParse, iCursor, -1, num15);
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 48, iCursor, num15);
        }
        pLevel.op = ((int) pLevel.plan.wsFlags & 67108864) == 0 ? (index1 == 0 ? (byte) 67 : (byte) 66) : (byte) 137;
        pLevel.p1 = iIdxCur;
      }
      else if (((int) pLevel.plan.wsFlags & 268435456) != 0)
      {
        int num16 = ++pParse.nMem;
        int num17 = 0;
        int iReg = 0;
        int num18 = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
        int num19 = 0;
        Sqlite3.WhereTerm pTerm = pLevel.plan.u.pTerm;
        Sqlite3.WhereClause wc = pTerm.u.pOrInfo.wc;
        pLevel.op = (byte) 3;
        pLevel.p1 = num16;
        Sqlite3.SrcList pT;
        if (pWInfo.nLevel > 1)
        {
          int num20 = pWInfo.nLevel - iLevel - 1;
          pT = new Sqlite3.SrcList()
          {
            a = new Sqlite3.SrcList_item[num20 + 1],
            nAlloc = (short) (num20 + 1)
          };
          pT.nSrc = pT.nAlloc;
          pT.a[0] = srcListItem;
          Sqlite3.SrcList_item[] a = pWInfo.pTabList.a;
          for (int index2 = 1; index2 <= num20; ++index2)
            pT.a[index2] = a[(int) pWInfo.a[iLevel + index2].iFrom];
        }
        else
          pT = pWInfo.pTabList;
        if (((int) wctrlFlags & 8) == 0)
        {
          num17 = ++pParse.nMem;
          iReg = ++pParse.nMem;
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, 10, 0, num17);
        }
        int addr = Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 0, num16);
        for (int index3 = 0; index3 < wc.nTerm; ++index3)
        {
          Sqlite3.WhereTerm whereTerm = wc.a[index3];
          if (whereTerm.leftCursor == iCursor || whereTerm.eOperator == (ushort) 512)
          {
            Sqlite3.ExprList ppOrderBy = (Sqlite3.ExprList) null;
            Sqlite3.WhereInfo pWInfo1 = Sqlite3.sqlite3WhereBegin(pParse, pT, whereTerm.pExpr, ref ppOrderBy, (ushort) 240);
            if (pWInfo1 != null)
            {
              Sqlite3.explainOneScan(pParse, pT, pWInfo1.a[0], iLevel, (int) pLevel.iFrom, (ushort) 0);
              if (((int) wctrlFlags & 8) == 0)
              {
                int p4 = index3 == wc.nTerm - 1 ? -1 : index3;
                int column = Sqlite3.sqlite3ExprCodeGetColumn(pParse, srcListItem.pTab, -1, iCursor, iReg);
                Sqlite3.sqlite3VdbeAddOp4Int(pVdbe, 107, num17, Sqlite3.sqlite3VdbeCurrentAddr(pVdbe) + 2, column, p4);
              }
              Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, num16, num18);
              if (pWInfo1.untestedTerms != (byte) 0)
                num19 = 1;
              Sqlite3.sqlite3WhereEnd(pWInfo1);
            }
          }
        }
        Sqlite3.sqlite3VdbeChangeP1(pVdbe, addr, Sqlite3.sqlite3VdbeCurrentAddr(pVdbe));
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, pLevel.addrBrk);
        Sqlite3.sqlite3VdbeResolveLabel(pVdbe, num18);
        if (pWInfo.nLevel > 1)
          Sqlite3.sqlite3DbFree<Sqlite3.SrcList>(pParse.db, ref pT);
        if (num19 == 0)
          Sqlite3.disableTerm(pLevel, pTerm);
      }
      else
      {
        byte[] numArray3 = new byte[2]
        {
          (byte) 67,
          (byte) 66
        };
        byte[] numArray4 = new byte[2]
        {
          (byte) 65,
          (byte) 63
        };
        pLevel.op = numArray3[index1];
        pLevel.p1 = iCursor;
        pLevel.p2 = 1 + Sqlite3.sqlite3VdbeAddOp2(pVdbe, (int) numArray4[index1], iCursor, p2);
        pLevel.p5 = (byte) 1;
      }
      notReady &= ~Sqlite3.getMask(pWc.pMaskSet, iCursor);
      for (int nTerm = pWc.nTerm; nTerm > 0; --nTerm)
      {
        Sqlite3.WhereTerm whereTerm = pWc.a[pWc.nTerm - nTerm];
        Sqlite3.testcase<int>((int) whereTerm.wtFlags & 2);
        Sqlite3.testcase<int>((int) whereTerm.wtFlags & 4);
        if (((int) whereTerm.wtFlags & 6) == 0)
        {
          if (((long) whereTerm.prereqAll & (long) notReady) != 0L)
          {
            Sqlite3.testcase<bool>(pWInfo.untestedTerms == (byte) 0 && ((uint) pWInfo.wctrlFlags & 128U) > 0U);
            pWInfo.untestedTerms = (byte) 1;
          }
          else
          {
            Sqlite3.Expr pExpr = whereTerm.pExpr;
            if (pLevel.iLeftJoin == 0 || ((int) pExpr.flags & 1) == 1)
            {
              Sqlite3.sqlite3ExprIfFalse(pParse, pExpr, num3, 8);
              whereTerm.wtFlags |= (byte) 4;
            }
          }
        }
      }
      if (pLevel.iLeftJoin != 0)
      {
        pLevel.addrFirst = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
        Sqlite3.sqlite3VdbeAddOp2(pVdbe, 7, 1, pLevel.iLeftJoin);
        Sqlite3.sqlite3ExprCacheClear(pParse);
        for (int index4 = 0; index4 < pWc.nTerm; ++index4)
        {
          Sqlite3.WhereTerm whereTerm = pWc.a[index4];
          Sqlite3.testcase<int>((int) whereTerm.wtFlags & 2);
          Sqlite3.testcase<int>((int) whereTerm.wtFlags & 4);
          if (((int) whereTerm.wtFlags & 6) == 0 && ((long) whereTerm.prereqAll & (long) notReady) == 0L)
          {
            Sqlite3.sqlite3ExprIfFalse(pParse, whereTerm.pExpr, num3, 8);
            whereTerm.wtFlags |= (byte) 4;
          }
        }
      }
      Sqlite3.sqlite3ReleaseTempReg(pParse, num1);
      return notReady;
    }

    private static void whereInfoFree(Sqlite3.sqlite3 db, Sqlite3.WhereInfo pWInfo)
    {
      if (!Sqlite3.ALWAYS(pWInfo != null))
        return;
      for (int index = 0; index < pWInfo.nLevel; ++index)
      {
        Sqlite3.sqlite3_index_info pT = pWInfo.a[index] != null ? pWInfo.a[index].pIdxInfo : (Sqlite3.sqlite3_index_info) null;
        if (pT != null)
        {
          int needToFreeIdxStr = pT.needToFreeIdxStr;
          Sqlite3.sqlite3DbFree<Sqlite3.sqlite3_index_info>(db, ref pT);
        }
        if (pWInfo.a[index] != null && ((int) pWInfo.a[index].plan.wsFlags & 536870912) != 0)
        {
          Sqlite3.Index pIdx = pWInfo.a[index].plan.u.pIdx;
          if (pIdx != null)
          {
            Sqlite3.sqlite3DbFree(db, ref pIdx.zColAff);
            Sqlite3.sqlite3DbFree<Sqlite3.Index>(db, ref pIdx);
          }
        }
      }
      Sqlite3.whereClauseClear(pWInfo.pWC);
      Sqlite3.sqlite3DbFree<Sqlite3.WhereInfo>(db, ref pWInfo);
    }

    private static Sqlite3.WhereInfo sqlite3WhereBegin(
      Sqlite3.Parse pParse,
      Sqlite3.SrcList pTabList,
      Sqlite3.Expr pWhere,
      ref Sqlite3.ExprList ppOrderBy,
      ushort wctrlFlags)
    {
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.WhereClause whereClause = new Sqlite3.WhereClause();
      Sqlite3.testcase<bool>(pTabList.nSrc == (short) 64);
      if (pTabList.nSrc > (short) 64)
      {
        Sqlite3.sqlite3ErrorMsg(pParse, "at most %d tables in a join", (object) 64);
        return (Sqlite3.WhereInfo) null;
      }
      int num1 = ((int) wctrlFlags & 128) != 0 ? 1 : (int) pTabList.nSrc;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.WhereInfo pWInfo = new Sqlite3.WhereInfo();
      pWInfo.a = new Sqlite3.WhereLevel[(int) pTabList.nSrc];
      for (int index = 0; index < pWInfo.a.Length; ++index)
        pWInfo.a[index] = new Sqlite3.WhereLevel();
      pWInfo.nLevel = num1;
      pWInfo.pParse = pParse;
      pWInfo.pTabList = pTabList;
      pWInfo.iBreak = Sqlite3.sqlite3VdbeMakeLabel(pVdbe);
      Sqlite3.WhereClause pWC;
      pWInfo.pWC = pWC = new Sqlite3.WhereClause();
      pWInfo.wctrlFlags = wctrlFlags;
      pWInfo.savedNQueryLoop = pParse.nQueryLoop;
      Sqlite3.WhereMaskSet pMaskSet = new Sqlite3.WhereMaskSet();
      Sqlite3.whereClauseInit(pWC, pParse, pMaskSet);
      Sqlite3.sqlite3ExprCodeConstants(pParse, pWhere);
      Sqlite3.whereSplit(pWC, pWhere, 69);
      if (pWhere != null && (num1 == 0 || Sqlite3.sqlite3ExprIsConstantNotJoin(pWhere) != 0))
      {
        Sqlite3.sqlite3ExprIfFalse(pParse, pWhere, pWInfo.iBreak, 8);
        pWhere = (Sqlite3.Expr) null;
      }
      for (int index = 0; index < (int) pTabList.nSrc; ++index)
        Sqlite3.createMask(pMaskSet, pTabList.a[index].iCursor);
      Sqlite3.exprAnalyzeAll(pTabList, pWC);
      ulong maxValue1 = ulong.MaxValue;
      int num2 = -1;
      int num3;
      for (int index1 = num3 = 0; index1 < num1; ++index1)
      {
        Sqlite3.WhereLevel whereLevel = pWInfo.a[index1];
        int index2 = -1;
        Sqlite3.WhereCost whereCost = new Sqlite3.WhereCost();
        whereCost.rCost = 1.15292150460685E+18;
        int num4 = 0;
        ulong num5 = 0;
        for (int index3 = num3 < num1 - 1 ? 1 : 0; index3 >= 0 && index2 < 0; --index3)
        {
          for (int index4 = num3; index4 < num1; ++index4)
          {
            Sqlite3.SrcList_item pSrc = pTabList.a[index4];
            Sqlite3.WhereCost pCost = new Sqlite3.WhereCost();
            int num6 = ((int) pSrc.jointype & 10) != 0 ? 1 : 0;
            if (index4 == num3 || num6 == 0)
            {
              ulong mask = Sqlite3.getMask(pMaskSet, pSrc.iCursor);
              if (((long) mask & (long) maxValue1) == 0L)
              {
                if (index4 == num3)
                  ++num3;
              }
              else
              {
                ulong notReady = index3 != 0 ? mask : maxValue1;
                Sqlite3.ExprList pOrderBy = index1 != 0 || ppOrderBy == null ? (Sqlite3.ExprList) null : ppOrderBy;
                if (pSrc.pIndex == null)
                  ++num4;
                Sqlite3.bestBtreeIndex(pParse, pWC, pSrc, notReady, maxValue1, pOrderBy, ref pCost);
                if (index3 != 0 && ((int) pCost.plan.wsFlags & 269430784) == 0)
                  num5 |= mask;
                if (((long) pCost.used & (long) maxValue1) == 0L && (index2 < 0 || ((long) num5 & (long) mask) != 0L || ((int) whereCost.plan.wsFlags & 269430784) == 0 || ((int) pCost.plan.wsFlags & 269430784) != 0) && (num4 == 0 || pSrc.pIndex == null || Sqlite3.NEVER((pCost.plan.wsFlags & 269430784U) > 0U)) && (index2 < 0 || pCost.rCost < whereCost.rCost || pCost.rCost <= whereCost.rCost && pCost.plan.nRow < whereCost.plan.nRow))
                {
                  whereCost = pCost;
                  index2 = index4;
                }
                if (num6 != 0)
                  break;
              }
            }
            else
              break;
          }
        }
        if (((int) whereCost.plan.wsFlags & 16777216) != 0)
          ppOrderBy = (Sqlite3.ExprList) null;
        num2 = (int) ((long) num2 & (long) whereCost.plan.wsFlags);
        whereLevel.plan = whereCost.plan;
        Sqlite3.testcase<uint>(whereCost.plan.wsFlags & 983040U);
        Sqlite3.testcase<uint>(whereCost.plan.wsFlags & 536870912U);
        whereLevel.iIdxCur = ((int) whereCost.plan.wsFlags & 537853952) == 0 ? -1 : pParse.nTab++;
        maxValue1 &= ~Sqlite3.getMask(pMaskSet, pTabList.a[index2].iCursor);
        whereLevel.iFrom = (byte) index2;
        if (whereCost.plan.nRow >= 1.0)
          pParse.nQueryLoop *= whereCost.plan.nRow;
        Sqlite3.Index pIndex = pTabList.a[index2].pIndex;
        if (pIndex != null && ((int) whereCost.plan.wsFlags & 983040) == 0)
        {
          Sqlite3.sqlite3ErrorMsg(pParse, "cannot use index: %s", (object) pIndex.zName);
          goto label_60;
        }
      }
      if (pParse.nErr == 0)
      {
        if ((num2 & 67108864) != 0 && ppOrderBy != null)
          ppOrderBy = (Sqlite3.ExprList) null;
        if (((int) wctrlFlags & 4) != 0 && (num2 & 67108864) != 0)
        {
          pWInfo.okOnePass = (byte) 1;
          pWInfo.a[0].plan.wsFlags = (uint) ((ulong) pWInfo.a[0].plan.wsFlags & 18446744073701163007UL);
        }
        Sqlite3.sqlite3CodeVerifySchema(pParse, -1);
        ulong maxValue2 = ulong.MaxValue;
        pWInfo.nRowOut = 1.0;
        for (int index5 = 0; index5 < num1; ++index5)
        {
          Sqlite3.WhereLevel pLevel = pWInfo.a[index5];
          Sqlite3.SrcList_item pSrc = pTabList.a[(int) pLevel.iFrom];
          Sqlite3.Table pTab = pSrc.pTab;
          pLevel.iTabCur = pSrc.iCursor;
          pWInfo.nRowOut *= pLevel.plan.nRow;
          int index6 = Sqlite3.sqlite3SchemaToIndex(db, pTab.pSchema);
          if (((int) pTab.tabFlags & 2) == 0 && pTab.pSelect == null)
          {
            if (((int) pLevel.plan.wsFlags & 8388608) == 0 && ((int) wctrlFlags & 16) == 0)
            {
              int opcode = pWInfo.okOnePass != (byte) 0 ? 39 : 38;
              Sqlite3.sqlite3OpenTable(pParse, pSrc.iCursor, index6, pTab, opcode);
              Sqlite3.testcase<bool>(pTab.nCol == 63);
              Sqlite3.testcase<bool>(pTab.nCol == 64);
              if (pWInfo.okOnePass == (byte) 0 && pTab.nCol < 64)
              {
                ulong colUsed = pSrc.colUsed;
                int i32n = 0;
                while (colUsed != 0UL)
                {
                  colUsed >>= 1;
                  ++i32n;
                }
                Sqlite3.sqlite3VdbeChangeP4(pVdbe, Sqlite3.sqlite3VdbeCurrentAddr(pVdbe) - 1, i32n, -14);
              }
            }
            else
              Sqlite3.sqlite3TableLock(pParse, index6, pTab.tnum, (byte) 0, pTab.zName);
          }
          if (((int) pLevel.plan.wsFlags & 536870912) != 0)
            Sqlite3.constructAutomaticIndex(pParse, pWC, pSrc, maxValue2, pLevel);
          else if (((int) pLevel.plan.wsFlags & 983040) != 0)
          {
            Sqlite3.Index pIdx = pLevel.plan.u.pIdx;
            Sqlite3.KeyInfo pP4 = Sqlite3.sqlite3IndexKeyinfo(pParse, pIdx);
            int iIdxCur = pLevel.iIdxCur;
            Sqlite3.sqlite3VdbeAddOp4(pVdbe, 38, iIdxCur, pIdx.tnum, index6, pP4, -16);
          }
          Sqlite3.sqlite3CodeVerifySchema(pParse, index6);
          maxValue2 &= ~Sqlite3.getMask(pWC.pMaskSet, pSrc.iCursor);
        }
        pWInfo.iTop = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
        ulong notReady = ulong.MaxValue;
        for (int iLevel = 0; iLevel < num1; ++iLevel)
        {
          Sqlite3.WhereLevel pLevel = pWInfo.a[iLevel];
          Sqlite3.explainOneScan(pParse, pTabList, pLevel, iLevel, (int) pLevel.iFrom, wctrlFlags);
          notReady = Sqlite3.codeOneLoopStart(pWInfo, iLevel, wctrlFlags, notReady);
          pWInfo.iContinue = pLevel.addrCont;
        }
        return pWInfo;
      }
label_60:
      if (pWInfo != null)
      {
        pParse.nQueryLoop = pWInfo.savedNQueryLoop;
        Sqlite3.whereInfoFree(db, pWInfo);
      }
      return (Sqlite3.WhereInfo) null;
    }

    private static void sqlite3WhereEnd(Sqlite3.WhereInfo pWInfo)
    {
      Sqlite3.Parse pParse = pWInfo.pParse;
      Sqlite3.Vdbe pVdbe = pParse.pVdbe;
      Sqlite3.SrcList pTabList = pWInfo.pTabList;
      Sqlite3.sqlite3 db = pParse.db;
      Sqlite3.sqlite3ExprCacheClear(pParse);
      for (int index = pWInfo.nLevel - 1; index >= 0; --index)
      {
        Sqlite3.WhereLevel whereLevel = pWInfo.a[index];
        Sqlite3.sqlite3VdbeResolveLabel(pVdbe, whereLevel.addrCont);
        if (whereLevel.op != (byte) 137)
        {
          Sqlite3.sqlite3VdbeAddOp2(pVdbe, (int) whereLevel.op, whereLevel.p1, whereLevel.p2);
          Sqlite3.sqlite3VdbeChangeP5(pVdbe, whereLevel.p5);
        }
        if (((int) whereLevel.plan.wsFlags & 987136) != 0 && whereLevel.u._in.nIn > 0)
        {
          Sqlite3.sqlite3VdbeResolveLabel(pVdbe, whereLevel.addrNxt);
          for (int nIn = whereLevel.u._in.nIn; nIn > 0; --nIn)
          {
            Sqlite3.InLoop inLoop = whereLevel.u._in.aInLoop[nIn - 1];
            Sqlite3.sqlite3VdbeJumpHere(pVdbe, inLoop.addrInTop + 1);
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 67, inLoop.iCur, inLoop.addrInTop);
            Sqlite3.sqlite3VdbeJumpHere(pVdbe, inLoop.addrInTop - 1);
          }
          Sqlite3.sqlite3DbFree<Sqlite3.InLoop[]>(db, ref whereLevel.u._in.aInLoop);
        }
        Sqlite3.sqlite3VdbeResolveLabel(pVdbe, whereLevel.addrBrk);
        if (whereLevel.iLeftJoin != 0)
        {
          int addr = Sqlite3.sqlite3VdbeAddOp1(pVdbe, 113, whereLevel.iLeftJoin);
          if (((int) whereLevel.plan.wsFlags & 8388608) == 0)
            Sqlite3.sqlite3VdbeAddOp1(pVdbe, 62, pTabList.a[index].iCursor);
          if (whereLevel.iIdxCur >= 0)
            Sqlite3.sqlite3VdbeAddOp1(pVdbe, 62, whereLevel.iIdxCur);
          if (whereLevel.op == (byte) 3)
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 2, whereLevel.p1, whereLevel.addrFirst);
          else
            Sqlite3.sqlite3VdbeAddOp2(pVdbe, 1, 0, whereLevel.addrFirst);
          Sqlite3.sqlite3VdbeJumpHere(pVdbe, addr);
        }
      }
      Sqlite3.sqlite3VdbeResolveLabel(pVdbe, pWInfo.iBreak);
      for (int index1 = 0; index1 < pWInfo.nLevel; ++index1)
      {
        Sqlite3.WhereLevel whereLevel = pWInfo.a[index1];
        Sqlite3.SrcList_item srcListItem = pTabList.a[(int) whereLevel.iFrom];
        Sqlite3.Table pTab = srcListItem.pTab;
        if (((int) pTab.tabFlags & 2) == 0 && pTab.pSelect == null && ((int) pWInfo.wctrlFlags & 32) == 0)
        {
          uint wsFlags = whereLevel.plan.wsFlags;
          if (pWInfo.okOnePass == (byte) 0 && ((int) wsFlags & 8388608) == 0)
            Sqlite3.sqlite3VdbeAddOp1(pVdbe, 43, srcListItem.iCursor);
          if (((int) wsFlags & 983040) != 0 && ((int) wsFlags & 536870912) == 0)
            Sqlite3.sqlite3VdbeAddOp1(pVdbe, 43, whereLevel.iIdxCur);
        }
        if (((int) whereLevel.plan.wsFlags & 983040) != 0)
        {
          Sqlite3.Index pIdx = whereLevel.plan.u.pIdx;
          int num = Sqlite3.sqlite3VdbeCurrentAddr(pVdbe);
          for (int iTop = pWInfo.iTop; iTop < num; ++iTop)
          {
            Sqlite3.VdbeOp op = Sqlite3.sqlite3VdbeGetOp(pVdbe, iTop);
            if (op.p1 == whereLevel.iTabCur)
            {
              if (op.opcode == (byte) 28)
              {
                for (int index2 = 0; index2 < pIdx.nColumn; ++index2)
                {
                  if (op.p2 == pIdx.aiColumn[index2])
                  {
                    op.p2 = index2;
                    op.p1 = whereLevel.iIdxCur;
                    break;
                  }
                }
              }
              else if (op.opcode == (byte) 61)
              {
                op.p1 = whereLevel.iIdxCur;
                op.opcode = (byte) 72;
              }
            }
          }
        }
      }
      pParse.nQueryLoop = pWInfo.savedNQueryLoop;
      Sqlite3.whereInfoFree(db, pWInfo);
    }

    private static int atoi(byte[] inStr) => Sqlite3.atoi(Encoding.UTF8.GetString(inStr, 0, inStr.Length));

    private static int atoi(string inStr)
    {
      int num = 0;
      while (num < inStr.Length && (inStr[num] >= '0' || inStr[num] <= '9' || inStr[num] == '-'))
        ++num;
      int result = 0;
      return !int.TryParse(inStr.Substring(0, num), out result) ? 0 : result;
    }

    private static void fprintf(TextWriter tw, string zFormat, params object[] ap) => tw.Write(Sqlite3.sqlite3_mprintf(zFormat, ap));

    private static void printf(string zFormat, params object[] ap) => Console.Out.Write(Sqlite3.sqlite3_mprintf(zFormat, ap));

    private static int memcmp(byte[] bA, byte[] bB, int Limit)
    {
      if (bA.Length < Limit)
        return bA.Length >= bB.Length ? 1 : -1;
      if (bB.Length < Limit)
        return 1;
      for (int index = 0; index < Limit; ++index)
      {
        if ((int) bA[index] != (int) bB[index])
          return (int) bA[index] >= (int) bB[index] ? 1 : -1;
      }
      return 0;
    }

    private static int memcmp(string A, byte[] bB, int Limit)
    {
      if (A.Length < Limit)
        return A.Length >= bB.Length ? 1 : -1;
      if (bB.Length < Limit)
        return 1;
      char[] charArray = A.ToCharArray();
      for (int index = 0; index < Limit; ++index)
      {
        if ((int) charArray[index] != (int) bB[index])
          return (int) charArray[index] >= (int) bB[index] ? 1 : -1;
      }
      return 0;
    }

    private static int memcmp(byte[] a, int Offset, byte[] b, int Limit)
    {
      if (a.Length < Offset + Limit)
        return a.Length - Offset >= b.Length ? 1 : -1;
      if (b.Length < Limit)
        return 1;
      for (int index = 0; index < Limit; ++index)
      {
        if ((int) a[index + Offset] != (int) b[index])
          return (int) a[index + Offset] >= (int) b[index] ? 1 : -1;
      }
      return 0;
    }

    private static int memcmp(byte[] a, int Aoffset, byte[] b, int Boffset, int Limit)
    {
      if (a.Length < Aoffset + Limit)
        return a.Length - Aoffset >= b.Length - Boffset ? 1 : -1;
      if (b.Length < Boffset + Limit)
        return 1;
      for (int index = 0; index < Limit; ++index)
      {
        if ((int) a[index + Aoffset] != (int) b[index + Boffset])
          return (int) a[index + Aoffset] >= (int) b[index + Boffset] ? 1 : -1;
      }
      return 0;
    }

    private static int memcmp(byte[] a, int Offset, string b, int Limit)
    {
      if (a.Length < Offset + Limit)
        return a.Length - Offset >= b.Length ? 1 : -1;
      if (b.Length < Limit)
        return 1;
      for (int index = 0; index < Limit; ++index)
      {
        if ((int) a[index + Offset] != (int) b[index])
          return (int) a[index + Offset] >= (int) b[index] ? 1 : -1;
      }
      return 0;
    }

    private static int memcmp(string A, string B, int Limit)
    {
      if (A.Length < Limit)
        return A.Length >= B.Length ? 1 : -1;
      if (B.Length < Limit)
        return 1;
      int num;
      if ((num = string.Compare(A, 0, B, 0, Limit, StringComparison.Ordinal)) == 0)
        return 0;
      return num >= 0 ? 1 : -1;
    }

    private static void regexpFunc(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.UNUSED_PARAMETER<int>(argc);
      string pattern = Sqlite3.sqlite3_value_text(argv[0]);
      string input = Sqlite3.sqlite3_value_text(argv[1]);
      if (input == null || string.IsNullOrEmpty(pattern))
      {
        Sqlite3.sqlite3_result_int(context, 0);
      }
      else
      {
        if (Sqlite3.oRegex == null || Sqlite3.oRegex.ToString() == pattern)
          Sqlite3.oRegex = new Regex(pattern, RegexOptions.IgnoreCase);
        Sqlite3.sqlite3_result_int(context, Sqlite3.oRegex.IsMatch(input) ? 1 : 0);
      }
    }

    private static void va_start(object[] ap, string zFormat)
    {
      Sqlite3.vaFORMAT = zFormat;
      Sqlite3.vaNEXT = 0;
    }

    private static bool va_arg(object[] ap, bool sysType) => Convert.ToBoolean(ap[Sqlite3.vaNEXT++]);

    private static byte[] va_arg(object[] ap, byte[] sysType) => (byte[]) ap[Sqlite3.vaNEXT++];

    private static byte[][] va_arg(object[] ap, byte[][] sysType)
    {
      if (ap[Sqlite3.vaNEXT] != null)
        return (byte[][]) ap[Sqlite3.vaNEXT++];
      ++Sqlite3.vaNEXT;
      return (byte[][]) null;
    }

    private static char va_arg(object[] ap, char sysType)
    {
      if (ap[Sqlite3.vaNEXT] is int && (int) ap[Sqlite3.vaNEXT] == 0)
      {
        ++Sqlite3.vaNEXT;
        return '0';
      }
      if (!(ap[Sqlite3.vaNEXT] is long))
        return (char) ap[Sqlite3.vaNEXT++];
      if ((long) ap[Sqlite3.vaNEXT] != 0L)
        return (char) (long) ap[Sqlite3.vaNEXT++];
      ++Sqlite3.vaNEXT;
      return '0';
    }

    private static double va_arg(object[] ap, double sysType) => Convert.ToDouble(ap[Sqlite3.vaNEXT++]);

    private static Sqlite3.dxLog va_arg(object[] ap, Sqlite3.dxLog sysType) => (Sqlite3.dxLog) ap[Sqlite3.vaNEXT++];

    private static long va_arg(object[] ap, long sysType) => ap[Sqlite3.vaNEXT] is long ? Convert.ToInt64(ap[Sqlite3.vaNEXT++]) : (long) ap[Sqlite3.vaNEXT++].GetHashCode();

    private static int va_arg(object[] ap, int sysType) => Convert.ToInt64(ap[Sqlite3.vaNEXT]) > 0L && Convert.ToUInt32(ap[Sqlite3.vaNEXT]) > (uint) int.MaxValue ? (int) Convert.ToUInt32(ap[Sqlite3.vaNEXT++]) - -1 - 1 : Convert.ToInt32(ap[Sqlite3.vaNEXT++]);

    private static int[] va_arg(object[] ap, int[] sysType)
    {
      if (ap[Sqlite3.vaNEXT] != null)
        return (int[]) ap[Sqlite3.vaNEXT++];
      ++Sqlite3.vaNEXT;
      return (int[]) null;
    }

    private static Sqlite3.MemPage va_arg(object[] ap, Sqlite3.MemPage sysType) => (Sqlite3.MemPage) ap[Sqlite3.vaNEXT++];

    private static object va_arg(object[] ap, object sysType) => ap[Sqlite3.vaNEXT++];

    private static Sqlite3.sqlite3 va_arg(object[] ap, Sqlite3.sqlite3 sysType) => (Sqlite3.sqlite3) ap[Sqlite3.vaNEXT++];

    private static Sqlite3.sqlite3_mem_methods va_arg(
      object[] ap,
      Sqlite3.sqlite3_mem_methods sysType)
    {
      return (Sqlite3.sqlite3_mem_methods) ap[Sqlite3.vaNEXT++];
    }

    private static Sqlite3.sqlite3_mutex_methods va_arg(
      object[] ap,
      Sqlite3.sqlite3_mutex_methods sysType)
    {
      return (Sqlite3.sqlite3_mutex_methods) ap[Sqlite3.vaNEXT++];
    }

    private static Sqlite3.SrcList va_arg(object[] ap, Sqlite3.SrcList sysType) => (Sqlite3.SrcList) ap[Sqlite3.vaNEXT++];

    private static string va_arg(object[] ap, string sysType)
    {
      if (ap.Length < Sqlite3.vaNEXT - 1 || ap[Sqlite3.vaNEXT] == null)
      {
        ++Sqlite3.vaNEXT;
        return "NULL";
      }
      if (ap[Sqlite3.vaNEXT] is byte[])
      {
        if (!(Encoding.UTF8.GetString((byte[]) ap[Sqlite3.vaNEXT], 0, ((byte[]) ap[Sqlite3.vaNEXT]).Length) == "\0"))
          return Encoding.UTF8.GetString((byte[]) ap[Sqlite3.vaNEXT], 0, ((byte[]) ap[Sqlite3.vaNEXT++]).Length);
        ++Sqlite3.vaNEXT;
        return "";
      }
      if (ap[Sqlite3.vaNEXT] is int)
      {
        ++Sqlite3.vaNEXT;
        return (string) null;
      }
      if (ap[Sqlite3.vaNEXT] is StringBuilder)
        return ap[Sqlite3.vaNEXT++].ToString();
      return ap[Sqlite3.vaNEXT] is char ? ((char) ap[Sqlite3.vaNEXT++]).ToString() : (string) ap[Sqlite3.vaNEXT++];
    }

    private static Sqlite3.Token va_arg(object[] ap, Sqlite3.Token sysType) => (Sqlite3.Token) ap[Sqlite3.vaNEXT++];

    private static uint va_arg(object[] ap, uint sysType) => ap[Sqlite3.vaNEXT].GetType().IsClass ? (uint) ap[Sqlite3.vaNEXT++].GetHashCode() : Convert.ToUInt32(ap[Sqlite3.vaNEXT++]);

    private static ulong va_arg(object[] ap, ulong sysType) => ap[Sqlite3.vaNEXT].GetType().IsClass ? (ulong) ap[Sqlite3.vaNEXT++].GetHashCode() : Convert.ToUInt64(ap[Sqlite3.vaNEXT++]);

    private static Sqlite3.void_function va_arg(object[] ap, Sqlite3.void_function sysType) => (Sqlite3.void_function) ap[Sqlite3.vaNEXT++];

    private static void va_end(ref string[] ap)
    {
      ap = (string[]) null;
      Sqlite3.vaNEXT = -1;
      Sqlite3.vaFORMAT = "";
    }

    private static void va_end(ref object[] ap)
    {
      ap = (object[]) null;
      Sqlite3.vaNEXT = -1;
      Sqlite3.vaFORMAT = "";
    }

    public static Sqlite3.tm localtime(long baseTime)
    {
      System.DateTime localTime = new System.DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(Convert.ToDouble(baseTime)).ToLocalTime();
      return new Sqlite3.tm()
      {
        tm_sec = localTime.Second,
        tm_min = localTime.Minute,
        tm_hour = localTime.Hour,
        tm_mday = localTime.Day,
        tm_mon = localTime.Month,
        tm_year = localTime.Year,
        tm_wday = (int) localTime.DayOfWeek,
        tm_yday = localTime.DayOfYear,
        tm_isdst = localTime.IsDaylightSavingTime() ? 1 : 0
      };
    }

    public static long ToUnixtime(System.DateTime date)
    {
      System.DateTime dateTime = new System.DateTime(1970, 1, 1, 0, 0, 0, 0);
      return Convert.ToInt64((date - dateTime).TotalSeconds);
    }

    public static System.DateTime ToCSharpTime(long unixTime) => new System.DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(Convert.ToDouble(unixTime));

    public static int GetbytesPerSector(StringBuilder diskPath) => 4096;

    private static void SWAP<T>(ref T A, ref T B)
    {
      T obj = A;
      A = B;
      B = obj;
    }

    private static void x_CountStep(Sqlite3.sqlite3_context context, int argc, Sqlite3.Mem[] argv)
    {
      Sqlite3.Mem mem = Sqlite3.sqlite3_aggregate_context(context, 1);
      if (mem._SumCtx == null)
        mem._SumCtx = new Sqlite3.SumCtx();
      Sqlite3.SumCtx sumCtx = mem._SumCtx;
      if (sumCtx.Context == null)
        sumCtx.Context = mem;
      if (argc == 0 || 5 == Sqlite3.sqlite3_value_type(argv[0]))
      {
        ++sumCtx.cnt;
        ++sumCtx.iSum;
      }
      else
      {
        int num1 = Sqlite3.sqlite3_value_numeric_type(argv[0]);
        if (sumCtx == null || num1 == 5)
          return;
        ++sumCtx.cnt;
        if (num1 == 1)
        {
          long num2 = Sqlite3.sqlite3_value_int64(argv[0]);
          switch (num2)
          {
            case 40:
            case 41:
              Sqlite3.sqlite3_result_error(context, "value of " + (object) num2 + " handed to x_count", -1);
              break;
            default:
              sumCtx.iSum += num2;
              if (sumCtx.approx | sumCtx.overflow != 0)
                break;
              long num3 = sumCtx.iSum + num2;
              int num4 = (int) (sumCtx.iSum >> 63);
              int num5 = (int) (num2 >> 63);
              int num6 = (int) (num3 >> 63);
              sumCtx.overflow = (num4 & num5 & ~num6 | ~num4 & ~num5 & num6) != 0 ? 1 : 0;
              sumCtx.iSum = num3;
              break;
          }
        }
        else
        {
          sumCtx.rSum += Sqlite3.sqlite3_value_double(argv[0]);
          sumCtx.approx = true;
        }
      }
    }

    private static void x_CountFinalize(Sqlite3.sqlite3_context context)
    {
      Sqlite3.SumCtx sumCtx = Sqlite3.sqlite3_aggregate_context(context, 0)._SumCtx;
      if (sumCtx == null || sumCtx.cnt <= 0L)
        return;
      if (sumCtx.overflow != 0)
        Sqlite3.sqlite3_result_error(context, "integer overflow", -1);
      else if (sumCtx.approx)
        Sqlite3.sqlite3_result_double(context, sumCtx.rSum);
      else if (sumCtx.iSum == 42L)
        Sqlite3.sqlite3_result_error(context, "x_count totals to 42", -1);
      else
        Sqlite3.sqlite3_result_int64(context, sumCtx.iSum);
    }

    public struct _aTable
    {
      public string zName;
      public string zCols;

      public _aTable(string zName, string zCols)
      {
        this.zName = zName;
        this.zCols = zCols;
      }
    }

    public struct analysisInfo
    {
      public Sqlite3.sqlite3 db;
      public string zDatabase;
    }

    public class sqlite3_backup
    {
      public Sqlite3.sqlite3 pDestDb;
      public Sqlite3.Btree pDest;
      public uint iDestSchema;
      public int bDestLocked;
      public uint iNext;
      public Sqlite3.sqlite3 pSrcDb;
      public Sqlite3.Btree pSrc;
      public int rc;
      public uint nRemaining;
      public uint nPagecount;
      public int isAttached;
      public Sqlite3.sqlite3_backup pNext;
    }

    public class _u
    {
      public byte[] aBitmap = new byte[Sqlite3.BITVEC_NELEM];
      public uint[] aHash = new uint[(int) Sqlite3.BITVEC_NINT];
      public Sqlite3.Bitvec[] apSub = new Sqlite3.Bitvec[Sqlite3.BITVEC_NPTR];
    }

    public class Bitvec
    {
      public uint iSize;
      public uint nSet;
      public uint iDivisor;
      public Sqlite3._u u = new Sqlite3._u();

      public static implicit operator bool(Sqlite3.Bitvec b) => b != null;
    }

    public struct _OvflCell
    {
      public byte[] pCell;
      public ushort idx;

      public Sqlite3._OvflCell Copy()
      {
        Sqlite3._OvflCell ovflCell = new Sqlite3._OvflCell();
        if (this.pCell != null)
        {
          ovflCell.pCell = Sqlite3.sqlite3Malloc(this.pCell.Length);
          Buffer.BlockCopy((Array) this.pCell, 0, (Array) ovflCell.pCell, 0, this.pCell.Length);
        }
        ovflCell.idx = this.idx;
        return ovflCell;
      }
    }

    public class MemPage
    {
      public byte isInit;
      public byte nOverflow;
      public byte intKey;
      public byte leaf;
      public byte hasData;
      public byte hdrOffset;
      public byte childPtrSize;
      public ushort maxLocal;
      public ushort minLocal;
      public ushort cellOffset;
      public ushort nFree;
      public ushort nCell;
      public ushort maskPage;
      public Sqlite3._OvflCell[] aOvfl = new Sqlite3._OvflCell[5];
      public Sqlite3.BtShared pBt;
      public byte[] aData;
      public Sqlite3.PgHdr pDbPage;
      public uint pgno;

      public Sqlite3.MemPage Copy()
      {
        Sqlite3.MemPage memPage = (Sqlite3.MemPage) this.MemberwiseClone();
        if (this.aOvfl != null)
        {
          memPage.aOvfl = new Sqlite3._OvflCell[this.aOvfl.Length];
          for (int index = 0; index < this.aOvfl.Length; ++index)
            memPage.aOvfl[index] = this.aOvfl[index].Copy();
        }
        if (this.aData != null)
        {
          memPage.aData = Sqlite3.sqlite3Malloc(this.aData.Length);
          Buffer.BlockCopy((Array) this.aData, 0, (Array) memPage.aData, 0, this.aData.Length);
        }
        return memPage;
      }
    }

    public class BtLock
    {
      private Sqlite3.Btree pBtree;
      private uint iTable;
      private byte eLock;
      private Sqlite3.BtLock pNext;
    }

    public class Btree
    {
      public Sqlite3.sqlite3 db;
      public Sqlite3.BtShared pBt;
      public byte inTrans;
      public bool sharable;
      public bool locked;
      public int wantToLock;
      public int nBackup;
      public Sqlite3.Btree pNext;
      public Sqlite3.Btree pPrev;
    }

    public class BtShared
    {
      public Sqlite3.Pager pPager;
      public Sqlite3.sqlite3 db;
      public Sqlite3.BtCursor pCursor;
      public Sqlite3.MemPage pPage1;
      public bool readOnly;
      public bool pageSizeFixed;
      public bool secureDelete;
      public bool initiallyEmpty;
      public byte openFlags;
      public bool autoVacuum;
      public bool incrVacuum;
      public byte inTransaction;
      public bool doNotUseWAL;
      public ushort maxLocal;
      public ushort minLocal;
      public ushort maxLeaf;
      public ushort minLeaf;
      public uint pageSize;
      public uint usableSize;
      public int nTransaction;
      public uint nPage;
      public Sqlite3.Schema pSchema;
      public Sqlite3.dxFreeSchema xFreeSchema;
      public Sqlite3.sqlite3_mutex mutex;
      public Sqlite3.Bitvec pHasContent;
      public byte[] pTmpSpace;
    }

    public struct CellInfo
    {
      public int iCell;
      public byte[] pCell;
      public long nKey;
      public uint nData;
      public uint nPayload;
      public ushort nHeader;
      public ushort nLocal;
      public ushort iOverflow;
      public ushort nSize;

      public bool Equals(Sqlite3.CellInfo ci) => ci.iCell < ci.pCell.Length && this.iCell < this.pCell.Length && (int) ci.pCell[ci.iCell] == (int) this.pCell[this.iCell] && ci.nKey == this.nKey && (int) ci.nData == (int) this.nData && (int) ci.nPayload == (int) this.nPayload && (int) ci.nHeader == (int) this.nHeader && (int) ci.nLocal == (int) this.nLocal && (int) ci.iOverflow == (int) this.iOverflow && (int) ci.nSize == (int) this.nSize;
    }

    public class BtCursor
    {
      public Sqlite3.Btree pBtree;
      public Sqlite3.BtShared pBt;
      public Sqlite3.BtCursor pNext;
      public Sqlite3.BtCursor pPrev;
      public Sqlite3.KeyInfo pKeyInfo;
      public uint pgnoRoot;
      public long cachedRowid;
      public Sqlite3.CellInfo info;
      public byte[] pKey;
      public long nKey;
      public int skipNext;
      public byte wrFlag;
      public byte atLast;
      public bool validNKey;
      public int eState;
      public short iPage;
      public ushort[] aiIdx = new ushort[20];
      public Sqlite3.MemPage[] apPage = new Sqlite3.MemPage[20];

      public void Clear()
      {
        this.pNext = (Sqlite3.BtCursor) null;
        this.pPrev = (Sqlite3.BtCursor) null;
        this.pKeyInfo = (Sqlite3.KeyInfo) null;
        this.pgnoRoot = 0U;
        this.cachedRowid = 0L;
        this.info = new Sqlite3.CellInfo();
        this.wrFlag = (byte) 0;
        this.atLast = (byte) 0;
        this.validNKey = false;
        this.eState = 0;
        this.pKey = (byte[]) null;
        this.nKey = 0L;
        this.skipNext = 0;
        this.iPage = (short) 0;
      }

      public Sqlite3.BtCursor Copy() => (Sqlite3.BtCursor) this.MemberwiseClone();
    }

    public class IntegrityCk
    {
      public Sqlite3.BtShared pBt;
      public Sqlite3.Pager pPager;
      public uint nPage;
      public int[] anRef;
      public int mxErr;
      public int nErr;
      public Sqlite3.StrAccum errMsg = new Sqlite3.StrAccum(100);
    }

    public class cipher_ctx
    {
      public string pass;
      public int pass_sz;
      public bool derive_key;
      public byte[] key;
      public int key_sz;
      public byte[] iv;
      public int iv_sz;
      public ICryptoTransform encryptor;
      public ICryptoTransform decryptor;

      public Sqlite3.cipher_ctx Copy()
      {
        Sqlite3.cipher_ctx cipherCtx = new Sqlite3.cipher_ctx();
        cipherCtx.derive_key = this.derive_key;
        cipherCtx.pass = this.pass;
        cipherCtx.pass_sz = this.pass_sz;
        if (this.key != null)
        {
          cipherCtx.key = new byte[this.key.Length];
          this.key.CopyTo((Array) cipherCtx.key, 0);
        }
        cipherCtx.key_sz = this.key_sz;
        if (this.iv != null)
        {
          cipherCtx.iv = new byte[this.iv.Length];
          this.iv.CopyTo((Array) cipherCtx.iv, 0);
        }
        cipherCtx.iv_sz = this.iv_sz;
        cipherCtx.encryptor = this.encryptor;
        cipherCtx.decryptor = this.decryptor;
        return cipherCtx;
      }

      public void CopyTo(Sqlite3.cipher_ctx ct)
      {
        ct.derive_key = this.derive_key;
        ct.pass = this.pass;
        ct.pass_sz = this.pass_sz;
        if (this.key != null)
        {
          ct.key = new byte[this.key.Length];
          this.key.CopyTo((Array) ct.key, 0);
        }
        ct.key_sz = this.key_sz;
        if (this.iv != null)
        {
          ct.iv = new byte[this.iv.Length];
          this.iv.CopyTo((Array) ct.iv, 0);
        }
        ct.iv_sz = this.iv_sz;
        ct.encryptor = this.encryptor;
        ct.decryptor = this.decryptor;
      }
    }

    public class codec_ctx
    {
      public int mode_rekey;
      public byte[] buffer;
      public Sqlite3.Btree pBt;
      public Sqlite3.cipher_ctx read_ctx;
      public Sqlite3.cipher_ctx write_ctx;

      public Sqlite3.codec_ctx Copy()
      {
        Sqlite3.codec_ctx codecCtx = new Sqlite3.codec_ctx();
        codecCtx.mode_rekey = this.mode_rekey;
        codecCtx.buffer = Sqlite3.sqlite3MemMalloc(this.buffer.Length);
        codecCtx.pBt = this.pBt;
        if (this.read_ctx != null)
          codecCtx.read_ctx = this.read_ctx.Copy();
        if (this.write_ctx != null)
          codecCtx.write_ctx = this.write_ctx.Copy();
        return codecCtx;
      }
    }

    public class DateTime
    {
      public long iJD;
      public int Y;
      public int M;
      public int D;
      public int h;
      public int m;
      public int tz;
      public double s;
      public byte validYMD;
      public byte validHMS;
      public byte validJD;
      public byte validTZ;

      public void CopyTo(Sqlite3.DateTime ct)
      {
        ct.iJD = this.iJD;
        ct.Y = this.Y;
        ct.M = this.M;
        ct.D = this.D;
        ct.h = this.h;
        ct.m = this.m;
        ct.tz = this.tz;
        ct.s = this.s;
        ct.validYMD = this.validYMD;
        ct.validHMS = this.validHMS;
        ct.validJD = this.validJD;
        ct.validTZ = this.validJD;
      }
    }

    public delegate void dxAuth(object pAuthArg, int b, string c, string d, string e, string f);

    public delegate int dxBusy(object pBtShared, int iValue);

    public delegate void dxFreeAux(object pAuxArg);

    public delegate int dxCallback(object pCallbackArg, long argc, object p2, object p3);

    public delegate void dxalarmCallback(object pNotUsed, long iNotUsed, int size);

    public delegate void dxCollNeeded(
      object pCollNeededArg,
      Sqlite3.sqlite3 db,
      int eTextRep,
      string collationName);

    public delegate int dxCommitCallback(object pCommitArg);

    public delegate int dxCompare(
      object pCompareArg,
      int size1,
      string Key1,
      int size2,
      string Key2);

    public delegate bool dxCompare4(string Key1, int size1, string Key2, int size2);

    public delegate void dxDel(ref string pDelArg);

    public delegate void dxDelCollSeq(ref object pDelArg);

    public delegate void dxLog(object pLogArg, int i, string msg);

    public delegate void dxLogcallback(object pCallbackArg, int argc, string p2);

    public delegate void dxProfile(object pProfileArg, string msg, long time);

    public delegate int dxProgress(object pProgressArg);

    public delegate void dxRollbackCallback(object pRollbackArg);

    public delegate void dxTrace(object pTraceArg, string msg);

    public delegate void dxUpdateCallback(object pUpdateArg, int b, string c, string d, long e);

    public delegate int dxWalCallback(object pWalArg, Sqlite3.sqlite3 db, string zDb, int nEntry);

    public delegate void dxFunc(Sqlite3.sqlite3_context ctx, int intValue, Sqlite3.Mem[] value);

    public delegate void dxStep(Sqlite3.sqlite3_context ctx, int intValue, Sqlite3.Mem[] value);

    public delegate void dxFinal(Sqlite3.sqlite3_context ctx);

    public delegate void dxFDestroy(object pArg);

    public delegate string dxColname(Sqlite3.Mem pVal);

    public delegate int dxFuncBtree(Sqlite3.Btree p);

    public delegate int dxExprTreeFunction(ref int pArg, Sqlite3.Expr pExpr);

    public delegate int dxExprTreeFunction_NC(Sqlite3.NameContext pArg, ref Sqlite3.Expr pExpr);

    public delegate int dxExprTreeFunction_OBJ(object pArg, Sqlite3.Expr pExpr);

    public delegate int dxClose(Sqlite3.sqlite3_file File_ID);

    public delegate int dxCheckReservedLock(Sqlite3.sqlite3_file File_ID, ref int pRes);

    public delegate int dxDeviceCharacteristics(Sqlite3.sqlite3_file File_ID);

    public delegate int dxFileControl(Sqlite3.sqlite3_file File_ID, int op, ref long pArgs);

    public delegate int dxFileSize(Sqlite3.sqlite3_file File_ID, ref long size);

    public delegate int dxLock(Sqlite3.sqlite3_file File_ID, int locktype);

    public delegate int dxRead(
      Sqlite3.sqlite3_file File_ID,
      byte[] buffer,
      int amount,
      long offset);

    public delegate int dxSectorSize(Sqlite3.sqlite3_file File_ID);

    public delegate int dxSync(Sqlite3.sqlite3_file File_ID, int flags);

    public delegate int dxTruncate(Sqlite3.sqlite3_file File_ID, long size);

    public delegate int dxUnlock(Sqlite3.sqlite3_file File_ID, int locktype);

    public delegate int dxWrite(
      Sqlite3.sqlite3_file File_ID,
      byte[] buffer,
      int amount,
      long offset);

    public delegate int dxShmMap(
      Sqlite3.sqlite3_file File_ID,
      int iPg,
      int pgsz,
      int pInt,
      out object pvolatile);

    public delegate int dxShmLock(Sqlite3.sqlite3_file File_ID, int offset, int n, int flags);

    public delegate void dxShmBarrier(Sqlite3.sqlite3_file File_ID);

    public delegate int dxShmUnmap(Sqlite3.sqlite3_file File_ID, int deleteFlag);

    public delegate int dxOpen(
      Sqlite3.sqlite3_vfs vfs,
      string zName,
      Sqlite3.sqlite3_file db,
      int flags,
      out int pOutFlags);

    public delegate int dxDelete(Sqlite3.sqlite3_vfs vfs, string zName, int syncDir);

    public delegate int dxAccess(
      Sqlite3.sqlite3_vfs vfs,
      string zName,
      int flags,
      out int pResOut);

    public delegate int dxFullPathname(
      Sqlite3.sqlite3_vfs vfs,
      string zName,
      int nOut,
      StringBuilder zOut);

    public delegate IntPtr dxDlOpen(Sqlite3.sqlite3_vfs vfs, string zFilename);

    public delegate int dxDlError(Sqlite3.sqlite3_vfs vfs, int nByte, string zErrMsg);

    public delegate IntPtr dxDlSym(Sqlite3.sqlite3_vfs vfs, IntPtr data, string zSymbol);

    public delegate int dxDlClose(Sqlite3.sqlite3_vfs vfs, IntPtr data);

    public delegate int dxRandomness(Sqlite3.sqlite3_vfs vfs, int nByte, byte[] buffer);

    public delegate int dxSleep(Sqlite3.sqlite3_vfs vfs, int microseconds);

    public delegate int dxCurrentTime(Sqlite3.sqlite3_vfs vfs, ref double currenttime);

    public delegate int dxGetLastError(Sqlite3.sqlite3_vfs pVfs, int nBuf, ref string zBuf);

    public delegate int dxCurrentTimeInt64(Sqlite3.sqlite3_vfs pVfs, ref long pTime);

    public delegate int dxSetSystemCall(
      Sqlite3.sqlite3_vfs pVfs,
      string zName,
      long sqlite3_syscall_ptr);

    public delegate int dxGetSystemCall(
      Sqlite3.sqlite3_vfs pVfs,
      string zName,
      long sqlite3_syscall_ptr);

    public delegate int dxNextSystemCall(
      Sqlite3.sqlite3_vfs pVfs,
      string zName,
      long sqlite3_syscall_ptr);

    public delegate void dxDestructor(Sqlite3.PgHdr dbPage);

    public delegate int dxBusyHandler(object pBusyHandlerArg);

    public delegate void dxReiniter(Sqlite3.PgHdr dbPage);

    public delegate void dxFreeSchema(Sqlite3.Schema schema);

    public delegate byte[] dxCodec(Sqlite3.codec_ctx pCodec, byte[] D, uint pageNumber, int X);

    public delegate void dxCodecSizeChng(Sqlite3.codec_ctx pCodec, int pageSize, short nReserve);

    public delegate void dxCodecFree(ref Sqlite3.codec_ctx pCodec);

    public delegate void dxDestroy(ref Sqlite3.PgHdr pDestroyArg);

    public delegate int dxStress(object obj, Sqlite3.PgHdr pPhHdr);

    public delegate int smdxCreateConnect(
      Sqlite3.sqlite3 db,
      object pAux,
      int argc,
      string[] constargv,
      out Sqlite3.sqlite3_vtab ppVTab,
      out string pError);

    public delegate int smdxBestIndex(
      Sqlite3.sqlite3_vtab pVTab,
      ref Sqlite3.sqlite3_index_info pIndex);

    public delegate int smdxDisconnect(ref object pVTab);

    public delegate int smdxDestroy(ref object pVTab);

    public delegate int smdxOpen(
      Sqlite3.sqlite3_vtab pVTab,
      out Sqlite3.sqlite3_vtab_cursor ppCursor);

    public delegate int smdxClose(ref Sqlite3.sqlite3_vtab_cursor pCursor);

    public delegate int smdxFilter(
      Sqlite3.sqlite3_vtab_cursor pCursor,
      int idxNum,
      string idxStr,
      int argc,
      Sqlite3.Mem[] argv);

    public delegate int smdxNext(Sqlite3.sqlite3_vtab_cursor pCursor);

    public delegate int smdxEof(Sqlite3.sqlite3_vtab_cursor pCursor);

    public delegate int smdxColumn(
      Sqlite3.sqlite3_vtab_cursor pCursor,
      Sqlite3.sqlite3_context p2,
      int p3);

    public delegate int smdxRowid(Sqlite3.sqlite3_vtab_cursor pCursor, out long pRowid);

    public delegate int smdxUpdate(
      Sqlite3.sqlite3_vtab pVTab,
      int p1,
      Sqlite3.Mem[] p2,
      out long p3);

    public delegate int smdxFunction(Sqlite3.sqlite3_vtab pVTab);

    public delegate int smdxFindFunction(
      Sqlite3.sqlite3_vtab pVtab,
      int nArg,
      string zName,
      ref Sqlite3.dxFunc pxFunc,
      ref object ppArg);

    public delegate int smdxRename(Sqlite3.sqlite3_vtab pVtab, string zNew);

    public delegate int smdxFunctionArg(Sqlite3.sqlite3_vtab pVTab, int nArg);

    public delegate int dxInit(
      Sqlite3.sqlite3 db,
      ref string zMessage,
      Sqlite3.sqlite3_api_routines sar);

    public delegate void void_function();

    public delegate int dxMemInit(object o);

    public delegate void dxMemShutdown(object o);

    public delegate byte[] dxMalloc(int nSize);

    public delegate int[] dxMallocInt(int nSize);

    public delegate Sqlite3.Mem dxMallocMem(Sqlite3.Mem pMem);

    public delegate void dxFree(ref byte[] pOld);

    public delegate void dxFreeInt(ref int[] pOld);

    public delegate void dxFreeMem(ref Sqlite3.Mem pOld);

    public delegate byte[] dxRealloc(byte[] pOld, int nSize);

    public delegate int dxSize(byte[] pArray);

    public delegate int dxRoundup(int nSize);

    public delegate int dxMutexInit();

    public delegate int dxMutexEnd();

    public delegate Sqlite3.sqlite3_mutex dxMutexAlloc(int iNumber);

    public delegate void dxMutexFree(Sqlite3.sqlite3_mutex sm);

    public delegate void dxMutexEnter(Sqlite3.sqlite3_mutex sm);

    public delegate int dxMutexTry(Sqlite3.sqlite3_mutex sm);

    public delegate void dxMutexLeave(Sqlite3.sqlite3_mutex sm);

    public delegate bool dxMutexHeld(Sqlite3.sqlite3_mutex sm);

    public delegate bool dxMutexNotheld(Sqlite3.sqlite3_mutex sm);

    public delegate object dxColumn(Sqlite3.Vdbe pStmt, int i);

    public delegate int dxColumn_I(Sqlite3.Vdbe pStmt, int i);

    public delegate int dxExprCallback(Sqlite3.Walker W, ref Sqlite3.Expr E);

    public delegate int dxSelectCallback(Sqlite3.Walker W, Sqlite3.Select S);

    public delegate int dxPC_Init(object NotUsed);

    public delegate void dxPC_Shutdown(object NotUsed);

    public delegate Sqlite3.PCache1 dxPC_Create(int szPage, bool bPurgeable);

    public delegate void dxPC_Cachesize(Sqlite3.PCache1 pCache, int nCachesize);

    public delegate int dxPC_Pagecount(Sqlite3.PCache1 pCache);

    public delegate Sqlite3.PgHdr dxPC_Fetch(
      Sqlite3.PCache1 pCache,
      uint key,
      int createFlag);

    public delegate void dxPC_Unpin(Sqlite3.PCache1 pCache, Sqlite3.PgHdr p2, bool discard);

    public delegate void dxPC_Rekey(
      Sqlite3.PCache1 pCache,
      Sqlite3.PgHdr p2,
      uint oldKey,
      uint newKey);

    public delegate void dxPC_Truncate(Sqlite3.PCache1 pCache, uint iLimit);

    public delegate void dxPC_Destroy(ref Sqlite3.PCache1 pCache);

    public delegate void dxIter(Sqlite3.PgHdr p);

    public struct BenignMallocHooks
    {
      public Sqlite3.void_function xBenignBegin;
      public Sqlite3.void_function xBenignEnd;

      public BenignMallocHooks(Sqlite3.void_function xBenignBegin, Sqlite3.void_function xBenignEnd)
      {
        this.xBenignBegin = xBenignBegin;
        this.xBenignEnd = xBenignEnd;
      }
    }

    private struct compareInfo
    {
      public char matchAll;
      public char matchOne;
      public char matchSet;
      public bool noCase;

      public compareInfo(char matchAll, char matchOne, char matchSet, bool noCase)
      {
        this.matchAll = matchAll;
        this.matchOne = matchOne;
        this.matchSet = matchSet;
        this.noCase = noCase;
      }
    }

    public class SumCtx
    {
      public double rSum;
      public long iSum;
      public long cnt;
      public int overflow;
      public bool approx;
      public Sqlite3.Mem _M;

      public Sqlite3.Mem Context
      {
        get => this._M;
        set
        {
          this._M = value;
          if (this._M == null || this._M.z == null)
            this.iSum = 0L;
          else
            this.iSum = Convert.ToInt64(this._M.z);
        }
      }
    }

    public class CountCtx
    {
      private long _n;
      private Sqlite3.Mem _M;

      public Sqlite3.Mem Context
      {
        get => this._M;
        set
        {
          this._M = value;
          if (this._M == null || this._M.z == null)
            this._n = 0L;
          else
            this._n = Convert.ToInt64(this._M.z);
        }
      }

      public long n
      {
        get => this._n;
        set
        {
          this._n = value;
          if (this._M == null)
            return;
          this._M.z = this._n.ToString();
        }
      }
    }

    public struct sFuncs
    {
      public string zName;
      public sbyte nArg;
      public byte argType;
      public byte eTextRep;
      public byte needCollSeq;
      public Sqlite3.dxFunc xFunc;

      public sFuncs(
        string zName,
        sbyte nArg,
        byte argType,
        byte eTextRep,
        byte needCollSeq,
        Sqlite3.dxFunc xFunc)
      {
        this.zName = zName;
        this.nArg = nArg;
        this.argType = argType;
        this.eTextRep = eTextRep;
        this.needCollSeq = needCollSeq;
        this.xFunc = xFunc;
      }
    }

    public struct sAggs
    {
      public string zName;
      public sbyte nArg;
      public byte argType;
      public byte needCollSeq;
      public Sqlite3.dxStep xStep;
      public Sqlite3.dxFinal xFinalize;

      public sAggs(
        string zName,
        sbyte nArg,
        byte argType,
        byte needCollSeq,
        Sqlite3.dxStep xStep,
        Sqlite3.dxFinal xFinalize)
      {
        this.zName = zName;
        this.nArg = nArg;
        this.argType = argType;
        this.needCollSeq = needCollSeq;
        this.xStep = xStep;
        this.xFinalize = xFinalize;
      }
    }

    public class _ht
    {
      public int count;
      public Sqlite3.HashElem chain;
    }

    public class Hash
    {
      public uint htsize = 31;
      public uint count;
      public Sqlite3.HashElem first;
      public Sqlite3._ht[] ht;

      public Sqlite3.Hash Copy() => this == null ? (Sqlite3.Hash) null : (Sqlite3.Hash) this.MemberwiseClone();
    }

    public class HashElem
    {
      public Sqlite3.HashElem next;
      public Sqlite3.HashElem prev;
      public object data;
      public string pKey;
      public int nKey;
    }

    public class sqlite3_api_routines
    {
      public Sqlite3.sqlite3 context_db_handle;
    }

    public class sqlite3AutoExtList
    {
      public int nExt;
      public Sqlite3.dxInit[] aExt;

      public sqlite3AutoExtList(int nExt, Sqlite3.dxInit[] aExt)
      {
        this.nExt = nExt;
        this.aExt = aExt;
      }
    }

    public class _aFlagOp
    {
      public int op;
      public uint mask;

      public _aFlagOp(int op, uint mask)
      {
        this.op = op;
        this.mask = mask;
      }
    }

    private class OpenMode
    {
      public string z;
      public int mode;

      public OpenMode(string z, int mode)
      {
        this.z = z;
        this.mode = mode;
      }
    }

    public class Mem0Global
    {
      public int nScratchFree;
      public int nPageFree;
      public Sqlite3.sqlite3_mutex mutex;
      public long alarmThreshold;
      public Sqlite3.dxalarmCallback alarmCallback;
      public object alarmArg;
      public bool nearlyFull;
      public byte[][][] aByte;
      public int[] aByteSize;
      public int[] aByte_used;
      public int[][] aInt;
      public Sqlite3.Mem[] aMem;
      public Sqlite3.BtCursor[] aBtCursor;
      public Sqlite3.Mem0Global.memstat msByte;
      public Sqlite3.Mem0Global.memstat msInt;
      public Sqlite3.Mem0Global.memstat msMem;
      public Sqlite3.Mem0Global.memstat msBtCursor;

      public Mem0Global()
      {
      }

      public Mem0Global(
        int nScratchFree,
        int nPageFree,
        Sqlite3.sqlite3_mutex mutex,
        long alarmThreshold,
        Sqlite3.dxalarmCallback alarmCallback,
        object alarmArg,
        int Byte_Allocation,
        int Int_Allocation,
        int Mem_Allocation,
        int BtCursor_Allocation)
      {
        this.nScratchFree = nScratchFree;
        this.nPageFree = nPageFree;
        this.mutex = mutex;
        this.alarmThreshold = alarmThreshold;
        this.alarmCallback = alarmCallback;
        this.alarmArg = alarmArg;
        this.msByte.next = -1;
        this.msInt.next = -1;
        this.msMem.next = -1;
        this.aByteSize = new int[5]
        {
          32,
          256,
          1024,
          8192,
          0
        };
        this.aByte_used = new int[5]{ -1, -1, -1, -1, -1 };
        this.aByte = new byte[this.aByteSize.Length][][];
        for (int index = 0; index < this.aByteSize.Length; ++index)
          this.aByte[index] = new byte[Byte_Allocation][];
        this.aInt = new int[Int_Allocation][];
        this.aMem = new Sqlite3.Mem[Mem_Allocation <= 4 ? 4 : Mem_Allocation];
        this.aBtCursor = new Sqlite3.BtCursor[BtCursor_Allocation <= 4 ? 4 : BtCursor_Allocation];
        this.nearlyFull = false;
      }

      public struct memstat
      {
        public int alloc;
        public int dealloc;
        public int cached;
        public int next;
        public int max;
      }
    }

    public class FileChunk
    {
      public Sqlite3.FileChunk pNext;
      public byte[] zChunk = new byte[4096];
    }

    public class FilePoint
    {
      public long iOffset;
      public Sqlite3.FileChunk pChunk;
    }

    public class sqlite3_file
    {
      public Sqlite3.FileChunk pFirst;
      public Sqlite3.FilePoint endpoint;
      public Sqlite3.FilePoint readpoint;
      public Sqlite3.sqlite3_vfs pVfs;
      public FileStream fs;
      public int locktype;
      public int sharedLockByte;
      public ulong lastErrno;
      public ulong sectorSize;
      public object pShm;
      public string zPath;
      public int szChunk;
      public Sqlite3.sqlite3_io_methods pMethods;

      public void Clear()
      {
        this.pMethods = (Sqlite3.sqlite3_io_methods) null;
        this.fs = (FileStream) null;
        this.locktype = 0;
        this.sharedLockByte = 0;
        this.lastErrno = 0UL;
        this.sectorSize = 0UL;
      }
    }

    public class sqlite3_mutex
    {
    }

    private class LockingStrategy
    {
      public virtual void LockFile(Sqlite3.sqlite3_file pFile, long offset, long length)
      {
      }

      public virtual int SharedLockFile(Sqlite3.sqlite3_file pFile, long offset, long length) => 1;

      public virtual void UnlockFile(Sqlite3.sqlite3_file pFile, long offset, long length)
      {
      }
    }

    private class MediumTrustLockingStrategy : Sqlite3.LockingStrategy
    {
      public override int SharedLockFile(Sqlite3.sqlite3_file pFile, long offset, long length) => 1;
    }

    public class PagerSavepoint
    {
      public long iOffset;
      public long iHdrOffset;
      public Sqlite3.Bitvec pInSavepoint;
      public uint nOrig;
      public uint iSubRec;
      public object aWalData;

      public static implicit operator bool(Sqlite3.PagerSavepoint b) => b != null;
    }

    public class Pager
    {
      public Sqlite3.sqlite3_vfs pVfs;
      public bool exclusiveMode;
      public byte journalMode;
      public byte useJournal;
      public byte noReadlock;
      public bool noSync;
      public bool fullSync;
      public byte ckptSyncFlags;
      public byte syncFlags;
      public bool tempFile;
      public bool readOnly;
      public bool alwaysRollback;
      public byte memDb;
      public byte eState;
      public byte eLock;
      public bool changeCountDone;
      public int setMaster;
      public byte doNotSpill;
      public byte doNotSyncSpill;
      public byte subjInMemory;
      public uint dbSize;
      public uint dbOrigSize;
      public uint dbFileSize;
      public uint dbHintSize;
      public int errCode;
      public int nRec;
      public uint cksumInit;
      public uint nSubRec;
      public Sqlite3.Bitvec pInJournal;
      public Sqlite3.sqlite3_file fd;
      public Sqlite3.sqlite3_file jfd;
      public Sqlite3.sqlite3_file sjfd;
      public long journalOff;
      public long journalHdr;
      public Sqlite3.sqlite3_backup pBackup;
      public Sqlite3.PagerSavepoint[] aSavepoint;
      public int nSavepoint;
      public byte[] dbFileVers = new byte[16];
      public ushort nExtra;
      public short nReserve;
      public uint vfsFlags;
      public uint sectorSize;
      public int pageSize;
      public uint mxPgno;
      public long journalSizeLimit;
      public string zFilename;
      public string zJournal;
      public Sqlite3.dxBusyHandler xBusyHandler;
      public object pBusyHandlerArg;
      public int nHit;
      public Sqlite3.dxReiniter xReiniter;
      public Sqlite3.dxCodec xCodec;
      public Sqlite3.dxCodecSizeChng xCodecSizeChng;
      public Sqlite3.dxCodecFree xCodecFree;
      public Sqlite3.codec_ctx pCodec;
      public byte[] pTmpSpace;
      public Sqlite3.PCache pPCache;
      public Sqlite3.sqlite3_vfs pWal;
    }

    public struct LimitVal
    {
      public Sqlite3.Expr pLimit;
      public Sqlite3.Expr pOffset;
    }

    public struct LikeOp
    {
      public Sqlite3.Token eOperator;
      public bool not;
    }

    public struct TrigEvent
    {
      public int a;
      public Sqlite3.IdList b;
    }

    public struct AttachKey
    {
      public int type;
      public Sqlite3.Token key;
    }

    public class YYMINORTYPE
    {
      public int yyinit;
      public Sqlite3.Token yy0 = new Sqlite3.Token();
      public int yy4;
      public Sqlite3.TrigEvent yy90;
      public Sqlite3.ExprSpan yy118 = new Sqlite3.ExprSpan();
      public Sqlite3.TriggerStep yy203;
      public byte yy210;
      public Sqlite3.YYMINORTYPE._yy215 yy215;
      public Sqlite3.SrcList yy259;
      public Sqlite3.LimitVal yy292;
      public Sqlite3.Expr yy314;
      public Sqlite3.ExprList yy322;
      public Sqlite3.LikeOp yy342;
      public Sqlite3.IdList yy384;
      public Sqlite3.Select yy387;

      public struct _yy215
      {
        public int value;
        public int mask;
      }
    }

    public class yyStackEntry
    {
      public int stateno;
      public int major;
      public Sqlite3.YYMINORTYPE minor;
    }

    public class yyParser
    {
      public int yyidx;
      public int yyerrcnt;
      public Sqlite3.Parse pParse;
      public Sqlite3.yyStackEntry[] yystack = new Sqlite3.yyStackEntry[100];
    }

    public struct _yyRuleInfo
    {
      public int lhs;
      public byte nrhs;

      public _yyRuleInfo(int lhs, byte nrhs)
      {
        this.lhs = lhs;
        this.nrhs = nrhs;
      }
    }

    public class yymsp
    {
      public Sqlite3.yyParser _yyParser;
      public int _yyidx;

      public yymsp(ref Sqlite3.yyParser pointer_to_yyParser, int yyidx)
      {
        this._yyParser = pointer_to_yyParser;
        this._yyidx = yyidx;
      }

      public Sqlite3.yyStackEntry this[int offset] => this._yyParser.yystack[this._yyidx + offset];
    }

    public class PGroup
    {
      public Sqlite3.sqlite3_mutex mutex;
      public int nMaxPage;
      public int nMinPage;
      public int mxPinned;
      public int nCurrentPage;
      public Sqlite3.PgHdr1 pLruHead;
      public Sqlite3.PgHdr1 pLruTail;

      public PGroup() => this.mutex = new Sqlite3.sqlite3_mutex();
    }

    public class PCache1
    {
      public Sqlite3.PGroup pGroup;
      public int szPage;
      public bool bPurgeable;
      public int nMin;
      public int nMax;
      public int n90pct;
      public int nRecyclable;
      public int nPage;
      public int nHash;
      public Sqlite3.PgHdr1[] apHash;
      public uint iMaxKey;

      public void Clear()
      {
        this.nRecyclable = 0;
        this.nPage = 0;
        this.nHash = 0;
        this.apHash = (Sqlite3.PgHdr1[]) null;
        this.iMaxKey = 0U;
      }
    }

    public class PgHdr1
    {
      public uint iKey;
      public Sqlite3.PgHdr1 pNext;
      public Sqlite3.PCache1 pCache;
      public Sqlite3.PgHdr1 pLruNext;
      public Sqlite3.PgHdr1 pLruPrev;
      public Sqlite3.PgHdr pPgHdr = new Sqlite3.PgHdr();

      public void Clear()
      {
        this.iKey = 0U;
        this.pNext = (Sqlite3.PgHdr1) null;
        this.pCache = (Sqlite3.PCache1) null;
        this.pPgHdr.Clear();
      }
    }

    public class PgFreeslot
    {
      public Sqlite3.PgFreeslot pNext;
      public Sqlite3.PgHdr _PgHdr;
    }

    public class PCacheGlobal
    {
      public Sqlite3.PGroup grp;
      public bool isInit;
      public int szSlot;
      public int nSlot;
      public int nReserve;
      public object pStart;
      public object pEnd;
      public Sqlite3.sqlite3_mutex mutex;
      public int nFreeSlot;
      public Sqlite3.PgFreeslot pFree;
      public bool bUnderPressure;

      public PCacheGlobal() => this.grp = new Sqlite3.PGroup();
    }

    public class PCache
    {
      public Sqlite3.PgHdr pDirty;
      public Sqlite3.PgHdr pDirtyTail;
      public Sqlite3.PgHdr pSynced;
      public int _nRef;
      public int nMax;
      public int szPage;
      public int szExtra;
      public bool bPurgeable;
      public Sqlite3.dxStress xStress;
      public object pStress;
      public Sqlite3.PCache1 pCache;
      public Sqlite3.PgHdr pPage1;

      public int nRef
      {
        get => this._nRef;
        set => this._nRef = value;
      }

      public void Clear()
      {
        this.pDirty = (Sqlite3.PgHdr) null;
        this.pDirtyTail = (Sqlite3.PgHdr) null;
        this.pSynced = (Sqlite3.PgHdr) null;
        this.nRef = 0;
      }
    }

    public class PgHdr
    {
      public byte[] pData;
      public Sqlite3.MemPage pExtra;
      public Sqlite3.PgHdr pDirty;
      public uint pgno;
      public Sqlite3.Pager pPager;
      public int flags;
      public int nRef;
      public Sqlite3.PCache pCache;
      public bool CacheAllocated;
      public Sqlite3.PgHdr pDirtyNext;
      public Sqlite3.PgHdr pDirtyPrev;
      public Sqlite3.PgHdr1 pPgHdr1;

      public static implicit operator bool(Sqlite3.PgHdr b) => b != null;

      public void Clear()
      {
        Sqlite3.sqlite3_free(ref this.pData);
        this.pData = (byte[]) null;
        this.pExtra = (Sqlite3.MemPage) null;
        this.pDirty = (Sqlite3.PgHdr) null;
        this.pgno = 0U;
        this.pPager = (Sqlite3.Pager) null;
        this.flags = 0;
        this.nRef = 0;
        this.CacheAllocated = false;
        this.pCache = (Sqlite3.PCache) null;
        this.pDirtyNext = (Sqlite3.PgHdr) null;
        this.pDirtyPrev = (Sqlite3.PgHdr) null;
        this.pPgHdr1 = (Sqlite3.PgHdr1) null;
      }
    }

    private struct sPragmaType
    {
      public string zName;
      public int mask;

      public sPragmaType(string zName, int mask)
      {
        this.zName = zName;
        this.mask = mask;
      }
    }

    private class EncName
    {
      public string zName;
      public byte enc;

      public EncName(string zName, byte enc)
      {
        this.zName = zName;
        this.enc = enc;
      }
    }

    public class et_info
    {
      public char fmttype;
      public byte _base;
      public byte flags;
      public byte type;
      public byte charset;
      public byte prefix;

      public et_info(char fmttype, byte _base, byte flags, byte type, byte charset, byte prefix)
      {
        this.fmttype = fmttype;
        this._base = _base;
        this.flags = flags;
        this.type = type;
        this.charset = charset;
        this.prefix = prefix;
      }
    }

    public class sqlite3PrngType
    {
      public bool isInit;
      public int i;
      public int j;
      public byte[] s = new byte[256];

      public Sqlite3.sqlite3PrngType Copy()
      {
        Sqlite3.sqlite3PrngType sqlite3PrngType = (Sqlite3.sqlite3PrngType) this.MemberwiseClone();
        sqlite3PrngType.s = new byte[this.s.Length];
        Array.Copy((Array) this.s, (Array) sqlite3PrngType.s, this.s.Length);
        return sqlite3PrngType;
      }
    }

    public class RowSetEntry
    {
      public long v;
      public Sqlite3.RowSetEntry pRight;
      public Sqlite3.RowSetEntry pLeft;
    }

    public class RowSetChunk
    {
      public Sqlite3.RowSetChunk pNextChunk;
      public Sqlite3.RowSetEntry[] aEntry = new Sqlite3.RowSetEntry[63];
    }

    public class RowSet
    {
      public Sqlite3.RowSetChunk pChunk;
      public Sqlite3.sqlite3 db;
      public Sqlite3.RowSetEntry pEntry;
      public Sqlite3.RowSetEntry pLast;
      public Sqlite3.RowSetEntry[] pFresh;
      public Sqlite3.RowSetEntry pTree;
      public int nFresh;
      public bool isSorted;
      public byte iBatch;

      public RowSet(Sqlite3.sqlite3 db, int N)
      {
        this.pChunk = (Sqlite3.RowSetChunk) null;
        this.db = db;
        this.pEntry = (Sqlite3.RowSetEntry) null;
        this.pLast = (Sqlite3.RowSetEntry) null;
        this.pFresh = new Sqlite3.RowSetEntry[N];
        this.pTree = (Sqlite3.RowSetEntry) null;
        this.nFresh = N;
        this.isSorted = true;
        this.iBatch = (byte) 0;
      }
    }

    private class Keyword
    {
      public byte i;
      public byte nChar;
      public byte code;

      public Keyword(byte i, byte nChar, byte code)
      {
        this.i = i;
        this.nChar = nChar;
        this.code = code;
      }
    }

    public class sqlite3_io_methods
    {
      public int iVersion;
      public Sqlite3.dxClose xClose;
      public Sqlite3.dxRead xRead;
      public Sqlite3.dxWrite xWrite;
      public Sqlite3.dxTruncate xTruncate;
      public Sqlite3.dxSync xSync;
      public Sqlite3.dxFileSize xFileSize;
      public Sqlite3.dxLock xLock;
      public Sqlite3.dxUnlock xUnlock;
      public Sqlite3.dxCheckReservedLock xCheckReservedLock;
      public Sqlite3.dxFileControl xFileControl;
      public Sqlite3.dxSectorSize xSectorSize;
      public Sqlite3.dxDeviceCharacteristics xDeviceCharacteristics;
      public Sqlite3.dxShmMap xShmMap;
      public Sqlite3.dxShmLock xShmLock;
      public Sqlite3.dxShmBarrier xShmBarrier;
      public Sqlite3.dxShmUnmap xShmUnmap;

      public sqlite3_io_methods(
        int iVersion,
        Sqlite3.dxClose xClose,
        Sqlite3.dxRead xRead,
        Sqlite3.dxWrite xWrite,
        Sqlite3.dxTruncate xTruncate,
        Sqlite3.dxSync xSync,
        Sqlite3.dxFileSize xFileSize,
        Sqlite3.dxLock xLock,
        Sqlite3.dxUnlock xUnlock,
        Sqlite3.dxCheckReservedLock xCheckReservedLock,
        Sqlite3.dxFileControl xFileControl,
        Sqlite3.dxSectorSize xSectorSize,
        Sqlite3.dxDeviceCharacteristics xDeviceCharacteristics,
        Sqlite3.dxShmMap xShmMap,
        Sqlite3.dxShmLock xShmLock,
        Sqlite3.dxShmBarrier xShmBarrier,
        Sqlite3.dxShmUnmap xShmUnmap)
      {
        this.iVersion = iVersion;
        this.xClose = xClose;
        this.xRead = xRead;
        this.xWrite = xWrite;
        this.xTruncate = xTruncate;
        this.xSync = xSync;
        this.xFileSize = xFileSize;
        this.xLock = xLock;
        this.xUnlock = xUnlock;
        this.xCheckReservedLock = xCheckReservedLock;
        this.xFileControl = xFileControl;
        this.xSectorSize = xSectorSize;
        this.xDeviceCharacteristics = xDeviceCharacteristics;
        this.xShmMap = xShmMap;
        this.xShmLock = xShmLock;
        this.xShmBarrier = xShmBarrier;
        this.xShmUnmap = xShmUnmap;
      }
    }

    public class sqlite3_vfs
    {
      public int iVersion;
      public int szOsFile;
      public int mxPathname;
      public Sqlite3.sqlite3_vfs pNext;
      public string zName;
      public object pAppData;
      public Sqlite3.dxOpen xOpen;
      public Sqlite3.dxDelete xDelete;
      public Sqlite3.dxAccess xAccess;
      public Sqlite3.dxFullPathname xFullPathname;
      public Sqlite3.dxDlOpen xDlOpen;
      public Sqlite3.dxDlError xDlError;
      public Sqlite3.dxDlSym xDlSym;
      public Sqlite3.dxDlClose xDlClose;
      public Sqlite3.dxRandomness xRandomness;
      public Sqlite3.dxSleep xSleep;
      public Sqlite3.dxCurrentTime xCurrentTime;
      public Sqlite3.dxGetLastError xGetLastError;
      public Sqlite3.dxCurrentTimeInt64 xCurrentTimeInt64;
      public Sqlite3.dxSetSystemCall xSetSystemCall;
      public Sqlite3.dxGetSystemCall xGetSystemCall;
      public Sqlite3.dxNextSystemCall xNextSystemCall;

      public sqlite3_vfs()
      {
      }

      public sqlite3_vfs(
        int iVersion,
        int szOsFile,
        int mxPathname,
        Sqlite3.sqlite3_vfs pNext,
        string zName,
        object pAppData,
        Sqlite3.dxOpen xOpen,
        Sqlite3.dxDelete xDelete,
        Sqlite3.dxAccess xAccess,
        Sqlite3.dxFullPathname xFullPathname,
        Sqlite3.dxDlOpen xDlOpen,
        Sqlite3.dxDlError xDlError,
        Sqlite3.dxDlSym xDlSym,
        Sqlite3.dxDlClose xDlClose,
        Sqlite3.dxRandomness xRandomness,
        Sqlite3.dxSleep xSleep,
        Sqlite3.dxCurrentTime xCurrentTime,
        Sqlite3.dxGetLastError xGetLastError,
        Sqlite3.dxCurrentTimeInt64 xCurrentTimeInt64,
        Sqlite3.dxSetSystemCall xSetSystemCall,
        Sqlite3.dxGetSystemCall xGetSystemCall,
        Sqlite3.dxNextSystemCall xNextSystemCall)
      {
        this.iVersion = iVersion;
        this.szOsFile = szOsFile;
        this.mxPathname = mxPathname;
        this.pNext = pNext;
        this.zName = zName;
        this.pAppData = pAppData;
        this.xOpen = xOpen;
        this.xDelete = xDelete;
        this.xAccess = xAccess;
        this.xFullPathname = xFullPathname;
        this.xDlOpen = xDlOpen;
        this.xDlError = xDlError;
        this.xDlSym = xDlSym;
        this.xDlClose = xDlClose;
        this.xRandomness = xRandomness;
        this.xSleep = xSleep;
        this.xCurrentTime = xCurrentTime;
        this.xGetLastError = xGetLastError;
        this.xCurrentTimeInt64 = xCurrentTimeInt64;
      }

      public void CopyTo(Sqlite3.sqlite3_vfs ct)
      {
        ct.iVersion = this.iVersion;
        ct.szOsFile = this.szOsFile;
        ct.mxPathname = this.mxPathname;
        ct.pNext = this.pNext;
        ct.zName = this.zName;
        ct.pAppData = this.pAppData;
        ct.xOpen = this.xOpen;
        ct.xDelete = this.xDelete;
        ct.xAccess = this.xAccess;
        ct.xFullPathname = this.xFullPathname;
        ct.xDlOpen = this.xDlOpen;
        ct.xDlError = this.xDlError;
        ct.xDlSym = this.xDlSym;
        ct.xDlClose = this.xDlClose;
        ct.xRandomness = this.xRandomness;
        ct.xSleep = this.xSleep;
        ct.xCurrentTime = this.xCurrentTime;
        ct.xGetLastError = this.xGetLastError;
        ct.xCurrentTimeInt64 = this.xCurrentTimeInt64;
      }
    }

    public class sqlite3_mem_methods
    {
      public Sqlite3.dxMalloc xMalloc;
      public Sqlite3.dxMallocInt xMallocInt;
      public Sqlite3.dxMallocMem xMallocMem;
      public Sqlite3.dxFree xFree;
      public Sqlite3.dxFreeInt xFreeInt;
      public Sqlite3.dxFreeMem xFreeMem;
      public Sqlite3.dxRealloc xRealloc;
      public Sqlite3.dxSize xSize;
      public Sqlite3.dxRoundup xRoundup;
      public Sqlite3.dxMemInit xInit;
      public Sqlite3.dxMemShutdown xShutdown;
      public object pAppData;

      public sqlite3_mem_methods()
      {
      }

      public sqlite3_mem_methods(
        Sqlite3.dxMalloc xMalloc,
        Sqlite3.dxMallocInt xMallocInt,
        Sqlite3.dxMallocMem xMallocMem,
        Sqlite3.dxFree xFree,
        Sqlite3.dxFreeInt xFreeInt,
        Sqlite3.dxFreeMem xFreeMem,
        Sqlite3.dxRealloc xRealloc,
        Sqlite3.dxSize xSize,
        Sqlite3.dxRoundup xRoundup,
        Sqlite3.dxMemInit xInit,
        Sqlite3.dxMemShutdown xShutdown,
        object pAppData)
      {
        this.xMalloc = xMalloc;
        this.xMallocInt = xMallocInt;
        this.xMallocMem = xMallocMem;
        this.xFree = xFree;
        this.xFreeInt = xFreeInt;
        this.xFreeMem = xFreeMem;
        this.xRealloc = xRealloc;
        this.xSize = xSize;
        this.xRoundup = xRoundup;
        this.xInit = xInit;
        this.xShutdown = xShutdown;
        this.pAppData = pAppData;
      }
    }

    public class sqlite3_module
    {
      public int iVersion;
      public Sqlite3.smdxCreateConnect xCreate;
      public Sqlite3.smdxCreateConnect xConnect;
      public Sqlite3.smdxBestIndex xBestIndex;
      public Sqlite3.smdxDisconnect xDisconnect;
      public Sqlite3.smdxDestroy xDestroy;
      public Sqlite3.smdxOpen xOpen;
      public Sqlite3.smdxClose xClose;
      public Sqlite3.smdxFilter xFilter;
      public Sqlite3.smdxNext xNext;
      public Sqlite3.smdxEof xEof;
      public Sqlite3.smdxColumn xColumn;
      public Sqlite3.smdxRowid xRowid;
      public Sqlite3.smdxUpdate xUpdate;
      public Sqlite3.smdxFunction xBegin;
      public Sqlite3.smdxFunction xSync;
      public Sqlite3.smdxFunction xCommit;
      public Sqlite3.smdxFunction xRollback;
      public Sqlite3.smdxFindFunction xFindFunction;
      public Sqlite3.smdxRename xRename;
      public Sqlite3.smdxFunctionArg xSavepoint;
      public Sqlite3.smdxFunctionArg xRelease;
      public Sqlite3.smdxFunctionArg xRollbackTo;

      public sqlite3_module(
        int iVersion,
        Sqlite3.smdxCreateConnect xCreate,
        Sqlite3.smdxCreateConnect xConnect,
        Sqlite3.smdxBestIndex xBestIndex,
        Sqlite3.smdxDisconnect xDisconnect,
        Sqlite3.smdxDestroy xDestroy,
        Sqlite3.smdxOpen xOpen,
        Sqlite3.smdxClose xClose,
        Sqlite3.smdxFilter xFilter,
        Sqlite3.smdxNext xNext,
        Sqlite3.smdxEof xEof,
        Sqlite3.smdxColumn xColumn,
        Sqlite3.smdxRowid xRowid,
        Sqlite3.smdxUpdate xUpdate,
        Sqlite3.smdxFunction xBegin,
        Sqlite3.smdxFunction xSync,
        Sqlite3.smdxFunction xCommit,
        Sqlite3.smdxFunction xRollback,
        Sqlite3.smdxFindFunction xFindFunction,
        Sqlite3.smdxRename xRename)
      {
        this.iVersion = iVersion;
        this.xCreate = xCreate;
        this.xConnect = xConnect;
        this.xBestIndex = xBestIndex;
        this.xDisconnect = xDisconnect;
        this.xDestroy = xDestroy;
        this.xOpen = xOpen;
        this.xClose = xClose;
        this.xFilter = xFilter;
        this.xNext = xNext;
        this.xEof = xEof;
        this.xColumn = xColumn;
        this.xRowid = xRowid;
        this.xUpdate = xUpdate;
        this.xBegin = xBegin;
        this.xSync = xSync;
        this.xCommit = xCommit;
        this.xRollback = xRollback;
        this.xFindFunction = xFindFunction;
        this.xRename = xRename;
      }

      public sqlite3_module(
        int iVersion,
        Sqlite3.smdxCreateConnect xCreate,
        Sqlite3.smdxCreateConnect xConnect,
        Sqlite3.smdxBestIndex xBestIndex,
        Sqlite3.smdxDisconnect xDisconnect,
        Sqlite3.smdxDestroy xDestroy,
        Sqlite3.smdxOpen xOpen,
        Sqlite3.smdxClose xClose,
        Sqlite3.smdxFilter xFilter,
        Sqlite3.smdxNext xNext,
        Sqlite3.smdxEof xEof,
        Sqlite3.smdxColumn xColumn,
        Sqlite3.smdxRowid xRowid,
        Sqlite3.smdxUpdate xUpdate,
        Sqlite3.smdxFunction xBegin,
        Sqlite3.smdxFunction xSync,
        Sqlite3.smdxFunction xCommit,
        Sqlite3.smdxFunction xRollback,
        Sqlite3.smdxFindFunction xFindFunction,
        Sqlite3.smdxRename xRename,
        Sqlite3.smdxFunctionArg xSavepoint,
        Sqlite3.smdxFunctionArg xRelease,
        Sqlite3.smdxFunctionArg xRollbackTo)
      {
        this.iVersion = iVersion;
        this.xCreate = xCreate;
        this.xConnect = xConnect;
        this.xBestIndex = xBestIndex;
        this.xDisconnect = xDisconnect;
        this.xDestroy = xDestroy;
        this.xOpen = xOpen;
        this.xClose = xClose;
        this.xFilter = xFilter;
        this.xNext = xNext;
        this.xEof = xEof;
        this.xColumn = xColumn;
        this.xRowid = xRowid;
        this.xUpdate = xUpdate;
        this.xBegin = xBegin;
        this.xSync = xSync;
        this.xCommit = xCommit;
        this.xRollback = xRollback;
        this.xFindFunction = xFindFunction;
        this.xRename = xRename;
        this.xSavepoint = xSavepoint;
        this.xRelease = xRelease;
        this.xRollbackTo = xRollbackTo;
      }
    }

    public class sqlite3_index_constraint
    {
      public int iColumn;
      public int op;
      public bool usable;
      public int iTermOffset;
    }

    public class sqlite3_index_orderby
    {
      public int iColumn;
      public bool desc;
    }

    public class sqlite3_index_constraint_usage
    {
      public int argvIndex;
      public bool omit;
    }

    public class sqlite3_index_info
    {
      public int nConstraint;
      public Sqlite3.sqlite3_index_constraint[] aConstraint;
      public int nOrderBy;
      public Sqlite3.sqlite3_index_orderby[] aOrderBy;
      public Sqlite3.sqlite3_index_constraint_usage[] aConstraintUsage;
      public int idxNum;
      public string idxStr;
      public int needToFreeIdxStr;
      public bool orderByConsumed;
      public double estimatedCost;
    }

    public class sqlite3_vtab
    {
      public Sqlite3.sqlite3_module pModule;
      public int nRef;
      public string zErrMsg;
    }

    public class sqlite3_vtab_cursor
    {
      public Sqlite3.sqlite3_vtab pVtab;
    }

    public class sqlite3_mutex_methods
    {
      public Sqlite3.dxMutexInit xMutexInit;
      public Sqlite3.dxMutexEnd xMutexEnd;
      public Sqlite3.dxMutexAlloc xMutexAlloc;
      public Sqlite3.dxMutexFree xMutexFree;
      public Sqlite3.dxMutexEnter xMutexEnter;
      public Sqlite3.dxMutexTry xMutexTry;
      public Sqlite3.dxMutexLeave xMutexLeave;
      public Sqlite3.dxMutexHeld xMutexHeld;
      public Sqlite3.dxMutexNotheld xMutexNotheld;

      public sqlite3_mutex_methods()
      {
      }

      public sqlite3_mutex_methods(
        Sqlite3.dxMutexInit xMutexInit,
        Sqlite3.dxMutexEnd xMutexEnd,
        Sqlite3.dxMutexAlloc xMutexAlloc,
        Sqlite3.dxMutexFree xMutexFree,
        Sqlite3.dxMutexEnter xMutexEnter,
        Sqlite3.dxMutexTry xMutexTry,
        Sqlite3.dxMutexLeave xMutexLeave,
        Sqlite3.dxMutexHeld xMutexHeld,
        Sqlite3.dxMutexNotheld xMutexNotheld)
      {
        this.xMutexInit = xMutexInit;
        this.xMutexEnd = xMutexEnd;
        this.xMutexAlloc = xMutexAlloc;
        this.xMutexFree = xMutexFree;
        this.xMutexEnter = xMutexEnter;
        this.xMutexTry = xMutexTry;
        this.xMutexLeave = xMutexLeave;
        this.xMutexHeld = xMutexHeld;
        this.xMutexNotheld = xMutexNotheld;
      }

      public void Copy(Sqlite3.sqlite3_mutex_methods cp)
      {
        this.xMutexInit = cp.xMutexInit;
        this.xMutexEnd = cp.xMutexEnd;
        this.xMutexAlloc = cp.xMutexAlloc;
        this.xMutexFree = cp.xMutexFree;
        this.xMutexEnter = cp.xMutexEnter;
        this.xMutexTry = cp.xMutexTry;
        this.xMutexLeave = cp.xMutexLeave;
        this.xMutexHeld = cp.xMutexHeld;
        this.xMutexNotheld = cp.xMutexNotheld;
      }
    }

    public class sqlite3_pcache_methods
    {
      public object pArg;
      public Sqlite3.dxPC_Init xInit;
      public Sqlite3.dxPC_Shutdown xShutdown;
      public Sqlite3.dxPC_Create xCreate;
      public Sqlite3.dxPC_Cachesize xCachesize;
      public Sqlite3.dxPC_Pagecount xPagecount;
      public Sqlite3.dxPC_Fetch xFetch;
      public Sqlite3.dxPC_Unpin xUnpin;
      public Sqlite3.dxPC_Rekey xRekey;
      public Sqlite3.dxPC_Truncate xTruncate;
      public Sqlite3.dxPC_Destroy xDestroy;

      public sqlite3_pcache_methods()
      {
      }

      public sqlite3_pcache_methods(
        object pArg,
        Sqlite3.dxPC_Init xInit,
        Sqlite3.dxPC_Shutdown xShutdown,
        Sqlite3.dxPC_Create xCreate,
        Sqlite3.dxPC_Cachesize xCachesize,
        Sqlite3.dxPC_Pagecount xPagecount,
        Sqlite3.dxPC_Fetch xFetch,
        Sqlite3.dxPC_Unpin xUnpin,
        Sqlite3.dxPC_Rekey xRekey,
        Sqlite3.dxPC_Truncate xTruncate,
        Sqlite3.dxPC_Destroy xDestroy)
      {
        this.pArg = pArg;
        this.xInit = xInit;
        this.xShutdown = xShutdown;
        this.xCreate = xCreate;
        this.xCachesize = xCachesize;
        this.xPagecount = xPagecount;
        this.xFetch = xFetch;
        this.xUnpin = xUnpin;
        this.xRekey = xRekey;
        this.xTruncate = xTruncate;
        this.xDestroy = xDestroy;
      }
    }

    public class BusyHandler
    {
      public Sqlite3.dxBusy xFunc;
      public object pArg;
      public int nBusy;
    }

    public class Db
    {
      public string zName;
      public Sqlite3.Btree pBt;
      public byte inTrans;
      public byte safety_level;
      public Sqlite3.Schema pSchema;
    }

    public class Schema
    {
      public int schema_cookie;
      public uint iGeneration;
      public Sqlite3.Hash tblHash = new Sqlite3.Hash();
      public Sqlite3.Hash idxHash = new Sqlite3.Hash();
      public Sqlite3.Hash trigHash = new Sqlite3.Hash();
      public Sqlite3.Hash fkeyHash = new Sqlite3.Hash();
      public Sqlite3.Table pSeqTab;
      public byte file_format;
      public byte enc;
      public ushort flags;
      public int cache_size;

      public Sqlite3.Schema Copy() => this == null ? (Sqlite3.Schema) null : (Sqlite3.Schema) this.MemberwiseClone();

      public void Clear()
      {
        if (this == null)
          return;
        this.schema_cookie = 0;
        this.tblHash = new Sqlite3.Hash();
        this.idxHash = new Sqlite3.Hash();
        this.trigHash = new Sqlite3.Hash();
        this.fkeyHash = new Sqlite3.Hash();
        this.pSeqTab = (Sqlite3.Table) null;
      }
    }

    public class Lookaside
    {
      public int sz;
      public byte bEnabled;
      public bool bMalloced;
      public int nOut;
      public int mxOut;
      public int[] anStat = new int[3];
      public Sqlite3.LookasideSlot pFree;
      public int pStart;
      public int pEnd;
    }

    public class LookasideSlot
    {
      public Sqlite3.LookasideSlot pNext;
    }

    public class FuncDefHash
    {
      public Sqlite3.FuncDef[] a = new Sqlite3.FuncDef[23];
    }

    public class sqlite3
    {
      public Sqlite3.sqlite3_vfs pVfs;
      public int nDb;
      public Sqlite3.Db[] aDb = new Sqlite3.Db[10];
      public int flags;
      public int openFlags;
      public int errCode;
      public int errMask;
      public byte autoCommit;
      public byte temp_store;
      public byte dfltLockMode;
      public int nextAutovac;
      public byte suppressErr;
      public byte vtabOnConflict;
      public int nextPagesize;
      public int nTable;
      public Sqlite3.CollSeq pDfltColl;
      public long lastRowid;
      public uint magic;
      public int nChange;
      public int nTotalChange;
      public Sqlite3.sqlite3_mutex mutex;
      public int[] aLimit = new int[11];
      public Sqlite3.sqlite3.sqlite3InitInfo init = new Sqlite3.sqlite3.sqlite3InitInfo();
      public int nExtension;
      public object[] aExtension;
      public Sqlite3.Vdbe pVdbe;
      public int activeVdbeCnt;
      public int writeVdbeCnt;
      public int vdbeExecCnt;
      public Sqlite3.dxTrace xTrace;
      public object pTraceArg;
      public Sqlite3.dxProfile xProfile;
      public object pProfileArg;
      public object pCommitArg;
      public Sqlite3.dxCommitCallback xCommitCallback;
      public object pRollbackArg;
      public Sqlite3.dxRollbackCallback xRollbackCallback;
      public object pUpdateArg;
      public Sqlite3.dxUpdateCallback xUpdateCallback;
      public Sqlite3.dxCollNeeded xCollNeeded;
      public Sqlite3.dxCollNeeded xCollNeeded16;
      public object pCollNeededArg;
      public Sqlite3.Mem pErr;
      public string zErrMsg;
      public string zErrMsg16;
      public Sqlite3.sqlite3._u1 u1;
      public Sqlite3.Lookaside lookaside = new Sqlite3.Lookaside();
      public Sqlite3.dxProgress xProgress;
      public object pProgressArg;
      public int nProgressOps;
      public Sqlite3.FuncDefHash aFunc = new Sqlite3.FuncDefHash();
      public Sqlite3.Hash aCollSeq = new Sqlite3.Hash();
      public Sqlite3.BusyHandler busyHandler = new Sqlite3.BusyHandler();
      public int busyTimeout;
      public Sqlite3.Db[] aDbStatic = new Sqlite3.Db[2]
      {
        new Sqlite3.Db(),
        new Sqlite3.Db()
      };
      public Sqlite3.Savepoint pSavepoint;
      public int nSavepoint;
      public int nStatement;
      public byte isTransactionSavepoint;
      public long nDeferredCons;
      public int pnBytesFreed;

      public class sqlite3InitInfo
      {
        public int iDb;
        public int newTnum;
        public byte busy;
        public byte orphanTrigger;
      }

      public struct _u1
      {
        public bool isInterrupted;
        public double notUsed1;
      }
    }

    public class FuncDef
    {
      public short nArg;
      public byte iPrefEnc;
      public byte flags;
      public object pUserData;
      public Sqlite3.FuncDef pNext;
      public Sqlite3.dxFunc xFunc;
      public Sqlite3.dxStep xStep;
      public Sqlite3.dxFinal xFinalize;
      public string zName;
      public Sqlite3.FuncDef pHash;
      public Sqlite3.FuncDestructor pDestructor;

      public FuncDef()
      {
      }

      public FuncDef(
        short nArg,
        byte iPrefEnc,
        byte iflags,
        object pUserData,
        Sqlite3.FuncDef pNext,
        Sqlite3.dxFunc xFunc,
        Sqlite3.dxStep xStep,
        Sqlite3.dxFinal xFinalize,
        string zName,
        Sqlite3.FuncDef pHash,
        Sqlite3.FuncDestructor pDestructor)
      {
        this.nArg = nArg;
        this.iPrefEnc = iPrefEnc;
        this.flags = iflags;
        this.pUserData = pUserData;
        this.pNext = pNext;
        this.xFunc = xFunc;
        this.xStep = xStep;
        this.xFinalize = xFinalize;
        this.zName = zName;
        this.pHash = pHash;
        this.pDestructor = pDestructor;
      }

      public FuncDef(
        string zName,
        byte iPrefEnc,
        short nArg,
        int iArg,
        byte iflags,
        Sqlite3.dxFunc xFunc)
      {
        this.nArg = nArg;
        this.iPrefEnc = iPrefEnc;
        this.flags = iflags;
        this.pUserData = (object) iArg;
        this.pNext = (Sqlite3.FuncDef) null;
        this.xFunc = xFunc;
        this.xStep = (Sqlite3.dxStep) null;
        this.xFinalize = (Sqlite3.dxFinal) null;
        this.zName = zName;
      }

      public FuncDef(
        string zName,
        byte iPrefEnc,
        short nArg,
        int iArg,
        byte iflags,
        Sqlite3.dxStep xStep,
        Sqlite3.dxFinal xFinal)
      {
        this.nArg = nArg;
        this.iPrefEnc = iPrefEnc;
        this.flags = iflags;
        this.pUserData = (object) iArg;
        this.pNext = (Sqlite3.FuncDef) null;
        this.xFunc = (Sqlite3.dxFunc) null;
        this.xStep = xStep;
        this.xFinalize = xFinal;
        this.zName = zName;
      }

      public FuncDef(
        string zName,
        byte iPrefEnc,
        short nArg,
        object arg,
        Sqlite3.dxFunc xFunc,
        byte flags)
      {
        this.nArg = nArg;
        this.iPrefEnc = iPrefEnc;
        this.flags = flags;
        this.pUserData = arg;
        this.pNext = (Sqlite3.FuncDef) null;
        this.xFunc = xFunc;
        this.xStep = (Sqlite3.dxStep) null;
        this.xFinalize = (Sqlite3.dxFinal) null;
        this.zName = zName;
      }

      public Sqlite3.FuncDef Copy() => new Sqlite3.FuncDef()
      {
        nArg = this.nArg,
        iPrefEnc = this.iPrefEnc,
        flags = this.flags,
        pUserData = this.pUserData,
        pNext = this.pNext,
        xFunc = this.xFunc,
        xStep = this.xStep,
        xFinalize = this.xFinalize,
        zName = this.zName,
        pHash = this.pHash,
        pDestructor = this.pDestructor
      };
    }

    public class FuncDestructor
    {
      public int nRef;
      public Sqlite3.dxFDestroy xDestroy;
      public object pUserData;
    }

    public class Savepoint
    {
      public string zName;
      public long nDeferredCons;
      public Sqlite3.Savepoint pNext;
    }

    public class Module
    {
      public Sqlite3.sqlite3_module pModule;
      public string zName;
      public object pAux;
      public Sqlite3.smdxDestroy xDestroy;
    }

    public class Column
    {
      public string zName;
      public Sqlite3.Expr pDflt;
      public string zDflt;
      public string zType;
      public string zColl;
      public byte notNull;
      public byte isPrimKey;
      public char affinity;

      public Sqlite3.Column Copy()
      {
        Sqlite3.Column column = (Sqlite3.Column) this.MemberwiseClone();
        if (column.pDflt != null)
          column.pDflt = this.pDflt.Copy();
        return column;
      }
    }

    public class CollSeq
    {
      public string zName;
      public byte enc;
      public byte type;
      public object pUser;
      public Sqlite3.dxCompare xCmp;
      public Sqlite3.dxDelCollSeq xDel;

      public Sqlite3.CollSeq Copy() => this == null ? (Sqlite3.CollSeq) null : (Sqlite3.CollSeq) this.MemberwiseClone();
    }

    public class VTable
    {
      public Sqlite3.sqlite3 db;
      public Sqlite3.Module pMod;
      public Sqlite3.sqlite3_vtab pVtab;
      public int nRef;
      public byte bConstraint;
      public int iSavepoint;
      public Sqlite3.VTable pNext;
    }

    public class Table
    {
      public string zName;
      public int iPKey;
      public int nCol;
      public Sqlite3.Column[] aCol;
      public Sqlite3.Index pIndex;
      public int tnum;
      public uint nRowEst;
      public Sqlite3.Select pSelect;
      public ushort nRef;
      public byte tabFlags;
      public byte keyConf;
      public Sqlite3.FKey pFKey;
      public string zColAff;
      public Sqlite3.Expr pCheck;
      public int addColOffset;
      public Sqlite3.Trigger pTrigger;
      public Sqlite3.Schema pSchema;
      public Sqlite3.Table pNextZombie;

      public Sqlite3.Table Copy()
      {
        if (this == null)
          return (Sqlite3.Table) null;
        Sqlite3.Table table = (Sqlite3.Table) this.MemberwiseClone();
        if (this.pIndex != null)
          table.pIndex = this.pIndex.Copy();
        if (this.pSelect != null)
          table.pSelect = this.pSelect.Copy();
        if (this.pTrigger != null)
          table.pTrigger = this.pTrigger.Copy();
        if (this.pFKey != null)
          table.pFKey = this.pFKey.Copy();
        return table;
      }
    }

    public class FKey
    {
      public Sqlite3.Table pFrom;
      public Sqlite3.FKey pNextFrom;
      public string zTo;
      public Sqlite3.FKey pNextTo;
      public Sqlite3.FKey pPrevTo;
      public int nCol;
      public byte isDeferred;
      public byte[] aAction = new byte[2];
      public Sqlite3.Trigger[] apTrigger = new Sqlite3.Trigger[2];
      public Sqlite3.FKey.sColMap[] aCol;

      public Sqlite3.FKey Copy() => this == null ? (Sqlite3.FKey) null : (Sqlite3.FKey) this.MemberwiseClone();

      public class sColMap
      {
        public int iFrom;
        public string zCol;
      }
    }

    public class KeyInfo
    {
      public Sqlite3.sqlite3 db;
      public byte enc;
      public ushort nField;
      public byte[] aSortOrder;
      public Sqlite3.CollSeq[] aColl = new Sqlite3.CollSeq[1];

      public Sqlite3.KeyInfo Copy() => (Sqlite3.KeyInfo) this.MemberwiseClone();
    }

    public class UnpackedRecord
    {
      public Sqlite3.KeyInfo pKeyInfo;
      public ushort nField;
      public ushort flags;
      public long rowid;
      public Sqlite3.Mem[] aMem;
    }

    public class Index
    {
      public string zName;
      public int nColumn;
      public int[] aiColumn;
      public int[] aiRowEst;
      public Sqlite3.Table pTable;
      public int tnum;
      public byte onError;
      public byte autoIndex;
      public byte bUnordered;
      public string zColAff;
      public Sqlite3.Index pNext;
      public Sqlite3.Schema pSchema;
      public byte[] aSortOrder;
      public string[] azColl;
      public Sqlite3.IndexSample[] aSample;

      public Sqlite3.Index Copy() => this == null ? (Sqlite3.Index) null : (Sqlite3.Index) this.MemberwiseClone();
    }

    public class IndexSample
    {
      public Sqlite3.IndexSample._u u;
      public byte eType;
      public byte nByte;

      public struct _u
      {
        public string z;
        public byte[] zBLOB;
        public double r;
      }
    }

    public class Token
    {
      public string z;
      public int n;

      public Token()
      {
        this.z = (string) null;
        this.n = 0;
      }

      public Token(string z, int n)
      {
        this.z = z;
        this.n = n;
      }

      public Sqlite3.Token Copy()
      {
        if (this == null)
          return (Sqlite3.Token) null;
        Sqlite3.Token token = (Sqlite3.Token) this.MemberwiseClone();
        if (this.z == null || this.z.Length == 0)
          token.n = 0;
        else if (this.n > this.z.Length)
          token.n = this.z.Length;
        return token;
      }
    }

    public class AggInfo_col
    {
      public Sqlite3.Table pTab;
      public int iTable;
      public int iColumn;
      public int iSorterColumn;
      public int iMem;
      public Sqlite3.Expr pExpr;
    }

    public class AggInfo_func
    {
      public Sqlite3.Expr pExpr;
      public Sqlite3.FuncDef pFunc;
      public int iMem;
      public int iDistinct;
    }

    public class AggInfo
    {
      public byte directMode;
      public byte useSortingIdx;
      public int sortingIdx;
      public Sqlite3.ExprList pGroupBy;
      public int nSortingColumn;
      public Sqlite3.AggInfo_col[] aCol;
      public int nColumn;
      public int nColumnAlloc;
      public int nAccumulator;
      public Sqlite3.AggInfo_func[] aFunc;
      public int nFunc;
      public int nFuncAlloc;

      public Sqlite3.AggInfo Copy()
      {
        if (this == null)
          return (Sqlite3.AggInfo) null;
        Sqlite3.AggInfo aggInfo = (Sqlite3.AggInfo) this.MemberwiseClone();
        if (this.pGroupBy != null)
          aggInfo.pGroupBy = this.pGroupBy.Copy();
        return aggInfo;
      }
    }

    public class Expr
    {
      public byte op;
      public char affinity;
      public ushort flags;
      public Sqlite3.Expr._u u;
      public Sqlite3.Expr pLeft;
      public Sqlite3.Expr pRight;
      public Sqlite3.Expr._x x;
      public Sqlite3.CollSeq pColl;
      public int iTable;
      public short iColumn;
      public short iAgg;
      public short iRightJoinTable;
      public byte flags2;
      public byte op2;
      public Sqlite3.AggInfo pAggInfo;
      public Sqlite3.Table pTab;
      public int nHeight;
      public Sqlite3.Table pZombieTab;

      public void CopyFrom(Sqlite3.Expr cf)
      {
        this.op = cf.op;
        this.affinity = cf.affinity;
        this.flags = cf.flags;
        this.u = cf.u;
        this.pColl = cf.pColl == null ? (Sqlite3.CollSeq) null : cf.pColl.Copy();
        this.iTable = cf.iTable;
        this.iColumn = cf.iColumn;
        this.pAggInfo = cf.pAggInfo == null ? (Sqlite3.AggInfo) null : cf.pAggInfo.Copy();
        this.iAgg = cf.iAgg;
        this.iRightJoinTable = cf.iRightJoinTable;
        this.flags2 = cf.flags2;
        this.pTab = cf.pTab == null ? (Sqlite3.Table) null : cf.pTab;
        this.nHeight = cf.nHeight;
        this.pZombieTab = cf.pZombieTab;
        this.pLeft = cf.pLeft == null ? (Sqlite3.Expr) null : cf.pLeft.Copy();
        this.pRight = cf.pRight == null ? (Sqlite3.Expr) null : cf.pRight.Copy();
        this.x.pList = cf.x.pList == null ? (Sqlite3.ExprList) null : cf.x.pList.Copy();
        this.x.pSelect = cf.x.pSelect == null ? (Sqlite3.Select) null : cf.x.pSelect.Copy();
      }

      public Sqlite3.Expr Copy() => this == null ? (Sqlite3.Expr) null : this.Copy((int) this.flags);

      public Sqlite3.Expr Copy(int flag)
      {
        Sqlite3.Expr expr = new Sqlite3.Expr();
        expr.op = this.op;
        expr.affinity = this.affinity;
        expr.flags = this.flags;
        expr.u = this.u;
        if ((flag & 8192) != 0)
          return expr;
        if (this.pLeft != null)
          expr.pLeft = this.pLeft.Copy();
        if (this.pRight != null)
          expr.pRight = this.pRight.Copy();
        expr.x = this.x;
        expr.pColl = this.pColl;
        if ((flag & 4096) != 0)
          return expr;
        expr.iTable = this.iTable;
        expr.iColumn = this.iColumn;
        expr.iAgg = this.iAgg;
        expr.iRightJoinTable = this.iRightJoinTable;
        expr.flags2 = this.flags2;
        expr.op2 = this.op2;
        expr.pAggInfo = this.pAggInfo;
        expr.pTab = this.pTab;
        expr.nHeight = this.nHeight;
        expr.pZombieTab = this.pZombieTab;
        return expr;
      }

      public struct _u
      {
        public string zToken;
        public int iValue;
      }

      public struct _x
      {
        public Sqlite3.ExprList pList;
        public Sqlite3.Select pSelect;
      }
    }

    public class ExprList_item
    {
      public Sqlite3.Expr pExpr;
      public string zName;
      public string zSpan;
      public byte sortOrder;
      public byte done;
      public ushort iCol;
      public ushort iAlias;
    }

    public class ExprList
    {
      public int nExpr;
      public int nAlloc;
      public int iECursor;
      public Sqlite3.ExprList_item[] a;

      public Sqlite3.ExprList Copy()
      {
        if (this == null)
          return (Sqlite3.ExprList) null;
        Sqlite3.ExprList exprList = (Sqlite3.ExprList) this.MemberwiseClone();
        this.a.CopyTo((Array) exprList.a, 0);
        return exprList;
      }
    }

    public class ExprSpan
    {
      public Sqlite3.Expr pExpr;
      public string zStart;
      public string zEnd;
    }

    public class IdList_item
    {
      public string zName;
      public int idx;
    }

    public class IdList
    {
      public Sqlite3.IdList_item[] a;
      public int nId;
      public int nAlloc;

      public Sqlite3.IdList Copy()
      {
        if (this == null)
          return (Sqlite3.IdList) null;
        Sqlite3.IdList idList = (Sqlite3.IdList) this.MemberwiseClone();
        this.a.CopyTo((Array) idList.a, 0);
        return idList;
      }
    }

    public class SrcList_item
    {
      public string zDatabase;
      public string zName;
      public string zAlias;
      public Sqlite3.Table pTab;
      public Sqlite3.Select pSelect;
      public byte isPopulated;
      public byte jointype;
      public byte notIndexed;
      public byte iSelectId;
      public int iCursor;
      public Sqlite3.Expr pOn;
      public Sqlite3.IdList pUsing;
      public ulong colUsed;
      public string zIndex;
      public Sqlite3.Index pIndex;
    }

    public class SrcList
    {
      public short nSrc;
      public short nAlloc;
      public Sqlite3.SrcList_item[] a;

      public Sqlite3.SrcList Copy()
      {
        if (this == null)
          return (Sqlite3.SrcList) null;
        Sqlite3.SrcList srcList = (Sqlite3.SrcList) this.MemberwiseClone();
        if (this.a != null)
          this.a.CopyTo((Array) srcList.a, 0);
        return srcList;
      }
    }

    public class WherePlan
    {
      public uint wsFlags;
      public uint nEq;
      public double nRow;
      public Sqlite3.WherePlan._u u = new Sqlite3.WherePlan._u();

      public void Clear()
      {
        this.wsFlags = 0U;
        this.nEq = 0U;
        this.nRow = 0.0;
        this.u.pIdx = (Sqlite3.Index) null;
        this.u.pTerm = (Sqlite3.WhereTerm) null;
        this.u.pVtabIdx = (Sqlite3.sqlite3_index_info) null;
      }

      public class _u
      {
        public Sqlite3.Index pIdx;
        public Sqlite3.WhereTerm pTerm;
        public Sqlite3.sqlite3_index_info pVtabIdx;
      }
    }

    public class InLoop
    {
      public int iCur;
      public int addrInTop;
    }

    public class WhereLevel
    {
      public Sqlite3.WherePlan plan = new Sqlite3.WherePlan();
      public int iLeftJoin;
      public int iTabCur;
      public int iIdxCur;
      public int addrBrk;
      public int addrNxt;
      public int addrCont;
      public int addrFirst;
      public byte iFrom;
      public byte op;
      public byte p5;
      public int p1;
      public int p2;
      public Sqlite3.WhereLevel._u u = new Sqlite3.WhereLevel._u();
      public Sqlite3.sqlite3_index_info pIdxInfo;

      public class _u
      {
        public Sqlite3.WhereLevel._u.__in _in = new Sqlite3.WhereLevel._u.__in();

        public class __in
        {
          public int nIn;
          public Sqlite3.InLoop[] aInLoop;
        }
      }
    }

    public class WhereInfo
    {
      public Sqlite3.Parse pParse;
      public ushort wctrlFlags;
      public byte okOnePass;
      public byte untestedTerms;
      public Sqlite3.SrcList pTabList;
      public int iTop;
      public int iContinue;
      public int iBreak;
      public int nLevel;
      public Sqlite3.WhereClause pWC;
      public double savedNQueryLoop;
      public double nRowOut;
      public Sqlite3.WhereLevel[] a = new Sqlite3.WhereLevel[1]
      {
        new Sqlite3.WhereLevel()
      };
    }

    public class NameContext
    {
      public Sqlite3.Parse pParse;
      public Sqlite3.SrcList pSrcList;
      public Sqlite3.ExprList pEList;
      public int nRef;
      public int nErr;
      public byte allowAgg;
      public byte hasAgg;
      public byte isCheck;
      public int nDepth;
      public Sqlite3.AggInfo pAggInfo;
      public Sqlite3.NameContext pNext;
    }

    public class Select
    {
      public Sqlite3.ExprList pEList;
      public byte op;
      public char affinity;
      public ushort selFlags;
      public Sqlite3.SrcList pSrc;
      public Sqlite3.Expr pWhere;
      public Sqlite3.ExprList pGroupBy;
      public Sqlite3.Expr pHaving;
      public Sqlite3.ExprList pOrderBy;
      public Sqlite3.Select pPrior;
      public Sqlite3.Select pNext;
      public Sqlite3.Select pRightmost;
      public Sqlite3.Expr pLimit;
      public Sqlite3.Expr pOffset;
      public int iLimit;
      public int iOffset;
      public int[] addrOpenEphm = new int[3];
      public double nSelectRow;

      public Sqlite3.Select Copy()
      {
        if (this == null)
          return (Sqlite3.Select) null;
        Sqlite3.Select select = (Sqlite3.Select) this.MemberwiseClone();
        if (this.pEList != null)
          select.pEList = this.pEList.Copy();
        if (this.pSrc != null)
          select.pSrc = this.pSrc.Copy();
        if (this.pWhere != null)
          select.pWhere = this.pWhere.Copy();
        if (this.pGroupBy != null)
          select.pGroupBy = this.pGroupBy.Copy();
        if (this.pHaving != null)
          select.pHaving = this.pHaving.Copy();
        if (this.pOrderBy != null)
          select.pOrderBy = this.pOrderBy.Copy();
        if (this.pPrior != null)
          select.pPrior = this.pPrior.Copy();
        if (this.pNext != null)
          select.pNext = this.pNext.Copy();
        if (this.pRightmost != null)
          select.pRightmost = this.pRightmost.Copy();
        if (this.pLimit != null)
          select.pLimit = this.pLimit.Copy();
        if (this.pOffset != null)
          select.pOffset = this.pOffset.Copy();
        return select;
      }
    }

    public class SelectDest
    {
      public byte eDest;
      public char affinity;
      public int iParm;
      public int iMem;
      public int nMem;

      public SelectDest()
      {
        this.eDest = (byte) 0;
        this.affinity = char.MinValue;
        this.iParm = 0;
        this.iMem = 0;
        this.nMem = 0;
      }

      public SelectDest(byte eDest, char affinity, int iParm)
      {
        this.eDest = eDest;
        this.affinity = affinity;
        this.iParm = iParm;
        this.iMem = 0;
        this.nMem = 0;
      }

      public SelectDest(byte eDest, char affinity, int iParm, int iMem, int nMem)
      {
        this.eDest = eDest;
        this.affinity = affinity;
        this.iParm = iParm;
        this.iMem = iMem;
        this.nMem = nMem;
      }
    }

    public class AutoincInfo
    {
      public Sqlite3.AutoincInfo pNext;
      public Sqlite3.Table pTab;
      public int iDb;
      public int regCtr;
    }

    public class TriggerPrg
    {
      public Sqlite3.Trigger pTrigger;
      public int orconf;
      public Sqlite3.SubProgram pProgram;
      public uint[] aColmask = new uint[2];
      public Sqlite3.TriggerPrg pNext;
    }

    public class yColCache
    {
      public int iTable;
      public int iColumn;
      public byte tempReg;
      public int iLevel;
      public int iReg;
      public int lru;
    }

    public class Parse
    {
      public Sqlite3.sqlite3 db;
      public int rc;
      public string zErrMsg;
      public Sqlite3.Vdbe pVdbe;
      public byte colNamesSet;
      public byte nameClash;
      public byte checkSchema;
      public byte nested;
      public byte parseError;
      public byte nTempReg;
      public byte nTempInUse;
      public int[] aTempReg;
      public int nRangeReg;
      public int iRangeReg;
      public int nErr;
      public int nTab;
      public int nMem;
      public int nSet;
      public int ckBase;
      public int iCacheLevel;
      public int iCacheCnt;
      public byte nColCache;
      public byte iColCache;
      public Sqlite3.yColCache[] aColCache;
      public int writeMask;
      public int cookieMask;
      public byte isMultiWrite;
      public byte mayAbort;
      public int cookieGoto;
      public int[] cookieValue;
      public int regRowid;
      public int regRoot;
      public Sqlite3.AutoincInfo pAinc;
      public int nMaxArg;
      public Sqlite3.Parse pToplevel;
      public Sqlite3.Table pTriggerTab;
      public uint oldmask;
      public uint newmask;
      public byte eTriggerOp;
      public byte eOrconf;
      public byte disableTriggers;
      public double nQueryLoop;
      public int nVar;
      public int nzVar;
      public string[] azVar;
      public Sqlite3.Vdbe pReprepare;
      public int nAlias;
      public int nAliasAlloc;
      public int[] aAlias;
      public byte explain;
      public Sqlite3.Token sNameToken;
      public Sqlite3.Token sLastToken;
      public StringBuilder zTail;
      public Sqlite3.Table pNewTable;
      public Sqlite3.Trigger pNewTrigger;
      public string zAuthContext;
      public int nHeight;
      public Sqlite3.Table pZombieTab;
      public Sqlite3.TriggerPrg pTriggerPrg;
      public int iSelectId;
      public int iNextSelectId;
      private Sqlite3.Parse[] SaveBuf = new Sqlite3.Parse[10];

      public Parse()
      {
        this.aTempReg = new int[8];
        this.aColCache = new Sqlite3.yColCache[10];
        for (int index = 0; index < this.aColCache.Length; ++index)
          this.aColCache[index] = new Sqlite3.yColCache();
        this.cookieValue = new int[12];
        this.sLastToken = new Sqlite3.Token();
      }

      public void ResetMembers()
      {
        this.nVar = 0;
        this.nzVar = 0;
        this.azVar = (string[]) null;
        this.nAlias = 0;
        this.nAliasAlloc = 0;
        this.aAlias = (int[]) null;
        this.explain = (byte) 0;
        this.sNameToken = new Sqlite3.Token();
        this.sLastToken = new Sqlite3.Token();
        this.zTail.Length = 0;
        this.pNewTable = (Sqlite3.Table) null;
        this.pNewTrigger = (Sqlite3.Trigger) null;
        this.zAuthContext = (string) null;
        this.nHeight = 0;
        this.pZombieTab = (Sqlite3.Table) null;
        this.pTriggerPrg = (Sqlite3.TriggerPrg) null;
      }

      public void RestoreMembers()
      {
        if (this.SaveBuf[(int) this.nested] == null)
          return;
        this.nVar = this.SaveBuf[(int) this.nested].nVar;
        this.nzVar = this.SaveBuf[(int) this.nested].nzVar;
        this.azVar = this.SaveBuf[(int) this.nested].azVar;
        this.nAlias = this.SaveBuf[(int) this.nested].nAlias;
        this.nAliasAlloc = this.SaveBuf[(int) this.nested].nAliasAlloc;
        this.aAlias = this.SaveBuf[(int) this.nested].aAlias;
        this.explain = this.SaveBuf[(int) this.nested].explain;
        this.sNameToken = this.SaveBuf[(int) this.nested].sNameToken;
        this.sLastToken = this.SaveBuf[(int) this.nested].sLastToken;
        this.zTail = this.SaveBuf[(int) this.nested].zTail;
        this.pNewTable = this.SaveBuf[(int) this.nested].pNewTable;
        this.pNewTrigger = this.SaveBuf[(int) this.nested].pNewTrigger;
        this.zAuthContext = this.SaveBuf[(int) this.nested].zAuthContext;
        this.nHeight = this.SaveBuf[(int) this.nested].nHeight;
        this.pZombieTab = this.SaveBuf[(int) this.nested].pZombieTab;
        this.pTriggerPrg = this.SaveBuf[(int) this.nested].pTriggerPrg;
        this.SaveBuf[(int) this.nested] = (Sqlite3.Parse) null;
      }

      public void SaveMembers()
      {
        this.SaveBuf[(int) this.nested] = new Sqlite3.Parse();
        this.SaveBuf[(int) this.nested].nVar = this.nVar;
        this.SaveBuf[(int) this.nested].nzVar = this.nzVar;
        this.SaveBuf[(int) this.nested].azVar = this.azVar;
        this.SaveBuf[(int) this.nested].nAlias = this.nAlias;
        this.SaveBuf[(int) this.nested].nAliasAlloc = this.nAliasAlloc;
        this.SaveBuf[(int) this.nested].aAlias = this.aAlias;
        this.SaveBuf[(int) this.nested].explain = this.explain;
        this.SaveBuf[(int) this.nested].sNameToken = this.sNameToken;
        this.SaveBuf[(int) this.nested].sLastToken = this.sLastToken;
        this.SaveBuf[(int) this.nested].zTail = this.zTail;
        this.SaveBuf[(int) this.nested].pNewTable = this.pNewTable;
        this.SaveBuf[(int) this.nested].pNewTrigger = this.pNewTrigger;
        this.SaveBuf[(int) this.nested].zAuthContext = this.zAuthContext;
        this.SaveBuf[(int) this.nested].nHeight = this.nHeight;
        this.SaveBuf[(int) this.nested].pZombieTab = this.pZombieTab;
        this.SaveBuf[(int) this.nested].pTriggerPrg = this.pTriggerPrg;
      }
    }

    public class AuthContext
    {
      public string zAuthContext;
      public Sqlite3.Parse pParse;
    }

    public class Trigger
    {
      public string zName;
      public string table;
      public byte op;
      public byte tr_tm;
      public Sqlite3.Expr pWhen;
      public Sqlite3.IdList pColumns;
      public Sqlite3.Schema pSchema;
      public Sqlite3.Schema pTabSchema;
      public Sqlite3.TriggerStep step_list;
      public Sqlite3.Trigger pNext;

      public Sqlite3.Trigger Copy()
      {
        if (this == null)
          return (Sqlite3.Trigger) null;
        Sqlite3.Trigger trigger = (Sqlite3.Trigger) this.MemberwiseClone();
        if (this.pWhen != null)
          trigger.pWhen = this.pWhen.Copy();
        if (this.pColumns != null)
          trigger.pColumns = this.pColumns.Copy();
        if (this.pSchema != null)
          trigger.pSchema = this.pSchema.Copy();
        if (this.pTabSchema != null)
          trigger.pTabSchema = this.pTabSchema.Copy();
        if (this.step_list != null)
          trigger.step_list = this.step_list.Copy();
        if (this.pNext != null)
          trigger.pNext = this.pNext.Copy();
        return trigger;
      }
    }

    public class TriggerStep
    {
      public byte op;
      public byte orconf;
      public Sqlite3.Trigger pTrig;
      public Sqlite3.Select pSelect;
      public Sqlite3.Token target;
      public Sqlite3.Expr pWhere;
      public Sqlite3.ExprList pExprList;
      public Sqlite3.IdList pIdList;
      public Sqlite3.TriggerStep pNext;
      public Sqlite3.TriggerStep pLast;

      public TriggerStep() => this.target = new Sqlite3.Token();

      public Sqlite3.TriggerStep Copy() => this == null ? (Sqlite3.TriggerStep) null : (Sqlite3.TriggerStep) this.MemberwiseClone();
    }

    public class DbFixer
    {
      public Sqlite3.Parse pParse;
      public string zDb;
      public string zType;
      public Sqlite3.Token pName;
    }

    public class StrAccum
    {
      public Sqlite3.sqlite3 db;
      public StringBuilder zText;
      public int mxAlloc;
      public Sqlite3.Mem Context;

      public StrAccum(int n)
      {
        this.db = (Sqlite3.sqlite3) null;
        this.zText = new StringBuilder(n);
        this.mxAlloc = 0;
        this.Context = (Sqlite3.Mem) null;
      }

      public long nChar => (long) this.zText.Length;

      public bool tooBig => this.mxAlloc > 0 && this.zText.Length > this.mxAlloc;
    }

    public class InitData
    {
      public Sqlite3.sqlite3 db;
      public int iDb;
      public string pzErrMsg;
      public int rc;
    }

    public class Sqlite3Config
    {
      public bool bMemstat;
      public bool bCoreMutex;
      public bool bFullMutex;
      public bool bOpenUri;
      public int mxStrlen;
      public int szLookaside;
      public int nLookaside;
      public Sqlite3.sqlite3_mem_methods m;
      public Sqlite3.sqlite3_mutex_methods mutex;
      public Sqlite3.sqlite3_pcache_methods pcache;
      public byte[] pHeap;
      public int nHeap;
      public int mnReq;
      public int mxReq;
      public byte[][] pScratch2;
      public byte[][] pScratch;
      public int szScratch;
      public int nScratch;
      public Sqlite3.MemPage pPage;
      public int szPage;
      public int nPage;
      public int mxParserStack;
      public bool sharedCacheEnabled;
      public int isInit;
      public int inProgress;
      public int isMutexInit;
      public int isMallocInit;
      public int isPCacheInit;
      public Sqlite3.sqlite3_mutex pInitMutex;
      public int nRefInitMutex;
      public Sqlite3.dxLog xLog;
      public object pLogArg;
      public bool bLocaltimeFault;

      public Sqlite3Config(
        int bMemstat,
        int bCoreMutex,
        bool bFullMutex,
        bool bOpenUri,
        int mxStrlen,
        int szLookaside,
        int nLookaside,
        Sqlite3.sqlite3_mem_methods m,
        Sqlite3.sqlite3_mutex_methods mutex,
        Sqlite3.sqlite3_pcache_methods pcache,
        byte[] pHeap,
        int nHeap,
        int mnReq,
        int mxReq,
        byte[][] pScratch,
        int szScratch,
        int nScratch,
        Sqlite3.MemPage pPage,
        int szPage,
        int nPage,
        int mxParserStack,
        bool sharedCacheEnabled,
        int isInit,
        int inProgress,
        int isMutexInit,
        int isMallocInit,
        int isPCacheInit,
        Sqlite3.sqlite3_mutex pInitMutex,
        int nRefInitMutex,
        Sqlite3.dxLog xLog,
        object pLogArg,
        bool bLocaltimeFault)
      {
        this.bMemstat = bMemstat != 0;
        this.bCoreMutex = bCoreMutex != 0;
        this.bOpenUri = bOpenUri;
        this.bFullMutex = bFullMutex;
        this.mxStrlen = mxStrlen;
        this.szLookaside = szLookaside;
        this.nLookaside = nLookaside;
        this.m = m;
        this.mutex = mutex;
        this.pcache = pcache;
        this.pHeap = pHeap;
        this.nHeap = nHeap;
        this.mnReq = mnReq;
        this.mxReq = mxReq;
        this.pScratch = pScratch;
        this.szScratch = szScratch;
        this.nScratch = nScratch;
        this.pPage = pPage;
        this.szPage = szPage;
        this.nPage = nPage;
        this.mxParserStack = mxParserStack;
        this.sharedCacheEnabled = sharedCacheEnabled;
        this.isInit = isInit;
        this.inProgress = inProgress;
        this.isMutexInit = isMutexInit;
        this.isMallocInit = isMallocInit;
        this.isPCacheInit = isPCacheInit;
        this.pInitMutex = pInitMutex;
        this.nRefInitMutex = nRefInitMutex;
        this.xLog = xLog;
        this.pLogArg = pLogArg;
        this.bLocaltimeFault = bLocaltimeFault;
      }
    }

    public class Walker
    {
      public Sqlite3.dxExprCallback xExprCallback;
      public Sqlite3.dxSelectCallback xSelectCallback;
      public Sqlite3.Parse pParse;
      public Sqlite3.Walker.uw u;

      public struct uw
      {
        public Sqlite3.NameContext pNC;
        public int i;
      }
    }

    public class sqlite3StatType
    {
      public int[] nowValue = new int[10];
      public int[] mxValue = new int[10];
    }

    public class VdbeCursor
    {
      public Sqlite3.BtCursor pCursor;
      public Sqlite3.Btree pBt;
      public Sqlite3.KeyInfo pKeyInfo;
      public int iDb;
      public int pseudoTableReg;
      public int nField;
      public bool zeroed;
      public bool rowidIsValid;
      public bool atFirst;
      public bool useRandomRowid;
      public bool nullRow;
      public bool deferredMoveto;
      public bool isTable;
      public bool isIndex;
      public bool isOrdered;
      public long seqCount;
      public long movetoTarget;
      public long lastRowid;
      public int seekResult;
      public uint cacheStatus;
      public uint payloadSize;
      public uint[] aType;
      public uint[] aOffset;
      public int aRow;

      public Sqlite3.VdbeCursor Copy() => (Sqlite3.VdbeCursor) this.MemberwiseClone();
    }

    public class VdbeFrame
    {
      public Sqlite3.Vdbe v;
      public int pc;
      public Sqlite3.VdbeOp[] aOp;
      public int nOp;
      public Sqlite3.Mem[] aMem;
      public int nMem;
      public Sqlite3.VdbeCursor[] apCsr;
      public ushort nCursor;
      public int token;
      public int nChildMem;
      public int nChildCsr;
      public long lastRowid;
      public int nChange;
      public Sqlite3.VdbeFrame pParent;
      public Sqlite3.Mem[] aChildMem;
      public Sqlite3.VdbeCursor[] aChildCsr;
    }

    public class Mem
    {
      public Sqlite3.sqlite3 db;
      public string z;
      public double r;
      public Sqlite3.Mem.union_ip u;
      public byte[] zBLOB;
      public int n;
      public ushort flags;
      public byte type;
      public byte enc;
      public Sqlite3.dxDel xDel;
      public Sqlite3.Mem _Mem;
      public Sqlite3.SumCtx _SumCtx;
      public Sqlite3.SubProgram[] _SubProgram;
      public Sqlite3.StrAccum _StrAccum;
      public object _MD5Context;

      public Mem()
      {
      }

      public Mem(
        Sqlite3.sqlite3 db,
        string z,
        double r,
        int i,
        int n,
        ushort flags,
        byte type,
        byte enc)
      {
        this.db = db;
        this.z = z;
        this.r = r;
        this.u.i = (long) i;
        this.n = n;
        this.flags = flags;
        this.type = type;
        this.enc = enc;
      }

      public void CopyTo(ref Sqlite3.Mem ct)
      {
        if (ct == null)
          ct = new Sqlite3.Mem();
        ct.u = this.u;
        ct.r = this.r;
        ct.db = this.db;
        ct.z = this.z;
        if (this.zBLOB == null)
        {
          ct.zBLOB = (byte[]) null;
        }
        else
        {
          ct.zBLOB = Sqlite3.sqlite3Malloc(this.zBLOB.Length);
          Buffer.BlockCopy((Array) this.zBLOB, 0, (Array) ct.zBLOB, 0, this.zBLOB.Length);
        }
        ct.n = this.n;
        ct.flags = this.flags;
        ct.type = this.type;
        ct.enc = this.enc;
        ct.xDel = this.xDel;
      }

      public struct union_ip
      {
        public long i;
        public int nZero;
        public Sqlite3.FuncDef pDef;
        public Sqlite3.RowSet pRowSet;
        public Sqlite3.VdbeFrame pFrame;
      }
    }

    public class AuxData
    {
      public object pAux;
    }

    public class VdbeFunc : Sqlite3.FuncDef
    {
      public Sqlite3.FuncDef pFunc;
      public int nAux;
      public Sqlite3.AuxData[] apAux = new Sqlite3.AuxData[2];
    }

    public class sqlite3_context
    {
      public Sqlite3.FuncDef pFunc;
      public Sqlite3.VdbeFunc pVdbeFunc;
      public Sqlite3.Mem s = new Sqlite3.Mem();
      public Sqlite3.Mem pMem;
      public int isError;
      public Sqlite3.CollSeq pColl;
    }

    public class Vdbe
    {
      public Sqlite3.sqlite3 db;
      public Sqlite3.VdbeOp[] aOp;
      public Sqlite3.Mem[] aMem;
      public Sqlite3.Mem[] apArg;
      public Sqlite3.Mem[] aColName;
      public Sqlite3.Mem[] pResultSet;
      public int nMem;
      public int nOp;
      public int nOpAlloc;
      public int nLabel;
      public int nLabelAlloc;
      public int[] aLabel;
      public ushort nResColumn;
      public ushort nCursor;
      public uint magic;
      public string zErrMsg;
      public Sqlite3.Vdbe pPrev;
      public Sqlite3.Vdbe pNext;
      public Sqlite3.VdbeCursor[] apCsr;
      public Sqlite3.Mem[] aVar;
      public string[] azVar;
      public short nVar;
      public short nzVar;
      public uint cacheCtr;
      public int pc;
      public int rc;
      public byte errorAction;
      public int explain;
      public bool changeCntOn;
      public bool expired;
      public byte runOnlyOnce;
      public int minWriteFileFormat;
      public int inVtabMethod;
      public bool usesStmtJournal;
      public bool readOnly;
      public int nChange;
      public bool isPrepareV2;
      public int btreeMask;
      public int lockMask;
      public int iStatement;
      public int[] aCounter = new int[3];
      public long startTime;
      public long nFkConstraint;
      public long nStmtDefCons;
      public string zSql = "";
      public object pFree;
      public Sqlite3.VdbeFrame pFrame;
      public Sqlite3.VdbeFrame pDelFrame;
      public int nFrame;
      public uint expmask;
      public Sqlite3.SubProgram pProgram;

      public Sqlite3.Vdbe Copy() => (Sqlite3.Vdbe) this.MemberwiseClone();

      public void CopyTo(Sqlite3.Vdbe ct)
      {
        ct.db = this.db;
        ct.pPrev = this.pPrev;
        ct.pNext = this.pNext;
        ct.nOp = this.nOp;
        ct.nOpAlloc = this.nOpAlloc;
        ct.aOp = this.aOp;
        ct.nLabel = this.nLabel;
        ct.nLabelAlloc = this.nLabelAlloc;
        ct.aLabel = this.aLabel;
        ct.apArg = this.apArg;
        ct.aColName = this.aColName;
        ct.nCursor = this.nCursor;
        ct.apCsr = this.apCsr;
        ct.aVar = this.aVar;
        ct.azVar = this.azVar;
        ct.nVar = this.nVar;
        ct.nzVar = this.nzVar;
        ct.magic = this.magic;
        ct.nMem = this.nMem;
        ct.aMem = this.aMem;
        ct.cacheCtr = this.cacheCtr;
        ct.pc = this.pc;
        ct.rc = this.rc;
        ct.errorAction = this.errorAction;
        ct.nResColumn = this.nResColumn;
        ct.zErrMsg = this.zErrMsg;
        ct.pResultSet = this.pResultSet;
        ct.explain = this.explain;
        ct.changeCntOn = this.changeCntOn;
        ct.expired = this.expired;
        ct.minWriteFileFormat = this.minWriteFileFormat;
        ct.inVtabMethod = this.inVtabMethod;
        ct.usesStmtJournal = this.usesStmtJournal;
        ct.readOnly = this.readOnly;
        ct.nChange = this.nChange;
        ct.isPrepareV2 = this.isPrepareV2;
        ct.startTime = this.startTime;
        ct.btreeMask = this.btreeMask;
        ct.lockMask = this.lockMask;
        this.aCounter.CopyTo((Array) ct.aCounter, 0);
        ct.zSql = this.zSql;
        ct.pFree = this.pFree;
        ct.nFkConstraint = this.nFkConstraint;
        ct.nStmtDefCons = this.nStmtDefCons;
        ct.iStatement = this.iStatement;
        ct.pFrame = this.pFrame;
        ct.nFrame = this.nFrame;
        ct.expmask = this.expmask;
        ct.pProgram = this.pProgram;
      }
    }

    public class union_p4
    {
      public int i;
      public object p;
      public string z;
      public long pI64;
      public double pReal;
      public Sqlite3.FuncDef pFunc;
      public Sqlite3.VdbeFunc pVdbeFunc;
      public Sqlite3.CollSeq pColl;
      public Sqlite3.Mem pMem;
      public Sqlite3.VTable pVtab;
      public Sqlite3.KeyInfo pKeyInfo;
      public int[] ai;
      public Sqlite3.SubProgram pProgram;
      public Sqlite3.dxDel pFuncDel;
    }

    public class VdbeOp
    {
      public byte opcode;
      public int p4type;
      public byte opflags;
      public byte p5;
      public int p1;
      public int p2;
      public int p3;
      public Sqlite3.union_p4 p4 = new Sqlite3.union_p4();
    }

    public class SubProgram
    {
      public Sqlite3.VdbeOp[] aOp;
      public int nOp;
      public int nMem;
      public int nCsr;
      public int token;
      public Sqlite3.SubProgram pNext;
    }

    public struct VdbeOpList
    {
      public byte opcode;
      public int p1;
      public int p2;
      public int p3;

      public VdbeOpList(byte opcode, int p1, int p2, int p3)
      {
        this.opcode = opcode;
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
      }
    }

    public class WhereTerm
    {
      public Sqlite3.Expr pExpr;
      public int iParent;
      public int leftCursor;
      public Sqlite3.WhereTerm._u u = new Sqlite3.WhereTerm._u();
      public ushort eOperator;
      public byte wtFlags;
      public byte nChild;
      public Sqlite3.WhereClause pWC;
      public ulong prereqRight;
      public ulong prereqAll;

      public class _u
      {
        public int leftColumn;
        public Sqlite3.WhereOrInfo pOrInfo;
        public Sqlite3.WhereAndInfo pAndInfo;
      }
    }

    public class WhereClause
    {
      public Sqlite3.Parse pParse;
      public Sqlite3.WhereMaskSet pMaskSet;
      public ulong vmask;
      public byte op;
      public int nTerm;
      public int nSlot;
      public Sqlite3.WhereTerm[] a;
      public Sqlite3.WhereTerm[] aStatic = new Sqlite3.WhereTerm[8];

      public void CopyTo(Sqlite3.WhereClause wc)
      {
        wc.pParse = this.pParse;
        wc.pMaskSet = new Sqlite3.WhereMaskSet();
        this.pMaskSet.CopyTo(wc.pMaskSet);
        wc.op = this.op;
        wc.nTerm = this.nTerm;
        wc.nSlot = this.nSlot;
        wc.a = (Sqlite3.WhereTerm[]) this.a.Clone();
        wc.aStatic = (Sqlite3.WhereTerm[]) this.aStatic.Clone();
      }
    }

    public class WhereOrInfo
    {
      public Sqlite3.WhereClause wc = new Sqlite3.WhereClause();
      public ulong indexable;
    }

    public class WhereAndInfo
    {
      public Sqlite3.WhereClause wc = new Sqlite3.WhereClause();
    }

    public class WhereMaskSet
    {
      public int n;
      public int[] ix = new int[64];

      public void CopyTo(Sqlite3.WhereMaskSet wms)
      {
        wms.n = this.n;
        wms.ix = (int[]) this.ix.Clone();
      }
    }

    public class WhereCost
    {
      public Sqlite3.WherePlan plan = new Sqlite3.WherePlan();
      public double rCost;
      public ulong used;

      public void Clear()
      {
        this.plan.Clear();
        this.rCost = 0.0;
        this.used = 0UL;
      }
    }

    public class tm
    {
      public int tm_sec;
      public int tm_min;
      public int tm_hour;
      public int tm_mday;
      public int tm_mon;
      public int tm_year;
      public int tm_wday;
      public int tm_yday;
      public int tm_isdst;
    }

    public struct FILETIME
    {
      public uint dwLowDateTime;
      public uint dwHighDateTime;
    }

    private class SQLite3UpperToLower
    {
      private static int[] sqlite3UpperToLower = new int[256]
      {
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        91,
        92,
        93,
        94,
        95,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        124,
        125,
        126,
        (int) sbyte.MaxValue,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        187,
        188,
        189,
        190,
        191,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252,
        253,
        254,
        (int) byte.MaxValue
      };

      public int this[int index] => index < Sqlite3.SQLite3UpperToLower.sqlite3UpperToLower.Length ? Sqlite3.SQLite3UpperToLower.sqlite3UpperToLower[index] : index;

      public int this[uint index] => (long) index < (long) Sqlite3.SQLite3UpperToLower.sqlite3UpperToLower.Length ? Sqlite3.SQLite3UpperToLower.sqlite3UpperToLower[(int) index] : (int) index;
    }
  }
}
