// Decompiled with JetBrains decompiler
// Type: SmartAssembly.SmartUsageCore.UsageCountStore
// Assembly: 5, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D96FE905-3567-4568-B7BF-8C667D038E34
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.Win32.DarkKomet.aykq-fdc0862a8406ebbcbbf4f093602f275a5f88cc2d88940d115e6108504c21b1f4.exe

using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.IsolatedStorage;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace SmartAssembly.SmartUsageCore
{
  public static class UsageCountStore
  {
    private const string AssemblyID = "{100fd8cd-4fe2-410e-8c33-ae1af08ef31d}";
    private static readonly string s_BuildHash;
    private static readonly string s_UsageFile;
    private static readonly string s_DynamicUsageFolder;
    private static readonly string s_UsageFileLock;
    private static readonly IsolatedStorageFile s_IsolatedStorage;
    private static readonly Encoding s_Encoding;
    private static readonly HashAlgorithm s_Hash;
    [NonSerialized]
    internal static GetString \u008A;

    static UsageCountStore()
    {
      if (true)
        Strings.CreateGetStringDelegate(typeof (UsageCountStore));
label_2:
      UsageCountStore.s_BuildHash = UsageCountStore.\u008A(1153).Substring(1, 8);
      UsageCountStore.s_UsageFile = Path.Combine(UsageCountStore.s_BuildHash, UsageCountStore.\u008A(2159));
      do
      {
        UsageCountStore.s_DynamicUsageFolder = Path.Combine(UsageCountStore.s_BuildHash, UsageCountStore.\u008A(2176));
        do
        {
          UsageCountStore.s_UsageFileLock = Path.Combine(UsageCountStore.s_BuildHash, UsageCountStore.\u008A(2181));
          UsageCountStore.s_Encoding = Encoding.UTF8;
          do
          {
            UsageCountStore.s_Hash = (HashAlgorithm) new MD5CryptoServiceProvider();
          }
          while (false);
          if (true)
            UsageCountStore.s_IsolatedStorage = IsolatedStorageFile.GetUserStoreForAssembly();
          else
            goto label_2;
        }
        while (false);
        UsageCountStore.s_IsolatedStorage.CreateDirectory(UsageCountStore.s_BuildHash);
      }
      while (false);
      UsageCountStore.s_IsolatedStorage.CreateDirectory(UsageCountStore.s_DynamicUsageFolder);
    }

    private static IDisposable GetGlobalUsageCountFileLock() => (IDisposable) new UsageCountStore.DisposableMutex(UsageCountStore.s_UsageFileLock);

    private static IsolatedStorageFileStream TryOpenLockFile()
    {
      try
      {
        IsolatedStorageFileStream storageFileStream = new IsolatedStorageFileStream(UsageCountStore.s_UsageFileLock, FileMode.Create, FileAccess.Read, FileShare.None);
        byte[] bytes = Encoding.UTF8.GetBytes(Process.GetCurrentProcess().Id.ToString());
        storageFileStream.Write(bytes, 0, bytes.Length);
        return storageFileStream;
      }
      catch (IOException ex)
      {
        return (IsolatedStorageFileStream) null;
      }
    }

    private static IsolatedStorageFileStream OpenIsolatedFile(
      string relativeFile,
      FileMode mode,
      FileAccess access)
    {
      return new IsolatedStorageFileStream(relativeFile, mode, access, FileShare.None, UsageCountStore.s_IsolatedStorage);
    }

    private static void DeleteIsolatedFile(string relativeFile)
    {
      try
      {
        UsageCountStore.s_IsolatedStorage.DeleteFile(relativeFile);
      }
      catch (IsolatedStorageException ex)
      {
      }
    }

    private static void IncrementCount(string usageFile, long countPosition)
    {
      IsolatedStorageFileStream storageFileStream = UsageCountStore.OpenIsolatedFile(usageFile, FileMode.OpenOrCreate, FileAccess.ReadWrite);
      try
      {
        storageFileStream.Position = countPosition + 8L;
        storageFileStream.Position = countPosition;
        ulong num1;
        do
        {
          long num2 = (long) new BinaryReader((Stream) storageFileStream).ReadUInt64();
          if (true)
            num2 = num2;
          num1 = (ulong) (num2 + 1L);
        }
        while (false);
        if (true)
          storageFileStream.Position = countPosition;
        if (false)
          return;
        new BinaryWriter((Stream) storageFileStream).Write(num1);
      }
      finally
      {
        do
        {
          storageFileStream?.Dispose();
        }
        while (false);
      }
    }

    public static void IncrementUsage(uint featureId)
    {
      if (true)
        goto label_6;
label_1:
      IDisposable disposable;
      try
      {
        disposable = UsageCountStore.GetGlobalUsageCountFileLock();
        UsageCountStore.IncrementCount(UsageCountStore.s_UsageFile, (long) (featureId * 8U));
        return;
      }
      catch (Exception ex)
      {
        return;
      }
      finally
      {
        disposable?.Dispose();
      }
label_6:
      disposable = (IDisposable) null;
      goto label_1;
    }

    private static string GetDynamicFeatureUsageFilename(string featureName)
    {
      byte[] bytes = UsageCountStore.s_Encoding.GetBytes(featureName);
      string str1 = Convert.ToBase64String(bytes).Replace('\\', '@');
      string featureUsageFilename;
      if (str1.Length > 50)
      {
        string path2 = new Guid(UsageCountStore.s_Hash.ComputeHash(bytes)).ToString().Substring(0, 18);
        string str2 = Path.Combine(UsageCountStore.s_DynamicUsageFolder, path2);
        featureUsageFilename = str2 + UsageCountStore.\u008A(2186);
        string relativeFile = str2 + UsageCountStore.\u008A(2195);
        IsolatedStorageFileStream storageFileStream = (IsolatedStorageFileStream) null;
        try
        {
          storageFileStream = UsageCountStore.OpenIsolatedFile(relativeFile, FileMode.CreateNew, FileAccess.Write);
          storageFileStream.Write(bytes, 0, bytes.Length);
        }
        catch (IOException ex)
        {
        }
        finally
        {
          storageFileStream?.Close();
        }
      }
      else
        featureUsageFilename = Path.Combine(UsageCountStore.s_DynamicUsageFolder, str1 + UsageCountStore.\u008A(2186));
      return featureUsageFilename;
    }

    public static void IncrementUsage(string featureName)
    {
      do
      {
        if (true)
        {
          if (true)
            goto label_12;
label_2:
          IDisposable disposable;
          try
          {
            disposable = UsageCountStore.GetGlobalUsageCountFileLock();
            string featureUsageFilename = UsageCountStore.GetDynamicFeatureUsageFilename(featureName);
            string usageFile;
            if (true)
              usageFile = featureUsageFilename;
            UsageCountStore.IncrementCount(usageFile, 0L);
            goto label_11;
          }
          catch (Exception ex)
          {
            goto label_11;
          }
          finally
          {
            do
            {
              disposable?.Dispose();
            }
            while (false);
          }
label_12:
          disposable = (IDisposable) null;
          goto label_2;
        }
label_11:;
      }
      while (false);
    }

    private static ulong[] GetUsageCountsFromFile(string fileName)
    {
      ulong[] dst;
      do
      {
        IsolatedStorageFileStream storageFileStream1 = new IsolatedStorageFileStream(fileName, FileMode.OpenOrCreate, FileAccess.Read, FileShare.None, UsageCountStore.s_IsolatedStorage);
        if (true)
          goto label_10;
label_1:
        IsolatedStorageFileStream storageFileStream2;
        try
        {
          byte[] numArray;
          if (true)
            numArray = new byte[storageFileStream2.Length];
          storageFileStream2.Read(numArray, 0, numArray.Length);
          do
          {
            dst = new ulong[numArray.Length / 8];
            Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 0, numArray.Length);
          }
          while (false);
        }
        finally
        {
          storageFileStream2?.Dispose();
        }
        continue;
label_10:
        storageFileStream2 = storageFileStream1;
        goto label_1;
      }
      while (false);
      return dst;
    }

    public static UsageCounts GetAllUsageCountsAndReset()
    {
      IDisposable usageCountFileLock = UsageCountStore.GetGlobalUsageCountFileLock();
      UsageCounts usageCountsAndReset;
      try
      {
        UsageCounts allUsageCounts = UsageCountStore.UnprotectedGetAllUsageCounts();
        if (true)
          goto label_3;
label_2:
        if (true)
          UsageCountStore.UnprotectedReset();
        UsageCounts usageCounts;
        usageCountsAndReset = usageCounts;
        goto label_10;
label_3:
        usageCounts = allUsageCounts;
        goto label_2;
      }
      finally
      {
        do
        {
          usageCountFileLock?.Dispose();
        }
        while (false);
      }
label_10:
      return usageCountsAndReset;
    }

    public static UsageCounts GetAllUsageCounts()
    {
      UsageCounts allUsageCounts;
      do
      {
        if (true)
          goto label_6;
label_5:
        continue;
label_6:
        using (UsageCountStore.GetGlobalUsageCountFileLock())
        {
          do
          {
            allUsageCounts = UsageCountStore.UnprotectedGetAllUsageCounts();
          }
          while (false);
          goto label_5;
        }
      }
      while (false);
      return allUsageCounts;
    }

    public static void Reset()
    {
      using (UsageCountStore.GetGlobalUsageCountFileLock())
        UsageCountStore.UnprotectedReset();
    }

    private static UsageCounts UnprotectedGetAllUsageCounts()
    {
      ulong[] usageCountsFromFile1 = UsageCountStore.GetUsageCountsFromFile(UsageCountStore.s_UsageFile);
      Dictionary<string, ulong> dynamicFeatureCounts = new Dictionary<string, ulong>();
      try
      {
        string[] fileNames = UsageCountStore.s_IsolatedStorage.GetFileNames(UsageCountStore.s_DynamicUsageFolder + UsageCountStore.\u008A(2204));
label_2:
        for (int index = 0; index < fileNames.Length; ++index)
        {
          if (true)
          {
            string str = fileNames[index];
            string withoutExtension = Path.GetFileNameWithoutExtension(str);
            ulong[] usageCountsFromFile2 = UsageCountStore.GetUsageCountsFromFile(Path.Combine(UsageCountStore.s_DynamicUsageFolder, str));
            string relativeFile = Path.Combine(UsageCountStore.s_DynamicUsageFolder, withoutExtension + UsageCountStore.\u008A(2195));
            IsolatedStorageFileStream storageFileStream = (IsolatedStorageFileStream) null;
            try
            {
              storageFileStream = UsageCountStore.OpenIsolatedFile(relativeFile, FileMode.Open, FileAccess.Read);
              byte[] numArray;
              if (true)
                numArray = new byte[storageFileStream.Length];
              storageFileStream.Read(numArray, 0, numArray.Length);
              withoutExtension = UsageCountStore.s_Encoding.GetString(numArray);
            }
            catch (FileNotFoundException ex)
            {
              withoutExtension = UsageCountStore.s_Encoding.GetString(Convert.FromBase64String(withoutExtension.Replace('@', '\\')));
            }
            finally
            {
              storageFileStream?.Close();
            }
            dynamicFeatureCounts[withoutExtension] = usageCountsFromFile2[0];
          }
          else
            goto label_2;
        }
      }
      catch (DirectoryNotFoundException ex)
      {
      }
      return new UsageCounts(usageCountsFromFile1, dynamicFeatureCounts);
    }

    private static void UnprotectedReset()
    {
      UsageCountStore.DeleteIsolatedFile(UsageCountStore.s_UsageFile);
      try
      {
        string[] fileNames = UsageCountStore.s_IsolatedStorage.GetFileNames(UsageCountStore.s_DynamicUsageFolder + UsageCountStore.\u008A(2204));
        if (true)
          goto label_5;
label_2:
        int index;
        while (true)
        {
          int num1 = index;
          int num2 = fileNames.Length;
          if (true)
            num2 = num2;
          if (num1 < num2)
          {
            string str = fileNames[index];
            string withoutExtension = Path.GetFileNameWithoutExtension(str);
            UsageCountStore.DeleteIsolatedFile(Path.Combine(UsageCountStore.s_DynamicUsageFolder, str));
            UsageCountStore.DeleteIsolatedFile(Path.Combine(UsageCountStore.s_DynamicUsageFolder, withoutExtension + UsageCountStore.\u008A(2195)));
            ++index;
          }
          else
            goto label_8;
        }
label_5:
        index = 0;
        goto label_2;
      }
      catch (DirectoryNotFoundException ex)
      {
      }
label_8:
      try
      {
        do
        {
          if (true)
            UsageCountStore.s_IsolatedStorage.DeleteDirectory(UsageCountStore.s_DynamicUsageFolder);
        }
        while (false);
      }
      catch (IsolatedStorageException ex)
      {
      }
      UsageCountStore.s_IsolatedStorage.CreateDirectory(UsageCountStore.s_DynamicUsageFolder);
    }

    private sealed class DisposableMutex : IDisposable
    {
      private static readonly CultureInfo s_EnUSCulture;
      private readonly CultureInfo m_OldCultureInfo;
      private readonly Mutex m_Mutex;
      [NonSerialized]
      internal static GetString \u009E;

      public DisposableMutex(string mutexName)
      {
        this.m_OldCultureInfo = Thread.CurrentThread.CurrentUICulture;
        Thread.CurrentThread.CurrentUICulture = UsageCountStore.DisposableMutex.s_EnUSCulture;
        if (mutexName.Length > 260)
          mutexName = mutexName.Remove(261);
        mutexName = mutexName.Replace(Path.DirectorySeparatorChar, '_');
        this.m_Mutex = new Mutex(false, mutexName);
        try
        {
          this.m_Mutex.WaitOne();
        }
        catch (AbandonedMutexException ex)
        {
        }
      }

      public void Dispose()
      {
        if (true)
        {
          if (true)
            this.m_Mutex.ReleaseMutex();
        }
        else
          goto label_5;
label_4:
        this.m_Mutex.Close();
label_5:
        Thread.CurrentThread.CurrentUICulture = this.m_OldCultureInfo;
        if (false)
          goto label_4;
      }

      static DisposableMutex()
      {
        Strings.CreateGetStringDelegate(typeof (UsageCountStore.DisposableMutex));
        UsageCountStore.DisposableMutex.s_EnUSCulture = CultureInfo.GetCultureInfo(UsageCountStore.DisposableMutex.\u009E(2217));
      }
    }
  }
}
