// Decompiled with JetBrains decompiler
// Type: SmartAssembly.StringsEncoding.Strings
// Assembly: Worker-0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6E50A6D0-CF23-40BF-9617-750EB84D00C0
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.Win32.Generic-122df846a943e419c3a31f65b6e67e7570134612b2dfd45638e0edd23e214036.exe

using SmartAssembly.Zip;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace SmartAssembly.StringsEncoding
{
  public sealed class Strings
  {
    private static readonly string MustUseCache = "1";
    private static readonly string OffsetValue = "171";
    private static readonly byte[] bytes = (byte[]) null;
    private static readonly Dictionary<int, string> hashtable;
    private static readonly object hashtableLock = new object();
    private static readonly bool cacheStrings = false;
    private static readonly int offset = 0;

    public static string Get(int p0)
    {
      p0 ^= 107396847;
      p0 -= Strings.offset;
      return !Strings.cacheStrings ? Strings.GetFromResource(p0) : Strings.GetCachedOrResource(p0);
    }

    public static string GetCachedOrResource(int p0)
    {
      lock (Strings.hashtableLock)
      {
        string cachedOrResource;
        Strings.hashtable.TryGetValue(p0, out cachedOrResource);
        if (cachedOrResource != null)
          return cachedOrResource;
      }
      return Strings.GetFromResource(p0);
    }

    public static string GetFromResource(int p0)
    {
      int num1 = p0;
      byte[] bytes1 = Strings.bytes;
      int index1 = num1;
      int index2 = index1 + 1;
      int num2 = (int) bytes1[index1];
      int count;
      if ((num2 & 128) == 0)
      {
        count = num2;
        if (count == 0)
          return string.Empty;
      }
      else if ((num2 & 64) == 0)
      {
        count = ((num2 & 63) << 8) + (int) Strings.bytes[index2++];
      }
      else
      {
        int num3 = (num2 & 31) << 24;
        byte[] bytes2 = Strings.bytes;
        int index3 = index2;
        int num4 = index3 + 1;
        int num5 = (int) bytes2[index3] << 16;
        int num6 = num3 + num5;
        byte[] bytes3 = Strings.bytes;
        int index4 = num4;
        int num7 = index4 + 1;
        int num8 = (int) bytes3[index4] << 8;
        int num9 = num6 + num8;
        byte[] bytes4 = Strings.bytes;
        int index5 = num7;
        index2 = index5 + 1;
        int num10 = (int) bytes4[index5];
        count = num9 + num10;
      }
      try
      {
        byte[] bytes5 = Convert.FromBase64String(Encoding.UTF8.GetString(Strings.bytes, index2, count));
        string p1 = string.Intern(Encoding.UTF8.GetString(bytes5, 0, bytes5.Length));
        if (Strings.cacheStrings)
          Strings.CacheString(p0, p1);
        return p1;
      }
      catch
      {
        return (string) null;
      }
    }

    public static void CacheString(int p0, string p1)
    {
      try
      {
        lock (Strings.hashtableLock)
          Strings.hashtable.Add(p0, p1);
      }
      catch
      {
      }
    }

    static Strings()
    {
      if (Strings.MustUseCache == "1")
      {
        Strings.cacheStrings = true;
        Strings.hashtable = new Dictionary<int, string>();
      }
      Strings.offset = Convert.ToInt32(Strings.OffsetValue);
      using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("{6bbecf33-c74c-43ea-9c4c-78503f416d39}"))
      {
        int int32 = Convert.ToInt32(manifestResourceStream.Length);
        byte[] numArray = new byte[int32];
        manifestResourceStream.Read(numArray, 0, int32);
        Strings.bytes = SimpleZip.Unzip(numArray);
      }
    }
  }
}
