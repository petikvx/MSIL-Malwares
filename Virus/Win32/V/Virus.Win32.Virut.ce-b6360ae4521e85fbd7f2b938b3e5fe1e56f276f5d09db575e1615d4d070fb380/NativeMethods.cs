// Decompiled with JetBrains decompiler
// Type: Microsoft.Windows.PowerShell.GuiExe.Internal.NativeMethods
// Assembly: powershell_ise, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 8E61B2A9-9D1B-4E14-B095-A239B1610C71
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Virut.ce-b6360ae4521e85fbd7f2b938b3e5fe1e56f276f5d09db575e1615d4d070fb380.exe

using System;
using System.Runtime.InteropServices;
using System.Threading;

namespace Microsoft.Windows.PowerShell.GuiExe.Internal
{
  internal static class NativeMethods
  {
    internal const uint PIPE_ACCESS_DUPLEX = 3;
    internal const uint PIPE_ACCESS_OUTBOUND = 2;
    internal const uint PIPE_ACCESS_INBOUND = 1;
    internal const uint PIPE_TYPE_BYTE = 0;
    internal const uint PIPE_TYPE_MESSAGE = 4;
    internal const uint FILE_FLAG_OVERLAPPED = 1073741824;
    internal const uint PIPE_WAIT = 0;
    internal const uint PIPE_NOWAIT = 1;
    internal const uint PIPE_READMODE_BYTE = 0;
    internal const uint PIPE_READMODE_MESSAGE = 2;
    internal const uint PIPE_ACCEPT_REMOTE_CLIENTS = 0;
    internal const uint PIPE_REJECT_REMOTE_CLIENTS = 8;
    internal const uint PIPE_UNLIMITED_INSTANCES = 255;
    internal const uint ERROR_MORE_DATA = 234;
    internal const uint ERROR_PIPE_CONNECTED = 535;
    internal const uint ERROR_IO_INCOMPLETE = 996;
    internal const uint ERROR_IO_PENDING = 997;
    internal const uint ERROR_NO_DATA = 232;
    internal const uint ERROR_BROKEN_PIPE = 109;
    internal const uint ERROR_PIPE_BUSY = 231;
    internal const uint INFINITE = 4294967295;
    internal const uint GENERIC_READ = 2147483648;
    internal const uint GENERIC_WRITE = 1073741824;
    internal const uint GENERIC_EXECUTE = 536870912;
    internal const uint GENERIC_ALL = 268435456;
    internal const uint CREATE_NEW = 1;
    internal const uint CREATE_ALWAYS = 2;
    internal const uint OPEN_EXISTING = 3;
    internal const uint OPEN_ALWAYS = 4;
    internal const uint TRUNCATE_EXISTING = 5;
    internal const uint TOKEN_QUERY = 8;
    internal const uint SE_GROUP_LOGON_ID = 3221225472;
    internal const int TokenGroups = 2;
    internal static readonly IntPtr INVALID_HANDLE_VALUE = (IntPtr) -1;

    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    internal static extern NamedPipeSafeHandle CreateNamedPipe(
      string lpName,
      uint dwOpenMode,
      uint dwPipeMode,
      uint nMaxInstances,
      uint nOutBufferSize,
      uint nInBufferSize,
      uint nDefaultTimeOut,
      NativeMethods.SECURITY_ATTRIBUTES securityAttributes);

    [DllImport("kernel32.dll", SetLastError = true)]
    internal static extern bool GetOverlappedResult(
      NamedPipeSafeHandle hFile,
      [In] ref NativeOverlapped lpOverlapped,
      out uint lpNumberOfBytesTransferred,
      bool bWait);

    [DllImport("kernel32.dll")]
    internal static extern IntPtr GetCurrentProcess();

    [DllImport("advapi32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool OpenProcessToken(
      IntPtr ProcessHandle,
      uint DesiredAccess,
      out IntPtr TokenHandle);

    [DllImport("Advapi32.Dll", SetLastError = true)]
    internal static extern int GetTokenInformation(
      IntPtr TokenHandle,
      int TokenInformationClass,
      IntPtr TokenInformation,
      uint TokenInformationLength,
      ref uint ReturnLength);

    [DllImport("kernel32.dll", SetLastError = true)]
    internal static extern bool ConnectNamedPipe(
      NamedPipeSafeHandle hNamedPipe,
      [In] ref NativeOverlapped lpOverlapped);

    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    internal static extern bool WaitNamedPipe(string lpNamedPipeName, uint nTimeOut);

    [DllImport("kernel32.dll", SetLastError = true)]
    internal static extern bool DisconnectNamedPipe(NamedPipeSafeHandle hNamedPipe);

    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    internal static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", SetLastError = true)]
    internal static extern bool ReadFile(
      NamedPipeSafeHandle hFile,
      byte[] lpBuffer,
      uint nNumberOfBytesToRead,
      out uint lpNumberOfBytesRead,
      [In] ref NativeOverlapped lpOverlapped);

    [DllImport("kernel32.dll", SetLastError = true)]
    internal static extern bool WriteFile(
      NamedPipeSafeHandle hFile,
      byte[] lpBuffer,
      uint nNumberOfBytesToWrite,
      out uint lpNumberOfBytesWritten,
      [In] IntPtr lpOverlapped);

    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    internal static extern NamedPipeSafeHandle CreateFile(
      string lpFileName,
      uint dwDesiredAccess,
      uint dwShareMode,
      IntPtr SecurityAttributes,
      uint dwCreationDisposition,
      uint dwFlagsAndAttributes,
      IntPtr hTemplateFile);

    [DllImport("kernel32.dll")]
    internal static extern bool SetEvent(IntPtr hEvent);

    [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
    internal static extern IntPtr CreateEvent(
      IntPtr lpEventAttributes,
      bool bManualReset,
      bool bInitialState,
      string lpName);

    [DllImport("kernel32.dll")]
    internal static extern uint WaitForMultipleObjects(
      uint nCount,
      IntPtr[] lpHandles,
      bool bWaitAll,
      uint dwMilliseconds);

    internal struct SID_AND_ATTRIBUTES
    {
      public IntPtr Sid;
      public uint Attributes;
    }

    internal struct TOKEN_GROUPSStart
    {
      public int GroupCount;
      public IntPtr Groups;
    }

    internal struct TOKEN_GROUPS
    {
      public int GroupCount;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]
      public NativeMethods.SID_AND_ATTRIBUTES[] FirstGroup;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal class SECURITY_ATTRIBUTES
    {
      public int NLength;
      public IntPtr LPSecurityDescriptor = IntPtr.Zero;
      public bool InheritHandle;

      public SECURITY_ATTRIBUTES() => this.NLength = 12;
    }
  }
}
