// Decompiled with JetBrains decompiler
// Type: Mono.Options.Option
// Assembly: FUNCD, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 38B3918C-7BBD-4048-BF6D-F5A856A1A18A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Convagent.gen-2f81e8b71640e7b5770deccc56c23d75240c34a5914dcb138ec2972e624a0f03.exe

using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace Mono.Options
{
  public abstract class Option
  {
    private string prototype;
    private string description;
    private string[] names;
    private OptionValueType type;
    private int count;
    private string[] separators;
    private static readonly char[] NameTerminator = new char[2]
    {
      '=',
      ':'
    };

    protected Option(string prototype, string description)
      : this(prototype, description, 1)
    {
    }

    protected Option(string prototype, string description, int maxValueCount)
    {
      switch (prototype)
      {
        case "":
          throw new ArgumentException("Cannot be the empty string.", nameof (prototype));
        case null:
          throw new ArgumentNullException(nameof (prototype));
        default:
          if (maxValueCount < 0)
            throw new ArgumentOutOfRangeException(nameof (maxValueCount));
          this.prototype = prototype;
          this.names = prototype.Split('|');
          this.description = description;
          this.count = maxValueCount;
          this.type = this.ParsePrototype();
          if (this.count == 0 && this.type != OptionValueType.None)
            throw new ArgumentException("Cannot provide maxValueCount of 0 for OptionValueType.Required or OptionValueType.Optional.", nameof (maxValueCount));
          if (this.type == OptionValueType.None && maxValueCount > 1)
            throw new ArgumentException(string.Format("Cannot provide maxValueCount of {0} for OptionValueType.None.", (object) maxValueCount), nameof (maxValueCount));
          if (Array.IndexOf<string>(this.names, "<>") < 0 || (this.names.Length != 1 || this.type == OptionValueType.None) && (this.names.Length <= 1 || this.MaxValueCount <= 1))
            break;
          throw new ArgumentException("The default option handler '<>' cannot require values.", nameof (prototype));
      }
    }

    public string Prototype => this.prototype;

    public string Description => this.description;

    public OptionValueType OptionValueType => this.type;

    public int MaxValueCount => this.count;

    public string[] GetNames() => (string[]) this.names.Clone();

    public string[] GetValueSeparators() => this.separators == null ? new string[0] : (string[]) this.separators.Clone();

    protected static T Parse<T>(string value, OptionContext c)
    {
      Type type1 = typeof (T);
      Type type2 = (!type1.IsValueType || !type1.IsGenericType || type1.IsGenericTypeDefinition ? 0 : (type1.GetGenericTypeDefinition() == typeof (Nullable<>) ? 1 : 0)) != 0 ? type1.GetGenericArguments()[0] : typeof (T);
      TypeConverter converter = TypeDescriptor.GetConverter(type2);
      T obj = default (T);
      try
      {
        if (value != null)
          obj = (T) converter.ConvertFromString(value);
      }
      catch (Exception ex)
      {
        throw new OptionException(string.Format(c.OptionSet.MessageLocalizer("Could not convert string `{0}' to type {1} for option `{2}'."), (object) value, (object) type2.Name, (object) c.OptionName), c.OptionName, ex);
      }
      return obj;
    }

    internal string[] Names => this.names;

    internal string[] ValueSeparators => this.separators;

    private OptionValueType ParsePrototype()
    {
      char minValue = char.MinValue;
      List<string> seps = new List<string>();
      for (int index = 0; index < this.names.Length; ++index)
      {
        string name = this.names[index];
        int num = name.Length != 0 ? name.IndexOfAny(Option.NameTerminator) : throw new ArgumentException("Empty option names are not supported.", "prototype");
        if (num != -1)
        {
          this.names[index] = name.Substring(0, num);
          if (minValue != char.MinValue && (int) minValue != (int) name[num])
            throw new ArgumentException(string.Format("Conflicting option types: '{0}' vs. '{1}'.", (object) minValue, (object) name[num]), "prototype");
          minValue = name[num];
          Option.AddSeparators(name, num, (ICollection<string>) seps);
        }
      }
      if (minValue == char.MinValue)
        return OptionValueType.None;
      if (this.count <= 1 && seps.Count != 0)
        throw new ArgumentException(string.Format("Cannot provide key/value separators for Options taking {0} value(s).", (object) this.count), "prototype");
      if (this.count > 1)
      {
        if (seps.Count == 0)
          this.separators = new string[2]{ ":", "=" };
        else
          this.separators = seps.Count != 1 || seps[0].Length != 0 ? seps.ToArray() : (string[]) null;
      }
      return minValue != '=' ? OptionValueType.Optional : OptionValueType.Required;
    }

    private static void AddSeparators(string name, int end, ICollection<string> seps)
    {
      int startIndex = -1;
      for (int index = end + 1; index < name.Length; ++index)
      {
        switch (name[index])
        {
          case '{':
            if (startIndex != -1)
              throw new ArgumentException(string.Format("Ill-formed name/value separator found in \"{0}\".", (object) name), "prototype");
            startIndex = index + 1;
            break;
          case '}':
            if (startIndex == -1)
              throw new ArgumentException(string.Format("Ill-formed name/value separator found in \"{0}\".", (object) name), "prototype");
            seps.Add(name.Substring(startIndex, index - startIndex));
            startIndex = -1;
            break;
          default:
            if (startIndex == -1)
            {
              seps.Add(name[index].ToString());
              break;
            }
            break;
        }
      }
      if (startIndex != -1)
        throw new ArgumentException(string.Format("Ill-formed name/value separator found in \"{0}\".", (object) name), "prototype");
    }

    public void Invoke(OptionContext c)
    {
      this.OnParseComplete(c);
      c.OptionName = (string) null;
      c.Option = (Option) null;
      c.OptionValues.Clear();
    }

    protected abstract void OnParseComplete(OptionContext c);

    public override string ToString() => this.Prototype;
  }
}
