// Decompiled with JetBrains decompiler
// Type: Diploma.entity.Vector
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using System;

namespace Diploma.entity
{
  public class Vector : IVector
  {
    private double[] vect;

    public Vector(int dim) => this.vect = new double[dim];

    public Vector(double[] mass)
    {
      this.vect = new double[mass.Length];
      for (int index = 0; index < mass.Length; ++index)
        this.vect[index] = mass[index];
    }

    public Vector(IVector a)
    {
      this.vect = new double[a.length];
      for (int index = 0; index < a.length; ++index)
        this.vect[index] = a[index];
    }

    public Vector(Vector a)
    {
      this.vect = new double[a.length];
      for (int index = 0; index < a.length; ++index)
        this.vect[index] = a[index];
    }

    void IVector.print()
    {
      try
      {
        for (int index = 0; index < this.vect.Length; ++index)
        {
          if (index == 0)
            Console.Write("[");
          if (index != this.vect.Length - 1)
            Console.Write("{0}, ", (object) this.vect[index]);
          else
            Console.WriteLine("{0}]", (object) this.vect[index]);
        }
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Vect massive!");
      }
    }

    int IVector.length => this.vect.Length;

    double IVector.this[int index]
    {
      get => this.vect[index];
      set => this.vect[index] = value;
    }

    double IVector.norm()
    {
      double num = 0.0;
      try
      {
        for (int index = 0; index < this.vect.Length; ++index)
        {
          if (Math.Abs(this.vect[index]) > num)
            num = Math.Abs(this.vect[index]);
        }
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Vect massive!");
      }
      return num;
    }

    public int length => this.vect.Length;

    public void print()
    {
      try
      {
        for (int index = 0; index < this.vect.Length; ++index)
        {
          if (index == 0)
            Console.Write("[");
          if (index != this.vect.Length - 1)
            Console.Write("{0}, ", (object) this.vect[index]);
          else
            Console.WriteLine("{0}]", (object) this.vect[index]);
        }
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Vect massive!");
      }
    }

    public override string ToString()
    {
      string str = "[";
      for (int index = 0; index < this.vect.Length; ++index)
      {
        str += this.vect[index].ToString();
        if (index != this.vect.Length - 1)
          str += ", ";
      }
      return str + "]";
    }

    public double this[int index]
    {
      get => this.vect[index];
      set => this.vect[index] = value;
    }

    public double norm()
    {
      double num = 0.0;
      try
      {
        for (int index = 0; index < this.vect.Length; ++index)
          num += Math.Abs(this.vect[index]);
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Vect massive!");
      }
      return num;
    }

    public static Vector operator +(Vector v1, Vector v2)
    {
      if (v1.vect.Length != v2.vect.Length)
        throw new ArgumentException("not similar dim");
      double[] mass = new double[v1.vect.Length];
      for (int index = 0; index < v1.vect.Length; ++index)
        mass[index] = v1.vect[index] + v2.vect[index];
      return new Vector(mass);
    }

    public static Vector operator -(Vector v1, Vector v2)
    {
      if (v1.vect.Length != v2.vect.Length)
        throw new ArgumentException("not similar dim");
      double[] mass = new double[v1.vect.Length];
      for (int index = 0; index < v1.vect.Length; ++index)
        mass[index] = v1.vect[index] - v2.vect[index];
      return new Vector(mass);
    }

    public static Vector operator *(double a, Vector v)
    {
      double[] mass = new double[v.vect.Length];
      for (int index = 0; index < v.vect.Length; ++index)
        mass[index] = a * v.vect[index];
      return new Vector(mass);
    }

    public static Vector operator *(int a, Vector v)
    {
      double[] mass = new double[v.vect.Length];
      for (int index = 0; index < v.vect.Length; ++index)
        mass[index] = (double) a * v.vect[index];
      return new Vector(mass);
    }

    public static double operator *(Vector v1, Vector v2)
    {
      if (v1.vect.Length != v2.vect.Length)
        throw new ArgumentException("not similar dim");
      double num = 0.0;
      for (int index = 0; index < v1.vect.Length; ++index)
        num += v1.vect[index] * v2.vect[index];
      return num;
    }

    public static bool operator ==(Vector a, Vector b)
    {
      if ((object) a == (object) b)
        return true;
      if ((object) a == null || (object) b == null)
        return false;
      for (int index = 0; index < a.vect.Length; ++index)
      {
        if (a.vect[index] != b.vect[index])
          return false;
      }
      return true;
    }

    public static bool operator !=(Vector a, Vector b) => !(a == b);

    public bool Equals(Vector a)
    {
      for (int index = 0; index < a.vect.Length; ++index)
      {
        if (a.vect[index] != this.vect[index])
          return false;
      }
      return true;
    }

    public override int GetHashCode()
    {
      int hashCode = 0;
      for (int index = 0; index < this.vect.Length; ++index)
        hashCode = 31 * hashCode + this.vect[index].GetHashCode();
      return hashCode;
    }
  }
}
