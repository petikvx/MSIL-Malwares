// Decompiled with JetBrains decompiler
// Type: .
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u0010;
using \u0012;
using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Runtime.InteropServices;

namespace \u0010
{
  internal struct \u0002
  {
    public int \u0001;
    public int \u0002;
    public int \u0003;
    public int \u0004;
    public int \u0005;
    public int \u0006;
    public int \u0007;
    public int \u0008;
    public int \u000E;
    public \u0008 \u0001;
    private char[] \u0001;
    private int \u000F;
    private static readonly int[] \u0001;
    private static readonly int \u0010;
    private static readonly int \u0011;
    private static readonly int \u0012;
    private static readonly int \u0013;
    private static readonly int \u0014;
    private static readonly int \u0015;
    private static readonly int \u0016;
    private static readonly int \u0017;
    private static readonly int \u0018;
    private static readonly int \u0019;
    private static readonly int \u001A;
    private static readonly int \u001B;
    private static readonly int \u001C;
    private const short \u0001 = 7;
    [NonSerialized]
    internal static GetString \u009E;

    static \u0002()
    {
      Strings.CreateGetStringDelegate(typeof (\u0002));
      \u0002.\u0001 = new int[7]
      {
        -1,
        10,
        100,
        1000,
        10000,
        100000,
        1000000
      };
      int num1 = \u001F.\u0011\u0003((object) \u0002.\u009E(4186));
      if (true)
      {
        \u0002.\u0010 = num1;
        num1 = \u001F.\u0011\u0003((object) \u0002.\u009E(4195));
      }
      \u0002.\u0011 = num1;
      int num2 = \u001F.\u0011\u0003((object) \u0002.\u009E(4204));
      int num3;
      while (true)
      {
        \u0002.\u0012 = num2;
        \u0002.\u0013 = \u001F.\u0011\u0003((object) \u0002.\u009E(4217));
        int num4 = \u001F.\u0011\u0003((object) \u0002.\u009E(4230));
        int num5;
        while (true)
        {
          \u0002.\u0014 = num4;
          num5 = \u001F.\u0011\u0003((object) \u0002.\u009E(4247));
          if (false)
            num4 = num5;
          else
            break;
        }
        \u0002.\u0015 = num5;
        \u0002.\u0016 = \u001F.\u0011\u0003((object) \u0002.\u009E(4264));
        if (true)
        {
          num3 = \u001F.\u0011\u0003((object) \u0002.\u009E(4269));
          if (false)
            num2 = num3;
          else
            break;
        }
        else
          goto label_11;
      }
      \u0002.\u0017 = num3;
      \u0002.\u0018 = \u001F.\u0011\u0003((object) \u0002.\u009E(4274));
      \u0002.\u0019 = \u001F.\u0011\u0003((object) \u0002.\u009E(4283));
      int num6 = \u001F.\u0011\u0003((object) \u0002.\u009E(4292));
label_10:
      \u0002.\u001A = num6;
label_11:
      \u0002.\u001B = \u001F.\u0011\u0003((object) \u0002.\u009E(4305));
      num6 = \u001F.\u0011\u0003((object) \u0002.\u009E(4310));
      if (true)
        \u0002.\u001C = num6;
      else
        goto label_10;
    }

    public bool \u0001([In] char[] obj0, [In] int obj1, [In] int obj2)
    {
      this.\u0001 = obj0;
      int num1;
      do
      {
        if (false)
          goto label_4;
        else
          goto label_11;
label_3:
        if (num1 == 0)
          goto label_8;
label_4:
        int num2 = this.\u0002(\u0002.\u0015 + obj1) ? 1 : 0;
label_5:
        if (num2 != 0)
          continue;
label_8:
        num1 = 0;
        if (num1 != 0)
        {
          num2 = num1;
          goto label_5;
        }
        else if (num1 != 0)
          goto label_3;
        else
          goto label_2;
label_11:
        this.\u000F = obj1 + obj2;
        if (this.\u0001(obj1))
        {
          num1 = this.\u0001(\u0002.\u0014 + obj1, 'T') ? 1 : 0;
          goto label_3;
        }
        else
          goto label_8;
      }
      while (false);
      return true;
label_2:
      return num1 != 0;
    }

    private bool \u0001([In] int obj0) => this.\u0001(obj0, out this.\u0001) && 1 <= this.\u0001 && this.\u0001(obj0 + \u0002.\u0010, '-') && this.\u0002(obj0 + \u0002.\u0011, out this.\u0002) && 1 <= this.\u0002 && this.\u0002 <= 12 && this.\u0001(obj0 + \u0002.\u0012, '-') && this.\u0002(obj0 + \u0002.\u0013, out this.\u0003) && 1 <= this.\u0003 && this.\u0003 <= \u009D.\u0013\u0004(this.\u0001, this.\u0002);

    private bool \u0002([In] int obj0) => this.\u0001(ref obj0) && this.\u0003(obj0);

    private unsafe bool \u0001([In] ref int obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      if (this.\u0002(obj0, out this.\u0004))
        goto label_28;
label_7:
      return false;
label_28:
      do
      {
        int num1 = this.\u0004;
        int num2;
        if (true)
        {
          if (num1 <= 24)
          {
            int num3 = this.\u0001(obj0 + \u0002.\u0016, ':') ? 1 : 0;
            if (true)
            {
              if (num3 == 0)
                goto label_7;
            }
            else
            {
              num2 = num3;
              goto label_24;
            }
          }
          else
            goto label_7;
        }
        else
          goto label_13;
label_3:
        if (this.\u0002(obj0 + \u0002.\u0017, out this.\u0005) && this.\u0005 < 60)
        {
          if (true)
          {
            if (!this.\u0001(obj0 + \u0002.\u0018, ':') || !this.\u0002(obj0 + \u0002.\u0019, out this.\u0006) || this.\u0006 >= 60)
              goto label_7;
          }
          else
            goto label_16;
        }
        else
          goto label_7;
label_6:
        if (this.\u0004 != 24 || this.\u0005 == 0 && this.\u0006 == 0)
        {
          obj0 += \u0002.\u001A;
          if (this.\u0001(obj0, '.'))
          {
            this.\u0007 = 0;
            *(int*) voidPtr = 0;
          }
          else
            goto label_26;
        }
        else
          goto label_7;
label_12:
        ref int local = ref obj0;
        *(int*) ((IntPtr) voidPtr + 8) = obj0 + 1;
        int num4 = *(int*) ((IntPtr) voidPtr + 8);
        local = num4;
        num1 = *(int*) ((IntPtr) voidPtr + 8);
label_13:
        int num5 = this.\u000F;
        int num6;
        int num7;
        if (num1 < num5)
        {
          int num8 = *(int*) voidPtr;
          num7 = 7;
          num6 = num8;
        }
        else
          goto label_16;
label_15:
        if (num6 < num7)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) this.\u0001[obj0] - 48;
          if (*(int*) ((IntPtr) voidPtr + 4) >= 0 && *(int*) ((IntPtr) voidPtr + 4) <= 9)
          {
            this.\u0007 = this.\u0007 * 10 + *(int*) ((IntPtr) voidPtr + 4);
            *(int*) voidPtr = *(int*) voidPtr + 1;
            goto label_12;
          }
        }
label_16:
        if (true)
        {
          num6 = *(int*) voidPtr;
          num7 = 7;
          if (num7 != 0)
          {
            if (num6 < num7)
            {
              if (*(int*) voidPtr == 0)
              {
                if (false)
                  goto label_3;
                else
                  goto label_21;
              }
              else
                this.\u0007 *= \u0002.\u0001[7 - *(int*) voidPtr];
            }
            num2 = this.\u0004;
          }
          else
            goto label_15;
        }
        else
          goto label_6;
label_24:
        if (num2 == 24 && this.\u0007 != 0)
          goto label_25;
label_26:;
      }
      while (false);
      goto label_27;
label_21:
      return false;
label_25:
      return false;
label_27:
      return true;
    }

    private bool \u0003([In] int obj0)
    {
      if (obj0 < this.\u000F)
        goto label_28;
label_27:
      return obj0 == this.\u000F;
label_28:
      char ch = this.\u0001[obj0];
      int num1;
      int num2;
      int num3;
      int num4;
      switch (ch)
      {
        case 'Z':
        case 'z':
          this.\u0001 = \u0008.\u0002;
          num1 = obj0;
          num2 = 1;
          if (num2 != 0)
          {
            obj0 = num1 + num2;
            goto label_27;
          }
          else
            goto label_22;
        default:
          if (obj0 + 2 < this.\u000F && this.\u0002(obj0 + \u0002.\u001B, out this.\u0008))
          {
            int num5 = this.\u0008;
            num4 = 99;
            num3 = num5;
            break;
          }
          goto label_12;
      }
label_4:
      int num6;
      if (num3 <= num4)
        num6 = (int) ch;
      else
        goto label_12;
label_6:
      int num7;
      int num8;
      int num9;
      while (true)
      {
        if (num6 != 43)
        {
          if (ch == '-')
          {
            this.\u0001 = \u0008.\u0003;
            num7 = obj0;
            num8 = \u0002.\u001C;
            if (true)
            {
              num9 = num7 + num8;
              if (false)
                num6 = num9;
              else
                break;
            }
            else
              goto label_25;
          }
          else
            goto label_12;
        }
        else
          goto label_11;
      }
      obj0 = num9;
      goto label_12;
label_11:
      this.\u0001 = \u0008.\u0004;
      obj0 += \u0002.\u001C;
label_12:
      if (obj0 < this.\u000F)
      {
        if (this.\u0001(obj0, ':'))
        {
          int num10 = obj0;
          if (true)
          {
            obj0 = num10 + 1;
            if (obj0 + 1 < this.\u000F && this.\u0002(obj0, out this.\u000E) && this.\u000E <= 99)
              num10 = obj0;
            else
              goto label_27;
          }
          obj0 = num10 + 2;
          goto label_27;
        }
        else
        {
          num3 = obj0 + 1;
          num4 = this.\u000F;
        }
      }
      else
        goto label_27;
label_19:
      if (true)
      {
        if (num3 < num4 && this.\u0002(obj0, out this.\u000E))
        {
          int num11 = this.\u000E;
          num2 = 99;
          num1 = num11;
        }
        else
          goto label_27;
      }
      else
        goto label_4;
label_22:
      if (num1 <= num2)
      {
        num6 = obj0;
        if (true)
        {
          num8 = 2;
          num7 = num6;
        }
        else
          goto label_6;
      }
      else
        goto label_27;
label_25:
      if (num8 == 0)
      {
        num4 = num8;
        num3 = num7;
        goto label_19;
      }
      else
      {
        obj0 = num7 + num8;
        goto label_27;
      }
    }

    private unsafe bool \u0001(int _param1, out int _param2)
    {
      int num1 = 16;
      int num2;
      while (true)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(num1);
        int num3 = _param1;
        int num4 = 3;
        while (true)
        {
          if (num3 + num4 >= this.\u000F)
            goto label_9;
          else
            goto label_11;
label_5:
          if (0 <= *(int*) ((IntPtr) voidPtr + 8))
          {
            int num5 = *(int*) ((IntPtr) voidPtr + 8);
            int num6 = 10;
            if (num6 == 0)
            {
              num4 = num6;
              num3 = num5;
              continue;
            }
            if (num5 < num6 && 0 <= *(int*) ((IntPtr) voidPtr + 12) && *(int*) ((IntPtr) voidPtr + 12) < 10)
              break;
          }
label_9:
          if (false)
            goto label_5;
          else
            goto label_10;
label_11:
          *(int*) voidPtr = (int) this.\u0001[_param1] - 48;
          *(int*) ((IntPtr) voidPtr + 4) = (int) this.\u0001[_param1 + 1] - 48;
          *(int*) ((IntPtr) voidPtr + 8) = (int) this.\u0001[_param1 + 2] - 48;
          *(int*) ((IntPtr) voidPtr + 12) = (int) this.\u0001[_param1 + 3] - 48;
          if (0 > *(int*) voidPtr || *(int*) voidPtr >= 10 || 0 > *(int*) ((IntPtr) voidPtr + 4) || *(int*) ((IntPtr) voidPtr + 4) >= 10)
            goto label_9;
          else
            goto label_5;
        }
        _param2 = ((*(int*) voidPtr * 10 + *(int*) ((IntPtr) voidPtr + 4)) * 10 + *(int*) ((IntPtr) voidPtr + 8)) * 10 + *(int*) ((IntPtr) voidPtr + 12);
        num2 = 1;
        if (num2 == 0)
          num1 = num2;
        else
          break;
      }
      return num2 != 0;
label_10:
      _param2 = 0;
      return false;
    }

    private unsafe bool \u0002(int _param1, out int _param2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
label_1:
      while (true)
      {
        int num1 = _param1 + 1;
        int num2 = this.\u000F;
        while (num1 < num2)
        {
          *(int*) voidPtr = (int) this.\u0001[_param1] - 48;
          *(int*) ((IntPtr) voidPtr + 4) = (int) this.\u0001[_param1 + 1] - 48;
          if (true)
          {
            int num3 = 0;
            int num4;
            int num5;
            int num6;
            while (true)
            {
              int num7 = *(int*) voidPtr;
              if (num3 <= num7)
              {
                num4 = *(int*) voidPtr;
                if (false)
                {
                  num3 = num4;
                }
                else
                {
                  num5 = 10;
                  if (num5 != 0)
                  {
                    if (num5 != 0)
                    {
                      if (num4 < num5)
                      {
                        num6 = 0;
                        if (num6 != 0)
                          num3 = num6;
                        else
                          goto label_10;
                      }
                      else
                        goto label_12;
                    }
                    else
                      goto label_17;
                  }
                  else
                    break;
                }
              }
              else
                goto label_12;
            }
            num2 = num5;
            num1 = num4;
            continue;
label_17:
            num2 = num5;
            num1 = num4;
            continue;
label_10:
            if (num6 <= *(int*) ((IntPtr) voidPtr + 4) && *(int*) ((IntPtr) voidPtr + 4) < 10)
            {
              _param2 = *(int*) voidPtr * 10 + *(int*) ((IntPtr) voidPtr + 4);
              return true;
            }
            break;
          }
          goto label_1;
        }
        break;
      }
label_12:
      _param2 = 0;
      return false;
    }

    private bool \u0001([In] int obj0, [In] char obj1)
    {
      if (false)
        goto label_4;
      else
        goto label_7;
label_3:
      int num1;
      int num2;
      return num1 == num2;
label_4:
      if (true)
        return false;
      goto label_8;
label_7:
      int num3 = obj0;
      int num4 = this.\u000F;
      if (true)
      {
        if (num3 >= num4)
          goto label_4;
      }
      else
      {
        num2 = num4;
        num1 = num3;
        goto label_3;
      }
label_8:
      num1 = (int) this.\u0001[obj0];
      if (false)
        return num1 != 0;
      num2 = (int) obj1;
      goto label_3;
    }
  }
}
