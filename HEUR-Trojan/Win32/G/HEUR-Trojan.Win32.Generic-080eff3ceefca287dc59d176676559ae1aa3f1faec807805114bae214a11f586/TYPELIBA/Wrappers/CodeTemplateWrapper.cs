// Decompiled with JetBrains decompiler
// Type: TYPELIBA.Wrappers.CodeTemplateWrapper
// Assembly: TYPELIBA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 97BB50BA-9882-4DFE-999C-7A4E4B448F1C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-080eff3ceefca287dc59d176676559ae1aa3f1faec807805114bae214a11f586.exe

using ProjNet.Rules;
using ProjNet.Shared;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TYPELIBA.Identifiers;
using TYPELIBA.Importers;

namespace TYPELIBA.Wrappers
{
  internal class CodeTemplateWrapper : StateProcess
  {
    protected bool _Invocation;
    private double broadcaster;
    private double @struct;
    private double global;
    private double _Mock;
    private double interpreter;
    private double _Mapping;
    protected List<Interceptor> tests;
    protected StateProcess m_Mapper;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public CodeTemplateWrapper(List<Interceptor> task, bool injectb)
    {
      ManagerParamsID.NewExpression();
      // ISSUE: explicit constructor call
      this.\u002Ector(task);
      this._Invocation = injectb;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal CodeTemplateWrapper(List<Interceptor> config)
    {
      ManagerParamsID.NewExpression();
      this._Invocation = false;
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.tests = config;
      this.@struct = this.tests.Find((Predicate<Interceptor>) (init =>
      {
        this.tests = this.tests;
        return init.Name.Equals("semi_major", StringComparison.OrdinalIgnoreCase);
      })).LoginProcess();
      this.global = this.tests.Find((Predicate<Interceptor>) (var1 =>
      {
        this.tests = this.tests;
        return var1.Name.Equals("semi_minor", StringComparison.OrdinalIgnoreCase);
      })).LoginProcess();
      this.broadcaster = 1.0 - this.global * this.global / (this.@struct * this.@struct);
      this._Mapping = (Math.Pow(this.@struct, 2.0) - Math.Pow(this.global, 2.0)) / Math.Pow(this.global, 2.0);
      this.interpreter = this.global / this.@struct;
      this._Mock = this.@struct / this.global;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override RepositoryProcess CreateState()
    {
      int num = 3;
      RepositoryProcess mapper;
      bool flag;
      while (true)
      {
        switch (num)
        {
          case 0:
          case 3:
            flag = this.m_Mapper == null;
            if (CodeTemplateWrapper.CustomizeDescriptor())
            {
              num = 4;
              continue;
            }
            goto case 1;
          case 1:
          case 4:
            if (flag)
            {
              this.m_Mapper = (StateProcess) new CodeTemplateWrapper(this.tests, !this._Invocation);
              goto case 2;
            }
            else
              goto case 2;
          case 2:
            mapper = (RepositoryProcess) this.m_Mapper;
            if (true)
            {
              num = 5;
              continue;
            }
            goto case 0;
          case 5:
            goto label_8;
          default:
            if (!CodeTemplateWrapper.ManageDescriptor())
            {
              num = 2;
              continue;
            }
            goto label_8;
        }
      }
label_8:
      return mapper;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private double[] SearchConsumer(double[] i)
    {
      int num1 = 6;
      double[] numArray;
      while (true)
      {
        int num2 = num1;
        double num3;
        double num4;
        double num5;
        double num6;
        double num7;
        while (true)
        {
          double num8;
          switch (num2)
          {
            case 0:
            case 4:
              goto label_12;
            case 1:
              num8 = i[2].Equals(double.NaN) ? 0.0 : i[2];
              break;
            case 2:
              num5 = StateProcess.PopConsumer(i[1]);
              if (i.Length < 3)
              {
                num8 = 0.0;
                break;
              }
              goto label_11;
            case 3:
            case 5:
label_1:
              num7 = (num3 + num4) * Math.Cos(num5) * Math.Cos(num6);
              if (!CodeTemplateWrapper.ManageDescriptor())
              {
                num2 = 0;
                continue;
              }
              goto label_2;
            case 6:
              goto label_2;
            case 7:
              goto label_13;
            default:
              goto label_9;
          }
          num4 = num8;
          num3 = this.@struct / Math.Sqrt(1.0 - this.broadcaster * Math.Pow(Math.Sin(num5), 2.0));
          goto label_1;
        }
label_2:
        num6 = StateProcess.PopConsumer(i[0]);
        num1 = 2;
        continue;
label_9:
        num1 = 5;
        continue;
label_11:
        num1 = 1;
        continue;
label_12:
        double num9 = (num3 + num4) * Math.Cos(num5) * Math.Sin(num6);
        double num10 = ((1.0 - this.broadcaster) * num3 + num4) * Math.Sin(num5);
        numArray = new double[3]{ num7, num9, num10 };
        num1 = 7;
      }
label_13:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private double[] ValidateConsumer(double[] asset)
    {
      int num1 = 6;
      double instance1;
      double[] numArray;
      while (true)
      {
        int num2 = num1;
        double num3;
        double num4;
        double num5;
        bool flag1;
        double instance2;
        bool flag2;
        double num6;
        double num7;
        while (true)
        {
          bool flag3;
          double d;
          switch (num2)
          {
            case 0:
              if (flag3)
              {
                instance2 = Math.PI / 2.0;
                if (true)
                {
                  num2 = 2;
                  continue;
                }
                goto case 8;
              }
              else if (num5 < 0.0)
              {
                instance2 = -1.0 * Math.PI / 2.0;
                goto case 2;
              }
              else
                goto label_31;
            case 1:
            case 4:
              break;
            case 2:
              goto case 1;
            case 3:
            case 14:
              instance1 = Math.Atan2(asset[1], asset[0]);
              break;
            case 5:
              num4 = 0.0;
              if (asset[0] == 0.0)
              {
                if (asset[1] > 0.0)
                {
                  instance1 = Math.PI / 2.0;
                  num2 = 1;
                  continue;
                }
                goto label_6;
              }
              else
              {
                num2 = 14;
                continue;
              }
            case 6:
              flag1 = false;
              num2 = 9;
              continue;
            case 7:
              goto label_7;
            case 8:
              if (flag2)
              {
                num2 = 11;
                continue;
              }
              flag1 = true;
              instance1 = 0.0;
              flag3 = num5 > 0.0;
              goto case 0;
            case 9:
              num5 = asset.Length < 3 ? 0.0 : (asset[2].Equals(double.NaN) ? 0.0 : asset[2]);
              instance1 = 0.0;
              instance2 = 0.0;
              if (!CodeTemplateWrapper.ManageDescriptor())
              {
                num2 = 5;
                continue;
              }
              goto case 5;
            case 10:
              goto label_3;
            case 11:
              instance1 = -1.0 * Math.PI / 2.0;
              goto case 1;
            case 12:
              goto label_1;
            case 13:
              num3 = Math.Sqrt(d);
              double num8 = num5 * 1.0026;
              double num9 = Math.Sqrt(num8 * num8 + d);
              double x = num8 / num9;
              double num10 = num3 / num9;
              double num11 = Math.Pow(x, 3.0);
              num6 = num5 + this.global * this._Mapping * num11;
              num7 = num3 - this.@struct * this.broadcaster * num10 * num10 * num10;
              if (!CodeTemplateWrapper.ManageDescriptor())
              {
                num2 = 7;
                continue;
              }
              goto case 11;
            case 15:
              goto label_36;
            default:
              if (true)
              {
                num2 = 0;
                continue;
              }
              goto case 2;
          }
          d = asset[0] * asset[0] + asset[1] * asset[1];
          if (true)
            num2 = 13;
          else
            goto label_36;
        }
label_1:
        double num12;
        double num13;
        num4 = num3 / -num12 - num13;
label_3:
        double num14;
        if (!flag1)
          instance2 = Math.Atan(num14 / num12);
        numArray = new double[3]
        {
          StateProcess.CheckConsumer(instance1),
          StateProcess.CheckConsumer(instance2),
          num4
        };
        num1 = 15;
        continue;
label_6:
        flag2 = asset[1] < 0.0;
        num1 = 8;
        continue;
label_7:
        double num15 = Math.Sqrt(num6 * num6 + num7 * num7);
        num14 = num6 / num15;
        num12 = num7 / num15;
        num13 = this.@struct / Math.Sqrt(1.0 - this.broadcaster * num14 * num14);
        if (num12 >= 0.38268343236508978)
        {
          num4 = num3 / num12 - num13;
          num1 = 10;
        }
        else if (num12 > -0.38268343236508978)
        {
          num4 = num5 / num14 + num13 * (this.broadcaster - 1.0);
          goto label_3;
        }
        else
          num1 = 12;
      }
label_31:
      numArray = new double[3]
      {
        StateProcess.CheckConsumer(instance1),
        StateProcess.CheckConsumer(Math.PI / 2.0),
        -this.global
      };
label_36:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] DisableConfiguration(double[] config)
    {
      int num1 = 0;
      double[] numArray;
      while (true)
      {
        int num2 = num1;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 0:
              flag = !this._Invocation;
              num2 = 3;
              continue;
            case 1:
            case 3:
              goto label_1;
            case 2:
            case 4:
              goto label_6;
            case 5:
              goto label_8;
            default:
              goto label_4;
          }
        }
label_1:
        if (!flag)
        {
          numArray = this.ValidateConsumer(config);
          num1 = 5;
          continue;
        }
        break;
label_4:
        num1 = 4;
      }
label_6:
      numArray = this.SearchConsumer(config);
label_8:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override List<double[]> SearchConfiguration(List<double[]> v)
    {
      List<double[]> numArrayList = new List<double[]>(v.Count);
      for (int index = 0; index < v.Count; ++index)
      {
        double[] v1 = v[index];
        numArrayList.Add(this.DisableConfiguration(v1));
      }
      return numArrayList;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override void ValidateConfiguration() => this._Invocation = !this._Invocation;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override string RevertError() => throw new NotImplementedException("The method or operation is not implemented.");

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public override string InterruptState() => throw new NotImplementedException("The method or operation is not implemented.");

    internal static bool CustomizeDescriptor() => true;

    internal static bool ManageDescriptor() => false;
  }
}
