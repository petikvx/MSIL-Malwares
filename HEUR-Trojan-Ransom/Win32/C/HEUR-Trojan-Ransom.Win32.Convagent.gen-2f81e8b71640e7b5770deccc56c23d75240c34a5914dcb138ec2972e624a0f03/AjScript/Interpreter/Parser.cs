// Decompiled with JetBrains decompiler
// Type: AjScript.Interpreter.Parser
// Assembly: FUNCD, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 38B3918C-7BBD-4048-BF6D-F5A856A1A18A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Convagent.gen-2f81e8b71640e7b5770deccc56c23d75240c34a5914dcb138ec2972e624a0f03.exe

using AjScript.Commands;
using AjScript.Expressions;
using AjScript.Language;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

namespace AjScript.Interpreter
{
  public class Parser : IDisposable
  {
    private static readonly Token tokenSemiColon = new Token()
    {
      TokenType = TokenType.Separator,
      Value = ";"
    };
    private static readonly string[] reserved = new string[5]
    {
      "this",
      "null",
      "true",
      "false",
      "undefined"
    };
    private Lexer lexer;
    private IList<ICommand> hoistedCommands;

    public Parser(string text)
      : this(new Lexer(text))
    {
    }

    public Parser(TextReader reader)
      : this(new Lexer(reader))
    {
    }

    public Parser(Lexer lexer) => this.lexer = lexer;

    public ICommand ParseCommands()
    {
      IList<ICommand> commands = (IList<ICommand>) new List<ICommand>();
      IList<ICommand> hoistedCommands = this.hoistedCommands;
      try
      {
        this.hoistedCommands = (IList<ICommand>) new List<ICommand>();
        for (ICommand command = this.ParseCommand(); command != null; command = this.ParseCommand())
          this.AddCommand(commands, command);
        return (ICommand) new CompositeCommand((ICollection<ICommand>) this.hoistedCommands, (ICollection<ICommand>) commands);
      }
      finally
      {
        this.hoistedCommands = hoistedCommands;
      }
    }

    public ICommand ParseCommand()
    {
      Token token = this.lexer.NextToken();
      if (token == null)
        return (ICommand) null;
      if (token.TokenType == TokenType.Name)
      {
        if (token.Value == "if")
          return this.ParseIfCommand();
        if (token.Value == "while")
          return this.ParseWhileCommand();
        if (token.Value == "for")
          return this.ParseForCommand();
        if (token.Value == "return")
          return this.ParseReturnCommand();
        if (token.Value == "var")
          return this.ParseVarCommand();
      }
      if (token.TokenType == TokenType.Separator && token.Value == "{")
        return (ICommand) this.ParseCompositeCommand();
      this.lexer.PushToken(token);
      ICommand simpleCommand = this.ParseSimpleCommand();
      if (simpleCommand == null)
        throw new UnexpectedTokenException(token);
      this.Parse(TokenType.Separator, ";");
      return simpleCommand;
    }

    public IExpression ParseExpression() => this.ParseBinaryLogicalExpressionLevelOne();

    public void Dispose()
    {
      if (this.lexer == null)
        return;
      this.lexer.Dispose();
    }

    private ICommand ParseSimpleCommand()
    {
      if (this.TryParse(TokenType.Name, "var"))
      {
        this.lexer.NextToken();
        return this.ParseVarCommand();
      }
      IExpression expression = this.ParseExpression();
      if (expression == null)
        return (ICommand) null;
      if (this.TryParse(TokenType.Operator, "="))
      {
        this.lexer.NextToken();
        ICommand simpleCommand;
        switch (expression)
        {
          case ArrayExpression _:
            ArrayExpression arrayExpression = (ArrayExpression) expression;
            simpleCommand = (ICommand) new SetArrayCommand(arrayExpression.Expression, arrayExpression.Arguments, this.ParseExpression());
            break;
          case VariableExpression _:
            this.IsValidName(((VariableExpression) expression).Name);
            goto default;
          default:
            simpleCommand = (ICommand) new SetCommand(expression, this.ParseExpression());
            break;
        }
        return simpleCommand;
      }
      if (expression is FunctionExpression && ((FunctionExpression) expression).Name != null)
        this.lexer.PushToken(Parser.tokenSemiColon);
      return (ICommand) new ExpressionCommand(expression);
    }

    private static bool IsName(Token token, string value) => Parser.IsToken(token, value, TokenType.Name);

    private static bool IsToken(Token token, string value, TokenType type) => token != null && token.TokenType == type && token.Value.Equals(value);

    private ICollection<IExpression> ParseArrayValues()
    {
      this.Parse(TokenType.Separator, "{");
      List<IExpression> arrayValues = new List<IExpression>();
      while (true)
      {
        if (!this.TryParse(TokenType.Separator, "}"))
        {
          if (arrayValues.Count > 0)
            this.Parse(TokenType.Separator, ",");
          arrayValues.Add(this.ParseExpression());
        }
        else
          break;
      }
      this.Parse(TokenType.Separator, "}");
      return (ICollection<IExpression>) arrayValues;
    }

    private IExpression ParseBinaryLogicalExpressionLevelOne()
    {
      IExpression left = this.ParseBinaryLogicalExpressionLevelTwo();
      if (left == null)
        return (IExpression) null;
      while (true)
      {
        if (this.TryParse(TokenType.Operator, "||"))
        {
          this.lexer.NextToken();
          IExpression expressionLevelTwo = this.ParseBinaryLogicalExpressionLevelTwo();
          left = (IExpression) new OrExpression(left, expressionLevelTwo);
        }
        else
          break;
      }
      return left;
    }

    private IExpression ParseBinaryLogicalExpressionLevelTwo()
    {
      IExpression left = this.ParseBinaryExpressionZerothLevel();
      if (left == null)
        return (IExpression) null;
      while (true)
      {
        if (this.TryParse(TokenType.Operator, "&&"))
        {
          this.lexer.NextToken();
          IExpression expressionZerothLevel = this.ParseBinaryExpressionZerothLevel();
          left = (IExpression) new AndExpression(left, expressionZerothLevel);
        }
        else
          break;
      }
      return left;
    }

    private IExpression ParseBinaryExpressionZerothLevel()
    {
      IExpression left = this.ParseBinaryExpressionFirstLevel();
      if (left == null)
        return (IExpression) null;
      Token token;
      while (true)
      {
        if (this.TryParse(TokenType.Operator, "<", ">", "==", ">=", "<=", "!=", "===", "!=="))
        {
          token = this.lexer.NextToken();
          IExpression expressionFirstLevel = this.ParseBinaryExpressionFirstLevel();
          ComparisonOperator operation = ComparisonOperator.Unknown;
          if (token.Value == "<")
            operation = ComparisonOperator.Less;
          if (token.Value == ">")
            operation = ComparisonOperator.Greater;
          if (token.Value == "<=")
            operation = ComparisonOperator.LessEqual;
          if (token.Value == ">=")
            operation = ComparisonOperator.GreaterEqual;
          if (token.Value == "===")
            operation = ComparisonOperator.Equal;
          if (token.Value == "!==")
            operation = ComparisonOperator.NotEqual;
          if (operation != ComparisonOperator.Unknown)
            left = (IExpression) new CompareExpression(operation, left, expressionFirstLevel);
          else
            break;
        }
        else
          goto label_18;
      }
      throw new ParserException(string.Format("Unknown operator '{0}'", (object) token.Value));
label_18:
      return left;
    }

    private IExpression ParseBinaryExpressionFirstLevel()
    {
      IExpression left = this.ParseBinaryExpressionSecondLevel();
      if (left == null)
        return (IExpression) null;
      while (true)
      {
        if (this.TryParse(TokenType.Operator, "+", "-"))
        {
          Token token = this.lexer.NextToken();
          IExpression expressionSecondLevel = this.ParseBinaryExpressionSecondLevel();
          left = (IExpression) new ArithmeticBinaryExpression(token.Value == "+" ? ArithmeticOperator.Add : ArithmeticOperator.Subtract, left, expressionSecondLevel);
        }
        else
          break;
      }
      return left;
    }

    private IExpression ParseBinaryExpressionSecondLevel()
    {
      IExpression left = this.ParseUnaryExpression();
      if (left == null)
        return (IExpression) null;
      Token token;
      while (true)
      {
        if (this.TryParse(TokenType.Operator, "*", "/", "\\", "%"))
        {
          token = this.lexer.NextToken();
          IExpression unaryExpression = this.ParseUnaryExpression();
          ArithmeticOperator operation;
          if (token.Value == "*")
            operation = ArithmeticOperator.Multiply;
          else if (token.Value == "/")
            operation = ArithmeticOperator.Divide;
          else if (token.Value == "\\")
            operation = ArithmeticOperator.IntegerDivide;
          else if (token.Value == "%")
            operation = ArithmeticOperator.Modulo;
          else
            break;
          left = (IExpression) new ArithmeticBinaryExpression(operation, left, unaryExpression);
        }
        else
          goto label_13;
      }
      throw new ParserException(string.Format("Invalid operator '{0}'", (object) token.Value));
label_13:
      return left;
    }

    private IExpression ParseUnaryExpression()
    {
      if (this.TryParse(TokenType.Operator, "+", "-", "!"))
      {
        Token token = this.lexer.NextToken();
        IExpression unaryExpression = this.ParseUnaryExpression();
        return token.Value == "!" ? (IExpression) new NotExpression(unaryExpression) : (IExpression) new ArithmeticUnaryExpression(token.Value == "+" ? ArithmeticOperator.Plus : ArithmeticOperator.Minus, unaryExpression);
      }
      if (this.TryParse(TokenType.Operator, "++", "--"))
      {
        Token token = this.lexer.NextToken();
        return (IExpression) new IncrementExpression(this.ParseTermExpression(), token.Value == "++" ? IncrementOperator.PreIncrement : IncrementOperator.PreDecrement);
      }
      IExpression termExpression = this.ParseTermExpression();
      if (!this.TryParse(TokenType.Operator, "++", "--"))
        return termExpression;
      IncrementOperator oper = this.lexer.NextToken().Value == "++" ? IncrementOperator.PostIncrement : IncrementOperator.PostDecrement;
      return (IExpression) new IncrementExpression(termExpression, oper);
    }

    private IExpression ParseTermExpression()
    {
      if (this.TryParse(TokenType.Name, "new"))
        return this.ParseNewExpression();
      IExpression expression = this.ParseSimpleTermExpression();
      while (true)
      {
        if (!this.TryParse(TokenType.Operator, "."))
          goto label_11;
label_3:
        if (this.TryParse(TokenType.Operator, "."))
        {
          this.lexer.NextToken();
          string name = this.ParseName();
          IList<IExpression> arguments = (IList<IExpression>) null;
          if (this.TryParse(TokenType.Separator, "("))
            arguments = this.ParseArgumentList();
          expression = (IExpression) new DotExpression(expression, name, (ICollection<IExpression>) arguments);
          continue;
        }
        if (this.TryParse(TokenType.Separator, "("))
        {
          IList<IExpression> argumentList = this.ParseArgumentList();
          expression = (IExpression) new InvokeExpression(expression, (ICollection<IExpression>) argumentList);
          continue;
        }
        expression = (IExpression) new ArrayExpression(expression, (ICollection<IExpression>) this.ParseArrayArgumentList());
        continue;
label_11:
        if (this.TryParse(TokenType.Separator, "[", "("))
          goto label_3;
        else
          break;
      }
      return expression;
    }

    private IExpression ParseNewExpression()
    {
      this.Parse(TokenType.Name, "new");
      return (IExpression) new NewExpression(this.ParseName(), (ICollection<IExpression>) this.ParseArgumentList());
    }

    private FunctionExpression ParseFunctionExpression()
    {
      string name = (string) null;
      if (this.TryPeekName())
        name = this.lexer.NextToken().Value;
      IList<ICommand> hoistedCommands = this.hoistedCommands;
      this.hoistedCommands = (IList<ICommand>) new List<ICommand>();
      try
      {
        IList<string> argumentNames = this.ParseArgumentNames();
        this.Parse(TokenType.Separator, "{");
        CompositeCommand compositeCommand = this.ParseCompositeCommand();
        if (compositeCommand.HoistedCommandCount > 0)
          throw new ParserException("Invalid command");
        CompositeCommand body = new CompositeCommand((ICollection<ICommand>) this.hoistedCommands, compositeCommand.Commands);
        return new FunctionExpression(name, argumentNames.ToArray<string>(), (ICommand) body);
      }
      finally
      {
        this.hoistedCommands = hoistedCommands;
      }
    }

    private IList<IExpression> ParseArgumentList()
    {
      List<IExpression> argumentList = new List<IExpression>();
      this.Parse(TokenType.Separator, "(");
      while (true)
      {
        if (!this.TryParse(TokenType.Separator, ")"))
        {
          if (argumentList.Count > 0)
            this.Parse(TokenType.Separator, ",");
          argumentList.Add(this.ParseExpression());
        }
        else
          break;
      }
      this.Parse(TokenType.Separator, ")");
      return (IList<IExpression>) argumentList;
    }

    private IList<string> ParseArgumentNames()
    {
      List<string> argumentNames = new List<string>();
      this.Parse(TokenType.Separator, "(");
      while (this.TryPeekName())
      {
        string name = this.ParseName();
        argumentNames.Add(name);
        if (!this.TryParse(TokenType.Separator, ")"))
          this.Parse(TokenType.Separator, ",");
        else
          break;
      }
      this.Parse(TokenType.Separator, ")");
      return (IList<string>) argumentNames;
    }

    private IList<IExpression> ParseArrayArgumentList()
    {
      List<IExpression> arrayArgumentList = new List<IExpression>();
      this.Parse(TokenType.Separator, "[");
      while (true)
      {
        if (!this.TryParse(TokenType.Separator, "]"))
        {
          if (arrayArgumentList.Count > 0)
            this.Parse(TokenType.Separator, ",");
          arrayArgumentList.Add(this.ParseExpression());
        }
        else
          break;
      }
      this.Parse(TokenType.Separator, "]");
      return (IList<IExpression>) arrayArgumentList;
    }

    private IExpression ParseSimpleTermExpression()
    {
      Token token = this.lexer.NextToken();
      if (token == null)
        return (IExpression) null;
      if (token.TokenType == TokenType.Name && token.Value == "function")
        return (IExpression) this.ParseFunctionExpression();
      switch (token.TokenType)
      {
        case TokenType.Name:
          IExpression expression1 = (IExpression) new VariableExpression(token.Value);
          if (this.TryParse(TokenType.Separator, "("))
          {
            IList<IExpression> argumentList = this.ParseArgumentList();
            expression1 = (IExpression) new InvokeExpression(expression1, (ICollection<IExpression>) argumentList);
          }
          return expression1;
        case TokenType.Integer:
          return (IExpression) new ConstantExpression((object) int.Parse(token.Value, (IFormatProvider) CultureInfo.InvariantCulture));
        case TokenType.Real:
          return (IExpression) new ConstantExpression((object) double.Parse(token.Value, (IFormatProvider) CultureInfo.InvariantCulture));
        case TokenType.Boolean:
          return (IExpression) new ConstantExpression((object) Convert.ToBoolean(token.Value));
        case TokenType.String:
          return (IExpression) new ConstantExpression((object) token.Value);
        case TokenType.Separator:
          if (token.Value == "(")
          {
            IExpression expression2 = this.ParseExpression();
            this.Parse(TokenType.Separator, ")");
            return expression2;
          }
          if (token.Value == "{")
            return this.ParseObjectExpression();
          break;
        case TokenType.Object:
          if (token.Value == "null")
            return (IExpression) new ConstantExpression((object) null);
          if (token.Value == "undefined")
            return (IExpression) new ConstantExpression((object) Undefined.Instance);
          break;
      }
      throw new UnexpectedTokenException(token);
    }

    private IExpression ParseObjectExpression()
    {
      IList<string> names = (IList<string>) new List<string>();
      IList<IExpression> expressions = (IList<IExpression>) new List<IExpression>();
      while (true)
      {
        if (!this.TryParse(TokenType.Separator, "}"))
        {
          if (names.Count > 0)
            this.Parse(TokenType.Separator, ",");
          string name = this.ParseName();
          this.Parse(TokenType.Separator, ":");
          IExpression expression = this.ParseExpression();
          names.Add(name);
          expressions.Add(expression);
        }
        else
          break;
      }
      this.Parse(TokenType.Separator, "}");
      return (IExpression) new ObjectExpression(names, expressions);
    }

    private CompositeCommand ParseCompositeCommand()
    {
      IList<ICommand> commands = (IList<ICommand>) new List<ICommand>();
      while (true)
      {
        if (!this.TryParse(TokenType.Separator, "}"))
          this.AddCommand(commands, this.ParseCommand());
        else
          break;
      }
      this.lexer.NextToken();
      return new CompositeCommand((ICollection<ICommand>) commands);
    }

    private void AddCommand(IList<ICommand> commands, ICommand command)
    {
      if (this.hoistedCommands != null && Parser.IsHoistedCommand(command))
      {
        this.hoistedCommands.Add(command);
      }
      else
      {
        if (Parser.IsNoOperationCommand(command))
          return;
        commands.Add(command);
      }
    }

    private ICommand ParseReturnCommand()
    {
      if (this.TryParse(TokenType.Separator, ";"))
      {
        this.lexer.NextToken();
        return (ICommand) new ReturnCommand();
      }
      IExpression expression = this.ParseExpression();
      this.Parse(TokenType.Separator, ";");
      return (ICommand) new ReturnCommand(expression);
    }

    private ICommand ParseIfCommand()
    {
      this.Parse(TokenType.Separator, "(");
      IExpression expression = this.ParseExpression();
      this.Parse(TokenType.Separator, ")");
      ICommand command1 = this.ParseCommand();
      if (!this.TryParse(TokenType.Name, "else"))
        return (ICommand) new IfCommand(expression, command1);
      this.lexer.NextToken();
      ICommand command2 = this.ParseCommand();
      return (ICommand) new IfCommand(expression, command1, command2);
    }

    private ICommand ParseWhileCommand()
    {
      this.Parse(TokenType.Separator, "(");
      IExpression expression = this.ParseExpression();
      this.Parse(TokenType.Separator, ")");
      ICommand command = this.ParseCommand();
      return (ICommand) new WhileCommand(expression, command);
    }

    private ICommand ParseForInCommand()
    {
      string name = this.ParseName();
      bool flag = false;
      if (name == "var")
      {
        name = this.ParseName();
        flag = true;
      }
      this.Parse(TokenType.Name, "in");
      IExpression expression = this.ParseExpression();
      this.Parse(TokenType.Separator, ")");
      ICommand command = this.ParseCommand();
      ICommand forInCommand = (ICommand) new ForEachCommand(name, expression, command);
      if (!flag)
        return forInCommand;
      return (ICommand) new CompositeCommand((ICollection<ICommand>) new List<ICommand>()
      {
        (ICommand) new VarCommand(name),
        forInCommand
      });
    }

    private ICommand ParseForCommand()
    {
      this.Parse(TokenType.Separator, "(");
      Token token = this.lexer.NextToken();
      if (token.TokenType == TokenType.Name && token.Value == "var")
      {
        string name = this.ParseName();
        if (this.TryParse(TokenType.Name, "in"))
        {
          this.lexer.PushToken(new Token()
          {
            TokenType = TokenType.Name,
            Value = name
          });
          this.lexer.PushToken(token);
          return this.ParseForInCommand();
        }
        this.lexer.PushToken(new Token()
        {
          TokenType = TokenType.Name,
          Value = name
        });
        this.lexer.PushToken(token);
      }
      ICommand simpleCommand1 = this.ParseSimpleCommand();
      IExpression expression = this.ParseExpression();
      this.Parse(TokenType.Separator, ";");
      ICommand simpleCommand2 = this.ParseSimpleCommand();
      this.Parse(TokenType.Separator, ")");
      ICommand command = this.ParseCommand();
      IExpression condition = expression;
      ICommand endCommand = simpleCommand2;
      ICommand body = command;
      return (ICommand) new ForCommand(simpleCommand1, condition, endCommand, body);
    }

    private ICommand ParseVarCommand()
    {
      string name = this.ParseName();
      this.IsValidName(name);
      IExpression expression = (IExpression) null;
      if (this.TryParse(TokenType.Operator, "="))
      {
        this.lexer.NextToken();
        expression = this.ParseExpression();
      }
      this.Parse(TokenType.Separator, ";");
      if (this.hoistedCommands != null)
      {
        this.hoistedCommands.Add((ICommand) new VarCommand(name));
        return expression == null ? (ICommand) NoOperationCommand.Instance : (ICommand) new SetVariableCommand(name, expression);
      }
      if (expression == null)
        return (ICommand) new VarCommand(name);
      return (ICommand) new CompositeCommand((ICollection<ICommand>) new List<ICommand>()
      {
        (ICommand) new VarCommand(name),
        (ICommand) new SetVariableCommand(name, expression)
      });
    }

    private void ParseMemberVariable(
      IList<string> memberNames,
      IList<IExpression> memberExpressions)
    {
      string name = this.ParseName();
      IExpression expression = (IExpression) null;
      if (this.TryParse(TokenType.Operator, "="))
      {
        this.lexer.NextToken();
        expression = this.ParseExpression();
      }
      this.Parse(TokenType.Separator, ";");
      memberNames.Add(name);
      memberExpressions.Add(expression);
    }

    private void ParseMemberMethod(
      IList<string> memberNames,
      IList<IExpression> memberExpressions,
      bool isdefault)
    {
      string name = this.ParseName();
      bool hasvariableparameters = false;
      this.ParseParameters(ref hasvariableparameters);
      this.ParseCommand();
      memberNames.Add(name);
      throw new NotImplementedException();
    }

    private string[] ParseParameters(ref bool hasvariableparameters)
    {
      List<string> stringList = new List<string>();
      this.Parse(TokenType.Separator, "(");
      while (true)
      {
        if (!this.TryParse(TokenType.Separator, ")"))
        {
          if (stringList.Count > 0)
            this.Parse(TokenType.Separator, ",");
          stringList.Add(this.ParseName());
        }
        else
          break;
      }
      this.lexer.NextToken();
      return stringList.ToArray();
    }

    private bool TryPeekName()
    {
      Token token = this.lexer.PeekToken();
      return token != null && token.TokenType == TokenType.Name;
    }

    private object ParseValue()
    {
      Token token = this.lexer.NextToken();
      if (token == null)
        throw new UnexpectedEndOfInputException();
      if (token.TokenType == TokenType.String)
        return (object) token.Value;
      return token.TokenType == TokenType.Integer ? (object) int.Parse(token.Value) : throw new UnexpectedTokenException(token);
    }

    private bool TryParse(TokenType type, params string[] values)
    {
      Token token = this.lexer.PeekToken();
      if (token == null || token.TokenType != type)
        return false;
      foreach (string str in values)
      {
        if (token.Value == str)
          return true;
      }
      return false;
    }

    private void Parse(TokenType type, string value)
    {
      Token token = this.lexer.NextToken();
      if (token == null)
        throw new UnexpectedEndOfInputException();
      if (type == TokenType.Name)
      {
        if (!Parser.IsName(token, value))
          throw new UnexpectedTokenException(token);
      }
      else if (token.TokenType != type || token.Value != value)
        throw new UnexpectedTokenException(token);
    }

    private string ParseName()
    {
      Token token = this.lexer.NextToken();
      if (token == null)
        throw new ParserException(string.Format("Unexpected end of input"));
      return token.TokenType == TokenType.Name ? token.Value : throw new UnexpectedTokenException(token);
    }

    private string ParseQualifiedName()
    {
      string qualifiedName = this.ParseName();
      while (true)
      {
        if (this.TryParse(TokenType.Operator, "."))
        {
          this.lexer.NextToken();
          qualifiedName = qualifiedName + "." + this.ParseName();
        }
        else
          break;
      }
      return qualifiedName;
    }

    private static bool IsNoOperationCommand(ICommand command) => command == null || command is CompositeCommand && ((CompositeCommand) command).CommandCount == 0 || command == NoOperationCommand.Instance;

    private static bool IsHoistedCommand(ICommand command)
    {
      switch (command)
      {
        case null:
          return false;
        case VarCommand _:
          return true;
        case ExpressionCommand _:
          if (((ExpressionCommand) command).Expression is FunctionExpression && ((FunctionExpression) ((ExpressionCommand) command).Expression).Name != null)
            return true;
          break;
      }
      return false;
    }

    private void IsValidName(string name)
    {
      if (((IEnumerable<string>) Parser.reserved).Contains<string>(name))
        throw new ParserException(string.Format("Invalid name '{0}'", (object) name));
    }
  }
}
