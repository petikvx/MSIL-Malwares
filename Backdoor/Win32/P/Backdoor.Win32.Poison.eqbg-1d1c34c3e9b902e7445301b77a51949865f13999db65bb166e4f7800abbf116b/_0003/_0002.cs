// Decompiled with JetBrains decompiler
// Type: .
// Assembly: 5, Version=0.0.0.0, Culture=neutral, PublicKeyToken=c1ca78561cb11ead
// MVID: 2D47F565-522D-4F7E-99C5-0FAB4FA0B168
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.Win32.Poison.eqbg-1d1c34c3e9b902e7445301b77a51949865f13999db65bb166e4f7800abbf116b.exe

using \u0007;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u0003
{
  [\u0001.\u0001]
  [\u0003.\u0001]
  internal static class \u0002
  {
    private static ModuleHandle \u0001;
    private static char[] \u0001;

    [\u0001.\u0001]
    [\u0002.\u0001]
    [\u0003.\u0001]
    public static unsafe void \u0001([In] int obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(29);
      Type typeFromHandle;
      FieldInfo[] fields;
      FieldInfo fieldInfo;
      string name;
      char ch;
      MethodInfo methodFromHandle;
      Delegate @delegate;
      ParameterInfo[] parameters;
      Type[] parameterTypes;
      DynamicMethod dynamicMethod;
      ILGenerator ilGenerator;
      try
      {
        try
        {
          typeFromHandle = Type.GetTypeFromHandle(\u0003.\u0002.\u0001.ResolveTypeHandle(33554433 + obj0));
        }
        catch
        {
          return;
        }
        fields = typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField);
        *(int*) ((IntPtr) voidPtr + 24) = 0;
        while (*(int*) ((IntPtr) voidPtr + 24) < fields.Length)
        {
          fieldInfo = fields[*(int*) ((IntPtr) voidPtr + 24)];
          name = fieldInfo.Name;
          *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 0;
          *(int*) voidPtr = 0;
          *(int*) ((IntPtr) voidPtr + 4) = name.Length - 1;
          int length;
          while (true)
          {
            length = *(int*) ((IntPtr) voidPtr + 4);
            if (true)
            {
              if (length >= 0)
              {
                ch = name[*(int*) ((IntPtr) voidPtr + 4)];
                if (ch != '~')
                {
                  *(int*) ((IntPtr) voidPtr + 8) = 0;
                  while (*(int*) ((IntPtr) voidPtr + 8) < 58)
                  {
                    if ((int) \u0003.\u0002.\u0001[*(int*) ((IntPtr) voidPtr + 8)] == (int) ch)
                    {
                      *(int*) voidPtr = *(int*) voidPtr * 58 + *(int*) ((IntPtr) voidPtr + 8);
                      break;
                    }
                    *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
                  }
                  *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
                }
                else
                  break;
              }
              else
                goto label_14;
            }
            else
              goto label_27;
          }
          *(sbyte*) ((IntPtr) voidPtr + 28) = (sbyte) 1;
label_14:
          try
          {
            methodFromHandle = (MethodInfo) MethodBase.GetMethodFromHandle(\u0003.\u0002.\u0001.ResolveMethodHandle(*(int*) voidPtr + 167772161));
          }
          catch
          {
            goto label_44;
          }
          if (methodFromHandle.IsStatic)
          {
            try
            {
              @delegate = Delegate.CreateDelegate(fieldInfo.FieldType, methodFromHandle);
              goto label_42;
            }
            catch (Exception ex)
            {
              goto label_44;
            }
          }
label_19:
          parameters = methodFromHandle.GetParameters();
          *(int*) ((IntPtr) voidPtr + 12) = parameters.Length + 1;
          length = *(int*) ((IntPtr) voidPtr + 12);
label_20:
          parameterTypes = new Type[length];
          parameterTypes[0] = typeof (object);
          *(int*) ((IntPtr) voidPtr + 16) = 1;
          int num1;
          int num2;
          while (true)
          {
            num1 = *(int*) ((IntPtr) voidPtr + 16);
            num2 = *(int*) ((IntPtr) voidPtr + 12);
            if (true)
            {
              if (num1 < num2)
              {
                parameterTypes[*(int*) ((IntPtr) voidPtr + 16)] = parameters[*(int*) ((IntPtr) voidPtr + 16) - 1].ParameterType;
                *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
              }
              else
                break;
            }
            else
              goto label_32;
          }
          dynamicMethod = new DynamicMethod(string.Empty, methodFromHandle.ReturnType, parameterTypes, typeFromHandle, true);
          ilGenerator = dynamicMethod.GetILGenerator();
          ilGenerator.Emit(OpCodes.Ldarg_0);
          if (*(int*) ((IntPtr) voidPtr + 12) > 1)
            ilGenerator.Emit(OpCodes.Ldarg_1);
          length = *(int*) ((IntPtr) voidPtr + 12);
label_27:
          if (true)
          {
            if (length > 2)
              ilGenerator.Emit(OpCodes.Ldarg_2);
            if (true)
            {
              int num3 = *(int*) ((IntPtr) voidPtr + 12);
              num2 = 3;
              num1 = num3;
            }
            else
              goto label_19;
          }
          else
            goto label_20;
label_32:
          if (num1 > num2)
            ilGenerator.Emit(OpCodes.Ldarg_3);
          if (*(int*) ((IntPtr) voidPtr + 12) > 4)
          {
            *(int*) ((IntPtr) voidPtr + 20) = 4;
            while (*(int*) ((IntPtr) voidPtr + 20) < *(int*) ((IntPtr) voidPtr + 12))
            {
              ilGenerator.Emit(OpCodes.Ldarg_S, *(int*) ((IntPtr) voidPtr + 20));
              *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
            }
          }
          ilGenerator.Emit(OpCodes.Tailcall);
          ilGenerator.Emit(*(sbyte*) ((IntPtr) voidPtr + 28) != (sbyte) 0 ? OpCodes.Callvirt : OpCodes.Call, methodFromHandle);
          ilGenerator.Emit(OpCodes.Ret);
          try
          {
            do
            {
              @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
            }
            while (false);
          }
          catch
          {
            goto label_44;
          }
label_42:
          try
          {
            fieldInfo.SetValue((object) null, (object) @delegate);
          }
          catch
          {
          }
label_44:
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 24) + 1;
        }
      }
      catch (Exception ex)
      {
        object[] objArray = new object[20]
        {
          (object) typeFromHandle,
          (object) fieldInfo,
          (object) name,
          (object) (bool) *(sbyte*) ((IntPtr) voidPtr + 28),
          (object) *(int*) voidPtr,
          (object) *(int*) ((IntPtr) voidPtr + 4),
          (object) ch,
          (object) *(int*) ((IntPtr) voidPtr + 8),
          (object) methodFromHandle,
          (object) @delegate,
          (object) parameters,
          (object) *(int*) ((IntPtr) voidPtr + 12),
          (object) parameterTypes,
          (object) *(int*) ((IntPtr) voidPtr + 16),
          (object) dynamicMethod,
          (object) ilGenerator,
          (object) *(int*) ((IntPtr) voidPtr + 20),
          (object) fields,
          (object) *(int*) ((IntPtr) voidPtr + 24),
          (object) obj0
        };
        \u0004.\u0001(ex, objArray);
        throw;
      }
    }

    static \u0002()
    {
      Type type1;
      try
      {
        \u0003.\u0002.\u0001 = new char[58]
        {
          '\u0001',
          '\u0002',
          '\u0003',
          '\u0004',
          '\u0005',
          '\u0006',
          '\a',
          '\b',
          '\u000E',
          '\u000F',
          '\u0010',
          '\u0011',
          '\u0012',
          '\u0013',
          '\u0014',
          '\u0015',
          '\u0016',
          '\u0017',
          '\u0018',
          '\u0019',
          '\u001A',
          '\u001B',
          '\u001C',
          '\u001D',
          '\u001E',
          '\u001F',
          '\u007F',
          '\u0080',
          '\u0081',
          '\u0082',
          '\u0083',
          '\u0084',
          '\u0086',
          '\u0087',
          '\u0088',
          '\u0089',
          '\u008A',
          '\u008B',
          '\u008C',
          '\u008D',
          '\u008E',
          '\u008F',
          '\u0090',
          '\u0091',
          '\u0092',
          '\u0093',
          '\u0094',
          '\u0095',
          '\u0096',
          '\u0097',
          '\u0098',
          '\u0099',
          '\u009A',
          '\u009B',
          '\u009C',
          '\u009D',
          '\u009E',
          '\u009F'
        };
        type1 = typeof (MulticastDelegate);
        if ((object) type1 == null)
          return;
        \u0003.\u0002.\u0001 = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
      }
      catch (Exception ex)
      {
        Type type2 = type1;
        \u0004.\u0001(ex, (object) type2);
        throw;
      }
    }
  }
}
