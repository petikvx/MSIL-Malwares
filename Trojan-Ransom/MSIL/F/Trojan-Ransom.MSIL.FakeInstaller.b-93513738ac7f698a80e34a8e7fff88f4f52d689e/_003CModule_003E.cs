// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: virus, Version=1.0.3904.23708, Culture=neutral, PublicKeyToken=null
// MVID: 6438B09B-1060-4AEB-A7B1-CE8F5BCDC576
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\Trojan-Ransom.MSIL.FakeInstaller.b-93513738ac7f698a80e34a8e7fff88f4f52d689e.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;
using System.Windows.Forms;
using virus;

internal class \u003CModule\u003E
{
  internal static \u003F\u003F_C\u0040_1BC\u0040EKMDCNOB\u0040\u003F\u0024AAK\u003F\u0024AAE\u003F\u0024AAR\u003F\u0024AAN\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AA3\u003F\u0024AA2\u003F\u0024AA\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040EKMDCNOB\u0040\u003F\u0024AAK\u003F\u0024AAE\u003F\u0024AAR\u003F\u0024AAN\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AA3\u003F\u0024AA2\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_0O\u0040JKAFBCMB\u0040CreateActCtxW\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040JKAFBCMB\u0040CreateActCtxW\u003F\u0024AA\u0040;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static double \u003FA0x7d798523\u002E_HUGE;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E_HUGE\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static double \u003FA0x7d798523\u002EHUGE;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002EHUGE\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x7d798523\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7d798523\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x49040904\u002E\u003F_lock\u0024initializer\u0024\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static \u003F\u003F_C\u0040_0BA\u0040NOJDBDJO\u0040\u003F4\u003F\u0024DPAVtype_info\u003F\u0024EA\u003F\u0024EA\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040NOJDBDJO\u0040\u003F4\u003F\u0024DPAVtype_info\u003F\u0024EA\u003F\u0024EA\u003F\u0024AA\u0040;
  [FixedAddressValueType]
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2type_info\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x2a41d782\u002E\u003F\u003F_R2type_info\u0040\u00408\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4type_info\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x2a41d782\u002E\u003F\u003F_R4type_info\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6MXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3type_info\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x2a41d782\u002E\u003F\u003F_R3type_info\u0040\u00408\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024_TypeDescriptor\u0024_extraBytes_16 \u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x2a41d782\u002E\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x2a41d782\u002E\u003F\u003F_7type_info\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408;
  [FixedAddressValueType]
  internal static __type_info_node __type_info_root_node;
  internal static __FnPtr<void ()> \u003FA0x2a41d782\u002E\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static int __\u0040\u0040_PchSym_\u004000\u0040UwlxfnvmghLzmwLhvggrmthUzwnrmUKmzKonKmzKolKmzKorLKmzKovKmzKolKmzKopKmyKrwKmzKonKmzKouKmzKomKmyKrxKmyKroUerhfzoLhgfwrlLCAAFUkilqvxghUerifhUerifhUivovzhvUhgwzucOlyq\u0040;
  internal static \u003F\u003F_C\u0040_02BKFDOEMK\u0040wt\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_02BKFDOEMK\u0040wt\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_0L\u0040PINOBPFB\u0040c\u003F3\u003F2drif\u003F4db\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040PINOBPFB\u0040c\u003F3\u003F2drif\u003F4db\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_01HIHLOKLC\u00401\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_01HIHLOKLC\u00401\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_02DKCKIIND\u0040\u003F\u0024CFs\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_02DKCKIIND\u0040\u003F\u0024CFs\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_02BMJICGCB\u0040rt\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_02BMJICGCB\u0040rt\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_02DPKJAMEF\u0040\u003F\u0024CFd\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_02DPKJAMEF\u0040\u003F\u0024CFd\u003F\u0024AA\u0040;
  internal static \u003F\u003F_C\u0040_09POOGIAIO\u0040\u003F4\u003F2tyr\u003F4exe\u003F\u0024AA\u0040\u0024\u0024BY0A\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_09POOGIAIO\u0040\u003F4\u003F2tyr\u003F4exe\u003F\u0024AA\u0040;
  [FixedAddressValueType]
  internal static int virus\u002Ev;
  [FixedAddressValueType]
  internal static unsafe _iobuf* virus\u002Ef;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FA0x7d798523\u0040_HUGE\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x7d798523\u002E_HUGE = double.PositiveInfinity;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FA0x7d798523\u0040HUGE\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x7d798523\u002EHUGE = \u003CModule\u003E.\u003FA0x7d798523\u002E_HUGE;

  internal static char* PtrToStringChars(string s)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* stringChars = (byte*) s;
    if (stringChars != null)
    {
      // ISSUE: cast to a reference type
      stringChars = (byte*) (RuntimeHelpers.OffsetToStringData + (IntPtr) stringChars);
    }
    // ISSUE: cast to a reference type
    return (char&) stringChars;
  }

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x7d798523\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static unsafe ActivationContext* \u003CCrtImplementationDetails\u003E\u002EActivationContext\u002E\u007Bctor\u007D(
    [In] ActivationContext* obj0)
  {
    *(int*) obj0 = -1;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) ((IntPtr) obj0 + 8));
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EActivationContext\u002E\u007Bdtor\u007D(
    [In] ActivationContext* obj0)
  {
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002ERelease(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EActivationContext\u002ECreate(
    [In] ActivationContext* obj0)
  {
    if (*(int*) obj0 != -1 || \u003CModule\u003E.GetProcAddress(\u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_1BC\u0040EKMDCNOB\u0040\u003F\u0024AAK\u003F\u0024AAE\u003F\u0024AAR\u003F\u0024AAN\u003F\u0024AAE\u003F\u0024AAL\u003F\u0024AA3\u003F\u0024AA2\u003F\u0024AA\u003F\u0024AA\u0040), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0O\u0040JKAFBCMB\u0040CreateActCtxW\u003F\u0024AA\u0040) == null)
      return;
    bool flag = false;
    string str = Assembly.GetCallingAssembly().Location;
    try
    {
      if (str == "")
      {
        string tempFileName = Path.GetTempFileName();
        StreamWriter text = File.CreateText(tempFileName);
        text.Write("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<assembly xmlns=\"urn:schemas-microsoft-com:asm.v1\" manifestVersion=\"1.0\">\n   <dependency>\n       <dependentAssembly>\n           <assemblyIdentity\n               type='win32'\n               name='Microsoft.VC80.CRT'\n               version='8.0.50608.0'\n               processorArchitecture='x86'\n               publicKeyToken='1fc8b3b9a1e18e3b'/>\n       </dependentAssembly>\n   </dependency>\n</assembly>\n");
        text.Close();
        flag = true;
        str = tempFileName;
      }
      fixed (char* chPtr = &\u003CModule\u003E.PtrToStringChars(str))
      {
        // ISSUE: variable of a reference type
        char* local;
        // ISSUE: fault handler
        try
        {
          tagACTCTXW tagActctxw;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(short&) ((IntPtr) &tagActctxw + 12) = (short) 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(short&) ((IntPtr) &tagActctxw + 14) = (short) 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &tagActctxw + 16) = 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &tagActctxw + 24) = 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &tagActctxw + 28) = 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref tagActctxw = 32;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &tagActctxw + 8) = (int) chPtr;
          if (flag)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &tagActctxw + 20) = 0;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &tagActctxw + 4) = 0;
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &tagActctxw + 20) = 2;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &tagActctxw + 4) = 8;
          }
          void* actCtxW = \u003CModule\u003E.CreateActCtxW(&tagActctxw);
          *(int*) obj0 = (int) actCtxW;
          if ((IntPtr) actCtxW == new IntPtr(-1))
          {
            if (!flag)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              ^(int&) ((IntPtr) &tagActctxw + 20) = 1;
              *(int*) obj0 = (int) \u003CModule\u003E.CreateActCtxW(&tagActctxw);
            }
          }
        }
        __fault
        {
          // ISSUE: cast to a reference type
          local = (char*) 0;
        }
        // ISSUE: cast to a reference type
        local = (char*) 0;
      }
    }
    finally
    {
      if (flag)
        File.Delete(str);
    }
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EActivationContext\u002EActivate(
    [In] ActivationContext* obj0)
  {
    uint num = (uint) *(int*) obj0;
    if (num == uint.MaxValue)
      return;
    \u003CModule\u003E.ActivateActCtx((void*) num, (uint*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EActivationContext\u002EDeActivate(
    [In] ActivationContext* obj0)
  {
    if (*(int*) obj0 == -1)
      return;
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 == 0U)
      return;
    uint num2 = num1;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    if (\u003CModule\u003E.DeactivateActCtx(0U, num2) != 0)
      return;
    ActivationContext* activationContextPtr = (ActivationContext*) ((IntPtr) obj0 + 8);
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) activationContextPtr, "The C++ module failed to Deactivate WinSXS Activation Context.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) activationContextPtr));
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EActivationContext\u002ERelease(
    [In] ActivationContext* obj0)
  {
    if (*(int*) obj0 == -1)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002EDeActivate(obj0);
    \u003CModule\u003E.ReleaseActCtx((void*) *(int*) obj0);
    *(int*) obj0 = -1;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x7d798523\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    ActivationContext activationContext;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002E\u007Bctor\u007D(&activationContext);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002ECreate(&activationContext);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002EActivate(&activationContext);
      \u003CModule\u003E.clock();
      \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002EDeActivate(&activationContext);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002ERelease(&activationContext);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
      \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002E\u007Bdtor\u007D), (void*) &activationContext);
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EActivationContext\u002E\u007Bdtor\u007D(&activationContext);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  [PrePrepareMethod]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    \u003CModule\u003E._app_exit_callback();
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  internal static int _atexit_m(__FnPtr<void ()> _Function) => \u003CModule\u003E._atexit_m_appdomain(_Function);

  internal static int atexit(__FnPtr<void ()> _Function) => \u003CModule\u003E._atexit_m_appdomain(_Function);

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EInitialize()
  {
    object obj = new object();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A = 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A, obj);
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A) != null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter() => Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit() => Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));

  internal static void \u003FA0x49040904\u002E\u003F\u003F__E\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x49040904\u002E\u003F\u003F__F\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0x49040904\u002E\u003F\u003F__F\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A);

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x49040904\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x49040904\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x49040904\u002E__alloc_global_lock()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EInitialize();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend,
    __FnPtr<void ()>** __ponexitbegin)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x49040904\u002E__global_lock())
    {
      try
      {
        if (*__pexit_list_size - 1U < (uint) (*(int*) __ponexitend - *(int*) __ponexitbegin) >> 2)
        {
          try
          {
            uint num2 = *__pexit_list_size * 4U;
            uint num3 = num2 >= 2048U ? 2048U : num2;
            IntPtr cb = new IntPtr((int) num2 + (int) num3);
            IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) __ponexitbegin), cb);
            __FnPtr<void ()>** local2 = __ponexitend;
            IntPtr num5 = *(int*) local2 + ((IntPtr) num4.ToPointer() - *(int*) __ponexitbegin);
            *(int*) local2 = (int) num5;
            *(int*) __ponexitbegin = (int) num4.ToPointer();
            uint num6 = *__pexit_list_size;
            uint num7 = 512U >= num6 ? num6 : 512U;
            *__pexit_list_size = num6 + num7;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) __ponexitbegin), cb);
            __FnPtr<void ()>** local3 = __ponexitend;
            IntPtr num9 = *(int*) local3 + ((IntPtr) num8.ToPointer() - *(int*) __ponexitbegin);
            *(int*) local3 = (int) num9;
            *(int*) __ponexitbegin = (int) num8.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num10 = (int) *numPtr + 4;
            *numPtr = (uint) num10;
          }
        }
        *(int*) *(int*) __ponexitend = (int) func;
        __FnPtr<void ()>** local4 = __ponexitend;
        int num11 = *(int*) local4 + 4;
        *(int*) local4 = num11;
        local1 = func;
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x49040904\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x49040904\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(__clean_type_info_names));
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    if ((IntPtr) \u003CModule\u003E.__onexitbegin_app_domain == new IntPtr(-1) || (IntPtr) \u003CModule\u003E.__onexitbegin_app_domain == IntPtr.Zero)
      return;
    if ((IntPtr) \u003CModule\u003E.__onexitend_app_domain == IntPtr.Zero)
      return;
    try
    {
      while (true)
      {
        do
        {
          \u003CModule\u003E.__onexitend_app_domain -= 4;
          if (\u003CModule\u003E.__onexitend_app_domain < \u003CModule\u003E.__onexitbegin_app_domain)
            goto label_8;
        }
        while (*(int*) \u003CModule\u003E.__onexitend_app_domain == 0);
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) *(int*) \u003CModule\u003E.__onexitend_app_domain)();
      }
label_8:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) \u003CModule\u003E.__onexitbegin_app_domain));
    }
  }

  internal static __FnPtr<int ()> _onexit_m_appdomain(__FnPtr<int ()> _Function) => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) _Function) != -1 ? _Function : (__FnPtr<int ()>) 0;

  [DebuggerStepThrough]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper(func, &\u003CModule\u003E.__exit_list_size_app_domain, &\u003CModule\u003E.__onexitend_app_domain, &\u003CModule\u003E.__onexitbegin_app_domain);

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EConstruct(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0,
    object value)
  {
    *(int*) obj0 = 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(obj0, value);
  }

  [DebuggerStepThrough]
  internal static unsafe object \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    uint num = (uint) *(int*) obj0;
    return num != 0U ? (ValueType) GCHandle.FromIntPtr(new IntPtr((void*) num)) : (ValueType) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0,
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    if (valueType == null)
    {
      IntPtr intPtr = GCHandle.ToIntPtr(GCHandle.Alloc(value));
      *(int*) obj0 = (int) intPtr.ToPointer();
    }
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003FA0x481a9c16\u002E__DestructExceptionObject_m(
    EHExceptionRecord* pExcept,
    byte fThrowNotAllowed)
  {
    // ISSUE: unable to decompile the method.
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int ___CxxExceptionFilter(
    void* ppExcept,
    void* pType,
    int adjectives,
    void* pBuildObj)
  {
    if ((IntPtr) ppExcept == IntPtr.Zero)
      return 0;
    EHExceptionRecord* pExcept = (EHExceptionRecord*) *(int*) ppExcept;
    if ((IntPtr) pType == IntPtr.Zero || *(sbyte*) ((IntPtr) pType + 8) == (sbyte) 0)
    {
      uint num1 = (uint) *(int*) pExcept;
      if (num1 == 3762507597U || (adjectives & 64) == 0)
      {
        if (num1 == 3765269347U && *(int*) ((IntPtr) pExcept + 16) == 3 && (*(int*) ((IntPtr) pExcept + 20) == 26820608 || *(int*) ((IntPtr) pExcept + 28) == 0) && *(int*) ((IntPtr) pExcept + 28) == 0 && *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == 0)
          return 0;
        IntPtr num2 = (IntPtr) \u003CModule\u003E._getptd() + 144;
        *(int*) num2 = *(int*) num2 + 1;
        return 1;
      }
    }
    if (*(int*) pExcept == -529697949 && *(int*) ((IntPtr) pExcept + 16) == 3 && (*(int*) ((IntPtr) pExcept + 20) == 26820608 || *(int*) ((IntPtr) pExcept + 28) == 0))
    {
      if (*(int*) ((IntPtr) pExcept + 28) == 0)
      {
        if (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == 0)
          return 0;
        pExcept = (EHExceptionRecord*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136);
      }
      _s_HandlerType sHandlerType;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &sHandlerType + 4) = (int) pType;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref sHandlerType = adjectives | int.MinValue;
      int num3 = *(int*) (*(int*) ((IntPtr) pExcept + 28) + 12);
      _s_CatchableType** sCatchableTypePtr1 = (_s_CatchableType**) (num3 + 4);
      int num4 = *(int*) num3;
      if (num4 > 0)
      {
        _s_CatchableType* sCatchableTypePtr2;
        do
        {
          sCatchableTypePtr2 = (_s_CatchableType*) *(int*) sCatchableTypePtr1;
          if (\u003CModule\u003E.\u003FA0x481a9c16\u002ETypeMatch\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u002Cstruct\u0020_s_ThrowInfo\u0020const\u0020\u003E(&sHandlerType, sCatchableTypePtr2, (_s_ThrowInfo*) *(int*) ((IntPtr) pExcept + 28)) == 0)
          {
            --num4;
            sCatchableTypePtr1 += 4;
          }
          else
            goto label_12;
        }
        while (num4 > 0);
        goto label_15;
label_12:
        IntPtr num5 = (IntPtr) \u003CModule\u003E._getptd() + 144;
        *(int*) num5 = *(int*) num5 + 1;
        if ((IntPtr) pBuildObj != IntPtr.Zero)
          \u003CModule\u003E.\u003FA0x481a9c16\u002EBuildCatchObject\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(pExcept, pBuildObj, &sHandlerType, sCatchableTypePtr2);
        return 1;
      }
    }
label_15:
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int ___CxxRegisterExceptionObject(void* ppExcept, void* pStorage)
  {
    if ((IntPtr) ppExcept != IntPtr.Zero)
    {
      uint num = (uint) *(int*) ppExcept;
      if (num != 0U)
      {
        EHExceptionRecord* ehExceptionRecordPtr = (EHExceptionRecord*) num;
        if (*(int*) ehExceptionRecordPtr == -529697949 && *(int*) ((IntPtr) ehExceptionRecordPtr + 16) == 3 && (*(int*) ((IntPtr) ehExceptionRecordPtr + 20) == 26820608 || *(int*) ((IntPtr) ehExceptionRecordPtr + 28) == 0) && *(int*) ((IntPtr) ehExceptionRecordPtr + 28) == 0)
          ehExceptionRecordPtr = (EHExceptionRecord*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136);
        \u003CModule\u003E._CreateFrameInfo((FrameInfo*) pStorage, (void*) *(int*) ((IntPtr) ehExceptionRecordPtr + 24));
        *(int*) ((IntPtr) pStorage + 8) = *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136);
        *(int*) ((IntPtr) pStorage + 8 + 4) = *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 140);
        *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) = (int) ehExceptionRecordPtr;
        goto label_6;
      }
    }
    *(int*) ((IntPtr) pStorage + 8) = -1;
    *(int*) ((IntPtr) pStorage + 8 + 4) = -1;
label_6:
    IntPtr num1 = (IntPtr) \u003CModule\u003E._getptd() + 144;
    *(int*) num1 = *(int*) num1 - 1;
    if (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 144) < 0)
      *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 144) = 0;
    return 1;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int ___CxxDetectRethrow(void* ppExcept)
  {
    if ((IntPtr) ppExcept == IntPtr.Zero)
      return 0;
    EHExceptionRecord* ehExceptionRecordPtr = (EHExceptionRecord*) *(int*) ppExcept;
    if (*(int*) ehExceptionRecordPtr != -529697949 || *(int*) ((IntPtr) ehExceptionRecordPtr + 16) != 3 || *(int*) ((IntPtr) ehExceptionRecordPtr + 20) != 26820608 && *(int*) ((IntPtr) ehExceptionRecordPtr + 28) != 0 || *(int*) ((IntPtr) ehExceptionRecordPtr + 28) != 0)
      return 0;
    IntPtr num = (IntPtr) \u003CModule\u003E._getptd() + 144;
    *(int*) num = *(int*) num + 1;
    return 1;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxUnregisterExceptionObject(void* pStorage, int rethrow)
  {
    EHExceptionRecord** ehExceptionRecordPtr = (EHExceptionRecord**) ((IntPtr) pStorage + 8);
    _CONTEXT** contextPtr = (_CONTEXT**) ((IntPtr) ehExceptionRecordPtr + 4);
    if (*(int*) ehExceptionRecordPtr == -1)
      return;
    \u003CModule\u003E._FindAndUnlinkFrame((FrameInfo*) pStorage);
    if (rethrow == 0 && *(int*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == -529697949 && *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 16) == 3 && (*(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 20) == 26820608 || *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 28) == 0) && \u003CModule\u003E._IsExceptionObjectToBeDestroyed((void*) *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 24)) != 0)
      \u003CModule\u003E.\u003FA0x481a9c16\u002E__DestructExceptionObject_m((EHExceptionRecord*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136), (byte) 1);
    if (*(int*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == -529697949 && *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 16) == 3 && (*(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 20) == 26820608 || *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 28) == 0) && rethrow != 0)
    {
      IntPtr num = (IntPtr) \u003CModule\u003E._getptd() + 144;
      *(int*) num = *(int*) num - 1;
    }
    *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) = *(int*) ehExceptionRecordPtr;
    *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 140) = *(int*) contextPtr;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static int ___CxxQueryExceptionSize() => 16;

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDelDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindVecDtor(
    __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> pVecDtor,
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      void* voidPtr = ptr;
      int num1 = (int) size;
      int num2 = count;
      __FnPtr<void (void*)> local = pDtor;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli(pVecDtor)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0x481a9c16\u002ETypeMatch\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u002Cstruct\u0020_s_ThrowInfo\u0020const\u0020\u003E(
    _s_HandlerType* pCatch,
    _s_CatchableType* pCatchable,
    _s_ThrowInfo* pThrow)
  {
    uint num1 = (uint) *(int*) ((IntPtr) pCatch + 4);
    if (num1 != 0U)
    {
      int num2 = (int) num1 + 8;
      if (*(sbyte*) num2 != (sbyte) 0)
      {
        uint num3 = (uint) *(int*) ((IntPtr) pCatchable + 4);
        if ((int) num1 != (int) num3 && \u003CModule\u003E.strcmp((sbyte*) num2, (sbyte*) ((int) num3 + 8)) != 0)
          return 0;
        int num4;
        if ((*(int*) pCatchable & 2) == 0 || (*(int*) pCatch & 8) != 0)
        {
          uint num5 = (uint) *(int*) pThrow;
          if ((((int) num5 & 1) == 0 || (*(int*) pCatch & 1) != 0) && (((int) num5 & 2) == 0 || (*(int*) pCatch & 2) != 0))
          {
            num4 = 1;
            goto label_8;
          }
        }
        num4 = 0;
label_8:
        return num4;
      }
    }
    return 1;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003FA0x481a9c16\u002EBuildCatchObject\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(
    EHExceptionRecord* pExcept,
    void* pRN,
    _s_HandlerType* pCatch,
    _s_CatchableType* pConv)
  {
    if ((*(int*) pCatch & int.MinValue) == 0)
      \u003CModule\u003E._inconsistency();
    try
    {
      switch (\u003CModule\u003E.\u003FA0x481a9c16\u002EBuildCatchObjectHelper\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(pExcept, pRN, pCatch, pConv))
      {
        case 1:
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (void*, void*)>) *(int*) ((IntPtr) pConv + 24))(pRN, \u003CModule\u003E.__AdjustPointer((void*) *(int*) ((IntPtr) pExcept + 24), (PMD*) ((IntPtr) pConv + 8)));
          break;
        case 2:
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (void*, void*, int)>) *(int*) ((IntPtr) pConv + 24))((int) pRN, \u003CModule\u003E.__AdjustPointer((void*) *(int*) ((IntPtr) pExcept + 24), (PMD*) ((IntPtr) pConv + 8)), (void*) 1);
          break;
      }
    }
    catch (Exception ex) when (true)
    {
      \u003CModule\u003E.terminate();
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0x481a9c16\u002EBuildCatchObjectHelper\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(
    EHExceptionRecord* pExcept,
    void* pRN,
    _s_HandlerType* pCatch,
    _s_CatchableType* pConv)
  {
    int num1 = 0;
    uint num2 = (uint) *(int*) ((IntPtr) pCatch + 4);
    if (num2 == 0U || *(sbyte*) ((int) num2 + 8) == (sbyte) 0 || *(int*) ((IntPtr) pCatch + 8) == 0 && (*(int*) pCatch & int.MinValue) == 0)
      return 0;
    if ((*(int*) pCatch & int.MinValue) == 0)
      \u003CModule\u003E._inconsistency();
    try
    {
      if ((*(int*) pCatch & 8) != 0)
      {
        if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite(pRN, 1U) != 0)
        {
          int num3 = *(int*) ((IntPtr) pExcept + 24);
          *(int*) pRN = num3;
          *(int*) pRN = (int) \u003CModule\u003E.__AdjustPointer((void*) num3, (PMD*) ((IntPtr) pConv + 8));
        }
        else
          \u003CModule\u003E._inconsistency();
      }
      else if ((*(int*) pConv & 1) != 0)
      {
        if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite(pRN, 1U) != 0)
        {
          \u003CModule\u003E.memmove(pRN, (void*) *(int*) ((IntPtr) pExcept + 24), (uint) *(int*) ((IntPtr) pConv + 20));
          if (*(int*) ((IntPtr) pConv + 20) == 4)
          {
            uint num4 = (uint) *(int*) pRN;
            if (num4 != 0U)
              *(int*) pRN = (int) \u003CModule\u003E.__AdjustPointer((void*) num4, (PMD*) ((IntPtr) pConv + 8));
          }
        }
        else
          \u003CModule\u003E._inconsistency();
      }
      else if (*(int*) ((IntPtr) pConv + 24) == 0)
      {
        if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite(pRN, 1U) != 0)
          \u003CModule\u003E.memmove(pRN, \u003CModule\u003E.__AdjustPointer((void*) *(int*) ((IntPtr) pExcept + 24), (PMD*) ((IntPtr) pConv + 8)), (uint) *(int*) ((IntPtr) pConv + 20));
        else
          \u003CModule\u003E._inconsistency();
      }
      else
      {
        // ISSUE: cast to a function pointer type
        if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite(pRN, 1U) != 0 && \u003CModule\u003E._ValidateExecute((__FnPtr<int ()>) *(int*) ((IntPtr) pConv + 24)) != 0)
          num1 = (*(int*) pConv & 4) != 0 ? 2 : 1;
        else
          \u003CModule\u003E._inconsistency();
      }
    }
    catch (Exception ex) when (true)
    {
      \u003CModule\u003E.terminate();
    }
    return num1;
  }

  [SpecialName]
  internal static unsafe type_info* type_info\u002E\u007Bctor\u007D(
    [In] type_info* obj0,
    type_info* rhs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7type_info\u0040\u00406B\u0040 + 4);
    return obj0;
  }

  internal static unsafe void* type_info\u002E__vecDelDtor([In] type_info* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      type_info* typeInfoPtr = (type_info*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) typeInfoPtr, (__FnPtr<void (void*)>) __methodptr(type_info\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) typeInfoPtr);
      return (void*) typeInfoPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7type_info\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.type_info\u002E_Type_info_dtor(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe type_info* type_info\u002E\u003D([In] type_info* obj0, type_info* rhs) => obj0;

  internal static unsafe void _invoke_watson_if_error(
    int _ExpressionError,
    char* _Expression,
    char* _Function,
    char* _File,
    uint _Line,
    uint _Reserved)
  {
    if (_ExpressionError == 0)
      return;
    \u003CModule\u003E._invoke_watson(_Expression, _Function, _File, _Line, _Reserved);
  }

  internal static unsafe sbyte* type_info\u002Ename(
    [In] type_info* obj0,
    __type_info_node* __ptype_info_node)
  {
    return \u003CModule\u003E.type_info\u002E_Name_base(obj0, __ptype_info_node);
  }

  internal static unsafe void type_info\u002E\u007Bdtor\u007D([In] type_info* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7type_info\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.type_info\u002E_Type_info_dtor(obj0);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool type_info\u002E\u003D\u003D([In] type_info* obj0, type_info* rhs) => \u003CModule\u003E.strcmp((sbyte*) ((IntPtr) rhs + 9), (sbyte*) ((IntPtr) obj0 + 9)) == 0;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool type_info\u002E\u0021\u003D([In] type_info* obj0, type_info* rhs) => \u003CModule\u003E.strcmp((sbyte*) ((IntPtr) rhs + 9), (sbyte*) ((IntPtr) obj0 + 9)) != 0;

  internal static unsafe int type_info\u002Ebefore([In] type_info* obj0, type_info* rhs) => \u003CModule\u003E.strcmp((sbyte*) ((IntPtr) rhs + 9), (sbyte*) ((IntPtr) obj0 + 9)) > 0 ? 1 : 0;

  internal static unsafe sbyte* type_info\u002Eraw_name([In] type_info* obj0) => (sbyte*) ((IntPtr) obj0 + 8);

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void type_info\u002E_Type_info_dtor(type_info* _param0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Thread.BeginThreadAffinity();
        \u003CModule\u003E._lock(14);
        flag = true;
      }
      uint num = (uint) *(int*) ((IntPtr) _param0 + 4);
      if (num == 0U)
        return;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      __type_info_node* typeInfoNodePtr1 = (__type_info_node*) ^(int&) ((IntPtr) &\u003CModule\u003E.__type_info_root_node + 4);
      __type_info_node* typeInfoNodePtr2 = &\u003CModule\u003E.__type_info_root_node;
      for (; (IntPtr) typeInfoNodePtr1 != IntPtr.Zero; typeInfoNodePtr1 = typeInfoNodePtr1)
      {
        if (*(int*) typeInfoNodePtr1 == (int) num)
        {
          *(int*) ((IntPtr) typeInfoNodePtr2 + 4) = *(int*) ((IntPtr) typeInfoNodePtr1 + 4);
          \u003CModule\u003E.free((void*) typeInfoNodePtr1);
          break;
        }
        typeInfoNodePtr2 = typeInfoNodePtr1;
      }
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) _param0 + 4));
      *(int*) ((IntPtr) _param0 + 4) = 0;
    }
    finally
    {
      if (flag)
      {
        \u003CModule\u003E._unlock(14);
        Thread.EndThreadAffinity();
      }
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe sbyte* type_info\u002E_Name_base(
    type_info* __unnamed000,
    __type_info_node* __ptype_info_node)
  {
    if (*(int*) ((IntPtr) __unnamed000 + 4) == 0)
    {
      void* voidPtr1 = \u003CModule\u003E.__unDNameHelper((sbyte*) 0, (sbyte*) ((IntPtr) __unnamed000 + 9), 0, (ushort) 0);
      if ((IntPtr) voidPtr1 == IntPtr.Zero)
        return (sbyte*) 0;
      uint num = \u003CModule\u003E.strlen((sbyte*) voidPtr1);
      if (num > 0U)
      {
        do
        {
          --num;
          if (*(sbyte*) ((IntPtr) voidPtr1 + (int) num) == (sbyte) 32)
            *(sbyte*) ((IntPtr) voidPtr1 + (int) num) = (sbyte) 0;
          else
            goto label_7;
        }
        while (num > 0U);
      }
      --num;
label_7:
      bool flag = false;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          Thread.BeginThreadAffinity();
          \u003CModule\u003E._lock(14);
          flag = true;
        }
        if (*(int*) ((IntPtr) __unnamed000 + 4) == 0)
        {
          __type_info_node* typeInfoNodePtr = (__type_info_node*) \u003CModule\u003E.malloc(8U);
          if ((IntPtr) typeInfoNodePtr != IntPtr.Zero)
          {
            void* voidPtr2 = \u003CModule\u003E.malloc(num + 2U);
            *(int*) ((IntPtr) __unnamed000 + 4) = (int) voidPtr2;
            if ((IntPtr) voidPtr2 != IntPtr.Zero)
            {
              if (\u003CModule\u003E.strcpy_s((sbyte*) voidPtr2, num + 2U, (sbyte*) voidPtr1) != 0)
                \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
              *(int*) typeInfoNodePtr = *(int*) ((IntPtr) __unnamed000 + 4);
              *(int*) ((IntPtr) typeInfoNodePtr + 4) = *(int*) ((IntPtr) __ptype_info_node + 4);
              *(int*) ((IntPtr) __ptype_info_node + 4) = (int) typeInfoNodePtr;
            }
            else
              \u003CModule\u003E.free((void*) typeInfoNodePtr);
          }
        }
        \u003CModule\u003E.free(voidPtr1);
      }
      finally
      {
        if (flag)
        {
          \u003CModule\u003E._unlock(14);
          Thread.EndThreadAffinity();
        }
      }
    }
    return (sbyte*) *(int*) ((IntPtr) __unnamed000 + 4);
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __clean_type_info_names_internal(
    __type_info_node* p_type_info_root_node)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Thread.BeginThreadAffinity();
        \u003CModule\u003E._lock(14);
        flag = true;
      }
      __type_info_node* typeInfoNodePtr1 = (__type_info_node*) *(int*) ((IntPtr) p_type_info_root_node + 4);
      __type_info_node* typeInfoNodePtr2;
      for (; (IntPtr) typeInfoNodePtr1 != IntPtr.Zero; typeInfoNodePtr1 = typeInfoNodePtr2)
      {
        typeInfoNodePtr2 = (__type_info_node*) *(int*) ((IntPtr) typeInfoNodePtr1 + 4);
        \u003CModule\u003E.free((void*) *(int*) typeInfoNodePtr1);
        \u003CModule\u003E.free((void*) typeInfoNodePtr1);
      }
    }
    finally
    {
      if (flag)
      {
        \u003CModule\u003E._unlock(14);
        Thread.EndThreadAffinity();
      }
    }
  }

  internal static unsafe void __clean_type_info_names() => \u003CModule\u003E.__clean_type_info_names_internal(&\u003CModule\u003E.__type_info_root_node);

  internal static unsafe void \u003FA0x2a41d782\u002E\u003F\u003F__E\u003F\u003F_7type_info\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7type_info\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4type_info\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7type_info\u0040\u00406B\u0040 + 4) = (int) __methodptr(type_info\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x2a41d782\u002E\u003F\u003F__E\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7type_info\u0040\u00406B\u0040 + 4);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408 + 4) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: cpblk instruction
    __memcpy((\u0024_TypeDescriptor\u0024_extraBytes_16&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408 + 8), ref \u003CModule\u003E.\u003F\u003F_C\u0040_0BA\u0040NOJDBDJO\u0040\u003F4\u003F\u0024DPAVtype_info\u003F\u0024EA\u003F\u0024EA\u003F\u0024AA\u0040, 16);
  }

  internal static unsafe void \u003FA0x2a41d782\u002E\u003F\u003F__E\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 = (int) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 + 4) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 + 8) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 + 12) = -1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 + 16) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 + 20) = 64;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408 + 24) = (int) &\u003CModule\u003E.\u003F\u003F_R3type_info\u0040\u00408;
  }

  internal static unsafe void \u003FA0x2a41d782\u002E\u003F\u003F__E\u003F\u003F_R2type_info\u0040\u00408\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003F\u003F_R2type_info\u0040\u00408 = (int) &\u003CModule\u003E.\u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040type_info\u0040\u00408;

  internal static unsafe void \u003FA0x2a41d782\u002E\u003F\u003F__E\u003F\u003F_R3type_info\u0040\u00408\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_R3type_info\u0040\u00408 = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R3type_info\u0040\u00408 + 4) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R3type_info\u0040\u00408 + 8) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R3type_info\u0040\u00408 + 12) = (int) &\u003CModule\u003E.\u003F\u003F_R2type_info\u0040\u00408;
  }

  internal static unsafe void \u003FA0x2a41d782\u002E\u003F\u003F__E\u003F\u003F_R4type_info\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_R4type_info\u0040\u00406B\u0040 = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R4type_info\u0040\u00406B\u0040 + 4) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R4type_info\u0040\u00406B\u0040 + 8) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R4type_info\u0040\u00406B\u0040 + 12) = (int) &\u003CModule\u003E.\u003F\u003F_R0\u003FAVtype_info\u0040\u0040\u00408;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_R4type_info\u0040\u00406B\u0040 + 16) = (int) &\u003CModule\u003E.\u003F\u003F_R3type_info\u0040\u00408;
  }

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern void _unlock(int _File);

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern void _lock(int _File);

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0xe6292fd0\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(int*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0xe6292fd0\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [STAThread]
  internal static int main(string[] args)
  {
    Application.EnableVisualStyles();
    Application.SetCompatibleTextRenderingDefault(false);
    Application.Run((Form) new Form1());
    return 0;
  }

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern unsafe __FnPtr<int ()> GetProcAddress([In] HINSTANCE__* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern unsafe void ReleaseActCtx([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern int DeactivateActCtx([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern int clock();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern unsafe int ActivateActCtx([In] void* obj0, [In] uint* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern unsafe void* CreateActCtxW([In] tagACTCTXW* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern unsafe HINSTANCE__* GetModuleHandleW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("msvcm80.dll", EntryPoint = "?ThrowModuleLoadException@<CrtImplementationDetails>@@YAXP$AAVString@System@@P$AAVException@3@@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("msvcm80.dll", EntryPoint = "?ThrowModuleLoadException@<CrtImplementationDetails>@@YAXP$AAVString@System@@@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("msvcm80.dll", EntryPoint = "?DoDllLanguageSupportValidation@<CrtImplementationDetails>@@YAXXZ", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("msvcm80.dll", EntryPoint = "?ThrowNestedModuleLoadException@<CrtImplementationDetails>@@YAXP$AAVException@System@@0@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    [In] Exception obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("msvcm80.dll", EntryPoint = "?RegisterModuleUninitializer@<CrtImplementationDetails>@@YAXP$AAVEventHandler@System@@@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    [In] EventHandler obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void* __AdjustPointer([In] void* obj0, [In] PMD* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", EntryPoint = "?_inconsistency@@YAXXZ", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void _inconsistency();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int _IsExceptionObjectToBeDestroyed([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", EntryPoint = "?terminate@@YAXXZ", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern void terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", EntryPoint = "?_ValidateRead@@YAHPBXI@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int _ValidateRead([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe _tiddata* _getptd();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe FrameInfo* _CreateFrameInfo([In] FrameInfo* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int strcmp([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", EntryPoint = "?_ValidateWrite@@YAHPAXI@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int _ValidateWrite([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void _FindAndUnlinkFrame([In] FrameInfo* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", EntryPoint = "?_ValidateExecute@@YAHP6GHXZ@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern int _ValidateExecute([In] __FnPtr<int ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void* memmove([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", EntryPoint = "??3@YAXPAX@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int strcpy_s([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void* __unDNameHelper(
    [In] sbyte* obj0,
    [In] sbyte* obj1,
    [In] int obj2,
    [In] ushort obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe uint strlen([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void* malloc([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void free([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe void _invoke_watson(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  public static extern unsafe uint WinExec([In] sbyte* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int fscanf([In] _iobuf* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int fclose([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe int fprintf([In] _iobuf* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR80.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  public static extern unsafe _iobuf* fopen([In] sbyte* obj0, [In] sbyte* obj1);
}
