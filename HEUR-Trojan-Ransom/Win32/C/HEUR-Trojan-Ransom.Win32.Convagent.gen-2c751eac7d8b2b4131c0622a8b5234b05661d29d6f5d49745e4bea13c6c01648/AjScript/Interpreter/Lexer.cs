// Decompiled with JetBrains decompiler
// Type: AjScript.Interpreter.Lexer
// Assembly: CryptoAPITransf, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3C6B9EE6-9C07-49E4-80B0-30EE0F446F3E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\HEUR-Trojan-Ransom.Win32.Convagent.gen-2c751eac7d8b2b4131c0622a8b5234b05661d29d6f5d49745e4bea13c6c01648.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

namespace AjScript.Interpreter
{
  public class Lexer : IDisposable
  {
    private const char StringChar = '"';
    private const char QuotedStringChar = '\'';
    private const string Operators = "!~+-*/%&|^<>=.\\@";
    private const string Separators = "()[]{},:;";
    private static string[] otherOperators = new string[15]
    {
      "++",
      "--",
      "<=",
      ">=",
      "==",
      "!=",
      "&&",
      "||",
      "*=",
      "/=",
      "%=",
      "+=",
      "-=",
      "===",
      "!=="
    };
    private TextReader reader;
    private Stack<Token> tokens;
    private char lastChar;
    private bool hasChar;
    private bool isConsole;
    private bool isFirstChar = true;

    public Lexer(string text)
    {
      this.reader = text != null ? (TextReader) new StringReader(text) : throw new ArgumentNullException(nameof (text));
      this.isConsole = false;
    }

    public Lexer(TextReader reader)
    {
      this.reader = reader != null ? reader : throw new ArgumentNullException(nameof (reader));
      this.isConsole = reader.Equals((object) Console.In);
    }

    public Token PeekToken()
    {
      Token token = this.NextToken();
      this.PushToken(token);
      return token;
    }

    public Token NextToken()
    {
      if (this.tokens != null && this.tokens.Count > 0)
        return this.tokens.Pop();
      char ch;
      try
      {
        ch = this.NextCharSkipBlanks();
      }
      catch (EndOfInputException ex)
      {
        return (Token) null;
      }
      if (char.IsDigit(ch))
        return this.NextInteger(ch);
      if (!char.IsLetter(ch))
      {
        switch (ch)
        {
          case '"':
            return this.NextString();
          case '\'':
            return this.NextQuotedString();
          case '_':
            break;
          default:
            if ("()[]{},:;".Contains<char>(ch))
              return this.NextSeparator(ch);
            return "!~+-*/%&|^<>=.\\@".Contains<char>(ch) ? this.NextOperator(ch) : throw new InvalidDataException(string.Format((IFormatProvider) CultureInfo.InvariantCulture, "Unknown input '{0}'", new object[1]
            {
              (object) ch
            }));
        }
      }
      return this.NextName(ch);
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    public void Dispose(bool dispose)
    {
      if (!dispose || this.reader == null)
        return;
      this.reader.Dispose();
    }

    public void PushToken(Token token)
    {
      if (this.tokens == null)
        this.tokens = new Stack<Token>();
      this.tokens.Push(token);
    }

    private Token NextOperator(char ch)
    {
      try
      {
        char ch1 = this.NextChar();
        string str1 = ch.ToString() + ch1.ToString();
        if (((IEnumerable<string>) Lexer.otherOperators).Contains<string>(str1))
        {
          try
          {
            char ch2 = this.NextChar();
            string str2 = str1 + ch2.ToString();
            if (((IEnumerable<string>) Lexer.otherOperators).Contains<string>(str2))
              return new Token()
              {
                TokenType = TokenType.Operator,
                Value = str2
              };
            this.PushChar(ch2);
          }
          catch (EndOfInputException ex)
          {
          }
          return new Token()
          {
            TokenType = TokenType.Operator,
            Value = str1
          };
        }
        this.PushChar(ch1);
      }
      catch (EndOfInputException ex)
      {
      }
      return new Token()
      {
        TokenType = TokenType.Operator,
        Value = ch.ToString()
      };
    }

    private Token NextSeparator(char ch) => new Token()
    {
      TokenType = TokenType.Separator,
      Value = ch.ToString()
    };

    private Token NextString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      char ch1 = char.MinValue;
      for (char ch2 = this.NextChar(); ch2 != '"' || ch1 == '\\'; ch2 = this.NextChar())
      {
        if (ch1 == '\\')
        {
          switch (ch2)
          {
            case '\\':
              ch1 = char.MinValue;
              continue;
            case 'a':
              --stringBuilder.Length;
              stringBuilder.Append('\a');
              goto case '\\';
            case 'b':
              --stringBuilder.Length;
              stringBuilder.Append('\b');
              goto case '\\';
            case 'e':
              --stringBuilder.Length;
              stringBuilder.Append('\u001B');
              goto case '\\';
            case 'f':
              --stringBuilder.Length;
              stringBuilder.Append('\f');
              goto case '\\';
            case 'n':
              --stringBuilder.Length;
              stringBuilder.Append('\n');
              goto case '\\';
            case 'r':
              --stringBuilder.Length;
              stringBuilder.Append('\r');
              goto case '\\';
            case 't':
              --stringBuilder.Length;
              stringBuilder.Append('\t');
              goto case '\\';
            case 'v':
              --stringBuilder.Length;
              stringBuilder.Append('\v');
              goto case '\\';
            default:
              --stringBuilder.Length;
              stringBuilder.Append(ch2);
              goto case '\\';
          }
        }
        else
        {
          stringBuilder.Append(ch2);
          ch1 = ch2;
        }
      }
      return new Token()
      {
        Value = stringBuilder.ToString(),
        TokenType = TokenType.String
      };
    }

    private Token NextQuotedString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      for (char ch = this.NextChar(); ch != '\''; ch = this.NextChar())
        stringBuilder.Append(ch);
      return new Token()
      {
        Value = stringBuilder.ToString(),
        TokenType = TokenType.String
      };
    }

    private Token NextInteger(char ch)
    {
      string integerPart = ch.ToString();
      try
      {
        for (ch = this.NextChar(); char.IsDigit(ch); ch = this.NextChar())
          integerPart += ch.ToString();
        if (ch == '.')
          return this.NextReal(integerPart);
        this.PushChar(ch);
      }
      catch (EndOfInputException ex)
      {
      }
      return new Token()
      {
        Value = integerPart,
        TokenType = TokenType.Integer
      };
    }

    private Token NextReal(string integerPart)
    {
      string str = integerPart + ".";
      try
      {
        char ch;
        for (ch = this.NextChar(); char.IsDigit(ch); ch = this.NextChar())
          str += ch.ToString();
        this.PushChar(ch);
      }
      catch (EndOfInputException ex)
      {
      }
      return new Token()
      {
        Value = str,
        TokenType = TokenType.Real
      };
    }

    private Token NextName(char ch)
    {
      string str = ch.ToString();
      try
      {
        for (ch = this.NextChar(); char.IsLetterOrDigit(ch) || ch == '_'; ch = this.NextChar())
          str += ch.ToString();
        this.PushChar(ch);
      }
      catch (EndOfInputException ex)
      {
      }
      Token token = new Token();
      token.Value = str;
      token.TokenType = TokenType.Name;
      if (str == "true" || str == "false")
        token.TokenType = TokenType.Boolean;
      if (str == "null" || str == "undefined")
        token.TokenType = TokenType.Object;
      return token;
    }

    private char NextCharSkipBlanks()
    {
      char c;
      for (c = this.NextChar(); char.IsWhiteSpace(c) || c == '/'; c = this.NextChar())
      {
        if (c == '/')
        {
          char ch = this.NextChar();
          switch (ch)
          {
            case '*':
              this.SkipToEndOfComment();
              continue;
            case '/':
              this.SkipToEndOfLine();
              continue;
            default:
              this.PushChar(ch);
              return c;
          }
        }
      }
      return c;
    }

    private void SkipToEndOfLine()
    {
      char ch = this.NextChar();
      while (ch != '\r' && ch != '\n')
        ch = this.NextChar();
      this.PushChar(ch);
    }

    private void SkipToEndOfComment()
    {
      char ch1 = this.NextChar();
      while (true)
      {
        while (ch1 != '*')
          ch1 = this.NextChar();
        char ch2 = this.NextChar();
        if (ch2 != '/')
          ch1 = ch2;
        else
          break;
      }
    }

    private void PushChar(char ch)
    {
      this.lastChar = ch;
      this.hasChar = true;
    }

    private char NextChar()
    {
      if (this.hasChar)
      {
        this.hasChar = false;
        return this.lastChar;
      }
      if (this.isConsole && (this.isFirstChar || this.reader.Peek() < 0))
      {
        Console.Out.Write("> ");
        Console.Out.Flush();
      }
      this.isFirstChar = false;
      int num = this.reader.Read();
      return num >= 0 ? Convert.ToChar(num) : throw new EndOfInputException();
    }
  }
}
