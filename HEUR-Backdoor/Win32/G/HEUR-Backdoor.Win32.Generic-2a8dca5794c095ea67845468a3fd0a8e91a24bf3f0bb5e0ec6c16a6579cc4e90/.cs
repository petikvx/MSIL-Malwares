// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Protected, Version=6.2.8400.0, Culture=neutral, PublicKeyToken=null
// MVID: 52CBE997-50C3-42B2-A704-C908D57869A5
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-2a8dca5794c095ea67845468a3fd0a8e91a24bf3f0bb5e0ec6c16a6579cc4e90.exe

using System;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

internal sealed class \uE024
{
  private \uE018 \uE000;
  private Type \uE001;
  private Type \uE002;
  private Type[] \uE003;
  private Type[] \uE004;

  public \uE024(\uE018 _param1) => this.\uE000 = _param1 != null ? _param1 : throw new ArgumentNullException("method");

  public Type \uE002 => this.\uE001;

  public Type \uE003 => this.\uE002;

  public Type[] \uE004 => this.\uE003;

  public Type[] \uE005 => this.\uE004;

  public \uE018 \uE000 => this.\uE000;

  internal DynamicMethod \uE000()
  {
    this.\uE001 = Type.GetType(((\uE021) this.\uE000).\uE001.\uE009);
label_2:
    int num1 = \uE026.\uE000(24);
    while (true)
    {
      switch ((num1 ^ 28) + 24)
      {
        case 0:
          this.\uE003 = this.\uE004;
          num1 = -9;
          continue;
        case 1:
          this.\uE002 = Type.GetType(((\uE000) this.\uE000).\uE003.\uE009);
          num1 = -10;
          continue;
        case 2:
          this.\uE004 = \uE01C.\uE000(((\uE000) this.\uE000).\uE001);
          num1 = -12;
          continue;
        case 3:
          if (this.\uE000.\uE006)
          {
            num1 = -16;
            continue;
          }
          goto label_9;
        case 4:
          goto label_8;
        default:
          goto label_2;
      }
    }
label_8:
    int num2 = 1;
    goto label_10;
label_9:
    num2 = 0;
label_10:
    if (num2 == 0)
    {
      this.\uE004 = new Type[this.\uE003.Length + 1];
      this.\uE004[0] = this.\uE001;
      if (this.\uE003.Length > 0)
        Array.Copy((Array) this.\uE003, 0, (Array) this.\uE004, 1, this.\uE003.Length);
    }
    DynamicMethod dynamicMethod = \uE024.\uE000(this.\uE000.\uE008, this.\uE002, this.\uE004, this.\uE001);
    dynamicMethod.InitLocals = this.\uE000.\uE005;
    DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
    SignatureHelper localVarSigHelper = SignatureHelper.GetLocalVarSigHelper();
    int index = 0;
    if (index == 0)
      goto label_15;
label_14:
    Type type = Type.GetType(this.\uE000.\uE001[index].\uE009);
    localVarSigHelper.AddArgument(type);
    ++index;
label_15:
    if (index >= this.\uE000.\uE001.Length)
    {
      byte[] signature = localVarSigHelper.GetSignature();
      dynamicIlInfo.SetLocalSignature(signature);
      MemoryStream output = new MemoryStream();
      BinaryWriter binaryWriter = new BinaryWriter((Stream) output);
      try
      {
        this.\uE000.\uE006.\uE000(this.\uE000, binaryWriter, dynamicIlInfo);
        if (this.\uE000.\uE002.Length > 0)
        {
          output.Position += 3L;
label_20:
          int num3 = \uE026.\uE000(28);
          byte[] exceptions;
          while (true)
          {
            switch ((num3 ^ 25) + 31)
            {
              case 0:
                output.Position &= -4L;
                num3 = -5;
                continue;
              case 1:
                exceptions = \uE024.\uE000(dynamicIlInfo, this.\uE000.\uE002, this.\uE000.\uE004);
                num3 = -6;
                continue;
              case 2:
                goto label_23;
              default:
                goto label_20;
            }
          }
label_23:
          dynamicIlInfo.SetExceptions(exceptions);
        }
        byte[] array = output.ToArray();
        dynamicIlInfo.SetCode(array, this.\uE000.\uE003);
      }
      finally
      {
        if ((binaryWriter == null ? 1 : 0) == 0)
          binaryWriter.Dispose();
      }
      return dynamicMethod;
    }
    goto label_14;
  }

  private static byte[] \uE000(DynamicILInfo _param0, \uE016[] _param1, bool _param2)
  {
    MemoryStream output = new MemoryStream();
    BinaryWriter binaryWriter = new BinaryWriter((Stream) output);
    try
    {
      if (_param1.Length < 21 && (!_param2 ? 0 : 1) == 0)
      {
        binaryWriter.Write((byte) 1);
label_4:
        int num = \uE026.\uE000(31);
        while (true)
        {
          \uE016[] objArray;
          int index;
          \uE016 obj;
          switch (num ^ 36)
          {
            case 35:
              index = 0;
              num = 2;
              continue;
            case 36:
label_6:
              obj = objArray[index];
              num = 13;
              continue;
            case 37:
              binaryWriter.Write(new byte[2]);
              num = 3;
              continue;
            case 38:
              if (index != 0)
              {
                num = 0;
                continue;
              }
              break;
            case 39:
              objArray = _param1;
              num = \uE026.\uE000(44);
              continue;
            case 40:
              binaryWriter.Write((byte) (_param1.Length * 12 + 2));
              num = 1;
              continue;
            case 41:
              \uE024.\uE005(_param0, binaryWriter, obj);
              num = 14;
              continue;
            case 42:
              ++index;
              break;
            default:
              goto label_4;
          }
          if (index < objArray.Length)
            goto label_6;
          else
            break;
        }
      }
      else
      {
        binaryWriter.Write((byte) 65);
label_17:
        int num1 = \uE026.\uE000(30);
        while (true)
        {
          int num2;
          int index;
          \uE016[] objArray;
          \uE016 obj;
          switch (num1 ^ 35)
          {
            case 29:
              binaryWriter.Write((byte) (num2 >> 16 & (int) byte.MaxValue));
              num1 = 7;
              continue;
            case 30:
              index = 0;
              num1 = \uE026.\uE000(35);
              continue;
            case 31:
              binaryWriter.Write((byte) (num2 & (int) byte.MaxValue));
              num1 = 2;
              continue;
            case 32:
label_21:
              obj = objArray[index];
              num1 = 0;
              continue;
            case 33:
              binaryWriter.Write((byte) (num2 >> 8 & (int) byte.MaxValue));
              num1 = 62;
              continue;
            case 34:
              num2 = _param1.Length * 24 + 4;
              num1 = 60;
              continue;
            case 35:
              \uE024.\uE006(_param0, binaryWriter, obj);
              num1 = 5;
              continue;
            case 36:
              objArray = _param1;
              num1 = 61;
              continue;
            case 37:
              if (index != 0)
              {
                num1 = 3;
                continue;
              }
              break;
            case 38:
              ++index;
              break;
            default:
              goto label_17;
          }
          if (index < objArray.Length)
            goto label_21;
          else
            break;
        }
      }
      return output.ToArray();
    }
    finally
    {
      if ((binaryWriter == null ? 1 : 0) == 0)
        binaryWriter.Dispose();
    }
  }

  private static void \uE005(DynamicILInfo _param0, BinaryWriter _param1, \uE016 _param2)
  {
    _param1.Write((ushort) _param2.\uE000);
label_2:
    int num = \uE026.\uE000(37);
    while (true)
    {
      switch ((num ^ 38) + 45)
      {
        case 0:
          \uE024.\uE007(_param0, _param1, _param2);
          num = \uE026.\uE000(38);
          continue;
        case 1:
          _param1.Write((ushort) _param2.\uE001);
          num = -16;
          continue;
        case 2:
          _param1.Write((ushort) _param2.\uE003);
          num = -15;
          continue;
        case 3:
          _param1.Write((byte) _param2.\uE002);
          num = -13;
          continue;
        case 4:
          _param1.Write((byte) _param2.\uE004);
          num = -11;
          continue;
        case 5:
          goto label_7;
        default:
          goto label_2;
      }
    }
label_7:;
  }

  private static void \uE006(DynamicILInfo _param0, BinaryWriter _param1, \uE016 _param2)
  {
    _param1.Write((uint) _param2.\uE000);
label_2:
    int num = \uE026.\uE000(42);
    while (true)
    {
      switch (num ^ 34)
      {
        case 46:
          \uE024.\uE007(_param0, _param1, _param2);
          num = 17;
          continue;
        case 47:
          _param1.Write((uint) _param2.\uE001);
          num = \uE026.\uE000(43);
          continue;
        case 48:
          _param1.Write((uint) _param2.\uE003);
          num = 16;
          continue;
        case 49:
          _param1.Write((uint) _param2.\uE002);
          num = 18;
          continue;
        case 50:
          _param1.Write((uint) _param2.\uE004);
          num = 12;
          continue;
        case 51:
          goto label_7;
        default:
          goto label_2;
      }
    }
label_7:;
  }

  private static void \uE007(DynamicILInfo _param0, BinaryWriter _param1, \uE016 _param2)
  {
    switch (_param2.\uE000)
    {
      case 0:
        uint tokenFor = (uint) _param0.GetTokenFor(Type.GetType(_param2.\uE005.\uE009).TypeHandle);
        _param1.Write(tokenFor);
        break;
      case 1:
        _param1.Write((uint) _param2.\uE006);
        break;
      default:
        _param1.Write(0);
        break;
    }
  }

  private static DynamicMethod \uE000(
    string _param0,
    Type _param1,
    Type[] _param2,
    Type _param3)
  {
    MethodAttributes attributes = MethodAttributes.Public | MethodAttributes.Static;
    return new DynamicMethod(_param0, attributes, CallingConventions.Standard, _param1, _param2, _param3, false);
  }
}
