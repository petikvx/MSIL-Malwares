// Decompiled with JetBrains decompiler
// Type: .
// Assembly: WindowsBC, Version=1.0.0.0, Culture=neutral, PublicKeyToken=9909ee17073e3364
// MVID: 658BFC85-36E1-493D-98E6-AE9127D73D60
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00004-msil\Trojan-Downloader.MSIL.BitCoinMiner.c-64f742a0b28b2c3d2a62ef6607fcfd5fa55b793a1aff3a6c11e014e3b119149e.exe

using \u000E;
using \u0093;
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;

namespace \u0093
{
  internal sealed class \u009C
  {
    private string \u0001;
    private ArrayList \u0002;
    private ArrayList \u0003;

    public \u009C([In] string obj0)
    {
      this.\u0001 = obj0;
      this.\u0002 = new ArrayList();
      this.\u0003 = new ArrayList();
      this.\u0092\u0003();
    }

    public static string[] \u008E\u0003([In] string obj0)
    {
      char ch = '\\';
      char[] array = new char[1]{ ';' };
      ArrayList arrayList = new ArrayList();
      if (obj0 != null && \u0011\u0003.\u007E\u0004\u0002((object) obj0) > 0)
      {
        int num1 = -1;
        StringBuilder stringBuilder1 = new StringBuilder();
        while (num1 < \u0011\u0003.\u007E\u0004\u0002((object) obj0))
        {
          ++num1;
          if (num1 >= \u0011\u0003.\u007E\u0004\u0002((object) obj0))
          {
            int num2 = \u0004\u0004.\u007E\u0004\u0004((object) arrayList, (object) \u0014\u0004.\u007E\u0093((object) stringBuilder1));
          }
          else if ((int) \u0089\u0003.\u007E\u0003\u0002((object) obj0, num1) == (int) ch)
          {
            ++num1;
            if (num1 >= \u0011\u0003.\u007E\u0004\u0002((object) obj0))
              throw new ArgumentException(\u0008.\u000E\u0003(690), \u0008.\u000E\u0003(739));
            if (Array.IndexOf<char>(array, \u0089\u0003.\u007E\u0003\u0002((object) obj0, num1)) < 0)
            {
              StringBuilder stringBuilder2 = \u008B\u0003.\u007E\u0087\u0002((object) stringBuilder1, ch);
            }
            StringBuilder stringBuilder3 = \u008B\u0003.\u007E\u0087\u0002((object) stringBuilder1, \u0089\u0003.\u007E\u0003\u0002((object) obj0, num1));
          }
          else if (Array.IndexOf<char>(array, \u0089\u0003.\u007E\u0003\u0002((object) obj0, num1)) >= 0)
          {
            int num3 = \u0004\u0004.\u007E\u0004\u0004((object) arrayList, (object) \u0014\u0004.\u007E\u0093((object) stringBuilder1));
            \u0006\u0005.\u007E\u0083\u0002((object) stringBuilder1, 0);
          }
          else
          {
            StringBuilder stringBuilder4 = \u008B\u0003.\u007E\u0087\u0002((object) stringBuilder1, \u0089\u0003.\u007E\u0003\u0002((object) obj0, num1));
          }
        }
      }
      // ISSUE: type reference
      return (string[]) \u0007\u0004.\u007E\u0006\u0004((object) arrayList, \u0002\u0004.\u0092\u0003(__typeref (string)));
    }

    public override string ToString() => this.\u0001;

    public bool \u008F\u0003([In] string obj0)
    {
      bool flag = false;
      if (\u0011\u0003.\u007E\u0003\u0004((object) this.\u0002) == 0)
      {
        flag = true;
      }
      else
      {
        IEnumerator enumerator = \u000E\u0004.\u007E\u0005\u0004((object) this.\u0002);
        try
        {
          while (\u0007\u0003.\u007E\u009C((object) enumerator))
          {
            Regex regex = (Regex) \u001B\u0005.\u007E\u009D((object) enumerator);
            if (\u0006\u0004.\u007E\u0015\u0006((object) regex, obj0))
            {
              flag = true;
              break;
            }
          }
        }
        finally
        {
          if (enumerator is IDisposable disposable)
            \u0093\u0003.\u007E\u009E((object) disposable);
        }
      }
      return flag;
    }

    public bool \u0090\u0003([In] string obj0)
    {
      bool flag = false;
      IEnumerator enumerator = \u000E\u0004.\u007E\u0005\u0004((object) this.\u0003);
      try
      {
        while (\u0007\u0003.\u007E\u009C((object) enumerator))
        {
          Regex regex = (Regex) \u001B\u0005.\u007E\u009D((object) enumerator);
          if (\u0006\u0004.\u007E\u0015\u0006((object) regex, obj0))
          {
            flag = true;
            break;
          }
        }
      }
      finally
      {
        if (enumerator is IDisposable disposable)
          \u0093\u0003.\u007E\u009E((object) disposable);
      }
      return flag;
    }

    public bool \u0091\u0003([In] string obj0) => this.\u008F\u0003(obj0) && !this.\u0090\u0003(obj0);

    private void \u0092\u0003()
    {
      if (this.\u0001 == null)
        return;
      string[] strArray = \u009C.\u008E\u0003(this.\u0001);
      for (int index = 0; index < strArray.Length; ++index)
      {
        if (strArray[index] != null && \u0011\u0003.\u007E\u0004\u0002((object) strArray[index]) > 0)
        {
          bool flag = \u0089\u0003.\u007E\u0003\u0002((object) strArray[index], 0) != '-';
          string pattern = \u0089\u0003.\u007E\u0003\u0002((object) strArray[index], 0) != '+' ? (\u0089\u0003.\u007E\u0003\u0002((object) strArray[index], 0) != '-' ? strArray[index] : \u001A\u0005.\u007E\u0007\u0002((object) strArray[index], 1, \u0011\u0003.\u007E\u0004\u0002((object) strArray[index]) - 1)) : \u001A\u0005.\u007E\u0007\u0002((object) strArray[index], 1, \u0011\u0003.\u007E\u0004\u0002((object) strArray[index]) - 1);
          if (flag)
          {
            int num1 = \u0004\u0004.\u007E\u0004\u0004((object) this.\u0002, (object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
          }
          else
          {
            int num2 = \u0004\u0004.\u007E\u0004\u0004((object) this.\u0003, (object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
          }
        }
      }
    }
  }
}
