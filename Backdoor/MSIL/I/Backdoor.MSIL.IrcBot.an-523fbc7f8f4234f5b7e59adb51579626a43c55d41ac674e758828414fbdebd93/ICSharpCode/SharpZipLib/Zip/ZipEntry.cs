// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.ZipEntry
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;
using System.IO;

namespace ICSharpCode.SharpZipLib.Zip
{
  public class ZipEntry : ICloneable
  {
    private ZipEntry.Known \uE010;
    private int \uE00F = -1;
    private ushort \uE00E;
    private string \uE00D;
    private ulong \uE00C;
    private ulong \uE00B;
    private ushort \uE00A;
    private uint \uE009;
    private uint \uE008;
    private CompressionMethod \uE007 = CompressionMethod.Deflated;
    private byte[] \uE006;
    private string \uE005;
    private int \uE004;
    private long \uE003 = -1;
    private long \uE002;
    private bool \uE001;
    private byte \uE000;

    public ZipEntry(string name)
      : this(name, 0, 45, CompressionMethod.Deflated)
    {
    }

    internal ZipEntry(string _param1, int _param2)
      : this(_param1, _param2, 45, CompressionMethod.Deflated)
    {
    }

    internal ZipEntry(string _param1, int _param2, int _param3, CompressionMethod _param4)
    {
      if (_param1 == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uF1C2\uF1CD\uF1C1\uF1C9", 61868));
      if (_param1.Length > (int) ushort.MaxValue)
        throw new ArgumentException(\uE01B.\uE000("\uEBA8\uEB87\uEB8B\uEB83\uEBC6\uEB8F\uEB95\uEBC6\uEB92\uEB89\uEB89\uEBC6\uEB8A\uEB89\uEB88\uEB81", 60390), \uE01B.\uE000("\uF1C2\uF1CD\uF1C1\uF1C9", 61868));
      if (_param2 != 0 && _param2 < 10)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uF664\uF677\uF660\uF661\uF67B\uF67D\uF67C\uF640\uF677\uF663\uF667\uF67B\uF660\uF677\uF676\uF646\uF67D\uF657\uF66A\uF666\uF660\uF673\uF671\uF666", 62994));
      this.DateTime = DateTime.Now;
      this.\uE00D = _param1;
      this.\uE00E = (ushort) _param3;
      this.\uE00A = (ushort) _param2;
      this.\uE007 = _param4;
    }

    [Obsolete("Use Clone instead")]
    public ZipEntry(ZipEntry entry)
    {
      this.\uE010 = entry != null ? entry.\uE010 : throw new ArgumentNullException(\uE01B.\uE000("\uEEB7\uEEBC\uEEA6\uEEA0\uEEAB", 61138));
      this.\uE00D = entry.\uE00D;
      this.\uE00C = entry.\uE00C;
      this.\uE00B = entry.\uE00B;
      this.\uE009 = entry.\uE009;
      this.\uE008 = entry.\uE008;
      this.\uE007 = entry.\uE007;
      this.\uE005 = entry.\uE005;
      this.\uE00A = entry.\uE00A;
      this.\uE00E = entry.\uE00E;
      this.\uE00F = entry.\uE00F;
      this.\uE004 = entry.\uE004;
      this.\uE003 = entry.\uE003;
      this.\uE002 = entry.\uE002;
      this.\uE001 = entry.\uE001;
      if (entry.\uE006 == null)
        return;
      this.\uE006 = new byte[entry.\uE006.Length];
      Array.Copy((Array) entry.\uE006, 0, (Array) this.\uE006, 0, entry.\uE006.Length);
    }

    public bool HasCrc => (this.\uE010 & ZipEntry.Known.Crc) != ZipEntry.Known.None;

    public bool IsCrypted
    {
      get => (this.\uE004 & 1) != 0;
      set
      {
        if (value)
          this.\uE004 |= 1;
        else
          this.\uE004 &= -2;
      }
    }

    public bool IsUnicodeText
    {
      get => (this.\uE004 & 2048) != 0;
      set
      {
        if (value)
          this.\uE004 |= 2048;
        else
          this.\uE004 &= -2049;
      }
    }

    internal byte \uE000
    {
      get => this.\uE000;
      set => this.\uE000 = value;
    }

    public int Flags
    {
      get => this.\uE004;
      set => this.\uE004 = value;
    }

    public long ZipFileIndex
    {
      get => this.\uE003;
      set => this.\uE003 = value;
    }

    public long Offset
    {
      get => this.\uE002;
      set => this.\uE002 = value;
    }

    public int ExternalFileAttributes
    {
      get => (this.\uE010 & ZipEntry.Known.ExternalAttributes) == ZipEntry.Known.None ? -1 : this.\uE00F;
      set
      {
        this.\uE00F = value;
        this.\uE010 |= ZipEntry.Known.ExternalAttributes;
      }
    }

    public int VersionMadeBy => (int) this.\uE00E & (int) byte.MaxValue;

    public bool IsDOSEntry => this.HostSystem == 0 || this.HostSystem == 10;

    private bool \uE000(int _param1)
    {
      bool flag = false;
      if ((this.\uE010 & ZipEntry.Known.ExternalAttributes) != ZipEntry.Known.None && (this.HostSystem == 0 || this.HostSystem == 10) && (this.ExternalFileAttributes & _param1) == _param1)
        flag = true;
      return flag;
    }

    public int HostSystem
    {
      get => (int) this.\uE00E >> 8 & (int) byte.MaxValue;
      set
      {
        this.\uE00E &= (ushort) byte.MaxValue;
        this.\uE00E |= (ushort) ((value & (int) byte.MaxValue) << 8);
      }
    }

    public int Version
    {
      get
      {
        if (this.\uE00A != (ushort) 0)
          return (int) this.\uE00A;
        int version = 10;
        if (this.CentralHeaderRequiresZip64)
          version = 45;
        else if (CompressionMethod.Deflated == this.\uE007)
          version = 20;
        else if (this.IsDirectory)
          version = 20;
        else if (this.IsCrypted)
          version = 20;
        else if (this.\uE000(8))
          version = 11;
        return version;
      }
    }

    public bool CanDecompress => this.Version <= 45 && (this.Version == 10 || this.Version == 11 || this.Version == 20 || this.Version == 45) && this.IsCompressionMethodSupported();

    public void ForceZip64() => this.\uE001 = true;

    public bool IsZip64Forced() => this.\uE001;

    public bool LocalHeaderRequiresZip64
    {
      get
      {
        bool headerRequiresZip64 = this.\uE001;
        if (!headerRequiresZip64)
        {
          ulong num = this.\uE00B;
          if (this.\uE00A == (ushort) 0 && this.IsCrypted)
            goto label_3;
label_2:
          headerRequiresZip64 = (this.\uE00C >= (ulong) uint.MaxValue || num >= (ulong) uint.MaxValue) && (this.\uE00A == (ushort) 0 || this.\uE00A >= (ushort) 45);
          goto label_4;
label_3:
          num += 12UL;
          goto label_2;
        }
label_4:
        return headerRequiresZip64;
      }
    }

    public bool CentralHeaderRequiresZip64 => this.LocalHeaderRequiresZip64 || this.\uE002 >= (long) uint.MaxValue;

    public long DosTime
    {
      get => (this.\uE010 & ZipEntry.Known.Time) == ZipEntry.Known.None ? 0L : (long) this.\uE008;
      set
      {
        this.\uE008 = (uint) value;
        this.\uE010 |= ZipEntry.Known.Time;
      }
    }

    public DateTime DateTime
    {
      get
      {
        uint second = Math.Min(59U, (uint) (2 * ((int) this.\uE008 & 31)));
        uint minute = Math.Min(59U, this.\uE008 >> 5 & 63U);
        uint hour = Math.Min(23U, this.\uE008 >> 11 & 31U);
        uint month = Math.Max(1U, Math.Min(12U, this.\uE008 >> 21 & 15U));
        uint year = (uint) (((int) (this.\uE008 >> 25) & (int) sbyte.MaxValue) + 1980);
        int day = Math.Max(1, Math.Min(DateTime.DaysInMonth((int) year, (int) month), (int) (this.\uE008 >> 16) & 31));
        return new DateTime((int) year, (int) month, day, (int) hour, (int) minute, (int) second);
      }
      set
      {
        uint num1 = (uint) value.Year;
        uint num2 = (uint) value.Month;
        uint num3 = (uint) value.Day;
        uint num4 = (uint) value.Hour;
        uint num5 = (uint) value.Minute;
        uint num6 = (uint) value.Second;
        if (num1 < 1980U)
        {
          num1 = 1980U;
          num2 = 1U;
          num3 = 1U;
          num4 = 0U;
          num5 = 0U;
          num6 = 0U;
        }
        else if (num1 > 2107U)
        {
          num1 = 2107U;
          num2 = 12U;
          num3 = 31U;
          num4 = 23U;
          num5 = 59U;
          num6 = 59U;
        }
        this.DosTime = (long) ((uint) (((int) num1 - 1980 & (int) sbyte.MaxValue) << 25 | (int) num2 << 21 | (int) num3 << 16 | (int) num4 << 11 | (int) num5 << 5) | num6 >> 1);
      }
    }

    public string Name => this.\uE00D;

    public long Size
    {
      get => (this.\uE010 & ZipEntry.Known.Size) == ZipEntry.Known.None ? -1L : (long) this.\uE00C;
      set
      {
        this.\uE00C = (ulong) value;
        this.\uE010 |= ZipEntry.Known.Size;
      }
    }

    public long CompressedSize
    {
      get => (this.\uE010 & ZipEntry.Known.CompressedSize) == ZipEntry.Known.None ? -1L : (long) this.\uE00B;
      set
      {
        this.\uE00B = (ulong) value;
        this.\uE010 |= ZipEntry.Known.CompressedSize;
      }
    }

    public long Crc
    {
      get => (this.\uE010 & ZipEntry.Known.Crc) == ZipEntry.Known.None ? -1L : (long) this.\uE009 & (long) uint.MaxValue;
      set
      {
        this.\uE009 = ((long) this.\uE009 & -4294967296L) == 0L ? (uint) value : throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uEA14\uEA03\uEA0E\uEA17\uEA07", 60002));
        this.\uE010 |= ZipEntry.Known.Crc;
      }
    }

    public CompressionMethod CompressionMethod
    {
      get => this.\uE007;
      set => this.\uE007 = ZipEntry.IsCompressionMethodSupported(value) ? value : throw new NotSupportedException(\uE01B.\uE000("\uF8AF\uF883\uF881\uF89C\uF89E\uF889\uF89F\uF89F\uF885\uF883\uF882\uF8CC\uF881\uF889\uF898\uF884\uF883\uF888\uF8CC\uF882\uF883\uF898\uF8CC\uF89F\uF899\uF89C\uF89C\uF883\uF89E\uF898\uF889\uF888", 63724));
    }

    public byte[] ExtraData
    {
      get => this.\uE006;
      set
      {
        if (value == null)
        {
          this.\uE006 = (byte[]) null;
        }
        else
        {
          this.\uE006 = value.Length <= (int) ushort.MaxValue ? new byte[value.Length] : throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uEA14\uEA03\uEA0E\uEA17\uEA07", 60002));
          Array.Copy((Array) value, 0, (Array) this.\uE006, 0, value.Length);
        }
      }
    }

    internal void \uE000(bool _param1)
    {
      ZipExtraData zipExtraData = new ZipExtraData(this.\uE006);
      if (zipExtraData.Find(1))
      {
        if (((int) this.\uE00A & (int) byte.MaxValue) < 45)
          throw new ZipException(\uE01B.\uE000("\uF146\uF175\uF16C\uF12A\uF128\uF13C\uF159\uF164\uF168\uF179\uF172\uF178\uF179\uF178\uF13C\uF175\uF172\uF17A\uF173\uF16E\uF171\uF17D\uF168\uF175\uF173\uF172\uF13C\uF17A\uF173\uF169\uF172\uF178\uF13C\uF17E\uF169\uF168\uF13C\uF16A\uF179\uF16E\uF16F\uF175\uF173\uF172\uF13C\uF175\uF16F\uF13C\uF172\uF173\uF168\uF13C\uF16A\uF17D\uF170\uF175\uF178", 61724));
        this.\uE001 = true;
        if (zipExtraData.ValueLength < 4)
          throw new ZipException(\uE01B.\uE000("\uE2C3\uE2FE\uE2F2\uE2F4\uE2E7\uE2A6\uE2E2\uE2E7\uE2F2\uE2E7\uE2A6\uE2E3\uE2FE\uE2F2\uE2E3\uE2E8\uE2E2\uE2E3\uE2E2\uE2A6\uE2DC\uE2EF\uE2F6\uE2B0\uE2B2\uE2A6\uE2EF\uE2E8\uE2E0\uE2E9\uE2F4\uE2EB\uE2E7\uE2F2\uE2EF\uE2E9\uE2E8\uE2A6\uE2EA\uE2E3\uE2E8\uE2E1\uE2F2\uE2EE\uE2A6\uE2EF\uE2F5\uE2A6\uE2EF\uE2E8\uE2F0\uE2E7\uE2EA\uE2EF\uE2E2", 57990));
        if (_param1 || this.\uE00C == (ulong) uint.MaxValue)
          this.\uE00C = (ulong) zipExtraData.ReadLong();
        if (_param1 || this.\uE00B == (ulong) uint.MaxValue)
          this.\uE00B = (ulong) zipExtraData.ReadLong();
        if (!_param1 && this.\uE002 == (long) uint.MaxValue)
          this.\uE002 = zipExtraData.ReadLong();
      }
      else if (((int) this.\uE00A & (int) byte.MaxValue) >= 45 && (this.\uE00C == (ulong) uint.MaxValue || this.\uE00B == (ulong) uint.MaxValue))
        throw new ZipException(\uE01B.\uE000("\uE778\uE74B\uE752\uE714\uE716\uE702\uE767\uE75A\uE756\uE747\uE74C\uE746\uE747\uE746\uE702\uE74B\uE74C\uE744\uE74D\uE750\uE74F\uE743\uE756\uE74B\uE74D\uE74C\uE702\uE750\uE747\uE753\uE757\uE74B\uE750\uE747\uE746\uE702\uE740\uE757\uE756\uE702\uE74B\uE751\uE702\uE74F\uE74B\uE751\uE751\uE74B\uE74C\uE745\uE70C", 59170));
      if (zipExtraData.Find(10))
      {
        if (zipExtraData.ValueLength < 8)
          throw new ZipException(\uE01B.\uE000("\uE7F4\uE7EE\uE7FC\uE7E9\uE79A\uE7FF\uE7C2\uE7CE\uE7C8\uE7DB\uE79A\uE7DE\uE7DB\uE7CE\uE7DB\uE79A\uE7D3\uE7D4\uE7CC\uE7DB\uE7D6\uE7D3\uE7DE", 59322));
        zipExtraData.ReadInt();
        while (zipExtraData.UnreadCount >= 4)
        {
          int num = zipExtraData.ReadShort();
          int amount = zipExtraData.ReadShort();
          if (num == 1)
          {
            if (amount < 24)
              break;
            long fileTime = zipExtraData.ReadLong();
            zipExtraData.ReadLong();
            zipExtraData.ReadLong();
            this.DateTime = DateTime.FromFileTime(fileTime);
            break;
          }
          zipExtraData.Skip(amount);
        }
      }
      else
      {
        if (!zipExtraData.Find(21589))
          return;
        int valueLength = zipExtraData.ValueLength;
        if ((zipExtraData.ReadByte() & 1) == 0 || valueLength < 5)
          return;
        int seconds = zipExtraData.ReadInt();
        this.DateTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() + new TimeSpan(0, 0, 0, seconds, 0)).ToLocalTime();
      }
    }

    public string Comment
    {
      get => this.\uE005;
      set
      {
        switch (value)
        {
          case null:
            this.\uE005 = value;
            break;
          default:
            if (value.Length > (int) ushort.MaxValue)
              throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uEA14\uEA03\uEA0E\uEA17\uEA07", 60002), \uE01B.\uE000("\uE5C4\uE5C6\uE5C9\uE5C9\uE5C8\uE5D3\uE587\uE5C2\uE5DF\uE5C4\uE5C2\uE5C2\uE5C3\uE587\uE591\uE592\uE592\uE594\uE592", 58791));
            goto case null;
        }
      }
    }

    public bool IsDirectory
    {
      get
      {
        int length = this.\uE00D.Length;
        return length > 0 && (this.\uE00D[length - 1] == '/' || this.\uE00D[length - 1] == '\\') || this.\uE000(16);
      }
    }

    public bool IsFile => !this.IsDirectory && !this.\uE000(8);

    public bool IsCompressionMethodSupported() => ZipEntry.IsCompressionMethodSupported(this.CompressionMethod);

    public object Clone()
    {
      ZipEntry zipEntry = (ZipEntry) this.MemberwiseClone();
      if (this.\uE006 != null)
      {
        zipEntry.\uE006 = new byte[this.\uE006.Length];
        Array.Copy((Array) this.\uE006, 0, (Array) zipEntry.\uE006, 0, this.\uE006.Length);
      }
      return (object) zipEntry;
    }

    public override string ToString() => this.\uE00D;

    public static bool IsCompressionMethodSupported(CompressionMethod method) => method == CompressionMethod.Deflated || method == CompressionMethod.Stored;

    public static string CleanName(string name)
    {
      switch (name)
      {
        case null:
          return string.Empty;
        default:
          if (Path.IsPathRooted(name))
            name = name.Substring(Path.GetPathRoot(name).Length);
          name = name.Replace(\uE01B.\uE000("\uE22F", 57971), \uE01B.\uE000("\uEDB0", 60831));
          while (name.Length > 0 && name[0] == '/')
            name = name.Remove(0, 1);
          return name;
      }
    }

    [System.Flags]
    private enum Known : byte
    {
      None = 0,
      Size = 1,
      CompressedSize = 2,
      Crc = 4,
      Time = 8,
      ExternalAttributes = 16, // 0x10
    }
  }
}
