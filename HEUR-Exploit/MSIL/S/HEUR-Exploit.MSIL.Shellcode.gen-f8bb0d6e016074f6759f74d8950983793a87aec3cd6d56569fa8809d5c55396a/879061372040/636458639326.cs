// Decompiled with JetBrains decompiler
// Type: 879061372040.636458639326
// Assembly: 942981470147, Version=16.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 92EB186D-EC33-4501-B5FF-A65C9233BC32
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Exploit.MSIL.Shellcode.gen-f8bb0d6e016074f6759f74d8950983793a87aec3cd6d56569fa8809d5c55396a.exe

using Microsoft.PythonTools.Infrastructure;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace \u003879061372040
{
  internal static class \u003636458639326
  {
    internal static string \u003276332148891(
      string _param0,
      Dictionary<string, string> _param1,
      IEnumerable<string> _param2,
      string _param3,
      string _param4,
      int _param5)
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        using (StreamReader streamReader = new StreamReader((Stream) memoryStream, Encoding.UTF8, false, 4096, true))
        {
          using (StreamWriter streamWriter = new StreamWriter((Stream) memoryStream, Encoding.UTF8, 4096, true))
          {
            using (ProcessOutput processOutput = ProcessOutput.Run(_param0, _param2, _param3, (IEnumerable<KeyValuePair<string, string>>) _param1, false, (Redirector) new StreamRedirector(streamWriter, (StreamWriter) null, (string) null, (string) null), true, false, (Encoding) null, (Encoding) null))
            {
              if (!processOutput.ExitCode.HasValue)
              {
                if (!processOutput.Wait(TimeSpan.FromSeconds((double) _param5)))
                {
                  try
                  {
                    processOutput.Kill();
                  }
                  catch (InvalidOperationException ex)
                  {
                  }
                  throw new TimeoutException();
                }
              }
              streamWriter.Flush();
              memoryStream.Seek(0L, SeekOrigin.Begin);
              return streamReader.ReadToEnd();
            }
          }
        }
      }
    }
  }
}
