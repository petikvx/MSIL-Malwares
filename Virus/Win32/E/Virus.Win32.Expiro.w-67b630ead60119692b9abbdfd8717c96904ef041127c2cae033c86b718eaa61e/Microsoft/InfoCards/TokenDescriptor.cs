// Decompiled with JetBrains decompiler
// Type: Microsoft.InfoCards.TokenDescriptor
// Assembly: infocard, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: ADE0A079-11DB-4A46-8BDE-D2A592CA8DEA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Virus.Win32.Expiro.w-67b630ead60119692b9abbdfd8717c96904ef041127c2cae033c86b718eaa61e.exe

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Security.Cryptography;
using System.Xml;

namespace Microsoft.InfoCards
{
  internal class TokenDescriptor : IDisposable
  {
    private string m_tokenId;
    private DateTime m_effectiveTime;
    private DateTime m_expirationTime;
    private XmlElement m_protectedToken;
    private DisplayToken m_displayToken;
    private SymmetricAlgorithm m_symmetricProof;
    private string m_internalTokenReference;
    private string m_externalTokenReference;
    private List<string> m_disclosedClaims;
    private bool m_disposed;
    private object m_sync;

    public TokenDescriptor(
      string tokenId,
      DateTime effectiveTime,
      DateTime expirationTime,
      XmlElement protectedToken,
      DisplayToken displayToken,
      SymmetricAlgorithm symmetricProof,
      string internalTokenReference,
      string externalTokenReference,
      IEnumerable<string> disclosedClaims)
    {
      this.m_sync = new object();
      this.m_tokenId = tokenId;
      this.m_effectiveTime = effectiveTime;
      this.m_expirationTime = expirationTime;
      this.m_protectedToken = protectedToken;
      this.m_displayToken = displayToken;
      this.m_symmetricProof = symmetricProof;
      this.m_internalTokenReference = internalTokenReference;
      this.m_externalTokenReference = externalTokenReference;
      this.m_disclosedClaims = new List<string>(disclosedClaims);
    }

    public ReadOnlyCollection<string> DisclosedClaims => this.m_disclosedClaims.AsReadOnly();

    public string TokenId => this.m_tokenId;

    public DateTime EffectiveTime => this.m_effectiveTime;

    public DateTime ExpirationTime => this.m_expirationTime;

    public string InternalTokenReference => this.m_internalTokenReference;

    public string ExternalTokenReference => this.m_externalTokenReference;

    public XmlElement ProtectedToken => this.m_protectedToken;

    public DisplayToken DisplayToken => this.m_displayToken;

    public SymmetricAlgorithm SymmetricProof => this.m_symmetricProof;

    public void Write(BinaryWriter bwriter)
    {
      bwriter.Write(this.m_effectiveTime.ToFileTimeUtc());
      bwriter.Write(this.m_expirationTime.ToFileTimeUtc());
      Utility.SerializeString(bwriter, this.m_protectedToken.OuterXml);
      Utility.SerializeString(bwriter, this.m_internalTokenReference);
      Utility.SerializeString(bwriter, this.m_externalTokenReference);
    }

    public void Dispose()
    {
      if (this.m_disposed)
        return;
      lock (this.m_sync)
      {
        if (this.m_disposed)
          return;
        this.m_disposed = true;
        if (this.m_symmetricProof != null)
        {
          this.m_symmetricProof.Dispose();
          this.m_symmetricProof = (SymmetricAlgorithm) null;
        }
        this.m_protectedToken = (XmlElement) null;
        this.m_expirationTime = DateTime.MinValue;
        this.m_effectiveTime = DateTime.MinValue;
        this.m_tokenId = (string) null;
        this.m_externalTokenReference = (string) null;
        this.m_internalTokenReference = (string) null;
        this.m_disclosedClaims = (List<string>) null;
        this.m_displayToken = (DisplayToken) null;
      }
    }
  }
}
