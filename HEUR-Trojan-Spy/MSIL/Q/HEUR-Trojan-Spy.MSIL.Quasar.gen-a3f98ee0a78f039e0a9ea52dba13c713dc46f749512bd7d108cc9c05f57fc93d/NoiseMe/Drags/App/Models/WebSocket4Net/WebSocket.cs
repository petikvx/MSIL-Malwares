// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.WebSocket4Net.WebSocket
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using NoiseMe.Drags.App.Models.SuperSocket.ClientEngine;
using NoiseMe.Drags.App.Models.WebSocket4Net.Command;
using NoiseMe.Drags.App.Models.WebSocket4Net.Common;
using NoiseMe.Drags.App.Models.WebSocket4Net.Protocol;
using System;
using System.Collections.Generic;
using System.Net;
using System.Security.Authentication;
using System.Threading;

namespace NoiseMe.Drags.App.Models.WebSocket4Net
{
  public class WebSocket : IDisposable
  {
    private EndPoint m_RemoteEndPoint;
    protected const string UserAgentKey = "User-Agent";
    public const int DefaultReceiveBufferSize = 4096;
    private int m_StateCode;
    private EndPoint m_HttpConnectProxy;
    private Dictionary<string, ICommand<WebSocket, WebSocketCommandInfo>> m_CommandDict = new Dictionary<string, ICommand<WebSocket, WebSocketCommandInfo>>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
    private static ProtocolProcessorFactory m_ProtocolProcessorFactory = new ProtocolProcessorFactory(new IProtocolProcessor[3]
    {
      (IProtocolProcessor) new Rfc6455Processor(),
      (IProtocolProcessor) new DraftHybi10Processor(),
      (IProtocolProcessor) new DraftHybi00Processor()
    });
    private System.Threading.Timer m_WebSocketTimer;
    private string m_LastPingRequest;
    private const string m_UriScheme = "ws";
    private const string m_UriPrefix = "ws://";
    private const string m_SecureUriScheme = "wss";
    private const int m_SecurePort = 443;
    private const string m_SecureUriPrefix = "wss://";
    private SecurityOption m_Security;
    private bool m_Disposed;
    private EventHandler m_Opened;
    private EventHandler<MessageReceivedEventArgs> m_MessageReceived;
    private EventHandler<DataReceivedEventArgs> m_DataReceived;
    private const string m_NotOpenSendingMessage = "You must send data by websocket after websocket is opened!";
    private ClosedEventArgs m_ClosedArgs;
    private EventHandler m_Closed;
    private EventHandler<ErrorEventArgs> m_Error;
    private static List<KeyValuePair<string, string>> EmptyCookies;
    private bool m_AllowUnstrustedCertificate;
    private SslProtocols m_SecureProtocols = SslProtocols.Default;

    public TcpClientSession Client { get; private set; }

    public WebSocketVersion Version { get; private set; }

    public DateTime LastActiveTime { get; set; }

    public bool EnableAutoSendPing { get; set; }

    public int AutoSendPingInterval { get; set; }

    public IProtocolProcessor ProtocolProcessor { get; private set; }

    public bool SupportBinary => this.ProtocolProcessor.SupportBinary;

    public Uri TargetUri { get; private set; }

    public string SubProtocol { get; private set; }

    public IDictionary<string, object> Items { get; private set; }

    public List<KeyValuePair<string, string>> Cookies { get; private set; }

    public List<KeyValuePair<string, string>> CustomHeaderItems { get; private set; }

    public int StateCode => this.m_StateCode;

    public WebSocketState State => (WebSocketState) this.m_StateCode;

    public bool Handshaked { get; private set; }

    public IProxyConnector Proxy { get; set; }

    public EndPoint HttpConnectProxy => this.m_HttpConnectProxy;

    protected IClientCommandReader<WebSocketCommandInfo> CommandReader { get; private set; }

    public bool NotSpecifiedVersion { get; private set; }

    public string LastPongResponse { get; set; }

    public string HandshakeHost { get; private set; }

    public string Origin { get; private set; }

    public bool NoDelay { get; set; }

    public EndPoint LocalEndPoint
    {
      get => this.Client == null ? (EndPoint) null : this.Client.LocalEndPoint;
      set
      {
        if (this.Client == null)
          throw new Exception("Websocket client is not initilized.");
        this.Client.LocalEndPoint = value;
      }
    }

    public SecurityOption Security
    {
      get
      {
        if (this.m_Security != null)
          return this.m_Security;
        return !(this.Client is SslStreamTcpSession client) ? (this.m_Security = new SecurityOption()) : (this.m_Security = client.Security);
      }
    }

    private EndPoint ResolveUri(string uri, int defaultPort, out int port)
    {
      this.TargetUri = new Uri(uri);
      if (string.IsNullOrEmpty(this.Origin))
        this.Origin = this.TargetUri.GetOrigin();
      port = this.TargetUri.Port;
      if (port <= 0)
        port = defaultPort;
      IPAddress address;
      return !IPAddress.TryParse(this.TargetUri.Host, out address) ? (EndPoint) new MailRy.Net.DnsEndPoint(this.TargetUri.Host, port) : (EndPoint) new IPEndPoint(address, port);
    }

    private TcpClientSession CreateClient(string uri)
    {
      int port;
      this.m_RemoteEndPoint = this.ResolveUri(uri, 80, out port);
      this.HandshakeHost = port != 80 ? this.TargetUri.Host + ":" + (object) port : this.TargetUri.Host;
      return (TcpClientSession) new AsyncTcpSession();
    }

    private TcpClientSession CreateSecureClient(string uri)
    {
      int num = uri.IndexOf('/', "wss://".Length);
      if (num < 0)
      {
        if (uri.IndexOf(':', "wss://".Length, uri.Length - "wss://".Length) < 0)
          uri = uri + ":" + (object) 443 + "/";
        else
          uri += "/";
      }
      else
      {
        if (num == "wss://".Length)
          throw new ArgumentException("Invalid uri", nameof (uri));
        if (uri.IndexOf(':', "wss://".Length, num - "wss://".Length) < 0)
          uri = uri.Substring(0, num) + ":" + (object) 443 + uri.Substring(num);
      }
      int port;
      this.m_RemoteEndPoint = this.ResolveUri(uri, 443, out port);
      if (this.m_HttpConnectProxy != null)
        this.m_RemoteEndPoint = this.m_HttpConnectProxy;
      this.HandshakeHost = port != 443 ? this.TargetUri.Host + ":" + (object) port : this.TargetUri.Host;
      return this.CreateSecureTcpSession();
    }

    private void Initialize(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      List<KeyValuePair<string, string>> customHeaderItems,
      string userAgent,
      string origin,
      WebSocketVersion version,
      EndPoint httpConnectProxy,
      int receiveBufferSize)
    {
      if (version == WebSocketVersion.None)
      {
        this.NotSpecifiedVersion = true;
        version = WebSocketVersion.Rfc6455;
      }
      this.Version = version;
      this.ProtocolProcessor = WebSocket.GetProtocolProcessor(version);
      this.Cookies = cookies;
      this.Origin = origin;
      if (!string.IsNullOrEmpty(userAgent))
      {
        if (customHeaderItems == null)
          customHeaderItems = new List<KeyValuePair<string, string>>();
        customHeaderItems.Add(new KeyValuePair<string, string>("User-Agent", userAgent));
      }
      if (customHeaderItems != null && customHeaderItems.Count > 0)
        this.CustomHeaderItems = customHeaderItems;
      Handshake handshake = new Handshake();
      this.m_CommandDict.Add(handshake.Name, (ICommand<WebSocket, WebSocketCommandInfo>) handshake);
      Text text = new Text();
      this.m_CommandDict.Add(text.Name, (ICommand<WebSocket, WebSocketCommandInfo>) text);
      Binary binary = new Binary();
      this.m_CommandDict.Add(binary.Name, (ICommand<WebSocket, WebSocketCommandInfo>) binary);
      NoiseMe.Drags.App.Models.WebSocket4Net.Command.Close close = new NoiseMe.Drags.App.Models.WebSocket4Net.Command.Close();
      this.m_CommandDict.Add(close.Name, (ICommand<WebSocket, WebSocketCommandInfo>) close);
      Ping ping = new Ping();
      this.m_CommandDict.Add(ping.Name, (ICommand<WebSocket, WebSocketCommandInfo>) ping);
      Pong pong = new Pong();
      this.m_CommandDict.Add(pong.Name, (ICommand<WebSocket, WebSocketCommandInfo>) pong);
      BadRequest badRequest = new BadRequest();
      this.m_CommandDict.Add(badRequest.Name, (ICommand<WebSocket, WebSocketCommandInfo>) badRequest);
      this.m_StateCode = -1;
      this.SubProtocol = subProtocol;
      this.Items = (IDictionary<string, object>) new Dictionary<string, object>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
      this.m_HttpConnectProxy = httpConnectProxy;
      TcpClientSession tcpClientSession;
      if (uri.StartsWith("ws://", StringComparison.OrdinalIgnoreCase))
        tcpClientSession = this.CreateClient(uri);
      else
        tcpClientSession = uri.StartsWith("wss://", StringComparison.OrdinalIgnoreCase) ? this.CreateSecureClient(uri) : throw new ArgumentException("Invalid uri", nameof (uri));
      tcpClientSession.ReceiveBufferSize = receiveBufferSize > 0 ? receiveBufferSize : 4096;
      tcpClientSession.Connected += new EventHandler(this.client_Connected);
      tcpClientSession.Closed += new EventHandler(this.client_Closed);
      tcpClientSession.Error += new EventHandler<ErrorEventArgs>(this.client_Error);
      tcpClientSession.DataReceived += new EventHandler<DataEventArgs>(this.client_DataReceived);
      this.Client = tcpClientSession;
      this.EnableAutoSendPing = true;
    }

    private void client_DataReceived(object sender, DataEventArgs e) => this.OnDataReceived(e.Data, e.Offset, e.Length);

    private void client_Error(object sender, ErrorEventArgs e)
    {
      this.OnError(e);
      this.OnClosed();
    }

    private void client_Closed(object sender, EventArgs e) => this.OnClosed();

    private void client_Connected(object sender, EventArgs e) => this.OnConnected();

    public bool GetAvailableProcessor(int[] availableVersions)
    {
      IProtocolProcessor processorFromAvialable = WebSocket.m_ProtocolProcessorFactory.GetPreferedProcessorFromAvialable(availableVersions);
      if (processorFromAvialable == null)
        return false;
      this.ProtocolProcessor = processorFromAvialable;
      return true;
    }

    public int ReceiveBufferSize
    {
      get => this.Client.ReceiveBufferSize;
      set => this.Client.ReceiveBufferSize = value;
    }

    public void Open()
    {
      this.m_StateCode = 0;
      if (this.Proxy != null)
        this.Client.Proxy = this.Proxy;
      this.Client.NoDelay = this.NoDelay;
      this.Client.Connect(this.m_RemoteEndPoint);
    }

    private static IProtocolProcessor GetProtocolProcessor(
      WebSocketVersion version)
    {
      return WebSocket.m_ProtocolProcessorFactory.GetProcessorByVersion(version) ?? throw new ArgumentException("Invalid websocket version");
    }

    private void OnConnected()
    {
      this.CommandReader = (IClientCommandReader<WebSocketCommandInfo>) this.ProtocolProcessor.CreateHandshakeReader(this);
      if (this.Items.Count > 0)
        this.Items.Clear();
      this.ProtocolProcessor.SendHandshake(this);
    }

    public virtual void OnHandshaked()
    {
      this.m_StateCode = 1;
      this.Handshaked = true;
      if (this.EnableAutoSendPing && this.ProtocolProcessor.SupportPingPong)
      {
        if (this.AutoSendPingInterval <= 0)
          this.AutoSendPingInterval = 60;
        this.m_WebSocketTimer = new System.Threading.Timer(new TimerCallback(this.OnPingTimerCallback), (object) this.ProtocolProcessor, this.AutoSendPingInterval * 1000, this.AutoSendPingInterval * 1000);
      }
      EventHandler opened = this.m_Opened;
      if (opened == null)
        return;
      opened((object) this, EventArgs.Empty);
    }

    private void OnPingTimerCallback(object state)
    {
      IProtocolProcessor protocolProcessor = state as IProtocolProcessor;
      if (!string.IsNullOrEmpty(this.m_LastPingRequest))
      {
        if (!this.m_LastPingRequest.Equals(this.LastPongResponse))
        {
          try
          {
            protocolProcessor.SendPong(this, "");
          }
          catch (Exception ex)
          {
            this.OnError(ex);
            return;
          }
        }
      }
      this.m_LastPingRequest = DateTime.Now.ToString();
      try
      {
        protocolProcessor.SendPing(this, this.m_LastPingRequest);
      }
      catch (Exception ex)
      {
        this.OnError(ex);
      }
    }

    public event EventHandler Opened
    {
      add => this.m_Opened += value;
      remove => this.m_Opened -= value;
    }

    public event EventHandler<MessageReceivedEventArgs> MessageReceived
    {
      add => this.m_MessageReceived += value;
      remove => this.m_MessageReceived -= value;
    }

    public void FireMessageReceived(string message)
    {
      if (this.m_MessageReceived == null)
        return;
      this.m_MessageReceived((object) this, new MessageReceivedEventArgs(message));
    }

    public event EventHandler<DataReceivedEventArgs> DataReceived
    {
      add => this.m_DataReceived += value;
      remove => this.m_DataReceived -= value;
    }

    public void FireDataReceived(byte[] data)
    {
      if (this.m_DataReceived == null)
        return;
      this.m_DataReceived((object) this, new DataReceivedEventArgs(data));
    }

    private bool EnsureWebSocketOpen()
    {
      if (this.Handshaked)
        return true;
      this.OnError(new Exception("You must send data by websocket after websocket is opened!"));
      return false;
    }

    public void Send(string message)
    {
      if (!this.EnsureWebSocketOpen())
        return;
      this.ProtocolProcessor.SendMessage(this, message);
    }

    public void Send(byte[] data, int offset, int length)
    {
      if (!this.EnsureWebSocketOpen())
        return;
      this.ProtocolProcessor.SendData(this, data, offset, length);
    }

    public void Send(IList<ArraySegment<byte>> segments)
    {
      if (!this.EnsureWebSocketOpen())
        return;
      this.ProtocolProcessor.SendData(this, segments);
    }

    private void OnClosed()
    {
      bool flag = false;
      if (this.m_StateCode == 2 || this.m_StateCode == 1 || this.m_StateCode == 0)
        flag = true;
      this.m_StateCode = 3;
      if (!flag)
        return;
      this.FireClosed();
    }

    public void Close() => this.Close(string.Empty);

    public void Close(string reason) => this.Close((int) this.ProtocolProcessor.CloseStatusCode.NormalClosure, reason);

    public void Close(int statusCode, string reason)
    {
      this.m_ClosedArgs = new ClosedEventArgs((short) statusCode, reason);
      if (Interlocked.CompareExchange(ref this.m_StateCode, 3, -1) == -1)
        this.OnClosed();
      else if (Interlocked.CompareExchange(ref this.m_StateCode, 2, 0) == 0)
      {
        TcpClientSession client = this.Client;
        if (client != null && client.IsConnected)
          client.Close();
        else
          this.OnClosed();
      }
      else
      {
        this.m_StateCode = 2;
        this.ClearTimer();
        this.m_WebSocketTimer = new System.Threading.Timer(new TimerCallback(this.CheckCloseHandshake), (object) null, 5000, -1);
        try
        {
          this.ProtocolProcessor.SendCloseHandshake(this, statusCode, reason);
        }
        catch (Exception ex)
        {
          if (this.Client == null)
            return;
          this.OnError(ex);
        }
      }
    }

    private void CheckCloseHandshake(object state)
    {
      if (this.m_StateCode == 3)
        return;
      try
      {
        this.CloseWithoutHandshake();
      }
      catch (Exception ex)
      {
        this.OnError(ex);
      }
    }

    public void CloseWithoutHandshake() => this.Client?.Close();

    protected void ExecuteCommand(WebSocketCommandInfo commandInfo)
    {
      ICommand<WebSocket, WebSocketCommandInfo> command;
      if (!this.m_CommandDict.TryGetValue(commandInfo.Key, out command))
        return;
      command.ExecuteCommand(this, commandInfo);
    }

    private void OnDataReceived(byte[] data, int offset, int length)
    {
      while (true)
      {
        int left;
        WebSocketCommandInfo commandInfo = this.CommandReader.GetCommandInfo(data, offset, length, out left);
        if (this.CommandReader.NextCommandReader != null)
          this.CommandReader = this.CommandReader.NextCommandReader;
        if (commandInfo != null)
          this.ExecuteCommand(commandInfo);
        if (left > 0)
        {
          offset = offset + length - left;
          length = left;
        }
        else
          break;
      }
    }

    public void FireError(Exception error) => this.OnError(error);

    public event EventHandler Closed
    {
      add => this.m_Closed += value;
      remove => this.m_Closed -= value;
    }

    private void ClearTimer()
    {
      System.Threading.Timer webSocketTimer = this.m_WebSocketTimer;
      if (webSocketTimer == null)
        return;
      lock (this)
      {
        if (this.m_WebSocketTimer == null)
          return;
        webSocketTimer.Change(-1, -1);
        webSocketTimer.Dispose();
        this.m_WebSocketTimer = (System.Threading.Timer) null;
      }
    }

    private void FireClosed()
    {
      this.ClearTimer();
      EventHandler closed = this.m_Closed;
      if (closed == null)
        return;
      closed((object) this, (EventArgs) this.m_ClosedArgs ?? EventArgs.Empty);
    }

    public event EventHandler<ErrorEventArgs> Error
    {
      add => this.m_Error += value;
      remove => this.m_Error -= value;
    }

    private void OnError(ErrorEventArgs e)
    {
      EventHandler<ErrorEventArgs> error = this.m_Error;
      if (error == null)
        return;
      error((object) this, e);
    }

    private void OnError(Exception e) => this.OnError(new ErrorEventArgs(e));

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.m_Disposed)
        return;
      if (disposing)
      {
        TcpClientSession client = this.Client;
        if (client != null)
        {
          client.Connected -= new EventHandler(this.client_Connected);
          client.Closed -= new EventHandler(this.client_Closed);
          client.Error -= new EventHandler<ErrorEventArgs>(this.client_Error);
          client.DataReceived -= new EventHandler<DataEventArgs>(this.client_DataReceived);
          if (client.IsConnected)
            client.Close();
          this.Client = (TcpClientSession) null;
        }
        this.ClearTimer();
      }
      this.m_Disposed = true;
    }

    ~WebSocket() => this.Dispose(false);

    public WebSocket(string uri, string subProtocol, WebSocketVersion version)
      : this(uri, subProtocol, WebSocket.EmptyCookies, (List<KeyValuePair<string, string>>) null, string.Empty, string.Empty, version)
    {
    }

    public WebSocket(
      string uri,
      string subProtocol = "",
      List<KeyValuePair<string, string>> cookies = null,
      List<KeyValuePair<string, string>> customHeaderItems = null,
      string userAgent = "",
      string origin = "",
      WebSocketVersion version = WebSocketVersion.None,
      EndPoint httpConnectProxy = null,
      SslProtocols sslProtocols = SslProtocols.None,
      int receiveBufferSize = 0)
    {
      if (sslProtocols != SslProtocols.None)
        this.m_SecureProtocols = sslProtocols;
      this.Initialize(uri, subProtocol, cookies, customHeaderItems, userAgent, origin, version, httpConnectProxy, receiveBufferSize);
    }

    public bool AllowUnstrustedCertificate
    {
      get => this.m_AllowUnstrustedCertificate;
      set
      {
        this.m_AllowUnstrustedCertificate = value;
        if (!(this.Client is SslStreamTcpSession client))
          return;
        client.Security.AllowUnstrustedCertificate = this.m_AllowUnstrustedCertificate;
      }
    }

    public WebSocket(string uri)
      : this(uri, string.Empty)
    {
    }

    public WebSocket(string uri, WebSocketVersion version)
      : this(uri, string.Empty, (List<KeyValuePair<string, string>>) null, version)
    {
    }

    public WebSocket(string uri, string subProtocol)
      : this(uri, subProtocol, (List<KeyValuePair<string, string>>) null, WebSocketVersion.None)
    {
    }

    public WebSocket(string uri, List<KeyValuePair<string, string>> cookies)
      : this(uri, string.Empty, cookies, WebSocketVersion.None)
    {
    }

    public WebSocket(string uri, string subProtocol, List<KeyValuePair<string, string>> cookies)
      : this(uri, subProtocol, cookies, WebSocketVersion.None)
    {
    }

    public WebSocket(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      WebSocketVersion version)
      : this(uri, subProtocol, cookies, new List<KeyValuePair<string, string>>(), (string) null, version)
    {
    }

    public WebSocket(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      string userAgent,
      WebSocketVersion version)
      : this(uri, subProtocol, cookies, (List<KeyValuePair<string, string>>) null, userAgent, version)
    {
    }

    public WebSocket(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      List<KeyValuePair<string, string>> customHeaderItems,
      string userAgent,
      WebSocketVersion version)
      : this(uri, subProtocol, cookies, customHeaderItems, userAgent, string.Empty, version)
    {
    }

    public WebSocket(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      List<KeyValuePair<string, string>> customHeaderItems,
      string userAgent,
      string origin,
      WebSocketVersion version)
      : this(uri, subProtocol, cookies, customHeaderItems, userAgent, origin, version, (EndPoint) null)
    {
    }

    public WebSocket(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      List<KeyValuePair<string, string>> customHeaderItems,
      string userAgent,
      string origin,
      WebSocketVersion version,
      EndPoint httpConnectProxy)
    {
      this.Initialize(uri, subProtocol, cookies, customHeaderItems, userAgent, origin, version, httpConnectProxy, 0);
    }

    public WebSocket(
      string uri,
      string subProtocol,
      List<KeyValuePair<string, string>> cookies,
      List<KeyValuePair<string, string>> customHeaderItems,
      string userAgent,
      string origin,
      WebSocketVersion version,
      EndPoint httpConnectProxy,
      SslProtocols sslProtocols)
    {
      this.m_SecureProtocols = sslProtocols;
      this.Initialize(uri, subProtocol, cookies, customHeaderItems, userAgent, origin, version, httpConnectProxy, 0);
    }

    private TcpClientSession CreateSecureTcpSession()
    {
      SslStreamTcpSession secureTcpSession = new SslStreamTcpSession();
      SecurityOption securityOption1;
      SecurityOption securityOption2 = securityOption1 = new SecurityOption();
      secureTcpSession.Security = securityOption1;
      securityOption2.EnabledSslProtocols = this.m_SecureProtocols;
      return (TcpClientSession) secureTcpSession;
    }
  }
}
