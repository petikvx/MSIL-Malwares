// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Protected, Version=6.2.8400.0, Culture=neutral, PublicKeyToken=null
// MVID: 52CBE997-50C3-42B2-A704-C908D57869A5
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-2a8dca5794c095ea67845468a3fd0a8e91a24bf3f0bb5e0ec6c16a6579cc4e90.exe

using System;
using System.Collections;
using System.IO;

internal sealed class \uE030
{
  public sealed class \uE000 : Stream, IDisposable
  {
    private Stream \uE000;
    private bool \uE001;
    private bool \uE002;
    private \uE030.\uE015 \uE003;
    private byte[] \uE004;
    private int \uE005;

    public \uE000(Stream _param1)
      : this(_param1, false)
    {
    }

    public \uE000(Stream _param1, bool _param2)
    {
      this.\uE000 = _param1 != null ? _param1 : throw new ArgumentNullException();
      this.\uE001 = _param2;
      this.\uE002 = true;
      this.\uE004 = new byte[8192];
      this.\uE003 = new \uE030.\uE015(_param1);
    }

    public Stream \uE000 => this.\uE000;

    public override bool CanSeek => false;

    public override bool CanRead => false;

    public override bool CanWrite => true;

    public override long Length => throw new NotImplementedException();

    public override long Position
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();

    public override void SetLength(long value) => throw new NotImplementedException();

    private void \uE003()
    {
      if (!this.\uE002)
        throw new InvalidOperationException("Stream is closed.");
    }

    public override int Read(byte[] buffer, int offset, int count) => throw new NotSupportedException();

    public override void Write(byte[] buffer, int offset, int count)
    {
      if (count < 0 || count > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (count));
      if (offset < 0 || offset > buffer.Length)
        throw new ArgumentOutOfRangeException(nameof (offset));
      if (offset + count > buffer.Length)
        throw new ArgumentException("offset + count out of buffer");
      this.\uE003();
      if (this.\uE005 + count > 8192)
        this.\uE004();
      if (count >= 8192)
      {
        int num;
        for (num = 0; count - num > 32768; num += 32768)
          this.\uE003.\uE005(buffer, offset + num, 32768, false);
        this.\uE003.\uE005(buffer, offset + num, count - num, false);
      }
      else
      {
        Array.Copy((Array) buffer, offset, (Array) this.\uE004, this.\uE005, count);
        this.\uE005 += count;
        if (this.\uE005 != 8192)
          return;
        this.\uE004();
      }
    }

    private void \uE004()
    {
      if (this.\uE005 <= 0)
        return;
      this.\uE003.\uE005(this.\uE004, 0, this.\uE005, false);
      this.\uE005 = 0;
    }

    public override void Flush()
    {
      this.\uE003();
      if (this.\uE005 > 0)
        this.\uE004();
      this.\uE003.\uE000(true, false);
      this.\uE000.Flush();
    }

    private void \uE005()
    {
      if (this.\uE005 > 0)
        this.\uE003.\uE005(this.\uE004, 0, this.\uE005, true);
      else
        this.\uE003.\uE000(false, true);
    }

    void IDisposable.Dispose()
    {
      if (this.\uE002)
      {
        this.\uE005();
        this.\uE004 = (byte[]) null;
        this.\uE003 = (\uE030.\uE015) null;
        if (!this.\uE001)
        {
          this.\uE000.Close();
          this.\uE000 = (Stream) null;
        }
        this.\uE002 = false;
      }
      this.Close();
    }
  }

  public sealed class \uE015
  {
    private Stream \uE000;
    private \uE030.\uE01B \uE001;
    private \uE030.\uE017 \uE002;
    private static int \uE003 = -1;
    private static int \uE004 = -1;
    private static int \uE005 = -1;
    private static int \uE006 = -1;
    private static int \uE007 = -1;

    public \uE015(Stream _param1)
    {
      this.\uE000 = _param1 != null ? _param1 : throw new ArgumentNullException();
      this.\uE001 = new \uE030.\uE01B(_param1);
      this.\uE002 = new \uE030.\uE017();
    }

    public Stream \uE000 => this.\uE000;

    public static int \uE006
    {
      get => \uE030.\uE015.\uE003 == -1 ? 3 : \uE030.\uE015.\uE003;
      set => \uE030.\uE015.\uE003 = value;
    }

    public static int \uE007
    {
      get => \uE030.\uE015.\uE004 == -1 ? 44266 : \uE030.\uE015.\uE004;
      set => \uE030.\uE015.\uE004 = value;
    }

    public static int \uE008
    {
      get => \uE030.\uE015.\uE005 == -1 ? 5 : \uE030.\uE015.\uE005;
      set => \uE030.\uE015.\uE005 = value;
    }

    public static int \uE009
    {
      get => \uE030.\uE015.\uE006 == -1 ? 1 : \uE030.\uE015.\uE006;
      set => \uE030.\uE015.\uE006 = value;
    }

    public static int \uE00A
    {
      get => \uE030.\uE015.\uE007 == -1 ? 3 : \uE030.\uE015.\uE007;
      set => \uE030.\uE015.\uE007 = value;
    }

    internal void \uE000(
      \uE030.\uE01A _param1,
      out int[] _param2,
      out int[] _param3,
      out int _param4)
    {
      _param2 = new int[286];
      _param3 = new int[30];
      _param4 = 0;
      int index1 = 0;
      int index2 = 0;
      while (index1 < _param1.\uE000.Count)
      {
        ushort index3 = (ushort) _param1.\uE000[index1];
        if (index3 <= (ushort) 256)
        {
          ++_param2[(int) index3];
          ++index1;
        }
        else
        {
          ++_param2[(int) index3];
          ++_param3[(int) (ushort) _param1.\uE000[index1 + 2]];
          index1 += 4;
          _param4 += (int) (byte) _param1.\uE001[index2] + (int) (byte) _param1.\uE001[index2 + 1];
          index2 += 2;
        }
      }
    }

    public void \uE000(bool _param1, bool _param2)
    {
      this.\uE001.\uE000(_param2);
      if (_param1)
      {
        this.\uE001.\uE003(\uE030.\uE015.\uE008, \uE030.\uE015.\uE006);
        this.\uE001.\uE000();
        this.\uE001.\uE003(0, 16);
      }
      else
      {
        this.\uE001.\uE003(\uE030.\uE015.\uE009, \uE030.\uE015.\uE006);
        \uE02C obj = \uE02B.\uE000[256];
        this.\uE001.\uE004(obj.\uE000, obj.\uE001);
      }
      if (!_param2)
        return;
      this.\uE001.\uE000();
    }

    public void \uE004(byte[] _param1, int _param2, int _param3, bool _param4)
    {
      if (_param3 > (int) ushort.MaxValue)
        throw new ArgumentOutOfRangeException();
      this.\uE001.\uE000(_param4);
      this.\uE001.\uE003(\uE030.\uE015.\uE008, \uE030.\uE015.\uE006);
      this.\uE001.\uE000();
      this.\uE001.\uE003((int) (ushort) (_param3 ^ \uE030.\uE015.\uE007), 16);
      this.\uE000(_param1, _param2, _param3);
    }

    public void \uE005(byte[] _param1, int _param2, int _param3, bool _param4)
    {
      if (_param3 > 32768)
        throw new ArgumentOutOfRangeException();
      \uE030.\uE01A obj = this.\uE002.\uE002(_param1, _param2, _param3);
      if (obj == null)
        throw new InvalidOperationException();
      if (obj.\uE002 != _param3)
        throw new InvalidOperationException();
      obj.\uE000();
      int[] numArray1;
      int[] numArray2;
      int num1;
      this.\uE000(obj, out numArray1, out numArray2, out num1);
      int[] numArray3 = \uE02B.\uE000(numArray1);
      int[] numArray4 = \uE02B.\uE000(numArray2);
      int num2 = (4 + _param3) * 8;
      int num3 = this.\uE001.\uE000 >= 3 ? num2 + (this.\uE001.\uE000 - 3) : num2 + (5 + this.\uE001.\uE000);
      int num4 = \uE02B.\uE002(numArray3, numArray1) + \uE02B.\uE002(numArray4, numArray2) + num1;
      int num5 = \uE02B.\uE003(numArray3, numArray4) + num1;
      bool flag1 = num5 <= num4 || num3 <= num4;
      if (!flag1)
      {
        int num6 = num4 + this.\uE000(numArray3, numArray4);
        flag1 = num5 <= num6 || num3 <= num6;
      }
      bool flag2 = num3 < num5;
      this.\uE001.\uE000(_param4);
      if (flag2 && flag1)
      {
        this.\uE001.\uE003(\uE030.\uE015.\uE008, \uE030.\uE015.\uE006);
        this.\uE001.\uE000();
        this.\uE001.\uE003(_param3 ^ \uE030.\uE015.\uE007, 16);
        this.\uE001.\uE000();
        this.\uE000(_param1, _param2, _param3);
      }
      else
      {
        \uE02C[] objArray1;
        \uE02C[] objArray2;
        if (flag1)
        {
          this.\uE001.\uE003(\uE030.\uE015.\uE009, \uE030.\uE015.\uE006);
          objArray1 = \uE02B.\uE000;
          objArray2 = \uE02B.\uE001;
        }
        else
        {
          this.\uE001.\uE003(\uE030.\uE015.\uE00A, \uE030.\uE015.\uE006);
          this.\uE000(numArray3, numArray4);
          objArray1 = \uE02B.\uE000(numArray3);
          objArray2 = \uE02B.\uE000(numArray4);
        }
        this.\uE000(obj, objArray1, objArray2);
      }
      if (!_param4)
        return;
      this.\uE001.\uE000();
    }

    public void \uE000()
    {
      this.\uE002 = new \uE030.\uE017();
      if (this.\uE002 == null)
        throw new InvalidOperationException();
    }

    private void \uE000(\uE030.\uE01A _param1, \uE02C[] _param2, \uE02C[] _param3)
    {
      int index1 = 0;
      int index2 = 0;
      while (index1 < _param1.\uE000.Count)
      {
        int index3 = (int) (ushort) _param1.\uE000[index1];
        if (index3 <= 256)
        {
          \uE02C obj = _param2[index3];
          this.\uE001.\uE004(obj.\uE000, obj.\uE001);
          ++index1;
        }
        else
        {
          \uE02C obj1 = _param2[index3];
          this.\uE001.\uE004(obj1.\uE000, obj1.\uE001);
          if ((byte) _param1.\uE001[index2] > (byte) 0)
            this.\uE001.\uE003((int) (ushort) _param1.\uE000[index1 + 1], (int) (byte) _param1.\uE001[index2]);
          int index4 = index1 + 2;
          int index5 = index2 + 1;
          \uE02C obj2 = _param3[(int) (ushort) _param1.\uE000[index4]];
          this.\uE001.\uE004(obj2.\uE000, obj2.\uE001);
          if ((byte) _param1.\uE001[index5] > (byte) 0)
            this.\uE001.\uE003((int) (ushort) _param1.\uE000[index4 + 1], (int) (byte) _param1.\uE001[index5]);
          index1 = index4 + 2;
          index2 = index5 + 1;
        }
      }
    }

    private void \uE000(byte[] _param1, int _param2, int _param3) => this.\uE000.Write(_param1, _param2, _param3);

    private void \uE000(int[] _param1, int[] _param2)
    {
      int[] numArray1 = new int[19];
      int num1 = 286;
      while (num1 > 257 && _param1[num1 - 1] == 0)
        --num1;
      int length = 30;
      while (length > 1 && _param2[length - 1] == 0)
        --length;
      int[] destinationArray = new int[num1 + length];
      Array.Copy((Array) _param1, 0, (Array) destinationArray, 0, num1);
      Array.Copy((Array) _param2, 0, (Array) destinationArray, num1, length);
      int[] numArray2 = \uE02B.\uE000(destinationArray, 0, destinationArray.Length);
      for (int index = 0; index < numArray2.Length; ++index)
      {
        ++numArray1[numArray2[index]];
        if (numArray2[index] >= 16)
          ++index;
      }
      int[] numArray3 = \uE02B.\uE000(numArray1, 7);
      int[] numArray4 = \uE02B.\uE003;
      int num2 = 19;
      while (num2 > 4 && numArray3[numArray4[num2 - 1]] == 0)
        --num2;
      int num3 = num1 - 257;
      int num4 = length - 1;
      int num5 = num2 - 4;
      \uE02C[] objArray = \uE02B.\uE000(numArray3);
      this.\uE001.\uE003(num3, 5);
      this.\uE001.\uE003(num4, 5);
      this.\uE001.\uE003(num5, 4);
      for (int index = 0; index < num2; ++index)
        this.\uE001.\uE003(numArray3[numArray4[index]], 3);
      for (int index1 = 0; index1 < numArray2.Length; ++index1)
      {
        int index2 = numArray2[index1];
        \uE02C obj = objArray[index2];
        this.\uE001.\uE004(obj.\uE000, obj.\uE001);
        if (index2 >= 16)
        {
          ++index1;
          this.\uE001.\uE003(numArray2[index1], \uE02B.\uE000(index2));
        }
      }
    }

    private int \uE000(int[] _param1, int[] _param2)
    {
      int[] numArray1 = new int[19];
      int num1 = 0;
      int num2 = 286;
      while (num2 > 257 && _param1[num2 - 1] == 0)
        --num2;
      int[] numArray2 = \uE02B.\uE000(_param1, 0, num2);
      for (int index = 0; index < numArray2.Length; ++index)
      {
        ++numArray1[numArray2[index]];
        if (numArray2[index] >= 16)
        {
          num1 += \uE02B.\uE000(numArray2[index]);
          ++index;
        }
      }
      int num3 = 30;
      while (num3 > 1 && _param2[num3 - 1] == 0)
        --num3;
      int[] numArray3 = \uE02B.\uE000(_param2, 0, num3);
      for (int index = 0; index < numArray3.Length; ++index)
      {
        ++numArray1[numArray3[index]];
        if (numArray3[index] >= 16)
        {
          num1 += \uE02B.\uE000(numArray3[index]);
          ++index;
        }
      }
      int[] numArray4 = \uE02B.\uE000(numArray1);
      int num4 = \uE02B.\uE002(numArray1, numArray4);
      int[] numArray5 = \uE02B.\uE003;
      int num5 = 19;
      while (num5 > 4 && numArray4[numArray5[num5 - 1]] == 0)
        --num5;
      return 14 + (num5 - 4 + 4) * 3 + num4 + num1;
    }
  }

  private sealed class \uE016
  {
    public static readonly \uE030.\uE016 \uE000 = new \uE030.\uE016()
    {
      \uE001 = 8,
      \uE002 = 32,
      \uE003 = 128,
      \uE004 = 256
    };
    public int \uE001;
    public int \uE002;
    public int \uE003;
    public int \uE004;
  }

  private sealed class \uE017
  {
    private \uE030.\uE019 \uE000;
    private \uE030.\uE018 \uE001;
    private \uE030.\uE016 \uE002;
    private int \uE003;

    internal \uE017()
      : this(\uE030.\uE016.\uE000)
    {
    }

    internal \uE017(\uE030.\uE016 _param1)
    {
      this.\uE002 = _param1;
      this.\uE000 = new \uE030.\uE019(65536);
      this.\uE001 = new \uE030.\uE018(32768);
      this.\uE003 = 0;
    }

    internal \uE030.\uE016 \uE000 => this.\uE002;

    public \uE030.\uE01A \uE002(byte[] _param1, int _param2, int _param3)
    {
      if (this.\uE000.\uE004 + _param3 > this.\uE000.\uE003)
      {
        int num = this.\uE000.\uE004 - 32768;
        this.\uE000.\uE000(num);
        if (this.\uE003 >= num)
        {
          this.\uE003 -= num;
        }
        else
        {
          this.\uE001.\uE000(num - this.\uE003);
          this.\uE003 = 0;
        }
      }
      int num1 = this.\uE000.\uE004;
      this.\uE000.\uE000(_param1, _param2, _param3);
      if (this.\uE003 < num1)
        this.\uE001.\uE000(this.\uE000.\uE000, this.\uE003, num1 - this.\uE003);
      return this.\uE000.\uE003 <= 0 ? this.\uE003(this.\uE000.\uE000, num1, _param3) : this.\uE000(this.\uE001, this.\uE000.\uE000, num1, _param3, out this.\uE003);
    }

    private \uE030.\uE01A \uE003(byte[] _param1, int _param2, int _param3)
    {
      \uE030.\uE01A obj = new \uE030.\uE01A();
      obj.\uE000.Capacity = _param3 + 1;
      for (int index = 0; index < _param3; ++index)
        obj.\uE000(_param1[index]);
      return obj;
    }

    private \uE030.\uE01A \uE000(
      \uE030.\uE018 _param1,
      byte[] _param2,
      int _param3,
      int _param4,
      out int _param5)
    {
      \uE030.\uE01A obj1 = new \uE030.\uE01A();
      object obj2 = (object) null;
      int num = 0;
      while (num < _param4 - 2)
      {
        \uE030.\uE018.\uE000 obj3 = _param1.\uE000(_param2, _param3 + num);
        if (obj3 != null)
        {
          object obj4;
          if (obj2 != null)
          {
            obj4 = obj2;
            obj2 = (object) null;
          }
          else
            obj4 = (object) this.\uE000(_param2, _param3, _param4, num, obj3, 3);
          \uE030.\uE017.\uE000 obj5 = (\uE030.\uE017.\uE000) obj4;
          bool flag = obj5.\uE001 >= 3;
          if (flag && num < _param4 - 3 && obj5.\uE001 < this.\uE002.\uE002)
          {
            \uE030.\uE018.\uE000 obj6 = _param1.\uE000(_param2, _param3 + num + 1);
            if (obj6 != null)
            {
              \uE030.\uE017.\uE000 obj7 = this.\uE000(_param2, _param3, _param4, num + 1, obj6, obj5.\uE001 + 1);
              if (obj7.\uE001 > obj5.\uE001)
              {
                obj2 = (object) obj7;
                flag = false;
              }
            }
          }
          if (flag)
          {
            obj1.\uE000(num - obj5.\uE000, obj5.\uE001);
            _param1.\uE000(_param2, _param3 + num);
            num += obj5.\uE001;
            _param1.\uE000(obj5.\uE001 - 1);
          }
          else
          {
            obj1.\uE000(_param2[_param3 + num]);
            _param1.\uE000(_param2, _param3 + num);
            ++num;
          }
        }
        else
        {
          obj1.\uE000(_param2[_param3 + num]);
          _param1.\uE000(_param2, _param3 + num);
          ++num;
        }
      }
      _param5 = _param3 + num;
      for (; num < _param4; ++num)
        obj1.\uE000(_param2[_param3 + num]);
      return obj1;
    }

    private \uE030.\uE017.\uE000 \uE000(
      byte[] _param1,
      int _param2,
      int _param3,
      int _param4,
      \uE030.\uE018.\uE000 _param5,
      int _param6)
    {
      int num1 = this.\uE002.\uE004;
      int num2 = 0;
      int num3 = -1;
      int num4 = 0;
      int num5 = _param6 - 1;
      int num6 = _param2 + _param4;
      while (_param5.\uE000())
      {
        int num7 = 0;
        int num8 = _param4 - _param5.\uE000;
        if (_param4 + num5 < _param3)
        {
          int num9 = _param2 + num8;
          if ((int) _param1[num9 + num5] == (int) _param1[num6 + num5])
          {
            while (num7 < 258 && _param4 + num7 < _param3 && (int) _param1[num9 + num7] == (int) _param1[num6 + num7])
              ++num7;
            if (num7 >= num2)
            {
              num2 = num7;
              num5 = num7;
              num3 = num8;
              if (num2 >= this.\uE002.\uE003)
                break;
            }
            if (num2 >= this.\uE002.\uE001)
              num1 >>= 2;
          }
          if (++num4 >= num1)
            break;
        }
        else
          break;
      }
      return new \uE030.\uE017.\uE000()
      {
        \uE001 = num2,
        \uE000 = num3
      };
    }

    private struct \uE000
    {
      public int \uE000;
      public int \uE001;
    }
  }

  private sealed class \uE018
  {
    private int \uE000;
    private ushort[] \uE001;
    private int[] \uE002;
    private int \uE003;

    internal \uE018(int _param1)
    {
      this.\uE000 = _param1;
      this.\uE001 = new ushort[this.\uE000];
      this.\uE002 = new int[256];
      for (int index = 0; index < 256; ++index)
        this.\uE002[index] = (int) ushort.MaxValue;
    }

    internal \uE030.\uE018.\uE000 \uE000(byte[] _param1, int _param2)
    {
      int index = \uE030.\uE018.\uE000(_param1, _param2);
      return this.\uE002[index] == (int) ushort.MaxValue || this.\uE003 - this.\uE002[index] > this.\uE000 ? (\uE030.\uE018.\uE000) null : new \uE030.\uE018.\uE000(this, this.\uE003 - this.\uE002[index]);
    }

    internal void \uE000(byte[] _param1, int _param2)
    {
      int index1 = \uE030.\uE018.\uE000(_param1, _param2);
      this.\uE001[this.\uE003 % this.\uE000] = this.\uE002[index1] == (int) ushort.MaxValue || this.\uE003 - this.\uE002[index1] >= this.\uE000 ? (ushort) 0 : (ushort) (this.\uE003 - this.\uE002[index1]);
      this.\uE002[index1] = this.\uE003;
      if (++this.\uE003 < 16777216)
        return;
      int num1 = this.\uE003 - this.\uE000;
      int num2 = num1 - num1 % this.\uE000;
      for (int index2 = 0; index2 < this.\uE002.Length; ++index2)
      {
        if (this.\uE002[index2] >= num2)
          this.\uE002[index2] -= num2;
        else
          this.\uE002[index2] = 0;
      }
      this.\uE003 -= num2;
    }

    internal void \uE000(byte[] _param1, int _param2, int _param3)
    {
      for (int index = 0; index < _param3; ++index)
        this.\uE000(_param1, _param2 + index);
    }

    internal void \uE000(int _param1) => this.\uE003 += _param1;

    private static int \uE000(byte[] _param0, int _param1) => (int) (byte) ((uint) _param0[_param1] + (uint) _param0[_param1 + 1] + (uint) _param0[_param1 + 2]);

    internal sealed class \uE000
    {
      private \uE030.\uE018 \uE000;
      private int \uE001;
      private int \uE002;

      internal \uE000(\uE030.\uE018 _param1, int _param2)
      {
        this.\uE000 = _param1;
        this.\uE001 = _param2;
      }

      internal int \uE000 => this.\uE001;

      internal bool \uE000()
      {
        if (this.\uE002 == 0)
        {
          this.\uE002 = 1;
          return true;
        }
        if (this.\uE002 == 1)
        {
          ushort num = this.\uE000.\uE001[(this.\uE000.\uE003 - this.\uE001) % this.\uE000.\uE000];
          if (num != (ushort) 0)
          {
            this.\uE001 += (int) num;
            if (this.\uE001 <= this.\uE000.\uE000)
              return true;
          }
          this.\uE002 = 2;
        }
        return false;
      }
    }
  }

  private sealed class \uE019
  {
    private int \uE000;
    private byte[] \uE001;
    private int \uE002;

    public \uE019(int _param1)
    {
      this.\uE000 = _param1;
      this.\uE001 = new byte[_param1];
      this.\uE002 = 0;
    }

    public byte[] \uE000 => this.\uE001;

    public int \uE003 => this.\uE000;

    public int \uE004 => this.\uE002;

    public void \uE000(byte[] _param1, int _param2, int _param3)
    {
      Array.Copy((Array) _param1, _param2, (Array) this.\uE001, this.\uE002, _param3);
      this.\uE002 += _param3;
    }

    public void \uE000(int _param1)
    {
      Array.Copy((Array) this.\uE001, _param1, (Array) this.\uE001, 0, this.\uE004 - _param1);
      this.\uE002 -= _param1;
    }
  }

  public sealed class \uE01A
  {
    internal ArrayList \uE000 = new ArrayList();
    internal ArrayList \uE001 = new ArrayList();
    internal int \uE002;

    public void \uE000(byte _param1)
    {
      this.\uE000.Add((object) (ushort) _param1);
      ++this.\uE002;
    }

    public void \uE000(int _param1, int _param2)
    {
      if (_param1 < 1 || _param1 > 32768)
        throw new ArgumentOutOfRangeException();
      if (_param2 < 3 || _param2 > 258)
        throw new ArgumentOutOfRangeException();
      int num1;
      int num2;
      int num3;
      \uE02B.\uE00A(_param2, out num1, out num2, out num3);
      int num4;
      int num5;
      int num6;
      \uE02B.\uE00B(_param1, out num4, out num5, out num6);
      this.\uE000.Add((object) (ushort) num1);
      this.\uE000.Add((object) (ushort) num2);
      this.\uE001.Add((object) (byte) num3);
      this.\uE000.Add((object) (ushort) num4);
      this.\uE000.Add((object) (ushort) num5);
      this.\uE001.Add((object) (byte) num6);
      this.\uE002 += _param2;
    }

    internal void \uE000() => this.\uE000.Add((object) (ushort) 256);
  }

  private sealed class \uE01B
  {
    private uint \uE000;
    private int \uE001;
    private Stream \uE002;

    internal \uE01B(Stream _param1) => this.\uE002 = _param1;

    internal Stream \uE000 => this.\uE002;

    internal int \uE000 => (32 - this.\uE001) % 8;

    internal void \uE000(bool _param1) => this.\uE003(_param1 ? 1 : 0, 1);

    internal void \uE003(int _param1, int _param2)
    {
      uint num1 = this.\uE000 | checked ((uint) _param1) << this.\uE001;
      int num2;
      for (num2 = this.\uE001 + _param2; num2 >= 8; num2 -= 8)
      {
        this.\uE000.WriteByte((byte) num1);
        num1 >>= 8;
      }
      this.\uE000 = num1;
      this.\uE001 = num2;
    }

    internal void \uE004(int _param1, int _param2)
    {
      int num = 0;
      for (int index = _param2 - 1; index >= 0; --index)
      {
        num = num << 1 | _param1 & 1;
        _param1 >>= 1;
      }
      this.\uE003(num, _param2);
    }

    internal void \uE000()
    {
      if (this.\uE001 <= 0)
        return;
      this.\uE000.WriteByte((byte) this.\uE000);
      this.\uE000 = 0U;
      this.\uE001 = 0;
    }
  }
}
