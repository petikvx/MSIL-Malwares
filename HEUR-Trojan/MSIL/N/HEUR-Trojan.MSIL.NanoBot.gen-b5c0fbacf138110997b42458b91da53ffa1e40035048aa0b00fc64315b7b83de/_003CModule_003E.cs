// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: eaalrcmrfI, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C355521D-A8D3-4BFF-826A-B700AE05DFBA
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan.MSIL.NanoBot.gen-b5c0fbacf138110997b42458b91da53ffa1e40035048aa0b00fc64315b7b83de.exe

using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  [Set_LongDatePattern(-859935010)]
  internal static M_raiseMethod ÅÀ\u0008\u00B2\u00B7;
  [\u003CasmSimpleName\u003E5__1(764402040)]
  internal static M_raiseMethod ÝFZûÿ;
  [Get_PreserveStringsOffsets(-1208124597)]
  internal static CheckSetDemand2 z_NÑM;
  [Get_PreserveStringsOffsets(1550569665)]
  internal static Op_GreaterThan óÝt\u0085\u0013;
  [ParameterBuilder(1605696241)]
  internal static DirectoryInfoResultHandler Ã\u0092æ\u00B7é;
  [S_ENDARG(-121433849)]
  internal static SystemData ph\u003Cæ\u00B0;
  [\u003CasmSimpleName\u003E5__1(1782426560)]
  internal static GetSecurityAttributes \u0029õH\u008D\u001B;
  [Get_NumberGroupSeparator(1342906751)]
  internal static Op_GreaterThan \u008B\u001Dªßs;
  [IsNegativeInfinity(1515505686)]
  internal static UserDefaultCulture \u0027\u0084èûS;
  [Get_PreserveStringsOffsets(-352611529)]
  internal static Op_GreaterThan \u0018v\u003C\u003E4;
  [S_ENDARG(1881480607)]
  internal static UserDefaultCulture ü\u005EÍþì;
  [\u003CgacInfo\u003E5__5(-2074057314)]
  internal static GetSecurityAttributes \u0001ã\u001DÌf;
  [TaiwanEraInfo(-584753699)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 ÌEFÆ\u0098;
  [DataPosition(-1170482337)]
  internal static Get_IsUninitializedData F\u009E\u00A7\u003EÙ;
  [Get_NumberGroupSeparator(1050195961)]
  internal static EfiApplication ëã6\u003Aÿ;
  [VerifyGroupSeparator(-1438288252)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 \u002EI\u007CK\u002E;
  [Get_IsBusy(-1048638831)]
  internal static Get_IsUninitializedData à\u008F\u0083e\u0098;
  [\u003CgacInfo\u003E5__5(1022216602)]
  internal static OnAssemblyLoadEvent \u00F7õv\u0027\u0020;
  [\u003CasmSimpleName\u003E5__1(1096547572)]
  internal static EfiApplication \u0031\u005D\u0040\u000EÐ;
  [Get_PreserveStringsOffsets(1990969895)]
  internal static GetDeviceName \u005E\u003ER\u0091\u005B;
  [VerifyGroupSeparator(-1535702200)]
  internal static TrimHead Ñã\u003D\u001A\u0022;
  [Get_Parent(1025945065)]
  internal static TrimHead \u000Aíu\u0014Ã;
  [S_ENDARG(-625066205)]
  internal static GetSecurityAttributes \u0012\u0023ç\u0084\u00BF;
  [Get_NumberGroupSeparator(82693837)]
  internal static OnAssemblyLoadEvent é1îE\u0018;
  [COR_E_ARGUMENTOUTOFRANGE(-626879346)]
  internal static CallCallbackInContext UÇ\u002F\u0099p;
  [\u003CasmSimpleName\u003E5__1(63802906)]
  internal static GetSecurityAttributes \u009Dèà\u0001V;
  [\u003CgacInfo\u003E5__5(-903793142)]
  internal static GetSecurityAttributes ÆÉ\u00A8\u00BBz;
  [Get_IsBusy(-2133976179)]
  internal static OnAssemblyLoadEvent üöØ7\u003F;
  [\u003CgacInfo\u003E5__5(-1892395282)]
  internal static CallCallbackInContext \u0027\u0090\u00F7\u000A\u005C;
  [\u003CasmSimpleName\u003E5__1(-1956218)]
  internal static get_Salt ó`È\u00A5È;
  [Get_IsBusy(1711357483)]
  internal static GetSecurityAttributes ôfûë\u0091;
  [S_ENDARG(2139274669)]
  internal static InternalHigh \u0085\u008A\u007F3a;
  [EnumInterfaceImpls(1901397285)]
  internal static ReadRow å\u003BÖR8;
  [\u003CasmSimpleName\u003E5__1(-1666664048)]
  internal static GetSecurityAttributes \u0098\u00A8\u001C\u00BBÐ;
  [Get_NumberGroupSeparator(-1170957579)]
  internal static SetEntryPointNoLock \u003AÂ\u0005Dé;
  [TaiwanEraInfo(1767197497)]
  internal static GetSecurityAttributes \u0088Ïl\u002C\u0016;
  [Set_LongDatePattern(-818047918)]
  internal static GetDeviceName \u005EQ\u0082Ü\u0004;
  [Get_IsBusy(373567899)]
  internal static OnAssemblyLoadEvent \u008C\u003F\u00A0\u00B6y;
  [Set_LongDatePattern(-650493068)]
  internal static ReadRow H\u0002\u00AFÀ\u00B9;
  [\u003CgacInfo\u003E5__5(-1719116712)]
  internal static InternalHigh \u0037í\u00B0\u009D`;
  [\u003CasmSimpleName\u003E5__1(-340751562)]
  internal static InternalHigh \u00B6\u0095O\u007FE;
  [EnumInterfaceImpls(-152298013)]
  internal static OnAssemblyLoadEvent \u008C\u007Be\u001F\u0091;
  [Set_LongDatePattern(1339685422)]
  internal static Get_Boolean \u00A3lEï6;
  [IsNegativeInfinity(-48574690)]
  internal static genericParamConstraints \u009A\u00AF\u0089bz;
  [Get_NumberGroupSeparator(-1447133597)]
  internal static OnAssemblyLoadEvent ÆnU1g;
  [COR_E_ARGUMENTOUTOFRANGE(1097742596)]
  internal static IsEcma2002 zT\u00B3ò\u000A;
  [DataPosition(-855176503)]
  internal static OnAssemblyLoadEvent æ\u007D\u00B2òþ;
  [COR_E_ARGUMENTOUTOFRANGE(784919024)]
  internal static \u003CLogger\u003Ek__BackingField éRd\u0088Î;
  [DataPosition(-533061077)]
  internal static TryParseSingle k\u003EVie;
  [COR_E_ARGUMENTOUTOFRANGE(-50366462)]
  internal static Functions Û\u00A2\u005B\u0009\u0027;
  [Get_PreserveStringsOffsets(-981327471)]
  internal static GetTimeZoneName w4º\u00B7\u000A;
  [ParameterBuilder(943752123)]
  internal static NumberGroupSeparator ß\u0006\u0097\u00B8Å;
  [ISymUnmanagedWriter2(-1473377704)]
  internal static IsManagedWinMD kÄ\u0017A\u0027;
  [S_ENDARG(-1949568461)]
  internal static invokeMethod \u00A2ÓêîI;
  [Get_PreserveStringsOffsets(857476443)]
  internal static LocalPush \u0031\u002AÃ\u0024\u0084;
  [Get_PreserveStringsOffsets(2071673553)]
  internal static InternalHigh \u00A1\u0026\u009D\u0027c;
  [DataPosition(1166356803)]
  internal static TargetFrameworkAttribute \u0090TLÞP;
  [EnumInterfaceImpls(1940192033)]
  internal static Get_IsUninitializedData õp\u00B0b\u002F;
  [\u003CgacInfo\u003E5__5(925631182)]
  internal static Get_IsUninitializedData \u009A\u008C\u00AFº\u008A;
  [ParameterBuilder(-1784756419)]
  internal static Get_IsUninitializedData Ú\u0027\u00884\u0021;
  [Get_IsBusy(1493648483)]
  internal static SEHException D\u005C\u007C\u00B8\u0026;
  [TaiwanEraInfo(810041499)]
  internal static InternalHigh \u007EX\u005E\u0007Q;
  [Get_Parent(-121983581)]
  internal static BytesPerWChar \u0091AF_ç;
  [EnumInterfaceImpls(743817737)]
  internal static Op_GreaterThan ÚO\u001326;
  [Set_LongDatePattern(-191294670)]
  internal static Op_GreaterThan \u008BÕ\u009Dáâ;
  [Get_NumberGroupSeparator(-1880268167)]
  internal static GetDeviceName Q\u001E\u00B7D\u0026;
  [DataPosition(1316815617)]
  internal static FixSignature \u0007\u0011\u0089\u0091\u007F;
  [Get_NumberGroupSeparator(-1814277227)]
  internal static GetTimeOfNN u\u0010ý\u008Aÿ;
  [Get_PreserveStringsOffsets(1367506463)]
  internal static Remove_AssemblyLoad v\u0016OD\u00BC;
  [\u003CgacInfo\u003E5__5(1610914968)]
  internal static CreateNewTimeDateStamp LÀá\u009EØ;
  [\u003CasmSimpleName\u003E5__1(1044832272)]
  internal static Op_GreaterThan Ö\u00A8\u00A8\u0096À;
  [EnumInterfaceImpls(1033140503)]
  internal static IsAbstract \u003555\u00A0\u00B3;
  [EnumInterfaceImpls(-431296115)]
  internal static UserDefaultCulture É\u0002\u000B\u00BCâ;
  [Get_PreserveStringsOffsets(2099571193)]
  internal static FixSignature \u0017ùGè\u0090;
  [Get_NumberGroupSeparator(2048429551)]
  internal static NativeMethods \u0017\u003D\u00B8\u0015h;
  [EnumInterfaceImpls(-591243463)]
  internal static COR_E_STACKOVERFLOW \u0029\u009CÊî\u003E;
  [VerifyGroupSeparator(121665116)]
  internal static SCURRENCY \u008DÛ\u00F7\u0021\u009C;
  [Get_NumberGroupSeparator(1346431933)]
  internal static GetExceptionDispatchInfos \u0003\u003FRx\u000A;
  [Get_Parent(-2089721615)]
  internal static M_globalTypeBuilder Ü\u0011U\u0090\u00A9;
  [Get_PreserveStringsOffsets(1538309425)]
  internal static IsAbstract \u0026û\u0083\u001BÐ;
  [DataPosition(-1926404747)]
  internal static GetSecurityAttributes \u0090\u003C\u0026öì;
  [ParameterBuilder(1150215301)]
  internal static StandardTaskContinuation \u00ADG\u00B9â\u0025;
  [VerifyGroupSeparator(-172756892)]
  internal static Get_IsUninitializedData Û\u00AFH\u0040Â;
  [Get_PreserveStringsOffsets(1486723933)]
  internal static Get_IsUninitializedData e\u00F7\u0080\u0001\u005D;
  [COR_E_ARGUMENTOUTOFRANGE(1074803268)]
  internal static Get_IsUninitializedData O\u00F7\u00A0\u0096Ó;
  [IsNegativeInfinity(1950835700)]
  internal static OnAssemblyLoadEvent \u0038\u0081º\u00A8\u00A8;
  [EnumInterfaceImpls(-1402367407)]
  internal static EfiApplication Ãû\u00BBFv;
  [ParameterBuilder(-1568023281)]
  internal static SetEntryPointNoLock i\u005E\u0040uÈ;
  [DataPosition(-427498561)]
  internal static OnAssemblyLoadEvent KÛ\u002A\u00A0\u0099;
  [DataPosition(-1506392645)]
  internal static CompleteOnInvokePromise \u00B1\u008CZ\u00ADè;
  [EnumInterfaceImpls(-1734703881)]
  internal static Get_StackTrace \u009C\u00BEÖ\u003BU;
  [ISymUnmanagedWriter2(1693105256)]
  internal static M_initSize \u0083óý\u0007ä;
  [Get_NumberGroupSeparator(-489354241)]
  internal static ClassLayoutTable \u00F7\u0080Å\u0093Þ;
  [Get_Parent(1557686679)]
  internal static OnAssemblyLoadEvent U\u001F`\u0004î;
  [Set_LongDatePattern(-938497032)]
  internal static OnAssemblyLoadEvent íx\u0092\u00B8\u0017;
  [DataPosition(332355343)]
  internal static GetDeclaringTypeInternal \u009B\u0093\u009Aâ\u002D;
  [S_ENDARG(690042021)]
  internal static Set_IsPreserveSig \u0009ÉØ\u001B\u00AF;
  [IsNegativeInfinity(-738599178)]
  internal static GenericComparer \u000CQ\u00A3\u0004\u001A;
  [DataPosition(2136080667)]
  internal static InternalHigh \u005Dõ\u00A9\u0018\u0002;
  [Get_IsBusy(1429505787)]
  internal static Set_IsUnmanaged cäÀãÑ;
  [\u003CasmSimpleName\u003E5__1(-513646654)]
  internal static _fullyInitialized \u0019\u0012D\u008CÌ;
  [Set_LongDatePattern(-1407752848)]
  internal static InternalHigh \u0033\u002CÛ\u00BCZ;
  [S_ENDARG(1647020929)]
  internal static \u003CLogger\u003Ek__BackingField e\u008C\u00B4ê\u0092;
  [Set_LongDatePattern(425822146)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 cúï\u008D\u0001;
  [S_ENDARG(-1247632223)]
  internal static invokeMethod º\u00A9\u0012\u007CZ;
  [IsNegativeInfinity(997476964)]
  internal static ReRegisterForFinalize æúç\u002E\u00A6;
  [COR_E_ARGUMENTOUTOFRANGE(-2002650350)]
  internal static OnAssemblyLoadEvent \u0080ëÁ\u000Bl;
  [S_ENDARG(159290669)]
  internal static StandardTaskContinuation y\u000Dª\u00A8\u005D;
  [ParameterBuilder(-676155413)]
  internal static HeaderOffset \u0008\u00B0ahË;
  [Get_Parent(-2121533145)]
  internal static LocalPush wº1è\u0080;
  [\u003CgacInfo\u003E5__5(1479714718)]
  internal static LOCALE_IGEOID \u0009\u0084\u00816z;
  [ParameterBuilder(-1835028465)]
  internal static M_raiseMethod ô\u00BEÑ\u0014\u002C;
  [IsNegativeInfinity(-21092794)]
  internal static LocalPush \u0085KªX\u00B4;
  [TaiwanEraInfo(1013718013)]
  internal static IsAppEarlierThanSl4 \u0009É\u007Bi\u0090;
  [COR_E_ARGUMENTOUTOFRANGE(1185883536)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 þò\u0008\u0096\u003C;
  [Get_PreserveStringsOffsets(-1291561591)]
  internal static PMDesignator \u002E4gU\u0094;
  [Get_PreserveStringsOffsets(310468599)]
  internal static Calculate \u005BiÚ\u0088ü;
  [\u003CasmSimpleName\u003E5__1(395669608)]
  internal static MaxSecondsFractionDigits uÙjë\u00AB;
  [VerifyGroupSeparator(1823973488)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 \u00A8\u005E\u00A5Bk;
  [DataPosition(1790300739)]
  internal static LocalPush ÛºÐ\u008Dð;
  [ISymUnmanagedWriter2(1532718384)]
  internal static CreatePdbState w2Âª\u0009;
  [TaiwanEraInfo(1682779601)]
  internal static CreateNewTimeDateStamp \u003B\u0019ª3\u009B;
  [Get_NumberGroupSeparator(-230852227)]
  internal static Get_ControlThread ô_\u0011\u00A0Ì;
  [Set_LongDatePattern(1317966800)]
  internal static StackPush Ô1fÆt;
  [S_ENDARG(887399691)]
  internal static GetStringHelper \u0034\u002A\u009F\u00AC\u009A;
  [COR_E_ARGUMENTOUTOFRANGE(1055143914)]
  internal static OnAssemblyLoadEvent B\u001FË\u0022ÿ;
  [TaiwanEraInfo(-1738840049)]
  internal static _factory \u008B\u005E\u0018\u008CY;
  [\u003CgacInfo\u003E5__5(-1337689732)]
  internal static ReadRow \u00A0\u008DáÙ\u0001;
  [ISymUnmanagedWriter2(-1173428122)]
  internal static ReadInlineVarArg \u008AÜusò;
  [\u003CasmSimpleName\u003E5__1(865001934)]
  internal static ReportProgress A\u003B6úÈ;
  [ParameterBuilder(-665439551)]
  internal static strName Sµãø\u0082;
  [EnumInterfaceImpls(1868752025)]
  internal static get_Interface \u002Aø\u00AB\u009Ep;
  [Get_Parent(-620977807)]
  internal static StandardTaskContinuation \u0032\u008Fïa\u009C;
  [ISymUnmanagedWriter2(711647322)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 ùÙTÓ\u009A;
  [\u003CasmSimpleName\u003E5__1(1127940738)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 b\u00D7\u0099Ñª;
  [EnumInterfaceImpls(-1977930467)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 \u007D\u008EK\u00ACº;
  [Get_Parent(1134957827)]
  internal static LocalPush ØcßwL;
  [Get_PreserveStringsOffsets(-1981566633)]
  internal static \u003CLogger\u003Ek__BackingField \u003B5\u007E\u009Bü;
  [ParameterBuilder(1105231565)]
  internal static \u003CLogger\u003Ek__BackingField \u00BE\u008B\u000FÒS;
  [S_ENDARG(782063555)]
  internal static BUsedEncoder é\u000A\u00B2\u003Bé;
  [Set_LongDatePattern(-364292832)]
  internal static SetEntryPointNoLock \u0086E\u009EJß;
  [TaiwanEraInfo(-36411839)]
  internal static DefaultComparer \u0012\u009D\u005E5\u0092;
  [IsNegativeInfinity(-1436924798)]
  internal static MatchEraName \u00BFV\u0004Eü;
  [Get_Parent(293839543)]
  internal static InternalHigh Dðýàú;
  [IsNegativeInfinity(-110397904)]
  internal static \u003CGetExtraMonoPaths\u003Ed__55 Åá\u005CµÛ;
  [\u003CgacInfo\u003E5__5(828592424)]
  internal static OnAssemblyLoadEvent \u0011IÂeE;
  [Get_NumberGroupSeparator(1479624381)]
  internal static LocalPush \u00B7ÛéÒä;
  [DataPosition(1658412403)]
  internal static Set_TargetTypeName \u00A8e\u0089I\u002C;

  static \u003CModule\u003E()
  {
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u00A8e\u0089I\u002C), (byte) 67);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.\u00B7ÛéÒä), (byte) 180);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.\u0011IÂeE), (byte) 98);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.Åá\u005CµÛ), (byte) 180);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.Dðýàú), (byte) 159);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u00BFV\u0004Eü), (byte) 212);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u0012\u009D\u005E5\u0092), (byte) 29);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.\u0086E\u009EJß), (byte) 42);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.é\u000A\u00B2\u003Bé), (byte) 134);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u00BE\u008B\u000FÒS), (byte) 209);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.\u003B5\u007E\u009Bü), (byte) 244);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.ØcßwL), (byte) 12);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.\u007D\u008EK\u00ACº), (byte) 225);
    // ISSUE: field reference
    \u003CModule\u003E.REG_SZ(__fieldref (\u003CModule\u003E.b\u00D7\u0099Ñª), (byte) 197);
    // ISSUE: field reference
    \u003CModule\u003E.REG_SZ(__fieldref (\u003CModule\u003E.ùÙTÓ\u009A), (byte) 178);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.\u0032\u008Fïa\u009C), (byte) 65);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.\u002Aø\u00AB\u009Ep), (byte) 208);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.Sµãø\u0082), (byte) 170);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.A\u003B6úÈ), (byte) 19);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u008AÜusò), (byte) 218);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u00A0\u008DáÙ\u0001), (byte) 136);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.\u008B\u005E\u0018\u008CY), (byte) 163);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.B\u001FË\u0022ÿ), (byte) 140);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.\u0034\u002A\u009F\u00AC\u009A), (byte) 28);
    // ISSUE: field reference
    \u003CModule\u003E.REG_SZ(__fieldref (\u003CModule\u003E.Ô1fÆt), (byte) 92);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.ô_\u0011\u00A0Ì), (byte) 136);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u003B\u0019ª3\u009B), (byte) 179);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.w2Âª\u0009), (byte) 95);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.ÛºÐ\u008Dð), (byte) 180);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u00A8\u005E\u00A5Bk), (byte) 4);
    // ISSUE: field reference
    \u003CModule\u003E.ManualResetEvent(__fieldref (\u003CModule\u003E.uÙjë\u00AB), (byte) 5);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.\u005BiÚ\u0088ü), (byte) 52);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u002E4gU\u0094), (byte) 251);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.þò\u0008\u0096\u003C), (byte) 145);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.\u0009É\u007Bi\u0090), (byte) 166);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.\u0085KªX\u00B4), (byte) 156);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.ô\u00BEÑ\u0014\u002C), (byte) 60);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u0009\u0084\u00816z), (byte) 89);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.wº1è\u0080), (byte) 135);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.\u0008\u00B0ahË), (byte) 103);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.y\u000Dª\u00A8\u005D), (byte) 46);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u0080ëÁ\u000Bl), (byte) 168);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.æúç\u002E\u00A6), (byte) 206);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.º\u00A9\u0012\u007CZ), (byte) 15);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.cúï\u008D\u0001), (byte) 110);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.e\u008C\u00B4ê\u0092), (byte) 227);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.\u0033\u002CÛ\u00BCZ), (byte) 67);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.\u0019\u0012D\u008CÌ), (byte) 125);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.cäÀãÑ), (byte) 140);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.\u005Dõ\u00A9\u0018\u0002), (byte) 154);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u000CQ\u00A3\u0004\u001A), (byte) 117);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u0009ÉØ\u001B\u00AF), (byte) 171);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u009B\u0093\u009Aâ\u002D), (byte) 245);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.íx\u0092\u00B8\u0017), (byte) 158);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.U\u001F`\u0004î), (byte) 108);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.\u00F7\u0080Å\u0093Þ), (byte) 223);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.\u0083óý\u0007ä), (byte) 156);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.\u009C\u00BEÖ\u003BU), (byte) 243);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u00B1\u008CZ\u00ADè), (byte) 53);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.KÛ\u002A\u00A0\u0099), (byte) 177);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.i\u005E\u0040uÈ), (byte) 6);
    // ISSUE: field reference
    \u003CModule\u003E.ManualResetEvent(__fieldref (\u003CModule\u003E.Ãû\u00BBFv), (byte) 212);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u0038\u0081º\u00A8\u00A8), (byte) 219);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.O\u00F7\u00A0\u0096Ó), (byte) 249);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.e\u00F7\u0080\u0001\u005D), (byte) 152);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.Û\u00AFH\u0040Â), (byte) 173);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u00ADG\u00B9â\u0025), (byte) 202);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u0090\u003C\u0026öì), (byte) 14);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.\u0026û\u0083\u001BÐ), (byte) 211);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.Ü\u0011U\u0090\u00A9), (byte) 126);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u0003\u003FRx\u000A), (byte) 121);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u008DÛ\u00F7\u0021\u009C), (byte) 223);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.\u0029\u009CÊî\u003E), (byte) 180);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u0017\u003D\u00B8\u0015h), (byte) 64);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u0017ùGè\u0090), (byte) 184);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.É\u0002\u000B\u00BCâ), (byte) 42);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.\u003555\u00A0\u00B3), (byte) 29);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.Ö\u00A8\u00A8\u0096À), (byte) 232);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.LÀá\u009EØ), (byte) 100);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.v\u0016OD\u00BC), (byte) 108);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.u\u0010ý\u008Aÿ), (byte) 56);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u0007\u0011\u0089\u0091\u007F), (byte) 161);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.Q\u001E\u00B7D\u0026), (byte) 14);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.\u008BÕ\u009Dáâ), (byte) 253);
    // ISSUE: field reference
    \u003CModule\u003E.ManualResetEvent(__fieldref (\u003CModule\u003E.ÚO\u001326), (byte) 59);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u0091AF_ç), (byte) 110);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u007EX\u005E\u0007Q), (byte) 118);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.D\u005C\u007C\u00B8\u0026), (byte) 108);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.Ú\u0027\u00884\u0021), (byte) 242);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u009A\u008C\u00AFº\u008A), (byte) 162);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.õp\u00B0b\u002F), (byte) 221);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u0090TLÞP), (byte) 246);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.\u00A1\u0026\u009D\u0027c), (byte) 15);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u0031\u002AÃ\u0024\u0084), (byte) 235);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u00A2ÓêîI), (byte) 209);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.kÄ\u0017A\u0027), (byte) 15);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.ß\u0006\u0097\u00B8Å), (byte) 247);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.w4º\u00B7\u000A), (byte) 28);
    // ISSUE: field reference
    \u003CModule\u003E.TypeNamespace(__fieldref (\u003CModule\u003E.Û\u00A2\u005B\u0009\u0027), (byte) 138);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.k\u003EVie), (byte) 22);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.éRd\u0088Î), (byte) 231);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.æ\u007D\u00B2òþ), (byte) 206);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.zT\u00B3ò\u000A), (byte) 124);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.ÆnU1g), (byte) 181);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.\u009A\u00AF\u0089bz), (byte) 82);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u00A3lEï6), (byte) 139);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u008C\u007Be\u001F\u0091), byte.MaxValue);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u00B6\u0095O\u007FE), (byte) 87);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.\u0037í\u00B0\u009D`), (byte) 242);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.H\u0002\u00AFÀ\u00B9), (byte) 145);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.\u008C\u003F\u00A0\u00B6y), (byte) 76);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.\u005EQ\u0082Ü\u0004), (byte) 121);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u0088Ïl\u002C\u0016), (byte) 62);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.\u003AÂ\u0005Dé), (byte) 173);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u0098\u00A8\u001C\u00BBÐ), (byte) 147);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.å\u003BÖR8), (byte) 205);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.\u0085\u008A\u007F3a), (byte) 14);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.ôfûë\u0091), (byte) 195);
    // ISSUE: field reference
    \u003CModule\u003E.\u003CGetAllTypeDefs\u003Eb__0(__fieldref (\u003CModule\u003E.ó`È\u00A5È), (byte) 224);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.\u0027\u0090\u00F7\u000A\u005C), (byte) 72);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.üöØ7\u003F), (byte) 222);
    // ISSUE: field reference
    \u003CModule\u003E.ManualResetEvent(__fieldref (\u003CModule\u003E.ÆÉ\u00A8\u00BBz), (byte) 128);
    // ISSUE: field reference
    \u003CModule\u003E.SetException(__fieldref (\u003CModule\u003E.\u009Dèà\u0001V), (byte) 192);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.UÇ\u002F\u0099p), (byte) 168);
    // ISSUE: field reference
    \u003CModule\u003E.SortedRows`2(__fieldref (\u003CModule\u003E.é1îE\u0018), (byte) 25);
    // ISSUE: field reference
    \u003CModule\u003E.GenerateString(__fieldref (\u003CModule\u003E.\u0012\u0023ç\u0084\u00BF), (byte) 151);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.\u000Aíu\u0014Ã), (byte) 34);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.Ñã\u003D\u001A\u0022), (byte) 50);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.\u005E\u003ER\u0091\u005B), (byte) 118);
    // ISSUE: field reference
    \u003CModule\u003E.S_pNumericLevel1Index(__fieldref (\u003CModule\u003E.\u0031\u005D\u0040\u000EÐ), (byte) 191);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.\u00F7õv\u0027\u0020), (byte) 221);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.à\u008F\u0083e\u0098), (byte) 10);
    // ISSUE: field reference
    \u003CModule\u003E.Leopard(__fieldref (\u003CModule\u003E.\u002EI\u007CK\u002E), (byte) 15);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.ëã6\u003Aÿ), (byte) 140);
    // ISSUE: field reference
    \u003CModule\u003E.ManualResetEvent(__fieldref (\u003CModule\u003E.F\u009E\u00A7\u003EÙ), (byte) 200);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.ÌEFÆ\u0098), (byte) 191);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.\u0001ã\u001DÌf), (byte) 41);
    // ISSUE: field reference
    \u003CModule\u003E.GetEnumerable_NoLock(__fieldref (\u003CModule\u003E.ü\u005EÍþì), (byte) 212);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.\u0018v\u003C\u003E4), (byte) 94);
    // ISSUE: field reference
    \u003CModule\u003E.REG_SZ(__fieldref (\u003CModule\u003E.\u0027\u0084èûS), (byte) 123);
    // ISSUE: field reference
    \u003CModule\u003E.UpdateInstructionOffsets(__fieldref (\u003CModule\u003E.\u008B\u001Dªßs), (byte) 247);
    // ISSUE: field reference
    \u003CModule\u003E.Comparer(__fieldref (\u003CModule\u003E.\u0029õH\u008D\u001B), (byte) 165);
    // ISSUE: field reference
    \u003CModule\u003E.CombineHashCodes(__fieldref (\u003CModule\u003E.ph\u003Cæ\u00B0), (byte) 31);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.Ã\u0092æ\u00B7é), (byte) 216);
    // ISSUE: field reference
    \u003CModule\u003E.IllegalRange(__fieldref (\u003CModule\u003E.óÝt\u0085\u0013), (byte) 219);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.z_NÑM), (byte) 190);
    // ISSUE: field reference
    \u003CModule\u003E.InternalValueCount(__fieldref (\u003CModule\u003E.ÝFZûÿ), (byte) 211);
    // ISSUE: field reference
    \u003CModule\u003E.ClassSemanticsMask(__fieldref (\u003CModule\u003E.ÅÀ\u0008\u00B2\u00B7), (byte) 232);
    \u003CModule\u003E.Get_IsSecurityCritical();
  }

  private static void Get_IsSecurityCritical()
  {
    string str = "COR";
    // ISSUE: type reference
    // ISSUE: type reference
    MethodInfo methodInfo = (MethodInfo) CheckSetDemand2.ENCLogTable((object) (Type) \u003CModule\u003E.ÅÀ\u0008\u00B2\u00B7(__typeref (Environment)), "GetEnvironmentVariable", new Type[1]
    {
      (Type) \u003CModule\u003E.ÝFZûÿ(__typeref (string))
    });
    if ((object) methodInfo != null)
    {
      if (SystemData.SHGetFolderPath((object) "1", DirectoryInfoResultHandler.AddMilliseconds((object) methodInfo, (object) null, new object[1]
      {
        (object) \u003CModule\u003E.óÝt\u0085\u0013(str, "_ENABLE_PROFILING")
      })))
        \u003CModule\u003E.\u0029õH\u008D\u001B((string) null);
    }
    if (\u003CModule\u003E.\u0027\u0084èûS(\u003CModule\u003E.\u008B\u001Dªßs(str, "_PROFILER")) != null || \u003CModule\u003E.ü\u005EÍþì(\u003CModule\u003E.\u0018v\u003C\u003E4(str, "_ENABLE_PROFILING")) != null)
      \u003CModule\u003E.\u0001ã\u001DÌf((string) null);
    Thread thread = (Thread) \u003CModule\u003E.ÌEFÆ\u0098((object) new ParameterizedThreadStart(\u003CModule\u003E.Set_ContainsMetaData));
    \u003CModule\u003E.F\u009E\u00A7\u003EÙ((object) thread, true);
    \u003CModule\u003E.ëã6\u003Aÿ((object) thread, (object) null);
  }

  private static void Set_ContainsMetaData([In] object obj0)
  {
    if (!(obj0 is Thread thread))
    {
      thread = (Thread) \u003CModule\u003E.\u002EI\u007CK\u002E((object) new ParameterizedThreadStart(\u003CModule\u003E.Set_ContainsMetaData));
      \u003CModule\u003E.à\u008F\u0083e\u0098((object) thread, true);
      \u003CModule\u003E.\u0031\u005D\u0040\u000EÐ((object) thread, \u003CModule\u003E.\u00F7õv\u0027\u0020());
      \u003CModule\u003E.\u005E\u003ER\u0091\u005B(500);
    }
    while (true)
    {
      if (TrimHead.AvailableFreeSpace() || \u003CModule\u003E.\u000Aíu\u0014Ã())
        \u003CModule\u003E.\u0012\u0023ç\u0084\u00BF((string) null);
      bool flag = false;
      \u003CModule\u003E.S_factory(\u003CModule\u003E.UÇ\u002F\u0099p(\u003CModule\u003E.é1îE\u0018()), ref flag);
      if (flag)
        \u003CModule\u003E.\u009Dèà\u0001V((string) null);
      if (\u003CModule\u003E.ZeroFreeGlobalAllocUnicode())
        \u003CModule\u003E.ÆÉ\u00A8\u00BBz((string) null);
      Process process = (Process) OnAssemblyLoadEvent.PropertyDefInfos();
      if (\u003CModule\u003E.ó`È\u00A5È(\u003CModule\u003E.\u0027\u0090\u00F7\u000A\u005C((object) process), IntPtr.Zero))
        \u003CModule\u003E.ôfûë\u0091("");
      \u003CModule\u003E.\u0085\u008A\u007F3a((object) process);
      if (\u003CModule\u003E.ValidateObject("") > \u003CModule\u003E.å\u003BÖR8())
        \u003CModule\u003E.\u0098\u00A8\u001C\u00BBÐ("");
      if (!\u003CModule\u003E.\u003AÂ\u0005Dé((object) thread))
        \u003CModule\u003E.\u0088Ïl\u002C\u0016((string) null);
      \u003CModule\u003E.\u005EQ\u0082Ü\u0004(1000);
    }
  }

  [DllImport("kernel32.dll", EntryPoint = "IsDebuggerPresent")]
  private static extern bool ZeroFreeGlobalAllocUnicode();

  [DllImport("kernel32.dll", EntryPoint = "CheckRemoteDebuggerPresent", SetLastError = true)]
  private static extern bool S_factory([In] IntPtr obj0, [In] ref bool obj1);

  [DllImport("kernel32.dll", EntryPoint = "OutputDebugString", CharSet = CharSet.Auto)]
  private static extern int ValidateObject([In] string obj0);

  [DllImport("kernel32.dll", EntryPoint = "CloseHandle")]
  private static extern bool \u0024\u0024method0x600030c\u002D1([In] IntPtr obj0);

  static void ClassSemanticsMask([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.FireQueuedTimerCompletion(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 8)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int FireQueuedTimerCompletion([In] int obj0);

  static void InternalValueCount([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Get_Size(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[3] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Get_Size([In] int obj0);

  static void IllegalRange([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.IntranetUri(num4 + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[0] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int IntranetUri([In] int obj0);

  static void CombineHashCodes([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.M_DynamicILInfo(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[0] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int M_DynamicILInfo([In] int obj0);

  static void Comparer([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.GetExceptionForHR(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[3] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int GetExceptionForHR([In] int obj0);

  static void UpdateInstructionOffsets([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.PercentGroupSeparator(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[3] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int PercentGroupSeparator([In] int obj0);

  static void REG_SZ([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Get_Is32Bit(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 16)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Get_Is32Bit([In] int obj0);

  static void GetEnumerable_NoLock([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.AsyncOperationManager(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[0] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int AsyncOperationManager([In] int obj0);

  static void ManualResetEvent([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 24);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.KeyName(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 16)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[2] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int KeyName([In] int obj0);

  static void Leopard([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.CreateClassOrValueType(num4 + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[2] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int CreateClassOrValueType([In] int obj0);

  static void S_pNumericLevel1Index([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.ParseCombiningCharacters(num4 + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int ParseCombiningCharacters([In] int obj0);

  static void GenerateString([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 16);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.Runrtl(num4 + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int Runrtl([In] int obj0);

  static void SortedRows`2([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.get_IsAllocated(num4 + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int get_IsAllocated([In] int obj0);

  static void SetException([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 16) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 8) + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num3 = num2 - 1]) << 0);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.ProjectWinMDRefs(num4 + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int ProjectWinMDRefs([In] int obj0);

  static void \u003CGetAllTypeDefs\u003Eb__0([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num1 = length - 1]) << 24) + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.HAVE_RESOURCES(num4 + (((int) fieldFromHandle.Name[1] ^ (int) numArray1[num6 = num5 - 1]) << 0)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[4] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int HAVE_RESOURCES([In] int obj0);

  static void TypeNamespace([In] RuntimeFieldHandle obj0, [In] byte obj1)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(obj0);
    byte[] numArray1 = fieldFromHandle.Module.ResolveSignature(fieldFromHandle.MetadataToken);
    int length = numArray1.Length;
    int num1;
    int num2;
    int num3;
    int num4 = fieldFromHandle.GetOptionalCustomModifiers()[0].MetadataToken + (((int) fieldFromHandle.Name[3] ^ (int) numArray1[num1 = length - 1]) << 0) + (((int) fieldFromHandle.Name[4] ^ (int) numArray1[num2 = num1 - 1]) << 16) + (((int) fieldFromHandle.Name[0] ^ (int) numArray1[num3 = num2 - 1]) << 8);
    int num5 = num3 - 1;
    int num6;
    int metadataToken = \u003CModule\u003E.IocbHelper(num4 + (((int) fieldFromHandle.Name[2] ^ (int) numArray1[num6 = num5 - 1]) << 24)) * fieldFromHandle.GetCustomAttributes(false)[0].GetHashCode();
    MethodBase method1 = fieldFromHandle.Module.ResolveMethod(metadataToken);
    Type fieldType = fieldFromHandle.FieldType;
    if (method1.IsStatic)
    {
      fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldType, (MethodInfo) method1));
    }
    else
    {
      DynamicMethod dynamicMethod = (DynamicMethod) null;
      Type[] parameterTypes = (Type[]) null;
      foreach (MethodInfo method2 in fieldFromHandle.FieldType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic))
      {
        if ((object) method2.DeclaringType == (object) fieldType)
        {
          ParameterInfo[] parameters = method2.GetParameters();
          parameterTypes = new Type[parameters.Length];
          for (int index = 0; index < parameterTypes.Length; ++index)
            parameterTypes[index] = parameters[index].ParameterType;
          Type declaringType = method1.DeclaringType;
          dynamicMethod = new DynamicMethod("", method2.ReturnType, parameterTypes, declaringType.IsInterface || declaringType.IsArray ? fieldType : declaringType, true);
          break;
        }
      }
      DynamicILInfo dynamicIlInfo = dynamicMethod.GetDynamicILInfo();
      dynamicIlInfo.SetLocalSignature(new byte[2]
      {
        (byte) 7,
        (byte) 0
      });
      byte[] code = new byte[7 * parameterTypes.Length + 6];
      int num7 = 0;
      ParameterInfo[] parameters1 = method1.GetParameters();
      int index1 = method1.IsConstructor ? 0 : -1;
      for (int index2 = 0; index2 < parameterTypes.Length; ++index2)
      {
        byte[] numArray2 = code;
        int index3 = num7;
        int num8 = index3 + 1;
        numArray2[index3] = (byte) 14;
        byte[] numArray3 = code;
        int index4 = num8;
        int num9 = index4 + 1;
        int num10 = (int) (byte) index2;
        numArray3[index4] = (byte) num10;
        Type type = index1 == -1 ? method1.DeclaringType : parameters1[index1].ParameterType;
        if (type.IsClass && !type.IsPointer && !type.IsByRef)
        {
          int tokenFor = dynamicIlInfo.GetTokenFor(type.TypeHandle);
          byte[] numArray4 = code;
          int index5 = num9;
          int num11 = index5 + 1;
          numArray4[index5] = (byte) 116;
          byte[] numArray5 = code;
          int index6 = num11;
          int num12 = index6 + 1;
          int num13 = (int) (byte) tokenFor;
          numArray5[index6] = (byte) num13;
          byte[] numArray6 = code;
          int index7 = num12;
          int num14 = index7 + 1;
          int num15 = (int) (byte) (tokenFor >> 8);
          numArray6[index7] = (byte) num15;
          byte[] numArray7 = code;
          int index8 = num14;
          int num16 = index8 + 1;
          int num17 = (int) (byte) (tokenFor >> 16);
          numArray7[index8] = (byte) num17;
          byte[] numArray8 = code;
          int index9 = num16;
          num7 = index9 + 1;
          int num18 = (int) (byte) (tokenFor >> 24);
          numArray8[index9] = (byte) num18;
        }
        else
          num7 = num9 + 5;
        ++index1;
      }
      byte[] numArray9 = code;
      int index10 = num7;
      int num19 = index10 + 1;
      int num20 = (int) (byte) ((uint) (byte) fieldFromHandle.Name[1] ^ (uint) obj1);
      numArray9[index10] = (byte) num20;
      int tokenFor1 = dynamicIlInfo.GetTokenFor(method1.MethodHandle);
      byte[] numArray10 = code;
      int index11 = num19;
      int num21 = index11 + 1;
      int num22 = (int) (byte) tokenFor1;
      numArray10[index11] = (byte) num22;
      byte[] numArray11 = code;
      int index12 = num21;
      int num23 = index12 + 1;
      int num24 = (int) (byte) (tokenFor1 >> 8);
      numArray11[index12] = (byte) num24;
      byte[] numArray12 = code;
      int index13 = num23;
      int num25 = index13 + 1;
      int num26 = (int) (byte) (tokenFor1 >> 16);
      numArray12[index13] = (byte) num26;
      byte[] numArray13 = code;
      int index14 = num25;
      int index15 = index14 + 1;
      int num27 = (int) (byte) (tokenFor1 >> 24);
      numArray13[index14] = (byte) num27;
      code[index15] = (byte) 42;
      dynamicIlInfo.SetCode(code, parameterTypes.Length + 1);
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldType));
    }
  }

  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  static extern int IocbHelper([In] int obj0);
}
