// Decompiled with JetBrains decompiler
// Type: flac.Format.SubframeLpc
// Assembly: STAThreadAttrib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6EE3DE1A-E148-4FBA-A193-65BEA1824C00
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f6a784c2aa30ddaf03919958455d18bf51533a475c21a73eff578df0174cc5d4.exe

using flac.Utils;

namespace flac.Format
{
  public class SubframeLpc : Subframe
  {
    private const int QLPC_PRECISION_BITS_COUNT = 4;
    private const int QLPC_PRECISION_SHIFT_COUNT = 5;
    private sbyte quantitizedLpcPrecisionInBitsMinusOne_;
    private sbyte quantitizedLpcShiftInBits_;
    private uint[] predictorCoefficients_;
    private Residual residual_;
    private int bitsPerSample_;
    private int lpcOrder_;

    private static int GetSignedInt(uint value, int bits)
    {
      Debug.Assert(bits < 32);
      int num = 32 - bits;
      return (int) value << num >> num;
    }

    public void Read(FlacStream stream, FrameHeader frameHeader, int order, int bitsPerSample)
    {
      this.bitsPerSample_ = bitsPerSample;
      this.lpcOrder_ = order;
      uint[] numArray = Warmup.ReadSamples(stream, order, this.bitsPerSample_);
      this.quantitizedLpcPrecisionInBitsMinusOne_ = stream.Reader.ReadBitsAsSByte(4);
      this.quantitizedLpcShiftInBits_ = stream.Reader.ReadBitsAsSByte(5);
      this.predictorCoefficients_ = new uint[order];
      for (int index = 0; index < this.predictorCoefficients_.Length; ++index)
        this.predictorCoefficients_[index] = stream.Reader.ReadBits((int) this.quantitizedLpcPrecisionInBitsMinusOne_ + 1);
      this.samples_ = new uint[frameHeader.BlockSize];
      int index1 = 0;
      foreach (uint num in numArray)
      {
        this.samples_[index1] = num;
        ++index1;
      }
      this.residual_ = new Residual();
      this.residual_.Read(stream, frameHeader.BlockSize, order, ref this.samples_);
    }

    public override void Write(FlacStream stream)
    {
      this.Write_(stream);
      this.residual_.Write(stream, ref this.samples_);
    }

    public override void Write(FlacStream stream, int count)
    {
      this.Write_(stream);
      this.residual_.Write(stream, count, ref this.samples_);
    }

    private void Write_(FlacStream stream)
    {
      base.Write(stream);
      Warmup.WriteSamples(stream, this.samples_, this.bitsPerSample_, this.lpcOrder_);
      stream.Writer.WriteBits((int) this.quantitizedLpcPrecisionInBitsMinusOne_, 4);
      stream.Writer.WriteBits((int) this.quantitizedLpcShiftInBits_, 5);
      foreach (uint predictorCoefficient in this.predictorCoefficients_)
        stream.Writer.WriteBits(predictorCoefficient, (int) this.quantitizedLpcPrecisionInBitsMinusOne_ + 1);
    }

    public void DecodeSamples()
    {
      uint[] samples1 = this.samples_;
      uint[] samples2 = new uint[this.samples_.Length];
      int i = 0;
      int length = samples1.Length;
      for (; i < this.lpcOrder_; ++i)
        samples2[i] = samples1[i];
      for (; i < length; ++i)
        samples2[i] = SubframeLpc.GetDecodedSample(ref samples1, ref samples2, this.lpcOrder_, ref this.predictorCoefficients_, (int) this.quantitizedLpcPrecisionInBitsMinusOne_ + 1, (int) this.quantitizedLpcShiftInBits_, i);
      this.samples_ = samples2;
    }

    private static uint GetDecodedSample(
      ref uint[] residuals,
      ref uint[] samples,
      int order,
      ref uint[] coeffs,
      int precision,
      int shift,
      int i)
    {
      int index = 0;
      int num1 = 0;
      for (; index < order; ++index)
      {
        int signedInt = SubframeLpc.GetSignedInt(coeffs[index], precision);
        num1 += signedInt * (int) samples[i - index - 1];
      }
      int num2 = SubframeLpc.GetSignedInt((uint) shift, 5) >= 0 ? num1 >> shift : num1 << shift;
      Debug.Assert(num2 <= int.MaxValue && num2 >= int.MinValue);
      return (uint) num2 + residuals[i];
    }

    public void EncodeSamples(int count)
    {
      uint[] samples = this.samples_;
      uint[] numArray = new uint[samples.Length];
      int i = 0;
      int num = count;
      for (; i < this.lpcOrder_; ++i)
        numArray[i] = samples[i];
      for (; i < num; ++i)
        numArray[i] = SubframeLpc.GetEncodedResidual(ref samples, this.lpcOrder_, ref this.predictorCoefficients_, (int) this.quantitizedLpcPrecisionInBitsMinusOne_ + 1, (int) this.quantitizedLpcShiftInBits_, i);
      this.samples_ = numArray;
    }

    private static uint GetEncodedResidual(
      ref uint[] samples,
      int order,
      ref uint[] coeffs,
      int precision,
      int shift,
      int i)
    {
      int index = 0;
      int num1 = 0;
      for (; index < order; ++index)
      {
        int signedInt = SubframeLpc.GetSignedInt(coeffs[index], precision);
        num1 += signedInt * (int) samples[i - index - 1];
      }
      int num2 = SubframeLpc.GetSignedInt((uint) shift, 5) >= 0 ? num1 >> shift : num1 << shift;
      Debug.Assert(num2 <= int.MaxValue && num2 >= int.MinValue);
      return samples[i] - (uint) num2;
    }
  }
}
