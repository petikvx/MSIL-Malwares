// Decompiled with JetBrains decompiler
// Type: ImageUtil
// Assembly: p的, Version=2.159.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E9517A17-41D2-4860-BC69-C7D574C89AF9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.01-msil\HEUR-Trojan-Ransom.MSIL.Makop.gen-9548c6a9da2d6cee9d27565c0055be4429cabfae9287ab3e525aaba66fd67032.exe

using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

public static class ImageUtil
{
  private const int bytesPerPixel = 4;

  public static Image Opacity(Image originalImage, double opacity)
  {
    if ((ImageUtil.\u206E‎‬‍‎‍⁮⁭‮⁭⁬‍‏​⁭‫‮‍‌​‌‌⁫⁬‬⁮‎‪‫‫​⁮⁪‪⁫⁬‎‌⁯‫‮(originalImage) & PixelFormat.Indexed) != PixelFormat.Indexed)
      goto label_9;
label_1:
    int num1 = -1199093407;
label_2:
    bool flag;
    int num2;
    int length;
    byte[] numArray;
    Image image;
    int num3;
    IntPtr num4;
    Bitmap bitmap;
    PixelFormat pixelFormat;
    Rectangle rectangle;
    BitmapData bitmapData;
    while (true)
    {
      uint num5;
      switch ((num5 = (uint) (num1 ^ -300603669)) % 27U)
      {
        case 0:
          int num6;
          num1 = num6 = num2 < numArray.Length ? -1494686477 : (num6 = -417300712);
          continue;
        case 1:
          num4 = ImageUtil.\u200F⁮⁯‭‭⁮⁬‏⁮⁭‎⁭‫⁯‍‮‏‌‭⁬‮‭‬‍‮‪‏‌‬‭‎‬‍⁫‪‏⁯⁬‏‍‮(bitmapData);
          length = ImageUtil.\u202B⁫‪‬⁮​‌‮‍‪‮⁬⁬‌​‮‍‍⁭⁪‎⁬⁪‬⁮⁬‮‭‪​⁪​‪⁪‍⁬‮‌‬‏‮((Image) bitmap) * ImageUtil.\u202D⁬⁫⁮⁭‪‌‌‌⁮‪⁭‫‮‏⁫⁫‏‬‫​‬⁪‮‬‬‌⁪‬‬⁯​‬⁬‬‏‌⁪⁪‫‮((Image) bitmap) * 4;
          num1 = (int) num5 * 794963479 ^ 814399901;
          continue;
        case 2:
          num1 = (int) num5 * -601450955 ^ 851526239;
          continue;
        case 3:
          pixelFormat = PixelFormat.Format32bppArgb;
          num1 = (int) num5 * -1424449830 ^ -1930210459;
          continue;
        case 4:
          num2 += 4;
          num1 = -768513671;
          continue;
        case 5:
          goto label_1;
        case 6:
          image = originalImage;
          num1 = (int) num5 * 202435264 ^ 130270132;
          continue;
        case 7:
          num1 = (int) num5 * 266637790 ^ -32053562;
          continue;
        case 8:
          ImageUtil.\u206C‮​‫⁯‮‬⁬⁫‬‬‎⁯⁪‪⁪‫⁯‬‎‮‭⁮‎‏⁬‭⁫⁮‪‫⁯‭⁮‮⁭⁭‌⁬⁮‮(bitmap, bitmapData);
          num1 = (int) num5 * -1366612626 ^ 337893311;
          continue;
        case 9:
          num1 = (int) num5 * -1300635038 ^ -1583521215;
          continue;
        case 10:
          goto label_9;
        case 11:
          numArray[num2 + num3] = (byte) ((double) numArray[num2 + num3] * opacity);
          num1 = (int) num5 * -520335899 ^ 1930980279;
          continue;
        case 12:
          num1 = (int) num5 * 135703046 ^ 591664000;
          continue;
        case 13:
          num1 = (int) num5 * 1311674098 ^ 883103100;
          continue;
        case 14:
          image = (Image) bitmap;
          num1 = (int) num5 * 1571633516 ^ 1957679154;
          continue;
        case 15:
          num1 = -1896499248;
          continue;
        case 16:
          ImageUtil.\u202A​‍‬‍⁯‭‫‮⁪‫⁬​⁭⁫‎‌⁮‌‭‏‎‎⁬⁭‮‬⁬‭‌‪‍‪‎‬⁭​‎‫‮(num4, numArray, 0, length);
          num1 = (int) num5 * 1557244990 ^ -693680973;
          continue;
        case 17:
          flag = numArray[num2 + 4 - 1] == (byte) 0;
          num1 = (int) num5 * 52868269 ^ 65632801;
          continue;
        case 18:
          ++num3;
          num1 = (int) num5 * -129048204 ^ 1814983105;
          continue;
        case 19:
          int num7 = !flag ? 1664496734 : (num7 = 625695095);
          num1 = num7 ^ (int) num5 * 2019817300;
          continue;
        case 20:
          numArray = new byte[length];
          num1 = (int) num5 * -1022655492 ^ -1020533408;
          continue;
        case 21:
          num3 = 0 + 1 + 1;
          num1 = -1128743210;
          continue;
        case 22:
          rectangle = new Rectangle(0, 0, ImageUtil.\u202B⁫‪‬⁮​‌‮‍‪‮⁬⁬‌​‮‍‍⁭⁪‎⁬⁪‬⁮⁬‮‭‪​⁪​‪⁪‍⁬‮‌‬‏‮((Image) bitmap), ImageUtil.\u202D⁬⁫⁮⁭‪‌‌‌⁮‪⁭‫‮‏⁫⁫‏‬‫​‬⁪‮‬‬‌⁪‬‬⁯​‬⁬‬‏‌⁪⁪‫‮((Image) bitmap));
          num1 = (int) num5 * -854819120 ^ -1375087596;
          continue;
        case 24:
          bitmapData = ImageUtil.\u206A‎‮‬⁪‮‍⁬​⁬‏⁬⁬‬‪‭⁫‌‫‮‍⁫⁯⁬​⁬⁬‎‮⁮‮⁭​⁫‭‮⁯⁬‌‪‮(bitmap, rectangle, ImageLockMode.ReadWrite, pixelFormat);
          num1 = (int) num5 * -562317571 ^ -1418981611;
          continue;
        case 25:
          ImageUtil.\u200B⁯‍​⁮⁭‎‍‮‌‍‭⁫‬‭⁪⁪⁫‬‏⁫‬⁭‪⁫⁯‍‪‬⁫⁮⁭​⁮​‮⁫⁪‬‮‮(numArray, 0, num4, length);
          num1 = (int) num5 * 346283951 ^ -164316676;
          continue;
        case 26:
          num2 = 0;
          num1 = (int) num5 * 815948308 ^ -2111681231;
          continue;
        default:
          goto label_28;
      }
    }
label_28:
    return image;
label_9:
    bitmap = (Bitmap) ImageUtil.\u202E⁬⁬⁫‫‎‮⁭‪‍‏‫‫⁬‭⁯‍‫⁬‮⁮‬⁭‭‫‎‮‌‏‏‪⁪⁫‫‬⁮‎​⁪⁮‮(originalImage);
    num1 = -570087733;
    goto label_2;
  }

  static PixelFormat \u206E‎‬‍‎‍⁮⁭‮⁭⁬‍‏​⁭‫‮‍‌​‌‌⁫⁬‬⁮‎‪‫‫​⁮⁪‪⁫⁬‎‌⁯‫‮([In] Image obj0) => obj0.PixelFormat;

  static object \u202E⁬⁬⁫‫‎‮⁭‪‍‏‫‫⁬‭⁯‍‫⁬‮⁮‬⁭‭‫‎‮‌‏‏‪⁪⁫‫‬⁮‎​⁪⁮‮([In] Image obj0) => obj0.Clone();

  static int \u202B⁫‪‬⁮​‌‮‍‪‮⁬⁬‌​‮‍‍⁭⁪‎⁬⁪‬⁮⁬‮‭‪​⁪​‪⁪‍⁬‮‌‬‏‮([In] Image obj0) => obj0.Width;

  static int \u202D⁬⁫⁮⁭‪‌‌‌⁮‪⁭‫‮‏⁫⁫‏‬‫​‬⁪‮‬‬‌⁪‬‬⁯​‬⁬‬‏‌⁪⁪‫‮([In] Image obj0) => obj0.Height;

  static BitmapData \u206A‎‮‬⁪‮‍⁬​⁬‏⁬⁬‬‪‭⁫‌‫‮‍⁫⁯⁬​⁬⁬‎‮⁮‮⁭​⁫‭‮⁯⁬‌‪‮(
    [In] Bitmap obj0,
    [In] Rectangle obj1,
    [In] ImageLockMode obj2,
    [In] PixelFormat obj3)
  {
    return obj0.LockBits(obj1, obj2, obj3);
  }

  static IntPtr \u200F⁮⁯‭‭⁮⁬‏⁮⁭‎⁭‫⁯‍‮‏‌‭⁬‮‭‬‍‮‪‏‌‬‭‎‬‍⁫‪‏⁯⁬‏‍‮([In] BitmapData obj0) => obj0.Scan0;

  static void \u202A​‍‬‍⁯‭‫‮⁪‫⁬​⁭⁫‎‌⁮‌‭‏‎‎⁬⁭‮‬⁬‭‌‪‍‪‎‬⁭​‎‫‮(
    [In] IntPtr obj0,
    [In] byte[] obj1,
    [In] int obj2,
    [In] int obj3)
  {
    Marshal.Copy(obj0, obj1, obj2, obj3);
  }

  static void \u200B⁯‍​⁮⁭‎‍‮‌‍‭⁫‬‭⁪⁪⁫‬‏⁫‬⁭‪⁫⁯‍‪‬⁫⁮⁭​⁮​‮⁫⁪‬‮‮(
    [In] byte[] obj0,
    [In] int obj1,
    [In] IntPtr obj2,
    [In] int obj3)
  {
    Marshal.Copy(obj0, obj1, obj2, obj3);
  }

  static void \u206C‮​‫⁯‮‬⁬⁫‬‬‎⁯⁪‪⁪‫⁯‬‎‮‭⁮‎‏⁬‭⁫⁮‪‫⁯‭⁮‮⁭⁭‌⁬⁮‮([In] Bitmap obj0, [In] BitmapData obj1) => obj0.UnlockBits(obj1);
}
