// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.DiskArchiveStorage
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;
using System.IO;

namespace ICSharpCode.SharpZipLib.Zip
{
  public class DiskArchiveStorage : BaseArchiveStorage
  {
    private Stream \uE002;
    private string \uE001;
    private string \uE000;

    public DiskArchiveStorage(ZipFile file, FileUpdateMode updateMode)
      : base(updateMode)
    {
      this.\uE001 = file.Name != null ? file.Name : throw new ZipException(\uE01B.\uE000("\uEFC9\uEFEB\uEFE4\uEFFE\uEFAA\uEFE2\uEFEB\uEFE4\uEFEE\uEFE6\uEFEF\uEFAA\uEFE4\uEFE5\uEFE4\uEFAA\uEFEC\uEFE3\uEFE6\uEFEF\uEFAA\uEFEB\uEFF8\uEFE9\uEFE2\uEFE3\uEFFC\uEFEF\uEFF9", 61322));
    }

    public DiskArchiveStorage(ZipFile file)
      : this(file, FileUpdateMode.Safe)
    {
    }

    public override Stream GetTemporaryOutput()
    {
      if (this.\uE000 != null)
      {
        this.\uE000 = DiskArchiveStorage.\uE000(this.\uE000, true);
        this.\uE002 = (Stream) File.OpenWrite(this.\uE000);
      }
      else
      {
        this.\uE000 = Path.GetTempFileName();
        this.\uE002 = (Stream) File.OpenWrite(this.\uE000);
      }
      return this.\uE002;
    }

    public override Stream ConvertTemporaryToFinal()
    {
      if (this.\uE002 == null)
        throw new ZipException(\uE01B.\uE000("\uEFD7\uEFF6\uEFB9\uEFED\uEFFC\uEFF4\uEFE9\uEFF6\uEFEB\uEFF8\uEFEB\uEFE0\uEFB9\uEFEA\uEFED\uEFEB\uEFFC\uEFF8\uEFF4\uEFB9\uEFF1\uEFF8\uEFEA\uEFB9\uEFFB\uEFFC\uEFFC\uEFF7\uEFB9\uEFFA\uEFEB\uEFFC\uEFF8\uEFED\uEFFC\uEFFD", 61337));
      Stream stream = (Stream) null;
      string str = DiskArchiveStorage.\uE000(this.\uE001, false);
      bool flag = false;
      try
      {
        this.\uE002.Close();
        File.Move(this.\uE001, str);
        File.Move(this.\uE000, this.\uE001);
        flag = true;
        File.Delete(str);
        return (Stream) File.OpenRead(this.\uE001);
      }
      catch (Exception ex)
      {
        stream = (Stream) null;
        if (!flag)
        {
          File.Move(str, this.\uE001);
          File.Delete(this.\uE000);
        }
        throw;
      }
    }

    public override Stream MakeTemporaryCopy(Stream stream)
    {
      stream.Close();
      this.\uE000 = DiskArchiveStorage.\uE000(this.\uE001, true);
      File.Copy(this.\uE001, this.\uE000, true);
      this.\uE002 = (Stream) new FileStream(this.\uE000, FileMode.Open, FileAccess.ReadWrite);
      return this.\uE002;
    }

    public override Stream OpenForDirectUpdate(Stream stream)
    {
      Stream stream1;
      if (stream == null || !stream.CanWrite)
      {
        stream?.Close();
        stream1 = (Stream) new FileStream(this.\uE001, FileMode.Open, FileAccess.ReadWrite);
      }
      else
        stream1 = stream;
      return stream1;
    }

    public override void Dispose()
    {
      if (this.\uE002 == null)
        return;
      this.\uE002.Close();
    }

    private static string \uE000(string _param0, bool _param1)
    {
      string str = (string) null;
      if (_param0 == null)
      {
        str = Path.GetTempFileName();
      }
      else
      {
        int num = 0;
        int second = DateTime.Now.Second;
        while (str == null)
        {
          num++;
          string path = string.Format(\uE01B.\uE000("\uF63A\uF671\uF63C\uF66F\uF63A\uF670\uF63C\uF63A\uF673\uF63C\uF66F\uF635\uF62C\uF631", 63041), (object) _param0, (object) second, (object) num);
          if (!File.Exists(path))
          {
            if (_param1)
            {
              try
              {
                using (File.Create(path))
                  ;
                str = path;
              }
              catch
              {
                second = DateTime.Now.Second;
              }
            }
            else
              str = path;
          }
        }
      }
      return str;
    }
  }
}
