// Decompiled with JetBrains decompiler
// Type: InterpreterVisitor
// Assembly: AuthorizationR, Version=1.0.0.6, Culture=neutral, PublicKeyToken=null
// MVID: 1A6D3D94-D71A-457A-A906-C73E898919CA
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.NanoBot.gen-8d4069f952ab15494c3be7c5cdf0fa161641dcc5fe3a1aab978726ea585f0076.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

public class InterpreterVisitor : Visitor
{
  private Hashtable mVariableMap;
  private Stack<int> mStack;
  private Stack<int[,]> matStack;

  public InterpreterVisitor()
  {
    this.mVariableMap = new Hashtable();
    this.mStack = new Stack<int>();
    this.matStack = new Stack<int[,]>();
  }

  public override void VisitVariableElement(VariableElement element)
  {
    if (!this.mVariableMap.ContainsKey((object) element.getText()))
      return;
    this.mStack.Push((int) this.mVariableMap[(object) element.getText()]);
  }

  public override void VisitIntegerElement(IntegerElement element) => this.mStack.Push(int.Parse(element.getText()));

  public override void VisitAssignmentOperationElement(AssignmentOperationElement element)
  {
    string text = element.getLhs().getText();
    this.VisitElement(element.getRhs());
    int num = this.mStack.Pop();
    this.mVariableMap[(object) text] = (object) num;
  }

  public override void VisitAdditionOperationElement(AdditionOperationElement element)
  {
    this.VisitElement(element.getLhs());
    this.VisitElement(element.getRhs());
    this.mStack.Push(this.mStack.Pop() + this.mStack.Pop());
  }

  public override void VisitMultiplicationOperationElement(MultiplicationOperationElement element)
  {
    this.VisitElement(element.getLhs());
    this.VisitElement(element.getRhs());
    this.mStack.Push(this.mStack.Pop() * this.mStack.Pop());
  }

  public override void VisitPrintOperationElement(PrintOperationElement element)
  {
    this.VisitElement(element.getChildElement());
    Console.WriteLine(this.mStack.Pop().ToString());
  }

  public override void VisitMatrixName(MatrixName element)
  {
    if (!this.mVariableMap.ContainsKey((object) element.getText()))
      return;
    this.matStack.Push((int[,]) this.mVariableMap[(object) element.getText()]);
  }

  public override void VisitMatrixData(MatrixData element)
  {
    string text = element.getText();
    int length1 = 0;
    int num1 = 0;
    for (int index = 1; index < text.LastIndexOf(']'); ++index)
    {
      if (text[index] == ',')
        ++num1;
      else if (text[index] != '[')
      {
        if (text[index] == ']')
          ++length1;
        else
          this.mStack.Push(int.Parse(text[index].ToString()));
      }
    }
    int length2 = num1 / length1 + 1;
    int[,] numArray = new int[length1, length2];
    for (int index1 = length1 - 1; index1 >= 0; --index1)
    {
      for (int index2 = length2 - 1; index2 >= 0; --index2)
      {
        int num2 = this.mStack.Pop();
        numArray[index1, index2] = num2;
      }
    }
    this.matStack.Push(numArray);
  }

  public override void VisitMatrixAssignmentOperationElement(
    MatrixAssignmentOperationElement element)
  {
    this.VisitElement(element.getRhs());
    this.mVariableMap[(object) element.getLhs().getText()] = (object) this.matStack.Pop();
  }

  public override void VisitMatrixAdditionOperationElement(MatrixAdditionOperationElement element)
  {
    this.VisitElement(element.getLhs());
    this.VisitElement(element.getRhs());
    Thread thread = new Thread(new ThreadStart(this.MatrixAddition));
    thread.Start();
    thread.Join();
  }

  public override void VisitMatrixMultiplicationOperationElement(
    MatrixMultiplicationOperationElement element)
  {
    this.VisitElement(element.getLhs());
    this.VisitElement(element.getRhs());
    Thread thread = new Thread(new ThreadStart(this.MatrixMultiplication));
    thread.Start();
    thread.Join();
  }

  public override void VisitPrintMatOperationElement(PrintMatOperationElement element)
  {
    int[,] mVariable = (int[,]) this.mVariableMap[(object) element.getText()];
    for (int index1 = 0; index1 < mVariable.GetLength(0); ++index1)
    {
      for (int index2 = 0; index2 < mVariable.GetLength(1); ++index2)
        Console.Write(mVariable[index1, index2].ToString() + " ");
      Console.WriteLine();
    }
  }

  private void MatrixMultiplication()
  {
    int[,] numArray1 = this.matStack.Pop();
    int[,] numArray2 = this.matStack.Pop();
    int[,] numArray3 = new int[numArray2.GetLength(0), numArray1.GetLength(1)];
    if (numArray2.GetLength(1) == numArray1.GetLength(0))
    {
      for (int index1 = 0; index1 < numArray2.GetLength(0); ++index1)
      {
        for (int index2 = 0; index2 < numArray1.GetLength(1); ++index2)
        {
          int num = 0;
          for (int index3 = 0; index3 < numArray2.GetLength(1); ++index3)
            num += numArray2[index1, index3] * numArray1[index3, index2];
          numArray3[index1, index2] = num;
        }
      }
    }
    else
      Console.Write("\nINVALID SIZE TO MULTIPLY\n");
    this.matStack.Push(numArray3);
  }

  private void MatrixAddition()
  {
    int[,] numArray1 = this.matStack.Pop();
    int[,] numArray2 = this.matStack.Pop();
    int[,] numArray3 = new int[numArray1.GetLength(0), numArray1.GetLength(1)];
    if (numArray2.GetLength(0) == numArray1.GetLength(0) && numArray2.GetLength(1) == numArray1.GetLength(1))
    {
      for (int index1 = 0; index1 < numArray1.GetLength(0); ++index1)
      {
        for (int index2 = 0; index2 < numArray1.GetLength(1); ++index2)
          numArray3[index1, index2] = numArray2[index1, index2] + numArray1[index1, index2];
      }
    }
    else
      Console.Write("\nINVALID SIZE TO ADD \n");
    this.matStack.Push(numArray3);
  }
}
