// Decompiled with JetBrains decompiler
// Type: SpatialController.DepthCorrection
// Assembly: Rea, Version=1.2.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 014AEBFB-7EE8-4B39-A7D6-AE7A18313427
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-fb4fb24a50b7f600c65d2bbc049f44337673fa7b0e6e16b6967c06d0cfb666ad.exe

using System;
using System.Collections.Generic;
using System.Windows.Media.Imaging;

namespace SpatialController
{
  public class DepthCorrection
  {
    public static unsafe void Fix(ref WriteableBitmap image, int XRes, int YRes)
    {
      image.Lock();
      for (int y = 0; y < YRes; ++y)
      {
        for (int counter = 0; counter < XRes; ++counter)
        {
          if (*DepthCorrection.GetPixel(image, counter, y) == (byte) 0)
          {
            int num = (int) DepthCorrection.FixPixel(image, counter, y, XRes, YRes, ref counter);
          }
        }
      }
      image.Unlock();
    }

    public static unsafe byte FixPixel(
      WriteableBitmap image,
      int x,
      int y,
      int XRes,
      int YRes,
      ref int counter)
    {
      List<byte> byteList = new List<byte>();
      byte* pixel = DepthCorrection.GetPixel(image, x, y);
      byte num1 = byte.MaxValue;
      if (x > 0 && x < XRes - 1 && y > 0 && y < YRes - 1)
      {
        byteList.Add(*DepthCorrection.GetPixel(image, x - 1, y - 1));
        byteList.Add(*DepthCorrection.GetPixel(image, x, y - 1));
        byteList.Add(*DepthCorrection.GetPixel(image, x + 1, y - 1));
        byteList.Add(*DepthCorrection.GetPixel(image, x - 1, y + 1));
        byteList.Add(*DepthCorrection.GetPixel(image, x, y + 1));
        byteList.Add(*DepthCorrection.GetPixel(image, x + 1, y + 1));
        byteList.Add(*DepthCorrection.GetPixel(image, x + 1, y));
      }
      foreach (byte num2 in byteList)
      {
        if ((int) num2 < (int) num1 && num2 > (byte) 0)
          num1 = num2;
      }
      if (x < XRes - 1 && *DepthCorrection.GetPixel(image, x + 1, y) == (byte) 0 && counter % 10 != 0)
      {
        byte num3 = DepthCorrection.FixPixel(image, x + 1, y, XRes, YRes, ref counter);
        if ((int) num3 < (int) num1)
          num1 = num3;
        ++counter;
      }
      *pixel = num1;
      pixel[1] = num1;
      pixel[2] = num1;
      return num1 == byte.MaxValue ? (byte) 0 : num1;
    }

    public static unsafe byte* GetPixel(WriteableBitmap image, int x, int y) => (byte*) ((IntPtr) image.BackBuffer.ToPointer() + y * image.BackBufferStride + x * 3);
  }
}
