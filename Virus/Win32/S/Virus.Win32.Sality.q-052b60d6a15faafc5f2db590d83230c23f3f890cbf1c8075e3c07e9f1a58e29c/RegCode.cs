// Decompiled with JetBrains decompiler
// Type: Microsoft.Tools.RegAsm.RegCode
// Assembly: RegAsm, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 097EDB82-DB75-4D42-81B4-3BEFAFAFEBC0
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Sality.q-052b60d6a15faafc5f2db590d83230c23f3f890cbf1c8075e3c07e9f1a58e29c.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Text;

namespace Microsoft.Tools.RegAsm
{
  [ComVisible(false)]
  internal static class RegCode
  {
    private const string strDocStringPrefix = "";
    private const string strManagedTypeThreadingModel = "Both";
    private const string strClassesRootRegKey = "HKEY_CLASSES_ROOT";
    private const string strMsCorEEFileName = "mscoree.dll";
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;
    internal static RegAsmOptions s_Options = (RegAsmOptions) null;
    internal static RegistrationServices s_RegistrationServices = new RegistrationServices();
    private static AssemblyResolver s_Resolver;

    internal static int Run(RegAsmOptions options)
    {
      RegCode.s_Options = options;
      Output.SetSilent(options.m_bSilentMode);
      int num = 0;
      try
      {
        bool flag = RegCode.s_Options.m_strRegFileName != null;
        if (flag)
          RegCode.s_Resolver = new AssemblyResolver(RegCode.s_Options.m_strAsmPath);
        Assembly assembly;
        try
        {
          assembly = !flag ? Assembly.LoadFrom(RegCode.s_Options.m_strAssemblyName) : Assembly.ReflectionOnlyLoadFrom(RegCode.s_Options.m_strAssemblyName);
        }
        catch (BadImageFormatException ex)
        {
          throw new ApplicationException(Resource.FormatString("Err_InvalidAssembly", (object) RegCode.s_Options.m_strAssemblyName), (Exception) ex);
        }
        catch (FileNotFoundException ex)
        {
          throw new ApplicationException(Resource.FormatString("Err_InputFileNotFound", (object) RegCode.s_Options.m_strAssemblyName), (Exception) ex);
        }
        if (RegCode.s_Options.m_strRegFileName != null)
        {
          if (string.Compare(RegCode.s_Options.m_strAssemblyName, RegCode.s_Options.m_strRegFileName, StringComparison.OrdinalIgnoreCase) == 0)
            throw new ApplicationException(Resource.FormatString("Err_RegFileWouldOverwriteInput"));
          if (RegCode.s_Options.m_bSetCodeBase && assembly.GetName().GetPublicKey().Length == 0)
            Output.WriteWarning(Resource.FormatString("Wrn_CodeBaseWithNoStrongName"));
          if (RegCode.GenerateRegFile(RegCode.s_Options.m_strRegFileName, assembly))
            Output.WriteInfo(Resource.FormatString("Msg_RegScriptGenerated", (object) RegCode.s_Options.m_strRegFileName));
          else
            Output.WriteWarning(Resource.FormatString("Wrn_NoRegScriptGenerated"));
        }
        else if (RegCode.s_Options.m_bRegister)
        {
          if (RegCode.s_Options.m_bSetCodeBase)
          {
            if (assembly.GetName().GetPublicKey().Length == 0)
              Output.WriteWarning(Resource.FormatString("Wrn_CodeBaseWithNoStrongName"));
          }
          try
          {
            AssemblyRegistrationFlags flags = RegCode.s_Options.m_bSetCodeBase ? AssemblyRegistrationFlags.SetCodeBase : AssemblyRegistrationFlags.None;
            if (RegCode.s_RegistrationServices.RegisterAssembly(assembly, flags))
              Output.WriteInfo(Resource.FormatString("Msg_TypesRegistered"));
            else if (!RegCode.s_Options.m_bTypeLibSpecified)
              Output.WriteWarning(Resource.FormatString("Wrn_NoTypesRegistered"));
          }
          catch (UnauthorizedAccessException ex)
          {
            throw new ApplicationException(Resource.FormatString("Err_CannotWriteToRegistry"), (Exception) ex);
          }
          if (RegCode.s_Options.m_strTypeLibName != null)
            RegCode.RegisterMainTypeLib(assembly);
        }
        else
        {
          if (RegCode.s_RegistrationServices.UnregisterAssembly(assembly))
            Output.WriteInfo(Resource.FormatString("Msg_TypesUnRegistered"));
          else
            Output.WriteWarning(Resource.FormatString("Wrn_NoTypesUnRegistered"));
          if (RegCode.s_Options.m_strTypeLibName != null)
          {
            if (RegCode.IsAssemblyImportedFromCom(assembly))
              Output.WriteWarning(Resource.FormatString("Wrn_ComTypelibNotUnregistered"));
            else
              RegCode.UnRegisterMainTypeLib();
          }
        }
      }
      catch (TargetInvocationException ex)
      {
        Output.WriteError(Resource.FormatString("Err_ErrorInUserDefFunc") + (object) ex.InnerException);
        num = 100;
      }
      catch (ReflectionTypeLoadException ex1)
      {
        Output.WriteError(Resource.FormatString("Err_TypeLoadExceptions"));
        Exception[] loaderExceptions = ex1.LoaderExceptions;
        for (int a1 = 0; a1 < loaderExceptions.Length; ++a1)
        {
          try
          {
            Output.WriteError(Resource.FormatString("Msg_DisplayException", (object) a1, (object) loaderExceptions[a1]));
          }
          catch (Exception ex2)
          {
            Output.WriteError(Resource.FormatString("Msg_DisplayNestedException", (object) a1, (object) ex2));
          }
        }
        num = 100;
      }
      catch (Exception ex)
      {
        Output.WriteError(ex);
        num = 100;
      }
      return num;
    }

    internal static ITypeLib DoExportAndRegister(Assembly asm, string strTypeLibName)
    {
      ITypeLibConverter typeLibConverter = (ITypeLibConverter) new TypeLibConverter();
      ExporterCallback notifySink = new ExporterCallback();
      ITypeLib typeLib = (ITypeLib) typeLibConverter.ConvertAssemblyToTypeLib(asm, strTypeLibName, RegCode.s_Options.m_Flags, (ITypeLibExporterNotifySink) notifySink);
      try
      {
        ((ICreateITypeLib) typeLib).SaveAllChanges();
      }
      catch (Exception ex)
      {
        RegCode.ThrowAppException(Resource.FormatString("Err_TypelibSaveFailed"), ex);
      }
      try
      {
        RegCode.RegisterTypeLib(typeLib, strTypeLibName, Path.GetDirectoryName(strTypeLibName));
      }
      catch (Exception ex)
      {
        RegCode.ThrowAppException(Resource.FormatString("Err_TypelibRegisterFailed"), ex);
      }
      return typeLib;
    }

    private static bool GenerateRegFile(string strRegFileName, Assembly asm)
    {
      Type[] registrableTypesInAssembly = RegCode.s_RegistrationServices.GetRegistrableTypesInAssembly(asm);
      int length = registrableTypesInAssembly.Length;
      IList<CustomAttributeData> customAttributes = CustomAttributeData.GetCustomAttributes(asm);
      int count = customAttributes.Count;
      bool flag = false;
      for (int index = 0; index < count; ++index)
      {
        if ((object) customAttributes[index].Constructor.DeclaringType == (object) typeof (PrimaryInteropAssemblyAttribute))
        {
          flag = true;
          break;
        }
      }
      if (length == 0 && !flag)
        return false;
      Stream stream = (Stream) File.Create(strRegFileName);
      RegCode.WriteUTFChars(stream, "REGEDIT4" + Environment.NewLine);
      string fullName = asm.FullName;
      string strAsmVersion = asm.GetName().Version.ToString();
      string imageRuntimeVersion = asm.ImageRuntimeVersion;
      string strAsmCodeBase = (string) null;
      if (RegCode.s_Options.m_bSetCodeBase)
      {
        strAsmCodeBase = asm.CodeBase;
        if (strAsmCodeBase == null)
          throw new ApplicationException(Resource.FormatString("Err_NoAsmCodeBase", (object) RegCode.s_Options.m_strAssemblyName));
      }
      for (int index = 0; index < length; ++index)
      {
        if (RegCode.IsRegisteredAsValueType(registrableTypesInAssembly[index]))
          RegCode.AddValueTypeToRegFile(registrableTypesInAssembly[index], fullName, strAsmVersion, strAsmCodeBase, imageRuntimeVersion, stream);
        else if (RegCode.s_RegistrationServices.TypeRepresentsComType(registrableTypesInAssembly[index]))
          RegCode.AddComImportedTypeToRegFile(registrableTypesInAssembly[index], fullName, strAsmVersion, strAsmCodeBase, imageRuntimeVersion, stream);
        else
          RegCode.AddManagedTypeToRegFile(registrableTypesInAssembly[index], fullName, strAsmVersion, strAsmCodeBase, imageRuntimeVersion, stream);
      }
      for (int index = 0; index < count; ++index)
      {
        if ((object) customAttributes[index].Constructor.DeclaringType == (object) typeof (PrimaryInteropAssemblyAttribute))
          RegCode.AddPrimaryInteropAssemblyToRegFile(Marshal.GetTypeLibGuidForAssembly(asm).ToString().ToUpper(CultureInfo.InvariantCulture), fullName, strAsmCodeBase, customAttributes[index], stream);
      }
      stream.Close();
      return true;
    }

    private static void AddValueTypeToRegFile(
      Type type,
      string strAsmName,
      string strAsmVersion,
      string strAsmCodeBase,
      string strRuntimeVersion,
      Stream regFile)
    {
      string str = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\Record\\" + str + "\\" + strAsmVersion + "]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
      if (strAsmCodeBase == null)
        return;
      RegCode.WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
    }

    private static void AddManagedTypeToRegFile(
      Type type,
      string strAsmName,
      string strAsmVersion,
      string strAsmCodeBase,
      string strRuntimeVersion,
      Stream regFile)
    {
      string str1 = "" + type.FullName;
      string str2 = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
      string progIdForType = RegCode.s_RegistrationServices.GetProgIdForType(type);
      if (progIdForType != string.Empty)
      {
        RegCode.WriteUTFChars(regFile, Environment.NewLine);
        RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\" + progIdForType + "]" + Environment.NewLine);
        RegCode.WriteUTFChars(regFile, "@=\"" + str1 + "\"" + Environment.NewLine);
        RegCode.WriteUTFChars(regFile, Environment.NewLine);
        RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\" + progIdForType + "\\CLSID]" + Environment.NewLine);
        RegCode.WriteUTFChars(regFile, "@=\"" + str2 + "\"" + Environment.NewLine);
      }
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str2 + "]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "@=\"" + str1 + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str2 + "\\InprocServer32]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "@=\"mscoree.dll\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"ThreadingModel\"=\"Both\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
      if (strAsmCodeBase != null)
        RegCode.WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str2 + "\\InprocServer32\\" + strAsmVersion + "]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
      if (strAsmCodeBase != null)
        RegCode.WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
      if (progIdForType != string.Empty)
      {
        RegCode.WriteUTFChars(regFile, Environment.NewLine);
        RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str2 + "\\ProgId]" + Environment.NewLine);
        RegCode.WriteUTFChars(regFile, "@=\"" + progIdForType + "\"" + Environment.NewLine);
      }
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str2 + "\\Implemented Categories\\{" + RegCode.s_RegistrationServices.GetManagedCategoryGuid().ToString().ToUpper(CultureInfo.InvariantCulture) + "}]" + Environment.NewLine);
    }

    private static void AddComImportedTypeToRegFile(
      Type type,
      string strAsmName,
      string strAsmVersion,
      string strAsmCodeBase,
      string strRuntimeVersion,
      Stream regFile)
    {
      string str = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str + "\\InprocServer32]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
      if (strAsmCodeBase != null)
        RegCode.WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\CLSID\\" + str + "\\InprocServer32\\" + strAsmVersion + "]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
      if (strAsmCodeBase == null)
        return;
      RegCode.WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
    }

    private static void AddPrimaryInteropAssemblyToRegFile(
      string strAsmGuid,
      string strAsmName,
      string strAsmCodeBase,
      CustomAttributeData attr,
      Stream regFile)
    {
      string str1 = "{" + strAsmGuid + "}";
      int num1 = (int) attr.ConstructorArguments[0].Value;
      int num2 = (int) attr.ConstructorArguments[1].Value;
      string str2 = num1.ToString("x", (IFormatProvider) CultureInfo.InvariantCulture) + "." + num2.ToString("x", (IFormatProvider) CultureInfo.InvariantCulture);
      RegCode.WriteUTFChars(regFile, Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "[HKEY_CLASSES_ROOT\\TypeLib\\" + str1 + "\\" + str2 + "]" + Environment.NewLine);
      RegCode.WriteUTFChars(regFile, "\"PrimaryInteropAssemblyName\"=\"" + strAsmName + "\"" + Environment.NewLine);
      if (strAsmCodeBase == null)
        return;
      RegCode.WriteUTFChars(regFile, "\"PrimaryInteropAssemblyCodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
    }

    private static void WriteUTFChars(Stream s, string value)
    {
      byte[] bytes = Encoding.UTF8.GetBytes(value);
      s.Write(bytes, 0, bytes.Length);
    }

    private static void RegisterMainTypeLib(Assembly asm)
    {
      ITypeLib TypeLib = (ITypeLib) null;
      if (RegCode.s_Options.m_strAssemblyName == RegCode.s_Options.m_strTypeLibName)
      {
        try
        {
          RegCode.LoadTypeLibEx(RegCode.s_Options.m_strTypeLibName, REGKIND.REGKIND_NONE, out TypeLib);
          if (TypeLib != null)
          {
            RegCode.RegisterTypeLib(TypeLib, RegCode.s_Options.m_strTypeLibName, Path.GetDirectoryName(RegCode.s_Options.m_strTypeLibName));
            Output.WriteInfo(Resource.FormatString("Msg_EmbeddedTypelibReg", (object) RegCode.s_Options.m_strTypeLibName));
          }
        }
        catch (Exception ex)
        {
        }
      }
      if (TypeLib != null)
        return;
      RegCode.DoExportAndRegister(asm, RegCode.s_Options.m_strTypeLibName);
      Output.WriteInfo(Resource.FormatString("Msg_AssemblyExportedAndReg", (object) RegCode.s_Options.m_strTypeLibName));
    }

    private static void UnRegisterMainTypeLib()
    {
      ITypeLib TypeLib = (ITypeLib) null;
      IntPtr ppTLibAttr = (IntPtr) 0;
      try
      {
        RegCode.LoadTypeLibEx(RegCode.s_Options.m_strTypeLibName, REGKIND.REGKIND_NONE, out TypeLib);
        TypeLib.GetLibAttr(out ppTLibAttr);
        System.Runtime.InteropServices.ComTypes.TYPELIBATTR structure = (System.Runtime.InteropServices.ComTypes.TYPELIBATTR) Marshal.PtrToStructure(ppTLibAttr, typeof (System.Runtime.InteropServices.ComTypes.TYPELIBATTR));
        RegCode.UnRegisterTypeLib(ref structure.guid, structure.wMajorVerNum, structure.wMinorVerNum, structure.lcid, structure.syskind);
      }
      catch (COMException ex)
      {
        if (ex.ErrorCode != -2147319780)
          RegCode.ThrowAppException(Resource.FormatString("Err_UnregistrationFailed"), (Exception) ex);
      }
      catch (Exception ex)
      {
        RegCode.ThrowAppException(Resource.FormatString("Err_UnregistrationFailed"), ex);
      }
      finally
      {
        if (ppTLibAttr != (IntPtr) 0)
          TypeLib.ReleaseTLibAttr(ppTLibAttr);
      }
      Output.WriteInfo(Resource.FormatString("Msg_TypelibUnregistered", (object) RegCode.s_Options.m_strTypeLibName));
    }

    private static bool IsAssemblyImportedFromCom(Assembly asm)
    {
      IList<CustomAttributeData> customAttributes = CustomAttributeData.GetCustomAttributes(asm);
      for (int index = 0; index < customAttributes.Count; ++index)
      {
        if ((object) customAttributes[index].Constructor.DeclaringType == (object) typeof (ImportedFromTypeLibAttribute))
          return true;
      }
      return false;
    }

    private static bool IsRegisteredAsValueType(Type type) => type.IsValueType;

    private static void ThrowAppException(string strPrefix, Exception e)
    {
      if (strPrefix == null)
        strPrefix = "";
      if (e.Message != null)
        throw new ApplicationException(strPrefix + e.Message);
      throw new ApplicationException(strPrefix + e.GetType().ToString());
    }

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void LoadTypeLibEx(
      string strTypeLibName,
      REGKIND regKind,
      out ITypeLib TypeLib);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void RegisterTypeLib(
      ITypeLib TypeLib,
      string szFullPath,
      string szHelpDirs);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void UnRegisterTypeLib(
      ref Guid libID,
      short wVerMajor,
      short wVerMinor,
      int lcid,
      System.Runtime.InteropServices.ComTypes.SYSKIND syskind);
  }
}
