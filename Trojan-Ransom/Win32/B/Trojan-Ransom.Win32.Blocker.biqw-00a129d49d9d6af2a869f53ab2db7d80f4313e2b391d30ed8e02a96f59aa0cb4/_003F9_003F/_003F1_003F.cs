// Decompiled with JetBrains decompiler
// Type: ?9?.?1?
// Assembly: wLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 601E9F23-A239-4CA4-BCF6-5BB65F85A0DA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.biqw-00a129d49d9d6af2a869f53ab2db7d80f4313e2b391d30ed8e02a96f59aa0cb4.exe

using \u003F9\u003F;
using System;

namespace \u003F9\u003F
{
  internal sealed class \u003F1\u003F
  {
    public static readonly uint[] \u003F1\u003F = new uint[256];
    private uint \u003F2\u003F = uint.MaxValue;

    static \u003F1\u003F()
    {
label_1:
      uint index = 0;
      while (true)
      {
        if (true)
        {
          if (index < 256U)
          {
            uint num1 = index;
            if (false)
              goto label_8;
            else
              goto label_12;
label_3:
            int num2;
            if (num2 < 8)
              goto label_8;
label_4:
            \u003F1\u003F.\u003F1\u003F[(IntPtr) index] = num1;
            int num3 = (int) index + 1;
label_5:
            index = (uint) num3;
            continue;
label_8:
            num3 = (int) num1 & 1;
            if (true)
            {
              if (num3 == 0)
                goto label_11;
              else
                goto label_9;
label_2:
              ++num2;
              goto label_3;
label_9:
              int num4 = (int) (num1 >> 1) ^ -306674912;
label_10:
              num1 = (uint) num4;
              goto label_2;
label_11:
              num4 = (int) num1;
              if (true)
              {
                num1 = (uint) num4 >> 1;
                goto label_2;
              }
              else
                goto label_10;
            }
            else
              goto label_5;
label_12:
            if (true)
            {
              num2 = 0;
              goto label_3;
            }
            else
              goto label_4;
          }
          else
            break;
        }
        else
          goto label_1;
      }
    }

    public void \u003F1\u003F() => this.\u003F2\u003F = uint.MaxValue;

    public void \u003F1\u003F(byte _param1) => this.\u003F2\u003F = \u003F1\u003F.\u003F1\u003F[(int) (byte) this.\u003F2\u003F ^ (int) _param1] ^ this.\u003F2\u003F >> 8;

    public void \u003F1\u003F(byte[] _param1, uint _param2, uint _param3)
    {
      for (uint index = 0; index < _param3; ++index)
      {
        this.\u003F2\u003F = \u003F1\u003F.\u003F1\u003F[(int) (byte) this.\u003F2\u003F ^ (int) _param1[(IntPtr) (_param2 + index)]] ^ this.\u003F2\u003F >> 8;
        if (false)
          break;
      }
    }

    public uint \u003F1\u003F() => this.\u003F2\u003F ^ uint.MaxValue;

    private static uint \u003F1\u003F(byte[] _param0, uint _param1, uint _param2)
    {
      \u003F1\u003F obj = new \u003F1\u003F();
      obj.\u003F1\u003F(_param0, _param1, _param2);
      return obj.\u003F1\u003F();
    }

    private static bool \u003F1\u003F(uint _param0, byte[] _param1, uint _param2, uint _param3) => (int) \u003F1\u003F.\u003F1\u003F(_param1, _param2, _param3) == (int) _param0;
  }
}
