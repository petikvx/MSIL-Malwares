// Decompiled with JetBrains decompiler
// Type: 73J.8H2
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0034Y6;
using \u0036b3;
using \u00373J;
using Q8f;
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using X5s;

namespace \u00373J
{
  internal sealed class \u0038H2
  {
    private int \u003841;
    private int Lar = -1;
    private int pHN;
    private int b83;
    private int nv1;
    private \u0038H2.\u0035a6 \u0036f2;
    private readonly ov2 \u0034U1 = new ov2(true);
    private p59 Z5P;
    private int t25;
    private int \u003922;
    private int S18;
    private bool s96;
    private bool J21;
    private int \u00382a;
    private int d7p;
    private int \u0038xM;
    private static readonly int \u00376n = 2097152;
    private static readonly int f21 = ~\u0038H2.\u00376n;
    private static readonly byte \u003918 = 15;
    private static readonly byte \u0034eT = 0;
    private static readonly int \u003186 = 20;
    private static readonly int \u00354f = 10;
    private static readonly int \u00349C = 30;
    private static readonly int[] f8O = new int[14]
    {
      1,
      4,
      13,
      40,
      121,
      364,
      1093,
      3280,
      9841,
      29524,
      88573,
      265720,
      797161,
      2391484
    };
    private uint \u0036i1;

    public \u0038H2([In] p59 obj0, [In] int obj1)
    {
      this.\u003841 = obj1;
      this.Z5P = obj0;
      this.nv1 = obj1 * ky4.\u003359 - 20;
      this.\u0036f2 = new \u0038H2.\u0035a6(obj1);
      this.f5l();
    }

    private void f5l()
    {
      this.\u0034U1.Y63();
      this.Lar = -1;
      this.pHN = 0;
      this.b83 = -1;
      int index = 256;
      while (--index >= 0)
        this.\u0036f2.\u0037Pn[index] = false;
    }

    [SpecialName]
    public uint ceY() => this.\u0036i1;

    [SpecialName]
    private void \u0038p7([In] uint obj0) => this.\u0036i1 = obj0;

    public int fkB([In] byte[] obj0, [In] int obj1, [In] int obj2)
    {
      if (this.b83 >= this.nv1)
        return 0;
      int num1 = 0;
      int num2 = obj1 + obj2;
      int num3;
      do
      {
        num3 = this.\u00345z(obj0[obj1++]);
        if (num3 > 0)
          ++num1;
      }
      while (obj1 < num2 && num3 == 1);
      return num1;
    }

    private int \u00345z([In] byte obj0)
    {
      if (this.Lar == -1)
      {
        this.Lar = (int) obj0;
        ++this.pHN;
        return 1;
      }
      if (this.Lar == (int) obj0)
      {
        if (++this.pHN <= 254)
          return 1;
        int num = this.X17(false) ? 1 : 0;
        this.Lar = -1;
        this.pHN = 0;
        return num == 0 ? 1 : 2;
      }
      if (this.X17(false))
      {
        this.Lar = -1;
        this.pHN = 0;
        return 0;
      }
      this.pHN = 1;
      this.Lar = (int) obj0;
      return 1;
    }

    private bool X17([In] bool obj0)
    {
      ++this.t25;
      int b83 = this.b83;
      if (b83 >= this.nv1 && !obj0)
        throw new Exception(string.Format("block overrun(final={2}): {0} >= threshold ({1})", (object) b83, (object) this.nv1, (object) obj0));
      byte lar = (byte) this.Lar;
      byte[] numArray = this.\u0036f2.\u0032JD;
      this.\u0036f2.\u0037Pn[(int) lar] = true;
      int pHn = this.pHN;
      this.\u0034U1.ppg(lar, pHn);
      switch (pHn)
      {
        case 1:
          numArray[b83 + 2] = lar;
          this.b83 = b83 + 1;
          break;
        case 2:
          numArray[b83 + 2] = lar;
          numArray[b83 + 3] = lar;
          this.b83 = b83 + 2;
          break;
        case 3:
          numArray[b83 + 2] = lar;
          numArray[b83 + 3] = lar;
          numArray[b83 + 4] = lar;
          this.b83 = b83 + 3;
          break;
        default:
          int index = pHn - 4;
          this.\u0036f2.\u0037Pn[index] = true;
          numArray[b83 + 2] = lar;
          numArray[b83 + 3] = lar;
          numArray[b83 + 4] = lar;
          numArray[b83 + 5] = lar;
          numArray[b83 + 6] = (byte) index;
          this.b83 = b83 + 5;
          break;
      }
      return this.b83 >= this.nv1;
    }

    public void GFk()
    {
      if (this.pHN > 0)
        this.X17(true);
      this.Lar = -1;
      if (this.b83 == -1)
        return;
      this.V57();
      this.Z5P.\u003411((byte) 49);
      this.Z5P.\u003411((byte) 65);
      this.Z5P.\u003411((byte) 89);
      this.Z5P.\u003411((byte) 38);
      this.Z5P.\u003411((byte) 83);
      this.Z5P.\u003411((byte) 89);
      this.\u0038p7((uint) this.\u0034U1.\u0033D4);
      this.Z5P.V67(this.ceY());
      this.Z5P.SH2(1, this.J21 ? 1U : 0U);
      this.uJ6();
      this.f5l();
    }

    private void \u00318U()
    {
      bool[] flagArray = this.\u0036f2.\u0037Pn;
      byte[] numArray = this.\u0036f2.\u0032JD;
      int b83 = this.b83;
      int index1 = 256;
      while (--index1 >= 0)
        flagArray[index1] = false;
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int index2 = 1;
      while (num3 <= b83)
      {
        if (num1 == 0)
        {
          num1 = (int) (ushort) U1A.w5U(num2);
          if (++num2 == 512)
            num2 = 0;
        }
        --num1;
        numArray[index2] ^= num1 == 1 ? (byte) 1 : (byte) 0;
        flagArray[(int) numArray[index2] & (int) byte.MaxValue] = true;
        num3 = index2;
        ++index2;
      }
      this.J21 = true;
    }

    private void QqN()
    {
      \u0038H2.\u0035a6 obj = this.\u0036f2;
      int[] numArray1 = obj.\u0031Ep;
      int[] numArray2 = obj.\u0032V4;
      bool[] n6Z = obj.N6Z;
      int[] f6Z = obj.f6Z;
      byte[] numArray3 = obj.\u0032JD;
      int[] numArray4 = obj.\u0031I6;
      char[] chArray = obj.\u003631;
      int b83 = this.b83;
      int s18 = this.S18;
      bool s96 = this.s96;
      int index1 = 65537;
      while (--index1 >= 0)
        f6Z[index1] = 0;
      for (int index2 = 0; index2 < ky4.\u0038eD; ++index2)
        numArray3[b83 + index2 + 2] = numArray3[index2 % (b83 + 1) + 1];
      int index3 = b83 + ky4.\u0038eD + 1;
      while (--index3 >= 0)
        chArray[index3] = char.MinValue;
      numArray3[0] = numArray3[b83 + 1];
      int num1 = (int) numArray3[0] & (int) byte.MaxValue;
      for (int index4 = 0; index4 <= b83; ++index4)
      {
        int num2 = (int) numArray3[index4 + 1] & (int) byte.MaxValue;
        ++f6Z[(num1 << 8) + num2];
        num1 = num2;
      }
      for (int index5 = 1; index5 <= 65536; ++index5)
        f6Z[index5] += f6Z[index5 - 1];
      int num3 = (int) numArray3[1] & (int) byte.MaxValue;
      for (int index6 = 0; index6 < b83; ++index6)
      {
        int num4 = (int) numArray3[index6 + 2] & (int) byte.MaxValue;
        numArray4[--f6Z[(num3 << 8) + num4]] = index6;
        num3 = num4;
      }
      numArray4[--f6Z[(((int) numArray3[b83 + 1] & (int) byte.MaxValue) << 8) + ((int) numArray3[1] & (int) byte.MaxValue)]] = b83;
      int index7 = 256;
      while (--index7 >= 0)
      {
        n6Z[index7] = false;
        numArray1[index7] = index7;
      }
      int num5 = 364;
      while (num5 != 1)
      {
        num5 /= 3;
        for (int index8 = num5; index8 <= (int) byte.MaxValue; ++index8)
        {
          int num6 = numArray1[index8];
          int num7 = f6Z[num6 + 1 << 8] - f6Z[num6 << 8];
          int num8 = num5 - 1;
          int index9 = index8;
          for (int index10 = numArray1[index9 - num5]; f6Z[index10 + 1 << 8] - f6Z[index10 << 8] > num7; index10 = numArray1[index9 - num5])
          {
            numArray1[index9] = index10;
            index9 -= num5;
            if (index9 <= num8)
              break;
          }
          numArray1[index9] = num6;
        }
      }
      for (int index11 = 0; index11 <= (int) byte.MaxValue; ++index11)
      {
        int index12 = numArray1[index11];
        for (int index13 = 0; index13 <= (int) byte.MaxValue; ++index13)
        {
          int index14 = (index12 << 8) + index13;
          int num9 = f6Z[index14];
          if ((num9 & \u0038H2.\u00376n) != \u0038H2.\u00376n)
          {
            int num10 = num9 & \u0038H2.f21;
            int num11 = (f6Z[index14 + 1] & \u0038H2.f21) - 1;
            if (num11 > num10)
            {
              this.\u00348Z(obj, num10, num11, 2);
              if (s96 && this.\u003922 > s18)
                return;
            }
            f6Z[index14] = num9 | \u0038H2.\u00376n;
          }
        }
        for (int index15 = 0; index15 <= (int) byte.MaxValue; ++index15)
          numArray2[index15] = f6Z[(index15 << 8) + index12] & \u0038H2.f21;
        int index16 = f6Z[index12 << 8] & \u0038H2.f21;
        for (int index17 = f6Z[index12 + 1 << 8] & \u0038H2.f21; index16 < index17; ++index16)
        {
          int index18 = numArray4[index16];
          int index19 = (int) numArray3[index18] & (int) byte.MaxValue;
          if (!n6Z[index19])
          {
            numArray4[numArray2[index19]] = index18 == 0 ? b83 : index18 - 1;
            ++numArray2[index19];
          }
        }
        int num12 = 256;
        while (--num12 >= 0)
          f6Z[(num12 << 8) + index12] |= \u0038H2.\u00376n;
        n6Z[index12] = true;
        if (index11 < (int) byte.MaxValue)
        {
          int num13 = f6Z[index12 << 8] & \u0038H2.f21;
          int num14 = (f6Z[index12 + 1 << 8] & \u0038H2.f21) - num13;
          int num15 = 0;
          while (num14 >> num15 > 65534)
            ++num15;
          for (int index20 = 0; index20 < num14; ++index20)
          {
            int index21 = numArray4[num13 + index20];
            char ch = (char) (index20 >> num15);
            chArray[index21] = ch;
            if (index21 < ky4.\u0038eD)
              chArray[index21 + b83 + 1] = ch;
          }
        }
      }
    }

    private void V57()
    {
      this.S18 = \u0038H2.\u00349C * this.b83;
      this.\u003922 = 0;
      this.J21 = false;
      this.s96 = true;
      this.QqN();
      if (this.s96 && this.\u003922 > this.S18)
      {
        this.\u00318U();
        this.S18 = this.\u003922 = 0;
        this.s96 = false;
        this.QqN();
      }
      int[] numArray = this.\u0036f2.\u0031I6;
      this.\u00382a = -1;
      int index = 0;
      for (int b83 = this.b83; index <= b83; ++index)
      {
        if (numArray[index] == 0)
        {
          this.\u00382a = index;
          break;
        }
      }
    }

    private bool \u003647([In] \u0038H2.\u0035a6 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      int num1 = obj2 - obj1 + 1;
      if (num1 < 2)
        return this.s96 && this.\u003922 > this.S18;
      int index1 = 0;
      while (\u0038H2.f8O[index1] < num1)
        ++index1;
      int[] numArray1 = obj0.\u0031I6;
      char[] chArray = obj0.\u003631;
      byte[] numArray2 = obj0.\u0032JD;
      int b83 = this.b83;
      int num2 = b83 + 1;
      bool s96 = this.s96;
      int s18 = this.S18;
      int num3 = this.\u003922;
      while (--index1 >= 0)
      {
        int num4 = \u0038H2.f8O[index1];
        int num5 = obj1 + num4 - 1;
        int index2 = obj1 + num4;
        while (index2 <= obj2)
        {
          for (int index3 = 3; index2 <= obj2 && --index3 >= 0; ++index2)
          {
            int num6 = numArray1[index2];
            int num7 = num6 + obj3;
            int index4 = index2;
            bool flag = false;
            int num8 = 0;
label_11:
            int num9;
            int num10;
            do
            {
              if (flag)
              {
                numArray1[index4] = num8;
                if ((index4 -= num4) <= num5)
                  break;
              }
              else
                flag = true;
              num8 = numArray1[index4 - num4];
              num9 = num8 + obj3;
              num10 = num7;
              if ((int) numArray2[num9 + 1] == (int) numArray2[num10 + 1])
              {
                if ((int) numArray2[num9 + 2] == (int) numArray2[num10 + 2])
                {
                  if ((int) numArray2[num9 + 3] == (int) numArray2[num10 + 3])
                  {
                    if ((int) numArray2[num9 + 4] == (int) numArray2[num10 + 4])
                    {
                      if ((int) numArray2[num9 + 5] == (int) numArray2[num10 + 5])
                      {
                        int index5;
                        int index6;
                        if ((int) numArray2[index5 = num9 + 6] == (int) numArray2[index6 = num10 + 6])
                        {
                          int num11 = b83;
                          while (num11 > 0)
                          {
                            num11 -= 4;
                            if ((int) numArray2[index5 + 1] == (int) numArray2[index6 + 1])
                            {
                              if ((int) chArray[index5] == (int) chArray[index6])
                              {
                                if ((int) numArray2[index5 + 2] == (int) numArray2[index6 + 2])
                                {
                                  if ((int) chArray[index5 + 1] == (int) chArray[index6 + 1])
                                  {
                                    if ((int) numArray2[index5 + 3] == (int) numArray2[index6 + 3])
                                    {
                                      if ((int) chArray[index5 + 2] == (int) chArray[index6 + 2])
                                      {
                                        if ((int) numArray2[index5 + 4] == (int) numArray2[index6 + 4])
                                        {
                                          if ((int) chArray[index5 + 3] == (int) chArray[index6 + 3])
                                          {
                                            if ((index5 += 4) >= num2)
                                              index5 -= num2;
                                            if ((index6 += 4) >= num2)
                                              index6 -= num2;
                                            ++num3;
                                          }
                                          else
                                          {
                                            if ((int) chArray[index5 + 3] <= (int) chArray[index6 + 3])
                                              break;
                                            goto label_11;
                                          }
                                        }
                                        else
                                        {
                                          if (((int) numArray2[index5 + 4] & (int) byte.MaxValue) <= ((int) numArray2[index6 + 4] & (int) byte.MaxValue))
                                            break;
                                          goto label_11;
                                        }
                                      }
                                      else
                                      {
                                        if ((int) chArray[index5 + 2] <= (int) chArray[index6 + 2])
                                          break;
                                        goto label_11;
                                      }
                                    }
                                    else
                                    {
                                      if (((int) numArray2[index5 + 3] & (int) byte.MaxValue) <= ((int) numArray2[index6 + 3] & (int) byte.MaxValue))
                                        break;
                                      goto label_11;
                                    }
                                  }
                                  else
                                  {
                                    if ((int) chArray[index5 + 1] <= (int) chArray[index6 + 1])
                                      break;
                                    goto label_11;
                                  }
                                }
                                else
                                {
                                  if (((int) numArray2[index5 + 2] & (int) byte.MaxValue) <= ((int) numArray2[index6 + 2] & (int) byte.MaxValue))
                                    break;
                                  goto label_11;
                                }
                              }
                              else
                              {
                                if ((int) chArray[index5] <= (int) chArray[index6])
                                  break;
                                goto label_11;
                              }
                            }
                            else
                            {
                              if (((int) numArray2[index5 + 1] & (int) byte.MaxValue) <= ((int) numArray2[index6 + 1] & (int) byte.MaxValue))
                                break;
                              goto label_11;
                            }
                          }
                          break;
                        }
                        if (((int) numArray2[index5] & (int) byte.MaxValue) <= ((int) numArray2[index6] & (int) byte.MaxValue))
                          break;
                      }
                      else if (((int) numArray2[num9 + 5] & (int) byte.MaxValue) <= ((int) numArray2[num10 + 5] & (int) byte.MaxValue))
                        break;
                    }
                    else if (((int) numArray2[num9 + 4] & (int) byte.MaxValue) <= ((int) numArray2[num10 + 4] & (int) byte.MaxValue))
                      break;
                  }
                  else if (((int) numArray2[num9 + 3] & (int) byte.MaxValue) <= ((int) numArray2[num10 + 3] & (int) byte.MaxValue))
                    break;
                }
                else if (((int) numArray2[num9 + 2] & (int) byte.MaxValue) <= ((int) numArray2[num10 + 2] & (int) byte.MaxValue))
                  break;
              }
            }
            while (((int) numArray2[num9 + 1] & (int) byte.MaxValue) > ((int) numArray2[num10 + 1] & (int) byte.MaxValue));
            numArray1[index4] = num6;
          }
          if (s96 && index2 <= obj2 && num3 > s18)
            goto label_54;
        }
      }
label_54:
      this.\u003922 = num3;
      return s96 && num3 > s18;
    }

    private static void \u00361M([In] int[] obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      obj3 += obj1;
      while (obj1 < obj3)
      {
        int num = obj0[obj1];
        obj0[obj1++] = obj0[obj2];
        obj0[obj2++] = num;
      }
    }

    private static byte e47([In] byte obj0, [In] byte obj1, [In] byte obj2)
    {
      if ((int) obj0 >= (int) obj1)
      {
        if ((int) obj1 > (int) obj2)
          return obj1;
        return (int) obj0 <= (int) obj2 ? obj0 : obj2;
      }
      if ((int) obj1 < (int) obj2)
        return obj1;
      return (int) obj0 >= (int) obj2 ? obj0 : obj2;
    }

    private void \u00348Z([In] \u0038H2.\u0035a6 obj0, [In] int obj1, [In] int obj2, [In] int obj3)
    {
      int[] numArray1 = obj0.\u003841;
      int[] numArray2 = obj0.\u00342q;
      int[] numArray3 = obj0.\u00355Y;
      int[] numArray4 = obj0.\u0031I6;
      byte[] numArray5 = obj0.\u0032JD;
      numArray1[0] = obj1;
      numArray2[0] = obj2;
      numArray3[0] = obj3;
      int index1 = 1;
      while (--index1 >= 0)
      {
        int index2 = numArray1[index1];
        int index3 = numArray2[index1];
        int num1 = numArray3[index1];
        if (index3 - index2 < \u0038H2.\u003186 || num1 > \u0038H2.\u00354f)
        {
          if (this.\u003647(obj0, index2, index3, num1))
            break;
        }
        else
        {
          int num2 = num1 + 1;
          int num3 = (int) \u0038H2.e47(numArray5[numArray4[index2] + num2], numArray5[numArray4[index3] + num2], numArray5[numArray4[index2 + index3 >> 1] + num2]) & (int) byte.MaxValue;
          int index4 = index2;
          int index5 = index3;
          int index6 = index2;
          int index7 = index3;
          while (true)
          {
            while (index4 <= index5)
            {
              int num4 = ((int) numArray5[numArray4[index4] + num2] & (int) byte.MaxValue) - num3;
              if (num4 == 0)
              {
                int num5 = numArray4[index4];
                numArray4[index4++] = numArray4[index6];
                numArray4[index6++] = num5;
              }
              else if (num4 < 0)
                ++index4;
              else
                break;
            }
            while (index4 <= index5)
            {
              int num6 = ((int) numArray5[numArray4[index5] + num2] & (int) byte.MaxValue) - num3;
              if (num6 == 0)
              {
                int num7 = numArray4[index5];
                numArray4[index5--] = numArray4[index7];
                numArray4[index7--] = num7;
              }
              else if (num6 > 0)
                --index5;
              else
                break;
            }
            if (index4 <= index5)
            {
              int num8 = numArray4[index4];
              numArray4[index4++] = numArray4[index5];
              numArray4[index5--] = num8;
            }
            else
              break;
          }
          if (index7 < index6)
          {
            numArray1[index1] = index2;
            numArray2[index1] = index3;
            numArray3[index1] = num2;
            ++index1;
          }
          else
          {
            int num9 = index6 - index2 < index4 - index6 ? index6 - index2 : index4 - index6;
            \u0038H2.\u00361M(numArray4, index2, index4 - num9, num9);
            int num10 = index3 - index7 < index7 - index5 ? index3 - index7 : index7 - index5;
            \u0038H2.\u00361M(numArray4, index4, index3 - num10 + 1, num10);
            int num11 = index2 + index4 - index6 - 1;
            int num12 = index3 - (index7 - index5) + 1;
            numArray1[index1] = index2;
            numArray2[index1] = num11;
            numArray3[index1] = num1;
            int index8 = index1 + 1;
            numArray1[index8] = num11 + 1;
            numArray2[index8] = num12 - 1;
            numArray3[index8] = num2;
            int index9 = index8 + 1;
            numArray1[index9] = num12;
            numArray2[index9] = index3;
            numArray3[index9] = num1;
            index1 = index9 + 1;
          }
        }
      }
    }

    private void \u003743()
    {
      int b83 = this.b83;
      \u0038H2.\u0035a6 obj = this.\u0036f2;
      bool[] flagArray = obj.\u0037Pn;
      byte[] numArray1 = obj.\u0032JD;
      int[] numArray2 = obj.\u0031I6;
      char[] chArray = obj.\u00374j;
      int[] numArray3 = obj.\u00357q;
      byte[] numArray4 = obj.\u0036l5;
      byte[] wbP = obj.wbP;
      int num1 = 0;
      for (int index = 0; index < 256; ++index)
      {
        if (flagArray[index])
        {
          numArray4[index] = (byte) num1;
          ++num1;
        }
      }
      this.d7p = num1;
      int index1 = num1 + 1;
      for (int index2 = index1; index2 >= 0; --index2)
        numArray3[index2] = 0;
      int index3 = num1;
      while (--index3 >= 0)
        wbP[index3] = (byte) index3;
      int index4 = 0;
      int num2 = 0;
      for (int index5 = 0; index5 <= b83; ++index5)
      {
        byte num3 = numArray4[(int) numArray1[numArray2[index5]] & (int) byte.MaxValue];
        byte num4 = wbP[0];
        int index6 = 0;
        while ((int) num3 != (int) num4)
        {
          ++index6;
          byte num5 = num4;
          num4 = wbP[index6];
          wbP[index6] = num5;
        }
        wbP[0] = num4;
        if (index6 == 0)
        {
          ++num2;
        }
        else
        {
          if (num2 > 0)
          {
            int num6 = num2 - 1;
            while (true)
            {
              if ((num6 & 1) == 0)
              {
                chArray[index4] = ky4.\u0033S8;
                ++index4;
                ++numArray3[(int) ky4.\u0033S8];
              }
              else
              {
                chArray[index4] = ky4.\u00346p;
                ++index4;
                ++numArray3[(int) ky4.\u00346p];
              }
              if (num6 >= 2)
                num6 = num6 - 2 >> 1;
              else
                break;
            }
            num2 = 0;
          }
          chArray[index4] = (char) (index6 + 1);
          ++index4;
          ++numArray3[index6 + 1];
        }
      }
      if (num2 > 0)
      {
        int num7 = num2 - 1;
        while (true)
        {
          if ((num7 & 1) == 0)
          {
            chArray[index4] = ky4.\u0033S8;
            ++index4;
            ++numArray3[(int) ky4.\u0033S8];
          }
          else
          {
            chArray[index4] = ky4.\u00346p;
            ++index4;
            ++numArray3[(int) ky4.\u00346p];
          }
          if (num7 >= 2)
            num7 = num7 - 2 >> 1;
          else
            break;
        }
      }
      chArray[index4] = (char) index1;
      ++numArray3[index1];
      this.\u0038xM = index4 + 1;
    }

    private static void r97([In] int[] obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3, [In] int obj4)
    {
      int num = 0;
      for (int index1 = obj2; index1 <= obj3; ++index1)
      {
        for (int index2 = 0; index2 < obj4; ++index2)
        {
          if (((int) obj1[index2] & (int) byte.MaxValue) == index1)
          {
            obj0[index2] = num;
            ++num;
          }
        }
        num <<= 1;
      }
    }

    private void LY3()
    {
      byte[][] pzq = this.\u0036f2.PZQ;
      int num1 = this.d7p + 2;
      int m6G = ky4.m6G;
      while (--m6G >= 0)
      {
        byte[] numArray = pzq[m6G];
        int index = num1;
        while (--index >= 0)
          numArray[index] = \u0038H2.\u003918;
      }
      int num2 = this.\u0038xM < 200 ? 2 : (this.\u0038xM < 600 ? 3 : (this.\u0038xM < 1200 ? 4 : (this.\u0038xM < 2400 ? 5 : 6)));
      this.lsv(num2, num1);
      int num3 = this.\u00369J(num2, num1);
      this.\u00351a(num2, num3);
      this.\u0035p5(num2, num1);
      this.\u0031f8();
      this.\u0035o3(num2, num3);
      this.qpi(num2, num1);
      this.\u0033Ns(num3);
    }

    private void lsv([In] int obj0, [In] int obj1)
    {
      byte[][] pzq = this.\u0036f2.PZQ;
      int[] numArray1 = this.\u0036f2.\u00357q;
      int num1 = this.\u0038xM;
      int num2 = 0;
      for (int index1 = obj0; index1 > 0; --index1)
      {
        int num3 = num1 / index1;
        int num4 = num2 - 1;
        int num5 = 0;
        int num6 = obj1 - 1;
        while (num5 < num3 && num4 < num6)
          num5 += numArray1[++num4];
        if (num4 > num2 && index1 != obj0 && index1 != 1 && (obj0 - index1 & 1) != 0)
          num5 -= numArray1[num4--];
        byte[] numArray2 = pzq[index1 - 1];
        int index2 = obj1;
        while (--index2 >= 0)
          numArray2[index2] = index2 < num2 || index2 > num4 ? \u0038H2.\u003918 : \u0038H2.\u0034eT;
        num2 = num4 + 1;
        num1 -= num5;
      }
    }

    private static void \u003651(
      [In] byte[] obj0,
      [In] int[] obj1,
      [In] \u0038H2.\u0035a6 obj2,
      [In] int obj3,
      [In] int obj4)
    {
      int[] numArray1 = obj2.\u003432;
      int[] hu9 = obj2.hu9;
      int[] numArray2 = obj2.\u0036rL;
      int index1 = obj3;
      while (--index1 >= 0)
        hu9[index1 + 1] = (obj1[index1] == 0 ? 1 : obj1[index1]) << 8;
      bool flag = true;
      while (flag)
      {
        flag = false;
        int index2 = obj3;
        int index3 = 0;
        numArray1[0] = 0;
        hu9[0] = 0;
        numArray2[0] = -2;
        for (int index4 = 1; index4 <= obj3; ++index4)
        {
          numArray2[index4] = -1;
          ++index3;
          numArray1[index3] = index4;
          int index5 = index3;
          int index6;
          for (index6 = numArray1[index5]; hu9[index6] < hu9[numArray1[index5 >> 1]]; index5 >>= 1)
            numArray1[index5] = numArray1[index5 >> 1];
          numArray1[index5] = index6;
        }
        while (index3 > 1)
        {
          int index7 = numArray1[1];
          numArray1[1] = numArray1[index3];
          int index8 = index3 - 1;
          int num1 = 0;
          int index9 = 1;
          int index10 = numArray1[1];
          while (true)
          {
            int index11 = index9 << 1;
            if (index11 <= index8)
            {
              if (index11 < index8 && hu9[numArray1[index11 + 1]] < hu9[numArray1[index11]])
                ++index11;
              if (hu9[index10] >= hu9[numArray1[index11]])
              {
                numArray1[index9] = numArray1[index11];
                index9 = index11;
              }
              else
                break;
            }
            else
              break;
          }
          numArray1[index9] = index10;
          int index12 = numArray1[1];
          numArray1[1] = numArray1[index8];
          int num2 = index8 - 1;
          num1 = 0;
          int index13 = 1;
          int index14 = numArray1[1];
          while (true)
          {
            int index15 = index13 << 1;
            if (index15 <= num2)
            {
              if (index15 < num2 && hu9[numArray1[index15 + 1]] < hu9[numArray1[index15]])
                ++index15;
              if (hu9[index14] >= hu9[numArray1[index15]])
              {
                numArray1[index13] = numArray1[index15];
                index13 = index15;
              }
              else
                break;
            }
            else
              break;
          }
          numArray1[index13] = index14;
          ++index2;
          numArray2[index7] = numArray2[index12] = index2;
          int num3 = hu9[index7];
          int num4 = hu9[index12];
          hu9[index2] = (num3 & -256) + (num4 & -256) | 1 + ((num3 & (int) byte.MaxValue) > (num4 & (int) byte.MaxValue) ? num3 & (int) byte.MaxValue : num4 & (int) byte.MaxValue);
          numArray2[index2] = -1;
          index3 = num2 + 1;
          numArray1[index3] = index2;
          int index16 = index3;
          int index17 = numArray1[index16];
          for (int index18 = hu9[index17]; index18 < hu9[numArray1[index16 >> 1]]; index16 >>= 1)
            numArray1[index16] = numArray1[index16 >> 1];
          numArray1[index16] = index17;
        }
        for (int index19 = 1; index19 <= obj3; ++index19)
        {
          int num5 = 0;
          int index20 = index19;
          int num6;
          while ((num6 = numArray2[index20]) >= 0)
          {
            index20 = num6;
            ++num5;
          }
          obj0[index19 - 1] = (byte) num5;
          if (num5 > obj4)
            flag = true;
        }
        if (flag)
        {
          for (int index21 = 1; index21 < obj3; ++index21)
          {
            int num = 1 + (hu9[index21] >> 8 >> 1);
            hu9[index21] = num << 8;
          }
        }
      }
    }

    private int \u00369J([In] int obj0, [In] int obj1)
    {
      \u0038H2.\u0035a6 obj = this.\u0036f2;
      int[][] numArray1 = obj.\u0034ke;
      int[] yPq = obj.yPQ;
      short[] numArray2 = obj.\u0036f1;
      char[] chArray = obj.\u00374j;
      byte[] numArray3 = obj.\u003337;
      byte[][] pzq = obj.PZQ;
      byte[] numArray4 = pzq[0];
      byte[] numArray5 = pzq[1];
      byte[] numArray6 = pzq[2];
      byte[] numArray7 = pzq[3];
      byte[] numArray8 = pzq[4];
      byte[] numArray9 = pzq[5];
      int num1 = this.\u0038xM;
      int index1 = 0;
      for (int index2 = 0; index2 < ky4.\u003714; ++index2)
      {
        int index3 = obj0;
        while (--index3 >= 0)
        {
          yPq[index3] = 0;
          int[] numArray10 = numArray1[index3];
          int index4 = obj1;
          while (--index4 >= 0)
            numArray10[index4] = 0;
        }
        index1 = 0;
        int num2;
        for (int index5 = 0; index5 < this.\u0038xM; index5 = num2 + 1)
        {
          num2 = Math.Min(index5 + ky4.\u0038x1 - 1, num1 - 1);
          if (obj0 == ky4.m6G)
          {
            int[] numArray11 = new int[6];
            for (int index6 = index5; index6 <= num2; ++index6)
            {
              int index7 = (int) chArray[index6];
              numArray11[0] += (int) numArray4[index7] & (int) byte.MaxValue;
              numArray11[1] += (int) numArray5[index7] & (int) byte.MaxValue;
              numArray11[2] += (int) numArray6[index7] & (int) byte.MaxValue;
              numArray11[3] += (int) numArray7[index7] & (int) byte.MaxValue;
              numArray11[4] += (int) numArray8[index7] & (int) byte.MaxValue;
              numArray11[5] += (int) numArray9[index7] & (int) byte.MaxValue;
            }
            numArray2[0] = (short) numArray11[0];
            numArray2[1] = (short) numArray11[1];
            numArray2[2] = (short) numArray11[2];
            numArray2[3] = (short) numArray11[3];
            numArray2[4] = (short) numArray11[4];
            numArray2[5] = (short) numArray11[5];
          }
          else
          {
            int index8 = obj0;
            while (--index8 >= 0)
              numArray2[index8] = (short) 0;
            for (int index9 = index5; index9 <= num2; ++index9)
            {
              int index10 = (int) chArray[index9];
              int index11 = obj0;
              while (--index11 >= 0)
                numArray2[index11] += (short) ((int) pzq[index11][index10] & (int) byte.MaxValue);
            }
          }
          int index12 = -1;
          int index13 = obj0;
          int num3 = 999999999;
          while (--index13 >= 0)
          {
            int num4 = (int) numArray2[index13];
            if (num4 < num3)
            {
              num3 = num4;
              index12 = index13;
            }
          }
          ++yPq[index12];
          numArray3[index1] = (byte) index12;
          ++index1;
          int[] numArray12 = numArray1[index12];
          for (int index14 = index5; index14 <= num2; ++index14)
            ++numArray12[(int) chArray[index14]];
        }
        for (int index15 = 0; index15 < obj0; ++index15)
          \u0038H2.\u003651(pzq[index15], numArray1[index15], this.\u0036f2, obj1, 20);
      }
      return index1;
    }

    private void \u00351a([In] int obj0, [In] int obj1)
    {
      \u0038H2.\u0035a6 obj = this.\u0036f2;
      byte[] ir4 = obj.ir4;
      int index1 = obj0;
      while (--index1 >= 0)
        ir4[index1] = (byte) index1;
      for (int index2 = 0; index2 < obj1; ++index2)
      {
        byte num1 = obj.\u003337[index2];
        byte num2 = ir4[0];
        int index3 = 0;
        while ((int) num1 != (int) num2)
        {
          ++index3;
          byte num3 = num2;
          num2 = ir4[index3];
          ir4[index3] = num3;
        }
        ir4[0] = num2;
        obj.FDA[index2] = (byte) index3;
      }
    }

    private void \u0035p5([In] int obj0, [In] int obj1)
    {
      int[][] numArray1 = this.\u0036f2.\u00337A;
      byte[][] pzq = this.\u0036f2.PZQ;
      for (int index1 = 0; index1 < obj0; ++index1)
      {
        int num1 = 32;
        int num2 = 0;
        byte[] numArray2 = pzq[index1];
        int index2 = obj1;
        while (--index2 >= 0)
        {
          int num3 = (int) numArray2[index2] & (int) byte.MaxValue;
          if (num3 > num2)
            num2 = num3;
          if (num3 < num1)
            num1 = num3;
        }
        \u0038H2.r97(numArray1[index1], pzq[index1], num1, num2, obj1);
      }
    }

    private void \u0031f8()
    {
      bool[] flagArray1 = this.\u0036f2.\u0037Pn;
      bool[] flagArray2 = this.\u0036f2.\u003822;
      int index1 = 16;
      while (--index1 >= 0)
      {
        flagArray2[index1] = false;
        int num1 = index1 * 16;
        int num2 = 16;
        while (--num2 >= 0)
        {
          if (flagArray1[num1 + num2])
            flagArray2[index1] = true;
        }
      }
      uint num3 = 0;
      for (int index2 = 0; index2 < 16; ++index2)
      {
        if (flagArray2[index2])
          num3 |= (uint) (1 << 16 - index2 - 1);
      }
      this.Z5P.SH2(16, num3);
      for (int index3 = 0; index3 < 16; ++index3)
      {
        if (flagArray2[index3])
        {
          int num4 = index3 * 16;
          uint num5 = 0;
          for (int index4 = 0; index4 < 16; ++index4)
          {
            if (flagArray1[num4 + index4])
              num5 |= (uint) (1 << 16 - index4 - 1);
          }
          this.Z5P.SH2(16, num5);
        }
      }
    }

    private void \u0035o3([In] int obj0, [In] int obj1)
    {
      this.Z5P.SH2(3, (uint) obj0);
      this.Z5P.SH2(15, (uint) obj1);
      byte[] fda = this.\u0036f2.FDA;
      for (int index1 = 0; index1 < obj1; ++index1)
      {
        int num = 0;
        for (int index2 = (int) fda[index1] & (int) byte.MaxValue; num < index2; ++num)
          this.Z5P.SH2(1, 1U);
        this.Z5P.SH2(1, 0U);
      }
    }

    private void qpi([In] int obj0, [In] int obj1)
    {
      byte[][] pzq = this.\u0036f2.PZQ;
      for (int index1 = 0; index1 < obj0; ++index1)
      {
        byte[] numArray = pzq[index1];
        uint num1 = (uint) numArray[0] & (uint) byte.MaxValue;
        this.Z5P.SH2(5, num1);
        for (int index2 = 0; index2 < obj1; ++index2)
        {
          int num2;
          for (num2 = (int) numArray[index2] & (int) byte.MaxValue; (long) num1 < (long) num2; ++num1)
            this.Z5P.SH2(2, 2U);
          for (; (long) num1 > (long) num2; --num1)
            this.Z5P.SH2(2, 3U);
          this.Z5P.SH2(1, 0U);
        }
      }
    }

    private void \u0033Ns([In] int obj0)
    {
      byte[][] pzq = this.\u0036f2.PZQ;
      int[][] numArray1 = this.\u0036f2.\u00337A;
      byte[] numArray2 = this.\u0036f2.\u003337;
      char[] chArray = this.\u0036f2.\u00374j;
      int num1 = this.\u0038xM;
      int index1 = 0;
      int index2 = 0;
      while (index2 < num1)
      {
        int num2 = Math.Min(index2 + ky4.\u0038x1 - 1, num1 - 1);
        int index3 = (int) numArray2[index1] & (int) byte.MaxValue;
        int[] numArray3 = numArray1[index3];
        byte[] numArray4 = pzq[index3];
        for (; index2 <= num2; ++index2)
        {
          int index4 = (int) chArray[index2];
          this.Z5P.SH2((int) numArray4[index4] & (int) byte.MaxValue, (uint) numArray3[index4]);
        }
        index2 = num2 + 1;
        ++index1;
      }
    }

    private void uJ6()
    {
      this.Z5P.SH2(24, (uint) this.\u00382a);
      this.\u003743();
      this.LY3();
    }

    private sealed class \u0035a6
    {
      public readonly bool[] \u0037Pn = new bool[256];
      public readonly byte[] \u0036l5 = new byte[256];
      public readonly int[] \u00357q = new int[ky4.\u00323I];
      public readonly byte[] \u003337 = new byte[ky4.T2J];
      public readonly byte[] FDA = new byte[ky4.T2J];
      public readonly byte[] wbP = new byte[256];
      public byte[][] PZQ;
      public int[][] \u0034ke;
      public readonly int[] yPQ = new int[ky4.m6G];
      public readonly short[] \u0036f1 = new short[ky4.m6G];
      public int[][] \u00337A;
      public readonly byte[] ir4 = new byte[ky4.m6G];
      public readonly bool[] \u003822 = new bool[16];
      public readonly int[] \u003841 = new int[ky4.\u0031Pn];
      public readonly int[] \u00342q = new int[ky4.\u0031Pn];
      public readonly int[] \u00355Y = new int[ky4.\u0031Pn];
      public readonly int[] \u0031Ep = new int[256];
      public readonly int[] \u0032V4 = new int[256];
      public readonly bool[] N6Z = new bool[256];
      public int[] \u003432 = new int[ky4.\u00323I + 2];
      public int[] hu9 = new int[ky4.\u00323I * 2];
      public int[] \u0036rL = new int[ky4.\u00323I * 2];
      public readonly int[] f6Z = new int[65537];
      public byte[] \u0032JD;
      public int[] \u0031I6;
      public char[] \u00374j;
      public char[] \u003631;

      public \u0035a6([In] int obj0)
      {
        int length = obj0 * ky4.\u003359;
        this.\u0032JD = new byte[length + 1 + ky4.\u0038eD];
        this.\u0031I6 = new int[length];
        this.\u00374j = new char[2 * length];
        this.\u003631 = this.\u00374j;
        this.PZQ = ky4.f5l<byte>(ky4.m6G, ky4.\u00323I);
        this.\u0034ke = ky4.f5l<int>(ky4.m6G, ky4.\u00323I);
        this.\u00337A = ky4.f5l<int>(ky4.m6G, ky4.\u00323I);
      }
    }
  }
}
