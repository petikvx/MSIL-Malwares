// Decompiled with JetBrains decompiler
// Type: jd.Dy
// Assembly: RuntimeFieldI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3177D6BF-0678-437F-AD25-445C5521A270
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4e662e06b02d9a2d6b61135dedc905b8bc0ad6107d655cb2448b7eedfbf9c5b6.exe

using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace jd
{
  [DefaultMember("Item")]
  public class Dy
  {
    private short k4l;
    private double[,] p48;
    internal static Dy eYX;

    public Dy(short _param1)
    {
      Dy.LYP();
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.k4l = _param1;
      this.p48 = new double[(int) this.k4l, (int) this.k4l];
      int num = 0;
      if (true)
        goto label_3;
label_1:
      switch (num)
      {
        case 0:
          return;
        default:
          return;
      }
label_3:
      num = 0;
      goto label_1;
    }

    public Dy(double[,] _param1)
    {
      gs.JD3Ei4();
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.k4l = (short) Dy.iYe((double) _param1.Length);
      this.p48 = new double[(int) this.k4l, (int) this.k4l];
      int num1 = 4;
      if (true)
        goto label_2;
label_1:
      int num2;
      num1 = num2;
label_2:
      while (true)
      {
        int index1;
        bool flag;
        int index2;
        switch (num1)
        {
          case 1:
            ++index2;
            num1 = 3;
            continue;
          case 2:
            ++index1;
            break;
          case 3:
            if (index2 < (int) this.k4l)
            {
              index1 = 0;
              break;
            }
            goto label_10;
          case 4:
            index2 = 0;
            goto case 3;
          default:
            if (!flag)
            {
              if (true)
              {
                num1 = 1;
                continue;
              }
              goto label_1;
            }
            else
            {
              this.p48[index2, index1] = _param1[index2, index1];
              num1 = 2;
              continue;
            }
        }
        flag = index1 < (int) this.k4l;
        if (true)
          num1 = 0;
        else
          goto label_1;
      }
label_10:;
    }

    public Dy(Dy _param1)
    {
      gs.JD3Ei4();
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.k4l = _param1.m4p();
      this.p48 = new double[(int) this.k4l, (int) this.k4l];
      int index1 = 0;
      int num1 = 0;
      if (false)
        goto label_5;
label_1:
      while (true)
      {
        int index2;
        bool flag;
        switch (num1)
        {
          case 1:
            ++index2;
            break;
          case 2:
            if (!flag)
            {
              num1 = 4;
              continue;
            }
            goto case 3;
          case 3:
            index2 = 0;
            break;
          case 4:
            goto label_11;
          default:
label_10:
            flag = index1 < (int) this.k4l;
            num1 = true ? 2 : 2;
            continue;
        }
        if (index2 >= (int) this.k4l)
        {
          ++index1;
          goto label_10;
        }
        else
        {
          this.p48[index1, index2] = _param1.t4F(index1, index2);
          int num2;
          num1 = true ? 1 : num2;
        }
      }
label_11:
      return;
label_5:
      num1 = 0;
      goto label_1;
    }

    public Dy(xg[] _param1)
    {
      gs.JD3Ei4();
      // ISSUE: explicit constructor call
      base.\u002Ector();
      this.k4l = (short) _param1.Length;
      int num1 = 3;
      while (true)
      {
        int index;
        int num2;
        bool flag;
        switch (num1)
        {
          case 2:
            ++index;
            num1 = true ? 1 : 0;
            continue;
          case 3:
            this.p48 = new double[(int) this.k4l, (int) this.k4l];
            index = 0;
            int num3;
            num1 = true ? 0 : num3;
            continue;
          case 4:
            if (!flag)
            {
              num1 = 2;
              continue;
            }
            Dy.sYE((object) this.p48, index, num2, _param1[index].Qvc(num2));
            ++num2;
            break;
          default:
            if (index < (int) this.k4l)
            {
              num2 = 0;
              break;
            }
            goto label_9;
        }
        flag = num2 < (int) this.k4l;
        num1 = 4;
      }
label_9:;
    }

    public void n4T()
    {
      try
      {
        int index1 = 0;
        int num1 = 5;
        while (true)
        {
          int index2;
          bool flag;
          switch (num1)
          {
            case 1:
              if (index1 != 0)
              {
                num1 = Dy.uYO() != null ? 0 : 0;
                continue;
              }
              Console.WriteLine("Matrix:");
              goto default;
            case 2:
              Console.Write("\t {0:0.000}", (object) this.p48[index1, index2]);
              ++index2;
              break;
            case 3:
              if (!flag)
              {
                int num2;
                num1 = Dy.uYO() == null ? 2 : num2;
                continue;
              }
              goto case 4;
            case 4:
              Console.Write("\t");
              goto case 2;
            case 5:
label_7:
              if (index1 < (int) this.k4l)
                goto case 1;
              else
                goto label_16;
            default:
              index2 = 0;
              break;
          }
          if (index2 >= (int) this.k4l)
          {
            Console.WriteLine("\n");
            ++index1;
            goto label_7;
          }
          else
          {
            flag = index2 == 0;
            num1 = Dy.uYO() != null ? 3 : 3;
          }
        }
label_16:;
      }
      catch (NullReferenceException ex)
      {
        Dy.OYT((object) "Empty Vect massive!");
      }
    }

    public string d4A(int _param1)
    {
      string str1 = "";
      for (int index = 0; index < _param1 + 1; ++index)
        str1 = (string) Dy.BYx((object) str1, (object) "\t");
      string str2 = "";
      int num1 = 0;
      int num2 = 0;
      if (Dy.QYQ())
        goto label_9;
label_2:
      while (true)
      {
        int num3;
        bool flag;
        int num4;
        switch (num2)
        {
          case 1:
            if (flag)
            {
              str2 += str1;
              num4 = 0;
              num3 = 2;
              break;
            }
            num2 = 6;
            continue;
          case 2:
          case 4:
            if (num4 >= (int) this.m4p())
            {
              str2 = (string) Dy.BYx((object) str2, (object) "\n");
              ++num1;
              num3 = 3;
              break;
            }
            goto case 5;
          case 5:
            str2 = (string) Dy.BYx((object) str2, Dy.rYk((object) "{0,20:0.00000000}   ", (object) Dy.eYf((object) this.p48, num1, num4)));
            ++num4;
            num2 = 4;
            continue;
          case 6:
            goto label_11;
          default:
            flag = num1 < (int) this.m4p();
            if (Dy.QYQ())
            {
              num2 = 1;
              continue;
            }
            break;
        }
        num2 = num3;
      }
label_11:
      return str2;
label_9:
      num2 = 0;
      goto label_2;
    }

    [SpecialName]
    public short m4p() => this.k4l;

    [SpecialName]
    public double t4F(int _param1, int _param2) => this.p48[_param1, _param2];

    [SpecialName]
    public void P4h(int _param1, int _param2, double _param3) => this.p48[_param1, _param2] = _param3;

    public static Dy operator +(Dy _param0, Dy _param1)
    {
      Dy dy1 = new Dy(Dy.UYC((object) _param0));
      int num1 = 0;
      Dy dy2;
      while (true)
      {
        if (num1 >= (int) _param0.m4p())
          goto label_10;
        else
          goto label_5;
label_1:
        int num2;
        bool flag;
        int num3;
        while (true)
        {
          switch (num3)
          {
            case 1:
              goto label_5;
            case 2:
              goto label_7;
            case 3:
              if (flag)
                break;
              goto label_6;
            case 4:
              goto label_9;
          }
          dy1.P4h(num1, num2, _param0.t4F(num1, num2) + _param1.t4F(num1, num2));
          num3 = 2;
        }
label_6:
        ++num1;
        continue;
label_7:
        ++num2;
label_3:
        flag = num2 < (int) Dy.UYC((object) _param0);
        num3 = Dy.uYO() != null ? 0 : 3;
        goto label_1;
label_5:
        num2 = 0;
        goto label_3;
label_10:
        dy2 = dy1;
        num3 = 4;
        goto label_1;
      }
label_9:
      return dy2;
    }

    public static Dy operator *(double _param0, Dy _param1)
    {
      int num1 = 3;
label_1:
      Dy dy;
      while (true)
      {
        int num2 = num1;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 1:
              goto label_7;
            case 2:
              goto label_4;
            case 3:
              dy = new Dy(Dy.UYC((object) _param1));
              num2 = 2;
              continue;
            case 4:
              if (flag)
              {
                if (Dy.uYO() == null)
                {
                  num2 = 0;
                  continue;
                }
                goto label_1;
              }
              else
                goto label_7;
            default:
              goto label_11;
          }
        }
label_4:
        int num3 = 0;
label_5:
        flag = num3 < (int) _param1.m4p();
        num1 = 4;
        continue;
label_11:
        for (int index = 0; index < (int) _param1.m4p(); ++index)
          Dy.SYh((object) dy, num3, index, _param0 * _param1.t4F(num3, index));
        ++num3;
        goto label_5;
      }
label_7:
      return dy;
    }

    public static Dy operator -(Dy _param0, Dy _param1)
    {
      Dy dy1 = new Dy(_param0.m4p());
      int num1 = 0;
      int num2 = 0;
      if (Dy.uYO() == null)
        goto label_7;
label_1:
      while (true)
      {
        bool flag;
        switch (num2)
        {
          case 1:
            goto label_2;
          case 2:
            goto label_3;
          case 3:
            if (!flag)
            {
              num2 = Dy.QYQ() ? 2 : 0;
              continue;
            }
            for (int index = 0; index < (int) _param0.m4p(); ++index)
              Dy.SYh((object) dy1, num1, index, _param0.t4F(num1, index) - _param1.t4F(num1, index));
            ++num1;
            break;
        }
        flag = num1 < (int) _param0.m4p();
        num2 = 3;
      }
label_2:
      Dy dy2;
      return dy2;
label_3:
      dy2 = dy1;
      goto label_2;
label_7:
      num2 = 0;
      goto label_1;
    }

    public static Dy operator *(Dy _param0, Dy _param1)
    {
      Dy dy1 = new Dy(Dy.UYC((object) _param0));
      if ((int) _param0.m4p() != (int) _param1.m4p())
        goto label_9;
      else
        goto label_18;
label_1:
      int num1;
      int num2 = num1;
label_2:
      Dy dy2;
      int num3;
      int num4;
      int num5;
      bool flag;
      while (true)
      {
        switch (num2)
        {
          case 1:
            goto label_5;
          case 2:
            goto label_9;
          case 3:
            if (!flag)
            {
              ++num5;
              if (Dy.QYQ())
              {
                num2 = 0;
                continue;
              }
              goto label_1;
            }
            else
            {
              dy2 = dy1;
              num2 = 7;
              continue;
            }
          case 4:
            goto label_11;
          case 5:
            goto label_12;
          case 6:
            goto label_13;
          case 7:
            int num6 = num3;
            int num7 = num5;
            dy2.P4h(num6, num7, dy2.t4F(num6, num7) + _param0.t4F(num3, num4) * _param1.t4F(num4, num5));
            if (Dy.uYO() == null)
            {
              num2 = 8;
              continue;
            }
            goto label_1;
          case 8:
            ++num4;
            num2 = Dy.uYO() == null ? 6 : 2;
            continue;
          default:
            goto label_17;
        }
      }
label_5:
      return dy1;
label_11:
      ++num3;
label_7:
      if (num3 >= (int) Dy.UYC((object) _param0))
      {
        num2 = Dy.uYO() != null ? 0 : 1;
        goto label_2;
      }
      else
      {
        num5 = 0;
        goto label_17;
      }
label_9:
      Dy.OYT((object) "допускается перемножение только квадратных матриц одной размерности");
      Environment.Exit(0);
label_12:
      num3 = 0;
      goto label_7;
label_13:
      flag = num4 < (int) _param0.m4p();
      num2 = 3;
      goto label_2;
label_17:
      if (num5 >= (int) _param0.m4p())
      {
        num2 = 4;
        goto label_2;
      }
      else
      {
        num4 = 0;
        goto label_13;
      }
label_18:
      if (Dy.QYQ())
      {
        num2 = 5;
        goto label_2;
      }
      else
        goto label_1;
    }

    public static UM operator *(Dy _param0, UM _param1)
    {
      if (_param1.afb() != 3)
        goto label_21;
      else
        goto label_8;
label_1:
      int num1;
      int num2 = num1;
label_2:
      UM um;
      while (true)
      {
        int num3;
        double num4;
        bool flag;
        int num5;
        switch (num2)
        {
          case 1:
            ++num5;
            break;
          case 2:
            um.BfW(num3, num4);
            ++num3;
            num2 = Dy.QYQ() ? 3 : 3;
            continue;
          case 3:
            flag = num3 < _param1.afb();
            num2 = 5;
            continue;
          case 5:
            if (!flag)
            {
              num2 = 7;
              continue;
            }
            num4 = 0.0;
            num5 = 0;
            break;
          case 6:
            goto label_5;
          case 7:
            goto label_7;
          default:
            num3 = 0;
            goto case 3;
        }
        if (num5 >= _param1.afb())
        {
          if (Dy.uYO() == null)
            num2 = 2;
          else
            goto label_1;
        }
        else
        {
          num4 += _param0.t4F(num3, num5) * Dy.TYF((object) _param1, num5);
          if (Dy.QYQ())
            num2 = 1;
          else
            goto label_1;
        }
      }
label_5:
      um = (UM) new qT();
      goto label_17;
label_7:
      return um;
label_8:
      num2 = 6;
      goto label_2;
label_17:
      if (Dy.EY6((object) _param1) != (int) _param0.m4p())
      {
        Console.WriteLine("допускается перемножение только квадратных матриц на вектор одной размерности");
        Dy.kYL(0);
        num2 = 4;
        goto label_2;
      }
      else if (Dy.QYQ())
      {
        num2 = 0;
        goto label_2;
      }
      else
        goto label_1;
label_21:
      um = (UM) new xg(_param1.afb());
      goto label_17;
    }

    public double D45()
    {
      int num1 = 5;
      double num2;
      while (true)
      {
        int num3 = num1;
        double num4;
        int index1;
        while (true)
        {
          bool flag;
          switch (num3)
          {
            case 1:
              goto label_7;
            case 2:
              if (!flag)
                goto label_8;
              else
                break;
            case 3:
              goto label_6;
            case 4:
              index1 = 0;
              goto case 6;
            case 5:
              num2 = 0.0;
              num3 = Dy.uYO() != null ? 0 : 4;
              continue;
            case 6:
              flag = index1 < (int) this.m4p();
              num3 = !Dy.QYQ() ? 1 : 2;
              continue;
          }
          num4 = 0.0;
          num3 = !Dy.QYQ() ? 0 : 1;
        }
label_7:
        for (int index2 = 0; index2 < (int) this.m4p(); ++index2)
          num4 += Dy.QYm(this.p48[index1, index2]);
        if (num4 > num2)
          num2 = num4;
        ++index1;
        num1 = 6;
      }
label_6:
      double num5;
      return num5;
label_8:
      num5 = num2;
      goto label_6;
    }

    public bool z4D()
    {
      int num = 4;
      bool flag1;
      while (true)
      {
        int index;
        bool flag2;
        switch (num)
        {
          case 1:
            flag2 = this.p48[index, index] == 0.0;
            num = !Dy.QYQ() ? 0 : 0;
            continue;
          case 2:
            goto label_6;
          case 3:
            index = 0;
            break;
          case 4:
            flag1 = true;
            num = 3;
            continue;
          default:
            if (flag2)
              flag1 = false;
            ++index;
            break;
        }
        if (index < (int) this.k4l)
          num = !Dy.QYQ() ? 0 : 1;
        else
          goto label_7;
      }
label_6:
      bool flag3;
      return flag3;
label_7:
      flag3 = flag1;
      goto label_6;
    }

    public double O41()
    {
      double num1 = 0.0;
      int index1 = 0;
      double num2;
      while (true)
      {
        if (index1 < (int) this.m4p())
          goto label_2;
        else
          goto label_12;
label_1:
        int num3;
        while (true)
        {
          switch (num3)
          {
            case 1:
              goto label_10;
            case 2:
              goto label_4;
            case 3:
              num2 = num1;
              num3 = Dy.uYO() != null ? 0 : 0;
              continue;
            case 4:
              goto label_2;
            default:
              goto label_11;
          }
        }
label_4:
        ++index1;
        continue;
label_2:
        int index2 = index1 + 1;
label_10:
        if (index2 >= (int) this.m4p())
        {
          num3 = 2;
          goto label_1;
        }
        else
        {
          if (Math.Abs(this.p48[index1, index2]) > num1)
            num1 = Math.Abs(this.p48[index1, index2]);
          ++index2;
          num3 = 1;
          if (!Dy.QYQ())
          {
            int num4;
            num3 = num4;
            goto label_1;
          }
          else
            goto label_1;
        }
label_12:
        num3 = 3;
        goto label_1;
      }
label_11:
      return num2;
    }

    public double O4n()
    {
      int num1 = 11;
label_1:
      int num2 = num1;
      double num3;
      while (true)
      {
        int num4;
        int num5;
        int index1;
        bool flag1;
        int num6;
        int index2;
        int num7;
        bool flag2;
        Dy dy;
        switch (num2)
        {
          case 1:
            if (num5 >= (int) this.m4p())
            {
              ++num4;
              break;
            }
            goto case 5;
          case 2:
            flag1 = num6 < (int) this.m4p();
            if (Dy.QYQ())
            {
              num2 = 8;
              continue;
            }
            goto label_1;
          case 3:
            if (!flag2)
              goto label_10;
            else
              goto case 4;
          case 4:
            num3 *= dy.t4F(num7, num7);
            ++num7;
            if (Dy.QYQ())
            {
              num2 = 13;
              continue;
            }
            goto label_1;
          case 5:
            num6 = num4 + 1;
            goto case 2;
          case 6:
            if (index1 < (int) this.m4p())
            {
              index2 = 0;
              goto label_30;
            }
            else
            {
              if (Dy.QYQ())
              {
                num2 = 0;
                continue;
              }
              goto label_1;
            }
          case 7:
            ++index2;
            goto label_30;
          case 8:
            if (flag1)
            {
              Dy.SYh((object) dy, num5, num6, dy.t4F(num5, num6) + dy.t4F(num4, num6) * (-dy.t4F(num5, num4) / dy.t4F(num4, num4)));
              ++num6;
              num2 = 2;
              continue;
            }
            dy.P4h(num5, num4, 0.0);
            ++num5;
            goto case 1;
          case 9:
            num7 = 0;
            goto case 13;
          case 10:
            index1 = 0;
            goto case 6;
          case 11:
            dy = new Dy(this.m4p());
            num2 = 10;
            continue;
          case 12:
            goto label_10;
          case 13:
            flag2 = num7 < (int) this.m4p();
            if (Dy.uYO() == null)
            {
              num2 = 3;
              continue;
            }
            goto label_1;
          default:
            num3 = 1.0;
            num4 = 0;
            break;
        }
        if (num4 < (int) this.m4p())
        {
          num5 = num4 + 1;
          if (Dy.uYO() == null)
          {
            num2 = 1;
            continue;
          }
          goto label_1;
        }
        else
        {
          if (Dy.QYQ())
          {
            num2 = 9;
            continue;
          }
          goto label_1;
        }
label_30:
        if (index2 >= (int) this.m4p())
        {
          ++index1;
          if (Dy.QYQ())
            num2 = 6;
          else
            goto label_1;
        }
        else
        {
          dy.P4h(index1, index2, this.p48[index1, index2]);
          num2 = 7;
        }
      }
label_10:
      return num3;
    }

    public UM z4y(int _param1)
    {
      int num1 = 3;
label_1:
      int num2 = num1;
      UM um;
      while (true)
      {
        int index;
        bool flag;
        switch (num2)
        {
          case 1:
            goto label_9;
          case 2:
            um = flag ? (UM) new qT() : (UM) new xg((int) this.k4l);
            index = 0;
            break;
          case 3:
            flag = this.k4l == (short) 3;
            num2 = Dy.QYQ() ? 2 : 1;
            continue;
          case 4:
            ++index;
            break;
          default:
label_5:
            um.BfW(index, this.p48[_param1, index]);
            num2 = 4;
            continue;
        }
        if (index >= (int) this.m4p())
        {
          if (Dy.QYQ())
            num2 = 1;
          else
            goto label_1;
        }
        else
          goto label_5;
      }
label_9:
      return um;
    }

    internal static void LYP() => gs.JD3Ei4();

    internal static bool QYQ() => Dy.eYX == null;

    internal static Dy uYO() => Dy.eYX;

    internal static double iYe([In] double obj0) => Math.Sqrt(obj0);

    internal static void sYE([In] object obj0, [In] int obj1, [In] int obj2, [In] double obj3) => ((double[,]) obj0)[obj1, obj2] = obj3;

    internal static void OYT([In] object obj0) => Console.WriteLine((string) obj0);

    internal static object BYx([In] object obj0, [In] object obj1) => (object) ((string) obj0 + (string) obj1);

    internal static double eYf([In] object obj0, [In] int obj1, [In] int obj2) => ((double[,]) obj0)[obj1, obj2];

    internal static object rYk([In] object obj0, [In] object obj1) => (object) string.Format((string) obj0, obj1);

    internal static short UYC([In] object obj0) => ((Dy) obj0).m4p();

    internal static void SYh([In] object obj0, int _param1, int _param2, double _param3) => ((Dy) obj0).P4h(_param1, _param2, _param3);

    internal static int EY6([In] object obj0) => ((UM) obj0).afb();

    internal static void kYL([In] int obj0) => Environment.Exit(obj0);

    internal static double TYF([In] object obj0, int _param1) => ((UM) obj0).zfZ(_param1);

    internal static double QYm([In] double obj0) => Math.Abs(obj0);
  }
}
