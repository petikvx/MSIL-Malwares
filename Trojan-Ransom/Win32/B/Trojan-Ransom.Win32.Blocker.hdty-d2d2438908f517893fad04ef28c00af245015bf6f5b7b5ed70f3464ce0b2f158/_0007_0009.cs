// Decompiled with JetBrains decompiler
// Type: ___codefort.	
// Assembly: l, Version=9.7.4712.31341, Culture=neutral, PublicKeyToken=null
// MVID: 54E09185-39E1-4364-8A8C-3E5AA9242180
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00032-msil\Trojan-Ransom.Win32.Blocker.hdty-d2d2438908f517893fad04ef28c00af245015bf6f5b7b5ed70f3464ce0b2f158.exe.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

namespace ___codefort
{
  internal sealed class \u0007\u0009
  {
    public static Type \u0003\u0009\u0015([In] RuntimeTypeHandle obj0) => Type.GetTypeFromHandle(obj0);

    public static FieldInfo \u0003\u0009\u0014(
      [In] object obj0,
      [In] string obj1,
      [In] BindingFlags obj2)
    {
      return ((Type) obj0).GetField(obj1, obj2);
    }

    public static object \u0003\u0009\u0017([In] object obj0, [In] object obj1) => ((FieldInfo) obj0).GetValue(obj1);

    public static string \u0003\u0009\u0016([In] string obj0, [In] string obj1, [In] string obj2, [In] string obj3) => obj0 + obj1 + obj2 + obj3;

    public static Exception \u0003\u0009\u0002([In] string obj0) => new Exception(obj0);

    public static string \u0003\u0009\u0001([In] ref object obj0) => obj0.Name;

    public static string \u0003\u0009\u0004([In] object obj0) => Convert.ToString(obj0);

    public static string \u0003\u0009\u0003([In] string[] obj0) => string.Concat(obj0);

    public static string[] \u0003\u0009\u0006([In] object obj0, [In] char[] obj1) => ((string) obj0).Split(obj1);

    public static StringBuilder \u0003\u0009\u0005() => new StringBuilder();

    public static StringBuilder \u0003\u0009\u0008([In] object obj0, [In] string obj1) => ((StringBuilder) obj0).Append(obj1);

    public static string \u0003\u0009\u0007([In] object obj0, [In] int obj1, [In] int obj2) => ((string) obj0).Substring(obj1, obj2);

    public static string \u0003\u0017\u000A([In] object obj0) => ((string) obj0).ToUpper();

    public static int \u0003\u0017\u0009([In] object obj0) => ((string) obj0).Length;

    public static string \u0003\u0017\u0013([In] object obj0, [In] int obj1) => ((string) obj0).Substring(obj1);

    public static string \u0003\u0017\u0012([In] string obj0, [In] string obj1) => obj0 + obj1;

    public static string \u0003\u0017\u0015([In] ref object obj0) => __nonvirtual (obj0.ToString());

    public static XmlDictionaryWriter \u0003\u0017\u0014([In] Stream obj0) => XmlDictionaryWriter.CreateBinaryWriter(obj0);

    public static void \u0003\u0017\u0017([In] object obj0, [In] XmlDictionaryWriter obj1, [In] object obj2) => ((XmlObjectSerializer) obj0).WriteObject(obj1, obj2);

    public static void \u0003\u0017\u0016([In] object obj0) => ((IDisposable) obj0).Dispose();

    public static XmlDictionaryReaderQuotas \u0003\u0017\u0002() => XmlDictionaryReaderQuotas.Max;

    public static XmlDictionaryReader \u0003\u0017\u0001(
      [In] Stream obj0,
      [In] XmlDictionaryReaderQuotas obj1)
    {
      return XmlDictionaryReader.CreateBinaryReader(obj0, obj1);
    }

    public static object \u0003\u0017\u0004([In] object obj0, [In] XmlDictionaryReader obj1) => ((XmlObjectSerializer) obj0).ReadObject(obj1);

    public static DataContractSerializer \u0003\u0017\u0003(
      [In] Type obj0,
      [In] IEnumerable<Type> obj1)
    {
      return new DataContractSerializer(obj0, obj1);
    }

    public static bool \u0003\u0017\u0006([In] object obj0) => ((IEnumerator) obj0).MoveNext();

    public static AppDomain \u0003\u0017\u0005() => AppDomain.CurrentDomain;

    public static AssemblyName \u0003\u0017\u0008([In] string obj0) => new AssemblyName(obj0);

    public static AssemblyBuilder \u0003\u0017\u0007(
      [In] object obj0,
      [In] AssemblyName obj1,
      [In] AssemblyBuilderAccess obj2)
    {
      return ((AppDomain) obj0).DefineDynamicAssembly(obj1, obj2);
    }

    public static ModuleBuilder \u0003\u0016\u000A([In] object obj0, [In] string obj1) => ((AssemblyBuilder) obj0).DefineDynamicModule(obj1);

    public static Type \u0003\u0016\u0009([In] object obj0) => ((TypeBuilder) obj0).CreateType();

    public static Type \u0003\u0016\u0013([In] object obj0, [In] string obj1) => ((Assembly) obj0).GetType(obj1);

    public static object \u0003\u0016\u0012([In] object obj0, [In] string obj1) => ((Assembly) obj0).CreateInstance(obj1);

    public static TypeBuilder \u0003\u0016\u0015(
      [In] object obj0,
      [In] string obj1,
      [In] TypeAttributes obj2)
    {
      return ((ModuleBuilder) obj0).DefineType(obj1, obj2);
    }

    public static TypeBuilder \u0003\u0016\u0014(
      [In] object obj0,
      [In] string obj1,
      [In] TypeAttributes obj2,
      [In] Type obj3)
    {
      return ((ModuleBuilder) obj0).DefineType(obj1, obj2, obj3);
    }

    public static ConstructorBuilder \u0003\u0016\u0017(
      [In] object obj0,
      [In] MethodAttributes obj1,
      [In] CallingConventions obj2,
      [In] Type[] obj3)
    {
      return ((TypeBuilder) obj0).DefineConstructor(obj1, obj2, obj3);
    }

    public static void \u0003\u0016\u0016([In] object obj0, [In] MethodImplAttributes obj1) => ((ConstructorBuilder) obj0).SetImplementationFlags(obj1);

    public static ILGenerator \u0003\u0016\u0002([In] object obj0) => ((ConstructorBuilder) obj0).GetILGenerator();

    public static ConstructorBuilder \u0003\u0016\u0001([In] object obj0) => ((TypeBuilder) obj0).DefineTypeInitializer();

    public static MethodBuilder \u0003\u0016\u0004(
      [In] object obj0,
      [In] string obj1,
      [In] MethodAttributes obj2,
      [In] CallingConventions obj3,
      [In] Type obj4,
      [In] Type[] obj5)
    {
      return ((TypeBuilder) obj0).DefineMethod(obj1, obj2, obj3, obj4, obj5);
    }

    public static void \u0003\u0016\u0003([In] object obj0, [In] MethodImplAttributes obj1) => ((MethodBuilder) obj0).SetImplementationFlags(obj1);

    public static ILGenerator \u0003\u0016\u0006([In] object obj0) => ((MethodBuilder) obj0).GetILGenerator();

    public static FieldBuilder \u0003\u0016\u0005(
      [In] object obj0,
      [In] string obj1,
      [In] Type obj2,
      [In] FieldAttributes obj3)
    {
      return ((TypeBuilder) obj0).DefineField(obj1, obj2, obj3);
    }

    public static PropertyBuilder \u0003\u0016\u0008(
      [In] object obj0,
      [In] string obj1,
      [In] PropertyAttributes obj2,
      [In] Type obj3,
      [In] Type[] obj4)
    {
      return ((TypeBuilder) obj0).DefineProperty(obj1, obj2, obj3, obj4);
    }

    public static void \u0003\u0016\u0007([In] object obj0, [In] MethodBuilder obj1) => ((PropertyBuilder) obj0).SetGetMethod(obj1);

    public static void \u0003\u0015\u000A([In] object obj0, [In] MethodBuilder obj1) => ((PropertyBuilder) obj0).SetSetMethod(obj1);

    public static EventBuilder \u0003\u0015\u0009(
      [In] object obj0,
      [In] string obj1,
      [In] EventAttributes obj2,
      [In] Type obj3)
    {
      return ((TypeBuilder) obj0).DefineEvent(obj1, obj2, obj3);
    }

    public static void \u0003\u0015\u0013([In] object obj0, [In] MethodBuilder obj1) => ((EventBuilder) obj0).SetAddOnMethod(obj1);

    public static void \u0003\u0015\u0012([In] object obj0, [In] MethodBuilder obj1) => ((EventBuilder) obj0).SetRemoveOnMethod(obj1);

    public static void \u0003\u0015\u0015([In] object obj0, [In] Type obj1) => ((ILGenerator) obj0).BeginCatchBlock(obj1);

    public static void \u0003\u0015\u0014([In] object obj0) => ((ILGenerator) obj0).BeginExceptFilterBlock();

    public static Label \u0003\u0015\u0017([In] object obj0) => ((ILGenerator) obj0).BeginExceptionBlock();

    public static void \u0003\u0015\u0016([In] object obj0) => ((ILGenerator) obj0).BeginFaultBlock();

    public static void \u0003\u0015\u0002([In] object obj0) => ((ILGenerator) obj0).BeginFinallyBlock();

    public static void \u0003\u0015\u0001([In] object obj0) => ((ILGenerator) obj0).BeginScope();

    public static LocalBuilder \u0003\u0015\u0004([In] object obj0, [In] Type obj1, [In] bool obj2) => ((ILGenerator) obj0).DeclareLocal(obj1, obj2);

    public static Label \u0003\u0015\u0003([In] object obj0) => ((ILGenerator) obj0).DefineLabel();

    public static void \u0003\u0015\u0006([In] object obj0) => ((ILGenerator) obj0).EndExceptionBlock();

    public static void \u0003\u0015\u0005([In] object obj0) => ((ILGenerator) obj0).EndScope();

    public static void \u0003\u0015\u0008([In] object obj0, [In] Label obj1) => ((ILGenerator) obj0).MarkLabel(obj1);

    public static NotImplementedException \u0003\u0015\u0007() => new NotImplementedException();

    public static void \u0003\u0014\u000A([In] object obj0, [In] Type obj1) => ((ILGenerator) obj0).ThrowException(obj1);

    public static Exception \u0003\u0014\u0009([In] string obj0, [In] Exception obj1) => new Exception(obj0, obj1);

    public static void \u0003\u0014\u0013([In] object obj0, [In] OpCode obj1) => ((ILGenerator) obj0).Emit(obj1);

    public static void \u0003\u0014\u0012([In] object obj0, [In] OpCode obj1, [In] byte obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0015([In] object obj0, [In] OpCode obj1, [In] ConstructorInfo obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0014([In] object obj0, [In] OpCode obj1, [In] double obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0017([In] object obj0, [In] OpCode obj1, [In] FieldInfo obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0016([In] object obj0, [In] OpCode obj1, [In] float obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0002([In] object obj0, [In] OpCode obj1, [In] int obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0001([In] object obj0, [In] OpCode obj1, [In] Label obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0004([In] object obj0, [In] OpCode obj1, [In] Label[] obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0003([In] object obj0, [In] OpCode obj1, [In] LocalBuilder obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0006([In] object obj0, [In] OpCode obj1, [In] long obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0005([In] object obj0, [In] OpCode obj1, [In] MethodInfo obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0008([In] object obj0, [In] OpCode obj1, [In] sbyte obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0003\u0014\u0007([In] object obj0, [In] OpCode obj1, [In] short obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0004\u0004\u000A([In] object obj0, [In] OpCode obj1, [In] string obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static void \u0004\u0004\u0009([In] object obj0, [In] OpCode obj1, [In] Type obj2) => ((ILGenerator) obj0).Emit(obj1, obj2);

    public static Assembly \u0004\u0004\u0013([In] string obj0) => Assembly.Load(obj0);

    public static Type \u0004\u0004\u0012([In] object obj0, [In] Type[] obj1) => ((Type) obj0).MakeGenericType(obj1);

    public static Type \u0004\u0004\u0015([In] object obj0) => ((Type) obj0).MakeArrayType();

    public static Type \u0004\u0004\u0014([In] object obj0, [In] int obj1) => ((Type) obj0).MakeArrayType(obj1);

    public static bool \u0004\u0004\u0017([In] string obj0, [In] string obj1) => obj0 == obj1;

    public static ConstructorInfo \u0004\u0004\u0016(
      [In] object obj0,
      [In] BindingFlags obj1,
      [In] Binder obj2,
      [In] Type[] obj3,
      [In] ParameterModifier[] obj4)
    {
      return ((Type) obj0).GetConstructor(obj1, obj2, obj3, obj4);
    }

    public static MethodInfo \u0004\u0004\u0002(
      [In] object obj0,
      [In] string obj1,
      [In] BindingFlags obj2,
      [In] Binder obj3,
      [In] CallingConventions obj4,
      [In] Type[] obj5,
      [In] ParameterModifier[] obj6)
    {
      return ((Type) obj0).GetMethod(obj1, obj2, obj3, obj4, obj5, obj6);
    }

    public static MemberInfo[] \u0004\u0004\u0001(
      [In] object obj0,
      [In] string obj1,
      [In] MemberTypes obj2,
      [In] BindingFlags obj3)
    {
      return ((Type) obj0).GetMember(obj1, obj2, obj3);
    }

    public static MethodInfo \u0004\u0004\u0004([In] object obj0, [In] string obj1) => ((Type) obj0).GetMethod(obj1);

    public static object \u0004\u0004\u0003([In] object obj0, [In] object obj1, [In] object[] obj2) => ((MethodBase) obj0).Invoke(obj1, obj2);

    public static Assembly \u0004\u0004\u0006() => Assembly.GetExecutingAssembly();

    public static Stream \u0004\u0004\u0005([In] object obj0, [In] string obj1) => ((Assembly) obj0).GetManifestResourceStream(obj1);

    public static MemoryStream \u0004\u0004\u0008([In] byte[] obj0) => new MemoryStream(obj0);

    public static BinaryReader \u0004\u0004\u0007([In] Stream obj0) => new BinaryReader(obj0);

    public static int \u0004\u0003\u000A([In] object obj0) => ((BinaryReader) obj0).ReadInt32();

    public static byte[] \u0004\u0003\u0009([In] object obj0, [In] int obj1) => ((BinaryReader) obj0).ReadBytes(obj1);

    public static double \u0004\u0003\u0013([In] double obj0) => Math.Atan(obj0);

    public static double \u0004\u0003\u0012([In] double obj0) => Math.Ceiling(obj0);

    public static Stream \u0004\u0003\u0015([In] object obj0) => ((BinaryReader) obj0).BaseStream;

    public static long \u0004\u0003\u0014([In] object obj0) => ((Stream) obj0).Length;

    public static long \u0004\u0003\u0017([In] object obj0) => ((Stream) obj0).Position;

    public static ConstructorInfo \u0004\u0003\u0016([In] object obj0, [In] Type[] obj1) => ((Type) obj0).GetConstructor(obj1);

    public static object \u0004\u0003\u0002([In] object obj0, [In] object[] obj1) => ((ConstructorInfo) obj0).Invoke(obj1);

    public static GZipStream \u0004\u0003\u0001([In] Stream obj0, [In] CompressionMode obj1) => new GZipStream(obj0, obj1);

    public static int \u0004\u0003\u0004([In] object obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3) => ((Stream) obj0).Read(obj1, obj2, obj3);

    public static void \u0004\u0003\u0003([In] object obj0) => ((Stream) obj0).Close();

    public static void \u0004\u0003\u0006([In] object obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3) => ((Stream) obj0).Write(obj1, obj2, obj3);

    public static int \u0004\u0003\u0005([In] object obj0) => ((string) obj0).Length;

    public static double \u0004\u0003\u0008([In] double obj0) => Math.Sqrt(obj0);

    public static char \u0004\u0003\u0007([In] object obj0, [In] int obj1) => ((string) obj0)[obj1];

    public static Encoding \u0004\u0002\u000A() => Encoding.UTF8;

    public static string \u0004\u0002\u0009([In] object obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3) => ((Encoding) obj0).GetString(obj1, obj2, obj3);
  }
}
