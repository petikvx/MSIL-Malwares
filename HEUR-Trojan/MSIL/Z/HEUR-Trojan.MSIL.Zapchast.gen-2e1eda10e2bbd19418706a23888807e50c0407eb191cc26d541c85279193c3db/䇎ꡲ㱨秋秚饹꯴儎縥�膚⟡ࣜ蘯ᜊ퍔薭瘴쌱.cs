// Decompiled with JetBrains decompiler
// Type: 䇎ꡲ㱨秋秚饹꯴儎縥�膚⟡ࣜ蘯ᜊ퍔薭瘴쌱
// Assembly: $77-Venom, Version=2.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC8E8704-647D-4CA7-99AB-BB7BE936B486
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan.MSIL.Zapchast.gen-2e1eda10e2bbd19418706a23888807e50c0407eb191cc26d541c85279193c3db.exe

using System;
using System.IO;

public class 䇎ꡲ㱨秋秚饹꯴儎縥\uFFFD膚\u27E1\u08DC蘯\uE5AAᜊ퍔薭瘴쌱
{
  private int ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫;
  private readonly object \uE1F0\uF8CD앲캩\u088F뾚Ẇꋲ\u2A13餜闟ඥᴄÕ核ﺰ\u2CE6㣤ﴥ唀 = new object();
  private const int \u25AE톮렢敜ᷡ㡑㢒逯턗컯좒뢒Ｔ烂䦈㵚ᡋ\uEF57샵㓫 = 65535;

  public string Path { get; private set; }

  public string LastError { get; private set; }

  public int MaxBlocks
  {
    get
    {
      if (this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫 <= 0)
      {
        if (this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫 != -1)
        {
          try
          {
            FileInfo fileInfo = new FileInfo(this.Path);
            this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫 = fileInfo.Exists ? (int) Math.Ceiling((double) fileInfo.Length / (double) ushort.MaxValue) : throw new FileNotFoundException();
          }
          catch (UnauthorizedAccessException ex)
          {
            this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫 = -1;
            this.LastError = "Access denied";
          }
          catch (IOException ex)
          {
            this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫 = -1;
            if (ex is FileNotFoundException)
              this.LastError = "File not found";
            if (ex is PathTooLongException)
              this.LastError = "Path is too long";
          }
          return this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫;
        }
      }
      return this.ᴰ功够柺⃜\uA8DF닊螁႐嘗ࣤ숔ᐕ耒椌\uE686\uE409\uF6E0旟鰫;
    }
  }

  public 䇎ꡲ㱨秋秚饹꯴儎縥\uFFFD膚\u27E1\u08DC蘯\uE5AAᜊ퍔薭瘴쌱(string path) => this.Path = path;

  private int \uEF6A莖偂좻썰葮晲\uE3F9\uF2EE糍\u24FCત䮄\uFFFDﾨ㮰\u229D쑍ഡ\uE0A9(long length) => length >= (long) ushort.MaxValue ? (int) ushort.MaxValue : (int) length;

  public bool 荢ꍂ깳㲭髑製薮扊\uFFFDࣳᯭ\uF16Aﭻ㬟焘诪庞触ం器(int blockNumber, out byte[] readBytes)
  {
    try
    {
      if (blockNumber > this.MaxBlocks)
        throw new ArgumentOutOfRangeException();
      lock (this.\uE1F0\uF8CD앲캩\u088F뾚Ẇꋲ\u2A13餜闟ඥᴄÕ核ﺰ\u2CE6㣤ﴥ唀)
      {
        using (FileStream fileStream = File.OpenRead(this.Path))
        {
          if (blockNumber == 0)
          {
            fileStream.Seek(0L, SeekOrigin.Begin);
            long length = fileStream.Length - fileStream.Position;
            readBytes = length >= 0L ? new byte[this.\uEF6A莖偂좻썰葮晲\uE3F9\uF2EE糍\u24FCત䮄\uFFFDﾨ㮰\u229D쑍ഡ\uE0A9(length)] : throw new IOException("negative length");
            fileStream.Read(readBytes, 0, readBytes.Length);
          }
          else
          {
            fileStream.Seek((long) (blockNumber * (int) ushort.MaxValue), SeekOrigin.Begin);
            long length = fileStream.Length - fileStream.Position;
            readBytes = length >= 0L ? new byte[this.\uEF6A莖偂좻썰葮晲\uE3F9\uF2EE糍\u24FCત䮄\uFFFDﾨ㮰\u229D쑍ഡ\uE0A9(length)] : throw new IOException("negative length");
            fileStream.Read(readBytes, 0, readBytes.Length);
          }
        }
      }
      return true;
    }
    catch (ArgumentOutOfRangeException ex)
    {
      readBytes = new byte[0];
      this.LastError = "BlockNumber bigger than MaxBlocks";
    }
    catch (UnauthorizedAccessException ex)
    {
      readBytes = new byte[0];
      this.LastError = "Access denied";
    }
    catch (IOException ex)
    {
      readBytes = new byte[0];
      switch (ex)
      {
        case FileNotFoundException _:
          this.LastError = "File not found";
          break;
        case DirectoryNotFoundException _:
          this.LastError = "Directory not found";
          break;
        case PathTooLongException _:
          this.LastError = "Path is too long";
          break;
        default:
          this.LastError = "Unable to read from File Stream";
          break;
      }
    }
    return false;
  }

  public bool \uE179婎䠡\u287F\uFFFD稱垷䢝\uF49E덄\u2A52ﴰ\uEC0E눇譁欲ⴙ뗡롽豼(byte[] block, int blockNumber)
  {
    try
    {
      if (!File.Exists(this.Path) && blockNumber > 0)
        throw new FileNotFoundException();
      lock (this.\uE1F0\uF8CD앲캩\u088F뾚Ẇꋲ\u2A13餜闟ඥᴄÕ核ﺰ\u2CE6㣤ﴥ唀)
      {
        if (blockNumber == 0)
        {
          using (FileStream fileStream = File.Open(this.Path, FileMode.Create, FileAccess.Write))
          {
            fileStream.Seek(0L, SeekOrigin.Begin);
            fileStream.Write(block, 0, block.Length);
          }
          return true;
        }
        using (FileStream fileStream = File.Open(this.Path, FileMode.Append, FileAccess.Write))
        {
          fileStream.Seek((long) (blockNumber * (int) ushort.MaxValue), SeekOrigin.Begin);
          fileStream.Write(block, 0, block.Length);
        }
      }
      return true;
    }
    catch (UnauthorizedAccessException ex)
    {
      this.LastError = "Access denied";
    }
    catch (IOException ex)
    {
      switch (ex)
      {
        case FileNotFoundException _:
          this.LastError = "File not found";
          break;
        case DirectoryNotFoundException _:
          this.LastError = "Directory not found";
          break;
        case PathTooLongException _:
          this.LastError = "Path is too long";
          break;
        default:
          this.LastError = "Unable to write to File Stream";
          break;
      }
    }
    return false;
  }
}
