// Decompiled with JetBrains decompiler
// Type: 3wQ.To4
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0033wQ;
using \u0034ke;
using \u0034p7;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace \u0033wQ
{
  internal static class To4
  {
    private static Regex \u0032XO = new Regex("^(.*/)?([^/\\\\.]+/\\\\.\\\\./)(.+)$");
    private static Encoding \u00364b = Encoding.GetEncoding("UTF-8");

    public static long wHY([In] string obj0)
    {
      if (!File.Exists(obj0))
        throw new FileNotFoundException(string.Format("Could not find file '{0}'.", (object) obj0), obj0);
      FileShare share = FileShare.ReadWrite | FileShare.Delete;
      using (FileStream fileStream = File.Open(obj0, FileMode.Open, FileAccess.Read, share))
        return fileStream.Length;
    }

    private static string \u00363B([In] string obj0)
    {
      if (obj0.StartsWith("./"))
        obj0 = obj0.Substring(2);
      obj0 = obj0.Replace("/./", "/");
      obj0 = To4.\u0032XO.Replace(obj0, "$1$3");
      return obj0;
    }

    public static string \u0037j4([In] string obj0)
    {
      if (string.IsNullOrEmpty(obj0))
        return obj0;
      if (obj0.Length >= 2 && obj0[1] == ':' && obj0[2] == '\\')
        obj0 = obj0.Substring(3);
      obj0 = obj0.Replace('\\', '/');
      while (obj0.StartsWith("/"))
        obj0 = obj0.Substring(1);
      return To4.\u00363B(obj0);
    }

    public static string \u0033m7([In] string obj0)
    {
      List<string> stringList = new List<string>();
      int index1 = 0;
      string str1 = obj0;
      char[] chArray = new char[1]{ '/' };
      foreach (string str2 in str1.Split(chArray))
      {
        if (str2 == "..")
        {
          if (index1 != 0)
            --index1;
        }
        else
        {
          if (stringList.Count - 1 < index1)
            stringList.Add(str2);
          else
            stringList[index1] = str2;
          ++index1;
        }
      }
      obj0 = "";
      for (int index2 = 0; index2 < index1; ++index2)
      {
        if (index2 > 0)
          obj0 += "/";
        obj0 += stringList[index2];
      }
      return obj0;
    }

    internal static byte[] \u0038R5([In] string obj0, [In] Encoding obj1) => obj1.GetBytes(obj0);

    internal static byte[] \u00374A([In] string obj0)
    {
      Encoding encoding = (Encoding) null;
      try
      {
        encoding = Encoding.GetEncoding("IBM437");
      }
      catch (Exception ex)
      {
      }
      if (encoding == null)
      {
        try
        {
          encoding = Encoding.GetEncoding(1252);
        }
        catch (Exception ex)
        {
        }
      }
      return To4.\u0038R5(obj0, encoding);
    }

    internal static string \u0035Kw([In] byte[] obj0) => To4.U74(obj0, To4.\u00364b);

    internal static string U74([In] byte[] obj0, [In] Encoding obj1) => obj1.GetString(obj0);

    internal static int \u00352s([In] Stream obj0)
    {
      int num = 0;
      try
      {
        num = To4.H8D(obj0, "n/a");
      }
      catch (e1T ex)
      {
      }
      return num;
    }

    internal static int \u003498([In] Stream obj0)
    {
      int num = 0;
      try
      {
        num = To4.H8D(obj0, "n/a");
        if (num == 134695760)
        {
          obj0.Seek(12L, SeekOrigin.Current);
          num = To4.H8D(obj0, "n/a");
          if (num != 67324752)
          {
            obj0.Seek(8L, SeekOrigin.Current);
            num = To4.H8D(obj0, "n/a");
            if (num != 67324752)
            {
              obj0.Seek(-24L, SeekOrigin.Current);
              num = To4.H8D(obj0, "n/a");
            }
          }
        }
      }
      catch (e1T ex)
      {
      }
      return num;
    }

    internal static int \u0038m2([In] Stream obj0) => To4.H8D(obj0, "Could not read block - no data!  (position 0x{0:X8})");

    private static int H8D([In] Stream obj0, [In] string obj1)
    {
      byte[] buffer = new byte[4];
      if (obj0.Read(buffer, 0, buffer.Length) != buffer.Length)
        throw new e1T(string.Format(obj1, (object) obj0.Position));
      return (((int) buffer[3] * 256 + (int) buffer[2]) * 256 + (int) buffer[1]) * 256 + (int) buffer[0];
    }

    internal static long I5o([In] Stream obj0, [In] int obj1)
    {
      long position1 = obj0.Position;
      byte[] numArray = new byte[4]
      {
        (byte) (obj1 >> 24),
        (byte) ((obj1 & 16711680) >> 16),
        (byte) ((obj1 & 65280) >> 8),
        (byte) (obj1 & (int) byte.MaxValue)
      };
      byte[] buffer = new byte[65536];
      bool flag = false;
      do
      {
        int num = obj0.Read(buffer, 0, buffer.Length);
        if (num != 0)
        {
          for (int index = 0; index < num; ++index)
          {
            if ((int) buffer[index] == (int) numArray[3])
            {
              long position2 = obj0.Position;
              obj0.Seek((long) (index - num), SeekOrigin.Current);
              flag = To4.\u00352s(obj0) == obj1;
              if (!flag)
                obj0.Seek(position2, SeekOrigin.Begin);
              else
                break;
            }
          }
        }
        else
          break;
      }
      while (!flag);
      if (flag)
        return obj0.Position - position1 - 4L;
      obj0.Seek(position1, SeekOrigin.Begin);
      return -1;
    }

    internal static DateTime \u0032Gy([In] DateTime obj0)
    {
      if (obj0.Kind == DateTimeKind.Utc)
        return obj0;
      DateTime dateTime = obj0;
      if (DateTime.Now.IsDaylightSavingTime() && !obj0.IsDaylightSavingTime())
        dateTime = obj0 - new TimeSpan(1, 0, 0);
      else if (!DateTime.Now.IsDaylightSavingTime() && obj0.IsDaylightSavingTime())
        dateTime = obj0 + new TimeSpan(1, 0, 0);
      return dateTime;
    }

    internal static DateTime \u003162([In] int obj0)
    {
      if (obj0 == (int) ushort.MaxValue || obj0 == 0)
        return new DateTime(1995, 1, 1, 0, 0, 0, 0);
      int num1 = (int) (short) (obj0 & (int) ushort.MaxValue);
      short num2 = (short) (((long) obj0 & 4294901760L) >> 16);
      int year = 1980 + (((int) num2 & 65024) >> 9);
      int month = ((int) num2 & 480) >> 5;
      int day = (int) num2 & 31;
      int hour = (num1 & 63488) >> 11;
      int minute = (num1 & 2016) >> 5;
      int second = (num1 & 31) * 2;
      if (second >= 60)
      {
        ++minute;
        second = 0;
      }
      if (minute >= 60)
      {
        ++hour;
        minute = 0;
      }
      if (hour >= 24)
      {
        ++day;
        hour = 0;
      }
      DateTime dateTime = DateTime.Now;
      bool flag = false;
      try
      {
        dateTime = new DateTime(year, month, day, hour, minute, second, 0);
        flag = true;
      }
      catch (ArgumentOutOfRangeException ex1)
      {
        if (year == 1980 && (month == 0 || day == 0))
        {
          try
          {
            dateTime = new DateTime(1980, 1, 1, hour, minute, second, 0);
            flag = true;
          }
          catch (ArgumentOutOfRangeException ex2)
          {
            try
            {
              dateTime = new DateTime(1980, 1, 1, 0, 0, 0, 0);
              flag = true;
            }
            catch (ArgumentOutOfRangeException ex3)
            {
            }
          }
        }
        else
        {
          try
          {
            while (year < 1980)
              ++year;
            while (year > 2030)
              --year;
            while (month < 1)
              ++month;
            while (month > 12)
              --month;
            while (day < 1)
              ++day;
            while (day > 28)
              --day;
            while (minute < 0)
              ++minute;
            while (minute > 59)
              --minute;
            while (second < 0)
              ++second;
            while (second > 59)
              --second;
            dateTime = new DateTime(year, month, day, hour, minute, second, 0);
            flag = true;
          }
          catch (ArgumentOutOfRangeException ex4)
          {
          }
        }
      }
      if (!flag)
        throw new xZi(string.Format("Bad date/time format in the zip file. ({0})", (object) string.Format("y({0}) m({1}) d({2}) h({3}) m({4}) s({5})", (object) year, (object) month, (object) day, (object) hour, (object) minute, (object) second)));
      return DateTime.SpecifyKind(dateTime, DateTimeKind.Local);
    }

    internal static int kr9([In] DateTime obj0)
    {
      obj0 = obj0.ToLocalTime();
      return (int) (ushort) (obj0.Day & 31 | obj0.Month << 5 & 480 | obj0.Year - 1980 << 9 & 65024) << 16 | (int) (ushort) (obj0.Second / 2 & 31 | obj0.Minute << 5 & 2016 | obj0.Hour << 11 & 63488);
    }

    public static void \u003234(string _param0, out Stream _param1, out string _param2)
    {
      for (int index = 0; index < 3; ++index)
      {
        try
        {
          _param2 = Path.Combine(_param0, To4.PE5());
          _param1 = (Stream) new FileStream(_param2, FileMode.CreateNew);
          return;
        }
        catch (IOException ex)
        {
          if (index == 2)
            throw;
        }
      }
      throw new IOException();
    }

    public static string PE5() => "DotNetZip-" + Path.GetRandomFileName().Substring(0, 8) + ".tmp";

    internal static int qdS([In] Stream obj0, [In] byte[] obj1, [In] int obj2, [In] int obj3, [In] string obj4)
    {
      int num1 = 0;
      bool flag = false;
      int num2 = 0;
      do
      {
        try
        {
          num1 = obj0.Read(obj1, obj2, obj3);
          flag = true;
        }
        catch (IOException ex)
        {
          if (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).IsUnrestricted())
          {
            if (To4.M75((Exception) ex) != 2147942433U)
              throw new IOException(string.Format("Cannot read file {0}", (object) obj4), (Exception) ex);
            ++num2;
            if (num2 > 10)
              throw new IOException(string.Format("Cannot read file {0}, at offset 0x{1:X8} after 10 retries", (object) obj4, (object) obj2), (Exception) ex);
            Thread.Sleep(250 + num2 * 550);
          }
          else
            throw;
        }
      }
      while (!flag);
      return num1;
    }

    private static uint M75([In] Exception obj0) => (uint) Marshal.GetHRForException(obj0);
  }
}
