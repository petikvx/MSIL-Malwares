// Decompiled with JetBrains decompiler
// Type: Microsoft.Windows.PowerShell.GuiExe.Internal.GPowerShell
// Assembly: powershell_ise, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 8E61B2A9-9D1B-4E14-B095-A239B1610C71
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Virut.ce-b6360ae4521e85fbd7f2b938b3e5fe1e56f276f5d09db575e1615d4d070fb380.exe

using Microsoft.PowerShell;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Management.Automation;
using System.Reflection;
using System.Security;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace Microsoft.Windows.PowerShell.GuiExe.Internal
{
  internal static class GPowerShell
  {
    [TraceSource("PowerShellISEInitialization", "tracer for PowerShell ISE Initialization")]
    private static PSTraceSource tracer = PSTraceSource.GetTracer("PowerShellISEInitialization", "tracer for PowerShell ISE Initialization");

    private static Assembly LoadAssembly(string assemblyName)
    {
      Assembly assembly = (Assembly) null;
      Exception exceptionRecord = (Exception) null;
      try
      {
        assembly = Assembly.Load(assemblyName);
      }
      catch (FileNotFoundException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      catch (FileLoadException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      catch (BadImageFormatException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      if (exceptionRecord != null)
        GPowerShell.tracer.TraceException(exceptionRecord);
      return assembly;
    }

    private static string GetFullPath(string filePath)
    {
      if (Path.IsPathRooted(filePath))
        return filePath;
      Exception exceptionRecord = (Exception) null;
      try
      {
        filePath = Path.GetFullPath(filePath);
      }
      catch (ArgumentException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      catch (SecurityException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      catch (NotSupportedException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      catch (PathTooLongException ex)
      {
        exceptionRecord = (Exception) ex;
      }
      if (exceptionRecord == null)
        return filePath;
      GPowerShell.tracer.TraceException(exceptionRecord);
      return (string) null;
    }

    private static void ShowErrorMessage(string error)
    {
      int num = (int) MessageBox.Show(error, Strings.GraphicalPowerShell, MessageBoxButtons.OK, MessageBoxIcon.Hand, MessageBoxDefaultButton.Button1, Thread.CurrentThread.CurrentUICulture.TextInfo.IsRightToLeft ? MessageBoxOptions.RightAlign | MessageBoxOptions.RtlReading : (MessageBoxOptions) 0);
    }

    private static string[] GetFileNames(string commaSeparatedFiles)
    {
      bool flag = false;
      List<string> files = new List<string>();
      StringBuilder currentFile = new StringBuilder();
      foreach (char commaSeparatedFile in commaSeparatedFiles)
      {
        switch (commaSeparatedFile)
        {
          case '"':
            flag = !flag;
            break;
          case ',':
            if (!flag)
            {
              if (!GPowerShell.AddCurrentFile(currentFile, files))
                return (string[]) null;
              currentFile = new StringBuilder();
              break;
            }
            goto default;
          default:
            currentFile.Append(commaSeparatedFile);
            break;
        }
      }
      return !GPowerShell.AddCurrentFile(currentFile, files) ? (string[]) null : files.ToArray();
    }

    private static bool AddCurrentFile(StringBuilder currentFile, List<string> files)
    {
      string filePath = currentFile.ToString().Trim();
      if (filePath.Length != 0)
      {
        string fullPath = GPowerShell.GetFullPath(filePath);
        if (fullPath == null)
        {
          GPowerShell.ShowErrorMessage(Strings.Format(Strings.UnableToRetrieveFullPath, (object) filePath));
          return false;
        }
        files.Add(fullPath);
      }
      return true;
    }

    private static Mutex SafeWaitMutex(Mutex mutex)
    {
      try
      {
        mutex.WaitOne();
      }
      catch (AbandonedMutexException ex)
      {
        mutex.ReleaseMutex();
        mutex.Dispose();
        mutex = new Mutex(false, "GPowerShellInitializationMutexName");
        mutex.WaitOne();
      }
      return mutex;
    }

    [STAThread]
    private static int Main(string[] args)
    {
      Cursor.Current = Cursors.WaitCursor;
      WindowsErrorReporting.RegisterWindowsErrorReporting(false);
      Thread.CurrentThread.CurrentUICulture = NativeCultureResolver.UICulture;
      if (args.Length != 0 && args.Length != 1)
      {
        GPowerShell.ShowErrorMessage(Strings.Usage);
        return -1;
      }
      string[] strArray = (string[]) null;
      if (args.Length == 1 && args[0] != null)
      {
        strArray = GPowerShell.GetFileNames(args[0]);
        if (strArray == null)
          return -1;
      }
      if (!PsUtils.FrameworkRegistryInstallation.IsFrameworkInstalled(3, 0, 0))
      {
        int num = (int) new WPFError().ShowDialog();
        return -1;
      }
      NamedPipeServer namedPipeServer = (NamedPipeServer) null;
      Mutex initializationMutex = new Mutex(false, "GPowerShellInitializationMutexName");
      bool initializationMutexReleased = false;
      try
      {
        initializationMutex = GPowerShell.SafeWaitMutex(initializationMutex);
        bool flag = NamedPipeClient.SendString("fe886c82-edda-4016-bcbb-bd5788201338");
        if (flag && strArray != null)
        {
          foreach (string str in strArray)
          {
            if (!NamedPipeClient.SendString(str))
              return -1;
          }
          return 0;
        }
        Assembly assembly = GPowerShell.LoadAssembly("Microsoft.PowerShell.GPowerShell,Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35");
        if ((object) assembly == null)
        {
          GPowerShell.ShowErrorMessage(string.Format((IFormatProvider) CultureInfo.CurrentCulture, Strings.AssemblyCorruptOrMissing, new object[1]
          {
            (object) "Microsoft.PowerShell.GPowerShell,Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
          }));
          return -1;
        }
        System.Type type = assembly.GetType("Microsoft.Windows.PowerShell.Gui.Internal.Program");
        MethodInfo method1 = type.GetMethod("Initialize", BindingFlags.Static | BindingFlags.Public);
        int num;
        try
        {
          num = (int) method1.Invoke((object) null, new object[0]);
        }
        catch (TargetInvocationException ex)
        {
          throw ex;
        }
        if (num < 0)
          return -1;
        MethodInfo method2 = type.GetMethod("ShowMainWindow", BindingFlags.Static | BindingFlags.Public);
        namedPipeServer = new NamedPipeServer(type.GetMethod("OpenFiles", BindingFlags.Static | BindingFlags.Public));
        if (namedPipeServer.CreateNamedPipe(!flag))
          namedPipeServer.StartListening();
        try
        {
          SendOrPostCallback sendOrPostCallback = (SendOrPostCallback) (ignored =>
          {
            initializationMutexReleased = true;
            initializationMutex.ReleaseMutex();
          });
          method2.Invoke((object) null, new object[2]
          {
            (object) strArray,
            (object) sendOrPostCallback
          });
        }
        catch (TargetInvocationException ex)
        {
          throw ex;
        }
      }
      finally
      {
        if (!initializationMutexReleased)
          initializationMutex.ReleaseMutex();
        if (namedPipeServer != null)
        {
          initializationMutex = GPowerShell.SafeWaitMutex(initializationMutex);
          namedPipeServer.StopListening();
          initializationMutex.ReleaseMutex();
        }
        initializationMutex.Dispose();
        WindowsErrorReporting.WaitForPendingReports();
      }
      return Environment.ExitCode;
    }
  }
}
