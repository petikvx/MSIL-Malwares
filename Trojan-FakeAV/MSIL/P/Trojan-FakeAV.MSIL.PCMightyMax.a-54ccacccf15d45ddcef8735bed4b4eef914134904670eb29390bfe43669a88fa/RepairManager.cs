// Decompiled with JetBrains decompiler
// Type: PCMightyMax2009.Core.RepairManager
// Assembly: Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3F47A863-2C3E-450E-BD40-DE96FBBFDAD1
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Trojan-FakeAV.MSIL.PCMightyMax.a-54ccacccf15d45ddcef8735bed4b4eef914134904670eb29390bfe43669a88fa.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Threading;

namespace PCMightyMax2009.Core
{
  public class RepairManager
  {
    private static volatile RepairManager LocalInstance;
    private static object SyncLock = new object();

    public string CurrentError { get; set; }

    public int Progress { get; set; }

    public List<FailedError> FailedErrors { get; set; }

    public RepairCollection MostRecentRepairCollection { get; set; }

    public List<Error> ErrorsToRepair { get; set; }

    public RepairCollection RepairCollectionToReverse { get; set; }

    public bool Repairing { get; set; }

    private RepairManager()
    {
      this.FailedErrors = new List<FailedError>();
      this.MostRecentRepairCollection = new RepairCollection();
      this.Repairing = false;
    }

    public static RepairManager Instance
    {
      get
      {
        if (RepairManager.LocalInstance == null)
        {
          lock (RepairManager.SyncLock)
          {
            if (RepairManager.LocalInstance == null)
              RepairManager.LocalInstance = new RepairManager();
          }
        }
        return RepairManager.LocalInstance;
      }
    }

    public void RepairErrors()
    {
      this.Repairing = true;
      new RepairCollection().RepairDate = DateTime.Now;
      this.FailedErrors = new List<FailedError>();
      double count = (double) this.ErrorsToRepair.Count;
      double num = 0.0;
      using (List<Error>.Enumerator enumerator = this.ErrorsToRepair.GetEnumerator())
      {
        while (enumerator.MoveNext())
        {
          Error Error = enumerator.Current;
          this.CurrentError = num.ToString() + " of " + (object) count + ": " + Error.Description;
          ++num;
          this.Progress = (int) (num / count * 100.0);
          Repair RepairResult = (Repair) null;
          if (!Error.Ignore)
          {
            Thread thread = new Thread((ThreadStart) (() =>
            {
              try
              {
                RepairResult = Error.Repair();
              }
              catch
              {
              }
            }))
            {
              Priority = ThreadPriority.AboveNormal,
              Name = "Repair Thread - " + Error.Description
            };
            DateTime now = DateTime.Now;
            bool flag = false;
            thread.Start();
            while (!thread.Join(1000))
            {
              if (now < DateTime.Now.AddSeconds(-60.0))
              {
                flag = true;
                break;
              }
              Thread.Sleep(100);
            }
            if (flag || RepairResult == null || RepairResult.Failed)
            {
              this.FailedErrors.Add(new FailedError()
              {
                Error = RepairResult != null ? RepairResult.ErrorRepaired : Error,
                FailureCount = 1,
                Description = flag ? "Timed Out" : ""
              });
              ConfigurationManager.Instance.Store.IgnoredErrors.Add(Error);
            }
            this.MostRecentRepairCollection.Repairs.Add(RepairResult);
          }
        }
      }
      Stream serializationStream = (Stream) null;
      try
      {
        string str = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\PCMM2009\\diagnostic";
        if (!Directory.Exists(str))
          Directory.CreateDirectory(str);
        serializationStream = (Stream) new FileStream(Path.Combine(str, "last-repair"), FileMode.Create);
        new BinaryFormatter().Serialize(serializationStream, (object) this.MostRecentRepairCollection);
        serializationStream = (Stream) new FileStream(Path.Combine(str, "failed-errors"), FileMode.Create);
        new BinaryFormatter().Serialize(serializationStream, (object) this.FailedErrors);
      }
      catch
      {
      }
      finally
      {
        serializationStream?.Close();
      }
      this.Repairing = false;
    }

    public void ReverseRepairs()
    {
      if (this.RepairCollectionToReverse == null)
        return;
      double count = (double) this.RepairCollectionToReverse.Repairs.Count;
      double num = 0.0;
      this.Progress = 0;
      foreach (Repair repair in this.RepairCollectionToReverse.Repairs)
      {
        this.CurrentError = num.ToString() + " of " + (object) count + ": " + repair.ErrorRepaired.Description;
        ++num;
        this.Progress = (int) (num / count * 100.0);
        repair.Reverse();
      }
    }
  }
}
