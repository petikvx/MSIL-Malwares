// Decompiled with JetBrains decompiler
// Type: AjScript.TypeUtilities
// Assembly: FUNCD, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 38B3918C-7BBD-4048-BF6D-F5A856A1A18A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Convagent.gen-2f81e8b71640e7b5770deccc56c23d75240c34a5914dcb138ec2972e624a0f03.exe

using System;
using System.Collections.Generic;
using System.Reflection;

namespace AjScript
{
  public class TypeUtilities
  {
    private static bool referencedAssembliesLoaded;

    public static Type GetType(IContext context, string name)
    {
      object obj = context.GetValue(name);
      return obj != null && (object) (obj as Type) != null ? (Type) obj : TypeUtilities.GetType(name);
    }

    public static Type AsType(string name)
    {
      Type type = Type.GetType(name);
      if (type != (Type) null)
        return type;
      Type loadedAssemblies1 = TypeUtilities.GetTypeFromLoadedAssemblies(name);
      if (loadedAssemblies1 != (Type) null)
        return loadedAssemblies1;
      Type partialNamedAssembly = TypeUtilities.GetTypeFromPartialNamedAssembly(name);
      if (partialNamedAssembly != (Type) null)
        return partialNamedAssembly;
      TypeUtilities.LoadReferencedAssemblies();
      Type loadedAssemblies2 = TypeUtilities.GetTypeFromLoadedAssemblies(name);
      return loadedAssemblies2 != (Type) null ? loadedAssemblies2 : (Type) null;
    }

    public static Type GetType(string name)
    {
      Type type = TypeUtilities.AsType(name);
      return type != (Type) null ? type : throw new InvalidOperationException(string.Format("Unknown type '{0}'", (object) name));
    }

    public static bool IsNamespace(string name) => TypeUtilities.GetNamespaces().Contains(name);

    public static object InvokeTypeMember(Type type, string name, object[] parameters) => type.InvokeMember(name, BindingFlags.IgnoreCase | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy | BindingFlags.InvokeMethod | BindingFlags.GetField | BindingFlags.GetProperty, (Binder) null, (object) null, parameters);

    private static ICollection<string> GetNamespaces()
    {
      List<string> namespaces = new List<string>();
      TypeUtilities.LoadReferencedAssemblies();
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
      {
        foreach (Type type in assembly.GetTypes())
        {
          if (!namespaces.Contains(type.Namespace))
            namespaces.Add(type.Namespace);
        }
      }
      return (ICollection<string>) namespaces;
    }

    private static Type GetTypeFromPartialNamedAssembly(string name)
    {
      int length = name.LastIndexOf(".");
      if (length < 0)
        return (Type) null;
      string partialName = name.Substring(0, length);
      try
      {
        return Assembly.LoadWithPartialName(partialName).GetType(name);
      }
      catch
      {
        return (Type) null;
      }
    }

    private static Type GetTypeFromLoadedAssemblies(string name)
    {
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
      {
        Type type = assembly.GetType(name);
        if (type != (Type) null)
          return type;
      }
      return (Type) null;
    }

    private static void LoadReferencedAssemblies()
    {
      if (TypeUtilities.referencedAssembliesLoaded)
        return;
      List<string> loaded = new List<string>();
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        loaded.Add(assembly.GetName().Name);
      foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
        TypeUtilities.LoadReferencedAssemblies(assembly, loaded);
      TypeUtilities.referencedAssembliesLoaded = true;
    }

    private static void LoadReferencedAssemblies(Assembly assembly, List<string> loaded)
    {
      foreach (AssemblyName referencedAssembly in assembly.GetReferencedAssemblies())
      {
        if (!loaded.Contains(referencedAssembly.Name))
        {
          loaded.Add(referencedAssembly.Name);
          TypeUtilities.LoadReferencedAssemblies(Assembly.Load(referencedAssembly), loaded);
        }
      }
    }
  }
}
