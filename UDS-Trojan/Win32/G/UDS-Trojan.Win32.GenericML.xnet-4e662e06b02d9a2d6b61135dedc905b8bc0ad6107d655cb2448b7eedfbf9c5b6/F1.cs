// Decompiled with JetBrains decompiler
// Type: jd.F1
// Assembly: RuntimeFieldI, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3177D6BF-0678-437F-AD25-445C5521A270
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4e662e06b02d9a2d6b61135dedc905b8bc0ad6107d655cb2448b7eedfbf9c5b6.exe

using System;

namespace jd
{
  public struct F1
  {
    public float Xs;
    public float dt;
    public float u3;
    internal static object ki;

    public F1(float _param1, float _param2, float _param3)
    {
      gs.JD3Ei4();
      this.Xs = _param1;
      this.dt = _param2;
      this.u3 = _param3;
      int num = 0;
      if (false)
        goto label_3;
label_1:
      switch (num)
      {
        case 0:
          return;
        default:
          return;
      }
label_3:
      num = 0;
      goto label_1;
    }

    public static float LY(F1 _param0, F1 _param1) => (float) ((double) _param0.Xs * (double) _param1.Xs + (double) _param0.dt * (double) _param1.dt + (double) _param0.u3 * (double) _param1.u3);

    public static F1 wS(F1 _param0, F1 _param1) => new F1((float) ((double) _param0.dt * (double) _param1.u3 - (double) _param0.u3 * (double) _param1.dt), (float) ((double) _param0.u3 * (double) _param1.Xs - (double) _param0.Xs * (double) _param1.u3), (float) ((double) _param0.Xs * (double) _param1.dt - (double) _param0.dt * (double) _param1.Xs));

    public float yE() => (float) Math.Sqrt((double) this.Xs * (double) this.Xs + (double) this.dt * (double) this.dt + (double) this.u3 * (double) this.u3);

    public F1 O6()
    {
      float num = this.yE();
      return new F1(this.Xs / num, this.dt / num, this.u3 / num);
    }

    public static F1 operator +(F1 _param0, F1 _param1) => new F1(_param0.Xs + _param1.Xs, _param0.dt + _param1.dt, _param0.u3 + _param1.u3);

    public static F1 operator -(F1 _param0, F1 _param1) => new F1(_param0.Xs - _param1.Xs, _param0.dt - _param1.dt, _param0.u3 - _param1.u3);

    public static F1 operator *(F1 _param0, F1 _param1) => new F1(_param0.Xs * _param1.Xs, _param0.dt * _param1.dt, _param0.u3 * _param1.u3);

    public static F1 operator /(F1 _param0, F1 _param1) => new F1(_param0.Xs / _param1.Xs, _param0.dt / _param1.dt, _param0.u3 / _param1.u3);

    public static F1 operator *(F1 _param0, float _param1) => new F1(_param0.Xs * _param1, _param0.dt * _param1, _param0.u3 * _param1);

    public static F1 operator /(F1 _param0, float _param1) => new F1(_param0.Xs / _param1, _param0.dt / _param1, _param0.u3 / _param1);

    public static F1 operator *(float _param0, F1 _param1) => new F1(_param0 * _param1.Xs, _param0 * _param1.dt, _param0 * _param1.u3);

    public static F1 operator /(float _param0, F1 _param1) => new F1(_param0 / _param1.Xs, _param0 / _param1.dt, _param0 / _param1.u3);

    public static F1 operator -(F1 _param0) => new F1(-_param0.Xs, -_param0.dt, -_param0.u3);

    internal static bool kH() => F1.ki == null;

    internal static object ju() => F1.ki;
  }
}
