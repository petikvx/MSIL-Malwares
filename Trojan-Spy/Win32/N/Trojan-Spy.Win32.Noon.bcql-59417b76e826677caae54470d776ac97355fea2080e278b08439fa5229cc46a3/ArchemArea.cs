// Decompiled with JetBrains decompiler
// Type: mmxAH.ArchemArea
// Assembly: X509Ut, Version=1.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: 1E869FE1-6699-4C5A-A346-E3A268AF0CFF
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcql-59417b76e826677caae54470d776ac97355fea2080e278b08439fa5229cc46a3.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Forms;

namespace mmxAH
{
  public abstract class ArchemArea : Locathion
  {
    protected List<MonsterIndivid> monsters;
    protected short BlackArrow = -1;
    protected short WhiteArrow = -1;
    protected List<short> OtherLinks;
    protected byte Districkt = 0;
    protected bool isClosed;
    protected byte clues;
    private byte MPcost;
    protected string GateAndClueTitle;

    public ArchemArea()
    {
      this.monsters = new List<MonsterIndivid>();
      this.OtherLinks = new List<short>();
      this.MPcost = (byte) 1;
    }

    public string GetGateAndClueTitle() => this.GateAndClueTitle;

    public byte GetDistrickt() => this.Districkt;

    public short GetWhiteArrow() => this.WhiteArrow;

    public short GetBlackArrow() => this.BlackArrow;

    public void AddMonster(MonsterIndivid mon) => this.monsters.Add(mon);

    public void RemoveMonster(MonsterIndivid monster) => this.monsters.Remove(monster);

    public void RemoveAllMonsters() => this.monsters.Clear();

    public void SetClosed(bool closedStatus)
    {
      this.isClosed = closedStatus;
      if (!this.isClosed)
        return;
      foreach (MonsterIndivid monster in this.monsters)
        monster.SetLocathion(this.BlackArrow);
      foreach (int investigator in this.investigators)
        this.en.ActiveInvistigators[investigator].SetLocathion(this.BlackArrow);
    }

    public bool GetClosed() => this.isClosed;

    public void AddClues(byte count = 1) => this.clues += count;

    public void RemoveClues(byte count = 1)
    {
      if ((int) this.clues < (int) count)
        return;
      this.clues -= count;
    }

    public void RemoveAllClues() => this.clues = (byte) 0;

    public byte GetClues() => this.clues;

    protected bool FromText2(TextFileParser prs, TextFileParser text)
    {
      if (!this.FromText3(prs, text) || !byte.TryParse(prs.GetToken(), out this.Districkt))
        return false;
      this.GateAndClueTitle = text.GetCurString();
      if (this.GateAndClueTitle != null)
        return true;
      int num = (int) MessageBox.Show(" Could not load loc text . Code Name:" + this.codeName);
      return false;
    }

    public override void Move()
    {
      bool flag = false;
      List<IOOption> opts = new List<IOOption>();
      Investigator activeInvistigator = this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()];
      foreach (MonsterIndivid monster in this.monsters)
      {
        if (!monster.isEncountred)
        {
          monster.SetRPAfterEncounter(new Func(activeInvistigator.MoveChicle));
          opts.Add((IOOption) new IOOpthionWithoutParam(this.CreateMonsterString(monster), new Func(monster.BeginEncounter)));
        }
      }
      if (opts.Count == 0 && activeInvistigator.isCanMove)
      {
        flag = true;
        if (this.BlackArrow != (short) -1)
          this.CreateMoveOpthin(this.BlackArrow, activeInvistigator, opts);
        if (this.WhiteArrow != (short) -1 && (int) this.BlackArrow != (int) this.WhiteArrow)
          this.CreateMoveOpthin(this.WhiteArrow, activeInvistigator, opts);
        foreach (byte otherLink in this.OtherLinks)
          this.CreateMoveOpthin((short) otherLink, activeInvistigator, opts);
      }
      if (activeInvistigator.isMonsterImunity)
        flag = true;
      foreach (IOOption chooseOpthion in activeInvistigator.myTrigers.GetChooseOpthions(TrigerEvent.MoveAH, (short) activeInvistigator.MovementPoints))
        opts.Add(chooseOpthion);
      if (opts.Count == 0)
      {
        this.en.clock.EndMovementSegment();
      }
      else
      {
        if (flag)
          opts.Add((IOOption) new IOOpthionWithoutParam(this.en.sysstr.GetString(SSType.MovementEndPromt), new Func(this.en.clock.EndMovementSegment)));
        this.en.io.SetFormMode(FormMode.Map);
        this.en.io.StartChoose(opts, this.en.sysstr.GetString(SSType.RemainMP) + "  " + activeInvistigator.MovementPoints.ToString() + Environment.NewLine + this.en.sysstr.GetString(SSType.ChooseActhioPromt), this.en.sysstr.GetString(SSType.ChooseActhionButton));
      }
    }

    private string CreateMonsterString(MonsterIndivid monster) => this.en.sysstr.GetString(SSType.MonsterEncounter) + "  " + monster.GetTitle();

    private void CreateMoveOpthin(short loci, Investigator inv, List<IOOption> opts)
    {
      if ((int) ((ArchemArea) this.en.locs[(int) loci]).GetCost() > (int) inv.MovementPoints)
        return;
      string T = this.en.sysstr.GetString(SSType.MoveToPropos) + "  " + this.en.locs[(int) loci].GetMoveToTitle();
      opts.Add((IOOption) new IOOptionWithParam(T, new FuncWithParam(inv.MoveTo), loci));
    }

    public void SetCost(byte newCost) => this.MPcost = newCost;

    public byte GetCost() => this.MPcost;

    public override string ToString()
    {
      string str1 = base.ToString() + " district: " + this.Districkt.ToString() + " ba: ";
      string str2 = (this.BlackArrow == (short) -1 ? str1 + "none" : str1 + this.en.locs[(int) this.BlackArrow].GetCodeName()) + " wa: ";
      string str3 = this.WhiteArrow == (short) -1 ? str2 + "none" : str2 + this.en.locs[(int) this.WhiteArrow].GetCodeName();
      foreach (short otherLink in this.OtherLinks)
        str3 = str3 + " other: " + this.en.locs[(int) otherLink].GetCodeName();
      return str3;
    }

    protected void PrintClosed(byte label)
    {
      if (!this.isClosed)
        return;
      this.en.io.Print(this.en.sysstr.GetString(SSType.ClosedFact), isBold: true, label: label);
    }

    protected void PrintInvestAndMonsters(byte label)
    {
      this.en.io.Print(Environment.NewLine, (byte) 10, label: label);
      foreach (int investigator in this.investigators)
        this.en.io.Print(this.en.ActiveInvistigators[investigator].PrintToMap() + Environment.NewLine, isItalic: true, label: label);
      foreach (MonsterIndivid monster in this.monsters)
      {
        monster.PrintToMap(label);
        this.en.io.Print(Environment.NewLine, label: label);
      }
    }

    protected void ToBin2(BinaryWriter wr)
    {
      this.ToBin1(wr);
      wr.Write(this.Districkt);
      wr.Write(this.BlackArrow);
      wr.Write(this.WhiteArrow);
      wr.Write(this.OtherLinks.Count);
      foreach (short otherLink in this.OtherLinks)
        wr.Write(otherLink);
      wr.Write(this.GateAndClueTitle);
    }

    protected void FromBin2(BinaryReader rd)
    {
      this.FromBin1(rd);
      this.Districkt = rd.ReadByte();
      this.BlackArrow = rd.ReadInt16();
      this.WhiteArrow = rd.ReadInt16();
      int num = rd.ReadInt32();
      for (int index = 0; index < num; ++index)
        this.OtherLinks.Add(rd.ReadInt16());
      this.GateAndClueTitle = rd.ReadString();
    }

    public override void FromBin(BinaryReader rd) => this.FromBin2(rd);

    public override void ToBin(BinaryWriter wr) => this.ToBin2(wr);

    public void EndMovementClues(byte invest)
    {
      if (this.clues == (byte) 0)
        this.en.clock.NextPlayer();
      else if (this.en.pref.isAutoCluePickup)
      {
        this.AfterMoveClues2((short) this.clues);
      }
      else
      {
        List<IOOption> opts = new List<IOOption>();
        for (byte clues = this.clues; clues >= (byte) 1; --clues)
          opts.Add((IOOption) new IOOptionWithParam(clues.ToString(), new FuncWithParam(this.AfterMoveClues2), (short) clues));
        opts.Add((IOOption) new IOOpthionWithoutParam("0", new Func(this.en.clock.NextPlayer)));
        string question = this.en.sysstr.GetString(SSType.CluesPromtBegin) + "  " + this.en.sysstr.GetNumberClueToken((short) this.clues) + "  " + this.en.sysstr.GetString(SSType.CluesPromtEnd);
        this.en.io.StartChoose(opts, question, this.en.sysstr.GetString(SSType.ClueActhionButtonName));
      }
    }

    public void AfterMoveClues2(short number)
    {
      this.en.io.PrintToLog(this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].GetTitle() + "  " + this.en.sysstr.GetString(SSType.Get));
      this.en.io.PrintToLog(" " + this.en.sysstr.GetNumberClueToken(number), ChooseColor: "Green");
      this.en.io.PrintToLog(" " + this.GateAndClueTitle + ", ");
      this.clues -= (byte) number;
      this.en.ActiveInvistigators[(int) this.en.clock.GetCurPlayer()].AddClues((byte) number);
      this.en.clock.NextPlayer();
    }

    public virtual void MythosClues()
    {
      ++this.clues;
      this.en.io.PrintToLog(this.en.sysstr.GetString(SSType.ClueAppear));
      this.en.io.PrintToLog("  " + this.GateAndClueTitle + "." + Environment.NewLine, isItalic: true);
      if (this.investigators.Count == 0)
      {
        this.en.curs.resolvingMythos.Step3();
      }
      else
      {
        if (this.investigators.Count != 1)
          return;
        if (this.en.pref.isAutoCluePickup)
          this.MythosClues3((short) this.investigators[0]);
        else
          this.en.io.YesNoStart(this.en.sysstr.GetString(SSType.PickupClueOnMythosPromt), this.en.sysstr.GetString(SSType.Yes), this.en.sysstr.GetString(SSType.No), new Func(this.MythosClues2), new Func(this.en.curs.resolvingMythos.Step3));
      }
    }

    private void MythosClues2() => this.MythosClues3((short) this.investigators[0]);

    private void MythosClues3(short invNum)
    {
      this.en.io.PrintToLog(this.en.ActiveInvistigators[(int) invNum].GetTitle() + "  " + this.en.sysstr.GetString(SSType.Get));
      this.en.io.PrintToLog(" " + this.en.sysstr.GetNumberClueToken((short) 1), ChooseColor: "Green");
      this.en.io.PrintToLog(" " + this.GateAndClueTitle + ", ");
      --this.clues;
      this.en.ActiveInvistigators[(int) invNum].AddClues((byte) 1);
      this.en.curs.resolvingMythos.Step3();
    }

    public override void Reset()
    {
      base.Reset();
      this.clues = (byte) 0;
      this.MPcost = (byte) 1;
      this.monsters.Clear();
    }

    public override void WriteToSave(BinaryWriter wr)
    {
      wr.Write(this.clues);
      wr.Write(this.isClosed);
    }

    public override void ReadFromSave(BinaryReader rd)
    {
      this.clues = rd.ReadByte();
      this.isClosed = rd.ReadBoolean();
    }

    public bool MonseterPlaced()
    {
      MonsterIndivid m = this.en.MonstersCup.Draw();
      if (m == null)
      {
        this.en.ga.Awekeen();
        return false;
      }
      if (this.en.status.IsMonserToPlace(m))
      {
        m.AddToMap(this.LocathionIndex);
        this.en.io.PrintToLog(m.GetTitle(), isBold: true);
        this.en.io.PrintToLog("  " + this.en.sysstr.GetString(SSType.MonsterPlacedVerb));
        this.en.io.PrintToLog("  " + this.GateAndClueTitle + ".  ", isItalic: true);
        this.en.status.PrintMonserCountServer();
      }
      return true;
    }

    public List<short> GetLinkedLocs()
    {
      List<short> linkedLocs = new List<short>();
      if (this.WhiteArrow != (short) -1)
        linkedLocs.Add(this.WhiteArrow);
      if (this.BlackArrow != (short) -1 && (int) this.WhiteArrow != (int) this.BlackArrow)
        linkedLocs.Add(this.BlackArrow);
      foreach (short otherLink in this.OtherLinks)
        linkedLocs.Add(otherLink);
      return linkedLocs;
    }
  }
}
