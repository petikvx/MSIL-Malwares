// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Dispatcher.QueryStringConverter
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Runtime;
using System.Runtime.InteropServices;
using System.Xml;

namespace System.ServiceModel.Dispatcher
{
  [ComVisible(false)]
  public class QueryStringConverter
  {
    private Hashtable defaultSupportedQueryStringTypes;
    private Hashtable typeConverterCache;

    public QueryStringConverter()
    {
      this.defaultSupportedQueryStringTypes = new Hashtable();
      this.defaultSupportedQueryStringTypes.Add((object) typeof (byte), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (sbyte), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (short), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (int), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (long), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (ushort), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (uint), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (ulong), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (float), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (double), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (bool), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (char), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (Decimal), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (string), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (object), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (DateTime), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (TimeSpan), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (byte[]), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (Guid), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (Uri), (object) null);
      this.defaultSupportedQueryStringTypes.Add((object) typeof (DateTimeOffset), (object) null);
      this.typeConverterCache = new Hashtable();
    }

    public virtual bool CanConvert(Type type) => this.defaultSupportedQueryStringTypes.ContainsKey((object) type) || typeof (Enum).IsAssignableFrom(type) || this.GetStringConverter(type) != null;

    public virtual object ConvertStringToValue(string parameter, Type parameterType)
    {
      if (parameterType == (Type) null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (parameterType));
      switch (Type.GetTypeCode(parameterType))
      {
        case TypeCode.Boolean:
          return (object) (bool) (parameter == null ? 0 : (Convert.ToBoolean(parameter, (IFormatProvider) CultureInfo.InvariantCulture) ? 1 : 0));
        case TypeCode.Char:
          return (object) (char) (parameter == null ? 0 : (int) XmlConvert.ToChar(parameter));
        case TypeCode.SByte:
          return (object) (sbyte) (parameter == null ? 0 : (int) XmlConvert.ToSByte(parameter));
        case TypeCode.Byte:
          return (object) (byte) (parameter == null ? 0 : (int) XmlConvert.ToByte(parameter));
        case TypeCode.Int16:
          return (object) (short) (parameter == null ? 0 : (int) XmlConvert.ToInt16(parameter));
        case TypeCode.UInt16:
          return (object) (ushort) (parameter == null ? 0 : (int) XmlConvert.ToUInt16(parameter));
        case TypeCode.Int32:
          return typeof (Enum).IsAssignableFrom(parameterType) ? Enum.Parse(parameterType, parameter, true) : (object) (parameter == null ? 0 : XmlConvert.ToInt32(parameter));
        case TypeCode.UInt32:
          return (object) (uint) (parameter == null ? 0 : (int) XmlConvert.ToUInt32(parameter));
        case TypeCode.Int64:
          return (object) (parameter == null ? 0L : XmlConvert.ToInt64(parameter));
        case TypeCode.UInt64:
          return (object) (ulong) (parameter == null ? 0L : (long) XmlConvert.ToUInt64(parameter));
        case TypeCode.Single:
          return (object) (float) (parameter == null ? 0.0 : (double) XmlConvert.ToSingle(parameter));
        case TypeCode.Double:
          return (object) (parameter == null ? 0.0 : XmlConvert.ToDouble(parameter));
        case TypeCode.Decimal:
          return (object) (parameter == null ? 0M : XmlConvert.ToDecimal(parameter));
        case TypeCode.DateTime:
          return (object) (parameter == null ? new DateTime() : DateTime.Parse(parameter, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind));
        case TypeCode.String:
          return (object) parameter;
        default:
          if (parameterType == typeof (TimeSpan))
          {
            TimeSpan result;
            if (!TimeSpan.TryParse(parameter, out result))
              result = parameter == null ? new TimeSpan() : XmlConvert.ToTimeSpan(parameter);
            return (object) result;
          }
          if (parameterType == typeof (Guid))
            return (object) (parameter == null ? new Guid() : XmlConvert.ToGuid(parameter));
          if (parameterType == typeof (DateTimeOffset))
            return (object) (parameter == null ? new DateTimeOffset() : DateTimeOffset.Parse(parameter, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.RoundtripKind));
          if (parameterType == typeof (byte[]))
            return string.IsNullOrEmpty(parameter) ? (object) new byte[0] : (object) Convert.FromBase64String(parameter);
          if (parameterType == typeof (Uri))
            return string.IsNullOrEmpty(parameter) ? (object) null : (object) new Uri(parameter, UriKind.RelativeOrAbsolute);
          if (parameterType == typeof (object))
            return (object) parameter;
          // ISSUE: reference to a compiler-generated method
          return (this.GetStringConverter(parameterType) ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new NotSupportedException(SR2.GetString(SR2.TypeNotSupportedByQueryStringConverter, (object) parameterType.ToString(), (object) this.GetType().Name)))).ConvertFromInvariantString(parameter);
      }
    }

    public virtual string ConvertValueToString(object parameter, Type parameterType)
    {
      if (parameterType == (Type) null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (parameterType));
      if (parameterType.IsValueType && parameter == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (parameter));
      switch (Type.GetTypeCode(parameterType))
      {
        case TypeCode.Boolean:
          return XmlConvert.ToString((bool) parameter);
        case TypeCode.Char:
          return XmlConvert.ToString((char) parameter);
        case TypeCode.SByte:
          return XmlConvert.ToString((sbyte) parameter);
        case TypeCode.Byte:
          return XmlConvert.ToString((byte) parameter);
        case TypeCode.Int16:
          return XmlConvert.ToString((short) parameter);
        case TypeCode.UInt16:
          return XmlConvert.ToString((ushort) parameter);
        case TypeCode.Int32:
          return typeof (Enum).IsAssignableFrom(parameterType) ? Enum.Format(parameterType, parameter, "G") : XmlConvert.ToString((int) parameter);
        case TypeCode.UInt32:
          return XmlConvert.ToString((uint) parameter);
        case TypeCode.Int64:
          return XmlConvert.ToString((long) parameter);
        case TypeCode.UInt64:
          return XmlConvert.ToString((ulong) parameter);
        case TypeCode.Single:
          return XmlConvert.ToString((float) parameter);
        case TypeCode.Double:
          return XmlConvert.ToString((double) parameter);
        case TypeCode.Decimal:
          return XmlConvert.ToString((Decimal) parameter);
        case TypeCode.DateTime:
          return XmlConvert.ToString((DateTime) parameter, XmlDateTimeSerializationMode.RoundtripKind);
        case TypeCode.String:
          return (string) parameter;
        default:
          if (parameterType == typeof (TimeSpan))
            return XmlConvert.ToString((TimeSpan) parameter);
          if (parameterType == typeof (Guid))
            return XmlConvert.ToString((Guid) parameter);
          if (parameterType == typeof (DateTimeOffset))
            return XmlConvert.ToString((DateTimeOffset) parameter);
          if (parameterType == typeof (byte[]))
            return parameter == null ? (string) null : Convert.ToBase64String((byte[]) parameter, Base64FormattingOptions.None);
          if (parameterType == typeof (Uri) || parameterType == typeof (object))
            return parameter == null ? (string) null : Convert.ToString(parameter, (IFormatProvider) CultureInfo.InvariantCulture);
          // ISSUE: reference to a compiler-generated method
          return (this.GetStringConverter(parameterType) ?? throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new NotSupportedException(SR2.GetString(SR2.TypeNotSupportedByQueryStringConverter, (object) parameterType.ToString(), (object) this.GetType().Name)))).ConvertToInvariantString(parameter);
      }
    }

    private TypeConverter GetStringConverter(Type parameterType)
    {
      if (this.typeConverterCache.ContainsKey((object) parameterType))
        return (TypeConverter) this.typeConverterCache[(object) parameterType];
      if (parameterType.GetCustomAttributes(typeof (TypeConverterAttribute), true) is TypeConverterAttribute[] customAttributes)
      {
        for (int index = 0; index < customAttributes.Length; ++index)
        {
          Type type = Type.GetType(customAttributes[index].ConverterTypeName, false, true);
          if (type != (Type) null)
          {
            TypeConverter stringConverter = (TypeConverter) null;
            Exception exception = (Exception) null;
            try
            {
              stringConverter = (TypeConverter) Activator.CreateInstance(type);
            }
            catch (TargetInvocationException ex)
            {
              exception = (Exception) ex;
            }
            catch (MemberAccessException ex)
            {
              exception = (Exception) ex;
            }
            catch (TypeLoadException ex)
            {
              exception = (Exception) ex;
            }
            catch (COMException ex)
            {
              exception = (Exception) ex;
            }
            catch (InvalidComObjectException ex)
            {
              exception = (Exception) ex;
            }
            finally
            {
              if (exception != null)
              {
                if (Fx.IsFatal(exception))
                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(exception);
                DiagnosticUtility.TraceHandledException(exception, TraceEventType.Warning);
              }
            }
            if (stringConverter != null && stringConverter.CanConvertTo(typeof (string)) && stringConverter.CanConvertFrom(typeof (string)))
            {
              this.typeConverterCache.Add((object) parameterType, (object) stringConverter);
              return stringConverter;
            }
          }
        }
      }
      return (TypeConverter) null;
    }
  }
}
