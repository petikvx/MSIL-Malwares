// Decompiled with JetBrains decompiler
// Type: .
// Assembly: !, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 557A2E9F-07C1-4548-9113-1357BAD65653
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan.MSIL.Crypt.hnss-93ea8c725747bfd67919febc6ed26643a8654b90a112977a3d914bf034f69ed8.exe

using \u0001\u0002;
using \u0001\u0003;
using \u0001\u0004;
using \u0001\u0005;
using System;
using System.IO;

namespace \u0001\u0004
{
  public class \u0006\u0005 : \u0002\u0004, \u0002\u0007
  {
    private \u0004\u0002 m_\u0004\u0003 = new \u0004\u0002();
    private \u0006\u0005 \u0006\u0002 = new \u0006\u0005();
    private \u0007\u0001[] \u0005\u0016 = new \u0007\u0001[new IntPtr(192)];
    private \u0007\u0001[] \u0005\u0018 = new \u0007\u0001[new IntPtr(12)];
    private \u0007\u0001[] \u0005\u0019 = new \u0007\u0001[new IntPtr(12)];
    private \u0007\u0001[] \u0005\u001A = new \u0007\u0001[new IntPtr(12)];
    private \u0007\u0001[] \u0005\u001B = new \u0007\u0001[new IntPtr(12)];
    private \u0007\u0001[] \u0005\u0017 = new \u0007\u0001[new IntPtr(192)];
    private \u0007\u0007[] \u0006 = new \u0007\u0007[new IntPtr(4)];
    private \u0007\u0001[] \u0005\u001F = new \u0007\u0001[new IntPtr(114)];
    private \u0007\u0007 \u0005\u001E = new \u0007\u0007(4);
    private \u0006\u0005.\u0006\u0004 \u0005\u001C = new \u0006\u0005.\u0006\u0004();
    private \u0006\u0005.\u0006\u0004 \u0006\u0003 = new \u0006\u0005.\u0006\u0004();
    private \u0006\u0005.\u0006\u000C \u0005\u001D = new \u0006\u0005.\u0006\u000C();
    private uint \u0005\u0014;
    private uint \u0005\u0015;
    private uint \u0006\u0001;

    public \u0006\u0005()
    {
      this.\u0005\u0014 = uint.MaxValue;
      for (int index = 0; index < 4; ++index)
        this.\u0006[index] = new \u0007\u0007(6);
    }

    private void \u0005\u0010(uint dictionarySize)
    {
      if ((int) this.\u0005\u0014 == (int) dictionarySize)
        return;
      this.\u0005\u0014 = dictionarySize;
      this.\u0005\u0015 = Math.Max(this.\u0005\u0014, 1U);
      this.m_\u0004\u0003.\u0002\u0010(Math.Max(this.\u0005\u0015, 4096U));
    }

    private void \u0005\u0011(int lp, int lc)
    {
      if (lp > 8)
        throw new \u0002\u0005();
      if (lc > 8)
        throw new \u0002\u0005();
      this.\u0005\u001D.\u0002\u0010(lp, lc);
    }

    private void \u0005\u0013(int pb)
    {
      if (pb > 4)
        throw new \u0002\u0005();
      uint numPosStates = (uint) (1 << pb);
      this.\u0005\u001C.\u0002\u0010(numPosStates);
      this.\u0006\u0003.\u0002\u0010(numPosStates);
      this.\u0006\u0001 = numPosStates - 1U;
    }

    private void \u0001\u001B(Stream inStream, Stream outStream)
    {
      this.\u0006\u0002.\u0001\u001B(inStream);
      this.m_\u0004\u0003.\u0001\u001B(outStream);
      for (uint index1 = 0; index1 < 12U; ++index1)
      {
        for (uint index2 = 0; index2 <= this.\u0006\u0001; ++index2)
        {
          uint index3 = (index1 << 4) + index2;
          this.\u0005\u0016[(IntPtr) index3].\u0001\u001B();
          this.\u0005\u0017[(IntPtr) index3].\u0001\u001B();
        }
        this.\u0005\u0018[(IntPtr) index1].\u0001\u001B();
        this.\u0005\u0019[(IntPtr) index1].\u0001\u001B();
        this.\u0005\u001A[(IntPtr) index1].\u0001\u001B();
        this.\u0005\u001B[(IntPtr) index1].\u0001\u001B();
      }
      this.\u0005\u001D.\u0001\u001B();
      for (uint index = 0; index < 4U; ++index)
        this.\u0006[(IntPtr) index].\u0001\u001B();
      for (uint index = 0; index < 114U; ++index)
        this.\u0005\u001F[(IntPtr) index].\u0001\u001B();
      this.\u0005\u001C.\u0001\u001B();
      this.\u0006\u0003.\u0001\u001B();
      this.\u0005\u001E.\u0001\u001B();
    }

    public void \u0007\u000D(
      Stream inStream,
      Stream outStream,
      long inSize,
      long outSize,
      \u0002\u0002 progress)
    {
      this.\u0001\u001B(inStream, outStream);
      \u0004\u000A.\u0005\u0012 obj = new \u0004\u000A.\u0005\u0012();
      obj.\u0001\u001B();
      uint distance = 0;
      uint num1 = 0;
      uint num2 = 0;
      uint num3 = 0;
      ulong pos = 0;
      ulong num4 = (ulong) outSize;
      if (pos < num4)
      {
        if (this.\u0005\u0016[(IntPtr) (obj.\u000B << 4)].\u0007\u000C(this.\u0006\u0002) != 0U)
          throw new \u0002\u0001();
        obj.\u0005\u000A();
        this.m_\u0004\u0003.\u0004\u0007(this.\u0005\u001D.\u0006\u000D(this.\u0006\u0002, 0U, (byte) 0));
        ++pos;
      }
      while (pos < num4)
      {
        uint posState = (uint) pos & this.\u0006\u0001;
        if (this.\u0005\u0016[(IntPtr) ((obj.\u000B << 4) + posState)].\u0007\u000C(this.\u0006\u0002) == 0U)
        {
          byte prevByte = this.m_\u0004\u0003.\u0004\u0006(0U);
          this.m_\u0004\u0003.\u0004\u0007(obj.\u0005\u0008() ? this.\u0005\u001D.\u0006\u000D(this.\u0006\u0002, (uint) pos, prevByte) : this.\u0005\u001D.\u0006\u000E(this.\u0006\u0002, (uint) pos, prevByte, this.m_\u0004\u0003.\u0004\u0006(distance)));
          obj.\u0005\u000A();
          ++pos;
        }
        else
        {
          uint len;
          if (this.\u0005\u0018[(IntPtr) obj.\u000B].\u0007\u000C(this.\u0006\u0002) == 1U)
          {
            if (this.\u0005\u0019[(IntPtr) obj.\u000B].\u0007\u000C(this.\u0006\u0002) == 0U)
            {
              if (this.\u0005\u0017[(IntPtr) ((obj.\u000B << 4) + posState)].\u0007\u000C(this.\u0006\u0002) == 0U)
              {
                obj.\u0005\u000D();
                this.m_\u0004\u0003.\u0004\u0007(this.m_\u0004\u0003.\u0004\u0006(distance));
                ++pos;
                continue;
              }
            }
            else
            {
              uint num5;
              if (this.\u0005\u001A[(IntPtr) obj.\u000B].\u0007\u000C(this.\u0006\u0002) == 0U)
              {
                num5 = num1;
              }
              else
              {
                if (this.\u0005\u001B[(IntPtr) obj.\u000B].\u0007\u000C(this.\u0006\u0002) == 0U)
                {
                  num5 = num2;
                }
                else
                {
                  num5 = num3;
                  num3 = num2;
                }
                num2 = num1;
              }
              num1 = distance;
              distance = num5;
            }
            len = this.\u0006\u0003.\u0007\u000C(this.\u0006\u0002, posState) + 2U;
            obj.\u0005\u000C();
          }
          else
          {
            num3 = num2;
            num2 = num1;
            num1 = distance;
            len = 2U + this.\u0005\u001C.\u0007\u000C(this.\u0006\u0002, posState);
            obj.\u0005\u000B();
            uint num6 = this.\u0006[(IntPtr) \u0004\u000A.\u0004\u000C(len)].\u0007\u000C(this.\u0006\u0002);
            if (num6 >= 4U)
            {
              int num7 = (int) (num6 >> 1) - 1;
              uint num8 = (uint) ((2 | (int) num6 & 1) << num7);
              distance = num6 >= 14U ? num8 + (this.\u0006\u0002.\u0006\u001B(num7 - 4) << 4) + this.\u0005\u001E.\u0007\u000A(this.\u0006\u0002) : num8 + \u0007\u0007.\u0007\u000A(this.\u0005\u001F, (uint) ((int) num8 - (int) num6 - 1), this.\u0006\u0002, num7);
            }
            else
              distance = num6;
          }
          if ((ulong) distance >= pos || distance >= this.\u0005\u0015)
          {
            if (distance != uint.MaxValue)
              throw new \u0002\u0001();
            break;
          }
          this.m_\u0004\u0003.\u0004\u0004(distance, len);
          pos += (ulong) len;
        }
      }
      this.m_\u0004\u0003.\u0004\u0005();
      this.m_\u0004\u0003.\u0002\u0017();
      this.\u0006\u0002.\u0002\u0017();
    }

    public void \u0002\u000C(byte[] properties)
    {
      if (properties.Length < 5)
        throw new \u0002\u0005();
      int lc = (int) properties[0] % 9;
      int num = (int) properties[0] / 9;
      int lp = num % 5;
      int pb = num / 5;
      if (pb > 4)
        throw new \u0002\u0005();
      uint dictionarySize = 0;
      for (int index = 0; index < 4; ++index)
        dictionarySize += (uint) properties[1 + index] << index * 8;
      this.\u0005\u0010(dictionarySize);
      this.\u0005\u0011(lp, lc);
      this.\u0005\u0013(pb);
    }

    private class \u0006\u0004
    {
      private \u0007\u0001 \u0006\u0007 = new \u0007\u0001();
      private \u0007\u0001 \u0006\u0006 = new \u0007\u0001();
      private \u0007\u0007[] \u0006\u0009 = new \u0007\u0007[new IntPtr(16)];
      private \u0007\u0007[] \u0006\u000A = new \u0007\u0007[new IntPtr(16)];
      private \u0007\u0007 \u0006\u0008 = new \u0007\u0007(8);
      private uint \u0006\u000B;

      public void \u0002\u0010(uint numPosStates)
      {
        for (uint index = this.\u0006\u000B; index < numPosStates; ++index)
        {
          this.\u0006\u0009[(IntPtr) index] = new \u0007\u0007(3);
          this.\u0006\u000A[(IntPtr) index] = new \u0007\u0007(3);
        }
        this.\u0006\u000B = numPosStates;
      }

      public void \u0001\u001B()
      {
        this.\u0006\u0007.\u0001\u001B();
        for (uint index = 0; index < this.\u0006\u000B; ++index)
        {
          this.\u0006\u0009[(IntPtr) index].\u0001\u001B();
          this.\u0006\u000A[(IntPtr) index].\u0001\u001B();
        }
        this.\u0006\u0006.\u0001\u001B();
        this.\u0006\u0008.\u0001\u001B();
      }

      public uint \u0007\u000C(\u0006\u0005 rangeDecoder, uint posState)
      {
        if (this.\u0006\u0007.\u0007\u000C(rangeDecoder) == 0U)
          return this.\u0006\u0009[(IntPtr) posState].\u0007\u000C(rangeDecoder);
        uint num = 8;
        return this.\u0006\u0006.\u0007\u000C(rangeDecoder) != 0U ? num + 8U + this.\u0006\u0008.\u0007\u000C(rangeDecoder) : num + this.\u0006\u000A[(IntPtr) posState].\u0007\u000C(rangeDecoder);
      }
    }

    private class \u0006\u000C
    {
      private \u0006\u0005.\u0006\u000C.\u0006\u0014[] \u0006\u0010;
      private int \u0006\u0012;
      private int \u0006\u0011;
      private uint \u0006\u0013;

      public void \u0002\u0010(int numPosBits, int numPrevBits)
      {
        if (this.\u0006\u0010 != null && this.\u0006\u0012 == numPrevBits && this.\u0006\u0011 == numPosBits)
          return;
        this.\u0006\u0011 = numPosBits;
        this.\u0006\u0013 = (uint) ((1 << numPosBits) - 1);
        this.\u0006\u0012 = numPrevBits;
        uint length = (uint) (1 << this.\u0006\u0012 + this.\u0006\u0011);
        this.\u0006\u0010 = new \u0006\u0005.\u0006\u000C.\u0006\u0014[(IntPtr) length];
        for (uint index = 0; index < length; ++index)
          this.\u0006\u0010[(IntPtr) index].\u0002\u0010();
      }

      public void \u0001\u001B()
      {
        uint num = (uint) (1 << this.\u0006\u0012 + this.\u0006\u0011);
        for (uint index = 0; index < num; ++index)
          this.\u0006\u0010[(IntPtr) index].\u0001\u001B();
      }

      private uint \u0006\u000F(uint pos, byte prevByte) => (uint) ((((int) pos & (int) this.\u0006\u0013) << this.\u0006\u0012) + ((int) prevByte >> 8 - this.\u0006\u0012));

      public byte \u0006\u000D(\u0006\u0005 rangeDecoder, uint pos, byte prevByte) => this.\u0006\u0010[(IntPtr) this.\u0006\u000F(pos, prevByte)].\u0006\u000D(rangeDecoder);

      public byte \u0006\u000E(\u0006\u0005 rangeDecoder, uint pos, byte prevByte, byte matchByte) => this.\u0006\u0010[(IntPtr) this.\u0006\u000F(pos, prevByte)].\u0006\u000E(rangeDecoder, matchByte);

      private struct \u0006\u0014
      {
        private \u0007\u0001[] \u0006\u0015;

        public void \u0002\u0010() => this.\u0006\u0015 = new \u0007\u0001[768];

        public void \u0001\u001B()
        {
          for (int index = 0; index < 768; ++index)
            this.\u0006\u0015[index].\u0001\u001B();
        }

        public byte \u0006\u000D(\u0006\u0005 rangeDecoder)
        {
          uint index = 1;
          do
          {
            index = index << 1 | this.\u0006\u0015[(IntPtr) index].\u0007\u000C(rangeDecoder);
          }
          while (index < 256U);
          return (byte) index;
        }

        public byte \u0006\u000E(\u0006\u0005 rangeDecoder, byte matchByte)
        {
          uint index = 1;
          do
          {
            uint num1 = (uint) ((int) matchByte >> 7 & 1);
            matchByte <<= 1;
            uint num2 = this.\u0006\u0015[(IntPtr) ((uint) (1 + (int) num1 << 8) + index)].\u0007\u000C(rangeDecoder);
            index = index << 1 | num2;
            if ((int) num1 != (int) num2)
            {
              while (index < 256U)
                index = index << 1 | this.\u0006\u0015[(IntPtr) index].\u0007\u000C(rangeDecoder);
              break;
            }
          }
          while (index < 256U);
          return (byte) index;
        }
      }
    }
  }
}
