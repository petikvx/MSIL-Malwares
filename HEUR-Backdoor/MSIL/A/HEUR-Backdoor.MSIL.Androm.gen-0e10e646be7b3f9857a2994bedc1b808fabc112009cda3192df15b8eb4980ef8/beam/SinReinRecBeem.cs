// Decompiled with JetBrains decompiler
// Type: beam.SinReinRecBeem
// Assembly: MuiResourceTypeIdIntEn, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2C7C9528-88C0-45FF-AB6A-2AC0C29EABCB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-0e10e646be7b3f9857a2994bedc1b808fabc112009cda3192df15b8eb4980ef8.exe

using beam.forms;
using beam.helper;
using beam.reinforcement;
using System;

namespace beam
{
  public class SinReinRecBeem : RenforcedBeem
  {
    private double d;
    private double h;
    private double equivalentX;
    private double icr;
    private double muS;
    private double muSmax;
    private double mcr;
    private double y;
    private double x;
    private double asb;
    private double asMax;
    private double teta;
    private double rM;
    private double eRM;

    public SinReinRecBeem(double h, double l, double b, double r, int n)
      : this(30.0, 420.0, h, l, b, r, n)
    {
    }

    public SinReinRecBeem(double cP, double iF, double h, double l, double b, double r, int n)
      : this(cP, iF, h, l, b, 210000.0, r, n, 5.0, (byte) 1)
    {
    }

    public SinReinRecBeem(
      double cP,
      double iF,
      double h,
      double l,
      double b,
      double es,
      double r,
      int n,
      double a,
      byte choese)
      : base(cP, iF, b, l, es)
    {
      this.H = h;
      this.Form = (Form) new Rectangle(h, l, b);
      this.Reinforcement = (Reinforcement) new SingleReinforcement(r, n);
      this.D = h - a;
      this.MuS = this.calcMuS(this.getSpaceTensileReinforcement(), this.D);
      this.y = this.calcY();
      this.x = this.getX();
      this.asb = this.calcAsb(this.D);
      this.asMax = this.calcAsMax();
      this.muSmax = this.calcMuSmax();
      this.teta = this.getTeta(choese, this.X, this.D);
      this.rM = this.calcRM();
      this.eRM = this.RM * this.Teta;
      this.Mcr = this.calcMcr();
      this.equivalentX = this.depthNeutralAxisSectionEquivalent(this.getSpaceTensileReinforcement(), 0.0, this.D, 0.0);
      this.icr = this.momentInertiaEquivalentCrackedSection(this.EquivalentX, this.getSpaceTensileReinforcement(), 0.0, this.D, 0.0);
    }

    public double H
    {
      get => this.h;
      private set => this.h = value > 0.0 ? value : throw new ArgumentException("H can't be <= 0 ");
    }

    public double MuSmax => this.muSmax;

    public override double ERM => this.eRM;

    public override double Teta => this.teta;

    public override double AsMax => this.asMax;

    public double Asb => this.asb;

    public double Y => this.y;

    public double MuS
    {
      get => this.muS;
      private set
      {
        if (value >= 1.0)
          throw new ArgumentException("As can't be >=  " + this.getCrossSectionalArea().ToString());
        this.muS = value >= this.MuSmin ? value : throw new ArgumentException("Mus can't be < " + this.MuSmin.ToString());
      }
    }

    public double D
    {
      get => this.d;
      private set => this.d = value > 0.0 ? value : throw new ArgumentException("D can't be  <= 0 ");
    }

    public double EquivalentX => this.equivalentX;

    public double Icr => this.icr;

    public override double Mcr
    {
      get => this.mcr;
      protected set => this.mcr = value;
    }

    public double X => this.x;

    public double RM => this.rM;

    private double calcAsMax() => this.Asb / 2.0;

    private double calcMuSmax() => this.AsMax / (this.B * this.D);

    protected override double calcY() => this.muS < this.MuSb ? this.getSpaceTensileReinforcement() * this.IF / (this.B * 0.85 * this.CP) : (this.y = MathHelper.sESDRP(0.85 * this.CP / (this.MuS * this.Es * 0.003), this.D, -(this.B1 * Math.Pow(this.D, 2.0))));

    public override double getIe(double Ma) => this.Ie(Ma, this.Mcr, this.getMomentInertiaNonCrackedSection(), this.Icr);

    protected override double calcRM() => 0.85 * this.CP * this.B * this.Y * (this.D - this.Y / 2.0);

    public override string getFailureWay() => this.MuS < 1.5 * this.MuSmax ? "Ductile failure" : "Brittle faliure";
  }
}
