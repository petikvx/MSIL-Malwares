// Decompiled with JetBrains decompiler
// Type: Mono.Options.StringCoda
// Assembly: FUNCD, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 38B3918C-7BBD-4048-BF6D-F5A856A1A18A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Convagent.gen-2f81e8b71640e7b5770deccc56c23d75240c34a5914dcb138ec2972e624a0f03.exe

using System;
using System.Collections.Generic;

namespace Mono.Options
{
  internal static class StringCoda
  {
    public static IEnumerable<string> WrappedLines(string self, params int[] widths)
    {
      IEnumerable<int> widths1 = (IEnumerable<int>) widths;
      return StringCoda.WrappedLines(self, widths1);
    }

    public static IEnumerable<string> WrappedLines(string self, IEnumerable<int> widths) => widths != null ? StringCoda.CreateWrappedLinesIterator(self, widths) : throw new ArgumentNullException(nameof (widths));

    private static IEnumerable<string> CreateWrappedLinesIterator(
      string self,
      IEnumerable<int> widths)
    {
      if (string.IsNullOrEmpty(self))
      {
        yield return string.Empty;
      }
      else
      {
        using (IEnumerator<int> ewidths = widths.GetEnumerator())
        {
          bool? hw = new bool?();
          int width = StringCoda.GetNextWidth(ewidths, int.MaxValue, ref hw);
          int num1 = 0;
          int end;
          do
          {
            end = StringCoda.GetLineEnd(num1, width, self);
            char c = self[end - 1];
            if (char.IsWhiteSpace(c))
              --end;
            int num2 = end == self.Length ? 0 : (!StringCoda.IsEolChar(c) ? 1 : 0);
            string str = "";
            if (num2 != 0)
            {
              --end;
              str = "-";
            }
            yield return self.Substring(num1, end - num1) + str;
            num1 = end;
            if (char.IsWhiteSpace(c))
              ++num1;
            width = StringCoda.GetNextWidth(ewidths, width, ref hw);
          }
          while (end < self.Length);
          hw = new bool?();
        }
      }
    }

    private static int GetNextWidth(IEnumerator<int> ewidths, int curWidth, ref bool? eValid)
    {
      if (eValid.HasValue && (!eValid.HasValue || !eValid.Value))
        return curWidth;
      curWidth = (eValid = new bool?(ewidths.MoveNext())).Value ? ewidths.Current : curWidth;
      return curWidth >= ".-".Length ? curWidth : throw new ArgumentOutOfRangeException("widths", string.Format("Element must be >= {0}, was {1}.", (object) ".-".Length, (object) curWidth));
    }

    private static bool IsEolChar(char c) => !char.IsLetterOrDigit(c);

    private static int GetLineEnd(int start, int length, string description)
    {
      int num1 = Math.Min(start + length, description.Length);
      int num2 = -1;
      for (int index = start; index < num1; ++index)
      {
        if (description[index] == '\n')
          return index + 1;
        if (StringCoda.IsEolChar(description[index]))
          num2 = index + 1;
      }
      return num2 == -1 || num1 == description.Length ? num1 : num2;
    }
  }
}
