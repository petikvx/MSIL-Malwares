// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: msvcm80, Version=8.0.50727.762, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 0C7A0EB3-B31C-48A8-9905-A26D929E091B
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Nimnul.e-16099460d97c325ace05ac2f2f8fb1aaf751cf2f741bf61321f378dfe778f712.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using msclr._detail;
using std;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static __FnPtr<int (_exception*)> pusermatherr;
  internal static __FnPtr<void ()> \u003FA0xedf1fba0\u002Epusermatherr\u0024initializer\u0024;
  internal static int _matherr_flag;
  public static unsafe int** __unep\u0040\u003F_matherr\u0040\u0040\u0024\u0024J0YAHPAU_exception\u0040\u0040\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09CIHEKKBK\u0040vcomp\u003F4dll\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040JLENCBNC\u0040_vcomp_fork\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0L\u0040ENDGOIHG\u0040vcompd\u003F4dll\u003F\u0024AA\u0040;
  internal static __s_GUID _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02;
  internal static __s_GUID _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
  internal static __s_GUID _GUID_00000000_0000_0000_c000_000000000046;
  [FixedAddressValueType]
  internal static volatile __FnPtr<int (uint)> __mpnhHeap;
  [FixedAddressValueType]
  internal static volatile __FnPtr<void ()> __nhmHeap;
  internal static __FnPtr<void ()> \u003FA0x1edcd7ee\u002E__nhmHeap\u0024initializer\u0024;
  internal static __signal_init \u003FA0x1edcd7ee\u002E_init;
  internal static __FnPtr<void ()> \u003FA0x1edcd7ee\u002E_init\u0024initializer\u0024;
  internal static __s_GUID _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e;
  internal static __FnPtr<void ()> \u003FA0x1edcd7ee\u002E__mpnhHeap\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static volatile \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040R6MXH\u0040Z \u003FA0x1edcd7ee\u002E__psignal_func;
  internal static __s_GUID _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02;
  public static unsafe int** __unep\u0040\u003F_callnewh_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAHI\u0040Z;
  public static unsafe int** __unep\u0040\u003F_callnewhandler_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAHI\u0040Z;
  public static unsafe int** __unep\u0040\u003F__signal_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAXH\u0040Z;
  [FixedAddressValueType]
  internal static volatile __FnPtr<void (char*, char*, char*, uint, uint)> __pParameter_m;
  [FixedAddressValueType]
  internal static __FnPtr<void ()> \u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xb82567e7\u002E\u003F__pPurecall_m\u0024initializer\u0024\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xb82567e7\u002E__pParameter_m\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static __FnPtr<void ()> \u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xb82567e7\u002E\u003F__pTerminate_m\u0024initializer\u0024\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static __FnPtr<void ()> \u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xb82567e7\u002E\u003F__pUnexpected_m\u0024initializer\u0024\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  public static unsafe int** __unep\u0040\u003F__invalid_parameter_handler_thunk\u0040\u0040\u0024\u0024FYAXPB_W00II\u0040Z;
  public static unsafe int** __unep\u0040\u003F__terminate_thunk\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F__purecall_thunk\u0040\u003FA0xb82567e7\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F__unexpected_thunk\u0040\u0040\u0024\u0024FYAXXZ;
  [FixedAddressValueType]
  internal static __FnPtr<int (_FPIEEE_RECORD*)> \u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA;
  internal static __FnPtr<void ()> \u003FA0xb8b4414c\u002E\u003F__pFilter_m\u0024initializer\u0024\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  public static unsafe int** __unep\u0040\u003Ffpieee_flt_thunk_func\u0040\u0040\u0024\u0024FYAHPAU_FPIEEE_RECORD\u0040\u0040\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x176e81b8\u002E__xc_mp_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x176e81b8\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x176e81b8\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x176e81b8\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x176e81b8\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x176e81b8\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x176e81b8\u002E__xc_mp_a;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040GHFPNOJB\u0040bad\u003F5allocation\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040EOODALEL\u0040Unknown\u003F5exception\u003F\u0024AA\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7exception\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4exception\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x0dad146e\u002E\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x0dad146e\u002E\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x0dad146e\u002E_bad_alloc_Message;
  internal static _GUID IID_ICLRRuntimeHost;
  internal static _GUID CLSID_CLRRuntimeHost;
  public static unsafe int** __unep\u0040\u003Fcallback\u0040callback_cdecl_void_struct0\u0040_detail\u0040msclr\u0040\u0040\u0024\u0024FSGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_callthreadstart\u0040\u003FA0x43294865\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F_threadstart\u0040\u003FA0x43294865\u0040\u0040\u0024\u0024FYGKPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_callthreadstartex\u0040\u003FA0xb4b5ff21\u0040\u0040\u0024\u0024FYAXXZ;
  public static unsafe int** __unep\u0040\u003F_threadstartex\u0040\u003FA0xb4b5ff21\u0040\u0040\u0024\u0024FYGKPAX\u0040Z;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAV_Locimp\u0040locale\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY08Q6AXXZ \u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024ctype\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3ios_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403FA\u0040\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2_Locimp\u0040locale\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024ctype\u0040G\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3_Locimp\u0040locale\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2facet\u0040locale\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2codecvt_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4_Locimp\u0040locale\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4ios_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403FA\u0040\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403EA\u0040ios_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040codecvt_base\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAV\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVcodecvt_base\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024ctype\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAV\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_19 \u003F\u003F_R0\u003FAVios_base\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2ctype_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAV\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_46 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3facet\u0040locale\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R13\u003F0A\u0040EA\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAV\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAV\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3codecvt_base\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040_Locimp\u0040locale\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2ios_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024ctype\u0040_W\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4ctype_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_46 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAV\u003F\u0024_Iosb\u0040H\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040ctype_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040facet\u0040locale\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R13A\u00403EA\u0040\u003F\u0024_Iosb\u0040H\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4facet\u0040locale\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY08Q6AXXZ \u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAUctype_base\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_54 \u003F\u003F_R0\u003FAV\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024ctype\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040ios_base\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVfacet\u0040locale\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3ctype_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static unsafe sbyte* std\u002E\u003FA0x7886e949\u002E_bad_alloc_Message;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_48 \u003F\u003F_R0\u003FAV\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040A\u00403FA\u0040\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_4 \u003F\u003F_R2\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4codecvt_base\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024ctype\u0040G\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x7886e949\u002E\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  public static unsafe int** __unep\u0040\u003Frsfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fsifun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fsbfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fspfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  public static unsafe int** __unep\u0040\u003Fswfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09PAVios_base\u0040std\u0040\u0040 std\u002E\u003FA0xc7622cfe\u002Estdstr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc7622cfe\u002Estdstr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static bool \u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA;
  internal static __FnPtr<void ()> \u003FA0xc7622cfe\u002E\u003F_Sync\u0024initializer\u0024\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xc7622cfe\u002E\u003F_Index\u0024initializer\u0024\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09D std\u002E\u003FA0xc7622cfe\u002Estdopens;
  internal static __FnPtr<void ()> std\u002E\u003FA0xc7622cfe\u002Estdopens\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xc7622cfe\u002E_bad_alloc_Message;
  internal static int std\u002E_BADOFF;
  internal static long std\u002E_Fpz;
  [FixedAddressValueType]
  internal static int \u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xaab18c51\u002E\u003F_Init_cnt\u0024initializer\u0024\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0xaab18c51\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static int \u003F_Init_cnt\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xcbb46b7e\u002E\u003F_Init_cnt\u0024initializer\u0024\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0xcbb46b7e\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static _Init_atexit \u003FA0xf46c9959\u002Einit_atexit;
  [FixedAddressValueType]
  internal static uint \u003FA0xf46c9959\u002Eatcount_cdecl;
  internal static __FnPtr<void ()> \u003FA0xf46c9959\u002Einit_atexit\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_cin;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_cin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_wcout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_cout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_cout\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FL\u0040D _PJP_CPP_Copyright;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09P6AXXZ \u003FA0xf46c9959\u002Eatfuns_cdecl;
  internal static __FnPtr<void ()> \u003FA0xf46c9959\u002Eatcount_cdecl\u0024initializer\u0024;
  internal static _Init_locks std\u002E\u003FA0xf46c9959\u002Einitlocks;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_clog;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_clog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_wcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_wcin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Ptr_wclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_wclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xf46c9959\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Ptr_cerr;
  internal static __FnPtr<void ()> \u003FA0xf46c9959\u002Eatfuns_cdecl\u0024initializer\u0024;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf46c9959\u002E_Ptr_cerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static int \u003F_Init_cnt\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0xf2a4e477\u002E\u003F_Init_cnt\u0024initializer\u0024\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf2a4e477\u002E_Ptr_wcout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf2a4e477\u002E_Ptr_wcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf2a4e477\u002E_Ptr_wcin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Ptr_wclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0xf2a4e477\u002E_Ptr_wclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xf2a4e477\u002E_bad_alloc_Message;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAV\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY08Q6AXXZ \u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _Init_locks \u003FA0x4ee7f526\u002Einitlocks;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x4ee7f526\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static int \u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x4ee7f526\u002E\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x4ee7f526\u002Einitlocks\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static _Init_cerr std\u002E\u003FA0x4ee7f526\u002Einit_cerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x4ee7f526\u002Einit_cerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Ecerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x4ee7f526\u002Ecerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x4ee7f526\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0x4ee7f526\u002Eferr;
  internal static unsafe sbyte* std\u002E\u003FA0x4ee7f526\u002E_bad_alloc_Message;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x4ee7f526\u002E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> std\u002E\u003FA0x4ee7f526\u002Eferr\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00408;
  internal static _Init_locks \u003FA0x8a3a1449\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Ecin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x8a3a1449\u002Ecin\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x8a3a1449\u002Einitlocks\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  [FixedAddressValueType]
  internal static _Init_cin std\u002E\u003FA0x8a3a1449\u002Einit_cin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x8a3a1449\u002Einit_cin\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x8a3a1449\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0x8a3a1449\u002Efin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x8a3a1449\u002Efin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Eclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x04ba802b\u002Eclog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0x04ba802b\u002Eflog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x04ba802b\u002Eflog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x04ba802b\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static _Init_clog std\u002E\u003FA0x04ba802b\u002Einit_clog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x04ba802b\u002Einit_clog\u0024initializer\u0024;
  internal static _Init_locks \u003FA0xccd9347d\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002Ecout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xccd9347d\u002Ecout\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xccd9347d\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E std\u002E\u003FA0xccd9347d\u002Efout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xccd9347d\u002Efout\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xccd9347d\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static _Init_cout std\u002E\u003FA0xccd9347d\u002Einit_cout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xccd9347d\u002Einit_cout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_ushcerr std\u002E\u003FA0x68dc8993\u002Einit_ushcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x68dc8993\u002Einit_ushcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x68dc8993\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x68dc8993\u002Ewcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0x68dc8993\u002Ewferr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x68dc8993\u002Ewferr\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _Init_locks \u003FA0x68dc8993\u002Einitlocks;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static __FnPtr<void ()> \u003FA0x68dc8993\u002E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static int \u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_50 \u003F\u003F_R0\u003FAV\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x68dc8993\u002Einitlocks\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0x68dc8993\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x68760d79\u002Ewcin\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static _Init_locks \u003FA0x68760d79\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0x68760d79\u002Ewfin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x68760d79\u002Ewfin\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x68760d79\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_ushcin std\u002E\u003FA0x68760d79\u002Einit_ushcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x68760d79\u002Einit_ushcin\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x68760d79\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0x2281fc9e\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0x2281fc9e\u002Ewflog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x2281fc9e\u002Ewflog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_ushclog std\u002E\u003FA0x2281fc9e\u002Einit_ushclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x2281fc9e\u002Einit_ushclog\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x2281fc9e\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x2281fc9e\u002Ewclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x2281fc9e\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0xeae248c8\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002E\u003FA0xeae248c8\u002Ewfout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xeae248c8\u002Ewfout\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_ushcout std\u002E\u003FA0xeae248c8\u002Einit_ushcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xeae248c8\u002Einit_ushcout\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xeae248c8\u002Einitlocks\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xeae248c8\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E std\u002Ewcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xeae248c8\u002Ewcout\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_52 \u003F\u003F_R0\u003FAV\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static int \u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x4fded7d1\u002Ewcerr\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0x4fded7d1\u002Ewferr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x4fded7d1\u002Ewferr\u0024initializer\u0024;
  internal static _Init_locks \u003FA0x4fded7d1\u002Einitlocks;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x4fded7d1\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static __FnPtr<void ()> \u003FA0x4fded7d1\u002Einitlocks\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static _Init_wcerr std\u002E\u003FA0x4fded7d1\u002Einit_wcerr;
  internal static __FnPtr<void ()> std\u002E\u003FA0x4fded7d1\u002Einit_wcerr\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x4fded7d1\u002E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x4fded7d1\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x6869e508\u002Ewcin\u0024initializer\u0024;
  internal static _Init_locks \u003FA0x6869e508\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0x6869e508\u002Ewfin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x6869e508\u002Ewfin\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_wcin std\u002E\u003FA0x6869e508\u002Einit_wcin;
  internal static __FnPtr<void ()> std\u002E\u003FA0x6869e508\u002Einit_wcin\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x6869e508\u002Einitlocks\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBH \u003F\u003F_8\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
  internal static unsafe sbyte* std\u002E\u003FA0x6869e508\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0x0583a2dc\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0x0583a2dc\u002Ewflog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x0583a2dc\u002Ewflog\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x0583a2dc\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_wclog std\u002E\u003FA0x0583a2dc\u002Einit_wclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x0583a2dc\u002Einit_wclog\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewclog;
  internal static __FnPtr<void ()> std\u002E\u003FA0x0583a2dc\u002Ewclog\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x0583a2dc\u002E_bad_alloc_Message;
  internal static _Init_locks \u003FA0xcde0168a\u002Einitlocks;
  [FixedAddressValueType]
  internal static basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002E\u003FA0xcde0168a\u002Ewfout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xcde0168a\u002Ewfout\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xcde0168a\u002Einitlocks\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static _Init_wcout std\u002E\u003FA0xcde0168a\u002Einit_wcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xcde0168a\u002Einit_wcout\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0xcde0168a\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E std\u002Ewcout;
  internal static __FnPtr<void ()> std\u002E\u003FA0xcde0168a\u002Ewcout\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05LAPONLG\u0040false\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04LOAJBDKD\u0040true\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02EAOCLKAK\u0040ld\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02BDDLJJBK\u0040lu\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02HIKPPMOK\u0040Ld\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02CLHGNPPK\u0040Lu\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003F\u003F_C\u0040_02BBAHNLBA\u0040\u003F\u0024CFp\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BH\u0040HHDGIIFB\u00400123456789abcdefABCDEF\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01DDCIFGEA\u0040E\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01KGKMHCOC\u0040e\u003F\u0024AA\u0040;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408\u003F\u003F0exception\u0040std\u0040\u0040\u0024\u0024FQAM\u0040ABV01\u0040\u0040Z12;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static bad_alloc \u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024numpunct\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040;
  internal static uint \u003FA0x78d0d095\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY06Q6AXXZ \u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static bad_alloc \u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404Vbad_alloc\u00404\u0040B;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAV\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static uint \u003FA0x78d0d095\u002E\u003F\u0024S1\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404IA;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_8 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09Q6AXXZ \u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_74 \u003F\u003F_R0\u003FAV\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_74 \u003F\u003F_R0\u003FAV\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024numpunct\u0040D\u0040std\u0040\u00408;
  internal static unsafe sbyte* std\u002E\u003FA0x78d0d095\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static _s__CatchableType _CT\u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408\u003F\u003F0bad_alloc\u0040std\u0040\u0040\u0024\u0024FQAE\u0040ABV01\u0040\u0040Z12;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x78d0d095\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040time_base\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3money_base\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040money_base\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe _Fac_node* std\u002E\u003FA0x7431c98f\u002E_Fac_head;
  internal static __FnPtr<void ()> std\u002E\u003FA0x7431c98f\u002E_Fac_head\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale._Locimp* \u003FA0x7431c98f\u002Eglobal_locale;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2messages_base\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static locale std\u002E\u003FA0x7431c98f\u002Eclassic_locale;
  internal static __FnPtr<void ()> std\u002E\u003FA0x7431c98f\u002Eclassic_locale\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2time_base\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static bool \u003FA0x7431c98f\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA;
  [FixedAddressValueType]
  internal static unsafe locale._Locimp* \u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003F_Clocptr\u0024initializer\u0024\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040messages_base\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4time_base\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAUmoney_base\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3messages_base\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4messages_base\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAUmessages_base\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static int \u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003F_Id_cnt\u0024initializer\u0024\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3time_base\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAUtime_base\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4money_base\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2money_base\u0040std\u0040\u00408;
  internal static unsafe sbyte* std\u002E\u003FA0x7431c98f\u002E_bad_alloc_Message;
  internal static uint \u003FA0x7431c98f\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA;
  internal static __FnPtr<void ()> \u003FA0x7431c98f\u002Eglobal_locale\u0024initializer\u0024;
  public static unsafe int** __unep\u0040\u003Ftidy_global\u0040\u003FA0x7431c98f\u0040\u0040\u0024\u0024J0YAXXZ;
  public static unsafe int** __unep\u0040\u003F_Fac_tidy\u0040\u0040\u0024\u0024J0YAXXZ;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FG\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0FG\u0040EOHGAEB\u0040\u003F3Sun\u003F3Sunday\u003F3Mon\u003F3Monday\u003F3Tue\u003F3Tuesd\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0IH\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0IH\u0040HPGJLCCK\u0040\u003F3Jan\u003F3January\u003F3Feb\u003F3February\u003F3Mar\u003F3Ma\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05NNKBBLJI\u0040\u003F\u0024CF\u003F40Lf\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04IHCGILC\u0040\u003F\u0024CB\u003F\u0024CFx\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01JOAMLHOP\u0040\u003F9\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04FJCIEOIB\u0040\u0024\u003F\u0024CLxv\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0HJ\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0HJ\u0040PJOMAIHM\u0040\u003F\u0024CLv\u0024x\u003F\u0024CLv\u0024xv\u0024\u003F\u0024CLxv\u003F\u0024CL\u0024xv\u0024\u003F\u0024CLx\u003F\u0024CL\u0024vx\u003F\u0024CL\u0024vx\u0024v\u003F\u0024CLx\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024collate\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY07Q6AXXZ \u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024collate\u0040D\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_75 \u003F\u003F_R0\u003FAV\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024messages\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024messages\u0040D\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAV\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAV\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_29 \u003F\u003F_R0\u003FAV\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_28 \u003F\u003F_R0\u003FAV\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_75 \u003F\u003F_R0\u003FAV\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_76 \u003F\u003F_R0\u003FAV\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_76 \u003F\u003F_R0\u003FAV\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static unsafe sbyte* std\u002E\u003FA0x84d97843\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAV\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x84d97843\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_79 \u003F\u003F_R0\u003FAV\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024messages\u0040_W\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_77 \u003F\u003F_R0\u003FAV\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024collate\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY07Q6AXXZ \u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_29 \u003F\u003F_R0\u003FAV\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAV\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024numpunct\u0040G\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_78 \u003F\u003F_R0\u003FAV\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_76 \u003F\u003F_R0\u003FAV\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_75 \u003F\u003F_R0\u003FAV\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAV\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_79 \u003F\u003F_R0\u003FAV\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY07Q6AXXZ \u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAV\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY06Q6AXXZ \u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_74 \u003F\u003F_R0\u003FAV\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09Q6AXXZ \u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_77 \u003F\u003F_R0\u003FAV\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024collate\u0040G\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040Q6AXXZ \u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_74 \u003F\u003F_R0\u003FAV\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024numpunct\u0040G\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_30 \u003F\u003F_R0\u003FAV\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY09Q6AXXZ \u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_76 \u003F\u003F_R0\u003FAV\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAV\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAV\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024messages\u0040G\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAV\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024collate\u0040G\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_28 \u003F\u003F_R0\u003FAV\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static \u0024ArrayType\u0024\u0024\u0024BY06Q6AXXZ \u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAV\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_12 \u003F\u003F_R2\u003F\u0024messages\u0040G\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024messages\u0040_W\u0040std\u0040\u00408;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024collate\u0040_W\u0040std\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_78 \u003F\u003F_R0\u003FAV\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAV\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static locale.id \u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003Fid\u0024initializer\u0024\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static unsafe sbyte* std\u002E\u003FA0xf64de732\u002E_bad_alloc_Message;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  [FixedAddressValueType]
  internal static unsafe locale.facet* \u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_75 \u003F\u003F_R0\u003FAV\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_29 \u003F\u003F_R0\u003FAV\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static _s__RTTICompleteObjectLocator \u003F\u003F_R4\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F_Psave\u0024initializer\u0024\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xf64de732\u002E\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00408;
  internal static unsafe sbyte* std\u002E\u003FA0x6c70cee1\u002E_bad_alloc_Message;
  internal static volatile \u0024ArrayType\u0024\u0024\u0024BY0DO\u0040RAU_CPLocEntry\u0040\u0040 \u003FA0x9284953a\u002E_CPLocHash;
  internal static __FnPtr<int ()> \u003FA0x9284953a\u002Epinit;
  internal static _Init_locks std\u002E\u003FA0x15dc9b6c\u002Einitlocks;
  internal static __FnPtr<void ()> std\u002E\u003FA0x15dc9b6c\u002Einitlocks\u0024initializer\u0024;
  internal static int std\u002E\u003FA0x15dc9b6c\u002Einit;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03U_RTL_CRITICAL_SECTION\u0040\u0040 std\u002E\u003FA0x15dc9b6c\u002Emtx;
  internal static double \u003FA0xc01c99da\u002Ec1;
  internal static double \u003FA0xc01c99da\u002Ec2;
  internal static double \u003FA0xc01c99da\u002Einvln2;
  internal static double \u003FA0xc01c99da\u002Ehugexp;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBN \u003FA0xc01c99da\u002Eq;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBN \u003FA0xc01c99da\u002Ep;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBN \u003FA0xfd7f576c\u002Ep;
  internal static _Dconst _Snan;
  internal static double _Xbig;
  internal static _Dconst _Denorm;
  internal static double _Zero;
  internal static _Dconst _Inf;
  internal static _Dconst _Nan;
  internal static _Dconst _Eps;
  internal static _Dconst _Hugeval;
  internal static _Dconst _Rteps;
  internal static float \u003FA0xc556392c\u002Ec1;
  internal static float \u003FA0xc556392c\u002Ec2;
  internal static float \u003FA0xc556392c\u002Einvln2;
  internal static float \u003FA0xc556392c\u002Ehugexp;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBM \u003FA0xc556392c\u002Eq;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBM \u003FA0xc556392c\u002Ep;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBM \u003FA0xa9a44ae5\u002Ep;
  internal static float _FZero;
  internal static _Dconst _FDenorm;
  internal static float _FXbig;
  internal static _Dconst _FNan;
  internal static _Dconst _FRteps;
  internal static _Dconst _FEps;
  internal static _Dconst _FInf;
  internal static _Dconst _FSnan;
  internal static double \u003FA0x61266662\u002Ec1;
  internal static double \u003FA0x61266662\u002Ec2;
  internal static double \u003FA0x61266662\u002Einvln2;
  internal static double \u003FA0x61266662\u002Ehugexp;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBO \u003FA0x61266662\u002Eq;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBO \u003FA0x61266662\u002Ep;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBO \u003FA0x3864562d\u002Ep;
  internal static _Dconst _LEps;
  internal static _Dconst _LNan;
  internal static _Dconst _LRteps;
  internal static _Dconst _LDenorm;
  internal static _Dconst _LInf;
  internal static double _LXbig;
  internal static _Dconst _LSnan;
  internal static double _LZero;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13BPINEIPE\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13CIFDLIMG\u0040\u003F\u0024AAw\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13FNCBLAIF\u0040\u003F\u0024AAa\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15JJPIMNBO\u0040\u003F\u0024AAr\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15MJDFFMKN\u0040\u003F\u0024AAw\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15BMLKLNCL\u0040\u003F\u0024AAa\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15HPOENKKJ\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024CL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15CPCJELBK\u0040\u003F\u0024AAw\u003F\u0024AA\u003F\u0024CL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15PKKGKKJM\u0040\u003F\u0024AAa\u003F\u0024AA\u003F\u0024CL\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17IIOMHMAG\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024CL\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17MAAMHCGC\u0040\u003F\u0024AAw\u003F\u0024AA\u003F\u0024CL\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17HKNIEKMO\u0040\u003F\u0024AAa\u003F\u0024AA\u003F\u0024CL\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBH \u003FA0x3e1b8fe7\u002E\u003Fvalid\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404QBHB;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040PB_W \u003FA0x3e1b8fe7\u002E\u003Fmods\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404PAPB_WA;
  internal static unsafe sbyte* std\u002E\u003FA0x3e1b8fe7\u002E_bad_alloc_Message;
  internal static unsafe sbyte* std\u002E\u003FA0x28996722\u002E_bad_alloc_Message;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07CIFAGBMG\u0040unknown\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003F\u003F_C\u0040_01EEMJAFIK\u0040\u003F6\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0M\u0040LLHBPFNE\u0040exception\u003F3\u003F5\u003F\u0024AA\u0040;
  internal static unsafe sbyte* stdext\u002E\u003FA0x634c7e6a\u002E_bad_alloc_Message;
  internal static bad_alloc \u003FA0xcfe6d8a4\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B;
  internal static uint \u003FA0xcfe6d8a4\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA;
  internal static unsafe sbyte* std\u002E\u003FA0xcfe6d8a4\u002E_bad_alloc_Message;
  internal static unsafe sbyte* std\u002E\u003FA0xe7dd2d4c\u002E_bad_alloc_Message;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07OJACGNH\u0040tolower\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003F\u003F_C\u0040_07FFCOENGO\u0040toupper\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBUwctab\u0040\u0040 \u003FA0x75aadbaf\u002Etab;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IIMHCHIO\u0040alnum\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IAEKHIAN\u0040alpha\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05JMDPEFNK\u0040cntrl\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05ODNOIFML\u0040digit\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05KCJBMLII\u0040graph\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IPJEPLHL\u0040lower\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05IJDJACGD\u0040print\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05KOBGHFJJ\u0040punct\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05OLNILLAB\u0040space\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003F\u003F_C\u0040_05NECKJAMC\u0040upper\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06BAPHGFFK\u0040xdigit\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBUwctab\u0040\u0040 \u003FA0xd536467b\u002Etab;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x23130d9f\u002E\u003F_lock\u0024initializer\u0024\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0P6MXXZA;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static uint \u003FA0x23130d9f\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0x23130d9f\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0x23130d9f\u002E__onexitend_m;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003FA0x165399fd\u002Edigits;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003FA0x165399fd\u002Endigs;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0x7b73d764\u002E\u003Fdigits\u0040\u003F1\u003F\u003F_Stoxflt\u0040\u0040YAHPBD0PAPADQAJH\u0040Z\u00404QBDB;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x7b73d764\u002E\u003Fvals\u0040\u003F1\u003F\u003F_Stoxflt\u0040\u0040YAHPBD0PAPADQAJH\u0040Z\u00404QBDB;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBN \u003FA0x83709a7a\u002Epows;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBM \u003FA0x0a37817a\u002Epows;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBO \u003FA0x1d1511b3\u002Epows;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  public static volatile uint __native_vcclrit_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  public static volatile __enative_startup_state __native_startup_state;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  public static unsafe void* __native_startup_lock;
  public static volatile uint __native_dllmain_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;

  internal static void \u003FA0xedf1fba0\u002E\u003F\u003F__Epusermatherr\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe int _matherr(_exception* pexcept)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<int (_exception*)> local = (__FnPtr<int (_exception*)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.pusermatherr);
    if (local == null)
      return 0;
    _exception* exceptionPtr = pexcept;
    // ISSUE: function pointer call
    return __calli(local)(exceptionPtr);
  }

  internal static unsafe void __setusermatherr_m(__FnPtr<int (_exception*)> pf)
  {
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.pusermatherr = (__FnPtr<int (_exception*)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pf);
    if (pf != null)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__setusermatherr((__FnPtr<int (_exception*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_matherr\u0040\u0040\u0024\u0024J0YAHPAU_exception\u0040\u0040\u0040Z);
    }
    \u003CModule\u003E._matherr_flag = 0;
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    Exception innerException,
    Exception nestedException)
  {
    throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage)
  {
    throw new ModuleLoadException(errorMessage);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage,
    Exception innerException)
  {
    throw new ModuleLoadException(errorMessage, innerException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    EventHandler handler)
  {
    ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
  }

  internal static unsafe int __get_default_appdomain(IUnknown** ppUnk)
  {
    int defaultAppdomain = 0;
    IUnknown* iunknownPtr1 = (IUnknown*) 0;
    ICorRuntimeHost* icorRuntimeHostPtr1 = (ICorRuntimeHost*) 0;
    try
    {
      defaultAppdomain = \u003CModule\u003E.CoCreateInstance((_GUID*) &\u003CModule\u003E._GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e, (IUnknown*) 0, 1U, (_GUID*) &\u003CModule\u003E._GUID_00000000_0000_0000_c000_000000000046, (void**) &iunknownPtr1);
      if (defaultAppdomain >= 0)
      {
        IUnknown* iunknownPtr2 = iunknownPtr1;
        ref __s_GUID local1 = ref \u003CModule\u003E._GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
        ref ICorRuntimeHost* local2 = ref icorRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        defaultAppdomain = __calli((__FnPtr<int (IntPtr, _GUID*, void**)>) *(int*) *(int*) iunknownPtr1)((void**) iunknownPtr2, (_GUID*) ref local1, (IntPtr) ref local2);
        if (defaultAppdomain >= 0)
        {
          ICorRuntimeHost* icorRuntimeHostPtr2 = icorRuntimeHostPtr1;
          IUnknown** iunknownPtr3 = ppUnk;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          defaultAppdomain = __calli((__FnPtr<int (IntPtr, IUnknown**)>) *(int*) (*(int*) icorRuntimeHostPtr1 + 52))((IUnknown**) icorRuntimeHostPtr2, (IntPtr) iunknownPtr3);
        }
      }
    }
    finally
    {
      if ((IntPtr) iunknownPtr1 != IntPtr.Zero)
      {
        IUnknown* iunknownPtr4 = iunknownPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr4 + 8))((IntPtr) iunknownPtr4);
      }
      if ((IntPtr) icorRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICorRuntimeHost* icorRuntimeHostPtr3 = icorRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) icorRuntimeHostPtr3 + 8))((IntPtr) icorRuntimeHostPtr3);
      }
    }
    return defaultAppdomain;
  }

  internal static unsafe void __release_appdomain(IUnknown* ppUnk)
  {
    IUnknown* iunknownPtr = ppUnk;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iunknownPtr + 8))((IntPtr) iunknownPtr);
  }

  internal static unsafe AppDomain \u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain()
  {
    IUnknown* ppUnk = (IUnknown*) 0;
    int defaultAppdomain = \u003CModule\u003E.__get_default_appdomain(&ppUnk);
    if (defaultAppdomain >= 0)
    {
      try
      {
        return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) ppUnk));
      }
      finally
      {
        \u003CModule\u003E.__release_appdomain(ppUnk);
      }
    }
    else
    {
      Marshal.ThrowExceptionForHR(defaultAppdomain);
      return (AppDomain) null;
    }
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    __FnPtr<int (void*)> function,
    void* cookie)
  {
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    try
    {
      int runtimeEx = \u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, (_GUID*) &\u003CModule\u003E._GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02, (_GUID*) &\u003CModule\u003E._GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02, (void**) &iclrRuntimeHostPtr1);
      if (runtimeEx < 0)
        Marshal.ThrowExceptionForHR(runtimeEx);
      AppDomain defaultDomain = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain();
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 32))((void*) iclrRuntimeHostPtr1, (__FnPtr<int (void*)>) defaultDomain.Id, (uint) function, (IntPtr) cookie);
      if (errorCode >= 0)
        return;
      Marshal.ThrowExceptionForHR(errorCode);
    }
    finally
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EIsUsingOpenMP()
  {
    HINSTANCE__* moduleHandleA1 = \u003CModule\u003E.GetModuleHandleA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_09CIHEKKBK\u0040vcomp\u003F4dll\u003F\u0024AA\u0040);
    if ((IntPtr) moduleHandleA1 != IntPtr.Zero && \u003CModule\u003E.GetProcAddress(moduleHandleA1, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040JLENCBNC\u0040_vcomp_fork\u003F\u0024AA\u0040) != null)
      return true;
    HINSTANCE__* moduleHandleA2 = \u003CModule\u003E.GetModuleHandleA((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0L\u0040ENDGOIHG\u0040vcompd\u003F4dll\u003F\u0024AA\u0040);
    return (IntPtr) moduleHandleA2 != IntPtr.Zero && \u003CModule\u003E.GetProcAddress(moduleHandleA2, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040JLENCBNC\u0040_vcomp_fork\u003F\u0024AA\u0040) != null;
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation()
  {
    if (!AppDomain.CurrentDomain.IsDefaultAppDomain() && \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EIsUsingOpenMP())
      throw new OpenMPWithMultipleAppdomainsException();
  }

  internal static void \u003FA0x1edcd7ee\u002E\u003F\u003F__E__mpnhHeap\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u003FA0x1edcd7ee\u002E\u003F\u003F__E__nhmHeap\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe int \u003FA0x1edcd7ee\u002E_callnewh_thunk(uint size)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<int (uint)> local = (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__mpnhHeap);
    if (local == null)
      return 0;
    int num = (int) size;
    // ISSUE: function pointer call
    return __calli(local)((uint) num);
  }

  internal static unsafe void \u003FA0x1edcd7ee\u002E_callnewh_cleanup()
  {
    __FnPtr<int (uint)> local1 = \u003CModule\u003E._query_new_handler();
    // ISSUE: cast to a function pointer type
    __FnPtr<int (uint)> local2 = (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** a0x1edcd7eeFyahiZ = \u003CModule\u003E.__unep\u0040\u003F_callnewh_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAHI\u0040Z;
    if (local1 == (IntPtr) a0x1edcd7eeFyahiZ && \u003CModule\u003E.__mpnhHeap != local2)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) 0);
    }
    \u003CModule\u003E.__mpnhHeap = local2;
  }

  internal static unsafe int \u003FA0x1edcd7ee\u002E_callnewhandler_thunk(uint size)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__nhmHeap);
    if (local == null)
      return 0;
    // ISSUE: function pointer call
    __calli(local)();
    return 1;
  }

  internal static unsafe void \u003FA0x1edcd7ee\u002E_callnewhandler_cleanup()
  {
    __FnPtr<int (uint)> local1 = \u003CModule\u003E._query_new_handler();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local2 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** a0x1edcd7eeFyahiZ = \u003CModule\u003E.__unep\u0040\u003F_callnewhandler_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAHI\u0040Z;
    if (local1 == (IntPtr) a0x1edcd7eeFyahiZ && \u003CModule\u003E.__nhmHeap != local2)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) 0);
    }
    \u003CModule\u003E.__nhmHeap = local2;
  }

  internal static unsafe __FnPtr<int (uint)> _set_new_handler(__FnPtr<int (uint)> pnh)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x1edcd7ee\u002E_callnewh_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<int (uint)>) 0;
    }
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__mpnhHeap);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__mpnhHeap = (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pnh);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callnewh_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAHI\u0040Z);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<int (uint)>) (IntPtr) voidPtr;
  }

  internal static unsafe __FnPtr<void ()> std\u002Eset_new_handler(__FnPtr<void ()> _NewHandler)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x1edcd7ee\u002E_callnewhandler_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__nhmHeap);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__nhmHeap = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) _NewHandler);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_new_handler((__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callnewhandler_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAHI\u0040Z);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe __FnPtr<int (uint)> __query_new_handler_m() => (__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__mpnhHeap);

  internal static unsafe __signal_init* __signal_init\u002E\u007Bctor\u007D(
    [In] __signal_init* obj0)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void (int)> local1 = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._encoded_null();
    __FnPtr<void (int)>* local2 = (__FnPtr<void (int)>*) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func;
    // ISSUE: cast to a reference type
    do
    {
      *(int*) local2 = (int) local1;
      local2 += 4;
    }
    while ((IntPtr) local2 < (\u0024ArrayType\u0024\u0024\u0024BY0BH\u0040R6MXH\u0040Z&) ((IntPtr) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func + 92));
    return obj0;
  }

  internal static void \u003FA0x1edcd7ee\u002E\u003F\u003F__E\u003FA0x1edcd7ee\u0040_init\u0040\u0040YMXXZ()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe void \u003FA0x1edcd7ee\u002E__signal_thunk(int i)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a function pointer type
    __FnPtr<void (int)> local = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) ^(int&) (i * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func));
    if (local == null)
      return;
    int num = i;
    // ISSUE: function pointer call
    __calli(local)(num);
  }

  internal static unsafe void \u003FA0x1edcd7ee\u002E_signal_cleanup()
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void (int)> local = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._encoded_null();
    int num = 0;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) (num * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func) != local)
      {
        // ISSUE: cast to a function pointer type
        if (\u003CModule\u003E.signal(num, (__FnPtr<void (int)>) 2) == (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__signal_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAXH\u0040Z)
        {
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.signal(num, (__FnPtr<void (int)>) 0);
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) (num * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func) = (int) local;
      }
      ++num;
    }
    while (num < 23);
  }

  internal static unsafe __FnPtr<void (int)> signal(int signum, __FnPtr<void (int)> sigact)
  {
    if ((uint) signum <= 22U)
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x1edcd7ee\u002E_signal_cleanup)) != 0)
      {
        // ISSUE: cast to a function pointer type
        return (__FnPtr<void (int)>) 0;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a function pointer type
      __FnPtr<void (int)> local1 = (__FnPtr<void (int)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) ^(int&) (signum * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) (signum * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x1edcd7ee\u002E__psignal_func) = (int) \u003CModule\u003E._encode_pointer((void*) sigact);
      int a0x1edcd7eeFyaxhZ = (int) \u003CModule\u003E.__unep\u0040\u003F__signal_thunk\u0040\u003FA0x1edcd7ee\u0040\u0040\u0024\u0024FYAXH\u0040Z;
      // ISSUE: cast to a function pointer type
      __FnPtr<void (int)> local2 = \u003CModule\u003E.signal(signum, (__FnPtr<void (int)>) a0x1edcd7eeFyaxhZ);
      if (local2 == a0x1edcd7eeFyaxhZ)
        return local1;
      int num = 0;
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a function pointer type
      return local2 == 0 ? (__FnPtr<void (int)>) num : (__FnPtr<void (int)>) ~num;
    }
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.signal(signum, (__FnPtr<void (int)>) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (int)>) -1;
  }

  internal static unsafe __FnPtr<void (int)> signal(int signum, int sigact)
  {
    if (sigact == 0)
    {
      // ISSUE: cast to a function pointer type
      return \u003CModule\u003E.signal(signum, (__FnPtr<void (int)>) 0);
    }
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (int)>) 0;
  }

  internal static unsafe void \u003FA0xb82567e7\u002E\u003F\u003F__E__pParameter_m\u0040\u0040YMXXZ() => \u003CModule\u003E.__pParameter_m = (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void __invalid_parameter_handler_thunk(
    char* pszExpression,
    char* pszFunction,
    char* pszFile,
    uint nLine,
    uint pReserved)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void (char*, char*, char*, uint, uint)> local = (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__pParameter_m);
    if (local == null)
      return;
    char* chPtr1 = pszExpression;
    char* chPtr2 = pszFunction;
    char* chPtr3 = pszFile;
    int num1 = (int) nLine;
    int num2 = (int) pReserved;
    // ISSUE: function pointer call
    __calli(local)((uint) chPtr1, (uint) chPtr2, chPtr3, (char*) num1, (char*) num2);
  }

  internal static unsafe void \u003FA0xb82567e7\u002E__invalid_parameter_handler_cleanup()
  {
    if (\u003CModule\u003E._get_invalid_parameter_handler() == (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__invalid_parameter_handler_thunk\u0040\u0040\u0024\u0024FYAXPB_W00II\u0040Z && \u003CModule\u003E.__pParameter_m != null)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_invalid_parameter_handler((__FnPtr<void (char*, char*, char*, uint, uint)>) 0);
    }
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__pParameter_m = (__FnPtr<void (char*, char*, char*, uint, uint)>) 0;
  }

  internal static unsafe __FnPtr<void (char*, char*, char*, uint, uint)> _set_invalid_parameter_handler(
    __FnPtr<void (char*, char*, char*, uint, uint)> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xb82567e7\u002E__invalid_parameter_handler_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void (char*, char*, char*, uint, uint)>) 0;
    }
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__pParameter_m);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_invalid_parameter_handler(pNew == null ? (__FnPtr<void (char*, char*, char*, uint, uint)>) (ValueType) 0 : (__FnPtr<void (char*, char*, char*, uint, uint)>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__invalid_parameter_handler_thunk\u0040\u0040\u0024\u0024FYAXPB_W00II\u0040Z);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.__pParameter_m = (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (char*, char*, char*, uint, uint)>) (IntPtr) voidPtr;
  }

  internal static unsafe void \u003FA0xb82567e7\u002E\u003F\u003F__E\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void \u003FA0xb82567e7\u002E\u003F\u003F__E\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void \u003FA0xb82567e7\u002E\u003F\u003F__E\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe void __terminate_thunk()
  {
    if ((IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA) == IntPtr.Zero)
      return;
    // ISSUE: function pointer call
    __calli(\u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA)();
  }

  internal static unsafe void \u003FA0xb82567e7\u002E__terminate_cleanup()
  {
    __FnPtr<void ()> terminate = \u003CModule\u003E._get_terminate();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** terminateThunkFyaxxz = \u003CModule\u003E.__unep\u0040\u003F__terminate_thunk\u0040\u0040\u0024\u0024FYAXXZ;
    if (terminate == (IntPtr) terminateThunkFyaxxz && \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA != local)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.set_terminate((__FnPtr<void ()>) 0);
    }
    \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = local;
  }

  internal static unsafe __FnPtr<void ()> set_terminate(__FnPtr<void ()> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xb82567e7\u002E__terminate_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    \u003CModule\u003E._encoded_null();
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pTerminate_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.set_terminate(pNew != null ? (__FnPtr<void ()>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__terminate_thunk\u0040\u0040\u0024\u0024FYAXXZ : (__FnPtr<void ()>) (ValueType) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe void \u003FA0xb82567e7\u002E__purecall_thunk()
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    if (local == null)
      return;
    // ISSUE: function pointer call
    __calli(local)();
  }

  internal static unsafe void \u003FA0xb82567e7\u002E__purecall_cleanup()
  {
    __FnPtr<void ()> purecallHandler = \u003CModule\u003E._get_purecall_handler();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** a0xb82567e7Fyaxxz = \u003CModule\u003E.__unep\u0040\u003F__purecall_thunk\u0040\u003FA0xb82567e7\u0040\u0040\u0024\u0024FYAXXZ;
    if (purecallHandler == (IntPtr) a0xb82567e7Fyaxxz && \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA != local)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._set_purecall_handler((__FnPtr<void ()>) 0);
    }
    \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = local;
  }

  internal static unsafe __FnPtr<void ()> _set_purecall_handler(__FnPtr<void ()> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xb82567e7\u002E__purecall_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    \u003CModule\u003E._encoded_null();
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pPurecall_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._set_purecall_handler(pNew != null ? (__FnPtr<void ()>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__purecall_thunk\u0040\u003FA0xb82567e7\u0040\u0040\u0024\u0024FYAXXZ : (__FnPtr<void ()>) (ValueType) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe void __unexpected_thunk()
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    if (local == null)
      return;
    // ISSUE: function pointer call
    __calli(local)();
  }

  internal static unsafe void \u003FA0xb82567e7\u002E__unexpected_cleanup()
  {
    __FnPtr<void ()> unexpected = \u003CModule\u003E._get_unexpected();
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encoded_null();
    int** unexpectedThunkFyaxxz = \u003CModule\u003E.__unep\u0040\u003F__unexpected_thunk\u0040\u0040\u0024\u0024FYAXXZ;
    if (unexpected == (IntPtr) unexpectedThunkFyaxxz && \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA != null)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.set_unexpected((__FnPtr<void ()>) 0);
    }
    \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = local;
  }

  internal static unsafe __FnPtr<void ()> set_unexpected(__FnPtr<void ()> pNew)
  {
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    if (\u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xb82567e7\u002E__unexpected_cleanup)) != 0)
    {
      // ISSUE: cast to a function pointer type
      return (__FnPtr<void ()>) 0;
    }
    \u003CModule\u003E._encoded_null();
    void* voidPtr = \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pUnexpected_m\u0040Handlers\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pNew);
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.set_unexpected(pNew != null ? (__FnPtr<void ()>) (ValueType) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F__unexpected_thunk\u0040\u0040\u0024\u0024FYAXXZ : (__FnPtr<void ()>) (ValueType) 0);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) (IntPtr) voidPtr;
  }

  internal static unsafe __FnPtr<void (char*, char*, char*, uint, uint)> _set_invalid_parameter_handler(
    int pNew)
  {
    if (pNew == 0)
    {
      // ISSUE: cast to a function pointer type
      return \u003CModule\u003E._set_invalid_parameter_handler((__FnPtr<void (char*, char*, char*, uint, uint)>) 0);
    }
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void (char*, char*, char*, uint, uint)>) 0;
  }

  internal static unsafe __FnPtr<void ()> _set_purecall_handler(int pNew)
  {
    if (pNew == 0)
    {
      // ISSUE: cast to a function pointer type
      return \u003CModule\u003E._set_purecall_handler((__FnPtr<void ()>) 0);
    }
    *\u003CModule\u003E._errno() = 22;
    \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void ()>) 0;
  }

  internal static unsafe void \u003FA0xb8b4414c\u002E\u003F\u003F__E\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA = (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E._encoded_null();

  internal static unsafe int fpieee_flt_thunk_func(_FPIEEE_RECORD* pfpieee_record)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<int (_FPIEEE_RECORD*)> local = (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA);
    if (local == null)
      return 0;
    _FPIEEE_RECORD* fpieeeRecordPtr = pfpieee_record;
    // ISSUE: function pointer call
    return __calli(local)(fpieeeRecordPtr);
  }

  internal static unsafe int _fpieee_flt(
    uint exceptionCode,
    _EXCEPTION_POINTERS* pExceptionPointers,
    __FnPtr<int (_FPIEEE_RECORD*)> pFunc)
  {
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.\u003F__pFilter_m\u0040HandlersFP\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MHPAU_FPIEEE_RECORD\u0040\u0040\u0040ZA = (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) pFunc);
    // ISSUE: cast to a function pointer type
    return \u003CModule\u003E._fpieee_flt(exceptionCode, pExceptionPointers, (__FnPtr<int (_FPIEEE_RECORD*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003Ffpieee_flt_thunk_func\u0040\u0040\u0024\u0024FYAHPAU_FPIEEE_RECORD\u0040\u0040\u0040Z);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x176e81b8\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x176e81b8\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num3 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num3, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      if (!\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
      }
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num4 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4);
      }
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [PrePrepareMethod]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  internal static unsafe void std\u002Ebad_alloc\u002E\u007Bdtor\u007D([In] bad_alloc* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D((std.exception*) obj0);
  }

  internal static unsafe void* std\u002Ebad_alloc\u002E__vecDelDtor([In] bad_alloc* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      bad_alloc* badAllocPtr = (bad_alloc*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) badAllocPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebad_alloc\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) badAllocPtr);
      return (void*) badAllocPtr;
    }
    \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Eexception\u002E__vecDelDtor([In] std.exception* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      std.exception* exceptionPtr = (std.exception*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 12U, *(int*) exceptionPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) exceptionPtr);
      return (void*) exceptionPtr;
    }
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe std.exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] std.exception* obj0,
    sbyte** _param1,
    int _param2)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = *(int*) _param1;
    *(int*) ((IntPtr) obj0 + 8) = 0;
    return obj0;
  }

  [SpecialName]
  internal static unsafe std.exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] std.exception* obj0,
    std.exception* _param1)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4);
    int num1 = *(int*) ((IntPtr) _param1 + 8);
    *(int*) ((IntPtr) obj0 + 8) = num1;
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) ((IntPtr) _param1 + 4);
      if (num2 != 0U)
      {
        uint num3 = \u003CModule\u003E.strlen((sbyte*) num2) + 1U;
        void* voidPtr = \u003CModule\u003E.malloc(num3);
        *(int*) ((IntPtr) obj0 + 4) = (int) voidPtr;
        if ((IntPtr) voidPtr != IntPtr.Zero)
          \u003CModule\u003E.strcpy_s((sbyte*) voidPtr, num3, (sbyte*) *(int*) ((IntPtr) _param1 + 4));
      }
      else
        *(int*) ((IntPtr) obj0 + 4) = 0;
    }
    else
      *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) _param1 + 4);
    return obj0;
  }

  internal static unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] std.exception* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4);
    if (*(int*) ((IntPtr) obj0 + 8) == 0)
      return;
    \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe sbyte* std\u002Eexception\u002Ewhat([In] std.exception* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    return num != 0U ? (sbyte*) num : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BC\u0040EOODALEL\u0040Unknown\u003F5exception\u003F\u0024AA\u0040;
  }

  internal static unsafe void \u003FA0x0dad146e\u002E\u003F\u003F__E\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4exception\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Eexception\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7exception\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Eexception\u002Ewhat);
  }

  internal static unsafe void \u003FA0x0dad146e\u002E\u003F\u003F__E\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebad_alloc\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Eexception\u002Ewhat);
  }

  internal static unsafe ICLRRuntimeHost* msclr\u002E_detail\u002Eget_clr_runtime_host()
  {
    ICLRRuntimeHost* clrRuntimeHost = (ICLRRuntimeHost*) 0;
    int runtimeEx = \u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, &\u003CModule\u003E.CLSID_CLRRuntimeHost, &\u003CModule\u003E.IID_ICLRRuntimeHost, (void**) &clrRuntimeHost);
    if (runtimeEx < 0)
    {
      if ((IntPtr) clrRuntimeHost != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr = clrRuntimeHost;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr + 8))((IntPtr) iclrRuntimeHostPtr);
      }
      Marshal.ThrowExceptionForHR(runtimeEx);
    }
    return clrRuntimeHost;
  }

  internal static unsafe int msclr\u002E_detail\u002Ecallback_cdecl_void_struct0\u002Ecallback(
    void* cookie)
  {
    if ((IntPtr) cookie == IntPtr.Zero)
      return -2147467259;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void ()>) *(int*) cookie)();
    return 0;
  }

  internal static unsafe void msclr\u002Ecall_in_appdomain(
    uint dwAppDomainId,
    __FnPtr<void ()> func)
  {
    ICLRRuntimeHost* clrRuntimeHost = \u003CModule\u003E.msclr\u002E_detail\u002Eget_clr_runtime_host();
    callback_cdecl_void_struct0 cdeclVoidStruct0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref cdeclVoidStruct0 = (int) func;
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = clrRuntimeHost;
    int num1 = (int) dwAppDomainId;
    int** detailMsclrFsgjpaxZ = \u003CModule\u003E.__unep\u0040\u003Fcallback\u0040callback_cdecl_void_struct0\u0040_detail\u0040msclr\u0040\u0040\u0024\u0024FSGJPAX\u0040Z;
    ref callback_cdecl_void_struct0 local = ref cdeclVoidStruct0;
    // ISSUE: cast to a function pointer type
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) clrRuntimeHost + 32))((void*) iclrRuntimeHostPtr1, (__FnPtr<int (void*)>) num1, (uint) detailMsclrFsgjpaxZ, (IntPtr) ref local);
    ICLRRuntimeHost* iclrRuntimeHostPtr2 = clrRuntimeHost;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
    if (errorCode >= 0)
      return;
    Marshal.ThrowExceptionForHR(errorCode);
  }

  internal static unsafe int \u003FA0x43294865\u002E_getdomain(uint* pDomain)
  {
    *pDomain = 0U;
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    if (\u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, &\u003CModule\u003E.CLSID_CLRRuntimeHost, &\u003CModule\u003E.IID_ICLRRuntimeHost, (void**) &iclrRuntimeHostPtr1) < 0)
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
      }
      return 0;
    }
    uint num1 = 0;
    ICLRRuntimeHost* iclrRuntimeHostPtr3 = iclrRuntimeHostPtr1;
    ref uint local = ref num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, uint*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 36))((uint*) iclrRuntimeHostPtr3, (IntPtr) ref local);
    ICLRRuntimeHost* iclrRuntimeHostPtr4 = iclrRuntimeHostPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr4 + 8))((IntPtr) iclrRuntimeHostPtr4);
    if (num2 < 0)
      return 0;
    *pDomain = num1;
    return 1;
  }

  internal static unsafe uint _beginthread(
    __FnPtr<void (void*)> initialcode,
    uint stacksize,
    void* argument)
  {
    uint num = 0;
    if (initialcode == null)
    {
      *\u003CModule\u003E._errno() = 22;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return uint.MaxValue;
    }
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.calloc(1U, 532U);
    if ((IntPtr) tiddataPtr != IntPtr.Zero)
    {
      \u003CModule\u003E._initptd(tiddataPtr, (threadlocaleinfostruct*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 108));
      *(int*) ((IntPtr) tiddataPtr + 84) = (int) initialcode;
      *(int*) ((IntPtr) tiddataPtr + 88) = (int) argument;
      if (\u003CModule\u003E.\u003FA0x43294865\u002E_getdomain((uint*) ((IntPtr) tiddataPtr + 528)) != 0)
      {
        // ISSUE: cast to a function pointer type
        uint thread = (uint) \u003CModule\u003E.CreateThread((_SECURITY_ATTRIBUTES*) 0, stacksize, (__FnPtr<uint (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_threadstart\u0040\u003FA0x43294865\u0040\u0040\u0024\u0024FYGKPAX\u0040Z, (void*) tiddataPtr, 4U, (uint*) tiddataPtr);
        *(int*) ((IntPtr) tiddataPtr + 4) = (int) thread;
        if (thread == 0U)
        {
          num = \u003CModule\u003E.GetLastError();
        }
        else
        {
          if (\u003CModule\u003E.ResumeThread((void*) thread) != uint.MaxValue)
            return thread;
          num = \u003CModule\u003E.GetLastError();
        }
      }
    }
    \u003CModule\u003E.free((void*) tiddataPtr);
    if (num != 0U)
      \u003CModule\u003E._dosmaperr(num);
    return uint.MaxValue;
  }

  internal static unsafe uint \u003FA0x43294865\u002E_threadstart(void* ptd)
  {
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.__fls_getvalue(\u003CModule\u003E.__get_flsindex());
    if ((IntPtr) tiddataPtr == IntPtr.Zero)
    {
      if (\u003CModule\u003E.__fls_setvalue(\u003CModule\u003E.__get_flsindex(), ptd) == 0)
        \u003CModule\u003E.ExitThread(\u003CModule\u003E.GetLastError());
      else
        goto label_4;
    }
    *(int*) ((IntPtr) tiddataPtr + 84) = *(int*) ((IntPtr) ptd + 84);
    *(int*) ((IntPtr) tiddataPtr + 88) = *(int*) ((IntPtr) ptd + 88);
    *(int*) ((IntPtr) tiddataPtr + 4) = *(int*) ((IntPtr) ptd + 4);
    *(int*) ((IntPtr) tiddataPtr + 528) = *(int*) ((IntPtr) ptd + 528);
    \u003CModule\u003E._freefls(ptd);
label_4:
    uint num = 0;
    if (\u003CModule\u003E.\u003FA0x43294865\u002E_getdomain(&num) == 0)
      \u003CModule\u003E.ExitThread(0U);
    uint dwAppDomainId = (uint) *(int*) ((IntPtr) tiddataPtr + 528);
    if ((int) num != (int) dwAppDomainId)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.msclr\u002Ecall_in_appdomain(dwAppDomainId, (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callthreadstart\u0040\u003FA0x43294865\u0040\u0040\u0024\u0024FYAXXZ);
      return 0;
    }
    \u003CModule\u003E.\u003FA0x43294865\u002E_callthreadstart();
    return 0;
  }

  internal static unsafe void \u003FA0x43294865\u002E_callthreadstart()
  {
    _tiddata* tiddataPtr = \u003CModule\u003E._getptd();
    try
    {
      int num = *(int*) ((IntPtr) tiddataPtr + 88);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli((__FnPtr<void (void*)>) *(int*) ((IntPtr) tiddataPtr + 84))((void*) num);
      \u003CModule\u003E._endthread();
    }
    catch (Exception ex) when (\u003CModule\u003E._XcptFilter((uint) Marshal.GetExceptionCode(), (_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
      \u003CModule\u003E._exit(Marshal.GetExceptionCode());
    }
  }

  internal static unsafe int \u003FA0xb4b5ff21\u002E_getdomain(uint* pDomain)
  {
    *pDomain = 0U;
    ICLRRuntimeHost* iclrRuntimeHostPtr1 = (ICLRRuntimeHost*) 0;
    if (\u003CModule\u003E.CorBindToRuntimeEx((char*) 0, (char*) 0, 0U, &\u003CModule\u003E.CLSID_CLRRuntimeHost, &\u003CModule\u003E.IID_ICLRRuntimeHost, (void**) &iclrRuntimeHostPtr1) < 0)
    {
      if ((IntPtr) iclrRuntimeHostPtr1 != IntPtr.Zero)
      {
        ICLRRuntimeHost* iclrRuntimeHostPtr2 = iclrRuntimeHostPtr1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr2 + 8))((IntPtr) iclrRuntimeHostPtr2);
      }
      return 0;
    }
    uint num1 = 0;
    ICLRRuntimeHost* iclrRuntimeHostPtr3 = iclrRuntimeHostPtr1;
    ref uint local = ref num1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = __calli((__FnPtr<int (IntPtr, uint*)>) *(int*) (*(int*) iclrRuntimeHostPtr1 + 36))((uint*) iclrRuntimeHostPtr3, (IntPtr) ref local);
    ICLRRuntimeHost* iclrRuntimeHostPtr4 = iclrRuntimeHostPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) iclrRuntimeHostPtr4 + 8))((IntPtr) iclrRuntimeHostPtr4);
    if (num2 < 0)
      return 0;
    *pDomain = num1;
    return 1;
  }

  internal static unsafe uint _beginthreadex(
    void* security,
    uint stacksize,
    __FnPtr<uint (void*)> initialcode,
    void* argument,
    uint createflag,
    uint* thrdaddr)
  {
    uint num1 = 0;
    if (initialcode == null)
    {
      *\u003CModule\u003E._errno() = 22;
      \u003CModule\u003E._invalid_parameter((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
      return 0;
    }
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.calloc(1U, 532U);
    if ((IntPtr) tiddataPtr != IntPtr.Zero)
    {
      \u003CModule\u003E._initptd(tiddataPtr, (threadlocaleinfostruct*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 108));
      *(int*) ((IntPtr) tiddataPtr + 84) = (int) initialcode;
      *(int*) ((IntPtr) tiddataPtr + 88) = (int) argument;
      *(int*) ((IntPtr) tiddataPtr + 4) = -1;
      if (\u003CModule\u003E.\u003FA0xb4b5ff21\u002E_getdomain((uint*) ((IntPtr) tiddataPtr + 528)) != 0)
      {
        if ((IntPtr) thrdaddr == IntPtr.Zero)
        {
          uint num2;
          thrdaddr = &num2;
        }
        // ISSUE: cast to a function pointer type
        uint thread = (uint) \u003CModule\u003E.CreateThread((_SECURITY_ATTRIBUTES*) security, stacksize, (__FnPtr<uint (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_threadstartex\u0040\u003FA0xb4b5ff21\u0040\u0040\u0024\u0024FYGKPAX\u0040Z, (void*) tiddataPtr, createflag, thrdaddr);
        if (thread != 0U)
          return thread;
        num1 = \u003CModule\u003E.GetLastError();
      }
    }
    \u003CModule\u003E.free((void*) tiddataPtr);
    if (num1 != 0U)
      \u003CModule\u003E._dosmaperr(num1);
    return 0;
  }

  internal static unsafe uint \u003FA0xb4b5ff21\u002E_threadstartex(void* ptd)
  {
    \u003CModule\u003E.__set_flsgetvalue();
    _tiddata* tiddataPtr = (_tiddata*) \u003CModule\u003E.__fls_getvalue(\u003CModule\u003E.__get_flsindex());
    if ((IntPtr) tiddataPtr == IntPtr.Zero)
    {
      if (\u003CModule\u003E.__fls_setvalue(\u003CModule\u003E.__get_flsindex(), ptd) == 0)
        \u003CModule\u003E.ExitThread(\u003CModule\u003E.GetLastError());
      *(int*) ptd = (int) \u003CModule\u003E.GetCurrentThreadId();
    }
    else
    {
      *(int*) ((IntPtr) tiddataPtr + 84) = *(int*) ((IntPtr) ptd + 84);
      *(int*) ((IntPtr) tiddataPtr + 88) = *(int*) ((IntPtr) ptd + 88);
      *(int*) ((IntPtr) tiddataPtr + 4) = *(int*) ((IntPtr) ptd + 4);
      *(int*) ((IntPtr) tiddataPtr + 528) = *(int*) ((IntPtr) ptd + 528);
      \u003CModule\u003E._freefls(ptd);
    }
    uint num = 0;
    if (\u003CModule\u003E.\u003FA0xb4b5ff21\u002E_getdomain(&num) == 0)
      \u003CModule\u003E.ExitThread(0U);
    uint dwAppDomainId = (uint) *(int*) ((IntPtr) tiddataPtr + 528);
    if ((int) num != (int) dwAppDomainId)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.msclr\u002Ecall_in_appdomain(dwAppDomainId, (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_callthreadstartex\u0040\u003FA0xb4b5ff21\u0040\u0040\u0024\u0024FYAXXZ);
      return 0;
    }
    \u003CModule\u003E.\u003FA0xb4b5ff21\u002E_callthreadstartex();
    return 0;
  }

  internal static unsafe void \u003FA0xb4b5ff21\u002E_callthreadstartex()
  {
    _tiddata* tiddataPtr = \u003CModule\u003E._getptd();
    try
    {
      int num = *(int*) ((IntPtr) tiddataPtr + 88);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      \u003CModule\u003E._endthreadex(__calli((__FnPtr<uint (void*)>) *(int*) ((IntPtr) tiddataPtr + 84))((void*) num));
    }
    catch (Exception ex) when (\u003CModule\u003E._XcptFilter((uint) Marshal.GetExceptionCode(), (_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
      \u003CModule\u003E._exit(Marshal.GetExceptionCode());
    }
  }

  internal static unsafe void std\u002E_Mutex\u002E\u007Bdtor\u007D([In] _Mutex* obj0) => \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor(obj0);

  internal static unsafe void std\u002Elocale\u002Efacet\u002E_Incref([In] locale.facet* obj0)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 4);
      if (num2 >= uint.MaxValue)
        return;
      *(int*) ((IntPtr) obj0 + 4) = (int) num2 + 1;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe locale.facet* std\u002Elocale\u002Efacet\u002E_Decref(
    [In] locale.facet* obj0)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 4);
      if (0U < num2 && num2 < uint.MaxValue)
        *(int*) ((IntPtr) obj0 + 4) = (int) num2 - 1;
      return *(int*) ((IntPtr) obj0 + 4) == 0 ? (locale.facet*) (ValueType) (IntPtr) obj0 : (locale.facet*) (ValueType) 0;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe void std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D([In] locale.facet* obj0) => *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E\u007Bdtor\u007D(
    [In] locale._Locimp* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Locimp_dtor(obj0);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24));
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 24), true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void std\u002Elocale\u002E\u007Bdtor\u007D([In] locale* obj0)
  {
    uint num = (uint) *(int*) obj0;
    if (num == 0U)
      return;
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) num);
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void* std\u002Elocale\u002Efacet\u002E__vecDelDtor(
    [In] locale.facet* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      locale.facet* facetPtr = (locale.facet*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) facetPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) facetPtr);
      return (void*) facetPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Elocale\u002E_Locimp\u002E__vecDelDtor(
    [In] locale._Locimp* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      locale._Locimp* locimpPtr = (locale._Locimp*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) locimpPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E_Locimp\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) locimpPtr);
      return (void*) locimpPtr;
    }
    \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ecodecvt_base\u002E\u007Bdtor\u007D([In] codecvt_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ecodecvt_base\u002Edo_always_noconv([In] codecvt_base* obj0) => true;

  internal static unsafe int std\u002Ecodecvt_base\u002Edo_max_length([In] codecvt_base* obj0) => 1;

  internal static unsafe int std\u002Ecodecvt_base\u002Edo_encoding([In] codecvt_base* obj0) => 1;

  internal static unsafe void* std\u002Ecodecvt_base\u002E__vecDelDtor(
    [In] codecvt_base* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt_base* codecvtBasePtr = (codecvt_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) codecvtBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) codecvtBasePtr);
      return (void*) codecvtBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_in(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    char* _First2,
    char* _Last2,
    char** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      do
      {
        uint pwc = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) pwc != (IntPtr) _Last2)
        {
          uint s = (uint) *(int*) _Mid1;
          int num3 = \u003CModule\u003E._Mbrtowc((char*) pwc, (sbyte*) s, (uint) (_Last1 - (int) s), _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
          if (num3 != -2)
          {
            if (num3 != -1)
            {
              if (num3 == 0)
              {
                if (*(ushort*) *(int*) _Mid2 == (ushort) 0)
                  num3 = (int) \u003CModule\u003E.strlen((sbyte*) *(int*) _Mid1) + 1;
                else
                  goto label_9;
              }
              if (num3 == -3)
                num3 = 0;
label_9:
              sbyte** numPtr = _Mid1;
              int num4 = *(int*) numPtr + num3;
              *(int*) numPtr = num4;
              char** chPtr = _Mid2;
              int num5 = *(int*) chPtr + 2;
              *(int*) chPtr = num5;
              num2 = 0;
            }
            else
              goto label_10;
          }
          else
            goto label_11;
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_10:
      return 2;
label_11:
      *(int*) _Mid1 = (int) _Last1;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_out(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    char* _First1,
    char* _Last1,
    char** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      int num3;
      do
      {
        uint s = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) s != (IntPtr) _Last2)
        {
          if (new IntPtr(5) <= (IntPtr) (_Last2 - (int) s))
          {
            int num4 = \u003CModule\u003E._Wcrtomb((sbyte*) s, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
            if (num4 >= 0)
            {
              char** chPtr = _Mid1;
              int num5 = *(int*) chPtr + 2;
              *(int*) chPtr = num5;
              sbyte** numPtr = _Mid2;
              int num6 = *(int*) numPtr + num4;
              *(int*) numPtr = num6;
              num2 = 0;
            }
            else
              goto label_9;
          }
          else
          {
            num3 = *_State;
            \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
            int num7 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
            if (num7 >= 0)
            {
              uint num8 = (uint) *(int*) _Mid2;
              sbyte* numPtr1 = _Last2 - (int) num8;
              if ((IntPtr) numPtr1 >= (IntPtr) num7)
              {
                \u003CModule\u003E.memcpy_s((void*) num8, (uint) numPtr1, (void*) &arrayTypeBy04D, (uint) num7);
                char** chPtr = _Mid1;
                int num9 = *(int*) chPtr + 2;
                *(int*) chPtr = num9;
                sbyte** numPtr2 = _Mid2;
                int num10 = *(int*) numPtr2 + num7;
                *(int*) numPtr2 = num10;
                num2 = 0;
              }
              else
                goto label_11;
            }
            else
              goto label_10;
          }
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_9:
      return 2;
label_10:
      return 2;
label_11:
      *_State = num3;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_unshift(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid2 = (int) _First2;
    int num1 = 0;
    int num2 = *_State;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    int num3 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, char.MinValue, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
    if (num3 <= 0)
    {
      num1 = 2;
    }
    else
    {
      int num4 = num3 - 1;
      int num5 = *(int*) _Mid2;
      sbyte* numPtr1 = _Last2 - num5;
      if ((IntPtr) numPtr1 < (IntPtr) num4)
      {
        *_State = num2;
        num1 = 1;
      }
      else if (0 < num4)
      {
        \u003CModule\u003E.memcpy_s((void*) num5, (uint) numPtr1, (void*) &arrayTypeBy04D, (uint) num4);
        sbyte** numPtr2 = _Mid2;
        int num6 = *(int*) numPtr2 + num4;
        *(int*) numPtr2 = num6;
      }
    }
    return num1;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_length(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    uint _Count)
  {
    int num1 = *_State;
    int num2 = 0;
    sbyte* s = _First1;
    if (0U < _Count)
    {
      while (s != _Last1)
      {
        char ch;
        int num3 = \u003CModule\u003E._Mbrtowc(&ch, s, (uint) ((IntPtr) _Last1 - (IntPtr) s), &num1, (_Cvtvec*) ((IntPtr) obj0 + 8));
        if (num3 == -2 || num3 == -1)
          return num2;
        if (num3 == 0)
        {
          if (ch == char.MinValue)
            num3 = (int) \u003CModule\u003E.strlen(s) + 1;
          else
            goto label_8;
        }
        if (num3 == -3)
          num3 = 0;
label_8:
        s = (sbyte*) (num3 + (IntPtr) s);
        ++num2;
        if ((uint) num2 >= _Count)
          break;
      }
    }
    return num2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_always_noconv(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    return false;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_max_length(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    return 5;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_encoding(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E__vecDelDtor(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) codecvtWcharTCharIntPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) codecvtWcharTCharIntPtr);
      return (void*) codecvtWcharTCharIntPtr;
    }
    \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_in(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    ushort* _First2,
    ushort* _Last2,
    ushort** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      do
      {
        uint pwc = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) pwc != (IntPtr) _Last2)
        {
          uint s = (uint) *(int*) _Mid1;
          int num3 = \u003CModule\u003E._Mbrtowc((char*) pwc, (sbyte*) s, (uint) (_Last1 - (int) s), _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
          if (num3 != -2)
          {
            if (num3 != -1)
            {
              if (num3 == 0)
              {
                if (*(ushort*) *(int*) _Mid2 == (ushort) 0)
                  num3 = (int) \u003CModule\u003E.strlen((sbyte*) *(int*) _Mid1) + 1;
                else
                  goto label_9;
              }
              if (num3 == -3)
                num3 = 0;
label_9:
              sbyte** numPtr1 = _Mid1;
              int num4 = *(int*) numPtr1 + num3;
              *(int*) numPtr1 = num4;
              ushort** numPtr2 = _Mid2;
              int num5 = *(int*) numPtr2 + 2;
              *(int*) numPtr2 = num5;
              num2 = 0;
            }
            else
              goto label_10;
          }
          else
            goto label_11;
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_10:
      return 2;
label_11:
      *(int*) _Mid1 = (int) _Last1;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_out(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    ushort* _First1,
    ushort* _Last1,
    ushort** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    uint num1 = (uint) *(int*) _Mid1;
    int num2 = (IntPtr) (int) num1 == (IntPtr) _Last1 ? 0 : 1;
    if ((IntPtr) (int) num1 != (IntPtr) _Last1)
    {
      int num3;
      do
      {
        uint s = (uint) *(int*) _Mid2;
        if ((IntPtr) (int) s != (IntPtr) _Last2)
        {
          if (new IntPtr(5) <= (IntPtr) (_Last2 - (int) s))
          {
            int num4 = \u003CModule\u003E._Wcrtomb((sbyte*) s, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
            if (num4 >= 0)
            {
              ushort** numPtr1 = _Mid1;
              int num5 = *(int*) numPtr1 + 2;
              *(int*) numPtr1 = num5;
              sbyte** numPtr2 = _Mid2;
              int num6 = *(int*) numPtr2 + num4;
              *(int*) numPtr2 = num6;
              num2 = 0;
            }
            else
              goto label_9;
          }
          else
          {
            num3 = *_State;
            \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
            int num7 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, (char) *(ushort*) *(int*) _Mid1, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
            if (num7 >= 0)
            {
              uint num8 = (uint) *(int*) _Mid2;
              sbyte* numPtr3 = _Last2 - (int) num8;
              if ((IntPtr) numPtr3 >= (IntPtr) num7)
              {
                \u003CModule\u003E.memcpy_s((void*) num8, (uint) numPtr3, (void*) &arrayTypeBy04D, (uint) num7);
                ushort** numPtr4 = _Mid1;
                int num9 = *(int*) numPtr4 + 2;
                *(int*) numPtr4 = num9;
                sbyte** numPtr5 = _Mid2;
                int num10 = *(int*) numPtr5 + num7;
                *(int*) numPtr5 = num10;
                num2 = 0;
              }
              else
                goto label_11;
            }
            else
              goto label_10;
          }
        }
        else
          break;
      }
      while ((IntPtr) *(int*) _Mid1 != (IntPtr) _Last1);
      goto label_12;
label_9:
      return 2;
label_10:
      return 2;
label_11:
      *_State = num3;
      return num2;
    }
label_12:
    return num2;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_unshift(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    *(int*) _Mid2 = (int) _First2;
    int num1 = 0;
    int num2 = *_State;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    int num3 = \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, char.MinValue, _State, (_Cvtvec*) ((IntPtr) obj0 + 8));
    if (num3 <= 0)
    {
      num1 = 2;
    }
    else
    {
      int num4 = num3 - 1;
      int num5 = *(int*) _Mid2;
      sbyte* numPtr1 = _Last2 - num5;
      if ((IntPtr) numPtr1 < (IntPtr) num4)
      {
        *_State = num2;
        num1 = 1;
      }
      else if (0 < num4)
      {
        \u003CModule\u003E.memcpy_s((void*) num5, (uint) numPtr1, (void*) &arrayTypeBy04D, (uint) num4);
        sbyte** numPtr2 = _Mid2;
        int num6 = *(int*) numPtr2 + num4;
        *(int*) numPtr2 = num6;
      }
    }
    return num1;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_length(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    uint _Count)
  {
    int num1 = *_State;
    int num2 = 0;
    sbyte* s = _First1;
    if (0U < _Count)
    {
      while (s != _Last1)
      {
        ushort num3;
        int num4 = \u003CModule\u003E._Mbrtowc((char*) &num3, s, (uint) ((IntPtr) _Last1 - (IntPtr) s), &num1, (_Cvtvec*) ((IntPtr) obj0 + 8));
        if (num4 == -2 || num4 == -1)
          return num2;
        if (num4 == 0)
        {
          if (num3 == (ushort) 0)
            num4 = (int) \u003CModule\u003E.strlen(s) + 1;
          else
            goto label_8;
        }
        if (num4 == -3)
          num4 = 0;
label_8:
        s = (sbyte*) (num4 + (IntPtr) s);
        ++num2;
        if ((uint) num2 >= _Count)
          break;
      }
    }
    return num2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_always_noconv(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    return false;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_max_length(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    return 5;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_encoding(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E__vecDelDtor(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) unsignedShortCharIntPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) unsignedShortCharIntPtr);
      return (void*) unsignedShortCharIntPtr;
    }
    \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ectype_base\u002E\u007Bdtor\u007D([In] ctype_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void* std\u002Ectype_base\u002E__vecDelDtor([In] ctype_base* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype_base* ctypeBasePtr = (ctype_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) ctypeBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeBasePtr);
      return (void*) ctypeBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ectype\u003Cchar\u003E\u002E\u007Bdtor\u007D(
    [In] ctype\u003Cchar\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void std\u002Ectype\u003Cchar\u003E\u002E_Tidy([In] ctype\u003Cchar\u003E* obj0)
  {
    int num = *(int*) ((IntPtr) obj0 + 20);
    if (0 < num)
    {
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 16));
    }
    else
    {
      if (num >= 0)
        return;
      \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    }
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_tolower(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Ch)
  {
    return (sbyte) \u003CModule\u003E._Tolower((int) (byte) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_tolower(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cchar\u003E* ploc = (ctype\u003Cchar\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        sbyte* numPtr = _First;
        int num = \u003CModule\u003E._Tolower((int) (byte) *numPtr, (_Ctypevec*) ploc);
        *numPtr = (sbyte) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_toupper(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Ch)
  {
    return (sbyte) \u003CModule\u003E._Toupper((int) (byte) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_toupper(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cchar\u003E* ploc = (ctype\u003Cchar\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        sbyte* numPtr = _First;
        int num = \u003CModule\u003E._Toupper((int) (byte) *numPtr, (_Ctypevec*) ploc);
        *numPtr = (sbyte) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_widen(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Byte)
  {
    return _Byte;
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_widen(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte* _Dest)
  {
    ctype\u003Cchar\u003E* ctypeCharPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    sbyte* numPtr3 = _Dest;
    IntPtr num = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, sbyte*, uint)>) *(int*) (*(int*) obj0 + 28))((uint) ctypeCharPtr, numPtr1, numPtr2, numPtr3, num);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002E_Do_widen_s(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte* _Dest,
    uint _Dest_size)
  {
    uint num = (uint) ((IntPtr) _Last - (IntPtr) _First);
    if (_Dest_size < num)
      \u003CModule\u003E._invalid_parameter_noinfo();
    \u003CModule\u003E.memcpy_s((void*) _Dest, _Dest_size, (void*) _First, num);
    return _Last;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cchar\u003E\u002Edo_narrow(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte _Ch,
    sbyte __unnamed001)
  {
    return _Ch;
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002Edo_narrow(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte _Dflt,
    sbyte* _Dest)
  {
    ctype\u003Cchar\u003E* ctypeCharPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    int num1 = (int) _Dflt;
    sbyte* numPtr3 = _Dest;
    IntPtr num2 = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, sbyte, sbyte*, uint)>) *(int*) (*(int*) obj0 + 40))((uint) ctypeCharPtr, numPtr1, (sbyte) numPtr2, (sbyte*) num1, numPtr3, num2);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cchar\u003E\u002E_Do_narrow_s(
    [In] ctype\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    sbyte __unnamed002,
    sbyte* _Dest,
    uint _Dest_size)
  {
    uint num = (uint) ((IntPtr) _Last - (IntPtr) _First);
    if (_Dest_size < num)
      \u003CModule\u003E._invalid_parameter_noinfo();
    \u003CModule\u003E.memcpy_s((void*) _Dest, _Dest_size, (void*) _First, num);
    return _Last;
  }

  internal static unsafe void* std\u002Ectype\u003Cchar\u003E\u002E__vecDelDtor(
    [In] ctype\u003Cchar\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype\u003Cchar\u003E* ctypeCharPtr = (ctype\u003Cchar\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24U, *(int*) ctypeCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeCharPtr);
      return (void*) ctypeCharPtr;
    }
    \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cwchar_t\u003E\u002Eis(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
    int num1 = (int) _Maskval;
    int num2 = (int) _Ch;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeWcharTPtr, (short) num1, (IntPtr) num2);
  }

  internal static unsafe void std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] ctype\u003Cwchar_t\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(int*) ((IntPtr) obj0 + 20) != 0)
        \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 16));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return (short) ((int) \u003CModule\u003E._Getwctype(_Ch, (_Ctypevec*) ((IntPtr) obj0 + 8)) & (int) _Maskval) != (short) 0;
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last,
    short* _Dest)
  {
    return \u003CModule\u003E._Getwctypes(_First, _Last, _Dest, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_is(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        char ch = *_First;
        ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
        int num1 = (int) _Maskval;
        int num2 = (int) ch;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeWcharTPtr, (short) num1, (IntPtr) num2) == (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_not(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    short _Maskval,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        char ch = *_First;
        ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
        int num1 = (int) _Maskval;
        int num2 = (int) ch;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeWcharTPtr, (short) num1, (IntPtr) num2) != (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return \u003CModule\u003E._Towlower(_Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cwchar_t\u003E* _Ctype = (ctype\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        char* chPtr = _First;
        int num = (int) \u003CModule\u003E._Towlower(*chPtr, (_Ctypevec*) _Ctype);
        *chPtr = (char) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return \u003CModule\u003E._Towupper(_Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cwchar_t\u003E* _Ctype = (ctype\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        char* chPtr = _First;
        int num = (int) \u003CModule\u003E._Towupper(*chPtr, (_Ctypevec*) _Ctype);
        *chPtr = (char) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002E_Dowiden(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte _Byte)
  {
    int num = 0;
    char ch;
    return \u003CModule\u003E._Mbrtowc(&ch, &_Byte, 1U, &num, (_Cvtvec*) ((IntPtr) obj0 + 24)) >= 0 ? ch : char.MaxValue;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte _Byte)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Dowiden(obj0, _Byte);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    char* _Dest)
  {
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    char* chPtr = _Dest;
    IntPtr num = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, char*, uint)>) *(int*) (*(int*) obj0 + 44))((uint) ctypeWcharTPtr, (char*) numPtr1, numPtr2, (sbyte*) chPtr, num);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_widen_s(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    char* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) _Last - (UIntPtr) _First)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Dowiden(obj0, *_First);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cwchar_t\u003E\u002E_Donarrow(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch,
    sbyte _Dflt)
  {
    int num = 0;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, _Ch, &num, (_Cvtvec*) ((IntPtr) obj0 + 24)) == 1 ? ^(sbyte&) ref arrayTypeBy04D : _Dflt;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch,
    sbyte _Dflt)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Donarrow(obj0, _Ch, _Dflt);
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last,
    sbyte _Dflt,
    sbyte* _Dest)
  {
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = obj0;
    char* chPtr1 = _First;
    char* chPtr2 = _Last;
    int num1 = (int) _Dflt;
    sbyte* numPtr = _Dest;
    IntPtr num2 = (IntPtr) _Last - (IntPtr) _First >> 1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<char* (IntPtr, char*, char*, sbyte, sbyte*, uint)>) *(int*) (*(int*) obj0 + 56))((uint) ctypeWcharTPtr, (sbyte*) chPtr1, (sbyte) chPtr2, (char*) num1, (char*) numPtr, num2);
  }

  internal static unsafe char* std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_narrow_s(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last,
    sbyte _Dflt,
    sbyte* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) ((IntPtr) _Last - (IntPtr) _First >> 1))
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Donarrow(obj0, *_First, _Dflt);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe void* std\u002Ectype\u003Cwchar_t\u003E\u002E__vecDelDtor(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = (ctype\u003Cwchar_t\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 32U, *(int*) ctypeWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeWcharTPtr);
      return (void*) ctypeWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Eis(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort _Ch)
  {
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
    int num1 = (int) _Maskval;
    int num2 = (int) _Ch;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (bool) __calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeUnsignedShortPtr, (short) num1, (IntPtr) num2);
  }

  internal static unsafe void std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(int*) ((IntPtr) obj0 + 20) != 0)
        \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 16));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort _Ch)
  {
    return (short) ((int) \u003CModule\u003E._Getwctype((char) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8)) & (int) _Maskval) != (short) 0;
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last,
    short* _Dest)
  {
    return (ushort*) \u003CModule\u003E._Getwctypes((char*) _First, (char*) _Last, _Dest, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_is(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        ushort num1 = *_First;
        ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
        int num2 = (int) _Maskval;
        int num3 = (int) num1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeUnsignedShortPtr, (short) num2, (IntPtr) num3) == (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_not(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    short _Maskval,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      do
      {
        ushort num1 = *_First;
        ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
        int num2 = (int) _Maskval;
        int num3 = (int) num1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<byte (IntPtr, short, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) ctypeUnsignedShortPtr, (short) num2, (IntPtr) num3) != (byte) 0)
          ++_First;
        else
          break;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch)
  {
    return (ushort) \u003CModule\u003E._Towlower((char) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cunsigned\u0020short\u003E* _Ctype = (ctype\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        ushort* numPtr = _First;
        int num = (int) \u003CModule\u003E._Towlower((char) *numPtr, (_Ctypevec*) _Ctype);
        *numPtr = (ushort) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch)
  {
    return (ushort) \u003CModule\u003E._Towupper((char) _Ch, (_Ctypevec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    if (_First != _Last)
    {
      ctype\u003Cunsigned\u0020short\u003E* _Ctype = (ctype\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        ushort* numPtr = _First;
        int num = (int) \u003CModule\u003E._Towupper((char) *numPtr, (_Ctypevec*) _Ctype);
        *numPtr = (ushort) num;
        ++_First;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Dowiden(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte _Byte)
  {
    int num1 = 0;
    ushort num2;
    return \u003CModule\u003E._Mbrtowc((char*) &num2, &_Byte, 1U, &num1, (_Cvtvec*) ((IntPtr) obj0 + 24)) >= 0 ? num2 : ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte _Byte)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Dowiden(obj0, _Byte);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    ushort* _Dest)
  {
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
    sbyte* numPtr1 = _First;
    sbyte* numPtr2 = _Last;
    ushort* numPtr3 = _Dest;
    IntPtr num = (IntPtr) _Last - (IntPtr) _First;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte* (IntPtr, sbyte*, sbyte*, ushort*, uint)>) *(int*) (*(int*) obj0 + 44))((uint) ctypeUnsignedShortPtr, (ushort*) numPtr1, numPtr2, (sbyte*) numPtr3, num);
  }

  internal static unsafe sbyte* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_widen_s(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    sbyte* _First,
    sbyte* _Last,
    ushort* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) _Last - (UIntPtr) _First)
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Dowiden(obj0, *_First);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Donarrow(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch,
    sbyte _Dflt)
  {
    int num = 0;
    \u0024ArrayType\u0024\u0024\u0024BY04D arrayTypeBy04D;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return \u003CModule\u003E._Wcrtomb((sbyte*) &arrayTypeBy04D, (char) _Ch, &num, (_Cvtvec*) ((IntPtr) obj0 + 24)) == 1 ? ^(sbyte&) ref arrayTypeBy04D : _Dflt;
  }

  internal static unsafe sbyte std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort _Ch,
    sbyte _Dflt)
  {
    return \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Donarrow(obj0, _Ch, _Dflt);
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last,
    sbyte _Dflt,
    sbyte* _Dest)
  {
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = obj0;
    ushort* numPtr1 = _First;
    ushort* numPtr2 = _Last;
    int num1 = (int) _Dflt;
    sbyte* numPtr3 = _Dest;
    IntPtr num2 = (IntPtr) _Last - (IntPtr) _First >> 1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort* (IntPtr, ushort*, ushort*, sbyte, sbyte*, uint)>) *(int*) (*(int*) obj0 + 56))((uint) ctypeUnsignedShortPtr, (sbyte*) numPtr1, (sbyte) numPtr2, (ushort*) num1, (ushort*) numPtr3, num2);
  }

  internal static unsafe ushort* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_narrow_s(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last,
    sbyte _Dflt,
    sbyte* _Dest,
    uint _Dest_size)
  {
    if ((UIntPtr) (int) _Dest_size < (UIntPtr) ((IntPtr) _Last - (IntPtr) _First >> 1))
      \u003CModule\u003E._invalid_parameter_noinfo();
    if (_First != _Last)
    {
      do
      {
        *_Dest = \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Donarrow(obj0, *_First, _Dflt);
        ++_First;
        ++_Dest;
      }
      while (_First != _Last);
    }
    return _First;
  }

  internal static unsafe void* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = (ctype\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 32U, *(int*) ctypeUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ctypeUnsignedShortPtr);
      return (void*) ctypeUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Eios_base\u002Eclear(
    [In] ios_base* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int num1 = _State & 23;
    *(int*) ((IntPtr) obj0 + 8) = num1;
    int num2 = *(int*) ((IntPtr) obj0 + 12) & num1;
    if (num2 == 0)
      return;
    if (_Reraise)
      \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
    if ((num2 & 4) != 0)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    else if ((num2 & 2) != 0)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    else
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
  }

  internal static unsafe int std\u002Eios_base\u002Eflags([In] ios_base* obj0) => *(int*) ((IntPtr) obj0 + 16);

  internal static unsafe int std\u002Eios_base\u002Ewidth([In] ios_base* obj0) => *(int*) ((IntPtr) obj0 + 24);

  internal static unsafe void std\u002Eios_base\u002E\u007Bdtor\u007D([In] ios_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor(obj0);
  }

  internal static unsafe void* std\u002Eios_base\u002E__vecDelDtor([In] ios_base* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      ios_base* iosBasePtr = (ios_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 40U, *(int*) iosBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) iosBasePtr);
      return (void*) iosBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002E\u003FA0x7886e949\u002Ersfun(ios_base* iostr, int mask) => *(int*) ((IntPtr) iostr + 16) = *(int*) ((IntPtr) iostr + 16) & ~mask;

  internal static unsafe void std\u002E\u003FA0x7886e949\u002Esifun(ios_base* iostr, int mask) => *(int*) ((IntPtr) iostr + 16) = ~mask & *(int*) ((IntPtr) iostr + 16) | mask & (int) ushort.MaxValue;

  internal static unsafe void std\u002E\u003FA0x7886e949\u002Esbfun(ios_base* iostr, int @base)
  {
    _Iosb\u003Cint\u003E._Fmtflags fmtflags1;
    _Iosb\u003Cint\u003E._Fmtflags fmtflags2;
    _Iosb\u003Cint\u003E._Fmtflags fmtflags3;
    switch (@base)
    {
      case 8:
        fmtflags1 = (_Iosb\u003Cint\u003E._Fmtflags) 1024;
        goto label_7;
      case 10:
        fmtflags2 = (_Iosb\u003Cint\u003E._Fmtflags) 512;
        goto label_6;
      case 16:
        fmtflags3 = (_Iosb\u003Cint\u003E._Fmtflags) 2048;
        break;
      default:
        fmtflags3 = (_Iosb\u003Cint\u003E._Fmtflags) 0;
        break;
    }
    fmtflags2 = fmtflags3;
label_6:
    fmtflags1 = fmtflags2;
label_7:
    *(int*) ((IntPtr) iostr + 16) = (int) ((_Iosb\u003Cint\u003E._Fmtflags) *(int*) ((IntPtr) iostr + 16) ^ ((_Iosb\u003Cint\u003E._Fmtflags) *(int*) ((IntPtr) iostr + 16) ^ fmtflags1) & (_Iosb\u003Cint\u003E._Fmtflags) 3584);
  }

  internal static unsafe void std\u002E\u003FA0x7886e949\u002Espfun(ios_base* iostr, int prec) => *(int*) ((IntPtr) iostr + 20) = prec;

  internal static unsafe void std\u002E\u003FA0x7886e949\u002Eswfun(ios_base* iostr, int wide) => *(int*) ((IntPtr) iostr + 24) = wide;

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Eresetiosflags(
    [In] _Smanip\u003Cint\u003E* obj0,
    int mask)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Frsfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = mask;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetiosflags(
    [In] _Smanip\u003Cint\u003E* obj0,
    int mask)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fsifun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = mask;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetbase(
    [In] _Smanip\u003Cint\u003E* obj0,
    int @base)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fsbfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = @base;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetprecision(
    [In] _Smanip\u003Cint\u003E* obj0,
    int prec)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fspfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = prec;
    return obj0;
  }

  internal static unsafe _Smanip\u003Cint\u003E* std\u002Esetw(
    [In] _Smanip\u003Cint\u003E* obj0,
    int wide)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.__unep\u0040\u003Fswfun\u0040\u003FA0x7886e949\u0040std\u0040\u0040\u0024\u0024FYAXAAVios_base\u00402\u0040H\u0040Z;
    *(int*) ((IntPtr) obj0 + 4) = wide;
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    uint _Count)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Count);
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Ptr);
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Count,
    sbyte _Ch)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Count, _Ch);
    return obj0;
  }

  [SpecialName]
  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte _Ch)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(obj0, 1U, _Ch);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (num1 < _Count)
      _Count = num1;
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (uint.MaxValue - num2 <= _Count || num2 + _Count < num2)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = (uint) *(int*) ((IntPtr) obj0 + 20) + _Count;
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        uint num3 = (uint) *(int*) ((IntPtr) obj0 + 20);
        \u003CModule\u003E.memcpy_s((void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) num3), (uint) *(int*) ((IntPtr) obj0 + 24) - num3, (void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(_Right) + (int) _Roff), _Count);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    uint _Count)
  {
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Inside(obj0, _Ptr))
    {
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = obj0;
      IntPtr _Roff = (IntPtr) _Ptr - (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0);
      int _Count1 = (int) _Count;
      return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(_Right, _Right, (uint) _Roff, (uint) _Count1);
    }
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (uint.MaxValue - num1 <= _Count || num1 + _Count < num1)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = (uint) *(int*) ((IntPtr) obj0 + 20) + _Count;
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20);
        \u003CModule\u003E.memcpy_s((void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) num2), (uint) *(int*) ((IntPtr) obj0 + 24) - num2, (void*) _Ptr, _Count);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Count,
    sbyte _Ch)
  {
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = obj0;
        int _Off = *(int*) ((IntPtr) stdAllocatorCharPtr + 20);
        int _Count1 = (int) _Count;
        int _Ch1 = (int) _Ch;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(stdAllocatorCharPtr, (uint) _Off, (uint) _Count1, (sbyte) _Ch1);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint _Newsize = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (_Count < _Newsize)
      _Newsize = _Count;
    if (obj0 == _Right)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(obj0, _Newsize + _Roff, uint.MaxValue);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(obj0, 0U, _Roff);
    }
    else if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
    {
      \u003CModule\u003E.memcpy_s((void*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(_Right) + (int) _Roff), _Newsize);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    uint _Num)
  {
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Inside(obj0, _Ptr))
    {
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = obj0;
      IntPtr _Roff = (IntPtr) _Ptr - (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0);
      int _Count = (int) _Num;
      return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(_Right, _Right, (uint) _Roff, (uint) _Count);
    }
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Num, false))
    {
      \u003CModule\u003E.memcpy_s((void*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (void*) _Ptr, _Num);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Num;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Num] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    uint _Num = \u003CModule\u003E.strlen(_Ptr);
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Num);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Count,
    sbyte _Ch)
  {
    if (_Count == uint.MaxValue)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Count, false))
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(obj0, 0U, _Count, _Ch);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Count;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Count] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    sbyte _Ch)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off + (int) _Count, (uint) *(int*) ((IntPtr) obj0 + 24) - _Off - _Count, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off, (uint) *(int*) ((IntPtr) obj0 + 20) - _Off);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(obj0, _Off, _Count, _Ch);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num < _Count)
      _Count = num;
    if (0U < _Count)
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off, (uint) *(int*) ((IntPtr) obj0 + 24) - _Off, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off + (int) _Count, num - _Count);
      uint index = (uint) *(int*) ((IntPtr) obj0 + 20) - _Count;
      *(int*) ((IntPtr) obj0 + 20) = (int) index;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) index] = (sbyte) 0;
    }
    return obj0;
  }

  internal static unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) obj1, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), (_Container_base*) obj0);
    return obj1;
  }

  internal static unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) obj1, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + *(int*) ((IntPtr) obj0 + 20), (_Container_base*) obj0);
    return obj1;
  }

  internal static unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off)
  {
    if (_Off > (uint) *(int*) ((IntPtr) obj0 + 20))
      \u003CModule\u003E._invalid_parameter_noinfo();
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off;
  }

  internal static unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0);
  }

  internal static unsafe uint std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return (uint) *(int*) ((IntPtr) obj0 + 20);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eresize(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Newsize,
    sbyte _Ch)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (_Newsize <= num)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(obj0, _Newsize, uint.MaxValue);
    else
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(obj0, _Newsize - num, _Ch);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Newcap)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (num > _Newcap || *(int*) ((IntPtr) obj0 + 24) == (int) _Newcap)
      return;
    uint index = num;
    if (!\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(obj0, _Newcap, true))
      return;
    *(int*) ((IntPtr) obj0 + 20) = (int) index;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) index] = (sbyte) 0;
  }

  internal static unsafe int std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    uint _Count = \u003CModule\u003E.strlen(_Ptr);
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare(obj0, 0U, (uint) *(int*) ((IntPtr) obj0 + 20), _Ptr, _Count);
  }

  internal static unsafe int std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _N0,
    sbyte* _Ptr,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num1 < _N0)
      _N0 = num1;
    uint num2 = _N0 >= _Count ? _Count : _N0;
    uint num3 = (uint) \u003CModule\u003E.memcmp((void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off), (void*) _Ptr, num2);
    return num3 == 0U ? (_N0 >= _Count ? ((int) _N0 == (int) _Count ? 0 : 1) : -1) : (int) num3;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Chassign(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    sbyte _Ch)
  {
    if (_Count == 1U)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Off] = _Ch;
    else
      \u003CModule\u003E.memset((void*) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + (int) _Off), (int) _Ch, _Count);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Copy(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Newsize,
    uint _Oldlen)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    uint num3 = _Newsize | 15U;
    if (4294967294U < num3)
    {
      num3 = _Newsize;
    }
    else
    {
      uint num4 = (uint) *(int*) ((IntPtr) obj0 + 24);
      uint num5 = num4 >> 1;
      if (num3 / 3U < num5 && num4 <= 4294967294U - num5)
        num3 = num5 + num4;
    }
    sbyte* _First1 = (sbyte*) 0;
    int num6;
    try
    {
      num6 = (int) num1 + num2;
      _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cchar\u003E(num3 + 1U, (sbyte*) 0);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num6);
      try
      {
        try
        {
          num3 = _Newsize;
          try
          {
            _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cchar\u003E(_Newsize + 1U, (sbyte*) 0);
            goto label_23;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num8 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
            try
            {
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
                \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
              }
              catch (Exception ex3) when (
              {
                // ISSUE: unable to correctly present filter
                num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num8 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              if (num8 != 0U)
                throw;
              else
                goto label_23;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
            }
          }
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num6, (int) num7);
      }
    }
label_23:
    if (0U < _Oldlen)
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First1, num3 + 1U, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0), _Oldlen);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
    *(int*) ((IntPtr) obj0 + 4) = (int) _First1;
    *(int*) ((IntPtr) obj0 + 24) = (int) num3;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Oldlen;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Oldlen] = (sbyte) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Grow(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U1)] bool _Trim)
  {
    if (4294967294U < _Newsize)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if ((uint) *(int*) ((IntPtr) obj0 + 24) < _Newsize)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Copy(obj0, _Newsize, (uint) *(int*) ((IntPtr) obj0 + 20));
    else if (_Trim && _Newsize < 16U)
    {
      uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
      uint _Newsize1 = _Newsize >= num ? num : _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(obj0, true, _Newsize1);
    }
    else if (_Newsize == 0U)
    {
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) = (sbyte) 0;
    }
    return 0U < _Newsize;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Inside(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr)
  {
    return _Ptr >= \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) && \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0) + *(int*) ((IntPtr) obj0 + 20) > _Ptr;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Built,
    uint _Newsize)
  {
    if (_Built && 16U <= (uint) *(int*) ((IntPtr) obj0 + 24))
    {
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      sbyte* numPtr = (sbyte*) *(int*) stdAllocatorCharPtr;
      if (0U < _Newsize)
        \u003CModule\u003E.memcpy_s((void*) stdAllocatorCharPtr, 16U, (void*) numPtr, _Newsize);
      \u003CModule\u003E.delete((void*) numPtr);
    }
    *(int*) ((IntPtr) obj0 + 24) = 15;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(obj0)[(int) _Newsize] = (sbyte) 0;
  }

  internal static unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 16U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (sbyte*) *(int*) ((IntPtr) obj0 + 4) : (sbyte*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe sbyte* std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 16U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (sbyte*) *(int*) ((IntPtr) obj0 + 4) : (sbyte*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int _State = 0;
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = obj0;
    int num1 = *(int*) (*(int*) stdCharTraitsCharPtr1 + 4);
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) stdCharTraitsCharPtr1 + num1);
    if (((*(int*) ((IntPtr) stdCharTraitsCharPtr2 + 8) & 6) != 0 ? 1 : 0) == 0)
    {
      int num2 = *(int*) ((IntPtr) stdCharTraitsCharPtr2 + 40);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (__calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) num2 + 48))((IntPtr) num2) == -1)
        _State = 4;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _State, false);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor((ios_base*) obj0);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetstate(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    if (_State == 0)
      return;
    basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    int _State1 = *(int*) ((IntPtr) stdCharTraitsCharPtr + 8) | _State;
    int num = _Reraise ? 1 : 0;
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclear(stdCharTraitsCharPtr, _State1, num != 0);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor((ios_base*) obj0);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Eios_base\u002E_Ios_base_dtor((ios_base*) obj0);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      locale* localePtr = (locale*) *(int*) ((IntPtr) obj0 + 56);
      if ((IntPtr) localePtr != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
        \u003CModule\u003E.delete((void*) localePtr);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor((_Mutex*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _param1)
  {
    return -1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _param1)
  {
    return -1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eshowmanyc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return -1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return -1 == __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 16))((IntPtr) stdCharTraitsCharPtr) ? -1 : (int) (byte) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc(obj0);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsgetn(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    int _Count)
  {
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    sbyte* numPtr = _Ptr;
    int num = _Count;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, sbyte*, uint, int)>) *(int*) (*(int*) obj0 + 28))((int) stdCharTraitsCharPtr, (uint) numPtr, (sbyte*) -1, (IntPtr) num);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Xsgetn_s(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    uint _Ptr_size,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gnavail(obj0);
        if (0 < num2)
        {
          int _Count1 = num2;
          if (_Count < num2)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_Ptr, _Ptr_size, (sbyte*) *(int*) *(int*) ((IntPtr) obj0 + 32), (uint) _Count1);
          _Ptr = (sbyte*) (_Count1 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 48);
          *(int*) num3 = *(int*) num3 - _Count1;
          int num4 = *(int*) ((IntPtr) obj0 + 32);
          *(int*) num4 = *(int*) num4 + _Count1;
        }
        else
        {
          basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          int num5 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 20))((IntPtr) stdCharTraitsCharPtr);
          if (-1 != num5)
          {
            *_Ptr = (sbyte) num5;
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsputn(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pnavail(obj0);
        if (0 < num2)
        {
          int num3 = num2;
          if (_Count < num2)
            num3 = _Count;
          \u003CModule\u003E.memcpy_s((void*) *(int*) *(int*) ((IntPtr) obj0 + 36), (uint) num2, (void*) _Ptr, (uint) num3);
          _Ptr = (sbyte*) (num3 + (IntPtr) _Ptr);
          num1 = num3 + num1;
          _Count -= num3;
          int num4 = *(int*) ((IntPtr) obj0 + 52);
          *(int*) num4 = *(int*) num4 - num3;
          int num5 = *(int*) ((IntPtr) obj0 + 36);
          *(int*) num5 = *(int*) num5 + num3;
        }
        else
        {
          int num6 = (int) (byte) *_Ptr;
          basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
          int num7 = num6;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (-1 != __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr, (IntPtr) num7))
          {
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _param2,
    int _param3,
    int _param4)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _param2,
    int _param3)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _param1,
    int _param2)
  {
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    locale* _param1)
  {
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      locale* localePtr = (locale*) *(int*) ((IntPtr) obj0 + 56);
      if ((IntPtr) localePtr != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
        \u003CModule\u003E.delete((void*) localePtr);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor((_Mutex*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eshowmanyc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 16))((IntPtr) charTraitsWcharTPtr) ? (ushort) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc(obj0) : ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsgetn(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    int _Count)
  {
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    char* chPtr = _Ptr;
    int num = _Count;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, char*, uint, int)>) *(int*) (*(int*) obj0 + 28))((int) charTraitsWcharTPtr, (uint) chPtr, (char*) -1, (IntPtr) num);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Xsgetn_s(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    uint _Ptr_size,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gnavail(obj0);
        if (0 < num2)
        {
          int _Count1 = num2;
          if (_Count < num2)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_Ptr, _Ptr_size, (char*) *(int*) *(int*) ((IntPtr) obj0 + 32), (uint) _Count1);
          _Ptr = (char*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 48);
          *(int*) num3 = *(int*) num3 - _Count1;
          int num4 = *(int*) ((IntPtr) obj0 + 32);
          *(int*) num4 = *(int*) num4 + _Count1 * 2;
        }
        else
        {
          basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          ushort num5 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 20))((IntPtr) charTraitsWcharTPtr);
          if (ushort.MaxValue != num5)
          {
            *_Ptr = (char) num5;
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsputn(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int _Size = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pnavail(obj0);
        if (0 < _Size)
        {
          int _Count1 = _Size;
          if (_Count < _Size)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) *(int*) *(int*) ((IntPtr) obj0 + 36), (uint) _Size, _Ptr, (uint) _Count1);
          _Ptr = (char*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num2 = *(int*) ((IntPtr) obj0 + 52);
          *(int*) num2 = *(int*) num2 - _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 36);
          *(int*) num3 = *(int*) num3 + _Count1 * 2;
        }
        else
        {
          ushort num4 = (ushort) *_Ptr;
          basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
          int num5 = (int) num4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr, (IntPtr) num5))
          {
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _param2,
    int _param3,
    int _param4)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _param2,
    int _param3)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _param1,
    int _param2)
  {
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    locale* _param1)
  {
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      locale* localePtr = (locale*) *(int*) ((IntPtr) obj0 + 56);
      if ((IntPtr) localePtr != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
        \u003CModule\u003E.delete((void*) localePtr);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_dtor((_Mutex*) ((IntPtr) obj0 + 4));
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _param1)
  {
    return ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eshowmanyc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 16))((IntPtr) traitsUnsignedShortPtr) ? *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc(obj0) : ushort.MaxValue;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsgetn(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    int _Count)
  {
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    ushort* numPtr = _Ptr;
    int num = _Count;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, ushort*, uint, int)>) *(int*) (*(int*) obj0 + 28))((int) traitsUnsignedShortPtr, (uint) numPtr, (ushort*) -1, (IntPtr) num);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Xsgetn_s(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    uint _Ptr_size,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gnavail(obj0);
        if (0 < num2)
        {
          int _Count1 = num2;
          if (_Count < num2)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_Ptr, _Ptr_size, (ushort*) *(int*) *(int*) ((IntPtr) obj0 + 32), (uint) _Count1);
          _Ptr = (ushort*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 48);
          *(int*) num3 = *(int*) num3 - _Count1;
          int num4 = *(int*) ((IntPtr) obj0 + 32);
          *(int*) num4 = *(int*) num4 + _Count1 * 2;
        }
        else
        {
          basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          ushort num5 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 20))((IntPtr) traitsUnsignedShortPtr);
          if (ushort.MaxValue != num5)
          {
            *_Ptr = num5;
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsputn(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    int _Count)
  {
    int num1 = 0;
    if (0 < _Count)
    {
      do
      {
        int _Size = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pnavail(obj0);
        if (0 < _Size)
        {
          int _Count1 = _Size;
          if (_Count < _Size)
            _Count1 = _Count;
          \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) *(int*) *(int*) ((IntPtr) obj0 + 36), (uint) _Size, _Ptr, (uint) _Count1);
          _Ptr = (ushort*) (_Count1 * 2 + (IntPtr) _Ptr);
          num1 = _Count1 + num1;
          _Count -= _Count1;
          int num2 = *(int*) ((IntPtr) obj0 + 52);
          *(int*) num2 = *(int*) num2 - _Count1;
          int num3 = *(int*) ((IntPtr) obj0 + 36);
          *(int*) num3 = *(int*) num3 + _Count1 * 2;
        }
        else
        {
          ushort num4 = *_Ptr;
          basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
          int num5 = (int) num4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr, (IntPtr) num5))
          {
            ++_Ptr;
            ++num1;
            --_Count;
          }
          else
            break;
        }
      }
      while (0 < _Count);
    }
    return num1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _param2,
    int _param3,
    int _param4)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _param2,
    int _param3)
  {
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _param1,
    int _param2)
  {
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    locale* _param1)
  {
  }

  internal static unsafe void* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 4), 56U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(stdCharTraitsCharPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
    return (void*) stdCharTraitsCharPtr1;
  }

  internal static unsafe void* std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 4), 56U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(charTraitsWcharTPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
    return (void*) charTraitsWcharTPtr1;
  }

  internal static unsafe void* std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 4), 56U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(traitsUnsignedShortPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
    return (void*) traitsUnsignedShortPtr1;
  }

  internal static unsafe void* std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 12);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 8), 60U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(stdCharTraitsCharPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
    return (void*) stdCharTraitsCharPtr1;
  }

  internal static unsafe void* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 60U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 12);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 8), 60U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(charTraitsWcharTPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
    return (void*) charTraitsWcharTPtr1;
  }

  internal static unsafe void* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 60U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 12);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) ((IntPtr) obj0 - 8), 60U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 8);
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(traitsUnsignedShortPtr1);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
    return (void*) traitsUnsignedShortPtr1;
  }

  internal static unsafe void* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 60U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
    basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = stdCharTraitsCharPtr1;
    int num = *(int*) (*(int*) ((IntPtr) stdCharTraitsCharPtr2 - 4) + 4);
    *(int*) ((IntPtr) stdCharTraitsCharPtr2 + num - 4) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) stdCharTraitsCharPtr1);
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
    basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = charTraitsWcharTPtr1;
    int num = *(int*) (*(int*) ((IntPtr) charTraitsWcharTPtr2 - 4) + 4);
    *(int*) ((IntPtr) charTraitsWcharTPtr2 + num - 4) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) charTraitsWcharTPtr1);
  }

  internal static unsafe void std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
    basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = traitsUnsignedShortPtr1;
    int num = *(int*) (*(int*) ((IntPtr) traitsUnsignedShortPtr2 - 4) + 4);
    *(int*) ((IntPtr) traitsUnsignedShortPtr2 + num - 4) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) traitsUnsignedShortPtr1);
  }

  internal static unsafe void std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
    basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = stdCharTraitsCharPtr1;
    int num = *(int*) (*(int*) ((IntPtr) stdCharTraitsCharPtr2 - 8) + 4);
    *(int*) ((IntPtr) stdCharTraitsCharPtr2 + num - 8) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) stdCharTraitsCharPtr1);
  }

  internal static unsafe void std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
    basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = charTraitsWcharTPtr1;
    int num = *(int*) (*(int*) ((IntPtr) charTraitsWcharTPtr2 - 8) + 4);
    *(int*) ((IntPtr) charTraitsWcharTPtr2 + num - 8) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) charTraitsWcharTPtr1);
  }

  internal static unsafe void std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(
    [In] basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
    basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = traitsUnsignedShortPtr1;
    int num = *(int*) (*(int*) ((IntPtr) traitsUnsignedShortPtr2 - 8) + 4);
    *(int*) ((IntPtr) traitsUnsignedShortPtr2 + num - 8) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) traitsUnsignedShortPtr1);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclear(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int _State1 = *(int*) ((IntPtr) obj0 + 40) != 0 ? _State : _State | 4;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear((ios_base*) obj0, _State1, _Reraise);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclear(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int _State1 = *(int*) ((IntPtr) obj0 + 40) != 0 ? _State : _State | 4;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear((ios_base*) obj0, _State1, _Reraise);
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclear(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    int _State,
    [MarshalAs(UnmanagedType.U1)] bool _Reraise)
  {
    int _State1 = *(int*) ((IntPtr) obj0 + 40) != 0 ? _State : _State | 4;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear((ios_base*) obj0, _State1, _Reraise);
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte _Ch)
  {
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pnavail(obj0))
    {
      *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pninc(obj0) = _Ch;
      return (int) (byte) _Ch;
    }
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    int num = (int) (byte) _Ch;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr, (IntPtr) num);
  }

  internal static unsafe sbyte* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 48);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 32);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 1;
    return (sbyte*) num4;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gnavail(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 32) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 48) : 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pnavail(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 36) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 52) : 0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esputc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    ushort num1;
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pnavail(obj0))
    {
      *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pninc(obj0) = _Ch;
      num1 = (ushort) _Ch;
    }
    else
    {
      basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      int num2 = (int) _Ch;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num1 = __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr, (IntPtr) num2);
    }
    return num1;
  }

  internal static unsafe char* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 48);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 32);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (char*) num4;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gnavail(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 32) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 48) : 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pnavail(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 36) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 52) : 0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esputc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Ch)
  {
    ushort num1;
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pnavail(obj0))
    {
      *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pninc(obj0) = _Ch;
      num1 = _Ch;
    }
    else
    {
      basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      int num2 = (int) _Ch;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num1 = __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr, (IntPtr) num2);
    }
    return num1;
  }

  internal static unsafe ushort* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 48);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 32);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (ushort*) num4;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gnavail(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 32) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 48) : 0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pnavail(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return *(int*) *(int*) ((IntPtr) obj0 + 36) != 0 ? *(int*) *(int*) ((IntPtr) obj0 + 52) : 0;
  }

  internal static unsafe _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Ptr,
    _Container_base* _Pstring)
  {
    *(int*) obj0 = 0;
    if ((IntPtr) _Pstring != IntPtr.Zero && (IntPtr) _Ptr != IntPtr.Zero)
    {
      sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Pstring);
      if (numPtr <= _Ptr && (UIntPtr) _Ptr <= (UIntPtr) *(int*) ((IntPtr) _Pstring + 20) + (UIntPtr) numPtr)
        goto label_3;
    }
    \u003CModule\u003E._invalid_parameter_noinfo();
label_3:
    *(int*) obj0 = (int) _Pstring;
    *(int*) ((IntPtr) obj0 + 4) = (int) _Ptr;
    return obj0;
  }

  internal static unsafe sbyte* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        return (sbyte*) *(int*) ((IntPtr) obj0 + 4);
      default:
        uint num = (uint) *(int*) obj0;
        if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) num) + *(int*) ((int) num + 20)))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D\u003D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    uint num = (uint) *(int*) obj0;
    switch (num)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto case 4294967294;
      case 4294967294:
        return *(int*) ((IntPtr) obj0 + 4) == *(int*) ((IntPtr) _Right + 4);
      default:
        if ((int) num == *(int*) _Right)
          goto case 4294967294;
        else
          goto case 0;
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right)
  {
    return !\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D\u003D(obj0, _Right);
  }

  internal static unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B(
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    int _Off)
  {
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    // ISSUE: cpblk instruction
    __memcpy(ref stdAllocatorChar, (IntPtr) obj0, 8);
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar, _Off);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref stdAllocatorChar, 8);
    return obj1;
  }

  internal static unsafe sbyte* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pninc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 52);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 36);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 1;
    return (sbyte*) num4;
  }

  internal static unsafe char* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pninc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 52);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 36);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (char*) num4;
  }

  internal static unsafe ushort* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pninc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) ((IntPtr) obj0 + 52);
    *(int*) num1 = *(int*) num1 - 1;
    int num2 = *(int*) ((IntPtr) obj0 + 36);
    int num3 = *(int*) num2;
    int num4 = num3;
    *(int*) num2 = num3 + 2;
    return (ushort*) num4;
  }

  internal static unsafe _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    int _Off)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + _Off;
        return obj0;
      default:
        uint num1 = (uint) *(int*) obj0;
        uint num2 = (uint) (_Off + *(int*) ((IntPtr) obj0 + 4));
        if ((UIntPtr) (int) num2 > (UIntPtr) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) num1) + *(int*) ((int) num1 + 20)) || (UIntPtr) (int) num2 < (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) num1))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  internal static unsafe sbyte* std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    sbyte* _First1,
    uint _Size,
    sbyte* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memcpy_s((void*) _First1, _Size, (void*) _First2, _Count);
    return _First1;
  }

  internal static unsafe sbyte* std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    sbyte* _First1,
    uint _Size,
    sbyte* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memmove_s((void*) _First1, _Size, (void*) _First2, _Count);
    return _First1;
  }

  internal static unsafe char* std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(
    char* _First1,
    uint _Size,
    char* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memcpy_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe ushort* std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(
    ushort* _First1,
    uint _Size,
    ushort* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memcpy_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe sbyte* std\u002E_Allocate\u003Cchar\u003E(uint _Count, sbyte* __unnamed001)
  {
    if (_Count <= 0U)
      _Count = 0U;
    else if (uint.MaxValue / _Count < 1U)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return (sbyte*) \u003CModule\u003E.@new(_Count);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4ios_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Eios_base\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4_Locimp\u0040locale\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Elocale\u002E_Locimp\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4facet\u0040locale\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Elocale\u002Efacet\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4codecvt_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt_base\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_encoding);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_encoding);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_in);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_out);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_unshift);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Edo_length);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_encoding);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_in);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_out);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_unshift);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Edo_length);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4ctype_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype_base\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E_Do_widen_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ectype\u003Cchar\u003E\u002E_Do_narrow_s);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_scan_not);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_widen_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 60) = (int) __methodptr(std\u002Ectype\u003Cwchar_t\u003E\u002E_Do_narrow_s);
  }

  internal static unsafe void \u003FA0x7886e949\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_is);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_scan_not);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_tolower);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_toupper);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_widen);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_widen_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Edo_narrow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 60) = (int) __methodptr(std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Do_narrow_s);
  }

  internal static unsafe void std\u002Eios_base\u002E_Callfns([In] ios_base* obj0, ios_base.@event _Ev)
  {
    ios_base._Fnarray* fnarrayPtr = (ios_base._Fnarray*) *(int*) ((IntPtr) obj0 + 32);
    if ((IntPtr) fnarrayPtr == IntPtr.Zero)
      return;
    do
    {
      int num1 = (int) _Ev;
      ios_base* iosBasePtr = obj0;
      int num2 = *(int*) ((IntPtr) fnarrayPtr + 4);
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli((__FnPtr<void (ios_base.@event, ios_base*, int)>) *(int*) ((IntPtr) fnarrayPtr + 8))(num1, iosBasePtr, (ios_base.@event) num2);
      fnarrayPtr = (ios_base._Fnarray*) *(int*) fnarrayPtr;
    }
    while ((IntPtr) fnarrayPtr != IntPtr.Zero);
  }

  internal static unsafe void std\u002Eios_base\u002E_Tidy([In] ios_base* obj0)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Callfns(obj0, (ios_base.@event) 0);
    ios_base._Iosarray* iosarrayPtr1 = (ios_base._Iosarray*) *(int*) ((IntPtr) obj0 + 28);
    if ((IntPtr) iosarrayPtr1 != IntPtr.Zero)
    {
      ios_base._Iosarray* iosarrayPtr2;
      do
      {
        iosarrayPtr2 = (ios_base._Iosarray*) *(int*) iosarrayPtr1;
        \u003CModule\u003E.delete((void*) iosarrayPtr1);
        iosarrayPtr1 = iosarrayPtr2;
      }
      while ((IntPtr) iosarrayPtr2 != IntPtr.Zero);
    }
    *(int*) ((IntPtr) obj0 + 28) = 0;
    ios_base._Fnarray* fnarrayPtr1 = (ios_base._Fnarray*) *(int*) ((IntPtr) obj0 + 32);
    if ((IntPtr) fnarrayPtr1 != IntPtr.Zero)
    {
      ios_base._Fnarray* fnarrayPtr2;
      do
      {
        fnarrayPtr2 = (ios_base._Fnarray*) *(int*) fnarrayPtr1;
        \u003CModule\u003E.delete((void*) fnarrayPtr1);
        fnarrayPtr1 = fnarrayPtr2;
      }
      while ((IntPtr) fnarrayPtr2 != IntPtr.Zero);
    }
    *(int*) ((IntPtr) obj0 + 32) = 0;
  }

  internal static unsafe long* std\u002E_Fpz_func() => &\u003CModule\u003E.std\u002E_Fpz;

  internal static unsafe int* std\u002E_BADOFF_func() => &\u003CModule\u003E.std\u002E_BADOFF;

  internal static void \u003FA0xc7622cfe\u002E\u003F\u003F__E\u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA = 0;

  internal static void \u003FA0xc7622cfe\u002E\u003F\u003F__E\u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA = true;

  internal static unsafe int* std\u002Eios_base\u002E_Index_func() => &\u003CModule\u003E.\u003F_Index\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;

  internal static unsafe bool* std\u002Eios_base\u002E_Sync_func() => &\u003CModule\u003E.\u003F_Sync\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0_NA;

  internal static unsafe void \u003FA0xc7622cfe\u002E\u003F\u003F__E\u003FA0xc7622cfe\u0040stdstr\u0040std\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdstr = 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY09PAVios_base\u0040std\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdstr + 4), 0, 36);
  }

  internal static unsafe void \u003FA0xc7622cfe\u002E\u003F\u003F__E\u003FA0xc7622cfe\u0040stdopens\u0040std\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref \u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdopens = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY09D&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdopens + 1), 0, 9);
  }

  internal static unsafe void std\u002Eios_base\u002E_Ios_base_dtor(ios_base* _param0)
  {
    if (0U < (uint) *(int*) ((IntPtr) _param0 + 4))
    {
      // ISSUE: cast to a reference type
      ref \u0024ArrayType\u0024\u0024\u0024BY09D local = (\u0024ArrayType\u0024\u0024\u0024BY09D&) (*(int*) ((IntPtr) _param0 + 4) + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdopens);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref local = (sbyte) ((int) ^(sbyte&) ref local - 1);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if ((sbyte) 0 < ^(sbyte&) (*(int*) ((IntPtr) _param0 + 4) + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdopens))
        return;
    }
    \u003CModule\u003E.std\u002Eios_base\u002E_Tidy(_param0);
    locale* localePtr = (locale*) *(int*) ((IntPtr) _param0 + 36);
    if ((IntPtr) localePtr == IntPtr.Zero)
      return;
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(localePtr);
    \u003CModule\u003E.delete((void*) localePtr);
  }

  internal static unsafe void std\u002Eios_base\u002E_Addstd(ios_base* _param0)
  {
    bool flag = false;
    int num1 = 2;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      *(int*) ((IntPtr) _param0 + 4) = 0;
      uint num2;
      uint num3;
      do
      {
        *(int*) ((IntPtr) _param0 + 4) = *(int*) ((IntPtr) _param0 + 4) + 1;
        num2 = (uint) *(int*) ((IntPtr) _param0 + 4);
        if (num2 < 8U)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          num3 = (uint) ^(int&) ((int) num2 * 4 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdstr);
        }
        else
          break;
      }
      while (num3 != 0U && (IntPtr) (int) num3 != (IntPtr) _param0);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((int) num2 * 4 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdstr) = (int) _param0;
      // ISSUE: cast to a reference type
      ref \u0024ArrayType\u0024\u0024\u0024BY09D local = (\u0024ArrayType\u0024\u0024\u0024BY09D&) (*(int*) ((IntPtr) _param0 + 4) + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0xc7622cfe\u002Estdopens);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref local = (sbyte) ((int) ^(sbyte&) ref local + 1);
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static void \u003FA0xaab18c51\u002E\u003F\u003F__E\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA = -1;

  internal static unsafe int* std\u002Eios_base\u002EInit\u002E_Init_cnt_func() => &\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;

  internal static unsafe void std\u002Eios_base\u002EInit\u002E_Init_ctor(ios_base.Init* _param0)
  {
    if (0 <= \u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA)
      ++\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
    else
      \u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA = 1;
  }

  internal static unsafe void std\u002Eios_base\u002EInit\u002E_Init_dtor(ios_base.Init* _param0)
  {
    --\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_Init_cnt\u0040Init\u0040ios_base\u0040std\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cerr != IntPtr.Zero)
      \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002E_Ptr_cerr);
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_clog != IntPtr.Zero)
      \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002E_Ptr_clog);
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cout == IntPtr.Zero)
      return;
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eflush(\u003CModule\u003E.std\u002E_Ptr_cout);
  }

  internal static void \u003FA0xcbb46b7e\u002E\u003F\u003F__E\u003F_Init_cnt\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Init_cnt\u0040_Winit\u0040std\u0040\u0040\u0024\u0024Q0HA = -1;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E\u003FA0xf46c9959\u0040initlocks\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.std\u002E\u003FA0xf46c9959\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xf46c9959\u002E\u003F\u003F__F\u003FA0xf46c9959\u0040initlocks\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__F\u003FA0xf46c9959\u0040initlocks\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.std\u002E\u003FA0xf46c9959\u002Einitlocks);

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_cin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_cin = (basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_cout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_cout = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_cerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_cerr = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_clog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_clog = (basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_wcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcin = (basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_wcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcout = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_wcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcerr = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E_Ptr_wclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wclog = (basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__E\u003FA0xf46c9959\u0040atfuns_cdecl\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003FA0xf46c9959\u002Eatfuns_cdecl = 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY09P6AXXZ&) ((IntPtr) &\u003CModule\u003E.\u003FA0xf46c9959\u002Eatfuns_cdecl + 4), 0, 36);
  }

  internal static void \u003FA0xf46c9959\u002E\u003F\u003F__E\u003FA0xf46c9959\u0040atcount_cdecl\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl = 10U;

  internal static unsafe void _Atexit(__FnPtr<void ()> pf)
  {
    if (\u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl == 0U)
    {
      \u003CModule\u003E.abort();
    }
    else
    {
      --\u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((int) \u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0xf46c9959\u002Eatfuns_cdecl) = (int) pf;
    }
  }

  internal static unsafe void _Init_atexit\u002E\u007Bdtor\u007D([In] _Init_atexit* obj0)
  {
    if (\u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl >= 10U)
      return;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num = ^(int&) ((int) \u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0xf46c9959\u002Eatfuns_cdecl);
      ++\u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl;
      if (num != 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) ^(int&) ((int) \u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0xf46c9959\u002Eatfuns_cdecl - 4))();
      }
    }
    while (\u003CModule\u003E.\u003FA0xf46c9959\u002Eatcount_cdecl < 10U);
  }

  internal static void \u003FA0xf46c9959\u002E\u003F\u003F__E\u003FA0xf46c9959\u0040init_atexit\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xf46c9959\u002E\u003F\u003F__F\u003FA0xf46c9959\u0040init_atexit\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0xf46c9959\u002E\u003F\u003F__F\u003FA0xf46c9959\u0040init_atexit\u0040\u0040YMXXZ() => \u003CModule\u003E._Init_atexit\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0xf46c9959\u002Einit_atexit);

  internal static unsafe void \u003FA0xf2a4e477\u002E\u003F\u003F__E_Ptr_wcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcin = (basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf2a4e477\u002E\u003F\u003F__E_Ptr_wcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcout = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf2a4e477\u002E\u003F\u003F__E_Ptr_wcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wcerr = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static unsafe void \u003FA0xf2a4e477\u002E\u003F\u003F__E_Ptr_wclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Ptr_wclog = (basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;

  internal static void \u003FA0xf2a4e477\u002E\u003F\u003F__E\u003F_Init_cnt\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Init_cnt\u0040_UShinit\u0040std\u0040\u0040\u0024\u0024Q0HA = -1;

  internal static unsafe _Locinfo* std\u002E_Locinfo\u002E\u007Bctor\u007D(
    [In] _Locinfo* obj0,
    sbyte* _Pch)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 32));
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 60));
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 88));
          // ISSUE: fault handler
          try
          {
            if ((IntPtr) _Pch == IntPtr.Zero)
              \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
            \u003CModule\u003E.std\u002E_Locinfo\u002E_Locinfo_ctor(obj0, _Pch);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 88));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 60));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Locinfo\u002E\u007Bdtor\u007D([In] _Locinfo* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002E_Locinfo\u002E_Locinfo_dtor(obj0);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 88));
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 88), true, 0U);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 60));
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 60), true, 0U);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32));
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 32), true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4), true, 0U);
  }

  internal static unsafe uint std\u002Elocale\u002Eid\u002E\u002EI([In] locale.id* obj0)
  {
    if (*(int*) obj0 == 0)
    {
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        if (*(int*) obj0 == 0)
        {
          ++\u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;
          *(int*) obj0 = \u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    return (uint) *(int*) obj0;
  }

  internal static unsafe void std\u002Elocale\u002Efacet\u002E_Register([In] locale.facet* obj0) => \u003CModule\u003E.std\u002Elocale\u002Efacet\u002Efacet_Register(obj0);

  internal static unsafe locale* std\u002Elocale\u002E\u007Bctor\u007D([In] locale* obj0)
  {
    *(int*) obj0 = (int) \u003CModule\u003E.std\u002Elocale\u002E_Init();
    \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) \u003CModule\u003E.std\u002Elocale\u002E_Getgloballocale());
    return obj0;
  }

  internal static unsafe locale.facet* std\u002Elocale\u002E_Getfacet([In] locale* obj0, uint _Id)
  {
    int num = *(int*) obj0;
    locale.facet* facetPtr = _Id >= (uint) *(int*) (num + 12) ? (locale.facet*) 0 : (locale.facet*) *(int*) ((int) _Id * 4 + *(int*) (num + 8));
    if ((IntPtr) facetPtr != IntPtr.Zero || *(byte*) (num + 20) == (byte) 0)
      return facetPtr;
    locale._Locimp* locimpPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getgloballocale();
    return _Id < (uint) *(int*) ((IntPtr) locimpPtr + 12) ? (locale.facet*) *(int*) ((int) _Id * 4 + *(int*) ((IntPtr) locimpPtr + 8)) : (locale.facet*) 0;
  }

  internal static unsafe ctype\u003Cchar\u003E* std\u002Ectype\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cchar\u003E* obj0,
    short* _Table,
    [MarshalAs(UnmanagedType.U1)] bool _Deletetable,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num1 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
      }
      if ((IntPtr) _Table != IntPtr.Zero)
      {
        \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E_Tidy(obj0);
        *(int*) ((IntPtr) obj0 + 16) = (int) _Table;
        int num2 = -1;
        if (!_Deletetable)
          num2 = ~num2;
        int num3 = num2;
        *(int*) ((IntPtr) obj0 + 20) = num3;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ectype\u003Cchar\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      ctype\u003Cchar\u003E* ctypeCharPtr1 = (ctype\u003Cchar\u003E*) \u003CModule\u003E.@new(24U);
      ctype\u003Cchar\u003E* ctypeCharPtr2;
      // ISSUE: fault handler
      try
      {
        ctypeCharPtr2 = (IntPtr) ctypeCharPtr1 == IntPtr.Zero ? (ctype\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E\u007Bctor\u007D(ctypeCharPtr1, (short*) 0, false, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) ctypeCharPtr1);
      }
      *(int*) _Ppf = (int) ctypeCharPtr2;
    }
    return 2;
  }

  internal static unsafe locale* std\u002Eios_base\u002Egetloc([In] ios_base* obj0, [In] locale* obj1)
  {
    uint num1 = 0;
    int num2 = *(int*) *(int*) ((IntPtr) obj0 + 36);
    *(int*) obj1 = num2;
    \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) num2);
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num3 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe void std\u002Eios_base\u002E_Init([In] ios_base* obj0)
  {
    *(int*) ((IntPtr) obj0 + 36) = 0;
    *(int*) ((IntPtr) obj0 + 12) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 513;
    *(int*) ((IntPtr) obj0 + 20) = 6;
    *(int*) ((IntPtr) obj0 + 24) = 0;
    *(int*) ((IntPtr) obj0 + 28) = 0;
    *(int*) ((IntPtr) obj0 + 32) = 0;
    \u003CModule\u003E.std\u002Eios_base\u002Eclear(obj0, 0, false);
    locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
    locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
    *(int*) ((IntPtr) obj0 + 36) = (int) localePtr2;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fgetc\u003Cchar\u003E(sbyte* _Byte, _iobuf* _File)
  {
    int num = \u003CModule\u003E.fgetc(_File);
    if (num == -1)
      return false;
    *_Byte = (sbyte) num;
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fputc\u003Cchar\u003E(sbyte _Byte, _iobuf* _File) => \u003CModule\u003E.fputc((int) _Byte, _File) != -1;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Ungetc\u003Cchar\u003E(sbyte* _Byte, _iobuf* _File) => \u003CModule\u003E.ungetc((int) (byte) *_Byte, _File) != -1;

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003FA0x4ee7f526\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x4ee7f526\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x4ee7f526\u002E\u003F\u003F__F\u003FA0x4ee7f526\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__F\u003FA0x4ee7f526\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x4ee7f526\u002Einitlocks);

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003FA0x4ee7f526\u0040ferr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x4ee7f526\u002Eferr, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x4ee7f526\u002E\u003F\u003F__F\u003FA0x4ee7f526\u0040ferr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__F\u003FA0x4ee7f526\u0040ferr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x4ee7f526\u002Eferr);

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__Ecerr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ecerr, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x4ee7f526\u002Eferr, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x4ee7f526\u002E\u003F\u003F__Fcerr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__Fcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ecerr);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Cerr_func() => &\u003CModule\u003E.std\u002Ecerr;

  internal static unsafe _Init_cerr* std\u002E_Init_cerr\u002E\u007Bctor\u007D(
    [In] _Init_cerr* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_cerr = &\u003CModule\u003E.std\u002Ecerr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ecerr + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ecerr + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ios_base* iosBasePtr = (ios_base*) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ecerr + 4) + (IntPtr) &\u003CModule\u003E.std\u002Ecerr);
    *(int*) ((IntPtr) iosBasePtr + 16) = *(int*) ((IntPtr) iosBasePtr + 16) | 2;
    return obj0;
  }

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003FA0x4ee7f526\u0040init_cerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_cerr\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x4ee7f526\u002Einit_cerr);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* pThis = (basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Einit((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(byte*) ((IntPtr) obj0 + 72) != (byte) 0)
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
  }

  internal static unsafe basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    _iobuf* _File)
  {
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(obj0, _File, (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _Meta)
  {
    if (-1 == _Meta)
      return _Meta == -1 ? 0 : _Meta;
    int num1 = *(int*) ((IntPtr) obj0 + 36);
    if (*(int*) num1 != 0)
    {
      int num2 = *(int*) num1;
      if ((uint) num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 52) + num2))
      {
        *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Pninc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0) = (sbyte) _Meta;
        return _Meta;
      }
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return -1;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
      return \u003CModule\u003E.std\u002E_Fputc\u003Cchar\u003E((sbyte) _Meta, (_iobuf*) _File) ? _Meta : -1;
    sbyte _Byte = (sbyte) _Meta;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    int num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      sbyte* _First2_1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
      sbyte* numPtr2;
      sbyte* numPtr3;
      int num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Byte, &_Byte + 1, &numPtr2, _First2_1, (sbyte*) ((int) num4 + (IntPtr) numPtr1), &numPtr3);
      if (num5 >= 0)
      {
        do
        {
          if (num5 <= 1)
          {
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
            uint num6 = (uint) ((IntPtr) numPtr3 - (IntPtr) numPtr4);
            if (0U < num6)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
              if ((int) num6 != (int) \u003CModule\u003E.fwrite((void*) numPtr5, 1U, num6, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                goto label_27;
            }
            *(sbyte*) ((IntPtr) obj0 + 65) = (sbyte) 1;
            if ((IntPtr) numPtr2 == ref _Byte)
            {
              if (0U >= num6)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) < 32U)
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
                else
                  goto label_29;
              }
              sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num7 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
              sbyte* _First2_2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
              num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Byte, &_Byte + 1, &numPtr2, _First2_2, (sbyte*) ((int) num7 + (IntPtr) numPtr6), &numPtr3);
            }
            else
              goto label_28;
          }
          else
            goto label_23;
        }
        while (num5 >= 0);
        goto label_30;
label_23:
        if (num5 == 3)
          num3 = !\u003CModule\u003E.std\u002E_Fputc\u003Cchar\u003E(_Byte, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)) ? -1 : _Meta;
        else
          goto label_30;
      }
      else
        goto label_30;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_27:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
label_28:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return _Meta;
label_29:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
label_30:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    int _Meta)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0 && (uint) *(int*) *(int*) ((IntPtr) obj0 + 16) < (uint) num1 && (-1 == _Meta || (int) (byte) *(sbyte*) (num1 - 1) == _Meta))
    {
      int num2 = *(int*) ((IntPtr) obj0 + 48);
      *(int*) num2 = *(int*) num2 + 1;
      int num3 = *(int*) ((IntPtr) obj0 + 32);
      *(int*) num3 = *(int*) num3 - 1;
      return _Meta == -1 ? 0 : _Meta;
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    return _File != 0U && -1 != _Meta && *(int*) ((IntPtr) obj0 + 60) == 0 && \u003CModule\u003E.std\u002E_Ungetc\u003Cchar\u003E(&(sbyte) _Meta, (_iobuf*) _File) ? _Meta : -1;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) *(int*) ((IntPtr) obj0 + 32);
      if (num2 < (uint) *(int*) *(int*) ((IntPtr) obj0 + 48) + num2)
        return (int) (byte) *(sbyte*) num1;
    }
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num3 = __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr1 + 20))((IntPtr) stdCharTraitsCharPtr1);
    if (-1 == num3)
      return num3;
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = obj0;
    int num4 = num3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 8))((int) stdCharTraitsCharPtr2, (IntPtr) num4);
    return num3;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (*(int*) *(int*) ((IntPtr) obj0 + 32) != 0)
    {
      int num = *(int*) *(int*) ((IntPtr) obj0 + 32);
      if ((uint) num < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) + num))
        return (int) (byte) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return -1;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
    {
      sbyte num;
      return \u003CModule\u003E.std\u002E_Fgetc\u003Cchar\u003E(&num, (_iobuf*) _File) ? (int) (byte) num : -1;
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
    sbyte* numPtr1;
    sbyte num1;
    // ISSUE: fault handler
    try
    {
      int _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
      if (_Ch != -1)
      {
        basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _State = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) _Ch);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* _First1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          sbyte* numPtr3;
          int num3 = \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Ein((codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) _State, _First1, numPtr2 + (int) num2, &numPtr1, &num1, &num1 + 1, &numPtr3);
          if (num3 >= 0)
          {
            if (num3 > 1)
            {
              if (num3 == 3)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) >= 1U)
                  goto label_21;
              }
              else
                goto label_29;
            }
            else if ((IntPtr) numPtr3 == ref num1)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar1, 0U, (uint) ((IntPtr) numPtr1 - (IntPtr) numPtr4));
            }
            else
              goto label_24;
            _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
          }
          else
            goto label_29;
        }
        while (_Ch != -1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
label_21:
    int num4;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5);
      \u003CModule\u003E.memcpy_s((void*) &num1, 1U, (void*) \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) stdAllocatorCharPtr), 1U);
      num4 = (int) (byte) num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num4;
label_24:
    int num5;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
      sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar6));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num6 = (int) (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) - (IntPtr) numPtr1 + (IntPtr) numPtr5);
      if (0 < num6)
      {
        do
        {
          --num6;
          \u003CModule\u003E.ungetc((int) *(sbyte*) (num6 + (IntPtr) numPtr1), (_iobuf*) *(int*) ((IntPtr) obj0 + 76));
        }
        while (num6 > 0);
      }
      num5 = (int) (byte) num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num5;
label_29:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return -1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _Off,
    int _Way,
    int __unnamed002)
  {
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64 && _Way == 1 && *(int*) ((IntPtr) obj0 + 60) == 0)
      --_Off;
    long num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(obj0) && (_Off == 0 && _Way == 1 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), _Off, _Way) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64)
      {
        sbyte* numPtr = (sbyte*) ((IntPtr) obj0 + 65);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 64);
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 65);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _Pos,
    int __unnamed001)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    long num = ^(long&) ((IntPtr) &_Pos + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(obj0) && \u003CModule\u003E.fsetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0 && (^(int&) ref _Pos == 0 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), ^(int&) ref _Pos, 1) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(int*) ((IntPtr) obj0 + 68) = ^(int&) ((IntPtr) &_Pos + 16);
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) stdCharTraitsCharPtr)
      {
        sbyte* numPtr = (sbyte*) ((IntPtr) obj0 + 65);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) stdCharTraitsCharPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 65);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte* _Buffer,
    int _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (num1 != 0U)
    {
      int num2 = (IntPtr) _Buffer != IntPtr.Zero || _Count != 0 ? 0 : 4;
      if (\u003CModule\u003E.setvbuf((_iobuf*) num1, _Buffer, num2, (uint) _Count) == 0)
      {
        basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
        int _File = *(int*) ((IntPtr) stdCharTraitsCharPtr + 76);
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(stdCharTraitsCharPtr, (_iobuf*) _File, (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 1);
        return (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0;
      }
    }
    return (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    int num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0)
    {
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (-1 != __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr, new IntPtr(-1)) && 0 > \u003CModule\u003E.fflush((_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
      {
        num = -1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    locale* _Loc)
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Initcvt(obj0, \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u0020\u003E(_Loc));
  }

  internal static unsafe void* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 80U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Einit(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Init((ios_base*) obj0);
    *(int*) ((IntPtr) obj0 + 40) = (int) _Strbuf;
    *(int*) ((IntPtr) obj0 + 44) = 0;
    *(sbyte*) ((IntPtr) obj0 + 48) = \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Ewiden(obj0, (sbyte) 32);
    if (*(int*) ((IntPtr) obj0 + 40) == 0)
    {
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
      int _State = *(int*) ((IntPtr) stdCharTraitsCharPtr + 8) | 4;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclear(stdCharTraitsCharPtr, _State, false);
    }
    if (_Isstd)
      \u003CModule\u003E.std\u002Eios_base\u002E_Addstd((ios_base*) obj0);
    else
      *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_ctor((_Mutex*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
      locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
      *(int*) ((IntPtr) obj0 + 56) = (int) localePtr2;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eclose(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    if (*(int*) ((IntPtr) obj0 + 76) == 0)
    {
      stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
    }
    else
    {
      if (!\u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(obj0))
        stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
      if (\u003CModule\u003E.fclose((_iobuf*) *(int*) ((IntPtr) obj0 + 76)) != 0)
        stdCharTraitsCharPtr = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) 0;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(obj0, (_iobuf*) 0, (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 2);
    return stdCharTraitsCharPtr;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    _iobuf* _File,
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl _Which)
  {
    int num = _Which == (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E._Initfl) 1 ? 1 : 0;
    *(sbyte*) ((IntPtr) obj0 + 72) = (sbyte) num;
    *(sbyte*) ((IntPtr) obj0 + 65) = (sbyte) 0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    if ((IntPtr) _File != IntPtr.Zero)
    {
      sbyte** numPtr = (sbyte**) ((IntPtr) _File + 8);
      *(int*) ((IntPtr) obj0 + 16) = (int) numPtr;
      *(int*) ((IntPtr) obj0 + 20) = (int) numPtr;
      *(int*) ((IntPtr) obj0 + 32) = (int) _File;
      *(int*) ((IntPtr) obj0 + 36) = (int) _File;
      _iobuf* iobufPtr = (_iobuf*) ((IntPtr) _File + 4);
      *(int*) ((IntPtr) obj0 + 48) = (int) iobufPtr;
      *(int*) ((IntPtr) obj0 + 52) = (int) iobufPtr;
    }
    *(int*) ((IntPtr) obj0 + 76) = (int) _File;
    *(int*) ((IntPtr) obj0 + 68) = \u003CModule\u003E.\u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
    *(int*) ((IntPtr) obj0 + 60) = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Endwrite(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (*(int*) ((IntPtr) obj0 + 60) == 0 || *(byte*) ((IntPtr) obj0 + 65) == (byte) 0)
      return true;
    basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (-1 == __calli((__FnPtr<int (IntPtr, int)>) *(int*) (*(int*) obj0 + 4))((int) stdCharTraitsCharPtr1, new IntPtr(-1)))
      return false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    // ISSUE: fault handler
    try
    {
      basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = (basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
      while (true)
      {
        uint num1;
        do
        {
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr1 = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60);
          codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr2 = codecvtCharCharIntPtr1;
          basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr3 = stdCharTraitsCharPtr2;
          sbyte* numPtr3 = numPtr2;
          IntPtr num3 = (int) num2 + (IntPtr) numPtr1;
          sbyte* numPtr4;
          ref sbyte* local = ref numPtr4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          switch (__calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) codecvtCharCharIntPtr1 + 24))((sbyte**) codecvtCharCharIntPtr2, (sbyte*) stdCharTraitsCharPtr3, numPtr3, (int*) num3, (IntPtr) ref local))
          {
            case 0:
              *(sbyte*) ((IntPtr) obj0 + 65) = (sbyte) 0;
              goto case 1;
            case 1:
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              num1 = (uint) ((IntPtr) numPtr4 - (IntPtr) numPtr5);
              if (0U < num1)
              {
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
                if ((int) num1 != (int) \u003CModule\u003E.fwrite((void*) numPtr6, 1U, num1, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                  goto label_15;
              }
              if (*(byte*) ((IntPtr) obj0 + 65) != (byte) 0)
                continue;
              goto label_16;
            case 3:
              goto label_14;
            default:
              goto label_13;
          }
        }
        while (num1 != 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_13:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_14:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
label_15:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_16:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Initcvt(
    [In] basic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* _Newpcvt)
  {
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = _Newpcvt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<byte (IntPtr)>) *(int*) (*(int*) codecvtCharCharIntPtr + 4))((IntPtr) codecvtCharCharIntPtr) != (byte) 0)
    {
      *(int*) ((IntPtr) obj0 + 60) = 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 60) = (int) _Newpcvt;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) obj0);
    }
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Ein(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    sbyte* numPtr5 = _First2;
    sbyte* numPtr6 = _Last2;
    sbyte** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 16))((sbyte**) codecvtCharCharIntPtr, (sbyte*) numPtr1, numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Eout(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    sbyte* numPtr5 = _First2;
    sbyte* numPtr6 = _Last2;
    sbyte** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 20))((sbyte**) codecvtCharCharIntPtr, (sbyte*) numPtr1, numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe void std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_in(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First1,
    sbyte* __unnamed002,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* __unnamed005,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    return 3;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_out(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First1,
    sbyte* __unnamed002,
    sbyte** _Mid1,
    sbyte* _First2,
    sbyte* __unnamed005,
    sbyte** _Mid2)
  {
    *(int*) _Mid1 = (int) _First1;
    *(int*) _Mid2 = (int) _First2;
    return 3;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_unshift(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First2,
    sbyte* __unnamed002,
    sbyte** _Mid2)
  {
    *(int*) _Mid2 = (int) _First2;
    return 3;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_length(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    int* __unnamed000,
    sbyte* _First1,
    sbyte* _Last1,
    uint _Count)
  {
    uint num = (uint) ((IntPtr) _Last1 - (IntPtr) _First1);
    return _Count < num ? (int) _Count : (int) num;
  }

  internal static unsafe void* std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E__vecDelDtor(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) codecvtCharCharIntPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) codecvtCharCharIntPtr);
      return (void*) codecvtCharCharIntPtr;
    }
    \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe sbyte std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Ewiden(
    [In] basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte _Byte)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc((ios_base*) obj0, &locale);
    ctype\u003Cchar\u003E* ctypeCharPtr1;
    // ISSUE: fault handler
    try
    {
      ctypeCharPtr1 = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cchar\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    ctype\u003Cchar\u003E* ctypeCharPtr2 = ctypeCharPtr1;
    int num = (int) _Byte;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte (IntPtr, sbyte)>) *(int*) (*(int*) ctypeCharPtr1 + 24))((sbyte) ctypeCharPtr2, (IntPtr) num);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Init(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 8);
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 12);
    *(int*) ((IntPtr) obj0 + 20) = (int) stdCharTraitsCharPtr;
    *(int*) ((IntPtr) obj0 + 32) = (int) ((IntPtr) obj0 + 24);
    *(int*) ((IntPtr) obj0 + 36) = (int) ((IntPtr) obj0 + 28);
    *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 + 40);
    *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) obj0 + 44);
    *(int*) stdCharTraitsCharPtr = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 36) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 52) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = 0;
  }

  internal static unsafe ctype\u003Cchar\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cchar\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (ctype\u003Cchar\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe codecvt\u003Cchar\u002Cchar\u002Cint\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe uint std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr1 = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(8U);
      codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr2;
      // ISSUE: fault handler
      try
      {
        codecvtCharCharIntPtr2 = (IntPtr) codecvtCharCharIntPtr1 == IntPtr.Zero ? (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) 0 : \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(codecvtCharCharIntPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) codecvtCharCharIntPtr1);
      }
      *(int*) _Ppf = (int) codecvtCharCharIntPtr2;
    }
    return 2;
  }

  internal static unsafe codecvt\u003Cchar\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x4ee7f526\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_always_noconv);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_max_length);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecodecvt_base\u002Edo_encoding);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_in);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_out);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_unshift);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002Edo_length);
  }

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__E\u003FA0x8a3a1449\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x8a3a1449\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x8a3a1449\u002E\u003F\u003F__F\u003FA0x8a3a1449\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__F\u003FA0x8a3a1449\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x8a3a1449\u002Einitlocks);

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__E\u003FA0x8a3a1449\u0040fin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x8a3a1449\u002Efin, \u003CModule\u003E.__iob_func());
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x8a3a1449\u002E\u003F\u003F__F\u003FA0x8a3a1449\u0040fin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__F\u003FA0x8a3a1449\u0040fin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x8a3a1449\u002Efin);

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__Ecin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ecin, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x8a3a1449\u002Efin, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x8a3a1449\u002E\u003F\u003F__Fcin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__Fcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ecin);

  internal static unsafe basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Cin_func() => &\u003CModule\u003E.std\u002Ecin;

  internal static unsafe void \u003FA0x8a3a1449\u002E\u003F\u003F__E\u003FA0x8a3a1449\u0040init_cin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_cin = &\u003CModule\u003E.std\u002Ecin;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ecin + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ecin + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
  }

  internal static unsafe basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Ebasic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* pThis = (basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 4) = 0;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Einit((basic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x04ba802b\u002E\u003F\u003F__E\u003FA0x04ba802b\u0040flog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x04ba802b\u002Eflog, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x04ba802b\u002E\u003F\u003F__F\u003FA0x04ba802b\u0040flog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x04ba802b\u002E\u003F\u003F__F\u003FA0x04ba802b\u0040flog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x04ba802b\u002Eflog);

  internal static unsafe void \u003FA0x04ba802b\u002E\u003F\u003F__Eclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Eclog, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x04ba802b\u002Eflog, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x04ba802b\u002E\u003F\u003F__Fclog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x04ba802b\u002E\u003F\u003F__Fclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Eclog);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Clog_func() => &\u003CModule\u003E.std\u002Eclog;

  internal static unsafe void \u003FA0x04ba802b\u002E\u003F\u003F__E\u003FA0x04ba802b\u0040init_clog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_clog = &\u003CModule\u003E.std\u002Eclog;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Eclog + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Eclog + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
  }

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__E\u003FA0xccd9347d\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0xccd9347d\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xccd9347d\u002E\u003F\u003F__F\u003FA0xccd9347d\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__F\u003FA0xccd9347d\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0xccd9347d\u002Einitlocks);

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__E\u003FA0xccd9347d\u0040fout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xccd9347d\u002Efout, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xccd9347d\u002E\u003F\u003F__F\u003FA0xccd9347d\u0040fout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__F\u003FA0xccd9347d\u0040fout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xccd9347d\u002Efout);

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__Ecout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ecout, (basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xccd9347d\u002Efout, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xccd9347d\u002E\u003F\u003F__Fcout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__Fcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ecout);

  internal static unsafe basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002E_Cout_func() => &\u003CModule\u003E.std\u002Ecout;

  internal static unsafe _Init_cout* std\u002E_Init_cout\u002E\u007Bctor\u007D(
    [In] _Init_cout* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_cout = &\u003CModule\u003E.std\u002Ecout;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cin != IntPtr.Zero)
    {
      basic_istream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdPtrCin = \u003CModule\u003E.std\u002E_Ptr_cin;
      int num = *(int*) (*(int*) stdPtrCin + 4);
      *(int*) ((IntPtr) stdPtrCin + num + 44) = (int) &\u003CModule\u003E.std\u002Ecout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_cerr != IntPtr.Zero)
    {
      basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdPtrCerr = \u003CModule\u003E.std\u002E_Ptr_cerr;
      int num = *(int*) (*(int*) stdPtrCerr + 4);
      *(int*) ((IntPtr) stdPtrCerr + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_clog != IntPtr.Zero)
    {
      basic_ostream\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdPtrClog = \u003CModule\u003E.std\u002E_Ptr_clog;
      int num = *(int*) (*(int*) stdPtrClog + 4);
      *(int*) ((IntPtr) stdPtrClog + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_cout;
    }
    return obj0;
  }

  internal static unsafe void \u003FA0xccd9347d\u002E\u003F\u003F__E\u003FA0xccd9347d\u0040init_cout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_cout\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xccd9347d\u002Einit_cout);

  internal static unsafe ushort std\u002Echar_traits\u003Cunsigned\u0020short\u003E\u002Enot_eof(
    ushort* _Meta)
  {
    ushort num = *_Meta;
    return num == ushort.MaxValue ? (ushort) 0 : num;
  }

  internal static unsafe _Cvtvec* std\u002E_Locinfo\u002E_Getcvt(
    [In] _Locinfo* obj0,
    [In] _Cvtvec* obj1)
  {
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref cvtvec, 8);
    return obj1;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Ein(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    ushort* _First2,
    ushort* _Last2,
    ushort** _Mid2)
  {
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    ushort* numPtr5 = _First2;
    ushort* numPtr6 = _Last2;
    ushort** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, ushort*, ushort*, ushort**)>) *(int*) (*(int*) obj0 + 16))((ushort**) unsignedShortCharIntPtr, (ushort*) numPtr1, (ushort*) numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, (sbyte*) numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Eout(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    ushort* _First1,
    ushort* _Last1,
    ushort** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = obj0;
    int* numPtr1 = _State;
    ushort* numPtr2 = _First1;
    ushort* numPtr3 = _Last1;
    ushort** numPtr4 = _Mid1;
    sbyte* numPtr5 = _First2;
    sbyte* numPtr6 = _Last2;
    sbyte** numPtr7 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, ushort*, ushort*, ushort**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 20))((sbyte**) unsignedShortCharIntPtr, (sbyte*) numPtr1, (sbyte*) numPtr2, (ushort**) numPtr3, (ushort*) numPtr4, (ushort*) numPtr5, (int*) numPtr6, (IntPtr) numPtr7);
  }

  internal static unsafe codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr1 = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(16U);
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr2;
      // ISSUE: fault handler
      try
      {
        unsignedShortCharIntPtr2 = (IntPtr) unsignedShortCharIntPtr1 == IntPtr.Zero ? (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) 0 : \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(unsignedShortCharIntPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) unsignedShortCharIntPtr1);
      }
      *(int*) _Ppf = (int) unsignedShortCharIntPtr2;
    }
    return 2;
  }

  internal static unsafe ctype\u003Cunsigned\u0020short\u003E* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr1 = (ctype\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(32U);
      ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        ctypeUnsignedShortPtr2 = (IntPtr) ctypeUnsignedShortPtr1 == IntPtr.Zero ? (ctype\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(ctypeUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) ctypeUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) ctypeUnsignedShortPtr2;
    }
    return 2;
  }

  internal static unsafe void std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Init(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj)
  {
    _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 24, ref cvtvec, 8);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fgetc\u003Cunsigned\u0020short\u003E(
    ushort* _Wchar,
    _iobuf* _File)
  {
    ushort num = \u003CModule\u003E.fgetwc(_File);
    if (num == ushort.MaxValue)
      return false;
    *_Wchar = num;
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fputc\u003Cunsigned\u0020short\u003E(
    ushort _Wchar,
    _iobuf* _File)
  {
    return \u003CModule\u003E.fputwc((char) _Wchar, _File) != ushort.MaxValue;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Ungetc\u003Cunsigned\u0020short\u003E(
    ushort* _Wchar,
    _iobuf* _File)
  {
    return \u003CModule\u003E.ungetwc(*_Wchar, _File) != ushort.MaxValue;
  }

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__E\u003FA0x68dc8993\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x68dc8993\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x68dc8993\u002E\u003F\u003F__F\u003FA0x68dc8993\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__F\u003FA0x68dc8993\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x68dc8993\u002Einitlocks);

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__E\u003FA0x68dc8993\u0040wferr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x68dc8993\u002Ewferr, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x68dc8993\u002E\u003F\u003F__F\u003FA0x68dc8993\u0040wferr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__F\u003FA0x68dc8993\u0040wferr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x68dc8993\u002Ewferr);

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__Ewcerr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcerr, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x68dc8993\u002Ewferr, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x68dc8993\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcerr);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wcerr_func() => &\u003CModule\u003E.std\u002Ewcerr;

  internal static unsafe _Init_ushcerr* std\u002E_Init_ushcerr\u002E\u007Bctor\u007D(
    [In] _Init_ushcerr* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcerr = &\u003CModule\u003E.std\u002Ewcerr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcerr + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ios_base* iosBasePtr = (ios_base*) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + (IntPtr) &\u003CModule\u003E.std\u002Ewcerr);
    *(int*) ((IntPtr) iosBasePtr + 16) = *(int*) ((IntPtr) iosBasePtr + 16) | 2;
    return obj0;
  }

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__E\u003FA0x68dc8993\u0040init_ushcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_ushcerr\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x68dc8993\u002Einit_ushcerr);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* pThis = (basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einit((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(byte*) ((IntPtr) obj0 + 72) != (byte) 0)
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclose(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
  }

  internal static unsafe basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    _iobuf* _File)
  {
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(obj0, _File, (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    if (ushort.MaxValue == _Meta)
      return \u003CModule\u003E.std\u002Echar_traits\u003Cunsigned\u0020short\u003E\u002Enot_eof(&_Meta);
    int num1 = *(int*) ((IntPtr) obj0 + 36);
    if (*(int*) num1 != 0)
    {
      int num2 = *(int*) num1;
      if ((uint) num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 52) * 2 + num2))
      {
        *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Pninc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0) = _Meta;
        return _Meta;
      }
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
      return !\u003CModule\u003E.std\u002E_Fputc\u003Cunsigned\u0020short\u003E(_Meta, (_iobuf*) _File) ? ushort.MaxValue : _Meta;
    ushort _Wchar = _Meta;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    ushort num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      sbyte* _First2_1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
      ushort* numPtr2;
      sbyte* numPtr3;
      int num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &numPtr2, _First2_1, (sbyte*) ((int) num4 + (IntPtr) numPtr1), &numPtr3);
      if (num5 >= 0)
      {
        do
        {
          if (num5 <= 1)
          {
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
            uint num6 = (uint) ((IntPtr) numPtr3 - (IntPtr) numPtr4);
            if (0U < num6)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
              if ((int) num6 != (int) \u003CModule\u003E.fwrite((void*) numPtr5, 1U, num6, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                goto label_23;
            }
            *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 1;
            if ((IntPtr) numPtr2 == ref _Wchar)
            {
              if (0U >= num6)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) < 32U)
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
                else
                  goto label_25;
              }
              sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num7 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
              sbyte* _First2_2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
              num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &numPtr2, _First2_2, (sbyte*) ((int) num7 + (IntPtr) numPtr6), &numPtr3);
            }
            else
              goto label_24;
          }
          else
            goto label_19;
        }
        while (num5 >= 0);
        goto label_26;
label_19:
        if (num5 == 3)
          num3 = !\u003CModule\u003E.std\u002E_Fputc\u003Cunsigned\u0020short\u003E(_Wchar, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)) ? ushort.MaxValue : _Meta;
        else
          goto label_26;
      }
      else
        goto label_26;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_23:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_24:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return _Meta;
label_25:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_26:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0 && (uint) *(int*) *(int*) ((IntPtr) obj0 + 16) < (uint) num1 && (ushort.MaxValue == _Meta || (int) *(ushort*) (num1 - 2) == (int) _Meta))
    {
      int num2 = *(int*) ((IntPtr) obj0 + 48);
      *(int*) num2 = *(int*) num2 + 1;
      int num3 = *(int*) ((IntPtr) obj0 + 32);
      *(int*) num3 = *(int*) num3 - 2;
      return \u003CModule\u003E.std\u002Echar_traits\u003Cunsigned\u0020short\u003E\u002Enot_eof(&_Meta);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U || ushort.MaxValue == _Meta)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0 && \u003CModule\u003E.std\u002E_Ungetc\u003Cunsigned\u0020short\u003E(&_Meta, (_iobuf*) _File))
      return _Meta;
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) traitsUnsignedShortPtr)
      return ushort.MaxValue;
    *(short*) traitsUnsignedShortPtr = (short) _Meta;
    ushort* numPtr = (ushort*) traitsUnsignedShortPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) traitsUnsignedShortPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 66 >> 1);
    return _Meta;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) *(int*) ((IntPtr) obj0 + 32);
      if (num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2) + num2)
        return *(ushort*) num1;
    }
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    ushort num3 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr1 + 20))((IntPtr) traitsUnsignedShortPtr1);
    if (ushort.MaxValue == num3)
      return num3;
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = obj0;
    int num4 = (int) num3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = (int) __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) traitsUnsignedShortPtr2, (IntPtr) num4);
    return num3;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    if (*(int*) *(int*) ((IntPtr) obj0 + 32) != 0)
    {
      int num = *(int*) *(int*) ((IntPtr) obj0 + 32);
      if ((uint) num < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2 + num))
        return *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
    {
      ushort num;
      return !\u003CModule\u003E.std\u002E_Fgetc\u003Cunsigned\u0020short\u003E(&num, (_iobuf*) _File) ? ushort.MaxValue : num;
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
    sbyte* numPtr1;
    ushort num1;
    // ISSUE: fault handler
    try
    {
      int _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
      if (_Ch != -1)
      {
        basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _State = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) _Ch);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* _First1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          ushort* numPtr3;
          int num3 = \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002Ein((codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) _State, _First1, numPtr2 + (int) num2, &numPtr1, &num1, &num1 + 1, &numPtr3);
          if (num3 >= 0)
          {
            if (num3 > 1)
            {
              if (num3 == 3)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) >= 2U)
                  goto label_19;
              }
              else
                goto label_27;
            }
            else if ((IntPtr) numPtr3 == ref num1)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar1, 0U, (uint) ((IntPtr) numPtr1 - (IntPtr) numPtr4));
            }
            else
              goto label_22;
            _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
          }
          else
            goto label_27;
        }
        while (_Ch != -1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_19:
    ushort num4;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5);
      \u003CModule\u003E.memcpy_s((void*) &num1, 2U, (void*) \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) stdAllocatorCharPtr), 2U);
      num4 = num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num4;
label_22:
    ushort num5;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
      sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar6));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num6 = (int) (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) - (IntPtr) numPtr1 + (IntPtr) numPtr5);
      if (0 < num6)
      {
        do
        {
          --num6;
          \u003CModule\u003E.ungetc((int) *(sbyte*) (num6 + (IntPtr) numPtr1), (_iobuf*) *(int*) ((IntPtr) obj0 + 76));
        }
        while (num6 > 0);
      }
      num5 = num1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num5;
label_27:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _Off,
    int _Way,
    int __unnamed002)
  {
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64 && _Way == 1 && *(int*) ((IntPtr) obj0 + 60) == 0)
      _Off -= 2;
    long num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(obj0) && (_Off == 0 && _Way == 1 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), _Off, _Way) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64)
      {
        ushort* numPtr = (ushort*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 64);
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _Pos,
    int __unnamed001)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    long num = ^(long&) ((IntPtr) &_Pos + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(obj0) && \u003CModule\u003E.fsetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0 && (^(int&) ref _Pos == 0 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), ^(int&) ref _Pos, 1) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(int*) ((IntPtr) obj0 + 68) = ^(int&) ((IntPtr) &_Pos + 16);
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) traitsUnsignedShortPtr)
      {
        ushort* numPtr = (ushort*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) traitsUnsignedShortPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) numPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) numPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Buffer,
    int _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (num1 != 0U)
    {
      int num2 = (IntPtr) _Buffer != IntPtr.Zero || _Count != 0 ? 0 : 4;
      if (\u003CModule\u003E.setvbuf((_iobuf*) num1, (sbyte*) _Buffer, num2, (uint) (_Count << 1)) == 0)
      {
        basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
        int _File = *(int*) ((IntPtr) traitsUnsignedShortPtr + 76);
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(traitsUnsignedShortPtr, (_iobuf*) _File, (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 1);
        return (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0;
      }
    }
    return (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    int num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0)
    {
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr, new IntPtr(65535)) && 0 > \u003CModule\u003E.fflush((_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
      {
        num = -1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    locale* _Loc)
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Initcvt(obj0, \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u0020\u003E(_Loc));
  }

  internal static unsafe void* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 80U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einit(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Init((ios_base*) obj0);
    *(int*) ((IntPtr) obj0 + 40) = (int) _Strbuf;
    *(int*) ((IntPtr) obj0 + 44) = 0;
    *(short*) ((IntPtr) obj0 + 48) = (short) \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ewiden(obj0, (sbyte) 32);
    if (*(int*) ((IntPtr) obj0 + 40) == 0)
    {
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      int _State = *(int*) ((IntPtr) traitsUnsignedShortPtr + 8) | 4;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclear(traitsUnsignedShortPtr, _State, false);
    }
    if (_Isstd)
      \u003CModule\u003E.std\u002Eios_base\u002E_Addstd((ios_base*) obj0);
    else
      *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_ctor((_Mutex*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
      locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
      *(int*) ((IntPtr) obj0 + 56) = (int) localePtr2;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eclose(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    if (*(int*) ((IntPtr) obj0 + 76) == 0)
    {
      traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
    }
    else
    {
      if (!\u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(obj0))
        traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
      if (\u003CModule\u003E.fclose((_iobuf*) *(int*) ((IntPtr) obj0 + 76)) != 0)
        traitsUnsignedShortPtr = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) 0;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(obj0, (_iobuf*) 0, (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 2);
    return traitsUnsignedShortPtr;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    _iobuf* _File,
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl _Which)
  {
    int num = _Which == (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E._Initfl) 1 ? 1 : 0;
    *(sbyte*) ((IntPtr) obj0 + 72) = (sbyte) num;
    *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    *(int*) ((IntPtr) obj0 + 76) = (int) _File;
    *(int*) ((IntPtr) obj0 + 68) = \u003CModule\u003E.\u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
    *(int*) ((IntPtr) obj0 + 60) = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Endwrite(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    if (*(int*) ((IntPtr) obj0 + 60) == 0 || *(byte*) ((IntPtr) obj0 + 66) == (byte) 0)
      return true;
    basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (ushort.MaxValue == __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) traitsUnsignedShortPtr1, new IntPtr(65535)))
      return false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    // ISSUE: fault handler
    try
    {
      basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = (basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
      while (true)
      {
        uint num1;
        do
        {
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr1 = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60);
          codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr2 = unsignedShortCharIntPtr1;
          basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr3 = traitsUnsignedShortPtr2;
          sbyte* numPtr3 = numPtr2;
          IntPtr num3 = (int) num2 + (IntPtr) numPtr1;
          sbyte* numPtr4;
          ref sbyte* local = ref numPtr4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          switch (__calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) unsignedShortCharIntPtr1 + 24))((sbyte**) unsignedShortCharIntPtr2, (sbyte*) traitsUnsignedShortPtr3, numPtr3, (int*) num3, (IntPtr) ref local))
          {
            case 0:
              *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
              goto case 1;
            case 1:
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              num1 = (uint) ((IntPtr) numPtr4 - (IntPtr) numPtr5);
              if (0U < num1)
              {
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
                if ((int) num1 != (int) \u003CModule\u003E.fwrite((void*) numPtr6, 1U, num1, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                  goto label_15;
              }
              if (*(byte*) ((IntPtr) obj0 + 66) != (byte) 0)
                continue;
              goto label_16;
            case 3:
              goto label_14;
            default:
              goto label_13;
          }
        }
        while (num1 != 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_13:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_14:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
label_15:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_16:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Initcvt(
    [In] basic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* _Newpcvt)
  {
    codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = _Newpcvt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<byte (IntPtr)>) *(int*) (*(int*) unsignedShortCharIntPtr + 4))((IntPtr) unsignedShortCharIntPtr) != (byte) 0)
    {
      *(int*) ((IntPtr) obj0 + 60) = 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 60) = (int) _Newpcvt;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj0);
    }
  }

  internal static unsafe ushort std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ewiden(
    [In] basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    sbyte _Byte)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc((ios_base*) obj0, &locale);
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr1;
    // ISSUE: fault handler
    try
    {
      ctypeUnsignedShortPtr1 = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr2 = ctypeUnsignedShortPtr1;
    int num = (int) _Byte;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort (IntPtr, sbyte)>) *(int*) (*(int*) ctypeUnsignedShortPtr1 + 40))((sbyte) ctypeUnsignedShortPtr2, (IntPtr) num);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Init(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 8);
    *(int*) ((IntPtr) obj0 + 20) = (int) ((IntPtr) obj0 + 12);
    *(int*) ((IntPtr) obj0 + 32) = (int) ((IntPtr) obj0 + 24);
    *(int*) ((IntPtr) obj0 + 36) = (int) ((IntPtr) obj0 + 28);
    *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 + 40);
    *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) obj0 + 44);
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetp(obj0, (ushort*) 0, (ushort*) 0);
    *(int*) *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetp(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    *(int*) *(int*) ((IntPtr) obj0 + 20) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 36) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) _Last - (IntPtr) _First >> 1);
  }

  internal static unsafe ctype\u003Cunsigned\u0020short\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cunsigned\u0020short\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (ctype\u003Cunsigned\u0020short\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x68dc8993\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__E\u003FA0x68760d79\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x68760d79\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x68760d79\u002E\u003F\u003F__F\u003FA0x68760d79\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__F\u003FA0x68760d79\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x68760d79\u002Einitlocks);

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__E\u003FA0x68760d79\u0040wfin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x68760d79\u002Ewfin, \u003CModule\u003E.__iob_func());
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x68760d79\u002E\u003F\u003F__F\u003FA0x68760d79\u0040wfin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__F\u003FA0x68760d79\u0040wfin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x68760d79\u002Ewfin);

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__Ewcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcin, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x68760d79\u002Ewfin, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x68760d79\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcin);

  internal static unsafe basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wcin_func() => &\u003CModule\u003E.std\u002Ewcin;

  internal static unsafe void \u003FA0x68760d79\u002E\u003F\u003F__E\u003FA0x68760d79\u0040init_ushcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wcin = &\u003CModule\u003E.std\u002Ewcin;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcin + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcin + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* pThis = (basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 4) = 0;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einit((basic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__E\u003FA0x2281fc9e\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x2281fc9e\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x2281fc9e\u002E\u003F\u003F__F\u003FA0x2281fc9e\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__F\u003FA0x2281fc9e\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x2281fc9e\u002Einitlocks);

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__E\u003FA0x2281fc9e\u0040wflog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x2281fc9e\u002Ewflog, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2281fc9e\u002E\u003F\u003F__F\u003FA0x2281fc9e\u0040wflog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__F\u003FA0x2281fc9e\u0040wflog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x2281fc9e\u002Ewflog);

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__Ewclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewclog, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x2281fc9e\u002Ewflog, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x2281fc9e\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewclog);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wclog_func() => &\u003CModule\u003E.std\u002Ewclog;

  internal static unsafe void \u003FA0x2281fc9e\u002E\u003F\u003F__E\u003FA0x2281fc9e\u0040init_ushclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wclog = &\u003CModule\u003E.std\u002Ewclog;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewclog + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewclog + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__E\u003FA0xeae248c8\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0xeae248c8\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xeae248c8\u002E\u003F\u003F__F\u003FA0xeae248c8\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__F\u003FA0xeae248c8\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0xeae248c8\u002Einitlocks);

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__E\u003FA0xeae248c8\u0040wfout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xeae248c8\u002Ewfout, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xeae248c8\u002E\u003F\u003F__F\u003FA0xeae248c8\u0040wfout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__F\u003FA0xeae248c8\u0040wfout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xeae248c8\u002Ewfout);

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__Ewcout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcout, (basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xeae248c8\u002Ewfout, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xeae248c8\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcout);

  internal static unsafe basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Wcout_func() => &\u003CModule\u003E.std\u002Ewcout;

  internal static unsafe _Init_ushcout* std\u002E_Init_ushcout\u002E\u007Bctor\u007D(
    [In] _Init_ushcout* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcout = &\u003CModule\u003E.std\u002Ewcout;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcin != IntPtr.Zero)
    {
      basic_istream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* stdPtrWcin = \u003CModule\u003E.std\u002E_Ptr_wcin;
      int num = *(int*) (*(int*) stdPtrWcin + 4);
      *(int*) ((IntPtr) stdPtrWcin + num + 44) = (int) &\u003CModule\u003E.std\u002Ewcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcerr != IntPtr.Zero)
    {
      basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* stdPtrWcerr = \u003CModule\u003E.std\u002E_Ptr_wcerr;
      int num = *(int*) (*(int*) stdPtrWcerr + 4);
      *(int*) ((IntPtr) stdPtrWcerr + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wclog != IntPtr.Zero)
    {
      basic_ostream\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* stdPtrWclog = \u003CModule\u003E.std\u002E_Ptr_wclog;
      int num = *(int*) (*(int*) stdPtrWclog + 4);
      *(int*) ((IntPtr) stdPtrWclog + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    return obj0;
  }

  internal static unsafe void \u003FA0xeae248c8\u002E\u003F\u003F__E\u003FA0xeae248c8\u0040init_ushcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_ushcout\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xeae248c8\u002Einit_ushcout);

  internal static unsafe ushort std\u002Echar_traits\u003Cwchar_t\u003E\u002Enot_eof(ushort* _Meta)
  {
    ushort num = *_Meta;
    return num == ushort.MaxValue ? (ushort) 0 : num;
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Ein(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte** _Mid1,
    char* _First2,
    char* _Last2,
    char** _Mid2)
  {
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = obj0;
    int* numPtr1 = _State;
    sbyte* numPtr2 = _First1;
    sbyte* numPtr3 = _Last1;
    sbyte** numPtr4 = _Mid1;
    char* chPtr1 = _First2;
    char* chPtr2 = _Last2;
    char** chPtr3 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**, char*, char*, char**)>) *(int*) (*(int*) obj0 + 16))((char**) codecvtWcharTCharIntPtr, (char*) numPtr1, (char*) numPtr2, (sbyte**) numPtr3, (sbyte*) numPtr4, (sbyte*) chPtr1, (int*) chPtr2, (IntPtr) chPtr3);
  }

  internal static unsafe int std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Eout(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    int* _State,
    char* _First1,
    char* _Last1,
    char** _Mid1,
    sbyte* _First2,
    sbyte* _Last2,
    sbyte** _Mid2)
  {
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = obj0;
    int* numPtr1 = _State;
    char* chPtr1 = _First1;
    char* chPtr2 = _Last1;
    char** chPtr3 = _Mid1;
    sbyte* numPtr2 = _First2;
    sbyte* numPtr3 = _Last2;
    sbyte** numPtr4 = _Mid2;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr, int*, char*, char*, char**, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) obj0 + 20))((sbyte**) codecvtWcharTCharIntPtr, (sbyte*) numPtr1, (sbyte*) chPtr1, (char**) chPtr2, (char*) chPtr3, (char*) numPtr2, (int*) numPtr3, (IntPtr) numPtr4);
  }

  internal static unsafe codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr1 = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(16U);
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr2;
      // ISSUE: fault handler
      try
      {
        codecvtWcharTCharIntPtr2 = (IntPtr) codecvtWcharTCharIntPtr1 == IntPtr.Zero ? (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) 0 : \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(codecvtWcharTCharIntPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) codecvtWcharTCharIntPtr1);
      }
      *(int*) _Ppf = (int) codecvtWcharTCharIntPtr2;
    }
    return 2;
  }

  internal static unsafe ctype\u003Cwchar_t\u003E* std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ectype\u003Cwchar_t\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      ctype\u003Cwchar_t\u003E* ctypeWcharTPtr1 = (ctype\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(32U);
      ctype\u003Cwchar_t\u003E* ctypeWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        ctypeWcharTPtr2 = (IntPtr) ctypeWcharTPtr1 == IntPtr.Zero ? (ctype\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(ctypeWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) ctypeWcharTPtr1);
      }
      *(int*) _Ppf = (int) ctypeWcharTPtr2;
    }
    return 2;
  }

  internal static unsafe void std\u002Ectype\u003Cwchar_t\u003E\u002E_Init(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj)
  {
    _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 24, ref cvtvec, 8);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fgetc\u003Cwchar_t\u003E(char* _Wchar, _iobuf* _File)
  {
    ushort num = \u003CModule\u003E.fgetwc(_File);
    if (num == ushort.MaxValue)
      return false;
    *_Wchar = (char) num;
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Fputc\u003Cwchar_t\u003E([MarshalAs(UnmanagedType.U2)] char _Wchar, _iobuf* _File) => \u003CModule\u003E.fputwc(_Wchar, _File) != ushort.MaxValue;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_Ungetc\u003Cwchar_t\u003E(char* _Wchar, _iobuf* _File) => \u003CModule\u003E.ungetwc((ushort) *_Wchar, _File) != ushort.MaxValue;

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__E\u003FA0x4fded7d1\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x4fded7d1\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x4fded7d1\u002E\u003F\u003F__F\u003FA0x4fded7d1\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__F\u003FA0x4fded7d1\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x4fded7d1\u002Einitlocks);

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__E\u003FA0x4fded7d1\u0040wferr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x4fded7d1\u002Ewferr, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x4fded7d1\u002E\u003F\u003F__F\u003FA0x4fded7d1\u0040wferr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__F\u003FA0x4fded7d1\u0040wferr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x4fded7d1\u002Ewferr);

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__Ewcerr\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcerr, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x4fded7d1\u002Ewferr, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x4fded7d1\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__Fwcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcerr);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wcerr_func() => &\u003CModule\u003E.std\u002Ewcerr;

  internal static unsafe _Init_wcerr* std\u002E_Init_wcerr\u002E\u007Bctor\u007D(
    [In] _Init_wcerr* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcerr = &\u003CModule\u003E.std\u002Ewcerr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcerr + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ios_base* iosBasePtr = (ios_base*) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcerr + 4) + (IntPtr) &\u003CModule\u003E.std\u002Ewcerr);
    *(int*) ((IntPtr) iosBasePtr + 16) = *(int*) ((IntPtr) iosBasePtr + 16) | 2;
    return obj0;
  }

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__E\u003FA0x4fded7d1\u0040init_wcerr\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_wcerr\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x4fded7d1\u002Einit_wcerr);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* pThis = (basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ostream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Einit((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      if (*(byte*) ((IntPtr) obj0 + 72) != (byte) 0)
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclose(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
  }

  internal static unsafe basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _iobuf* _File)
  {
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(obj0, _File, (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    if (ushort.MaxValue == _Meta)
      return \u003CModule\u003E.std\u002Echar_traits\u003Cwchar_t\u003E\u002Enot_eof(&_Meta);
    int num1 = *(int*) ((IntPtr) obj0 + 36);
    if (*(int*) num1 != 0)
    {
      int num2 = *(int*) num1;
      if ((uint) num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 52) * 2 + num2))
      {
        *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Pninc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0) = (char) _Meta;
        return _Meta;
      }
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
      return !\u003CModule\u003E.std\u002E_Fputc\u003Cwchar_t\u003E((char) _Meta, (_iobuf*) _File) ? ushort.MaxValue : _Meta;
    char _Wchar = (char) _Meta;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    ushort num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      sbyte* _First2_1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
      char* chPtr;
      sbyte* numPtr2;
      int num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &chPtr, _First2_1, (sbyte*) ((int) num4 + (IntPtr) numPtr1), &numPtr2);
      if (num5 >= 0)
      {
        do
        {
          if (num5 <= 1)
          {
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            sbyte* numPtr3 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
            uint num6 = (uint) ((IntPtr) numPtr2 - (IntPtr) numPtr3);
            if (0U < num6)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
              sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
              if ((int) num6 != (int) \u003CModule\u003E.fwrite((void*) numPtr4, 1U, num6, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                goto label_23;
            }
            *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 1;
            if ((IntPtr) chPtr == ref _Wchar)
            {
              if (0U >= num6)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) < 32U)
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
                else
                  goto label_25;
              }
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num7 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
              sbyte* _First2_2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
              num5 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Eout((codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) ((IntPtr) obj0 + 68), &_Wchar, &_Wchar + 1, &chPtr, _First2_2, (sbyte*) ((int) num7 + (IntPtr) numPtr5), &numPtr2);
            }
            else
              goto label_24;
          }
          else
            goto label_19;
        }
        while (num5 >= 0);
        goto label_26;
label_19:
        if (num5 == 3)
          num3 = !\u003CModule\u003E.std\u002E_Fputc\u003Cwchar_t\u003E(_Wchar, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)) ? ushort.MaxValue : _Meta;
        else
          goto label_26;
      }
      else
        goto label_26;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_23:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_24:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return _Meta;
label_25:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_26:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ushort _Meta)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0 && (uint) *(int*) *(int*) ((IntPtr) obj0 + 16) < (uint) num1 && (ushort.MaxValue == _Meta || (int) *(ushort*) (num1 - 2) == (int) _Meta))
    {
      int num2 = *(int*) ((IntPtr) obj0 + 48);
      *(int*) num2 = *(int*) num2 + 1;
      int num3 = *(int*) ((IntPtr) obj0 + 32);
      *(int*) num3 = *(int*) num3 - 2;
      return \u003CModule\u003E.std\u002Echar_traits\u003Cwchar_t\u003E\u002Enot_eof(&_Meta);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U || ushort.MaxValue == _Meta)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0 && \u003CModule\u003E.std\u002E_Ungetc\u003Cwchar_t\u003E(&(char) _Meta, (_iobuf*) _File))
      return _Meta;
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) charTraitsWcharTPtr)
      return ushort.MaxValue;
    *(short*) charTraitsWcharTPtr = (short) _Meta;
    char* chPtr = (char*) charTraitsWcharTPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) charTraitsWcharTPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) chPtr;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) chPtr + 66 >> 1);
    return _Meta;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num1 = *(int*) *(int*) ((IntPtr) obj0 + 32);
    if (num1 != 0)
    {
      uint num2 = (uint) *(int*) *(int*) ((IntPtr) obj0 + 32);
      if (num2 < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2) + num2)
        return *(ushort*) num1;
    }
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    ushort num3 = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr1 + 20))((IntPtr) charTraitsWcharTPtr1);
    if (ushort.MaxValue == num3)
      return num3;
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = obj0;
    int num4 = (int) num3;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num5 = (int) __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 8))((ushort) charTraitsWcharTPtr2, (IntPtr) num4);
    return num3;
  }

  internal static unsafe ushort std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if (*(int*) *(int*) ((IntPtr) obj0 + 32) != 0)
    {
      int num = *(int*) *(int*) ((IntPtr) obj0 + 32);
      if ((uint) num < (uint) (*(int*) *(int*) ((IntPtr) obj0 + 48) * 2 + num))
        return (ushort) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    }
    uint _File = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (_File == 0U)
      return ushort.MaxValue;
    if (*(int*) ((IntPtr) obj0 + 60) == 0)
    {
      char ch;
      return !\u003CModule\u003E.std\u002E_Fgetc\u003Cwchar_t\u003E(&ch, (_iobuf*) _File) ? ushort.MaxValue : (ushort) ch;
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, false, 0U);
    sbyte* numPtr1;
    char ch1;
    // ISSUE: fault handler
    try
    {
      int _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
      if (_Ch != -1)
      {
        basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _State = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) _Ch);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num1 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* _First1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          char* chPtr;
          int num2 = \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002Ein((codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60), (int*) _State, _First1, numPtr2 + (int) num1, &numPtr1, &ch1, &ch1 + 1, &chPtr);
          if (num2 >= 0)
          {
            if (num2 > 1)
            {
              if (num2 == 3)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if ((uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) >= 2U)
                  goto label_19;
              }
              else
                goto label_27;
            }
            else if ((IntPtr) chPtr == ref ch1)
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr3 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar1, 0U, (uint) ((IntPtr) numPtr1 - (IntPtr) numPtr3));
            }
            else
              goto label_22;
            _Ch = \u003CModule\u003E.fgetc((_iobuf*) *(int*) ((IntPtr) obj0 + 76));
          }
          else
            goto label_27;
        }
        while (_Ch != -1);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
label_19:
    ushort num3;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5);
      \u003CModule\u003E.memcpy_s((void*) &ch1, 2U, (void*) \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) stdAllocatorCharPtr), 2U);
      num3 = (ushort) ch1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num3;
label_22:
    ushort num4;
    // ISSUE: fault handler
    try
    {
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
      sbyte* numPtr4 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar6));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num5 = (int) (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) - (IntPtr) numPtr1 + (IntPtr) numPtr4);
      if (0 < num5)
      {
        do
        {
          --num5;
          \u003CModule\u003E.ungetc((int) *(sbyte*) (num5 + (IntPtr) numPtr1), (_iobuf*) *(int*) ((IntPtr) obj0 + 76));
        }
        while (num5 > 0);
      }
      num4 = (ushort) ch1;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return num4;
label_27:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return ushort.MaxValue;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    int _Off,
    int _Way,
    int __unnamed002)
  {
    if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64 && _Way == 1 && *(int*) ((IntPtr) obj0 + 60) == 0)
      _Off -= 2;
    long num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(obj0) && (_Off == 0 && _Way == 1 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), _Off, _Way) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) obj0 + 64)
      {
        char* chPtr = (char*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 64);
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) chPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) chPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe fpos\u003Cint\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] fpos\u003Cint\u003E* obj1,
    fpos\u003Cint\u003E _Pos,
    int __unnamed001)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    long num = ^(long&) ((IntPtr) &_Pos + 8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (*(int*) ((IntPtr) obj0 + 76) != 0 && \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(obj0) && \u003CModule\u003E.fsetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0 && (^(int&) ref _Pos == 0 || \u003CModule\u003E.fseek((_iobuf*) *(int*) ((IntPtr) obj0 + 76), ^(int&) ref _Pos, 1) == 0) && \u003CModule\u003E.fgetpos((_iobuf*) *(int*) ((IntPtr) obj0 + 76), &num) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(int*) ((IntPtr) obj0 + 68) = ^(int&) ((IntPtr) &_Pos + 16);
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 64);
      if ((IntPtr) *(int*) *(int*) ((IntPtr) obj0 + 32) == (IntPtr) charTraitsWcharTPtr)
      {
        char* chPtr = (char*) ((IntPtr) obj0 + 66);
        *(int*) *(int*) ((IntPtr) obj0 + 16) = (int) charTraitsWcharTPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 32) = (int) chPtr;
        *(int*) *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 - (IntPtr) chPtr + 66 >> 1);
      }
      *(int*) obj1 = 0;
      *(long*) ((IntPtr) obj1 + 8) = num;
      *(int*) ((IntPtr) obj1 + 16) = *(int*) ((IntPtr) obj0 + 68);
      return obj1;
    }
    *(int*) obj1 = \u003CModule\u003E.std\u002E_BADOFF;
    *(long*) ((IntPtr) obj1 + 8) = 0L;
    *(int*) ((IntPtr) obj1 + 16) = 0;
    return obj1;
  }

  internal static unsafe basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Buffer,
    int _Count)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 76);
    if (num1 != 0U)
    {
      int num2 = (IntPtr) _Buffer != IntPtr.Zero || _Count != 0 ? 0 : 4;
      if (\u003CModule\u003E.setvbuf((_iobuf*) num1, (sbyte*) _Buffer, num2, (uint) (_Count << 1)) == 0)
      {
        basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
        int _File = *(int*) ((IntPtr) charTraitsWcharTPtr + 76);
        \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(charTraitsWcharTPtr, (_iobuf*) _File, (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 1);
        return (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0;
      }
    }
    return (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
  }

  internal static unsafe int std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    int num;
    if (*(int*) ((IntPtr) obj0 + 76) != 0)
    {
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      if (ushort.MaxValue != __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr, new IntPtr(65535)) && 0 > \u003CModule\u003E.fflush((_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
      {
        num = -1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    locale* _Loc)
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Initcvt(obj0, \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u0020\u003E(_Loc));
  }

  internal static unsafe void* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 80U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Einit(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd)
  {
    \u003CModule\u003E.std\u002Eios_base\u002E_Init((ios_base*) obj0);
    *(int*) ((IntPtr) obj0 + 40) = (int) _Strbuf;
    *(int*) ((IntPtr) obj0 + 44) = 0;
    *(short*) ((IntPtr) obj0 + 48) = (short) \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Ewiden(obj0, (sbyte) 32);
    if (*(int*) ((IntPtr) obj0 + 40) == 0)
    {
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      int _State = *(int*) ((IntPtr) charTraitsWcharTPtr + 8) | 4;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclear(charTraitsWcharTPtr, _State, false);
    }
    if (_Isstd)
      \u003CModule\u003E.std\u002Eios_base\u002E_Addstd((ios_base*) obj0);
    else
      *(int*) ((IntPtr) obj0 + 4) = 0;
  }

  internal static unsafe basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_streambuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mutex\u002E_Mutex_ctor((_Mutex*) ((IntPtr) obj0 + 4));
    // ISSUE: fault handler
    try
    {
      locale* localePtr1 = (locale*) \u003CModule\u003E.@new(4U);
      locale* localePtr2 = (IntPtr) localePtr1 == IntPtr.Zero ? (locale*) 0 : \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(localePtr1);
      *(int*) ((IntPtr) obj0 + 56) = (int) localePtr2;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mutex\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 4));
    }
    return obj0;
  }

  internal static unsafe basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eclose(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    if (*(int*) ((IntPtr) obj0 + 76) == 0)
    {
      charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
    }
    else
    {
      if (!\u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(obj0))
        charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
      if (\u003CModule\u003E.fclose((_iobuf*) *(int*) ((IntPtr) obj0 + 76)) != 0)
        charTraitsWcharTPtr = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) 0;
    }
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(obj0, (_iobuf*) 0, (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 2);
    return charTraitsWcharTPtr;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _iobuf* _File,
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl _Which)
  {
    int num = _Which == (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E._Initfl) 1 ? 1 : 0;
    *(sbyte*) ((IntPtr) obj0 + 72) = (sbyte) num;
    *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    *(int*) ((IntPtr) obj0 + 76) = (int) _File;
    *(int*) ((IntPtr) obj0 + 68) = \u003CModule\u003E.\u003F_Stinit\u0040\u003F1\u003F\u003F_Init\u0040\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040IAMXPAU_iobuf\u0040\u0040W4_Initfl\u004023\u0040\u0040Z\u00404HA;
    *(int*) ((IntPtr) obj0 + 60) = 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Endwrite(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if (*(int*) ((IntPtr) obj0 + 60) == 0 || *(byte*) ((IntPtr) obj0 + 66) == (byte) 0)
      return true;
    basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (ushort.MaxValue == __calli((__FnPtr<ushort (IntPtr, ushort)>) *(int*) (*(int*) obj0 + 4))((ushort) charTraitsWcharTPtr1, new IntPtr(65535)))
      return false;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 8U, (sbyte) 0);
    // ISSUE: fault handler
    try
    {
      basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = (basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 68);
      while (true)
      {
        uint num1;
        do
        {
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          sbyte* numPtr1 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num2 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
          sbyte* numPtr2 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3));
          codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr1 = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) *(int*) ((IntPtr) obj0 + 60);
          codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr2 = codecvtWcharTCharIntPtr1;
          basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr3 = charTraitsWcharTPtr2;
          sbyte* numPtr3 = numPtr2;
          IntPtr num3 = (int) num2 + (IntPtr) numPtr1;
          sbyte* numPtr4;
          ref sbyte* local = ref numPtr4;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          switch (__calli((__FnPtr<int (IntPtr, int*, sbyte*, sbyte*, sbyte**)>) *(int*) (*(int*) codecvtWcharTCharIntPtr1 + 24))((sbyte**) codecvtWcharTCharIntPtr2, (sbyte*) charTraitsWcharTPtr3, numPtr3, (int*) num3, (IntPtr) ref local))
          {
            case 0:
              *(sbyte*) ((IntPtr) obj0 + 66) = (sbyte) 0;
              goto case 1;
            case 1:
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
              sbyte* numPtr5 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar4));
              num1 = (uint) ((IntPtr) numPtr4 - (IntPtr) numPtr5);
              if (0U < num1)
              {
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                sbyte* numPtr6 = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar5));
                if ((int) num1 != (int) \u003CModule\u003E.fwrite((void*) numPtr6, 1U, num1, (_iobuf*) *(int*) ((IntPtr) obj0 + 76)))
                  goto label_15;
              }
              if (*(byte*) ((IntPtr) obj0 + 66) != (byte) 0)
                continue;
              goto label_16;
            case 3:
              goto label_14;
            default:
              goto label_13;
          }
        }
        while (num1 != 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 8U, (sbyte) 0);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
label_13:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_14:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
label_15:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return false;
label_16:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return true;
  }

  internal static unsafe void std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Initcvt(
    [In] basic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* _Newpcvt)
  {
    codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = _Newpcvt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    if (__calli((__FnPtr<byte (IntPtr)>) *(int*) (*(int*) codecvtWcharTCharIntPtr + 4))((IntPtr) codecvtWcharTCharIntPtr) != (byte) 0)
    {
      *(int*) ((IntPtr) obj0 + 60) = 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 60) = (int) _Newpcvt;
      \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) obj0);
    }
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Ewiden(
    [In] basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    sbyte _Byte)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc((ios_base*) obj0, &locale);
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr1;
    // ISSUE: fault handler
    try
    {
      ctypeWcharTPtr1 = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    ctype\u003Cwchar_t\u003E* ctypeWcharTPtr2 = ctypeWcharTPtr1;
    int num = (int) _Byte;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (char) __calli((__FnPtr<ushort (IntPtr, sbyte)>) *(int*) (*(int*) ctypeWcharTPtr1 + 40))((sbyte) ctypeWcharTPtr2, (IntPtr) num);
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Init(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) ((IntPtr) obj0 + 16) = (int) ((IntPtr) obj0 + 8);
    *(int*) ((IntPtr) obj0 + 20) = (int) ((IntPtr) obj0 + 12);
    *(int*) ((IntPtr) obj0 + 32) = (int) ((IntPtr) obj0 + 24);
    *(int*) ((IntPtr) obj0 + 36) = (int) ((IntPtr) obj0 + 28);
    *(int*) ((IntPtr) obj0 + 48) = (int) ((IntPtr) obj0 + 40);
    *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) obj0 + 44);
    \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetp(obj0, (char*) 0, (char*) 0);
    *(int*) *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 32) = 0;
    *(int*) *(int*) ((IntPtr) obj0 + 48) = 0;
  }

  internal static unsafe void std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetp(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _First,
    char* _Last)
  {
    *(int*) *(int*) ((IntPtr) obj0 + 20) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 36) = (int) _First;
    *(int*) *(int*) ((IntPtr) obj0 + 52) = (int) ((IntPtr) _Last - (IntPtr) _First >> 1);
  }

  internal static unsafe ctype\u003Cwchar_t\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cwchar_t\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (ctype\u003Cwchar_t\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x4fded7d1\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eoverflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Epbackfail);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eshowmanyc);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eunderflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Euflow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsgetn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Xsgetn_s);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Exsputn);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekoff);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eseekpos);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esetbuf);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 52) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esync);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_filebuf\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 56) = (int) __methodptr(std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eimbue);
  }

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__E\u003FA0x6869e508\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x6869e508\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x6869e508\u002E\u003F\u003F__F\u003FA0x6869e508\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__F\u003FA0x6869e508\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x6869e508\u002Einitlocks);

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__E\u003FA0x6869e508\u0040wfin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x6869e508\u002Ewfin, \u003CModule\u003E.__iob_func());
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x6869e508\u002E\u003F\u003F__F\u003FA0x6869e508\u0040wfin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__F\u003FA0x6869e508\u0040wfin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x6869e508\u002Ewfin);

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__Ewcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcin, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x6869e508\u002Ewfin, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x6869e508\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__Fwcin\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcin);

  internal static unsafe basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wcin_func() => &\u003CModule\u003E.std\u002Ewcin;

  internal static unsafe void \u003FA0x6869e508\u002E\u003F\u003F__E\u003FA0x6869e508\u0040init_wcin\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wcin = &\u003CModule\u003E.std\u002Ewcin;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewcin + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewcin + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Strbuf,
    [MarshalAs(UnmanagedType.U1)] bool _Isstd,
    [In] int obj3)
  {
    uint num1 = 0;
    if (obj3 != 0)
    {
      *(int*) obj0 = (int) &\u003CModule\u003E.\u003F\u003F_8\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00407B\u0040;
      basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* pThis = (basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ios_base\u0040std\u0040\u00406B\u0040 + 4);
      // ISSUE: fault handler
      try
      {
        *(int*) pThis = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_ios\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eios_base\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
        }
      }
    }
    // ISSUE: fault handler
    try
    {
      *(int*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0) = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024basic_istream\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 4) = 0;
      \u003CModule\u003E.std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Einit((basic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) (*(int*) (*(int*) obj0 + 4) + (IntPtr) obj0), _Strbuf, _Isstd);
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_ios\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    return obj0;
  }

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__E\u003FA0x0583a2dc\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0x0583a2dc\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x0583a2dc\u002E\u003F\u003F__F\u003FA0x0583a2dc\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__F\u003FA0x0583a2dc\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0x0583a2dc\u002Einitlocks);

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__E\u003FA0x0583a2dc\u0040wflog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x0583a2dc\u002Ewflog, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x0583a2dc\u002E\u003F\u003F__F\u003FA0x0583a2dc\u0040wflog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__F\u003FA0x0583a2dc\u0040wflog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x0583a2dc\u002Ewflog);

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__Ewclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewclog, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0x0583a2dc\u002Ewflog, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x0583a2dc\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__Fwclog\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewclog);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wclog_func() => &\u003CModule\u003E.std\u002Ewclog;

  internal static unsafe void \u003FA0x0583a2dc\u002E\u003F\u003F__E\u003FA0x0583a2dc\u0040init_wclog\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Ptr_wclog = &\u003CModule\u003E.std\u002Ewclog;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (*(int*) (^(int&) ref \u003CModule\u003E.std\u002Ewclog + 4) + ((IntPtr) &\u003CModule\u003E.std\u002Ewclog + 44)) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
  }

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__E\u003FA0xcde0168a\u0040initlocks\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.\u003FA0xcde0168a\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xcde0168a\u002E\u003F\u003F__F\u003FA0xcde0168a\u0040initlocks\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__F\u003FA0xcde0168a\u0040initlocks\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.\u003FA0xcde0168a\u002Einitlocks);

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__E\u003FA0xcde0168a\u0040wfout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xcde0168a\u002Ewfout, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xcde0168a\u002E\u003F\u003F__F\u003FA0xcde0168a\u0040wfout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__F\u003FA0xcde0168a\u0040wfout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_filebuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xcde0168a\u002Ewfout);

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__Ewcout\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002Ewcout, (basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) &\u003CModule\u003E.std\u002E\u003FA0xcde0168a\u002Ewfout, false, 1);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0xcde0168a\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__Fwcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebasic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E__vbaseDtor(&\u003CModule\u003E.std\u002Ewcout);

  internal static unsafe basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Wcout_func() => &\u003CModule\u003E.std\u002Ewcout;

  internal static unsafe _Init_wcout* std\u002E_Init_wcout\u002E\u007Bctor\u007D(
    [In] _Init_wcout* obj0)
  {
    \u003CModule\u003E.std\u002E_Ptr_wcout = &\u003CModule\u003E.std\u002Ewcout;
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcin != IntPtr.Zero)
    {
      basic_istream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* stdPtrWcin = \u003CModule\u003E.std\u002E_Ptr_wcin;
      int num = *(int*) (*(int*) stdPtrWcin + 4);
      *(int*) ((IntPtr) stdPtrWcin + num + 44) = (int) &\u003CModule\u003E.std\u002Ewcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wcerr != IntPtr.Zero)
    {
      basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* stdPtrWcerr = \u003CModule\u003E.std\u002E_Ptr_wcerr;
      int num = *(int*) (*(int*) stdPtrWcerr + 4);
      *(int*) ((IntPtr) stdPtrWcerr + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    if ((IntPtr) \u003CModule\u003E.std\u002E_Ptr_wclog != IntPtr.Zero)
    {
      basic_ostream\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* stdPtrWclog = \u003CModule\u003E.std\u002E_Ptr_wclog;
      int num = *(int*) (*(int*) stdPtrWclog + 4);
      *(int*) ((IntPtr) stdPtrWclog + num + 44) = (int) \u003CModule\u003E.std\u002E_Ptr_wcout;
    }
    return obj0;
  }

  internal static unsafe void \u003FA0xcde0168a\u002E\u003F\u003F__E\u003FA0xcde0168a\u0040init_wcout\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_wcout\u002E\u007Bctor\u007D(&\u003CModule\u003E.std\u002E\u003FA0xcde0168a\u002Einit_wcout);

  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((std.exception*) obj0, &\u003CModule\u003E.std\u002E\u003FA0x78d0d095\u002E_bad_alloc_Message, 1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Locinfo\u002E_Getname(
    [In] _Locinfo* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 88));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Addfac(
    [In] locale._Locimp* obj0,
    locale.facet* _Pfacet,
    uint _Id)
  {
    \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Locimp_Addfac(obj0, _Pfacet, _Id);
  }

  internal static unsafe ctype\u003Cchar\u003E* std\u002Ectype\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe locale* std\u002Elocale\u002Eglobal([In] locale* obj0, locale* _param1)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bctor\u007D(obj0);
      num1 = 1U;
      bool flag = false;
      int num2 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num2);
          flag = true;
        }
        locale._Locimp* locimpPtr1 = \u003CModule\u003E.std\u002Elocale\u002E_Getgloballocale();
        if ((IntPtr) locimpPtr1 != (IntPtr) *(int*) _param1)
        {
          locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) locimpPtr1);
          void* voidPtr;
          if ((IntPtr) facetPtr1 != IntPtr.Zero)
          {
            locale.facet* facetPtr2 = facetPtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
          }
          else
            voidPtr = (void*) 0;
          locale._Locimp* locimpPtr2 = (locale._Locimp*) *(int*) _param1;
          \u003CModule\u003E.std\u002Elocale\u002E_Setgloballocale((void*) locimpPtr2);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) locimpPtr2);
          int num3 = *(int*) ((IntPtr) locimpPtr2 + 16) & 63;
          if (num3 == 63)
          {
            \u003CModule\u003E.setlocale(0, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) locimpPtr2 + 24)));
          }
          else
          {
            for (int index = 0; index <= 5; ++index)
            {
              if ((1 << index >> 1 & num3) != 0)
                \u003CModule\u003E.setlocale(index, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) locimpPtr2 + 24)));
            }
          }
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num2);
      }
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Locimp\u002E_Makeloc(
    _Locinfo* _param0,
    int _param1,
    locale._Locimp* _param2,
    locale* _param3)
  {
    if ((_param1 & 2) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        ctype\u003Cchar\u003E* ctypeCharPtr1 = (ctype\u003Cchar\u003E*) \u003CModule\u003E.@new(24U);
        ctype\u003Cchar\u003E* ctypeCharPtr2;
        // ISSUE: fault handler
        try
        {
          ctypeCharPtr2 = (IntPtr) ctypeCharPtr1 == IntPtr.Zero ? (ctype\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002E\u007Bctor\u007D(ctypeCharPtr1, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) ctypeCharPtr1);
        }
        uint num = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Locimp_Addfac(_param2, (locale.facet*) ctypeCharPtr2, num);
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cchar\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    int num1 = _param1 & 8;
    if (num1 != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) stdCharTraitsCharPtr == IntPtr.Zero ? (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_get\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if (num1 != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) stdCharTraitsCharPtr == IntPtr.Zero ? (num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_put\u003Cchar\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        numpunct\u003Cchar\u003E* numpunctCharPtr = (numpunct\u003Cchar\u003E*) \u003CModule\u003E.@new(24U);
        numpunct\u003Cchar\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) numpunctCharPtr == IntPtr.Zero ? (numpunct\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bctor\u007D(numpunctCharPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) numpunctCharPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        codecvt\u003Cchar\u002Cchar\u002Cint\u003E* codecvtCharCharIntPtr = (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(8U);
        codecvt\u003Cchar\u002Cchar\u002Cint\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) codecvtCharCharIntPtr == IntPtr.Zero ? (codecvt\u003Cchar\u002Cchar\u002Cint\u003E*) 0 : \u003CModule\u003E.std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(codecvtCharCharIntPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) codecvtCharCharIntPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Makexloc(_param0, _param1, _param2, _param3);
    \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Makewloc(_param0, _param1, _param2, _param3);
    \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Makeushloc(_param0, _param1, _param2, _param3);
    *(int*) ((IntPtr) _param2 + 16) = *(int*) ((IntPtr) _param2 + 16) | _param1;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Locinfo\u002E_Getname(_param0, &stdAllocatorChar);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param2 + 24), _Right);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar);
    return _param2;
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Locimp_ctor(
    locale._Locimp* _param0,
    locale._Locimp* _param1)
  {
    if (_param1 == \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A)
    {
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Makeloc(&locinfo, 63, _param0, (locale*) 0);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    else
    {
      bool flag = false;
      int num1 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
          flag = true;
        }
        uint num2 = (uint) *(int*) ((IntPtr) _param0 + 12);
        if (0U >= num2)
          return;
        void* voidPtr = \u003CModule\u003E.malloc(num2 << 2);
        *(int*) ((IntPtr) _param0 + 8) = (int) voidPtr;
        if ((IntPtr) voidPtr == IntPtr.Zero)
        {
          if (((int) \u003CModule\u003E.\u003FA0x78d0d095\u002E\u003F\u0024S1\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404IA & 1) == 0)
          {
            \u003CModule\u003E.\u003FA0x78d0d095\u002E\u003F\u0024S1\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404IA |= 1U;
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404Vbad_alloc\u00404\u0040B);
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x78d0d095\u002E\u003F\u003F__Fnomem\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV123\u0040ABV123\u0040\u0040Z\u0040YMXXZ));
            }
            __fault
            {
              \u003CModule\u003E.\u003FA0x78d0d095\u002E\u003F\u0024S1\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404IA &= 4294967294U;
            }
          }
          bad_alloc badAlloc;
          \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&badAlloc, &\u003CModule\u003E.\u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404Vbad_alloc\u00404\u0040B);
          \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
        }
        uint num3 = (uint) *(int*) ((IntPtr) _param0 + 12);
        while (0U < num3)
        {
          --num3;
          locale.facet* facetPtr = (locale.facet*) *(int*) (*(int*) ((IntPtr) _param1 + 8) + (int) num3 * 4);
          *(int*) (*(int*) ((IntPtr) _param0 + 8) + (int) num3 * 4) = (int) facetPtr;
          if ((IntPtr) facetPtr != IntPtr.Zero)
            \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(facetPtr);
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
      }
    }
  }

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__Fnomem\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV123\u0040ABV123\u0040\u0040Z\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FBJ\u0040\u003F\u003F_Locimp_ctor\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040ABV234\u0040\u0040Z\u00404Vbad_alloc\u00404\u0040B);

  [SpecialName]
  internal static unsafe bad_alloc* std\u002Ebad_alloc\u002E\u007Bctor\u007D(
    [In] bad_alloc* obj0,
    bad_alloc* _param1)
  {
    \u003CModule\u003E.std\u002Eexception\u002E\u007Bctor\u007D((std.exception*) obj0, (std.exception*) _param1);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Eexception\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Locimp_Addfac(
    locale._Locimp* _param0,
    locale.facet* _param1,
    uint _param2)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      if ((uint) *(int*) ((IntPtr) _param0 + 12) <= _param2)
      {
        uint num2 = _param2 + 1U;
        if (num2 < 40U)
          num2 = 40U;
        locale.facet** facetPtr = (locale.facet**) \u003CModule\u003E.realloc((void*) *(int*) ((IntPtr) _param0 + 8), num2 << 2);
        if ((IntPtr) facetPtr == IntPtr.Zero)
        {
          if (((int) \u003CModule\u003E.\u003FA0x78d0d095\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA & 1) == 0)
          {
            \u003CModule\u003E.\u003FA0x78d0d095\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA |= 1U;
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B);
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x78d0d095\u002E\u003F\u003F__Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV123\u0040PAVfacet\u004023\u0040I\u0040Z\u0040YMXXZ));
            }
            __fault
            {
              \u003CModule\u003E.\u003FA0x78d0d095\u002E\u003F\u0024S2\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404IA &= 4294967294U;
            }
          }
          bad_alloc badAlloc;
          \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&badAlloc, &\u003CModule\u003E.\u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B);
          \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
        }
        *(int*) ((IntPtr) _param0 + 8) = (int) facetPtr;
        while (true)
        {
          uint num3 = (uint) *(int*) ((IntPtr) _param0 + 12);
          if (num3 < num2)
          {
            *(int*) ((int) num3 * 4 + *(int*) ((IntPtr) _param0 + 8)) = 0;
            *(int*) ((IntPtr) _param0 + 12) = *(int*) ((IntPtr) _param0 + 12) + 1;
          }
          else
            break;
        }
      }
      \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(_param1);
      int num4 = (int) _param2 * 4;
      int num5 = num4 + *(int*) ((IntPtr) _param0 + 8);
      if (*(int*) num5 != 0)
      {
        locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(int*) num5);
        if ((IntPtr) facetPtr1 != IntPtr.Zero)
        {
          locale.facet* facetPtr2 = facetPtr1;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
        }
      }
      *(int*) (*(int*) ((IntPtr) _param0 + 8) + num4) = (int) _param1;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV123\u0040PAVfacet\u004023\u0040I\u0040Z\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x78d0d095\u002E\u003Fnomem\u0040\u003FO\u0040\u003F\u003F_Locimp_Addfac\u0040_Locimp\u0040locale\u0040std\u0040\u0040CAXPAV234\u0040PAVfacet\u004034\u0040I\u0040Z\u00404Vbad_alloc\u00404\u0040B);

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_ctor(
    _Locinfo* _param0,
    int _param1,
    sbyte* _param2)
  {
    sbyte* numPtr = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
    sbyte* _Ptr = (IntPtr) numPtr != IntPtr.Zero ? numPtr : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60), _Ptr);
    \u003CModule\u003E.std\u002E_Locinfo\u002E_Locinfo_Addcats(_param0, _param1, _param2);
  }

  internal static unsafe _Locinfo* std\u002E_Locinfo\u002E_Locinfo_Addcats(
    _Locinfo* _param0,
    int _param1,
    sbyte* _param2)
  {
    if (*_param2 != (sbyte) 42 || _param2[1] != (sbyte) 0)
    {
      sbyte* _Ptr;
      switch (_param1)
      {
        case 0:
          _Ptr = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
          break;
        case 63:
          _Ptr = \u003CModule\u003E.setlocale(0, _param2);
          break;
        default:
          int num = 0;
          do
          {
            if ((1 << num >> 1 & _param1) != 0)
              \u003CModule\u003E.setlocale(num, _param2);
            ++num;
          }
          while (num <= 5);
          _Ptr = \u003CModule\u003E.setlocale(0, _param2);
          break;
      }
      if ((IntPtr) _Ptr != IntPtr.Zero)
      {
        _Locinfo* locinfoPtr = (_Locinfo*) ((IntPtr) _param0 + 88);
        if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ecompare((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) locinfoPtr, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040) != 0)
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) locinfoPtr, _Ptr);
          goto label_13;
        }
        else
          goto label_13;
      }
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 88), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040);
label_13:
    return _param0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esgetc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gnavail(obj0))
      return (int) (byte) *(sbyte*) *(int*) *(int*) ((IntPtr) obj0 + 32);
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 16))((IntPtr) stdCharTraitsCharPtr);
  }

  internal static unsafe uint std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr2;
      // ISSUE: fault handler
      try
      {
        stdCharTraitsCharPtr2 = (IntPtr) stdCharTraitsCharPtr1 == IntPtr.Zero ? (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
      }
      *(int*) _Ppf = (int) stdCharTraitsCharPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    bool* _Val)
  {
    int num1 = -1;
    if ((*(int*) ((IntPtr) _Iosbase + 16) & 16384) != 0)
    {
      locale locale;
      locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
      numpunct\u003Cchar\u003E* numpunctCharPtr;
      // ISSUE: fault handler
      try
      {
        numpunctCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_Loc);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
      }
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, 1U, (sbyte) 0);
      // ISSUE: fault handler
      try
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right1 = \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Efalsename(numpunctCharPtr, &stdAllocatorChar2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar1, _Right1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) 0);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right2 = \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Etruename(numpunctCharPtr, &stdAllocatorChar3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar1, _Right2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar3, true, 0U);
        sbyte* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar1);
        num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 2U, _Ptr);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    }
    else
    {
      int num2 = 0;
      locale locale;
      locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
      \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
      sbyte* numPtr;
      uint num3;
      // ISSUE: fault handler
      try
      {
        int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
        num3 = \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
      }
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      if ((IntPtr) numPtr != ref arrayTypeBy0CaD && num2 == 0 && num3 <= 1U)
        num1 = (int) num3;
    }
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr = _State;
      int num4 = *numPtr | 1;
      *numPtr = num4;
    }
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num5 = *numPtr | 2;
      *numPtr = num5;
    }
    else
    {
      int num6 = num1 != 0 ? 1 : 0;
      *_Val = num6 != 0;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    ushort* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int traitsCharGetifld;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      traitsCharGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* s = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? (sbyte*) &arrayTypeBy0CaD : (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
    sbyte* numPtr1;
    uint num2 = \u003CModule\u003E._Stoulx(s, &numPtr1, traitsCharGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if (numPtr1 != s && num1 == 0 && (uint) ushort.MaxValue >= num2)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? num2 : (uint) -(int) num2;
      *_Val = (ushort) num4;
    }
    else
    {
      int* numPtr3 = _State;
      int num5 = *numPtr3 | 2;
      *numPtr3 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    uint* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int traitsCharGetifld;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      traitsCharGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* s = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? (sbyte*) &arrayTypeBy0CaD : (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
    sbyte* numPtr1;
    uint num2 = \u003CModule\u003E._Stoulx(s, &numPtr1, traitsCharGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if (numPtr1 != s && num1 == 0 && uint.MaxValue >= num2)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? num2 : (uint) -(int) num2;
      *_Val = num4;
    }
    else
    {
      int* numPtr3 = _State;
      int num5 = *numPtr3 | 2;
      *numPtr3 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    int* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    int num2;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num2 = \u003CModule\u003E._Stolx((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    uint* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    uint num2;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num2 = \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    long* _Val)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    long num1;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num1 = \u003CModule\u003E._strtoi64((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num2 = *numPtr2 | 1;
      *numPtr2 = num2;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD)
    {
      *_Val = num1;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    ulong* _Val)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    ulong num1;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num1 = \u003CModule\u003E._strtoui64((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num2 = *numPtr2 | 1;
      *numPtr2 = num2;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD)
    {
      *_Val = num1;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    float* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    float num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stofx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    double num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stodx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    double num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stoldx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    void** _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int traitsCharGetifld;
    // ISSUE: fault handler
    try
    {
      traitsCharGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, 2048, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    sbyte* numPtr1;
    ulong num2 = (ulong) \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr1, traitsCharGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *(int*) _Val = (int) num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe uint std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr2;
      // ISSUE: fault handler
      try
      {
        stdCharTraitsCharPtr2 = (IntPtr) stdCharTraitsCharPtr1 == IntPtr.Zero ? (num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
      }
      *(int*) _Ppf = (int) stdCharTraitsCharPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    [MarshalAs(UnmanagedType.U1)] bool _Val)
  {
    if ((*(int*) ((IntPtr) _Iosbase + 16) & 16384) == 0)
    {
      num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
      ref ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E local = ref stdCharTraitsChar1;
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2 = _Dest;
      ios_base* iosBasePtr = _Iosbase;
      int num1 = (int) _Fill;
      int num2 = _Val ? 1 : 0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* (IntPtr, ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*, ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E, ios_base*, sbyte, int)>) *(int*) (*(int*) obj0 + 28))((int) stdCharTraitsCharPtr, (sbyte) ref local, (ios_base*) stdCharTraitsChar2, (ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E) (IntPtr) iosBasePtr, (ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) num1, (IntPtr) num2);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, num3, 12);
      return obj1;
    }
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cchar\u003E* numpunctCharPtr;
    // ISSUE: fault handler
    try
    {
      numpunctCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      if (_Val)
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Etruename(numpunctCharPtr, &stdAllocatorChar2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(&stdAllocatorChar1, _Right);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
      }
      else
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Efalsename(numpunctCharPtr, &stdAllocatorChar3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(&stdAllocatorChar1, _Right);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar3, true, 0U);
      }
      int num = *(int*) ((IntPtr) _Iosbase + 24);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint _Count1 = num <= 0 || (uint) num <= (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) ? 0U : (uint) (num - ^(int&) ((IntPtr) &stdAllocatorChar1 + 20));
      uint _Count2 = _Count1;
      if ((*(int*) ((IntPtr) _Iosbase + 16) & 448) != 64)
      {
        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar, _Dest, _Fill, _Count1);
        // ISSUE: cpblk instruction
        __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr, 12);
        _Count2 = 0U;
      }
      sbyte* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar1);
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(obj0, &stdCharTraitsChar3, _Dest, _Ptr, (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20));
      // ISSUE: cpblk instruction
      __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr1, 12);
      *(int*) ((IntPtr) _Iosbase + 24) = 0;
      \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    int _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY05D arrayTypeBy05D;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy05D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02EAOCLKAK\u0040ld\u003F\u0024AA\u0040, _Flags), __arglist (_Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    uint _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY05D arrayTypeBy05D;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy05D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02BDDLJJBK\u0040lu\u003F\u0024AA\u0040, _Flags), __arglist ((int) _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    long _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02HIKPPMOK\u0040Ld\u003F\u0024AA\u0040, _Flags), __arglist (_Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    ulong _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02CLHGNPPK\u0040Lu\u003F\u0024AA\u0040, _Flags), __arglist ((long) _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    double _Val)
  {
    int num1 = *(int*) ((IntPtr) _Iosbase + 20);
    int num2;
    int num3;
    if (num1 <= 0 && (*(int*) ((IntPtr) _Iosbase + 16) & 8192) == 0)
    {
      num2 = 6;
    }
    else
    {
      num2 = num1;
      if (36 < num2)
      {
        num3 = 36;
        goto label_5;
      }
    }
    num3 = num2;
label_5:
    int _Trailing = num2 - num3;
    uint _Beforepoint = 0;
    uint _Afterpoint = 0;
    int num4 = *(int*) ((IntPtr) _Iosbase + 16);
    if ((num4 & 12288) == 8192)
    {
      bool flag = _Val < 0.0;
      if (flag)
        _Val = -_Val;
      if (1E+35 <= _Val)
      {
        while (_Beforepoint < 5000U)
        {
          _Val /= 10000000000.0;
          _Beforepoint += 10U;
          if (1E+35 > _Val)
            break;
        }
      }
      if (0.0 < _Val && 10 <= _Trailing)
      {
        while (_Val <= 1E-35 && _Afterpoint < 5000U)
        {
          _Val *= 10000000000.0;
          _Trailing -= 10;
          _Afterpoint += 10U;
          if (10 > _Trailing)
            break;
        }
      }
      if (flag)
        _Val = -_Val;
    }
    int _Flags = num4;
    \u0024ArrayType\u0024\u0024\u0024BY0GM\u0040D arrayTypeBy0GmD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Fput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0GmD, _Beforepoint, _Afterpoint, (uint) _Trailing, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0GmD, 108U, \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte) 0, _Flags), __arglist (num3, _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    double _Val)
  {
    int num1 = *(int*) ((IntPtr) _Iosbase + 20);
    int num2;
    int num3;
    if (num1 <= 0 && (*(int*) ((IntPtr) _Iosbase + 16) & 8192) == 0)
    {
      num2 = 6;
    }
    else
    {
      num2 = num1;
      if (36 < num2)
      {
        num3 = 36;
        goto label_5;
      }
    }
    num3 = num2;
label_5:
    int _Trailing = num2 - num3;
    uint _Beforepoint = 0;
    uint _Afterpoint = 0;
    int num4 = *(int*) ((IntPtr) _Iosbase + 16);
    if ((num4 & 12288) == 8192)
    {
      bool flag = _Val < 0.0;
      if (flag)
        _Val = -_Val;
      if (1E+35 <= _Val)
      {
        while (_Beforepoint < 5000U)
        {
          _Val /= 10000000000.0;
          _Beforepoint += 10U;
          if (1E+35 > _Val)
            break;
        }
      }
      if (0.0 < _Val && 10 <= _Trailing)
      {
        while (_Val <= 1E-35 && _Afterpoint < 5000U)
        {
          _Val *= 10000000000.0;
          _Trailing -= 10;
          _Afterpoint += 10U;
          if (10 > _Trailing)
            break;
        }
      }
      if (flag)
        _Val = -_Val;
    }
    int _Flags = num4;
    \u0024ArrayType\u0024\u0024\u0024BY0GM\u0040D arrayTypeBy0GmD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Fput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0GmD, _Beforepoint, _Afterpoint, (uint) _Trailing, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0GmD, 108U, \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte) 76, _Flags), __arglist (num3, _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    void* _Val)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02BBAHNLBA\u0040\u003F\u0024CFp\u003F\u0024AA\u0040, __arglist ((IntPtr) _Val)));
    return obj1;
  }

  internal static unsafe numpunct\u003Cchar\u003E* std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] numpunct\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Enumpunct\u003Cchar\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      numpunct\u003Cchar\u003E* numpunctCharPtr1 = (numpunct\u003Cchar\u003E*) \u003CModule\u003E.@new(24U);
      numpunct\u003Cchar\u003E* numpunctCharPtr2;
      // ISSUE: fault handler
      try
      {
        numpunctCharPtr2 = (IntPtr) numpunctCharPtr1 == IntPtr.Zero ? (numpunct\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bctor\u007D(numpunctCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numpunctCharPtr1);
      }
      *(int*) _Ppf = (int) numpunctCharPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D(
    [In] numpunct\u003Cchar\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe sbyte std\u002Enumpunct\u003Cchar\u003E\u002Edo_decimal_point(
    [In] numpunct\u003Cchar\u003E* obj0)
  {
    return *(sbyte*) ((IntPtr) obj0 + 12);
  }

  internal static unsafe sbyte std\u002Enumpunct\u003Cchar\u003E\u002Edo_thousands_sep(
    [In] numpunct\u003Cchar\u003E* obj0)
  {
    return *(sbyte*) ((IntPtr) obj0 + 13);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cchar\u003E\u002Edo_grouping(
    [In] numpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cchar\u003E\u002Edo_falsename(
    [In] numpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 16));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cchar\u003E\u002Edo_truename(
    [In] numpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 20));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe codecvt\u003Cchar\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cchar\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cchar\u002Cchar\u002Cint\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040DDH\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* traitsCharVecDelDtor = (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) traitsCharVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsCharVecDelDtor);
      return (void*) traitsCharVecDelDtor;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enumpunct\u003Cchar\u003E\u002E__vecDelDtor(
    [In] numpunct\u003Cchar\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      numpunct\u003Cchar\u003E* numpunctCharPtr = (numpunct\u003Cchar\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24U, *(int*) numpunctCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) numpunctCharPtr);
      return (void*) numpunctCharPtr;
    }
    \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe int std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esbumpc(
    [In] basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gnavail(obj0))
      return (int) (byte) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Gninc(obj0);
    basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 20))((IntPtr) stdCharTraitsCharPtr);
  }

  internal static unsafe num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe int std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Ac,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Last,
    int _Basefield,
    locale* _Loc)
  {
    numpunct\u003Cchar\u003E* numpunctCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_Loc);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Egrouping(numpunctCharPtr, &stdAllocatorChar1);
    int traitsCharGetifld;
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      sbyte num1 = ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) != 0 ? \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Ethousands_sep(numpunctCharPtr) : (sbyte) 0;
      sbyte* numPtr1 = _Ac;
      if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
      {
        if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 43)
        {
          *_Ac = (sbyte) 43;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
        else if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 45)
        {
          *_Ac = (sbyte) 45;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
      }
      _Basefield &= 3584;
      int num2;
      int num3;
      int num4;
      switch (_Basefield)
      {
        case 0:
          num4 = 0;
          break;
        case 1024:
          num2 = 8;
          goto label_13;
        case 2048:
          num3 = 16;
          goto label_12;
        default:
          num4 = 10;
          break;
      }
      num3 = num4;
label_12:
      num2 = num3;
label_13:
      traitsCharGetifld = num2;
      bool _Ch = false;
      bool flag = false;
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 48)
      {
        _Ch = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) && (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 120 || \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 88) && (num2 == 0 || num2 == 16))
        {
          traitsCharGetifld = 16;
          _Ch = false;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          goto label_22;
        }
        else if (num2 == 0)
          traitsCharGetifld = 8;
        else
          goto label_19;
      }
      if (traitsCharGetifld == 0)
        goto label_24;
label_19:
      int num5;
      if (traitsCharGetifld != 10)
      {
        if (traitsCharGetifld == 8)
        {
          num5 = 8;
          goto label_23;
        }
      }
      else
        goto label_24;
label_22:
      num5 = 22;
label_23:
      int num6 = num5;
      goto label_25;
label_24:
      num6 = 10;
label_25:
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) _Ch);
      // ISSUE: fault handler
      try
      {
        uint _Off = 0;
        sbyte* numPtr2 = _Ac + 31;
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
        {
          num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* __unnamed001 = (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
          do
          {
            sbyte num7 = \u003CModule\u003E.std\u002E_Maklocbyte\u003Cchar\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First), (_Cvtvec*) __unnamed001);
            *numPtr1 = num7;
            if ((IntPtr) \u003CModule\u003E.memchr((void*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BH\u0040HHDGIIFB\u00400123456789abcdefABCDEF\u003F\u0024AA\u0040, (int) num7, (uint) num6) != IntPtr.Zero)
            {
              if ((flag || *numPtr1 != (sbyte) 48) && numPtr1 < numPtr2)
              {
                ++numPtr1;
                flag = true;
              }
              _Ch = true;
              if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
              {
                sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                int num8 = (int) *numPtr3 + 1;
                *numPtr3 = (sbyte) num8;
              }
            }
            else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && num1 != (sbyte) 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) num1)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
              ++_Off;
            }
            else
              break;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
          while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last));
          if (_Off != 0U)
          {
            if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
              ++_Off;
            else
              _Ch = false;
          }
        }
        sbyte* numPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar1);
        if (_Ch)
        {
          while (0U < _Off && *numPtr4 != sbyte.MaxValue)
          {
            --_Off;
            if (0U < _Off)
            {
              sbyte* numPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
              if ((int) *numPtr4 != (int) *numPtr5)
                goto label_50;
            }
            if (0U == _Off)
            {
              sbyte* numPtr6 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
              if ((int) *numPtr4 < (int) *numPtr6)
                goto label_50;
            }
            sbyte* numPtr7 = numPtr4 + 1;
            if ((sbyte) 0 < *numPtr7)
              numPtr4 = numPtr7;
          }
          if (!flag)
          {
            *numPtr1 = (sbyte) 48;
            ++numPtr1;
            goto label_51;
          }
          else
            goto label_51;
        }
label_50:
        numPtr1 = _Ac;
label_51:
        *numPtr1 = (sbyte) 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return traitsCharGetifld;
  }

  internal static unsafe int std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(
    [In] num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Ac,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Last,
    locale* _Loc)
  {
    numpunct\u003Cchar\u003E* numpunctCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_Loc);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Egrouping(numpunctCharPtr, &stdAllocatorChar1);
    int traitsCharGetffld;
    // ISSUE: fault handler
    try
    {
      sbyte* numPtr1 = _Ac;
      bool flag1 = false;
      if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
      {
        if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 43)
        {
          *_Ac = (sbyte) 43;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
        else if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 45)
        {
          *_Ac = (sbyte) 45;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
      }
      bool flag2 = false;
      int num1 = 0;
      traitsCharGetffld = 0;
      sbyte num2 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
      if (num2 != sbyte.MaxValue && num2 > (sbyte) 0)
      {
        sbyte num3 = \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Ethousands_sep(numpunctCharPtr);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) 0);
        // ISSUE: fault handler
        try
        {
          uint _Off = 0;
          if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
          {
            do
            {
              if ((sbyte) 48 <= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (sbyte) 57)
              {
                flag2 = true;
                if (36 <= num1)
                  ++traitsCharGetffld;
                else if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) != (sbyte) 48 || num1 != 0)
                {
                  *numPtr1 = \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First);
                  ++numPtr1;
                  ++num1;
                }
                if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
                {
                  sbyte* numPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  int num4 = (int) *numPtr2 + 1;
                  *numPtr2 = (sbyte) num4;
                }
              }
              else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && num3 != (sbyte) 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) num3)
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
                ++_Off;
              }
              else
                break;
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            }
            while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last));
            if (_Off != 0U)
            {
              if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
                ++_Off;
              else
                flag1 = true;
            }
          }
          sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          if (!flag1)
          {
            while (0U < _Off)
            {
              if (*numPtr3 != sbyte.MaxValue)
              {
                --_Off;
                if (0U < _Off)
                {
                  sbyte* numPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  if ((int) *numPtr3 != (int) *numPtr4)
                    goto label_32;
                }
                if (0U == _Off)
                {
                  sbyte* numPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  if ((int) *numPtr3 < (int) *numPtr5)
                    goto label_32;
                }
                if ((sbyte) 0 < numPtr3[1])
                {
                  ++numPtr3;
                  continue;
                }
                continue;
label_32:
                flag1 = true;
                break;
              }
              break;
            }
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      else if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
      {
        while ((sbyte) 48 <= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (sbyte) 57)
        {
          if (36 <= num1)
            ++traitsCharGetffld;
          else if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) != (sbyte) 48 || num1 != 0)
          {
            *numPtr1 = \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First);
            ++numPtr1;
            ++num1;
          }
          flag2 = true;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
            break;
        }
      }
      else
        goto label_44;
      if (flag2 && num1 == 0)
      {
        *numPtr1 = (sbyte) 48;
        ++numPtr1;
      }
label_44:
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Edecimal_point(numpunctCharPtr))
      {
        lconv* lconvPtr = \u003CModule\u003E.localeconv();
        *numPtr1 = *(sbyte*) *(int*) lconvPtr;
        ++numPtr1;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
      if (num1 == 0)
      {
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
        {
          while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 48)
          {
            --traitsCharGetffld;
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
              break;
          }
        }
        if (traitsCharGetffld < 0)
        {
          *numPtr1 = (sbyte) 48;
          ++numPtr1;
          ++traitsCharGetffld;
        }
      }
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
      {
        while ((sbyte) 48 <= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (sbyte) 57)
        {
          if (num1 < 36)
          {
            *numPtr1 = \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First);
            ++numPtr1;
            ++num1;
          }
          flag2 = true;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
            break;
        }
      }
      if (flag2 && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) && (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 101 || \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 69))
      {
        *numPtr1 = (sbyte) 101;
        ++numPtr1;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        flag2 = false;
        int num5 = 0;
        if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
        {
          if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 43)
          {
            *numPtr1 = (sbyte) 43;
            ++numPtr1;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
          else if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 45)
          {
            *numPtr1 = (sbyte) 45;
            ++numPtr1;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
        }
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
        {
          while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 48)
          {
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
              break;
          }
          if (flag2)
          {
            *numPtr1 = (sbyte) 48;
            ++numPtr1;
          }
        }
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
        {
          while ((sbyte) 48 <= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (sbyte) 57)
          {
            if (num5 < 8)
            {
              *numPtr1 = \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First);
              ++numPtr1;
              ++num5;
            }
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
              break;
          }
        }
      }
      if (flag1 || !flag2)
        numPtr1 = _Ac;
      *numPtr1 = (sbyte) 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return traitsCharGetffld;
  }

  internal static unsafe num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe sbyte* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Fmt,
    sbyte _Spec,
    int _Flags)
  {
    *_Fmt = (sbyte) 37;
    sbyte* numPtr1 = _Fmt + 1;
    if ((_Flags & 32) != 0)
    {
      *numPtr1 = (sbyte) 43;
      ++numPtr1;
    }
    if ((_Flags & 16) != 0)
    {
      *numPtr1 = (sbyte) 35;
      ++numPtr1;
    }
    *numPtr1 = (sbyte) 46;
    sbyte* numPtr2 = numPtr1 + 1;
    *numPtr2 = (sbyte) 42;
    sbyte* numPtr3 = numPtr2 + 1;
    if (_Spec != (sbyte) 0)
    {
      *numPtr3 = _Spec;
      ++numPtr3;
    }
    sbyte num1;
    int num2;
    switch (_Flags & 12288)
    {
      case 4096:
        num2 = 101;
        break;
      case 8192:
        num1 = (sbyte) 102;
        goto label_11;
      default:
        num2 = 103;
        break;
    }
    num1 = (sbyte) num2;
label_11:
    *numPtr3 = num1;
    numPtr3[1] = (sbyte) 0;
    return _Fmt;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Fput(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    sbyte* _Buf,
    uint _Beforepoint,
    uint _Afterpoint,
    uint _Trailing,
    uint _Count)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cchar\u003E* numpunctCharPtr;
    // ISSUE: fault handler
    try
    {
      numpunctCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Egrouping(numpunctCharPtr, &stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      sbyte _Kseparator = \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Ethousands_sep(numpunctCharPtr);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2);
      // ISSUE: fault handler
      try
      {
        int num1;
        switch (*_Buf)
        {
          case 43:
          case 45:
            num1 = 1;
            break;
          default:
            num1 = 0;
            break;
        }
        lconv* lconvPtr = \u003CModule\u003E.localeconv();
        \u0024ArrayType\u0024\u0024\u0024BY02D arrayTypeBy02D;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy02D = *(sbyte*) *(int*) lconvPtr;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 1) = (sbyte) 101;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 2) = (sbyte) 0;
        sbyte* numPtr1 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, 101, _Count);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        sbyte* numPtr2 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, (int) ^(sbyte&) ref arrayTypeBy02D, _Count);
        if ((IntPtr) numPtr2 == IntPtr.Zero)
          _Trailing = 0U;
        sbyte num2 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
        if (num2 != sbyte.MaxValue && (sbyte) 0 < num2)
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Buf, _Count);
          if ((IntPtr) numPtr1 == IntPtr.Zero)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Trailing, (sbyte) 48);
          }
          else
          {
            if ((IntPtr) numPtr2 == IntPtr.Zero)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Beforepoint, (sbyte) 48);
              _Beforepoint = 0U;
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, (uint) ((IntPtr) numPtr1 - (IntPtr) _Buf), _Trailing, (sbyte) 48);
          }
          if ((IntPtr) numPtr2 == IntPtr.Zero)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Beforepoint, (sbyte) 48);
          }
          else
          {
            uint _Off = (uint) ((IntPtr) numPtr2 - (IntPtr) _Buf);
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off + 1U, _Afterpoint, (sbyte) 48);
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off, _Beforepoint, (sbyte) 48);
            _Afterpoint = 0U;
          }
          _Beforepoint = 0U;
          sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          uint _Off1 = \u003CModule\u003E.strcspn(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, 0U), (sbyte*) &arrayTypeBy02D);
          sbyte num3 = *numPtr3;
          if (num3 != sbyte.MaxValue)
          {
            while ((sbyte) 0 < num3 && (uint) num3 < _Off1 - (uint) num1)
            {
              _Off1 -= (uint) num3;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off1, 1U, (sbyte) 0);
              if ((sbyte) 0 < numPtr3[1])
                ++numPtr3;
              num3 = *numPtr3;
              if (num3 == sbyte.MaxValue)
                break;
            }
          }
          _Buf = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, 0U);
          _Trailing = 0U;
          _Count = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar2);
        }
        uint num4 = _Beforepoint + _Afterpoint + _Trailing + _Count;
        uint _Count1 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= 0 || (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= num4 ? 0U : (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) - num4;
        uint _Count2 = _Count1;
        switch (\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 448)
        {
          case 64:
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            sbyte* numPtr4 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, (int) ^(sbyte&) ref arrayTypeBy02D, _Count);
            if ((IntPtr) numPtr4 != IntPtr.Zero)
            {
              uint num5 = (uint) ((IntPtr) numPtr4 - (IntPtr) _Buf + 1);
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &stdCharTraitsChar1, _Dest, _Buf, num5 - 1U, _Kseparator);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr1, 12);
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar2, _Dest, (sbyte) 48, _Beforepoint);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr2, 12);
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr3 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar3, _Dest, \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Edecimal_point(numpunctCharPtr), 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr3, 12);
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar4;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr4 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar4, _Dest, (sbyte) 48, _Afterpoint);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr4, 12);
              _Buf = (sbyte*) ((int) num5 + (IntPtr) _Buf);
              _Count -= num5;
            }
            sbyte* numPtr5 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, 101, _Count);
            if ((IntPtr) numPtr5 != IntPtr.Zero)
            {
              uint num6 = (uint) ((IntPtr) numPtr5 - (IntPtr) _Buf + 1);
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar5;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr5 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &stdCharTraitsChar5, _Dest, _Buf, num6 - 1U, _Kseparator);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr5, 12);
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar6;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr6 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar6, _Dest, (sbyte) 48, _Trailing);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr6, 12);
              _Trailing = 0U;
              sbyte* _Ptr = (\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 4) == 0 ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KGKMHCOC\u0040e\u003F\u0024AA\u0040 : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01DDCIFGEA\u0040E\u003F\u0024AA\u0040;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar7;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr7 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &stdCharTraitsChar7, _Dest, _Ptr, 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr7, 12);
              _Buf = (sbyte*) ((int) num6 + (IntPtr) _Buf);
              _Count -= num6;
            }
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar8;
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr8 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &stdCharTraitsChar8, _Dest, _Buf, _Count, _Kseparator);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr8, 12);
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar9;
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr9 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar9, _Dest, (sbyte) 48, _Trailing);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr9, 12);
            *(int*) ((IntPtr) _Iosbase + 24) = 0;
            \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count2);
            break;
          case 256:
            if (0U < (uint) num1)
            {
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar10;
              ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr10 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &stdCharTraitsChar10, _Dest, _Buf, 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr10, 12);
              ++_Buf;
              --_Count;
            }
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar11;
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr11 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar11, _Dest, _Fill, _Count1);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr11, 12);
            _Count2 = 0U;
            goto case 64;
          default:
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar12;
            ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr12 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar12, _Dest, _Fill, _Count1);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr12, 12);
            _Count2 = 0U;
            goto case 64;
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe sbyte* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Fmt,
    sbyte* _Spec,
    int _Flags)
  {
    *_Fmt = (sbyte) 37;
    sbyte* numPtr1 = _Fmt + 1;
    if ((_Flags & 32) != 0)
    {
      *numPtr1 = (sbyte) 43;
      ++numPtr1;
    }
    if ((_Flags & 8) != 0)
    {
      *numPtr1 = (sbyte) 35;
      ++numPtr1;
    }
    sbyte num1 = *_Spec;
    sbyte* numPtr2;
    if (num1 != (sbyte) 76)
    {
      *numPtr1 = num1;
      numPtr2 = numPtr1 + 1;
    }
    else
    {
      *numPtr1 = (sbyte) 73;
      sbyte* numPtr3 = numPtr1 + 1;
      *numPtr3 = (sbyte) 54;
      sbyte* numPtr4 = numPtr3 + 1;
      *numPtr4 = (sbyte) 52;
      numPtr2 = numPtr4 + 1;
    }
    sbyte num2;
    sbyte num3;
    switch (_Flags & 3584)
    {
      case 1024:
        num2 = (sbyte) 111;
        goto label_12;
      case 2048:
        num3 = (sbyte) (~(_Flags << 3) & 32 | 88);
        break;
      default:
        num3 = _Spec[1];
        break;
    }
    num2 = num3;
label_12:
    *numPtr2 = num2;
    numPtr2[1] = (sbyte) 0;
    return _Fmt;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Iput(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    sbyte _Fill,
    sbyte* _Buf,
    uint _Count)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cchar\u003E* numpunctCharPtr;
    // ISSUE: fault handler
    try
    {
      numpunctCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Egrouping(numpunctCharPtr, &stdAllocatorChar);
    // ISSUE: fault handler
    try
    {
      int num1;
      int _Count1;
      switch (*_Buf)
      {
        case 43:
        case 45:
          _Count1 = 1;
          goto label_10;
        case 48:
          switch (_Buf[1])
          {
            case 88:
            case 120:
              num1 = 2;
              break;
            default:
              goto label_7;
          }
          break;
        default:
label_7:
          num1 = 0;
          break;
      }
      _Count1 = num1;
label_10:
      sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
      sbyte num2 = *numPtr1;
      if (num2 != sbyte.MaxValue && (sbyte) 0 < num2)
      {
        sbyte* numPtr2 = numPtr1;
        uint index = _Count;
        sbyte num3 = *numPtr2;
        if (num3 != sbyte.MaxValue)
        {
          while ((sbyte) 0 < num3 && (uint) num3 < index - (uint) _Count1)
          {
            index -= (uint) num3;
            uint num4 = (uint) ((int) _Count - (int) index + 1);
            \u003CModule\u003E.memmove_s((void*) (_Buf + (int) index + 1), num4, (void*) (_Buf + (int) index), num4);
            _Buf[(int) index] = (sbyte) 0;
            ++_Count;
            if ((sbyte) 0 < numPtr2[1])
              ++numPtr2;
            num3 = *numPtr2;
            if (num3 == sbyte.MaxValue)
              break;
          }
        }
      }
      int num5 = *(int*) ((IntPtr) _Iosbase + 24);
      uint _Count2 = num5 <= 0 || (uint) num5 <= _Count ? 0U : (uint) num5 - _Count;
      uint _Count3 = _Count2;
      switch (*(int*) ((IntPtr) _Iosbase + 16) & 448)
      {
        case 64:
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &stdCharTraitsChar1, _Dest, _Buf, _Count, \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002Ethousands_sep(numpunctCharPtr));
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr1, 12);
          *(int*) ((IntPtr) _Iosbase + 24) = 0;
          \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count3);
          break;
        case 256:
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &stdCharTraitsChar2, _Dest, _Buf, (uint) _Count1);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr2, 12);
          _Buf = (sbyte*) (_Count1 + (IntPtr) _Buf);
          _Count -= (uint) _Count1;
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3;
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr3 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar3, _Dest, _Fill, _Count2);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr3, 12);
          _Count3 = 0U;
          goto case 64;
        default:
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar4;
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr4 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar4, _Dest, _Fill, _Count2);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr4, 12);
          _Count3 = 0U;
          goto case 64;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, *_Ptr);
        --_Count;
        ++_Ptr;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    sbyte _Ch,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, _Ch);
        --_Count;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cchar\u003E\u002Efalsename(
    [In] numpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cchar\u003E* numpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 16))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) numpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cchar\u003E\u002Etruename(
    [In] numpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cchar\u003E* numpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 20))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) numpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe numpunct\u003Cchar\u003E* std\u002Enumpunct\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] numpunct\u003Cchar\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E_Init(obj0, &locinfo);
          numpunct\u003Cchar\u003E* numpunctCharPtr = (numpunct\u003Cchar\u003E*) ((IntPtr) obj0 + 13);
          if (*(sbyte*) numpunctCharPtr == (sbyte) 0)
          {
            _Cvtvec cvtvec;
            \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(&locinfo, &cvtvec);
            *(sbyte*) numpunctCharPtr = (sbyte) 44;
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Enumpunct\u003Cchar\u003E\u002E_Init(
    [In] numpunct\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) ((IntPtr) obj0 + 20) = 0;
    try
    {
      _Cvtvec cvtvec1;
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) *(int*) ((IntPtr) lconvPtr + 8), (sbyte*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec1));
      _Cvtvec cvtvec2;
      *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05LAPONLG\u0040false\u003F\u0024AA\u0040, (sbyte*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec2));
      _Cvtvec cvtvec3;
      *(int*) ((IntPtr) obj0 + 20) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04LOAJBDKD\u0040true\u003F\u0024AA\u0040, (sbyte*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec3));
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    \u003CModule\u003E._Getcvt();
    *(sbyte*) ((IntPtr) obj0 + 12) = *(sbyte*) *(int*) lconvPtr;
    \u003CModule\u003E._Getcvt();
    *(sbyte*) ((IntPtr) obj0 + 13) = *(sbyte*) *(int*) ((IntPtr) lconvPtr + 4);
  }

  internal static unsafe void std\u002Enumpunct\u003Cchar\u003E\u002E_Tidy(
    [In] numpunct\u003Cchar\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 20));
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putc(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, *_Ptr);
        --_Count;
        ++_Ptr;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(
    [In] num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count,
    sbyte _Kseparator)
  {
    while (true)
    {
      sbyte* numPtr = (sbyte*) \u003CModule\u003E.memchr((void*) _Ptr, 0, _Count);
      uint _Count1 = (IntPtr) numPtr == IntPtr.Zero ? _Count : (uint) ((IntPtr) numPtr - (IntPtr) _Ptr);
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &stdCharTraitsChar1, _Dest, _Ptr, _Count1);
      // ISSUE: cpblk instruction
      __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr1, 12);
      _Ptr = (sbyte*) ((int) _Count1 + (IntPtr) _Ptr);
      _Count -= _Count1;
      if (_Count != 0U)
      {
        if (_Kseparator != (sbyte) 0)
        {
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
          ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &stdCharTraitsChar2, _Dest, _Kseparator, 1U);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr2, 12);
        }
        ++_Ptr;
        --_Count;
      }
      else
        break;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe sbyte std\u002Enumpunct\u003Cchar\u003E\u002Edecimal_point(
    [In] numpunct\u003Cchar\u003E* obj0)
  {
    numpunct\u003Cchar\u003E* numpunctCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte (IntPtr)>) *(int*) (*(int*) numpunctCharPtr + 4))((IntPtr) numpunctCharPtr);
  }

  internal static unsafe sbyte std\u002Enumpunct\u003Cchar\u003E\u002Ethousands_sep(
    [In] numpunct\u003Cchar\u003E* obj0)
  {
    numpunct\u003Cchar\u003E* numpunctCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte (IntPtr)>) *(int*) (*(int*) numpunctCharPtr + 8))((IntPtr) numpunctCharPtr);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cchar\u003E\u002Egrouping(
    [In] numpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cchar\u003E* numpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 12))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) numpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe sbyte std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    if (*(byte*) ((IntPtr) obj0 + 8) == (byte) 0)
    {
      int num = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    return *(sbyte*) ((IntPtr) obj0 + 9);
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Inc(obj0);
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    sbyte _Right)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num == 0U || -1 == \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esputc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) num, _Right))
      *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) 1;
    return obj0;
  }

  internal static unsafe void std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Inc(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num != 0U && -1 != \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esbumpc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) num))
    {
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 4) = 0;
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    }
  }

  internal static unsafe sbyte std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 != 0U)
    {
      int num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Esgetc((basic_streambuf\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) num1);
      if (-1 != num2)
      {
        *(sbyte*) ((IntPtr) obj0 + 9) = (sbyte) num2;
        goto label_4;
      }
    }
    *(int*) ((IntPtr) obj0 + 4) = 0;
label_4:
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    return *(sbyte*) ((IntPtr) obj0 + 9);
  }

  internal static void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_get\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* stdCharTraitsChar = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) stdCharTraitsChar == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          stdCharTraitsChar = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          stdCharTraitsChar = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (num_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) stdCharTraitsChar;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_put\u003Cchar\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (num_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe numpunct\u003Cchar\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cchar\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enumpunct\u003Cchar\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (numpunct\u003Cchar\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe int std\u002E_Getloctxt\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Last,
    uint _Numfields,
    sbyte* _Ptr)
  {
    sbyte num1 = *_Ptr;
    if (num1 != (sbyte) 0)
    {
      sbyte num2 = num1;
      sbyte* numPtr = _Ptr;
      sbyte num3;
      do
      {
        if ((int) num2 == (int) num1)
          ++_Numfields;
        ++numPtr;
        num3 = *numPtr;
        num2 = num3;
      }
      while (num3 != (sbyte) 0);
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, _Numfields, (sbyte) 0);
    int num4;
    // ISSUE: fault handler
    try
    {
      num4 = -2;
      uint num5 = 1;
      while (true)
      {
        bool flag = false;
        uint index = 0;
        uint _Off = 0;
        if (0U < _Numfields)
        {
          do
          {
            sbyte num6 = *(sbyte*) ((int) index + (IntPtr) _Ptr);
            if (num6 != (sbyte) 0)
            {
              sbyte num7 = *_Ptr;
              while ((int) num6 != (int) num7)
              {
                ++index;
                num6 = *(sbyte*) ((int) index + (IntPtr) _Ptr);
                if (num6 == (sbyte) 0)
                  break;
              }
            }
            if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) != (sbyte) 0)
            {
              index = (uint) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) + index;
            }
            else
            {
              index = num5 + index;
              sbyte num8 = _Ptr[(int) index];
              if ((int) num8 != (int) *_Ptr && num8 != (sbyte) 0)
              {
                if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) && (int) _Ptr[(int) index] == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First))
                {
                  flag = true;
                }
                else
                {
                  uint num9 = num5 >= (uint) sbyte.MaxValue ? (uint) sbyte.MaxValue : num5;
                  *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) = (sbyte) num9;
                }
              }
              else
              {
                uint num10 = num5 >= (uint) sbyte.MaxValue ? (uint) sbyte.MaxValue : num5;
                *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) = (sbyte) num10;
                num4 = (int) _Off;
              }
            }
            ++_Off;
          }
          while (_Off < _Numfields);
          if (flag)
          {
            if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
            {
              ++num5;
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Inc(_First);
              num4 = -1;
            }
            else
              break;
          }
          else
            break;
        }
        else
          break;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return num4;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(_Left, _Right);
  }

  internal static unsafe sbyte std\u002E_Maklocchr\u003Cchar\u003E(
    sbyte _Byte,
    sbyte* __unnamed001,
    _Cvtvec* __unnamed002)
  {
    return _Byte;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Right)
  {
    return !\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(_Left, _Right);
  }

  internal static unsafe sbyte std\u002E_Maklocbyte\u003Cchar\u003E(
    sbyte _Char,
    _Cvtvec* __unnamed001)
  {
    return _Char;
  }

  internal static unsafe sbyte* std\u002E_Maklocstr\u003Cchar\u003E(
    sbyte* _Ptr,
    sbyte* __unnamed001,
    _Cvtvec* __unnamed002)
  {
    uint num = \u003CModule\u003E.strlen(_Ptr) + 1U;
    sbyte* numPtr1 = (sbyte*) \u003CModule\u003E.new\u005B\u005D(num);
    sbyte* numPtr2 = numPtr1;
    if (0U < num)
    {
      do
      {
        *numPtr2 = *_Ptr;
        --num;
        ++numPtr2;
        ++_Ptr;
      }
      while (num > 0U);
    }
    return numPtr1;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Right)
  {
    if (*(byte*) ((IntPtr) obj0 + 8) == (byte) 0)
    {
      int num1 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    if (*(byte*) ((IntPtr) _Right + 8) == (byte) 0)
    {
      int num2 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Peek(_Right);
    }
    uint num3 = (uint) *(int*) ((IntPtr) obj0 + 4);
    return num3 == 0U && *(int*) ((IntPtr) _Right + 4) == 0 || num3 != 0U && *(int*) ((IntPtr) _Right + 4) != 0;
  }

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Enum_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
  }

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Enum_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0x78d0d095\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002Edo_falsename);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040D\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enumpunct\u003Cchar\u003E\u002Edo_truename);
  }

  internal static unsafe void delete(void* _param0, void* _param1)
  {
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Locimp\u002E\u007Bctor\u007D(
    [In] locale._Locimp* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Transparent)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = 1;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7_Locimp\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      *(int*) ((IntPtr) obj0 + 12) = 0;
      *(int*) ((IntPtr) obj0 + 16) = 0;
      *(sbyte*) ((IntPtr) obj0 + 20) = (sbyte) _Transparent;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 24), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Emessages_base\u002E\u007Bdtor\u007D([In] messages_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void* std\u002Emessages_base\u002E__vecDelDtor(
    [In] messages_base* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      messages_base* messagesBasePtr = (messages_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) messagesBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) messagesBasePtr);
      return (void*) messagesBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Emoney_base\u002E\u007Bdtor\u007D([In] money_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void* std\u002Emoney_base\u002E__vecDelDtor([In] money_base* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_base* moneyBasePtr = (money_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) moneyBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneyBasePtr);
      return (void*) moneyBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002Etime_base\u002E\u007Bdtor\u007D([In] time_base* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe void* std\u002Etime_base\u002E__vecDelDtor([In] time_base* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_base* timeBasePtr = (time_base*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) timeBasePtr, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) timeBasePtr);
      return (void*) timeBasePtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void std\u002E_Fac_node\u002E\u007Bdtor\u007D([In] _Fac_node* obj0)
  {
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(int*) ((IntPtr) obj0 + 4));
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003FA0x7431c98f\u0040_Fac_head\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head = (_Fac_node*) 0;

  internal static unsafe void _Fac_tidy()
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      while ((IntPtr) \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head != IntPtr.Zero)
      {
        _Fac_node* a0x7431c98fFacHead = \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head;
        \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head = (_Fac_node*) *(int*) \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head;
        \u003CModule\u003E.std\u002E_Fac_node\u002E__delDtor(a0x7431c98fFacHead, 1U);
      }
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void* std\u002E_Fac_node\u002E__delDtor([In] _Fac_node* obj0, uint _param1)
  {
    \u003CModule\u003E.std\u002E_Fac_node\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void _Deletegloballocale(void* ptr)
  {
    locale._Locimp* locimpPtr = (locale._Locimp*) *(int*) ptr;
    if ((IntPtr) locimpPtr == IntPtr.Zero)
      return;
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) locimpPtr);
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003FA0x7431c98f\u0040global_locale\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale = (locale._Locimp*) 0;

  internal static unsafe void \u003FA0x7431c98f\u002Etidy_global()
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      \u003CModule\u003E._Deletegloballocale((void*) &\u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale);
      \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale = (locale._Locimp*) 0;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Getgloballocale() => \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale;

  internal static unsafe void std\u002Elocale\u002E_Setgloballocale(void* _param0)
  {
    if (((int) \u003CModule\u003E.\u003FA0x7431c98f\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA & 1) == 0)
    {
      \u003CModule\u003E.\u003FA0x7431c98f\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA |= 1U;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.\u003FA0x7431c98f\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA = false;
      }
      __fault
      {
        \u003CModule\u003E.\u003FA0x7431c98f\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404IA &= 4294967294U;
      }
    }
    if (!\u003CModule\u003E.\u003FA0x7431c98f\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA)
    {
      \u003CModule\u003E.\u003FA0x7431c98f\u002E\u003Fregistered\u0040\u003F1\u003F\u003F_Setgloballocale\u0040locale\u0040std\u0040\u0040CAXPAX\u0040Z\u00404_NA = true;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._Atexit((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003Ftidy_global\u0040\u003FA0x7431c98f\u0040\u0040\u0024\u0024J0YAXXZ);
    }
    \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale = (locale._Locimp*) _param0;
  }

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003FA0x7431c98f\u0040classic_locale\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x7431c98f\u002E\u003F\u003F__F\u003FA0x7431c98f\u0040classic_locale\u0040std\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__F\u003FA0x7431c98f\u0040classic_locale\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&\u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale);

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A = (locale._Locimp*) 0;

  internal static unsafe locale._Locimp** std\u002Elocale\u002E_Locimp\u002E_Clocptr_func() => &\u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA = 0;

  internal static unsafe int* std\u002Elocale\u002Eid\u002E_Id_cnt_func() => &\u003CModule\u003E.\u003F_Id_cnt\u0040id\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0HA;

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ectype\u003Cchar\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ectype\u003Cwchar_t\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe locale.id* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Id_func() => &\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A;

  internal static unsafe locale* std\u002Elocale\u002Eclassic()
  {
    \u003CModule\u003E.std\u002Elocale\u002E_Init();
    return &\u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale;
  }

  internal static unsafe locale* std\u002Elocale\u002Eempty([In] locale* obj0)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Elocale\u002E_Init();
    locale._Locimp* locimpPtr1 = (locale._Locimp*) \u003CModule\u003E.@new(52U);
    // ISSUE: fault handler
    try
    {
      locale._Locimp* locimpPtr2;
      // ISSUE: fault handler
      try
      {
        locimpPtr2 = (IntPtr) locimpPtr1 == IntPtr.Zero ? (locale._Locimp*) 0 : \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E\u007Bctor\u007D(locimpPtr1, true);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) locimpPtr1);
      }
      *(int*) obj0 = (int) locimpPtr2;
      num1 = 1U;
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  internal static unsafe locale._Locimp* std\u002Elocale\u002E_Init()
  {
    locale._Locimp* locimpPtr1 = \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale;
    if ((IntPtr) \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale == IntPtr.Zero)
    {
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        locimpPtr1 = \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale;
        if ((IntPtr) \u003CModule\u003E.\u003FA0x7431c98f\u002Eglobal_locale == IntPtr.Zero)
        {
          locale._Locimp* locimpPtr2 = (locale._Locimp*) \u003CModule\u003E.@new(52U);
          locale._Locimp* locimpPtr3;
          // ISSUE: fault handler
          try
          {
            locimpPtr3 = (IntPtr) locimpPtr2 == IntPtr.Zero ? (locale._Locimp*) 0 : \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E\u007Bctor\u007D(locimpPtr2, false);
          }
          __fault
          {
            \u003CModule\u003E.delete((void*) locimpPtr2);
          }
          locimpPtr1 = locimpPtr3;
          \u003CModule\u003E.std\u002Elocale\u002E_Setgloballocale((void*) locimpPtr3);
          *(int*) ((IntPtr) locimpPtr3 + 16) = 63;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) locimpPtr3 + 24), (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
          \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A = locimpPtr3;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref((locale.facet*) locimpPtr3);
          locale* localePtr1 = &\u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale;
          // ISSUE: fault handler
          try
          {
            locale._Locimp* localeStdQ0PaV123A = \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ref \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale = (int) \u003CModule\u003E.\u003F_Clocptr\u0040_Locimp\u0040locale\u0040std\u0040\u0040\u0024\u0024Q0PAV123\u0040A;
            locale* localePtr2 = &\u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale;
            locale* localePtr3 = &\u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale;
          }
          __fault
          {
            \u003CModule\u003E.delete((void*) localePtr1, (void*) &\u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002Eclassic_locale);
          }
        }
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    return locimpPtr1;
  }

  internal static unsafe void std\u002Elocale\u002Efacet\u002Efacet_Register(locale.facet* _param0)
  {
    if ((IntPtr) \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head == IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._Atexit((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_Fac_tidy\u0040\u0040\u0024\u0024J0YAXXZ);
    }
    _Fac_node* facNodePtr1 = (_Fac_node*) \u003CModule\u003E.@new(8U);
    _Fac_node* facNodePtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) facNodePtr1 != IntPtr.Zero)
      {
        *(int*) facNodePtr1 = (int) \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head;
        *(int*) ((IntPtr) facNodePtr1 + 4) = (int) _param0;
        facNodePtr2 = facNodePtr1;
      }
      else
        facNodePtr2 = (_Fac_node*) 0;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) facNodePtr1);
    }
    \u003CModule\u003E.std\u002E\u003FA0x7431c98f\u002E_Fac_head = facNodePtr2;
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Locimp_dtor(locale._Locimp* _param0)
  {
    bool flag = false;
    int num1 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num1);
        flag = true;
      }
      uint num2 = (uint) *(int*) ((IntPtr) _param0 + 12);
      while (0U < num2)
      {
        --num2;
        int num3 = (int) num2 * 4 + *(int*) ((IntPtr) _param0 + 8);
        if (*(int*) num3 != 0)
        {
          locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(int*) num3);
          if ((IntPtr) facetPtr1 != IntPtr.Zero)
          {
            locale.facet* facetPtr2 = facetPtr1;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(int*) *(int*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
          }
        }
      }
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) _param0 + 8));
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num1);
    }
  }

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_ctor(
    _Locinfo* _param0,
    sbyte* _param1)
  {
    sbyte* numPtr = \u003CModule\u003E.setlocale(0, (sbyte*) 0);
    sbyte* _Ptr1 = (IntPtr) numPtr != IntPtr.Zero ? numPtr : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60), _Ptr1);
    sbyte* _Ptr2;
    if ((IntPtr) _param1 != IntPtr.Zero)
    {
      _param1 = \u003CModule\u003E.setlocale(0, _param1);
      if ((IntPtr) _param1 != IntPtr.Zero)
      {
        _Ptr2 = _param1;
        goto label_4;
      }
    }
    _Ptr2 = (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01NBENCBCI\u0040\u003F\u0024CK\u003F\u0024AA\u0040;
label_4:
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 88), _Ptr2);
  }

  internal static unsafe void std\u002E_Locinfo\u002E_Locinfo_dtor(_Locinfo* _param0)
  {
    if (0U >= (uint) *(int*) ((IntPtr) _param0 + 80))
      return;
    \u003CModule\u003E.setlocale(0, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) _param0 + 60)));
  }

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4messages_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emessages_base\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4money_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_base\u002E__vecDelDtor);
  }

  internal static unsafe void \u003FA0x7431c98f\u002E\u003F\u003F__E\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4time_base\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_base\u002E__vecDelDtor);
  }

  internal static unsafe void std\u002E_Timevec\u002E\u007Bdtor\u007D([In] _Timevec* obj0) => \u003CModule\u003E.free((void*) *(int*) obj0);

  internal static unsafe _Timevec* std\u002E_Locinfo\u002E_Gettnames(
    [In] _Locinfo* obj0,
    [In] _Timevec* obj1)
  {
    uint num1 = 0;
    *(int*) obj1 = (int) \u003CModule\u003E._Gettnames();
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe sbyte* std\u002E_Locinfo\u002E_Getdays([In] _Locinfo* obj0)
  {
    sbyte* _Ptr = \u003CModule\u003E._Getdays();
    if ((IntPtr) _Ptr != IntPtr.Zero)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4), _Ptr);
      \u003CModule\u003E.free((void*) _Ptr);
    }
    return *(int*) ((IntPtr) obj0 + 24) != 0 ? \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 4)) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0FG\u0040EOHGAEB\u0040\u003F3Sun\u003F3Sunday\u003F3Mon\u003F3Monday\u003F3Tue\u003F3Tuesd\u0040;
  }

  internal static unsafe sbyte* std\u002E_Locinfo\u002E_Getmonths([In] _Locinfo* obj0)
  {
    sbyte* _Ptr = \u003CModule\u003E._Getmonths();
    if ((IntPtr) _Ptr != IntPtr.Zero)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 32), _Ptr);
      \u003CModule\u003E.free((void*) _Ptr);
    }
    return *(int*) ((IntPtr) obj0 + 52) != 0 ? \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj0 + 32)) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0IH\u0040HPGJLCCK\u0040\u003F3Jan\u003F3January\u003F3Feb\u003F3February\u003F3Mar\u003F3Ma\u0040;
  }

  internal static unsafe int std\u002E_Locinfo\u002E_Getdateorder([In] _Locinfo* obj0) => \u003CModule\u003E._Getdateorder();

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ectype\u003Cchar\u003E\u002Eis(
    [In] ctype\u003Cchar\u003E* obj0,
    short _Maskval,
    sbyte _Ch)
  {
    return (short) ((int) *(short*) ((int) (byte) _Ch * 2 + *(int*) ((IntPtr) obj0 + 16)) & (int) _Maskval) != (short) 0;
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Makexloc(
    _Locinfo* _param0,
    int _param1,
    locale._Locimp* _param2,
    locale* _param3)
  {
    if ((_param1 & 1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        collate\u003Cchar\u003E* collateCharPtr1 = (collate\u003Cchar\u003E*) \u003CModule\u003E.@new(16U);
        collate\u003Cchar\u003E* collateCharPtr2;
        // ISSUE: fault handler
        try
        {
          collateCharPtr2 = (IntPtr) collateCharPtr1 == IntPtr.Zero ? (collate\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Ecollate\u003Cchar\u003E\u002E\u007Bctor\u007D(collateCharPtr1, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) collateCharPtr1);
        }
        uint num = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Locimp_Addfac(_param2, (locale.facet*) collateCharPtr2, num);
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acollate\u003Cchar\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emessages\u003Cchar\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        messages\u003Cchar\u003E* messagesCharPtr1 = (messages\u003Cchar\u003E*) \u003CModule\u003E.@new(8U);
        messages\u003Cchar\u003E* messagesCharPtr2;
        // ISSUE: fault handler
        try
        {
          messagesCharPtr2 = (IntPtr) messagesCharPtr1 == IntPtr.Zero ? (messages\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Emessages\u003Cchar\u003E\u002E\u007Bctor\u007D(messagesCharPtr1, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) messagesCharPtr1);
        }
        uint num = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Locimp_Addfac(_param2, (locale.facet*) messagesCharPtr2, num);
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amessages\u003Cchar\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) stdCharTraitsCharPtr == IntPtr.Zero ? (money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_get\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) stdCharTraitsCharPtr == IntPtr.Zero ? (money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_put\u003Cchar\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        moneypunct\u003Cchar\u002C0\u003E* moneypunctChar0Ptr = (moneypunct\u003Cchar\u002C0\u003E*) \u003CModule\u003E.@new(52U);
        moneypunct\u003Cchar\u002C0\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) moneypunctChar0Ptr == IntPtr.Zero ? (moneypunct\u003Cchar\u002C0\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bctor\u007D(moneypunctChar0Ptr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) moneypunctChar0Ptr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C0\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        moneypunct\u003Cchar\u002C1\u003E* moneypunctChar1Ptr = (moneypunct\u003Cchar\u002C1\u003E*) \u003CModule\u003E.@new(52U);
        moneypunct\u003Cchar\u002C1\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) moneypunctChar1Ptr == IntPtr.Zero ? (moneypunct\u003Cchar\u002C1\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bctor\u007D(moneypunctChar1Ptr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) moneypunctChar1Ptr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C1\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
        time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) stdCharTraitsCharPtr == IntPtr.Zero ? (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_get\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) == 0)
      return;
    if ((IntPtr) _param3 == IntPtr.Zero)
    {
      time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(20U);
      time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* _Pfacet;
      // ISSUE: fault handler
      try
      {
        _Pfacet = (IntPtr) stdCharTraitsCharPtr == IntPtr.Zero ? (time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr, _param0, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr);
      }
      \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    else
      \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_put\u003Cchar\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
  }

  internal static unsafe collate\u003Cchar\u003E* std\u002Ecollate\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] collate\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      _Collvec collvec = \u003CModule\u003E._Getcoll();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref collvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecollate\u003Cchar\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      collate\u003Cchar\u003E* collateCharPtr1 = (collate\u003Cchar\u003E*) \u003CModule\u003E.@new(16U);
      collate\u003Cchar\u003E* collateCharPtr2;
      // ISSUE: fault handler
      try
      {
        collateCharPtr2 = (IntPtr) collateCharPtr1 == IntPtr.Zero ? (collate\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Ecollate\u003Cchar\u003E\u002E\u007Bctor\u007D(collateCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) collateCharPtr1);
      }
      *(int*) _Ppf = (int) collateCharPtr2;
    }
    return 1;
  }

  internal static unsafe void std\u002Ecollate\u003Cchar\u003E\u002E\u007Bdtor\u007D(
    [In] collate\u003Cchar\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecollate\u003Cchar\u003E\u002Edo_compare(
    [In] collate\u003Cchar\u003E* obj0,
    sbyte* _First1,
    sbyte* _Last1,
    sbyte* _First2,
    sbyte* _Last2)
  {
    return \u003CModule\u003E._Strcoll(_First1, _Last1, _First2, _Last2, (_Collvec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Ecollate\u003Cchar\u003E\u002Edo_transform(
    [In] collate\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    sbyte* _First,
    sbyte* _Last)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1);
      num1 = 1U;
      uint _Newsize = (uint) ((IntPtr) _Last - (IntPtr) _First);
      if (0U < _Newsize)
      {
        collate\u003Cchar\u003E* ploc = (collate\u003Cchar\u003E*) ((IntPtr) obj0 + 8);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) ((IntPtr) obj1 + 20);
        uint num2;
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eresize(obj1, _Newsize, (sbyte) 0);
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
          sbyte* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(obj1, &stdAllocatorChar1));
          uint num3 = (uint) *(int*) stdAllocatorCharPtr;
          _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
          _Newsize = \u003CModule\u003E._Strxfrm(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(obj1, &stdAllocatorChar2)), (sbyte*) ((int) num3 + (IntPtr) numPtr), _First, _Last, (_Collvec*) ploc);
          num2 = (uint) *(int*) stdAllocatorCharPtr;
        }
        while (_Newsize > num2 && 0U < _Newsize);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eresize(obj1, _Newsize, (sbyte) 0);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002Ecollate\u003Cchar\u003E\u002Edo_hash(
    [In] collate\u003Cchar\u003E* obj0,
    sbyte* _First,
    sbyte* _Last)
  {
    uint num = 0;
    if (_First != _Last)
    {
      do
      {
        num = (num >> 24 | num << 8) + (uint) *_First;
        ++_First;
      }
      while (_First != _Last);
    }
    return (int) num;
  }

  internal static unsafe messages\u003Cchar\u003E* std\u002Emessages\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] messages\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emessages\u003Cchar\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      messages\u003Cchar\u003E* messagesCharPtr1 = (messages\u003Cchar\u003E*) \u003CModule\u003E.@new(8U);
      messages\u003Cchar\u003E* messagesCharPtr2;
      // ISSUE: fault handler
      try
      {
        messagesCharPtr2 = (IntPtr) messagesCharPtr1 == IntPtr.Zero ? (messages\u003Cchar\u003E*) 0 : \u003CModule\u003E.std\u002Emessages\u003Cchar\u003E\u002E\u007Bctor\u007D(messagesCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) messagesCharPtr1);
      }
      *(int*) _Ppf = (int) messagesCharPtr2;
    }
    return 6;
  }

  internal static unsafe void std\u002Emessages\u003Cchar\u003E\u002E\u007Bdtor\u007D(
    [In] messages\u003Cchar\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Emessages\u003Cchar\u003E\u002Edo_open(
    [In] messages\u003Cchar\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _param1,
    locale* _param2)
  {
    return -1;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Emessages\u003Cchar\u003E\u002Edo_get(
    [In] messages\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    int __unnamed000,
    int __unnamed001,
    int __unnamed002,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Dflt)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, _Dflt);
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe void std\u002Emessages\u003Cchar\u003E\u002Edo_close(
    [In] messages\u003Cchar\u003E* obj0,
    int _param1)
  {
  }

  internal static unsafe money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr2;
      // ISSUE: fault handler
      try
      {
        stdCharTraitsCharPtr2 = (IntPtr) stdCharTraitsCharPtr1 == IntPtr.Zero ? (money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
      }
      *(int*) _Ppf = (int) stdCharTraitsCharPtr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(obj0, &stdAllocatorChar1, &_First, &_Last, _Intl, _Iosbase);
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
      {
        int* numPtr = _State;
        int num = *numPtr | 1;
        *numPtr = num;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &stdAllocatorChar1 + 20) == 0)
      {
        int* numPtr = _State;
        int num = *numPtr | 2;
        *numPtr = num;
      }
      else
      {
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2);
        // ISSUE: fault handler
        try
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(&stdAllocatorChar2, (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20));
          uint _Off = 0;
          if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar1, 0U) < (sbyte) 48 || (sbyte) 57 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar1, 0U))
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar2, (sbyte) 45);
            _Off = 1U;
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (_Off < (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20))
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            do
            {
              sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar1, _Off);
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar2, *numPtr);
              ++_Off;
            }
            while (_Off < (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20));
          }
          sbyte* s = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar2);
          int num1 = 0;
          sbyte* numPtr1;
          double num2 = \u003CModule\u003E._Stoldx(s, &numPtr1, 0, &num1);
          if (numPtr1 != s && num1 == 0)
          {
            *_Val = num2;
          }
          else
          {
            int* numPtr2 = _State;
            int num3 = *numPtr2 | 2;
            *numPtr2 = num3;
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
      }
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _First, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    int* _State,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Val)
  {
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(obj0, &stdAllocatorChar, &_First, &_Last, _Intl, _Iosbase);
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
      {
        int* numPtr = _State;
        int num = *numPtr | 1;
        *numPtr = num;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &stdAllocatorChar + 20) == 0)
      {
        int* numPtr = _State;
        int num = *numPtr | 2;
        *numPtr = num;
      }
      else
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eassign(_Val, &stdAllocatorChar, 0U, uint.MaxValue);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _First, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return obj1;
  }

  internal static unsafe money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr2;
      // ISSUE: fault handler
      try
      {
        stdCharTraitsCharPtr2 = (IntPtr) stdCharTraitsCharPtr1 == IntPtr.Zero ? (money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
      }
      *(int*) _Ppf = (int) stdCharTraitsCharPtr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    sbyte _Fill,
    double _Val)
  {
    bool _Neg = false;
    if (_Val < 0.0)
    {
      _Neg = true;
      _Val = -_Val;
    }
    uint _Count = 0;
    if (1E+35 <= _Val)
    {
      while (_Count < 5000U)
      {
        _Val /= 10000000000.0;
        _Count += 10U;
        if (1E+35 > _Val)
          break;
      }
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040D arrayTypeBy0CiD;
      int num1 = \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0CiD, 40U, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05NNKBBLJI\u0040\u003F\u0024CF\u003F40Lf\u003F\u0024AA\u0040, __arglist (_Val));
      int num2 = 0;
      if (0 < num1)
      {
        do
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          sbyte _Ch = ^(sbyte&) (num2 + (IntPtr) &arrayTypeBy0CiD);
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, _Ch);
          ++num2;
        }
        while (num2 < num1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, _Count, (sbyte) 48);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* pThis = &stdAllocatorChar2;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Val1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, &stdAllocatorChar1);
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest1;
      // ISSUE: fault handler
      try
      {
        _Dest1 = _Dest;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(obj0, obj1, _Dest1, _Intl, _Iosbase, _Fill, _Neg, _Val1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    sbyte _Fill,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Val)
  {
    sbyte* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(_Val);
    bool _Neg = false;
    if (*_Ptr == (sbyte) 45)
    {
      _Neg = true;
      ++_Ptr;
    }
    uint _Count = 0;
    sbyte num1 = *_Ptr;
    if ((sbyte) 48 <= num1)
    {
      sbyte num2 = num1;
      while (num2 <= (sbyte) 57)
      {
        ++_Count;
        num2 = *(sbyte*) ((int) _Count + (IntPtr) _Ptr);
        if ((sbyte) 48 > num2)
          break;
      }
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1, _Ptr, _Count);
    // ISSUE: fault handler
    try
    {
      if (_Count == 0U)
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 1U, (sbyte) 48);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* pThis = &stdAllocatorChar2;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Val1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, &stdAllocatorChar1);
      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest1;
      // ISSUE: fault handler
      try
      {
        _Dest1 = _Dest;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(obj0, obj1, _Dest1, _Intl, _Iosbase, _Fill, _Neg, _Val1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cchar\u002C0\u003E* std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cchar\u002C0\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cchar\u003E*) obj0, _Lobj, _Refs, false);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      moneypunct\u003Cchar\u002C0\u003E* moneypunctChar0Ptr1 = (moneypunct\u003Cchar\u002C0\u003E*) \u003CModule\u003E.@new(52U);
      moneypunct\u003Cchar\u002C0\u003E* moneypunctChar0Ptr2;
      // ISSUE: fault handler
      try
      {
        moneypunctChar0Ptr2 = (IntPtr) moneypunctChar0Ptr1 == IntPtr.Zero ? (moneypunct\u003Cchar\u002C0\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bctor\u007D(moneypunctChar0Ptr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) moneypunctChar0Ptr1);
      }
      *(int*) _Ppf = (int) moneypunctChar0Ptr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bdtor\u007D(
    [In] moneypunct\u003Cchar\u002C0\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D((_Mpunct\u003Cchar\u003E*) obj0);
  }

  internal static unsafe void std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe sbyte std\u002E_Mpunct\u003Cchar\u003E\u002Edo_decimal_point(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    return *(sbyte*) ((IntPtr) obj0 + 12);
  }

  internal static unsafe sbyte std\u002E_Mpunct\u003Cchar\u003E\u002Edo_thousands_sep(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    return *(sbyte*) ((IntPtr) obj0 + 13);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Edo_grouping(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Edo_curr_symbol(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 16));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Edo_positive_sign(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 20));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Edo_negative_sign(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 24));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002E_Mpunct\u003Cchar\u003E\u002Edo_frac_digits(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    return *(int*) ((IntPtr) obj0 + 28);
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cchar\u003E\u002Edo_pos_format(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, (IntPtr) obj0 + 32, 4);
    return obj1;
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cchar\u003E\u002Edo_neg_format(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, (IntPtr) obj0 + 36, 4);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cchar\u002C1\u003E* std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cchar\u002C1\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cchar\u003E*) obj0, _Lobj, _Refs, true);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      moneypunct\u003Cchar\u002C1\u003E* moneypunctChar1Ptr1 = (moneypunct\u003Cchar\u002C1\u003E*) \u003CModule\u003E.@new(52U);
      moneypunct\u003Cchar\u002C1\u003E* moneypunctChar1Ptr2;
      // ISSUE: fault handler
      try
      {
        moneypunctChar1Ptr2 = (IntPtr) moneypunctChar1Ptr1 == IntPtr.Zero ? (moneypunct\u003Cchar\u002C1\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bctor\u007D(moneypunctChar1Ptr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) moneypunctChar1Ptr1);
      }
      *(int*) _Ppf = (int) moneypunctChar1Ptr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bdtor\u007D(
    [In] moneypunct\u003Cchar\u002C1\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D((_Mpunct\u003Cchar\u003E*) obj0);
  }

  internal static unsafe time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
      time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr2;
      // ISSUE: fault handler
      try
      {
        stdCharTraitsCharPtr2 = (IntPtr) stdCharTraitsCharPtr1 == IntPtr.Zero ? (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
      }
      *(int*) _Ppf = (int) stdCharTraitsCharPtr2;
    }
    return 5;
  }

  internal static unsafe void std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe time_base.dateorder std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_date_order(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    return (time_base.dateorder) *(int*) ((IntPtr) obj0 + 16);
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_time(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int* numPtr1 = _State;
    int num1 = *numPtr1 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 23, (int*) ((IntPtr) _Pt + 8));
    *numPtr1 = num1;
    if (*_State == 0 && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 58)
    {
      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Inc(&_First);
      int* numPtr2 = _State;
      int num2 = *numPtr2 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 59, (int*) ((IntPtr) _Pt + 4));
      *numPtr2 = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    if (*_State == 0 && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 58)
    {
      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E_Inc(&_First);
      int* numPtr4 = _State;
      int num4 = *numPtr4 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 59, (int*) _Pt);
      *numPtr4 = num4;
    }
    else
    {
      int* numPtr5 = _State;
      int num5 = *numPtr5 | 2;
      *numPtr5 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_date(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_base.dateorder dateorder = \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edate_order(obj0);
    if (dateorder == (time_base.dateorder) 0)
      dateorder = (time_base.dateorder) 2;
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) >= (sbyte) 48 && (sbyte) 57 >= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First))
    {
      switch (dateorder)
      {
        case (time_base.dateorder) 1:
          int* numPtr1 = _State;
          int num1 = *numPtr1 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
          *numPtr1 = num1;
          break;
        case (time_base.dateorder) 2:
          int* numPtr2 = _State;
          int num2 = *numPtr2 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
          *numPtr2 = num2;
          *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
          break;
        default:
          istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
          istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* traitsCharGetYear1 = \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_year(obj0, &stdCharTraitsChar1, _First, _Last, _Iosbase, _State, _Pt);
          // ISSUE: cpblk instruction
          __memcpy(ref _First, (IntPtr) traitsCharGetYear1, 12);
          break;
      }
    }
    else
    {
      istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
      istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* charGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &stdCharTraitsChar2, _First, _Last, _Iosbase, _State, _Pt);
      // ISSUE: cpblk instruction
      __memcpy(ref _First, (IntPtr) charGetMonthname, 12);
      dateorder = (time_base.dateorder) 2;
    }
    if (*_State == 0)
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32)
      {
        do
        {
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
        }
        while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32);
      }
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 58 || \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 44 || \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 47)
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32)
      {
        do
        {
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
        }
        while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32);
      }
      if (*_State == 0)
      {
        if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) >= (sbyte) 48 && (sbyte) 57 >= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First))
        {
          if (dateorder != (time_base.dateorder) 1 && dateorder != (time_base.dateorder) 3)
          {
            int* numPtr3 = _State;
            int num3 = *numPtr3 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
            *numPtr3 = num3;
          }
          else
          {
            int* numPtr4 = _State;
            int num4 = *numPtr4 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
            *numPtr4 = num4;
            *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
          }
        }
        else if (dateorder == (time_base.dateorder) 2)
        {
          int* numPtr5 = _State;
          int num5 = *numPtr5 | 2;
          *numPtr5 = num5;
        }
        else
        {
          istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3;
          istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* charGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &stdCharTraitsChar3, _First, _Last, _Iosbase, _State, _Pt);
          // ISSUE: cpblk instruction
          __memcpy(ref _First, (IntPtr) charGetMonthname, 12);
          if (dateorder == (time_base.dateorder) 4)
            dateorder = (time_base.dateorder) 3;
        }
        if (*_State == 0)
        {
          if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32)
          {
            do
            {
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
            }
            while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32);
          }
          if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 58 || \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 44 || \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 47)
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
          if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32)
          {
            do
            {
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
            }
            while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) == (sbyte) 32);
          }
          if (*_State == 0)
          {
            if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First) >= (sbyte) 48 && (sbyte) 57 >= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_First))
            {
              switch (dateorder)
              {
                case (time_base.dateorder) 3:
                  int* numPtr6 = _State;
                  int num6 = *numPtr6 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
                  *numPtr6 = num6;
                  break;
                case (time_base.dateorder) 4:
                  int* numPtr7 = _State;
                  int num7 = *numPtr7 | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
                  *numPtr7 = num7;
                  *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
                  break;
                default:
                  istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar4;
                  istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* traitsCharGetYear2 = \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_year(obj0, &stdCharTraitsChar4, _First, _Last, _Iosbase, _State, _Pt);
                  // ISSUE: cpblk instruction
                  __memcpy(ref _First, (IntPtr) traitsCharGetYear2, 12);
                  break;
              }
            }
            else if (dateorder != (time_base.dateorder) 4)
            {
              int* numPtr8 = _State;
              int num8 = *numPtr8 | 2;
              *numPtr8 = num8;
            }
            else
            {
              istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar5;
              istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* charGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &stdCharTraitsChar5, _First, _Last, _Iosbase, _State, _Pt);
              // ISSUE: cpblk instruction
              __memcpy(ref _First, (IntPtr) charGetMonthname, 12);
            }
          }
        }
      }
    }
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr9 = _State;
      int num9 = *numPtr9 | 1;
      *numPtr9 = num9;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_weekday(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 0U, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num2 = *numPtr | 2;
      *numPtr = num2;
    }
    else
      *(int*) ((IntPtr) _Pt + 24) = num1 >> 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_monthname(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 0U, (sbyte*) *(int*) ((IntPtr) obj0 + 12));
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num2 = *numPtr | 2;
      *numPtr = num2;
    }
    else
      *(int*) ((IntPtr) _Pt + 16) = num1 >> 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_year(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = 0;
    int* numPtr = _State;
    int num2 = *numPtr | \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 2035, &num1);
    *numPtr = num2;
    int num3 = *_State;
    if ((num3 & 2) == 0)
    {
      if (1900 <= num1)
        num1 -= 1900;
      else if (135 < num1)
        *_State = num3 | 2;
    }
    if ((*_State & 2) == 0)
      *(int*) ((IntPtr) _Pt + 20) = num1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, _Lobj);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr1 = (time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(20U);
      time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr2;
      // ISSUE: fault handler
      try
      {
        stdCharTraitsCharPtr2 = (IntPtr) stdCharTraitsCharPtr1 == IntPtr.Zero ? (time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(stdCharTraitsCharPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) stdCharTraitsCharPtr1);
      }
      *(int*) _Ppf = (int) stdCharTraitsCharPtr2;
    }
    return 5;
  }

  internal static unsafe void std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 8));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    ios_base* __unnamed001,
    sbyte __unnamed002,
    tm* _Pt,
    sbyte _Specifier,
    sbyte _Modifier)
  {
    \u0024ArrayType\u0024\u0024\u0024BY04D ihcgilcCbCfxAaAa = (\u0024ArrayType\u0024\u0024\u0024BY04D) \u003CModule\u003E.\u003F\u003F_C\u0040_04IHCGILC\u0040\u003F\u0024CB\u003F\u0024CFx\u003F\u0024AA\u003F\u0024AA\u0040;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      if (_Modifier == (sbyte) 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 2) = _Specifier;
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 2) = _Modifier;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 3) = _Specifier;
      }
      uint _Count = 16;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 16U, (sbyte) 0);
      void* voidPtr1 = (void*) *(int*) ((IntPtr) obj0 + 8);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num1 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      uint num2 = \u003CModule\u003E._Strftime(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2)), num1, (sbyte*) &ihcgilcCbCfxAaAa, _Pt, voidPtr1);
      if (0U >= num2)
      {
        do
        {
          _Count <<= 1;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, _Count, (sbyte) 0);
          void* voidPtr2 = (void*) *(int*) ((IntPtr) obj0 + 8);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num3 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          num2 = \u003CModule\u003E._Strftime(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2)), num3, (sbyte*) &ihcgilcCbCfxAaAa, _Pt, voidPtr2);
        }
        while (0U >= num2);
      }
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3);
      _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
      // ISSUE: cpblk instruction
      __memcpy(ref stdAllocatorChar4, (IntPtr) stdAllocatorCharPtr, 8);
      uint num4 = num2 - 1U;
      if (0U < num4)
      {
        do
        {
          sbyte _Right = *\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&stdAllocatorChar4));
          \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, _Right);
          --num4;
        }
        while (num4 > 0U);
      }
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _Dest, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe void* std\u002Ecollate\u003Cchar\u003E\u002E__vecDelDtor(
    [In] collate\u003Cchar\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      collate\u003Cchar\u003E* collateCharPtr = (collate\u003Cchar\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) collateCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecollate\u003Cchar\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) collateCharPtr);
      return (void*) collateCharPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emessages\u003Cchar\u003E\u002E__vecDelDtor(
    [In] messages\u003Cchar\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      messages\u003Cchar\u003E* messagesCharPtr = (messages\u003Cchar\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) messagesCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emessages\u003Cchar\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) messagesCharPtr);
      return (void*) messagesCharPtr;
    }
    \u003CModule\u003E.std\u002Emessages\u003Cchar\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* traitsCharVecDelDtor = (money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) traitsCharVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsCharVecDelDtor);
      return (void*) traitsCharVecDelDtor;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E__vecDelDtor(
    [In] moneypunct\u003Cchar\u002C0\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      moneypunct\u003Cchar\u002C0\u003E* moneypunctChar0Ptr = (moneypunct\u003Cchar\u002C0\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) moneypunctChar0Ptr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneypunctChar0Ptr);
      return (void*) moneypunctChar0Ptr;
    }
    \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002E_Mpunct\u003Cchar\u003E\u002E__vecDelDtor(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      _Mpunct\u003Cchar\u003E* mpunctCharPtr = (_Mpunct\u003Cchar\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) mpunctCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) mpunctCharPtr);
      return (void*) mpunctCharPtr;
    }
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E__vecDelDtor(
    [In] moneypunct\u003Cchar\u002C1\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      moneypunct\u003Cchar\u002C1\u003E* moneypunctChar1Ptr = (moneypunct\u003Cchar\u002C1\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) moneypunctChar1Ptr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneypunctChar1Ptr);
      return (void*) moneypunctChar1Ptr;
    }
    \u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* traitsCharVecDelDtor = (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 28U, *(int*) traitsCharVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsCharVecDelDtor);
      return (void*) traitsCharVecDelDtor;
    }
    \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = (time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 20U, *(int*) stdCharTraitsCharPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) stdCharTraitsCharPtr);
      return (void*) stdCharTraitsCharPtr;
    }
    \u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe collate\u003Cchar\u003E* std\u002Ecollate\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] collate\u003Cchar\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Collvec collvec = \u003CModule\u003E._Getcoll();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref collvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe messages\u003Cchar\u003E* std\u002Emessages\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] messages\u003Cchar\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(
    [In] money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      _Mpunct\u003Cchar\u003E* mpunctCharPtr;
      if (_Intl)
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctCharPtr = (_Mpunct\u003Cchar\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C1\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      else
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctCharPtr = (_Mpunct\u003Cchar\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C0\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      bool flag1 = false;
      bool flag2 = false;
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1);
        num1 = 1U;
        money_base.pattern pattern;
        \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Eneg_format(mpunctCharPtr, &pattern);
        uint num2 = 0;
        while (num2 < 4U)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          switch (^(sbyte&) ((int) num2 + (IntPtr) &pattern))
          {
            case 32:
            case 120:
              if (num2 != 3U)
              {
                locale locale;
                locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
                ctype\u003Cchar\u003E* ctypeCharPtr;
                // ISSUE: fault handler
                try
                {
                  ctypeCharPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cchar\u003E\u0020\u003E(_Loc);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
                }
                \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                {
                  while (\u003CModule\u003E.std\u002Ectype\u003Cchar\u003E\u002Eis(ctypeCharPtr, (short) 72, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First)))
                  {
                    \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                    if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                      break;
                  }
                  break;
                }
                break;
              }
              break;
            case 36:
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
              \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Ecurr_symbol(mpunctCharPtr, &stdAllocatorChar2);
              // ISSUE: fault handler
              try
              {
                _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
                \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar3);
                if ((\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 8) == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) != (int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar2))
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar2, 0U, uint.MaxValue);
                else if (num2 == 3U && \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar1) <= 1U && (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) != (int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar2)))
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(&stdAllocatorChar2, 0U, uint.MaxValue);
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar2, &stdAllocatorChar4);
                // ISSUE: cpblk instruction
                __memcpy(ref stdAllocatorChar3, (IntPtr) stdAllocatorCharPtr, 8);
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                {
                  _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
                  while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D(&stdAllocatorChar3, (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar2, &stdAllocatorChar5)))
                  {
                    sbyte* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&stdAllocatorChar3);
                    if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) *numPtr)
                    {
                      \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&stdAllocatorChar3);
                      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                      if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                        break;
                    }
                    else
                      break;
                  }
                }
                _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
                if (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D(&stdAllocatorChar3, (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar2, &stdAllocatorChar6)))
                  flag1 = true;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
              break;
            case 43:
              if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
              {
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Epositive_sign(mpunctCharPtr, &stdAllocatorChar7);
                bool flag3;
                // ISSUE: fault handler
                try
                {
                  num1 |= 2U;
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
                  int num3;
                  if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(stdAllocatorCharPtr1))
                  {
                    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Epositive_sign(mpunctCharPtr, &stdAllocatorChar8);
                    // ISSUE: fault handler
                    try
                    {
                      num1 |= 4U;
                      if ((int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(stdAllocatorCharPtr2, 0U) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First))
                      {
                        num3 = 1;
                        goto label_75;
                      }
                    }
                    __fault
                    {
                      if (((int) num1 & 4) != 0)
                      {
                        num1 &= 4294967291U;
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
                      }
                    }
                  }
                  // ISSUE: fault handler
                  try
                  {
                    num3 = 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 4) != 0)
                    {
                      num1 &= 4294967291U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
                    }
                  }
label_75:
                  // ISSUE: fault handler
                  try
                  {
                    flag3 = num3 != 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 4) != 0)
                    {
                      num1 &= 4294967291U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar8);
                    }
                  }
                  if (((int) num1 & 4) != 0)
                  {
                    num1 &= 4294967291U;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar8);
                  }
                }
                __fault
                {
                  if (((int) num1 & 2) != 0)
                  {
                    num1 &= 4294967293U;
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar7);
                  }
                }
                if (((int) num1 & 2) != 0)
                {
                  num1 &= 4294967293U;
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar7);
                }
                if (flag3)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Epositive_sign(mpunctCharPtr, &stdAllocatorChar9);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar1, _Right);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar9);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar9);
                  break;
                }
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar10;
                basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Enegative_sign(mpunctCharPtr, &stdAllocatorChar10);
                bool flag4;
                // ISSUE: fault handler
                try
                {
                  num1 |= 8U;
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar11;
                  int num4;
                  if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(stdAllocatorCharPtr3))
                  {
                    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Enegative_sign(mpunctCharPtr, &stdAllocatorChar11);
                    // ISSUE: fault handler
                    try
                    {
                      num1 |= 16U;
                      if ((int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(stdAllocatorCharPtr4, 0U) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First))
                      {
                        num4 = 1;
                        goto label_105;
                      }
                    }
                    __fault
                    {
                      if (((int) num1 & 16) != 0)
                      {
                        num1 &= 4294967279U;
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
                      }
                    }
                  }
                  // ISSUE: fault handler
                  try
                  {
                    num4 = 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 16) != 0)
                    {
                      num1 &= 4294967279U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
                    }
                  }
label_105:
                  // ISSUE: fault handler
                  try
                  {
                    flag4 = num4 != 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 16) != 0)
                    {
                      num1 &= 4294967279U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar11);
                    }
                  }
                  if (((int) num1 & 16) != 0)
                  {
                    num1 &= 4294967279U;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar11);
                  }
                }
                __fault
                {
                  if (((int) num1 & 8) != 0)
                  {
                    num1 &= 4294967287U;
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar10);
                  }
                }
                if (((int) num1 & 8) != 0)
                {
                  num1 &= 4294967287U;
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar10);
                }
                if (flag4)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar12;
                  basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Enegative_sign(mpunctCharPtr, &stdAllocatorChar12);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar1, _Right);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar12);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar12);
                  flag2 = true;
                  break;
                }
                break;
              }
              break;
            case 118:
              int num5 = 0;
              int num6 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Efrac_digits(mpunctCharPtr);
              sbyte _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cchar\u003E((sbyte) 48, (sbyte*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar13;
              \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Egrouping(mpunctCharPtr, &stdAllocatorChar13);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar14;
              // ISSUE: fault handler
              try
              {
                if ((byte) 127 <= (byte) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar13))
                {
                  if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                  {
                    while ((int) _Ch <= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First))
                    {
                      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                      {
                        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First));
                        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                          break;
                      }
                      else
                        break;
                    }
                    goto label_48;
                  }
                  else
                    goto label_48;
                }
                else
                {
                  sbyte num7 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Ethousands_sep(mpunctCharPtr);
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar14, 1U, (sbyte) 0);
                  // ISSUE: fault handler
                  try
                  {
                    uint _Off = 0;
                    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                    {
                      do
                      {
                        if ((int) _Ch <= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                        {
                          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First));
                          if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar14, _Off) != sbyte.MaxValue)
                          {
                            sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar14, _Off);
                            int num8 = (int) *numPtr + 1;
                            *numPtr = (sbyte) num8;
                          }
                        }
                        else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar14, _Off) != (sbyte) 0 && num7 != (sbyte) 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) num7)
                        {
                          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar14, 1U, (sbyte) 0);
                          ++_Off;
                        }
                        else
                          break;
                        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                      }
                      while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last));
                      if (_Off != 0U)
                      {
                        if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar14, _Off))
                          ++_Off;
                        else
                          flag1 = true;
                      }
                    }
                    sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar13);
                    if (!flag1)
                    {
                      while (0U < _Off)
                      {
                        if (*numPtr1 != sbyte.MaxValue)
                        {
                          --_Off;
                          if (0U < _Off)
                          {
                            sbyte* numPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar14, _Off);
                            if ((int) *numPtr1 != (int) *numPtr2)
                              goto label_40;
                          }
                          if (0U == _Off)
                          {
                            sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar14, _Off);
                            if ((int) *numPtr1 < (int) *numPtr3)
                              goto label_40;
                          }
                          if ((sbyte) 0 < numPtr1[1])
                          {
                            ++numPtr1;
                            continue;
                          }
                          continue;
label_40:
                          flag1 = true;
                          goto label_42;
                        }
                        else
                          break;
                      }
                      goto label_45;
                    }
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar14);
                  }
label_42:
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar14);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar13);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar13);
              break;
label_45:
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar14);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar13);
              }
label_48:
              // ISSUE: fault handler
              try
              {
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Edecimal_point(mpunctCharPtr) && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First), _Last))
                {
                  while ((int) _Ch <= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                  {
                    if (num5 < num6)
                    {
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First));
                      ++num5;
                    }
                    if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First), _Last))
                      break;
                  }
                }
                if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(obj1) == 0U)
                  flag1 = true;
                else if (num5 < num6)
                {
                  uint num9 = (uint) (num6 - num5);
                  do
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(obj1, _Ch);
                    --num9;
                  }
                  while (num9 > 0U);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar13);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar13);
              break;
          }
          ++num2;
          if (flag1)
            break;
        }
        if (!flag1)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (1U < (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20))
          {
            _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar15;
            \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar15);
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar16;
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar16);
            // ISSUE: cpblk instruction
            __memcpy(ref stdAllocatorChar15, (IntPtr) stdAllocatorCharPtr, 8);
            if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
            {
              _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar17;
              while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&stdAllocatorChar15), (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar1, &stdAllocatorChar17)))
              {
                sbyte* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&stdAllocatorChar15);
                if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (int) *numPtr)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
                    break;
                }
                else
                  break;
              }
            }
            _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar18;
            if (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u0021\u003D(&stdAllocatorChar15, (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(&stdAllocatorChar1, &stdAllocatorChar18)))
              goto label_150;
          }
          if (flag2)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(obj1, 0U, 1U, (sbyte) 45);
            goto label_154;
          }
          else
            goto label_154;
        }
label_150:
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eerase(obj1, 0U, uint.MaxValue);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
label_154:
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num10 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(
    [In] money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    sbyte _Fill,
    [MarshalAs(UnmanagedType.U1)] bool _Neg,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Val)
  {
    // ISSUE: fault handler
    try
    {
      _Mpunct\u003Cchar\u003E* mpunctCharPtr;
      if (_Intl)
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctCharPtr = (_Mpunct\u003Cchar\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C1\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      else
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctCharPtr = (_Mpunct\u003Cchar\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C0\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
      \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Egrouping(mpunctCharPtr, &stdAllocatorChar1);
      // ISSUE: fault handler
      try
      {
        int num1 = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Efrac_digits(mpunctCharPtr);
        int num2 = num1 >= 0 ? num1 : -num1;
        uint num3 = (uint) *(int*) ((IntPtr) _Val + 20);
        if (num3 <= (uint) num2)
        {
          uint num4 = num3;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(_Val, 0U, (uint) (num2 - (int) num4 + 1), (sbyte) 48);
        }
        else
        {
          sbyte num5 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          if (num5 != sbyte.MaxValue && (sbyte) 0 < num5)
          {
            sbyte _Ch = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Ethousands_sep(mpunctCharPtr);
            sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
            uint _Off = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val) - (uint) num2;
            sbyte num6 = *numPtr;
            if (num6 != sbyte.MaxValue)
            {
              while ((sbyte) 0 < num6 && (uint) num6 < _Off)
              {
                _Off -= (uint) num6;
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(_Val, _Off, 1U, _Ch);
                if ((sbyte) 0 < numPtr[1])
                  ++numPtr;
                num6 = *numPtr;
                if (num6 == sbyte.MaxValue)
                  break;
              }
            }
          }
        }
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2);
        // ISSUE: fault handler
        try
        {
          money_base.pattern pattern1;
          if (_Neg)
          {
            money_base.pattern pattern2;
            money_base.pattern* patternPtr = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Eneg_format(mpunctCharPtr, &pattern2);
            // ISSUE: cpblk instruction
            __memcpy(ref pattern1, (IntPtr) patternPtr, 4);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Enegative_sign(mpunctCharPtr, &stdAllocatorChar3);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar2, _Right);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar3);
          }
          else
          {
            money_base.pattern pattern3;
            money_base.pattern* patternPtr = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Epos_format(mpunctCharPtr, &pattern3);
            // ISSUE: cpblk instruction
            __memcpy(ref pattern1, (IntPtr) patternPtr, 4);
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
            basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Epositive_sign(mpunctCharPtr, &stdAllocatorChar4);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar2, _Right);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar4);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar4);
          }
          basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar5);
          // ISSUE: fault handler
          try
          {
            if ((*(int*) ((IntPtr) _Iosbase + 16) & 8) != 0)
            {
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar6;
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Ecurr_symbol(mpunctCharPtr, &stdAllocatorChar6);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u003D(&stdAllocatorChar5, _Right);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar6);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar6);
            }
            bool flag = false;
            uint num7 = 0;
            uint num8 = 0;
            do
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              switch (^(sbyte&) ((int) num8 + (IntPtr) &pattern1))
              {
                case 32:
                  ++num7;
                  goto case 120;
                case 36:
                  num7 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar5) + num7;
                  break;
                case 43:
                  num7 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar2) + num7;
                  break;
                case 118:
                  int num9 = 0U < (uint) num2 ? 1 : 0;
                  uint num10 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val) > (uint) num2 ? 0U : (uint) (num2 - (int) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val) + 1);
                  num7 = (uint) ((int) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val) + (int) num10 + num9) + num7;
                  break;
                case 120:
                  if (num8 != 3U)
                  {
                    flag = true;
                    break;
                  }
                  break;
              }
              ++num8;
            }
            while (num8 < 4U);
            uint _Count1 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= 0 || (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= num7 ? 0U : (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) - num7;
            uint _Count2 = _Count1;
            int num11 = \u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 448;
            switch (num11)
            {
              case 64:
                uint num12 = 0;
                do
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  switch (^(sbyte&) ((int) num12 + (IntPtr) &pattern1))
                  {
                    case 32:
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr1 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&stdCharTraitsChar1, _Dest, _Fill, 1U);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr1, 12);
                      goto case 120;
                    case 36:
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar7;
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar5, &stdAllocatorChar7);
                      _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source1;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source1, (IntPtr) stdAllocatorCharPtr1, 8);
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2;
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr2 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar2, _Dest, _Source1, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar5));
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr2, 12);
                      break;
                    case 43:
                      if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar2))
                      {
                        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar8;
                        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar2, &stdAllocatorChar8);
                        _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source2;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source2, (IntPtr) stdAllocatorCharPtr2, 8);
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3;
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr3 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar3, _Dest, _Source2, 1U);
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr3, 12);
                        break;
                      }
                      break;
                    case 118:
                      if (num2 == 0)
                      {
                        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar9;
                        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(_Val, &stdAllocatorChar9);
                        _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source3;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source3, (IntPtr) stdAllocatorCharPtr3, 8);
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar4;
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr4 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar4, _Dest, _Source3, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr4, 12);
                        break;
                      }
                      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val) <= (uint) num2)
                      {
                        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, (sbyte) 48);
                        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Edecimal_point(mpunctCharPtr));
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar5;
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr5 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&stdCharTraitsChar5, _Dest, (sbyte) 48, (uint) num2 - \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr5, 12);
                        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar10;
                        _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(_Val, &stdAllocatorChar10);
                        _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source4;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source4, (IntPtr) stdAllocatorCharPtr4, 8);
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar6;
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr6 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar6, _Dest, _Source4, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr6, 12);
                        break;
                      }
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar11;
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(_Val, &stdAllocatorChar11);
                      _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source5;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source5, (IntPtr) stdAllocatorCharPtr5, 8);
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar7;
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr7 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar7, _Dest, _Source5, \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(_Val) - (uint) num2);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr7, 12);
                      \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002Edecimal_point(mpunctCharPtr));
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar12;
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar13;
                      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr6 = \u003CModule\u003E.std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002D(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eend(_Val, &stdAllocatorChar12), &stdAllocatorChar13, num2);
                      _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source6;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source6, (IntPtr) stdAllocatorCharPtr6, 8);
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar8;
                      ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr8 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar8, _Dest, _Source6, (uint) num2);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr8, 12);
                      break;
                    case 120:
                      if (num11 == 256)
                      {
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar9;
                        ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr9 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&stdCharTraitsChar9, _Dest, _Fill, _Count2);
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr9, 12);
                        _Count2 = 0U;
                        break;
                      }
                      break;
                  }
                  ++num12;
                }
                while (num12 < 4U);
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if (1U < (uint) ^(int&) ((IntPtr) &stdAllocatorChar2 + 20))
                {
                  _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar14;
                  _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar15;
                  _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar2, &stdAllocatorChar14), &stdAllocatorChar15, 1);
                  _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source;
                  // ISSUE: cpblk instruction
                  __memcpy(ref _Source, (IntPtr) stdAllocatorCharPtr, 8);
                  ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar;
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(&stdCharTraitsChar, _Dest, _Source, (uint) (^(int&) ((IntPtr) &stdAllocatorChar2 + 20) - 1));
                  // ISSUE: cpblk instruction
                  __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr, 12);
                }
                *(int*) ((IntPtr) _Iosbase + 24) = 0;
                \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj1, _Dest, _Fill, _Count2);
                break;
              case 256:
                if (flag)
                  goto case 64;
                else
                  goto default;
              default:
                ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar10;
                ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* stdCharTraitsCharPtr10 = \u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&stdCharTraitsChar10, _Dest, _Fill, _Count1);
                // ISSUE: cpblk instruction
                __memcpy(ref _Dest, (IntPtr) stdCharTraitsCharPtr10, 12);
                _Count2 = 0U;
                goto case 64;
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar5);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar5);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) _Val);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(_Val);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cchar\u002C0\u003E* std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cchar\u002C0\u003E* obj0,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cchar\u003E*) obj0, _Refs, false);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe _Mpunct\u003Cchar\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs,
    [MarshalAs(UnmanagedType.U1)] bool _Intl)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      *(sbyte*) ((IntPtr) obj0 + 40) = (sbyte) _Intl;
      \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cchar\u003E\u002E_Tidy(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 20));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 24));
  }

  internal static unsafe moneypunct\u003Cchar\u002C1\u003E* std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cchar\u002C1\u003E* obj0,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cchar\u003E*) obj0, _Refs, true);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe time_base.dateorder std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edate_order(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<time_base.dateorder (IntPtr)>) *(int*) (*(int*) stdCharTraitsCharPtr + 4))((IntPtr) stdCharTraitsCharPtr);
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
    ref istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E local = ref stdCharTraitsChar1;
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2 = _First;
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3 = _Last;
    ios_base* iosBasePtr = _Iosbase;
    int* numPtr = _State;
    tm* tmPtr = _Pt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* (IntPtr, istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*, istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E, istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E, ios_base*, int*, tm*)>) *(int*) (*(int*) obj0 + 20))((tm*) stdCharTraitsCharPtr, (int*) ref local, (ios_base*) stdCharTraitsChar2, stdCharTraitsChar3, (istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E) (IntPtr) iosBasePtr, (istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) numPtr, (IntPtr) tmPtr);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Eget_year(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* stdCharTraitsCharPtr = obj0;
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar1;
    ref istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E local = ref stdCharTraitsChar1;
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar2 = _First;
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E stdCharTraitsChar3 = _Last;
    ios_base* iosBasePtr = _Iosbase;
    int* numPtr = _State;
    tm* tmPtr = _Pt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* (IntPtr, istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*, istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E, istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E, ios_base*, int*, tm*)>) *(int*) (*(int*) obj0 + 24))((tm*) stdCharTraitsCharPtr, (int*) ref local, (ios_base*) stdCharTraitsChar2, stdCharTraitsChar3, (istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E) (IntPtr) iosBasePtr, (istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E*) numPtr, (IntPtr) tmPtr);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 12);
    return obj1;
  }

  internal static unsafe time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Init(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* __unnamed002 = (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 20);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) __unnamed002, ref cvtvec, 8);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 12) = 0;
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E(\u003CModule\u003E.std\u002E_Locinfo\u002E_Getdays(_Lobj), (sbyte*) 0, (_Cvtvec*) __unnamed002);
      *(int*) ((IntPtr) obj0 + 12) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E(\u003CModule\u003E.std\u002E_Locinfo\u002E_Getmonths(_Lobj), (sbyte*) 0, (_Cvtvec*) __unnamed002);
      *(int*) ((IntPtr) obj0 + 16) = \u003CModule\u003E.std\u002E_Locinfo\u002E_Getdateorder(_Lobj);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
  }

  internal static unsafe int std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getint(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* _Last,
    int _Lo,
    int _Hi,
    int* _Val)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1 = (sbyte*) &arrayTypeBy0CaD;
    if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 43)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy0CaD = (sbyte) 43;
        numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
      else if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 45)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy0CaD = (sbyte) 45;
        numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
    }
    bool flag = false;
    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
    {
      while (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) == (sbyte) 48)
      {
        flag = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
          break;
      }
      if (flag)
      {
        *numPtr1 = (sbyte) 48;
        ++numPtr1;
      }
    }
    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
    {
      while ((sbyte) 48 <= \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) && \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First) <= (sbyte) 57)
      {
        *numPtr1 = \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002A(_First);
        // ISSUE: cast to a reference type
        if ((IntPtr) numPtr1 < (\u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D&) ((IntPtr) &arrayTypeBy0CaD + 31))
          ++numPtr1;
        flag = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E(_First, _Last))
          break;
      }
    }
    if (!flag)
      numPtr1 = (sbyte*) &arrayTypeBy0CaD;
    *numPtr1 = (sbyte) 0;
    int num1 = 0;
    sbyte* numPtr2;
    int num2 = \u003CModule\u003E._Stolx((sbyte*) &arrayTypeBy0CaD, &numPtr2, 10, &num1);
    int traitsCharGetint = 0;
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002Eequal(_First, _Last))
      traitsCharGetint = 1;
    if ((IntPtr) numPtr2 != ref arrayTypeBy0CaD && num1 == 0 && num2 >= _Lo && _Hi >= num2)
      *_Val = num2;
    else
      traitsCharGetint |= 2;
    return traitsCharGetint;
  }

  internal static unsafe void std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(
    [In] time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 12));
  }

  internal static unsafe time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      // ISSUE: fault handler
      try
      {
        bool flag = false;
        int num = 0;
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
          RuntimeHelpers.PrepareConstrainedRegions();
          try
          {
          }
          finally
          {
            \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
            flag = true;
          }
          _Locinfo locinfo;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, &locinfo);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
        finally
        {
          if (flag)
            \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Init(
    [In] time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj)
  {
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 12, ref cvtvec, 8);
    _Timevec timevec;
    _Timevec* timevecPtr = \u003CModule\u003E.std\u002E_Locinfo\u002E_Gettnames(_Lobj, &timevec);
    // ISSUE: fault handler
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = *(int*) timevecPtr;
      *(int*) timevecPtr = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) &timevec);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.free((void*) ^(int&) ref timevec);
  }

  internal static unsafe _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + 1;
        return obj0;
      default:
        uint num = (uint) *(int*) obj0;
        if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) num) + *(int*) ((int) num + 20)))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Put(
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E _Source,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        sbyte* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&_Source);
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, *numPtr);
        --_Count;
        \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u002B(&_Source);
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _Dest, 12);
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Rep(
    [In] ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E* obj0,
    ostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E _Dest,
    sbyte _Ch,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u002E\u003D(&_Dest, _Ch);
        --_Count;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _Dest, 12);
    return obj0;
  }

  internal static unsafe sbyte std\u002E_Mpunct\u003Cchar\u003E\u002Edecimal_point(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte (IntPtr)>) *(int*) (*(int*) mpunctCharPtr + 4))((IntPtr) mpunctCharPtr);
  }

  internal static unsafe sbyte std\u002E_Mpunct\u003Cchar\u003E\u002Ethousands_sep(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<sbyte (IntPtr)>) *(int*) (*(int*) mpunctCharPtr + 8))((IntPtr) mpunctCharPtr);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Egrouping(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 12))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) mpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Ecurr_symbol(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 16))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) mpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Epositive_sign(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 20))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) mpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002Enegative_sign(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 24))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) mpunctCharPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002E_Mpunct\u003Cchar\u003E\u002Efrac_digits(
    [In] _Mpunct\u003Cchar\u003E* obj0)
  {
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) mpunctCharPtr + 28))((IntPtr) mpunctCharPtr);
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cchar\u003E\u002Epos_format(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    money_base.pattern pattern;
    ref money_base.pattern local = ref pattern;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<money_base.pattern* (IntPtr, money_base.pattern*)>) *(int*) (*(int*) obj0 + 32))((money_base.pattern*) mpunctCharPtr, (IntPtr) ref local);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 4);
    return obj1;
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cchar\u003E\u002Eneg_format(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    _Mpunct\u003Cchar\u003E* mpunctCharPtr = obj0;
    money_base.pattern pattern;
    ref money_base.pattern local = ref pattern;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<money_base.pattern* (IntPtr, money_base.pattern*)>) *(int*) (*(int*) obj0 + 36))((money_base.pattern*) mpunctCharPtr, (IntPtr) ref local);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 4);
    return obj1;
  }

  internal static unsafe _Mpunct\u003Cchar\u003E* std\u002E_Mpunct\u003Cchar\u003E\u002E\u007Bctor\u007D(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    uint _Refs,
    [MarshalAs(UnmanagedType.U1)] bool _Intl)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4);
      *(sbyte*) ((IntPtr) obj0 + 40) = (sbyte) _Intl;
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cchar\u003E\u002E_Init(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    _Mpunct\u003Cchar\u003E* __unnamed002 = (_Mpunct\u003Cchar\u003E*) ((IntPtr) obj0 + 44);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) __unnamed002, ref cvtvec, 8);
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) ((IntPtr) obj0 + 20) = 0;
    *(int*) ((IntPtr) obj0 + 24) = 0;
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) *(int*) ((IntPtr) lconvPtr + 28), (sbyte*) 0, (_Cvtvec*) __unnamed002);
      sbyte* _Ptr1 = *(byte*) ((IntPtr) obj0 + 40) == (byte) 0 ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 16) : (sbyte*) *(int*) ((IntPtr) lconvPtr + 12);
      *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E(_Ptr1, (sbyte*) 0, (_Cvtvec*) __unnamed002);
      sbyte* _Ptr2 = (byte) 4 >= (byte) *(sbyte*) ((IntPtr) lconvPtr + 46) ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 32) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
      *(int*) ((IntPtr) obj0 + 20) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E(_Ptr2, (sbyte*) 0, (_Cvtvec*) __unnamed002);
      sbyte* _Ptr3 = (byte) 4 >= (byte) *(sbyte*) ((IntPtr) lconvPtr + 47) ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 36) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01JOAMLHOP\u0040\u003F9\u003F\u0024AA\u0040;
      *(int*) ((IntPtr) obj0 + 24) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E(_Ptr3, (sbyte*) 0, (_Cvtvec*) __unnamed002);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    *(sbyte*) ((IntPtr) obj0 + 12) = *(sbyte*) *(int*) ((IntPtr) lconvPtr + 20);
    *(sbyte*) ((IntPtr) obj0 + 13) = *(sbyte*) *(int*) ((IntPtr) lconvPtr + 24);
    int num3 = *(byte*) ((IntPtr) obj0 + 40) == (byte) 0 ? (int) *(sbyte*) ((IntPtr) lconvPtr + 41) : (int) *(sbyte*) ((IntPtr) lconvPtr + 40);
    *(int*) ((IntPtr) obj0 + 28) = num3;
    if (num3 < 0 || (int) sbyte.MaxValue <= num3)
      *(int*) ((IntPtr) obj0 + 28) = 0;
    _Mpunct\u003Cchar\u003E* mpunctCharPtr1 = obj0;
    IntPtr _Pattern1 = (IntPtr) mpunctCharPtr1 + 32;
    int _Sepbyspace1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 43);
    int _Symbolprecedes1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 42);
    int _Signposition1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 46);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E_Makpat(mpunctCharPtr1, (money_base.pattern*) _Pattern1, (uint) _Sepbyspace1, (uint) _Symbolprecedes1, (uint) _Signposition1);
    _Mpunct\u003Cchar\u003E* mpunctCharPtr2 = obj0;
    IntPtr _Pattern2 = (IntPtr) mpunctCharPtr2 + 36;
    int _Sepbyspace2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 45);
    int _Symbolprecedes2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 44);
    int _Signposition2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 47);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cchar\u003E\u002E_Makpat(mpunctCharPtr2, (money_base.pattern*) _Pattern2, (uint) _Sepbyspace2, (uint) _Symbolprecedes2, (uint) _Signposition2);
  }

  internal static unsafe _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = 0;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return obj0;
  }

  internal static unsafe _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002D(
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1,
    int _Off)
  {
    _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    // ISSUE: cpblk instruction
    __memcpy(ref stdAllocatorChar, (IntPtr) obj0, 8);
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar, -_Off);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref stdAllocatorChar, 8);
    return obj1;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cchar\u003E\u002E_Makpat(
    [In] _Mpunct\u003Cchar\u003E* obj0,
    money_base.pattern* _Pattern,
    uint _Sepbyspace,
    uint _Symbolprecedes,
    uint _Signposition)
  {
    sbyte* numPtr = *(byte*) ((IntPtr) obj0 + 40) != (byte) 0 || 2U < _Sepbyspace || 1U < _Symbolprecedes || 4U < _Signposition ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04FJCIEOIB\u0040\u0024\u003F\u0024CLxv\u003F\u0024AA\u0040 : (sbyte*) ((((int) _Sepbyspace * 2 + (int) _Symbolprecedes) * 5 + (int) _Signposition) * 4 + (IntPtr) &\u003CModule\u003E.\u003F\u003F_C\u0040_0HJ\u0040PJOMAIHM\u0040\u003F\u0024CLv\u0024x\u003F\u0024CLv\u0024xv\u0024\u003F\u0024CLxv\u003F\u0024CL\u0024xv\u0024\u003F\u0024CLx\u003F\u0024CL\u0024vx\u003F\u0024CL\u0024vx\u0024v\u003F\u0024CLx\u0040);
    \u003CModule\u003E.memcpy_s((void*) _Pattern, 4U, (void*) numPtr, 4U);
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe collate\u003Cchar\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acollate\u003Cchar\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecollate\u003Cchar\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (collate\u003Cchar\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe messages\u003Cchar\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amessages\u003Cchar\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emessages\u003Cchar\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (messages\u003Cchar\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_get\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* stdCharTraitsChar = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) stdCharTraitsChar == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          stdCharTraitsChar = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          stdCharTraitsChar = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (money_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) stdCharTraitsChar;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_put\u003Cchar\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (money_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe moneypunct\u003Cchar\u002C0\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C0\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (moneypunct\u003Cchar\u002C0\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe moneypunct\u003Cchar\u002C1\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cchar\u002C1\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (moneypunct\u003Cchar\u002C1\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_get\u003Cchar\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* stdCharTraitsChar = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) stdCharTraitsChar == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          stdCharTraitsChar = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          stdCharTraitsChar = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (time_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) stdCharTraitsChar;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0x84d97843\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_put\u003Cchar\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (time_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecollate\u003Cchar\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecollate\u003Cchar\u003E\u002Edo_compare);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecollate\u003Cchar\u003E\u002Edo_transform);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040D\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecollate\u003Cchar\u003E\u002Edo_hash);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emessages\u003Cchar\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emessages\u003Cchar\u003E\u002Edo_open);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emessages\u003Cchar\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040D\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Emessages\u003Cchar\u003E\u002Edo_close);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emoney_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emoney_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoneypunct\u003Cchar\u002C0\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoneypunct\u003Cchar\u002C1\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040D\u002400\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_date_order);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_time);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_date);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_weekday);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_monthname);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040DV\u003F\u0024istreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Etime_get\u003Cchar\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_get_year);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040DV\u003F\u0024ostreambuf_iterator\u0040DU\u003F\u0024char_traits\u0040D\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Etime_put\u003Cchar\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0x84d97843\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040D\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cchar\u003E\u002Edo_neg_format);
  }

  internal static unsafe char* wmemset(char* _S, [MarshalAs(UnmanagedType.U2)] char _C, uint _N)
  {
    char* chPtr = _S;
    if (0U < _N)
    {
      do
      {
        *chPtr = _C;
        ++chPtr;
        --_N;
      }
      while (_N > 0U);
    }
    return _S;
  }

  internal static unsafe sbyte std\u002E_Maklocbyte\u003Cwchar_t\u003E([MarshalAs(UnmanagedType.U2)] char _Char, _Cvtvec* _Cvt)
  {
    sbyte num1 = 0;
    int num2 = 0;
    \u003CModule\u003E._Wcrtomb(&num1, _Char, &num2, _Cvt);
    return num1;
  }

  internal static unsafe sbyte std\u002E_Maklocbyte\u003Cunsigned\u0020short\u003E(
    ushort _Char,
    _Cvtvec* _Cvt)
  {
    sbyte num1 = 0;
    int num2 = 0;
    \u003CModule\u003E._Wcrtomb(&num1, (char) _Char, &num2, _Cvt);
    return num1;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002E_Maklocchr\u003Cwchar_t\u003E(
    sbyte _Byte,
    char* __unnamed001,
    _Cvtvec* _Cvt)
  {
    char minValue = char.MinValue;
    int num = 0;
    \u003CModule\u003E._Mbrtowc(&minValue, &_Byte, 1U, &num, _Cvt);
    return minValue;
  }

  internal static unsafe ushort std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(
    sbyte _Byte,
    ushort* __unnamed001,
    _Cvtvec* _Cvt)
  {
    ushort num1 = 0;
    int num2 = 0;
    \u003CModule\u003E._Mbrtowc((char*) &num1, &_Byte, 1U, &num2, _Cvt);
    return num1;
  }

  internal static unsafe char* std\u002E_Maklocstr\u003Cwchar_t\u003E(
    sbyte* _Ptr,
    char* __unnamed001,
    _Cvtvec* _Cvt)
  {
    int num1 = 0;
    uint n1 = \u003CModule\u003E.strlen(_Ptr) + 1U;
    uint n2 = n1;
    uint num2 = 0;
    sbyte* s = _Ptr;
    if (0U < n1)
    {
      do
      {
        char ch;
        int num3 = \u003CModule\u003E._Mbrtowc(&ch, s, n2, &num1, _Cvt);
        if (num3 > 0)
        {
          n2 -= (uint) num3;
          s = (sbyte*) (num3 + (IntPtr) s);
          ++num2;
        }
        else
          break;
      }
      while (0U < n2);
    }
    uint num4 = num2 + 1U;
    char* chPtr = (char*) \u003CModule\u003E.new\u005B\u005D(num4 > (uint) int.MaxValue ? uint.MaxValue : num4 << 1);
    char* pwc = chPtr;
    int num5 = 0;
    if (0U < num4)
    {
      do
      {
        int num6 = \u003CModule\u003E._Mbrtowc(pwc, _Ptr, n1, &num5, _Cvt);
        if (num6 > 0)
        {
          _Ptr = (sbyte*) (num6 + (IntPtr) _Ptr);
          --num4;
          ++pwc;
        }
        else
          break;
      }
      while (0U < num4);
    }
    *pwc = char.MinValue;
    return chPtr;
  }

  internal static unsafe ushort* std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E(
    sbyte* _Ptr,
    ushort* __unnamed001,
    _Cvtvec* _Cvt)
  {
    int num1 = 0;
    uint n1 = \u003CModule\u003E.strlen(_Ptr) + 1U;
    uint n2 = n1;
    uint num2 = 0;
    sbyte* s = _Ptr;
    if (0U < n1)
    {
      do
      {
        ushort num3;
        int num4 = \u003CModule\u003E._Mbrtowc((char*) &num3, s, n2, &num1, _Cvt);
        if (num4 > 0)
        {
          n2 -= (uint) num4;
          s = (sbyte*) (num4 + (IntPtr) s);
          ++num2;
        }
        else
          break;
      }
      while (0U < n2);
    }
    uint num5 = num2 + 1U;
    char* chPtr = (char*) \u003CModule\u003E.new\u005B\u005D(num5 > (uint) int.MaxValue ? uint.MaxValue : num5 << 1);
    char* pwc = chPtr;
    int num6 = 0;
    if (0U < num5)
    {
      do
      {
        int num7 = \u003CModule\u003E._Mbrtowc(pwc, _Ptr, n1, &num6, _Cvt);
        if (num7 > 0)
        {
          _Ptr = (sbyte*) (num7 + (IntPtr) _Ptr);
          --num5;
          ++pwc;
        }
        else
          break;
      }
      while (0U < num5);
    }
    *pwc = char.MinValue;
    return (ushort*) chPtr;
  }

  internal static unsafe codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7codecvt_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ecodecvt_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ctype\u003Cwchar_t\u003E* std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 24, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ctype\u003Cunsigned\u0020short\u003E* std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] ctype\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7ctype_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024ctype\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      _Ctypevec ctypevec = \u003CModule\u003E._Getctype();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref ctypevec, 16);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 24, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ectype_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Makewloc(
    _Locinfo* _param0,
    int _param1,
    locale._Locimp* _param2,
    locale* _param3)
  {
    if ((1 << (int) \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        ctype\u003Cwchar_t\u003E* ctypeWcharTPtr = (ctype\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(32U);
        ctype\u003Cwchar_t\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) ctypeWcharTPtr == IntPtr.Zero ? (ctype\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(ctypeWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) ctypeWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cwchar_t\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) charTraitsWcharTPtr == IntPtr.Zero ? (num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) charTraitsWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_get\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) charTraitsWcharTPtr == IntPtr.Zero ? (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) charTraitsWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_put\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = (numpunct\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(24U);
        numpunct\u003Cwchar_t\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) numpunctWcharTPtr == IntPtr.Zero ? (numpunct\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(numpunctWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) numpunctWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Ecollate\u003Cwchar_t\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        collate\u003Cwchar_t\u003E* collateWcharTPtr = (collate\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(16U);
        collate\u003Cwchar_t\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) collateWcharTPtr == IntPtr.Zero ? (collate\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Ecollate\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(collateWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) collateWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acollate\u003Cwchar_t\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emessages\u003Cwchar_t\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        messages\u003Cwchar_t\u003E* messagesWcharTPtr = (messages\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(8U);
        messages\u003Cwchar_t\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) messagesWcharTPtr == IntPtr.Zero ? (messages\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(messagesWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) messagesWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amessages\u003Cwchar_t\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) charTraitsWcharTPtr == IntPtr.Zero ? (money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) charTraitsWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_get\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) charTraitsWcharTPtr == IntPtr.Zero ? (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) charTraitsWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_put\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        moneypunct\u003Cwchar_t\u002C0\u003E* moneypunctWcharT0Ptr = (moneypunct\u003Cwchar_t\u002C0\u003E*) \u003CModule\u003E.@new(52U);
        moneypunct\u003Cwchar_t\u002C0\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) moneypunctWcharT0Ptr == IntPtr.Zero ? (moneypunct\u003Cwchar_t\u002C0\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bctor\u007D(moneypunctWcharT0Ptr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) moneypunctWcharT0Ptr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C0\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        moneypunct\u003Cwchar_t\u002C1\u003E* moneypunctWcharT1Ptr = (moneypunct\u003Cwchar_t\u002C1\u003E*) \u003CModule\u003E.@new(52U);
        moneypunct\u003Cwchar_t\u002C1\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) moneypunctWcharT1Ptr == IntPtr.Zero ? (moneypunct\u003Cwchar_t\u002C1\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bctor\u007D(moneypunctWcharT1Ptr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) moneypunctWcharT1Ptr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C1\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
        time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) charTraitsWcharTPtr == IntPtr.Zero ? (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) charTraitsWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_get\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(20U);
        time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) charTraitsWcharTPtr == IntPtr.Zero ? (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) charTraitsWcharTPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_put\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) == 0)
      return;
    if ((IntPtr) _param3 == IntPtr.Zero)
    {
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* codecvtWcharTCharIntPtr = (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(16U);
      codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E* _Pfacet;
      // ISSUE: fault handler
      try
      {
        _Pfacet = (IntPtr) codecvtWcharTCharIntPtr == IntPtr.Zero ? (codecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E*) 0 : \u003CModule\u003E.std\u002Ecodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(codecvtWcharTCharIntPtr, _param0, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) codecvtWcharTCharIntPtr);
      }
      \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    else
      \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cwchar_t\u002Cchar\u002Cint\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040_WDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
  }

  internal static unsafe void std\u002Elocale\u002E_Locimp\u002E_Makeushloc(
    _Locinfo* _param0,
    int _param1,
    locale._Locimp* _param2,
    locale* _param3)
  {
    if ((1 << (int) \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr = (ctype\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(32U);
        ctype\u003Cunsigned\u0020short\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) ctypeUnsignedShortPtr == IntPtr.Zero ? (ctype\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(ctypeUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) ctypeUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cunsigned\u0020short\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024ctype\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) traitsUnsignedShortPtr == IntPtr.Zero ? (num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_get\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) traitsUnsignedShortPtr == IntPtr.Zero ? (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_put\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = (numpunct\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(24U);
        numpunct\u003Cunsigned\u0020short\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) numpunctUnsignedShortPtr == IntPtr.Zero ? (numpunct\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(numpunctUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) numpunctUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        collate\u003Cunsigned\u0020short\u003E* collateUnsignedShortPtr = (collate\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(16U);
        collate\u003Cunsigned\u0020short\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) collateUnsignedShortPtr == IntPtr.Zero ? (collate\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(collateUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) collateUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acollate\u003Cunsigned\u0020short\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        messages\u003Cunsigned\u0020short\u003E* messagesUnsignedShortPtr = (messages\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(8U);
        messages\u003Cunsigned\u0020short\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) messagesUnsignedShortPtr == IntPtr.Zero ? (messages\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(messagesUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) messagesUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amessages\u003Cunsigned\u0020short\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) traitsUnsignedShortPtr == IntPtr.Zero ? (money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_get\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
        money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) traitsUnsignedShortPtr == IntPtr.Zero ? (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_put\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        moneypunct\u003Cunsigned\u0020short\u002C0\u003E* moneypunctUnsignedShort0Ptr = (moneypunct\u003Cunsigned\u0020short\u002C0\u003E*) \u003CModule\u003E.@new(52U);
        moneypunct\u003Cunsigned\u0020short\u002C0\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) moneypunctUnsignedShort0Ptr == IntPtr.Zero ? (moneypunct\u003Cunsigned\u0020short\u002C0\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bctor\u007D(moneypunctUnsignedShort0Ptr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) moneypunctUnsignedShort0Ptr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        moneypunct\u003Cunsigned\u0020short\u002C1\u003E* moneypunctUnsignedShort1Ptr = (moneypunct\u003Cunsigned\u0020short\u002C1\u003E*) \u003CModule\u003E.@new(52U);
        moneypunct\u003Cunsigned\u0020short\u002C1\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) moneypunctUnsignedShort1Ptr == IntPtr.Zero ? (moneypunct\u003Cunsigned\u0020short\u002C1\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bctor\u007D(moneypunctUnsignedShort1Ptr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) moneypunctUnsignedShort1Ptr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
        time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) traitsUnsignedShortPtr == IntPtr.Zero ? (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_get\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) != 0)
    {
      if ((IntPtr) _param3 == IntPtr.Zero)
      {
        time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(20U);
        time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Pfacet;
        // ISSUE: fault handler
        try
        {
          _Pfacet = (IntPtr) traitsUnsignedShortPtr == IntPtr.Zero ? (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr, _param0, 0U);
        }
        __fault
        {
          \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr);
        }
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
      }
      else
        \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_put\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    if ((1 << (int) \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E_Getcat((locale.facet**) 0) >> 1 & _param1) == 0)
      return;
    if ((IntPtr) _param3 == IntPtr.Zero)
    {
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* unsignedShortCharIntPtr = (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) \u003CModule\u003E.@new(16U);
      codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E* _Pfacet;
      // ISSUE: fault handler
      try
      {
        _Pfacet = (IntPtr) unsignedShortCharIntPtr == IntPtr.Zero ? (codecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E*) 0 : \u003CModule\u003E.std\u002Ecodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u002E\u007Bctor\u007D(unsignedShortCharIntPtr, _param0, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) unsignedShortCharIntPtr);
      }
      \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) _Pfacet, \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
    }
    else
      \u003CModule\u003E.std\u002Elocale\u002E_Locimp\u002E_Addfac(_param2, (locale.facet*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acodecvt\u003Cunsigned\u0020short\u002Cchar\u002Cint\u003E\u0020\u003E(_param3), \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024codecvt\u0040GDH\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A));
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esgetc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    ushort num;
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gnavail(obj0))
    {
      num = *(ushort*) *(int*) *(int*) ((IntPtr) obj0 + 32);
    }
    else
    {
      basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 16))((IntPtr) charTraitsWcharTPtr);
    }
    return num;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esgetc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    ushort num;
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gnavail(obj0))
    {
      num = *(ushort*) *(int*) *(int*) ((IntPtr) obj0 + 32);
    }
    else
    {
      basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 16))((IntPtr) traitsUnsignedShortPtr);
    }
    return num;
  }

  internal static unsafe time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, _Lobj);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr1 = (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(20U);
      time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        charTraitsWcharTPtr2 = (IntPtr) charTraitsWcharTPtr1 == IntPtr.Zero ? (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
      }
      *(int*) _Ppf = (int) charTraitsWcharTPtr2;
    }
    return 5;
  }

  internal static unsafe void std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 8));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* __unnamed001,
    [MarshalAs(UnmanagedType.U2)] char __unnamed002,
    tm* _Pt,
    sbyte _Specifier,
    sbyte _Modifier)
  {
    \u0024ArrayType\u0024\u0024\u0024BY04D ihcgilcCbCfxAaAa = (\u0024ArrayType\u0024\u0024\u0024BY04D) \u003CModule\u003E.\u003F\u003F_C\u0040_04IHCGILC\u0040\u003F\u0024CB\u003F\u0024CFx\u003F\u0024AA\u003F\u0024AA\u0040;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      if (_Modifier == (sbyte) 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 2) = _Specifier;
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 2) = _Modifier;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 3) = _Specifier;
      }
      uint _Count = 16;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 16U, (sbyte) 0);
      void* voidPtr1 = (void*) *(int*) ((IntPtr) obj0 + 8);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num1 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      uint num2 = \u003CModule\u003E._Strftime(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2)), num1, (sbyte*) &ihcgilcCbCfxAaAa, _Pt, voidPtr1);
      if (0U >= num2)
      {
        do
        {
          _Count <<= 1;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, _Count, (sbyte) 0);
          void* voidPtr2 = (void*) *(int*) ((IntPtr) obj0 + 8);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num3 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          num2 = \u003CModule\u003E._Strftime(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2)), num3, (sbyte*) &ihcgilcCbCfxAaAa, _Pt, voidPtr2);
        }
        while (0U >= num2);
      }
      int num4 = 0;
      uint n = num2 - 1U;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
      // ISSUE: cpblk instruction
      __memcpy(ref stdAllocatorChar4, (IntPtr) stdAllocatorCharPtr, 8);
      \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar4, 1);
      _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5 = (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E) stdAllocatorChar4;
      if (0U < n)
      {
        time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* ploc = (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 12);
        do
        {
          char _Right;
          int _Off = \u003CModule\u003E._Mbrtowc(&_Right, \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&stdAllocatorChar5), n, &num4, (_Cvtvec*) ploc);
          if (_Off != -3)
          {
            if (_Off > -3)
            {
              if (_Off >= 0)
              {
                if (_Off == 0 && _Right == char.MinValue)
                  _Off = (int) \u003CModule\u003E.strlen(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&stdAllocatorChar5)) + 1;
              }
              else
                goto label_15;
            }
          }
          else
            _Off = 0;
          n -= (uint) _Off;
          \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar5, _Off);
          \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, _Right);
        }
        while (0U < n);
        goto label_18;
label_15:
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) obj1, ref _Dest, 12);
      }
      else
        goto label_18;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
label_18:
    // ISSUE: fault handler
    try
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _Dest, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe uint std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr1 = (num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        charTraitsWcharTPtr2 = (IntPtr) charTraitsWcharTPtr1 == IntPtr.Zero ? (num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
      }
      *(int*) _Ppf = (int) charTraitsWcharTPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    bool* _Val)
  {
    int num1 = -1;
    if ((*(int*) ((IntPtr) _Iosbase + 16) & 16384) != 0)
    {
      locale locale;
      locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
      numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr;
      // ISSUE: fault handler
      try
      {
        numpunctWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_Loc);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
      }
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1, 1U, char.MinValue);
      // ISSUE: fault handler
      try
      {
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right1 = \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Efalsename(numpunctWcharTPtr, &stdAllocatorWcharT2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorWcharT1, _Right1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT2, true, 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(&stdAllocatorWcharT1, 1U, char.MinValue);
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right2 = \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Etruename(numpunctWcharTPtr, &stdAllocatorWcharT3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorWcharT1, _Right2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT3, true, 0U);
        char* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorWcharT1);
        num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 2U, _Ptr);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT1, true, 0U);
    }
    else
    {
      int num2 = 0;
      locale locale;
      locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
      \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
      sbyte* numPtr;
      uint num3;
      // ISSUE: fault handler
      try
      {
        int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
        num3 = \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
      }
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      if ((IntPtr) numPtr != ref arrayTypeBy0CaD && num2 == 0 && num3 <= 1U)
        num1 = (int) num3;
    }
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr = _State;
      int num4 = *numPtr | 1;
      *numPtr = num4;
    }
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num5 = *numPtr | 2;
      *numPtr = num5;
    }
    else
    {
      int num6 = num1 != 0 ? 1 : 0;
      *_Val = num6 != 0;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    ushort* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int traitsWcharTGetifld;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      traitsWcharTGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* s = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? (sbyte*) &arrayTypeBy0CaD : (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
    sbyte* numPtr1;
    uint num2 = \u003CModule\u003E._Stoulx(s, &numPtr1, traitsWcharTGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if (numPtr1 != s && num1 == 0 && (uint) ushort.MaxValue >= num2)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? num2 : (uint) -(int) num2;
      *_Val = (ushort) num4;
    }
    else
    {
      int* numPtr3 = _State;
      int num5 = *numPtr3 | 2;
      *numPtr3 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    uint* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int traitsWcharTGetifld;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      traitsWcharTGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* s = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? (sbyte*) &arrayTypeBy0CaD : (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
    sbyte* numPtr1;
    uint num2 = \u003CModule\u003E._Stoulx(s, &numPtr1, traitsWcharTGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if (numPtr1 != s && num1 == 0 && uint.MaxValue >= num2)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? num2 : (uint) -(int) num2;
      *_Val = num4;
    }
    else
    {
      int* numPtr3 = _State;
      int num5 = *numPtr3 | 2;
      *numPtr3 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    int* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    int num2;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num2 = \u003CModule\u003E._Stolx((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    uint* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    uint num2;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num2 = \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    long* _Val)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    long num1;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num1 = \u003CModule\u003E._strtoi64((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num2 = *numPtr2 | 1;
      *numPtr2 = num2;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD)
    {
      *_Val = num1;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    ulong* _Val)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    ulong num1;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num1 = \u003CModule\u003E._strtoui64((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num2 = *numPtr2 | 1;
      *numPtr2 = num2;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD)
    {
      *_Val = num1;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    float* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    float num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stofx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    double num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stodx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    double num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stoldx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    void** _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int traitsWcharTGetifld;
    // ISSUE: fault handler
    try
    {
      traitsWcharTGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, 2048, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    sbyte* numPtr1;
    ulong num2 = (ulong) \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr1, traitsWcharTGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *(int*) _Val = (int) num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe uint std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr1 = (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        charTraitsWcharTPtr2 = (IntPtr) charTraitsWcharTPtr1 == IntPtr.Zero ? (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
      }
      *(int*) _Ppf = (int) charTraitsWcharTPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    [MarshalAs(UnmanagedType.U1)] bool _Val)
  {
    if ((*(int*) ((IntPtr) _Iosbase + 16) & 16384) == 0)
    {
      num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
      ref ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E local = ref charTraitsWcharT1;
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2 = _Dest;
      ios_base* iosBasePtr = _Iosbase;
      int num1 = (int) _Fill;
      int num2 = _Val ? 1 : 0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*, ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E, ios_base*, ushort, int)>) *(int*) (*(int*) obj0 + 28))((int) charTraitsWcharTPtr, (ushort) ref local, (ios_base*) charTraitsWcharT2, (ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E) (IntPtr) iosBasePtr, (ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) num1, (IntPtr) num2);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, num3, 12);
      return obj1;
    }
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr;
    // ISSUE: fault handler
    try
    {
      numpunctWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1);
    // ISSUE: fault handler
    try
    {
      if (_Val)
      {
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Etruename(numpunctWcharTPtr, &stdAllocatorWcharT2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(&stdAllocatorWcharT1, _Right);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT2, true, 0U);
      }
      else
      {
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Efalsename(numpunctWcharTPtr, &stdAllocatorWcharT3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(&stdAllocatorWcharT1, _Right);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT3, true, 0U);
      }
      int num = *(int*) ((IntPtr) _Iosbase + 24);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint _Count1 = num <= 0 || (uint) num <= (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) ? 0U : (uint) (num - ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20));
      uint _Count2 = _Count1;
      if ((*(int*) ((IntPtr) _Iosbase + 16) & 448) != 64)
      {
        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT;
        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT, _Dest, _Fill, _Count1);
        // ISSUE: cpblk instruction
        __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr, 12);
        _Count2 = 0U;
      }
      char* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorWcharT1);
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(obj0, &charTraitsWcharT3, _Dest, _Ptr, (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20));
      // ISSUE: cpblk instruction
      __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr1, 12);
      *(int*) ((IntPtr) _Iosbase + 24) = 0;
      \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT1, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    int _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY05D arrayTypeBy05D;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy05D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02EAOCLKAK\u0040ld\u003F\u0024AA\u0040, _Flags), __arglist (_Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    uint _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY05D arrayTypeBy05D;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy05D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02BDDLJJBK\u0040lu\u003F\u0024AA\u0040, _Flags), __arglist ((int) _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    long _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02HIKPPMOK\u0040Ld\u003F\u0024AA\u0040, _Flags), __arglist (_Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    ulong _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02CLHGNPPK\u0040Lu\u003F\u0024AA\u0040, _Flags), __arglist ((long) _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    double _Val)
  {
    int num1 = *(int*) ((IntPtr) _Iosbase + 20);
    int num2;
    int num3;
    if (num1 <= 0 && (*(int*) ((IntPtr) _Iosbase + 16) & 8192) == 0)
    {
      num2 = 6;
    }
    else
    {
      num2 = num1;
      if (36 < num2)
      {
        num3 = 36;
        goto label_5;
      }
    }
    num3 = num2;
label_5:
    int _Trailing = num2 - num3;
    uint _Beforepoint = 0;
    uint _Afterpoint = 0;
    int num4 = *(int*) ((IntPtr) _Iosbase + 16);
    if ((num4 & 12288) == 8192)
    {
      bool flag = _Val < 0.0;
      if (flag)
        _Val = -_Val;
      if (1E+35 <= _Val)
      {
        while (_Beforepoint < 5000U)
        {
          _Val /= 10000000000.0;
          _Beforepoint += 10U;
          if (1E+35 > _Val)
            break;
        }
      }
      if (0.0 < _Val && 10 <= _Trailing)
      {
        while (_Val <= 1E-35 && _Afterpoint < 5000U)
        {
          _Val *= 10000000000.0;
          _Trailing -= 10;
          _Afterpoint += 10U;
          if (10 > _Trailing)
            break;
        }
      }
      if (flag)
        _Val = -_Val;
    }
    int _Flags = num4;
    \u0024ArrayType\u0024\u0024\u0024BY0GM\u0040D arrayTypeBy0GmD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Fput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0GmD, _Beforepoint, _Afterpoint, (uint) _Trailing, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0GmD, 108U, \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte) 0, _Flags), __arglist (num3, _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    double _Val)
  {
    int num1 = *(int*) ((IntPtr) _Iosbase + 20);
    int num2;
    int num3;
    if (num1 <= 0 && (*(int*) ((IntPtr) _Iosbase + 16) & 8192) == 0)
    {
      num2 = 6;
    }
    else
    {
      num2 = num1;
      if (36 < num2)
      {
        num3 = 36;
        goto label_5;
      }
    }
    num3 = num2;
label_5:
    int _Trailing = num2 - num3;
    uint _Beforepoint = 0;
    uint _Afterpoint = 0;
    int num4 = *(int*) ((IntPtr) _Iosbase + 16);
    if ((num4 & 12288) == 8192)
    {
      bool flag = _Val < 0.0;
      if (flag)
        _Val = -_Val;
      if (1E+35 <= _Val)
      {
        while (_Beforepoint < 5000U)
        {
          _Val /= 10000000000.0;
          _Beforepoint += 10U;
          if (1E+35 > _Val)
            break;
        }
      }
      if (0.0 < _Val && 10 <= _Trailing)
      {
        while (_Val <= 1E-35 && _Afterpoint < 5000U)
        {
          _Val *= 10000000000.0;
          _Trailing -= 10;
          _Afterpoint += 10U;
          if (10 > _Trailing)
            break;
        }
      }
      if (flag)
        _Val = -_Val;
    }
    int _Flags = num4;
    \u0024ArrayType\u0024\u0024\u0024BY0GM\u0040D arrayTypeBy0GmD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Fput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0GmD, _Beforepoint, _Afterpoint, (uint) _Trailing, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0GmD, 108U, \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte) 76, _Flags), __arglist (num3, _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    void* _Val)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02BBAHNLBA\u0040\u003F\u0024CFp\u003F\u0024AA\u0040, __arglist ((IntPtr) _Val)));
    return obj1;
  }

  internal static unsafe numpunct\u003Cwchar_t\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr1 = (numpunct\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(24U);
      numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        numpunctWcharTPtr2 = (IntPtr) numpunctWcharTPtr1 == IntPtr.Zero ? (numpunct\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(numpunctWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numpunctWcharTPtr1);
      }
      *(int*) _Ppf = (int) numpunctWcharTPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] numpunct\u003Cwchar_t\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_decimal_point(
    [In] numpunct\u003Cwchar_t\u003E* obj0)
  {
    return (char) *(ushort*) ((IntPtr) obj0 + 12);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_thousands_sep(
    [In] numpunct\u003Cwchar_t\u003E* obj0)
  {
    return (char) *(ushort*) ((IntPtr) obj0 + 14);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_grouping(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_falsename(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (char*) *(int*) ((IntPtr) obj0 + 16));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_truename(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (char*) *(int*) ((IntPtr) obj0 + 20));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe collate\u003Cwchar_t\u003E* std\u002Ecollate\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] collate\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      _Collvec collvec = \u003CModule\u003E._Getcoll();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref collvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecollate\u003Cwchar_t\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      collate\u003Cwchar_t\u003E* collateWcharTPtr1 = (collate\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(16U);
      collate\u003Cwchar_t\u003E* collateWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        collateWcharTPtr2 = (IntPtr) collateWcharTPtr1 == IntPtr.Zero ? (collate\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Ecollate\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(collateWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) collateWcharTPtr1);
      }
      *(int*) _Ppf = (int) collateWcharTPtr2;
    }
    return 1;
  }

  internal static unsafe void std\u002Ecollate\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] collate\u003Cwchar_t\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecollate\u003Cwchar_t\u003E\u002Edo_compare(
    [In] collate\u003Cwchar_t\u003E* obj0,
    char* _First1,
    char* _Last1,
    char* _First2,
    char* _Last2)
  {
    return \u003CModule\u003E._Wcscoll(_First1, _Last1, _First2, _Last2, (_Collvec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ecollate\u003Cwchar_t\u003E\u002Edo_transform(
    [In] collate\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    char* _First,
    char* _Last)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1);
      num1 = 1U;
      uint _Newsize = (uint) ((IntPtr) _Last - (IntPtr) _First >> 1);
      if (0U < _Newsize)
      {
        collate\u003Cwchar_t\u003E* ploc = (collate\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 8);
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj1 + 20);
        uint num2;
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(obj1, _Newsize, char.MinValue);
          _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
          char* chPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(obj1, &stdAllocatorWcharT1));
          uint num3 = (uint) *(int*) stdAllocatorWcharTPtr;
          _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
          _Newsize = \u003CModule\u003E._Wcsxfrm(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(obj1, &stdAllocatorWcharT2)), (char*) ((int) num3 * 2 + (IntPtr) chPtr), _First, _Last, (_Collvec*) ploc);
          num2 = (uint) *(int*) stdAllocatorWcharTPtr;
        }
        while (_Newsize > num2 && 0U < _Newsize);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(obj1, _Newsize, char.MinValue);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002Ecollate\u003Cwchar_t\u003E\u002Edo_hash(
    [In] collate\u003Cwchar_t\u003E* obj0,
    char* _First,
    char* _Last)
  {
    uint num = 0;
    if (_First != _Last)
    {
      do
      {
        num = (num >> 24 | num << 8) + (uint) *_First;
        ++_First;
      }
      while (_First != _Last);
    }
    return (int) num;
  }

  internal static unsafe messages\u003Cwchar_t\u003E* std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] messages\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emessages\u003Cwchar_t\u003E\u002E_Getcat(locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      messages\u003Cwchar_t\u003E* messagesWcharTPtr1 = (messages\u003Cwchar_t\u003E*) \u003CModule\u003E.@new(8U);
      messages\u003Cwchar_t\u003E* messagesWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        messagesWcharTPtr2 = (IntPtr) messagesWcharTPtr1 == IntPtr.Zero ? (messages\u003Cwchar_t\u003E*) 0 : \u003CModule\u003E.std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(messagesWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) messagesWcharTPtr1);
      }
      *(int*) _Ppf = (int) messagesWcharTPtr2;
    }
    return 6;
  }

  internal static unsafe void std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] messages\u003Cwchar_t\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Emessages\u003Cwchar_t\u003E\u002Edo_open(
    [In] messages\u003Cwchar_t\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _param1,
    locale* _param2)
  {
    return -1;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Emessages\u003Cwchar_t\u003E\u002Edo_get(
    [In] messages\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    int __unnamed000,
    int __unnamed001,
    int __unnamed002,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Dflt)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, _Dflt);
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe void std\u002Emessages\u003Cwchar_t\u003E\u002Edo_close(
    [In] messages\u003Cwchar_t\u003E* obj0,
    int _param1)
  {
  }

  internal static unsafe money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr1 = (money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        charTraitsWcharTPtr2 = (IntPtr) charTraitsWcharTPtr1 == IntPtr.Zero ? (money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
      }
      *(int*) _Ppf = (int) charTraitsWcharTPtr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    \u003CModule\u003E.std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(obj0, &stdAllocatorWcharT, &_First, &_Last, _Intl, _Iosbase);
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
      {
        int* numPtr = _State;
        int num = *numPtr | 1;
        *numPtr = num;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &stdAllocatorWcharT + 20) == 0)
      {
        int* numPtr = _State;
        int num = *numPtr | 2;
        *numPtr = num;
      }
      else
      {
        char ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar);
        // ISSUE: fault handler
        try
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(&stdAllocatorChar, (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 20));
          uint _Off = 0;
          if ((uint) *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorWcharT, 0U) >= (uint) ch)
          {
            char* chPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorWcharT, 0U);
            if ((int) ch + 9 >= (int) *chPtr)
              goto label_9;
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar, (sbyte) 45);
          _Off = 1U;
label_9:
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (_Off < (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 20))
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            do
            {
              char* chPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorWcharT, _Off);
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar, (sbyte) ((int) *chPtr - (int) ch + 48));
              ++_Off;
            }
            while (_Off < (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT + 20));
          }
          sbyte* s = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar);
          int num1 = 0;
          sbyte* numPtr1;
          double num2 = \u003CModule\u003E._Stoldx(s, &numPtr1, 0, &num1);
          if (numPtr1 != s && num1 == 0)
          {
            *_Val = num2;
          }
          else
          {
            int* numPtr2 = _State;
            int num3 = *numPtr2 | 2;
            *numPtr2 = num3;
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _First, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    int* _State,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Val)
  {
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    \u003CModule\u003E.std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(obj0, &stdAllocatorWcharT, &_First, &_Last, _Intl, _Iosbase);
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
      {
        int* numPtr = _State;
        int num = *numPtr | 1;
        *numPtr = num;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &stdAllocatorWcharT + 20) == 0)
      {
        int* numPtr = _State;
        int num = *numPtr | 2;
        *numPtr = num;
      }
      else
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(_Val, &stdAllocatorWcharT, 0U, uint.MaxValue);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _First, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
    return obj1;
  }

  internal static unsafe money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr1 = (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        charTraitsWcharTPtr2 = (IntPtr) charTraitsWcharTPtr1 == IntPtr.Zero ? (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
      }
      *(int*) _Ppf = (int) charTraitsWcharTPtr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    double _Val)
  {
    bool _Neg = false;
    if (_Val < 0.0)
    {
      _Neg = true;
      _Val = -_Val;
    }
    uint _Count = 0;
    if (1E+35 <= _Val)
    {
      while (_Count < 5000U)
      {
        _Val /= 10000000000.0;
        _Count += 10U;
        if (1E+35 > _Val)
          break;
      }
    }
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1);
    // ISSUE: fault handler
    try
    {
      \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040D arrayTypeBy0CiD;
      int num1 = \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0CiD, 40U, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05NNKBBLJI\u0040\u003F\u0024CF\u003F40Lf\u003F\u0024AA\u0040, __arglist (_Val));
      int num2 = 0;
      if (0 < num1)
      {
        money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Cvt = (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
        do
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(&stdAllocatorWcharT1, 1U, \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E(^(sbyte&) (num2 + (IntPtr) &arrayTypeBy0CiD), (char*) 0, (_Cvtvec*) _Cvt));
          ++num2;
        }
        while (num2 < num1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(&stdAllocatorWcharT1, _Count, \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)));
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* pThis = &stdAllocatorWcharT2;
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Val1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT2, &stdAllocatorWcharT1);
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest1;
      // ISSUE: fault handler
      try
      {
        _Dest1 = _Dest;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(obj0, obj1, _Dest1, _Intl, _Iosbase, _Fill, _Neg, _Val1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT1, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Val)
  {
    char _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
    char* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(_Val);
    bool _Neg = false;
    if ((int) *_Ptr == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 45, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
    {
      _Neg = true;
      ++_Ptr;
    }
    uint _Count = 0;
    ushort num1 = (ushort) *_Ptr;
    if ((uint) _Ch <= (uint) num1)
    {
      ushort num2 = num1;
      int num3 = (int) _Ch + 9;
      while ((int) num2 <= num3)
      {
        ++_Count;
        num2 = *(ushort*) ((int) _Count * 2 + (IntPtr) _Ptr);
        if ((uint) _Ch > (uint) num2)
          break;
      }
    }
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1, _Ptr, _Count);
    // ISSUE: fault handler
    try
    {
      if (_Count == 0U)
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(&stdAllocatorWcharT1, 1U, _Ch);
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* pThis = &stdAllocatorWcharT2;
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Val1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT2, &stdAllocatorWcharT1);
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest1;
      // ISSUE: fault handler
      try
      {
        _Dest1 = _Dest;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(obj0, obj1, _Dest1, _Intl, _Iosbase, _Fill, _Neg, _Val1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT1, true, 0U);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cwchar_t\u002C0\u003E* std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cwchar_t\u002C0\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cwchar_t\u003E*) obj0, _Lobj, _Refs, false);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      moneypunct\u003Cwchar_t\u002C0\u003E* moneypunctWcharT0Ptr1 = (moneypunct\u003Cwchar_t\u002C0\u003E*) \u003CModule\u003E.@new(52U);
      moneypunct\u003Cwchar_t\u002C0\u003E* moneypunctWcharT0Ptr2;
      // ISSUE: fault handler
      try
      {
        moneypunctWcharT0Ptr2 = (IntPtr) moneypunctWcharT0Ptr1 == IntPtr.Zero ? (moneypunct\u003Cwchar_t\u002C0\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bctor\u007D(moneypunctWcharT0Ptr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) moneypunctWcharT0Ptr1);
      }
      *(int*) _Ppf = (int) moneypunctWcharT0Ptr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bdtor\u007D(
    [In] moneypunct\u003Cwchar_t\u002C0\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D((_Mpunct\u003Cwchar_t\u003E*) obj0);
  }

  internal static unsafe void std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_decimal_point(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    return (char) *(ushort*) ((IntPtr) obj0 + 12);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_thousands_sep(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    return (char) *(ushort*) ((IntPtr) obj0 + 14);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_grouping(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_curr_symbol(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (char*) *(int*) ((IntPtr) obj0 + 16));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_positive_sign(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (char*) *(int*) ((IntPtr) obj0 + 20));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_negative_sign(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (char*) *(int*) ((IntPtr) obj0 + 24));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_frac_digits(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    return *(int*) ((IntPtr) obj0 + 28);
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_pos_format(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, (IntPtr) obj0 + 32, 4);
    return obj1;
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_neg_format(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, (IntPtr) obj0 + 36, 4);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cwchar_t\u002C1\u003E* std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cwchar_t\u002C1\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cwchar_t\u003E*) obj0, _Lobj, _Refs, true);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      moneypunct\u003Cwchar_t\u002C1\u003E* moneypunctWcharT1Ptr1 = (moneypunct\u003Cwchar_t\u002C1\u003E*) \u003CModule\u003E.@new(52U);
      moneypunct\u003Cwchar_t\u002C1\u003E* moneypunctWcharT1Ptr2;
      // ISSUE: fault handler
      try
      {
        moneypunctWcharT1Ptr2 = (IntPtr) moneypunctWcharT1Ptr1 == IntPtr.Zero ? (moneypunct\u003Cwchar_t\u002C1\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bctor\u007D(moneypunctWcharT1Ptr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) moneypunctWcharT1Ptr1);
      }
      *(int*) _Ppf = (int) moneypunctWcharT1Ptr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bdtor\u007D(
    [In] moneypunct\u003Cwchar_t\u002C1\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D((_Mpunct\u003Cwchar_t\u003E*) obj0);
  }

  internal static unsafe time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr1 = (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
      time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr2;
      // ISSUE: fault handler
      try
      {
        charTraitsWcharTPtr2 = (IntPtr) charTraitsWcharTPtr1 == IntPtr.Zero ? (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(charTraitsWcharTPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) charTraitsWcharTPtr1);
      }
      *(int*) _Ppf = (int) charTraitsWcharTPtr2;
    }
    return 5;
  }

  internal static unsafe void std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe time_base.dateorder std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_date_order(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    return (time_base.dateorder) *(int*) ((IntPtr) obj0 + 16);
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_time(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    char ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 58, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    int* numPtr1 = _State;
    int num1 = *numPtr1 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 23, (int*) ((IntPtr) _Pt + 8));
    *numPtr1 = num1;
    if (*_State == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch)
    {
      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Inc(&_First);
      int* numPtr2 = _State;
      int num2 = *numPtr2 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 59, (int*) ((IntPtr) _Pt + 4));
      *numPtr2 = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    if (*_State == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch)
    {
      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Inc(&_First);
      int* numPtr4 = _State;
      int num4 = *numPtr4 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 59, (int*) _Pt);
      *numPtr4 = num4;
    }
    else
    {
      int* numPtr5 = _State;
      int num5 = *numPtr5 | 2;
      *numPtr5 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_date(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    char ch1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    char ch2 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 58, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    char ch3 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 44, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    char ch4 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 47, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    char ch5 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 32, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    time_base.dateorder dateorder = \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edate_order(obj0);
    if (dateorder == (time_base.dateorder) 0)
      dateorder = (time_base.dateorder) 2;
    if ((uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) >= (uint) ch1 && (int) ch1 + 9 >= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First))
    {
      switch (dateorder)
      {
        case (time_base.dateorder) 1:
          int* numPtr1 = _State;
          int num1 = *numPtr1 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
          *numPtr1 = num1;
          break;
        case (time_base.dateorder) 2:
          int* numPtr2 = _State;
          int num2 = *numPtr2 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
          *numPtr2 = num2;
          *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
          break;
        default:
          istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
          istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* traitsWcharTGetYear1 = \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_year(obj0, &charTraitsWcharT1, _First, _Last, _Iosbase, _State, _Pt);
          // ISSUE: cpblk instruction
          __memcpy(ref _First, (IntPtr) traitsWcharTGetYear1, 12);
          break;
      }
    }
    else
    {
      istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2;
      istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* wcharTGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &charTraitsWcharT2, _First, _Last, _Iosbase, _State, _Pt);
      // ISSUE: cpblk instruction
      __memcpy(ref _First, (IntPtr) wcharTGetMonthname, 12);
      dateorder = (time_base.dateorder) 2;
    }
    if (*_State == 0)
    {
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5)
      {
        do
        {
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
        }
        while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5);
      }
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch2 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch3 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch4)
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5)
      {
        do
        {
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
        }
        while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5);
      }
      if (*_State == 0)
      {
        if ((uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) >= (uint) ch1 && (int) ch1 + 9 >= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First))
        {
          if (dateorder != (time_base.dateorder) 1 && dateorder != (time_base.dateorder) 3)
          {
            int* numPtr3 = _State;
            int num3 = *numPtr3 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
            *numPtr3 = num3;
          }
          else
          {
            int* numPtr4 = _State;
            int num4 = *numPtr4 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
            *numPtr4 = num4;
            *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
          }
        }
        else if (dateorder == (time_base.dateorder) 2)
        {
          int* numPtr5 = _State;
          int num5 = *numPtr5 | 2;
          *numPtr5 = num5;
        }
        else
        {
          istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3;
          istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* wcharTGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &charTraitsWcharT3, _First, _Last, _Iosbase, _State, _Pt);
          // ISSUE: cpblk instruction
          __memcpy(ref _First, (IntPtr) wcharTGetMonthname, 12);
          if (dateorder == (time_base.dateorder) 4)
            dateorder = (time_base.dateorder) 3;
        }
        if (*_State == 0)
        {
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5)
          {
            do
            {
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
            }
            while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5);
          }
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch2 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch3 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch4)
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5)
          {
            do
            {
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
            }
            while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) == (int) ch5);
          }
          if (*_State == 0)
          {
            if ((uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First) >= (uint) ch1 && (int) ch1 + 9 >= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_First))
            {
              switch (dateorder)
              {
                case (time_base.dateorder) 3:
                  int* numPtr6 = _State;
                  int num6 = *numPtr6 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
                  *numPtr6 = num6;
                  break;
                case (time_base.dateorder) 4:
                  int* numPtr7 = _State;
                  int num7 = *numPtr7 | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
                  *numPtr7 = num7;
                  *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
                  break;
                default:
                  istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT4;
                  istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* traitsWcharTGetYear2 = \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_year(obj0, &charTraitsWcharT4, _First, _Last, _Iosbase, _State, _Pt);
                  // ISSUE: cpblk instruction
                  __memcpy(ref _First, (IntPtr) traitsWcharTGetYear2, 12);
                  break;
              }
            }
            else if (dateorder != (time_base.dateorder) 4)
            {
              int* numPtr8 = _State;
              int num8 = *numPtr8 | 2;
              *numPtr8 = num8;
            }
            else
            {
              istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT5;
              istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* wcharTGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &charTraitsWcharT5, _First, _Last, _Iosbase, _State, _Pt);
              // ISSUE: cpblk instruction
              __memcpy(ref _First, (IntPtr) wcharTGetMonthname, 12);
            }
          }
        }
      }
    }
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr9 = _State;
      int num9 = *numPtr9 | 1;
      *numPtr9 = num9;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_weekday(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 0U, (char*) *(int*) ((IntPtr) obj0 + 8));
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num2 = *numPtr | 2;
      *numPtr = num2;
    }
    else
      *(int*) ((IntPtr) _Pt + 24) = num1 >> 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_monthname(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 0U, (char*) *(int*) ((IntPtr) obj0 + 12));
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num2 = *numPtr | 2;
      *numPtr = num2;
    }
    else
      *(int*) ((IntPtr) _Pt + 16) = num1 >> 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_year(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = 0;
    int* numPtr = _State;
    int num2 = *numPtr | \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 2035, &num1);
    *numPtr = num2;
    int num3 = *_State;
    if ((num3 & 2) == 0)
    {
      if (1900 <= num1)
        num1 -= 1900;
      else if (135 < num1)
        *_State = num3 | 2;
    }
    if ((*_State & 2) == 0)
      *(int*) ((IntPtr) _Pt + 20) = num1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe uint std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        traitsUnsignedShortPtr2 = (IntPtr) traitsUnsignedShortPtr1 == IntPtr.Zero ? (num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) traitsUnsignedShortPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    bool* _Val)
  {
    int num1 = -1;
    if ((*(int*) ((IntPtr) _Iosbase + 16) & 16384) != 0)
    {
      locale locale;
      locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
      numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr;
      // ISSUE: fault handler
      try
      {
        numpunctUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
      }
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort1, 1U, (ushort) 0);
      // ISSUE: fault handler
      try
      {
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right1 = \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Efalsename(numpunctUnsignedShortPtr, &allocatorUnsignedShort2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(&allocatorUnsignedShort1, _Right1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort2, true, 0U);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(&allocatorUnsignedShort1, 1U, (ushort) 0);
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort3;
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right2 = \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Etruename(numpunctUnsignedShortPtr, &allocatorUnsignedShort3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(&allocatorUnsignedShort1, _Right2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort3, true, 0U);
        ushort* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(&allocatorUnsignedShort1);
        num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 2U, _Ptr);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort1, true, 0U);
    }
    else
    {
      int num2 = 0;
      locale locale;
      locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
      \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
      sbyte* numPtr;
      uint num3;
      // ISSUE: fault handler
      try
      {
        int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
        num3 = \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
      }
      \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      if ((IntPtr) numPtr != ref arrayTypeBy0CaD && num2 == 0 && num3 <= 1U)
        num1 = (int) num3;
    }
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr = _State;
      int num4 = *numPtr | 1;
      *numPtr = num4;
    }
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num5 = *numPtr | 2;
      *numPtr = num5;
    }
    else
    {
      int num6 = num1 != 0 ? 1 : 0;
      *_Val = num6 != 0;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    ushort* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int unsignedShortGetifld;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      unsignedShortGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* s = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? (sbyte*) &arrayTypeBy0CaD : (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
    sbyte* numPtr1;
    uint num2 = \u003CModule\u003E._Stoulx(s, &numPtr1, unsignedShortGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if (numPtr1 != s && num1 == 0 && (uint) ushort.MaxValue >= num2)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? num2 : (uint) -(int) num2;
      *_Val = (ushort) num4;
    }
    else
    {
      int* numPtr3 = _State;
      int num5 = *numPtr3 | 2;
      *numPtr3 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    uint* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int unsignedShortGetifld;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      unsignedShortGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    sbyte* s = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? (sbyte*) &arrayTypeBy0CaD : (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
    sbyte* numPtr1;
    uint num2 = \u003CModule\u003E._Stoulx(s, &numPtr1, unsignedShortGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if (numPtr1 != s && num1 == 0 && uint.MaxValue >= num2)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num4 = ^(sbyte&) ref arrayTypeBy0CaD != (sbyte) 45 ? num2 : (uint) -(int) num2;
      *_Val = num4;
    }
    else
    {
      int* numPtr3 = _State;
      int num5 = *numPtr3 | 2;
      *numPtr3 = num5;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    int* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    int num2;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num2 = \u003CModule\u003E._Stolx((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    uint* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    uint num2;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num2 = \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    long* _Val)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    long num1;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num1 = \u003CModule\u003E._strtoi64((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num2 = *numPtr2 | 1;
      *numPtr2 = num2;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD)
    {
      *_Val = num1;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    ulong* _Val)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1;
    ulong num1;
    // ISSUE: fault handler
    try
    {
      int _Basefield = *(int*) ((IntPtr) _Iosbase + 16);
      num1 = \u003CModule\u003E._strtoui64((sbyte*) &arrayTypeBy0CaD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, _Basefield, _Loc));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num2 = *numPtr2 | 1;
      *numPtr2 = num2;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD)
    {
      *_Val = num1;
    }
    else
    {
      int* numPtr3 = _State;
      int num3 = *numPtr3 | 2;
      *numPtr3 = num3;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    float* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    float num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stofx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    double num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stodx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    sbyte* numPtr1;
    double num2;
    // ISSUE: fault handler
    try
    {
      num2 = \u003CModule\u003E._Stoldx((sbyte*) &arrayTypeBy0DmD, &numPtr1, \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(obj0, (sbyte*) &arrayTypeBy0DmD, &_First, &_Last, _Loc), &num1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0DmD && num1 == 0)
    {
      *_Val = num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    void** _Val)
  {
    int num1 = 0;
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    int unsignedShortGetifld;
    // ISSUE: fault handler
    try
    {
      unsignedShortGetifld = \u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(obj0, (sbyte*) &arrayTypeBy0CaD, &_First, &_Last, 2048, _Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    sbyte* numPtr1;
    ulong num2 = (ulong) \u003CModule\u003E._Stoulx((sbyte*) &arrayTypeBy0CaD, &numPtr1, unsignedShortGetifld, &num1);
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr2 = _State;
      int num3 = *numPtr2 | 1;
      *numPtr2 = num3;
    }
    if ((IntPtr) numPtr1 != ref arrayTypeBy0CaD && num1 == 0)
    {
      *(int*) _Val = (int) num2;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe uint std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        traitsUnsignedShortPtr2 = (IntPtr) traitsUnsignedShortPtr1 == IntPtr.Zero ? (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) traitsUnsignedShortPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    [MarshalAs(UnmanagedType.U1)] bool _Val)
  {
    if ((*(int*) ((IntPtr) _Iosbase + 16) & 16384) == 0)
    {
      num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
      ref ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref traitsUnsignedShort1;
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2 = _Dest;
      ios_base* iosBasePtr = _Iosbase;
      int num1 = (int) _Fill;
      int num2 = _Val ? 1 : 0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num3 = (int) __calli((__FnPtr<ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*, ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E, ios_base*, ushort, int)>) *(int*) (*(int*) obj0 + 28))((int) traitsUnsignedShortPtr, (ushort) ref local, (ios_base*) traitsUnsignedShort2, (ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E) (IntPtr) iosBasePtr, (ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) num1, (IntPtr) num2);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, num3, 12);
      return obj1;
    }
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr;
    // ISSUE: fault handler
    try
    {
      numpunctUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort1);
    // ISSUE: fault handler
    try
    {
      if (_Val)
      {
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Etruename(numpunctUnsignedShortPtr, &allocatorUnsignedShort2);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(&allocatorUnsignedShort1, _Right);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort2, true, 0U);
      }
      else
      {
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort3;
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Efalsename(numpunctUnsignedShortPtr, &allocatorUnsignedShort3);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(&allocatorUnsignedShort1, _Right);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort3);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort3, true, 0U);
      }
      int num = *(int*) ((IntPtr) _Iosbase + 24);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint _Count1 = num <= 0 || (uint) num <= (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort1 + 20) ? 0U : (uint) (num - ^(int&) ((IntPtr) &allocatorUnsignedShort1 + 20));
      uint _Count2 = _Count1;
      if ((*(int*) ((IntPtr) _Iosbase + 16) & 448) != 64)
      {
        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort;
        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort, _Dest, _Fill, _Count1);
        // ISSUE: cpblk instruction
        __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr, 12);
        _Count2 = 0U;
      }
      ushort* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(&allocatorUnsignedShort1);
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(obj0, &traitsUnsignedShort3, _Dest, _Ptr, (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort1 + 20));
      // ISSUE: cpblk instruction
      __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr1, 12);
      *(int*) ((IntPtr) _Iosbase + 24) = 0;
      \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort1, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    int _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY05D arrayTypeBy05D;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy05D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02EAOCLKAK\u0040ld\u003F\u0024AA\u0040, _Flags), __arglist (_Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    uint _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY05D arrayTypeBy05D;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy05D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02BDDLJJBK\u0040lu\u003F\u0024AA\u0040, _Flags), __arglist ((int) _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    long _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02HIKPPMOK\u0040Ld\u003F\u0024AA\u0040, _Flags), __arglist (_Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    ulong _Val)
  {
    int _Flags = *(int*) ((IntPtr) _Iosbase + 16);
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02CLHGNPPK\u0040Lu\u003F\u0024AA\u0040, _Flags), __arglist ((long) _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    double _Val)
  {
    int num1 = *(int*) ((IntPtr) _Iosbase + 20);
    int num2;
    int num3;
    if (num1 <= 0 && (*(int*) ((IntPtr) _Iosbase + 16) & 8192) == 0)
    {
      num2 = 6;
    }
    else
    {
      num2 = num1;
      if (36 < num2)
      {
        num3 = 36;
        goto label_5;
      }
    }
    num3 = num2;
label_5:
    int _Trailing = num2 - num3;
    uint _Beforepoint = 0;
    uint _Afterpoint = 0;
    int num4 = *(int*) ((IntPtr) _Iosbase + 16);
    if ((num4 & 12288) == 8192)
    {
      bool flag = _Val < 0.0;
      if (flag)
        _Val = -_Val;
      if (1E+35 <= _Val)
      {
        while (_Beforepoint < 5000U)
        {
          _Val /= 10000000000.0;
          _Beforepoint += 10U;
          if (1E+35 > _Val)
            break;
        }
      }
      if (0.0 < _Val && 10 <= _Trailing)
      {
        while (_Val <= 1E-35 && _Afterpoint < 5000U)
        {
          _Val *= 10000000000.0;
          _Trailing -= 10;
          _Afterpoint += 10U;
          if (10 > _Trailing)
            break;
        }
      }
      if (flag)
        _Val = -_Val;
    }
    int _Flags = num4;
    \u0024ArrayType\u0024\u0024\u0024BY0GM\u0040D arrayTypeBy0GmD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Fput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0GmD, _Beforepoint, _Afterpoint, (uint) _Trailing, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0GmD, 108U, \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte) 0, _Flags), __arglist (num3, _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    double _Val)
  {
    int num1 = *(int*) ((IntPtr) _Iosbase + 20);
    int num2;
    int num3;
    if (num1 <= 0 && (*(int*) ((IntPtr) _Iosbase + 16) & 8192) == 0)
    {
      num2 = 6;
    }
    else
    {
      num2 = num1;
      if (36 < num2)
      {
        num3 = 36;
        goto label_5;
      }
    }
    num3 = num2;
label_5:
    int _Trailing = num2 - num3;
    uint _Beforepoint = 0;
    uint _Afterpoint = 0;
    int num4 = *(int*) ((IntPtr) _Iosbase + 16);
    if ((num4 & 12288) == 8192)
    {
      bool flag = _Val < 0.0;
      if (flag)
        _Val = -_Val;
      if (1E+35 <= _Val)
      {
        while (_Beforepoint < 5000U)
        {
          _Val /= 10000000000.0;
          _Beforepoint += 10U;
          if (1E+35 > _Val)
            break;
        }
      }
      if (0.0 < _Val && 10 <= _Trailing)
      {
        while (_Val <= 1E-35 && _Afterpoint < 5000U)
        {
          _Val *= 10000000000.0;
          _Trailing -= 10;
          _Afterpoint += 10U;
          if (10 > _Trailing)
            break;
        }
      }
      if (flag)
        _Val = -_Val;
    }
    int _Flags = num4;
    \u0024ArrayType\u0024\u0024\u0024BY0GM\u0040D arrayTypeBy0GmD;
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Fput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0GmD, _Beforepoint, _Afterpoint, (uint) _Trailing, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0GmD, 108U, \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(obj0, (sbyte*) &arrayTypeBy07D, (sbyte) 76, _Flags), __arglist (num3, _Val)));
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    void* _Val)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Iput(obj0, obj1, _Dest, _Iosbase, _Fill, (sbyte*) &arrayTypeBy0EaD, (uint) \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0EaD, 64U, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_02BBAHNLBA\u0040\u003F\u0024CFp\u003F\u0024AA\u0040, __arglist ((IntPtr) _Val)));
    return obj1;
  }

  internal static unsafe numpunct\u003Cunsigned\u0020short\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr1 = (numpunct\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(24U);
      numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        numpunctUnsignedShortPtr2 = (IntPtr) numpunctUnsignedShortPtr1 == IntPtr.Zero ? (numpunct\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(numpunctUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) numpunctUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) numpunctUnsignedShortPtr2;
    }
    return 4;
  }

  internal static unsafe void std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ushort std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_decimal_point(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    return *(ushort*) ((IntPtr) obj0 + 12);
  }

  internal static unsafe ushort std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_thousands_sep(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    return *(ushort*) ((IntPtr) obj0 + 14);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_grouping(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_falsename(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (ushort*) *(int*) ((IntPtr) obj0 + 16));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_truename(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (ushort*) *(int*) ((IntPtr) obj0 + 20));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe collate\u003Cunsigned\u0020short\u003E* std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      _Collvec collvec = \u003CModule\u003E._Getcoll();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref collvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      collate\u003Cunsigned\u0020short\u003E* collateUnsignedShortPtr1 = (collate\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(16U);
      collate\u003Cunsigned\u0020short\u003E* collateUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        collateUnsignedShortPtr2 = (IntPtr) collateUnsignedShortPtr1 == IntPtr.Zero ? (collate\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(collateUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) collateUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) collateUnsignedShortPtr2;
    }
    return 1;
  }

  internal static unsafe void std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002Edo_compare(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First1,
    ushort* _Last1,
    ushort* _First2,
    ushort* _Last2)
  {
    return \u003CModule\u003E.std\u002E_LStrcoll\u003Cunsigned\u0020short\u003E(_First1, _Last1, _First2, _Last2, (_Collvec*) ((IntPtr) obj0 + 8));
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002Edo_transform(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ushort* _First,
    ushort* _Last)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1);
      num1 = 1U;
      uint _Newsize = (uint) ((IntPtr) _Last - (IntPtr) _First >> 1);
      if (0U < _Newsize)
      {
        collate\u003Cunsigned\u0020short\u003E* __unnamed004 = (collate\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 8);
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr = (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj1 + 20);
        uint num2;
        do
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eresize(obj1, _Newsize, (ushort) 0);
          _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
          ushort* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(obj1, &allocatorUnsignedShort1));
          uint num3 = (uint) *(int*) allocatorUnsignedShortPtr;
          _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
          _Newsize = \u003CModule\u003E.std\u002E_LStrxfrm\u003Cunsigned\u0020short\u003E(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(obj1, &allocatorUnsignedShort2)), (ushort*) ((int) num3 * 2 + (IntPtr) numPtr), _First, _Last, (_Collvec*) __unnamed004);
          num2 = (uint) *(int*) allocatorUnsignedShortPtr;
        }
        while (_Newsize > num2 && 0U < _Newsize);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eresize(obj1, _Newsize, (ushort) 0);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num4 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002Edo_hash(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0,
    ushort* _First,
    ushort* _Last)
  {
    uint num = 0;
    if (_First != _Last)
    {
      do
      {
        num = (num >> 24 | num << 8) + (uint) *_First;
        ++_First;
      }
      while (_First != _Last);
    }
    return (int) num;
  }

  internal static unsafe messages\u003Cunsigned\u0020short\u003E* std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      messages\u003Cunsigned\u0020short\u003E* messagesUnsignedShortPtr1 = (messages\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.@new(8U);
      messages\u003Cunsigned\u0020short\u003E* messagesUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        messagesUnsignedShortPtr2 = (IntPtr) messagesUnsignedShortPtr1 == IntPtr.Zero ? (messages\u003Cunsigned\u0020short\u003E*) 0 : \u003CModule\u003E.std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(messagesUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) messagesUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) messagesUnsignedShortPtr2;
    }
    return 6;
  }

  internal static unsafe void std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe int std\u002Emessages\u003Cunsigned\u0020short\u003E\u002Edo_open(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0,
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* _param1,
    locale* _param2)
  {
    return -1;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emessages\u003Cunsigned\u0020short\u003E\u002Edo_get(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    int __unnamed000,
    int __unnamed001,
    int __unnamed002,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Dflt)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, _Dflt);
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe void std\u002Emessages\u003Cunsigned\u0020short\u003E\u002Edo_close(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0,
    int _param1)
  {
  }

  internal static unsafe money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        traitsUnsignedShortPtr2 = (IntPtr) traitsUnsignedShortPtr1 == IntPtr.Zero ? (money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) traitsUnsignedShortPtr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    int* _State,
    double* _Val)
  {
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    \u003CModule\u003E.std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(obj0, &allocatorUnsignedShort, &_First, &_Last, _Intl, _Iosbase);
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
      {
        int* numPtr = _State;
        int num = *numPtr | 1;
        *numPtr = num;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &allocatorUnsignedShort + 20) == 0)
      {
        int* numPtr = _State;
        int num = *numPtr | 2;
        *numPtr = num;
      }
      else
      {
        ushort num1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar);
        // ISSUE: fault handler
        try
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ereserve(&stdAllocatorChar, (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort + 20));
          uint _Off = 0;
          if ((uint) *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u005B\u005D(&allocatorUnsignedShort, 0U) >= (uint) num1)
          {
            ushort* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u005B\u005D(&allocatorUnsignedShort, 0U);
            if ((int) num1 + 9 >= (int) *numPtr)
              goto label_9;
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar, (sbyte) 45);
          _Off = 1U;
label_9:
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (_Off < (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort + 20))
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            do
            {
              ushort* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u005B\u005D(&allocatorUnsignedShort, _Off);
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar, (sbyte) ((int) *numPtr - (int) num1 + 48));
              ++_Off;
            }
            while (_Off < (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort + 20));
          }
          sbyte* s = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar);
          int num2 = 0;
          sbyte* numPtr1;
          double num3 = \u003CModule\u003E._Stoldx(s, &numPtr1, 0, &num2);
          if (numPtr1 != s && num2 == 0)
          {
            *_Val = num3;
          }
          else
          {
            int* numPtr2 = _State;
            int num4 = *numPtr2 | 2;
            *numPtr2 = num4;
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      }
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _First, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    int* _State,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Val)
  {
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    \u003CModule\u003E.std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(obj0, &allocatorUnsignedShort, &_First, &_Last, _Intl, _Iosbase);
    // ISSUE: fault handler
    try
    {
      if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
      {
        int* numPtr = _State;
        int num = *numPtr | 1;
        *numPtr = num;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &allocatorUnsignedShort + 20) == 0)
      {
        int* numPtr = _State;
        int num = *numPtr | 2;
        *numPtr = num;
      }
      else
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(_Val, &allocatorUnsignedShort, 0U, uint.MaxValue);
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _First, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
    return obj1;
  }

  internal static unsafe money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(16U);
      money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        traitsUnsignedShortPtr2 = (IntPtr) traitsUnsignedShortPtr1 == IntPtr.Zero ? (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) traitsUnsignedShortPtr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    ushort _Fill,
    double _Val)
  {
    bool _Neg = false;
    if (_Val < 0.0)
    {
      _Neg = true;
      _Val = -_Val;
    }
    uint _Count = 0;
    if (1E+35 <= _Val)
    {
      while (_Count < 5000U)
      {
        _Val /= 10000000000.0;
        _Count += 10U;
        if (1E+35 > _Val)
          break;
      }
    }
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort1);
    // ISSUE: fault handler
    try
    {
      \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040D arrayTypeBy0CiD;
      int num1 = \u003CModule\u003E.sprintf_s((sbyte*) &arrayTypeBy0CiD, 40U, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05NNKBBLJI\u0040\u003F\u0024CF\u003F40Lf\u003F\u0024AA\u0040, __arglist (_Val));
      int num2 = 0;
      if (0 < num1)
      {
        money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Cvt = (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
        do
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(&allocatorUnsignedShort1, 1U, \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(^(sbyte&) (num2 + (IntPtr) &arrayTypeBy0CiD), (ushort*) 0, (_Cvtvec*) _Cvt));
          ++num2;
        }
        while (num2 < num1);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(&allocatorUnsignedShort1, _Count, \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)));
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* pThis = &allocatorUnsignedShort2;
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Val1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort2, &allocatorUnsignedShort1);
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest1;
      // ISSUE: fault handler
      try
      {
        _Dest1 = _Dest;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(obj0, obj1, _Dest1, _Intl, _Iosbase, _Fill, _Neg, _Val1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort1, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    ushort _Fill,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Val)
  {
    ushort _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
    ushort* _Ptr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(_Val);
    bool _Neg = false;
    if ((int) *_Ptr == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 45, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
    {
      _Neg = true;
      ++_Ptr;
    }
    uint _Count = 0;
    ushort num1 = *_Ptr;
    if ((uint) _Ch <= (uint) num1)
    {
      ushort num2 = num1;
      int num3 = (int) _Ch + 9;
      while ((int) num2 <= num3)
      {
        ++_Count;
        num2 = *(ushort*) ((int) _Count * 2 + (IntPtr) _Ptr);
        if ((uint) _Ch > (uint) num2)
          break;
      }
    }
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort1, _Ptr, _Count);
    // ISSUE: fault handler
    try
    {
      if (_Count == 0U)
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(&allocatorUnsignedShort1, 1U, _Ch);
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* pThis = &allocatorUnsignedShort2;
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Val1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort2, &allocatorUnsignedShort1);
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest1;
      // ISSUE: fault handler
      try
      {
        _Dest1 = _Dest;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) pThis);
      }
      \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(obj0, obj1, _Dest1, _Intl, _Iosbase, _Fill, _Neg, _Val1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort1, true, 0U);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cunsigned\u0020short\u002C0\u003E* std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cunsigned\u0020short\u002C0\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cunsigned\u0020short\u003E*) obj0, _Lobj, _Refs, false);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      moneypunct\u003Cunsigned\u0020short\u002C0\u003E* moneypunctUnsignedShort0Ptr1 = (moneypunct\u003Cunsigned\u0020short\u002C0\u003E*) \u003CModule\u003E.@new(52U);
      moneypunct\u003Cunsigned\u0020short\u002C0\u003E* moneypunctUnsignedShort0Ptr2;
      // ISSUE: fault handler
      try
      {
        moneypunctUnsignedShort0Ptr2 = (IntPtr) moneypunctUnsignedShort0Ptr1 == IntPtr.Zero ? (moneypunct\u003Cunsigned\u0020short\u002C0\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bctor\u007D(moneypunctUnsignedShort0Ptr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) moneypunctUnsignedShort0Ptr1);
      }
      *(int*) _Ppf = (int) moneypunctUnsignedShort0Ptr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bdtor\u007D(
    [In] moneypunct\u003Cunsigned\u0020short\u002C0\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D((_Mpunct\u003Cunsigned\u0020short\u003E*) obj0);
  }

  internal static unsafe void std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ushort std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_decimal_point(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    return *(ushort*) ((IntPtr) obj0 + 12);
  }

  internal static unsafe ushort std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_thousands_sep(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    return *(ushort*) ((IntPtr) obj0 + 14);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_grouping(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (sbyte*) *(int*) ((IntPtr) obj0 + 8));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_curr_symbol(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (ushort*) *(int*) ((IntPtr) obj0 + 16));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_positive_sign(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (ushort*) *(int*) ((IntPtr) obj0 + 20));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_negative_sign(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (ushort*) *(int*) ((IntPtr) obj0 + 24));
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_frac_digits(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    return *(int*) ((IntPtr) obj0 + 28);
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_pos_format(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, (IntPtr) obj0 + 32, 4);
    return obj1;
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_neg_format(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, (IntPtr) obj0 + 36, 4);
    return obj1;
  }

  internal static unsafe moneypunct\u003Cunsigned\u0020short\u002C1\u003E* std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cunsigned\u0020short\u002C1\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cunsigned\u0020short\u003E*) obj0, _Lobj, _Refs, true);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      moneypunct\u003Cunsigned\u0020short\u002C1\u003E* moneypunctUnsignedShort1Ptr1 = (moneypunct\u003Cunsigned\u0020short\u002C1\u003E*) \u003CModule\u003E.@new(52U);
      moneypunct\u003Cunsigned\u0020short\u002C1\u003E* moneypunctUnsignedShort1Ptr2;
      // ISSUE: fault handler
      try
      {
        moneypunctUnsignedShort1Ptr2 = (IntPtr) moneypunctUnsignedShort1Ptr1 == IntPtr.Zero ? (moneypunct\u003Cunsigned\u0020short\u002C1\u003E*) 0 : \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bctor\u007D(moneypunctUnsignedShort1Ptr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) moneypunctUnsignedShort1Ptr1);
      }
      *(int*) _Ppf = (int) moneypunctUnsignedShort1Ptr2;
    }
    return 3;
  }

  internal static unsafe void std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bdtor\u007D(
    [In] moneypunct\u003Cunsigned\u0020short\u002C1\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 4);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D((_Mpunct\u003Cunsigned\u0020short\u003E*) obj0);
  }

  internal static unsafe time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(28U);
      time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        traitsUnsignedShortPtr2 = (IntPtr) traitsUnsignedShortPtr1 == IntPtr.Zero ? (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) traitsUnsignedShortPtr2;
    }
    return 5;
  }

  internal static unsafe void std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(obj0);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe time_base.dateorder std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_date_order(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    return (time_base.dateorder) *(int*) ((IntPtr) obj0 + 16);
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_time(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    ushort num1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 58, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    int* numPtr1 = _State;
    int num2 = *numPtr1 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 23, (int*) ((IntPtr) _Pt + 8));
    *numPtr1 = num2;
    if (*_State == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num1)
    {
      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inc(&_First);
      int* numPtr2 = _State;
      int num3 = *numPtr2 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 59, (int*) ((IntPtr) _Pt + 4));
      *numPtr2 = num3;
    }
    else
    {
      int* numPtr3 = _State;
      int num4 = *numPtr3 | 2;
      *numPtr3 = num4;
    }
    if (*_State == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num1)
    {
      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inc(&_First);
      int* numPtr4 = _State;
      int num5 = *numPtr4 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 59, (int*) _Pt);
      *numPtr4 = num5;
    }
    else
    {
      int* numPtr5 = _State;
      int num6 = *numPtr5 | 2;
      *numPtr5 = num6;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_date(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    ushort num1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    ushort num2 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 58, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    ushort num3 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 44, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    ushort num4 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 47, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    ushort num5 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 32, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    time_base.dateorder dateorder = \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edate_order(obj0);
    if (dateorder == (time_base.dateorder) 0)
      dateorder = (time_base.dateorder) 2;
    if ((uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) >= (uint) num1 && (int) num1 + 9 >= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First))
    {
      switch (dateorder)
      {
        case (time_base.dateorder) 1:
          int* numPtr1 = _State;
          int num6 = *numPtr1 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
          *numPtr1 = num6;
          break;
        case (time_base.dateorder) 2:
          int* numPtr2 = _State;
          int num7 = *numPtr2 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
          *numPtr2 = num7;
          *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
          break;
        default:
          istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
          istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* unsignedShortGetYear1 = \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_year(obj0, &traitsUnsignedShort1, _First, _Last, _Iosbase, _State, _Pt);
          // ISSUE: cpblk instruction
          __memcpy(ref _First, (IntPtr) unsignedShortGetYear1, 12);
          break;
      }
    }
    else
    {
      istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2;
      istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* shortGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &traitsUnsignedShort2, _First, _Last, _Iosbase, _State, _Pt);
      // ISSUE: cpblk instruction
      __memcpy(ref _First, (IntPtr) shortGetMonthname, 12);
      dateorder = (time_base.dateorder) 2;
    }
    if (*_State == 0)
    {
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5)
      {
        do
        {
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
        }
        while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5);
      }
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num2 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num3 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num4)
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5)
      {
        do
        {
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
        }
        while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5);
      }
      if (*_State == 0)
      {
        if ((uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) >= (uint) num1 && (int) num1 + 9 >= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First))
        {
          if (dateorder != (time_base.dateorder) 1 && dateorder != (time_base.dateorder) 3)
          {
            int* numPtr3 = _State;
            int num8 = *numPtr3 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
            *numPtr3 = num8;
          }
          else
          {
            int* numPtr4 = _State;
            int num9 = *numPtr4 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
            *numPtr4 = num9;
            *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
          }
        }
        else if (dateorder == (time_base.dateorder) 2)
        {
          int* numPtr5 = _State;
          int num10 = *numPtr5 | 2;
          *numPtr5 = num10;
        }
        else
        {
          istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3;
          istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* shortGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &traitsUnsignedShort3, _First, _Last, _Iosbase, _State, _Pt);
          // ISSUE: cpblk instruction
          __memcpy(ref _First, (IntPtr) shortGetMonthname, 12);
          if (dateorder == (time_base.dateorder) 4)
            dateorder = (time_base.dateorder) 3;
        }
        if (*_State == 0)
        {
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5)
          {
            do
            {
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
            }
            while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5);
          }
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num2 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num3 || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num4)
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5)
          {
            do
            {
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_First);
            }
            while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) == (int) num5);
          }
          if (*_State == 0)
          {
            if ((uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First) >= (uint) num1 && (int) num1 + 9 >= (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_First))
            {
              switch (dateorder)
              {
                case (time_base.dateorder) 3:
                  int* numPtr6 = _State;
                  int num11 = *numPtr6 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 31, (int*) ((IntPtr) _Pt + 12));
                  *numPtr6 = num11;
                  break;
                case (time_base.dateorder) 4:
                  int* numPtr7 = _State;
                  int num12 = *numPtr7 | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 1, 12, (int*) ((IntPtr) _Pt + 16));
                  *numPtr7 = num12;
                  *(int*) ((IntPtr) _Pt + 16) = *(int*) ((IntPtr) _Pt + 16) - 1;
                  break;
                default:
                  istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort4;
                  istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* unsignedShortGetYear2 = \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_year(obj0, &traitsUnsignedShort4, _First, _Last, _Iosbase, _State, _Pt);
                  // ISSUE: cpblk instruction
                  __memcpy(ref _First, (IntPtr) unsignedShortGetYear2, 12);
                  break;
              }
            }
            else if (dateorder != (time_base.dateorder) 4)
            {
              int* numPtr8 = _State;
              int num13 = *numPtr8 | 2;
              *numPtr8 = num13;
            }
            else
            {
              istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort5;
              istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* shortGetMonthname = \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(obj0, &traitsUnsignedShort5, _First, _Last, _Iosbase, _State, _Pt);
              // ISSUE: cpblk instruction
              __memcpy(ref _First, (IntPtr) shortGetMonthname, 12);
            }
          }
        }
      }
    }
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(&_First, &_Last))
    {
      int* numPtr9 = _State;
      int num14 = *numPtr9 | 1;
      *numPtr9 = num14;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_weekday(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 0U, (ushort*) *(int*) ((IntPtr) obj0 + 8));
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num2 = *numPtr | 2;
      *numPtr = num2;
    }
    else
      *(int*) ((IntPtr) _Pt + 24) = num1 >> 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_monthname(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = \u003CModule\u003E.std\u002E_Getloctxt\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E(&_First, &_Last, 0U, (ushort*) *(int*) ((IntPtr) obj0 + 12));
    if (num1 < 0)
    {
      int* numPtr = _State;
      int num2 = *numPtr | 2;
      *numPtr = num2;
    }
    else
      *(int*) ((IntPtr) _Pt + 16) = num1 >> 1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_year(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* __unnamed002,
    int* _State,
    tm* _Pt)
  {
    int num1 = 0;
    int* numPtr = _State;
    int num2 = *numPtr | \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(obj0, &_First, &_Last, 0, 2035, &num1);
    *numPtr = num2;
    int num3 = *_State;
    if ((num3 & 2) == 0)
    {
      if (1900 <= num1)
        num1 -= 1900;
      else if (135 < num1)
        *_State = num3 | 2;
    }
    if ((*_State & 2) == 0)
      *(int*) ((IntPtr) _Pt + 20) = num1;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _First, 12);
    return obj1;
  }

  internal static unsafe time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, _Lobj);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe uint std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(
    locale.facet** _Ppf)
  {
    if ((IntPtr) _Ppf != IntPtr.Zero && *(int*) _Ppf == 0)
    {
      time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr1 = (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) \u003CModule\u003E.@new(20U);
      time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr2;
      // ISSUE: fault handler
      try
      {
        traitsUnsignedShortPtr2 = (IntPtr) traitsUnsignedShortPtr1 == IntPtr.Zero ? (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) 0 : \u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(traitsUnsignedShortPtr1, 0U);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) traitsUnsignedShortPtr1);
      }
      *(int*) _Ppf = (int) traitsUnsignedShortPtr2;
    }
    return 5;
  }

  internal static unsafe void std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.free((void*) *(int*) ((IntPtr) obj0 + 8));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put(
    [In] time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* __unnamed001,
    ushort __unnamed002,
    tm* _Pt,
    sbyte _Specifier,
    sbyte _Modifier)
  {
    \u0024ArrayType\u0024\u0024\u0024BY04D ihcgilcCbCfxAaAa = (\u0024ArrayType\u0024\u0024\u0024BY04D) \u003CModule\u003E.\u003F\u003F_C\u0040_04IHCGILC\u0040\u003F\u0024CB\u003F\u0024CFx\u003F\u0024AA\u003F\u0024AA\u0040;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      if (_Modifier == (sbyte) 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 2) = _Specifier;
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 2) = _Modifier;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &ihcgilcCbCfxAaAa + 3) = _Specifier;
      }
      uint _Count = 16;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, 16U, (sbyte) 0);
      void* voidPtr1 = (void*) *(int*) ((IntPtr) obj0 + 8);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num1 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      uint num2 = \u003CModule\u003E._Strftime(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2)), num1, (sbyte*) &ihcgilcCbCfxAaAa, _Pt, voidPtr1);
      if (0U >= num2)
      {
        do
        {
          _Count <<= 1;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar1, _Count, (sbyte) 0);
          void* voidPtr2 = (void*) *(int*) ((IntPtr) obj0 + 8);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num3 = (uint) ^(int&) ((IntPtr) &stdAllocatorChar1 + 20);
          num2 = \u003CModule\u003E._Strftime(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar2)), num3, (sbyte*) &ihcgilcCbCfxAaAa, _Pt, voidPtr2);
        }
        while (0U >= num2);
      }
      int num4 = 0;
      uint n = num2 - 1U;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar3;
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* stdAllocatorCharPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ebegin(&stdAllocatorChar1, &stdAllocatorChar3);
      _String_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar4;
      // ISSUE: cpblk instruction
      __memcpy(ref stdAllocatorChar4, (IntPtr) stdAllocatorCharPtr, 8);
      \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) &stdAllocatorChar4, 1);
      _String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar5 = (_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E) stdAllocatorChar4;
      if (0U < n)
      {
        time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* ploc = (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 12);
        do
        {
          char _Right;
          int _Off = \u003CModule\u003E._Mbrtowc(&_Right, \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&stdAllocatorChar5), n, &num4, (_Cvtvec*) ploc);
          if (_Off != -3)
          {
            if (_Off > -3)
            {
              if (_Off >= 0)
              {
                if (_Off == 0 && _Right == char.MinValue)
                  _Off = (int) \u003CModule\u003E.strlen(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002A(&stdAllocatorChar5)) + 1;
              }
              else
                goto label_15;
            }
          }
          else
            _Off = 0;
          n -= (uint) _Off;
          \u003CModule\u003E.std\u002E_String_const_iterator\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u002B\u003D(&stdAllocatorChar5, _Off);
          \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, (ushort) _Right);
        }
        while (0U < n);
        goto label_18;
label_15:
        // ISSUE: cpblk instruction
        __memcpy((IntPtr) obj1, ref _Dest, 12);
      }
      else
        goto label_18;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
label_18:
    // ISSUE: fault handler
    try
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) obj1, ref _Dest, 12);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe void* std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 20U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    \u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* wcharTVecDelDtor = (num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) wcharTVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) wcharTVecDelDtor);
      return (void*) wcharTVecDelDtor;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enumpunct\u003Cwchar_t\u003E\u002E__vecDelDtor(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = (numpunct\u003Cwchar_t\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24U, *(int*) numpunctWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) numpunctWcharTPtr);
      return (void*) numpunctWcharTPtr;
    }
    \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ecollate\u003Cwchar_t\u003E\u002E__vecDelDtor(
    [In] collate\u003Cwchar_t\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      collate\u003Cwchar_t\u003E* collateWcharTPtr = (collate\u003Cwchar_t\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) collateWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecollate\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) collateWcharTPtr);
      return (void*) collateWcharTPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emessages\u003Cwchar_t\u003E\u002E__vecDelDtor(
    [In] messages\u003Cwchar_t\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      messages\u003Cwchar_t\u003E* messagesWcharTPtr = (messages\u003Cwchar_t\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) messagesWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) messagesWcharTPtr);
      return (void*) messagesWcharTPtr;
    }
    \u003CModule\u003E.std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* wcharTVecDelDtor = (money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) wcharTVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) wcharTVecDelDtor);
      return (void*) wcharTVecDelDtor;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) charTraitsWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) charTraitsWcharTPtr);
      return (void*) charTraitsWcharTPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E__vecDelDtor(
    [In] moneypunct\u003Cwchar_t\u002C0\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      moneypunct\u003Cwchar_t\u002C0\u003E* moneypunctWcharT0Ptr = (moneypunct\u003Cwchar_t\u002C0\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) moneypunctWcharT0Ptr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneypunctWcharT0Ptr);
      return (void*) moneypunctWcharT0Ptr;
    }
    \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002E_Mpunct\u003Cwchar_t\u003E\u002E__vecDelDtor(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = (_Mpunct\u003Cwchar_t\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) mpunctWcharTPtr, (__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) mpunctWcharTPtr);
      return (void*) mpunctWcharTPtr;
    }
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E__vecDelDtor(
    [In] moneypunct\u003Cwchar_t\u002C1\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      moneypunct\u003Cwchar_t\u002C1\u003E* moneypunctWcharT1Ptr = (moneypunct\u003Cwchar_t\u002C1\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) moneypunctWcharT1Ptr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneypunctWcharT1Ptr);
      return (void*) moneypunctWcharT1Ptr;
    }
    \u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* wcharTVecDelDtor = (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 28U, *(int*) wcharTVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) wcharTVecDelDtor);
      return (void*) wcharTVecDelDtor;
    }
    \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* unsignedShortVecDelDtor = (num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) unsignedShortVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) unsignedShortVecDelDtor);
      return (void*) unsignedShortVecDelDtor;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = (numpunct\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24U, *(int*) numpunctUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) numpunctUnsignedShortPtr);
      return (void*) numpunctUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      collate\u003Cunsigned\u0020short\u003E* collateUnsignedShortPtr = (collate\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) collateUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) collateUnsignedShortPtr);
      return (void*) collateUnsignedShortPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      messages\u003Cunsigned\u0020short\u003E* messagesUnsignedShortPtr = (messages\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8U, *(int*) messagesUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) messagesUnsignedShortPtr);
      return (void*) messagesUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* unsignedShortVecDelDtor = (money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) unsignedShortVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) unsignedShortVecDelDtor);
      return (void*) unsignedShortVecDelDtor;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E__vecDelDtor(
    [In] moneypunct\u003Cunsigned\u0020short\u002C0\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      moneypunct\u003Cunsigned\u0020short\u002C0\u003E* moneypunctUnsignedShort0Ptr = (moneypunct\u003Cunsigned\u0020short\u002C0\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) moneypunctUnsignedShort0Ptr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneypunctUnsignedShort0Ptr);
      return (void*) moneypunctUnsignedShort0Ptr;
    }
    \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = (_Mpunct\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) mpunctUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) mpunctUnsignedShortPtr);
      return (void*) mpunctUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E__vecDelDtor(
    [In] moneypunct\u003Cunsigned\u0020short\u002C1\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      moneypunct\u003Cunsigned\u0020short\u002C1\u003E* moneypunctUnsignedShort1Ptr = (moneypunct\u003Cunsigned\u0020short\u002C1\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 52U, *(int*) moneypunctUnsignedShort1Ptr, (__FnPtr<void (void*)>) __methodptr(std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) moneypunctUnsignedShort1Ptr);
      return (void*) moneypunctUnsignedShort1Ptr;
    }
    \u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* unsignedShortVecDelDtor = (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 28U, *(int*) unsignedShortVecDelDtor, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) unsignedShortVecDelDtor);
      return (void*) unsignedShortVecDelDtor;
    }
    \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor(
    [In] time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 - 4);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 20U, *(int*) traitsUnsignedShortPtr, (__FnPtr<void (void*)>) __methodptr(std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) traitsUnsignedShortPtr);
      return (void*) traitsUnsignedShortPtr;
    }
    \u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esbumpc(
    [In] basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    ushort num;
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gnavail(obj0))
    {
      num = (ushort) *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Gninc(obj0);
    }
    else
    {
      basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 20))((IntPtr) charTraitsWcharTPtr);
    }
    return num;
  }

  internal static unsafe ushort std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esbumpc(
    [In] basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    ushort num;
    if (0 < \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gnavail(obj0))
    {
      num = *\u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Gninc(obj0);
    }
    else
    {
      basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num = __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 20))((IntPtr) traitsUnsignedShortPtr);
    }
    return num;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Right)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num == 0U || ushort.MaxValue == \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esputc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) num, _Right))
      *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) 1;
    return obj0;
  }

  internal static unsafe time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      // ISSUE: fault handler
      try
      {
        bool flag = false;
        int num = 0;
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
          RuntimeHelpers.PrepareConstrainedRegions();
          try
          {
          }
          finally
          {
            \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
            flag = true;
          }
          _Locinfo locinfo;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, &locinfo);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
        finally
        {
          if (flag)
            \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Init(
    [In] time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj)
  {
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 12, ref cvtvec, 8);
    _Timevec timevec;
    _Timevec* timevecPtr = \u003CModule\u003E.std\u002E_Locinfo\u002E_Gettnames(_Lobj, &timevec);
    // ISSUE: fault handler
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = *(int*) timevecPtr;
      *(int*) timevecPtr = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) &timevec);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.free((void*) ^(int&) ref timevec);
  }

  internal static unsafe num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe int std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Ac,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Last,
    int _Basefield,
    locale* _Loc)
  {
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Egrouping(numpunctWcharTPtr, &stdAllocatorChar1);
    int traitsWcharTGetifld;
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      char ch1 = ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) != 0 ? \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Ethousands_sep(numpunctWcharTPtr) : char.MinValue;
      char ch2 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
      sbyte* numPtr1 = _Ac;
      if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
      {
        if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 43, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 43;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
        else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 45, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 45;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
      }
      _Basefield &= 3584;
      int num1;
      int num2;
      int num3;
      switch (_Basefield)
      {
        case 0:
          num3 = 0;
          break;
        case 1024:
          num1 = 8;
          goto label_13;
        case 2048:
          num2 = 16;
          goto label_12;
        default:
          num3 = 10;
          break;
      }
      num2 = num3;
label_12:
      num1 = num2;
label_13:
      traitsWcharTGetifld = num1;
      bool _Ch = false;
      bool flag = false;
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch2)
      {
        _Ch = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) && ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 120, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 88, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8))) && (num1 == 0 || num1 == 16))
        {
          traitsWcharTGetifld = 16;
          _Ch = false;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          goto label_22;
        }
        else if (num1 == 0)
          traitsWcharTGetifld = 8;
        else
          goto label_19;
      }
      if (traitsWcharTGetifld == 0)
        goto label_24;
label_19:
      int num4;
      if (traitsWcharTGetifld != 10)
      {
        if (traitsWcharTGetifld == 8)
        {
          num4 = 8;
          goto label_23;
        }
      }
      else
        goto label_24;
label_22:
      num4 = 22;
label_23:
      int num5 = num4;
      goto label_25;
label_24:
      num5 = 10;
label_25:
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) _Ch);
      // ISSUE: fault handler
      try
      {
        uint _Off = 0;
        sbyte* numPtr2 = _Ac + 31;
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
        {
          do
          {
            sbyte num6 = \u003CModule\u003E.std\u002E_Maklocbyte\u003Cwchar_t\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First), (_Cvtvec*) ((IntPtr) obj0 + 8));
            *numPtr1 = num6;
            if ((IntPtr) \u003CModule\u003E.memchr((void*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BH\u0040HHDGIIFB\u00400123456789abcdefABCDEF\u003F\u0024AA\u0040, (int) num6, (uint) num5) != IntPtr.Zero)
            {
              if ((flag || *numPtr1 != (sbyte) 48) && numPtr1 < numPtr2)
              {
                ++numPtr1;
                flag = true;
              }
              _Ch = true;
              if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
              {
                sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                int num7 = (int) *numPtr3 + 1;
                *numPtr3 = (sbyte) num7;
              }
            }
            else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && ch1 != char.MinValue && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch1)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
              ++_Off;
            }
            else
              break;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
          while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last));
          if (_Off != 0U)
          {
            if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
              ++_Off;
            else
              _Ch = false;
          }
        }
        sbyte* numPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar1);
        if (_Ch)
        {
          while (0U < _Off && *numPtr4 != sbyte.MaxValue)
          {
            --_Off;
            if (0U < _Off)
            {
              sbyte* numPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
              if ((int) *numPtr4 != (int) *numPtr5)
                goto label_49;
            }
            if (0U == _Off)
            {
              sbyte* numPtr6 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
              if ((int) *numPtr4 < (int) *numPtr6)
                goto label_49;
            }
            sbyte* numPtr7 = numPtr4 + 1;
            if ((sbyte) 0 < *numPtr7)
              numPtr4 = numPtr7;
          }
          if (!flag)
          {
            *numPtr1 = (sbyte) 48;
            ++numPtr1;
            goto label_50;
          }
          else
            goto label_50;
        }
label_49:
        numPtr1 = _Ac;
label_50:
        *numPtr1 = (sbyte) 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return traitsWcharTGetifld;
  }

  internal static unsafe int std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(
    [In] num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Ac,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Last,
    locale* _Loc)
  {
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Egrouping(numpunctWcharTPtr, &stdAllocatorChar1);
    int traitsWcharTGetffld;
    // ISSUE: fault handler
    try
    {
      char ch1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
      sbyte* numPtr1 = _Ac;
      bool flag1 = false;
      if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
      {
        if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 43, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 43;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
        else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 45, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 45;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
      }
      bool flag2 = false;
      int num1 = 0;
      traitsWcharTGetffld = 0;
      sbyte num2 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
      if (num2 != sbyte.MaxValue && num2 > (sbyte) 0)
      {
        char ch2 = \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Ethousands_sep(numpunctWcharTPtr);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) 0);
        // ISSUE: fault handler
        try
        {
          uint _Off = 0;
          if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
          {
            do
            {
              if ((uint) ch1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) ch1 + 9)
              {
                flag2 = true;
                if (36 <= num1)
                  ++traitsWcharTGetffld;
                else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) != (int) ch1 || num1 != 0)
                {
                  *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) - (int) ch1 + 48);
                  ++numPtr1;
                  ++num1;
                }
                if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
                {
                  sbyte* numPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  int num3 = (int) *numPtr2 + 1;
                  *numPtr2 = (sbyte) num3;
                }
              }
              else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && ch2 != char.MinValue && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch2)
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
                ++_Off;
              }
              else
                break;
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            }
            while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last));
            if (_Off != 0U)
            {
              if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
                ++_Off;
              else
                flag1 = true;
            }
          }
          sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          if (!flag1)
          {
            while (0U < _Off)
            {
              if (*numPtr3 != sbyte.MaxValue)
              {
                --_Off;
                if (0U < _Off)
                {
                  sbyte* numPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  if ((int) *numPtr3 != (int) *numPtr4)
                    goto label_32;
                }
                if (0U == _Off)
                {
                  sbyte* numPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  if ((int) *numPtr3 < (int) *numPtr5)
                    goto label_32;
                }
                if ((sbyte) 0 < numPtr3[1])
                {
                  ++numPtr3;
                  continue;
                }
                continue;
label_32:
                flag1 = true;
                break;
              }
              break;
            }
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      else if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
      {
        while ((uint) ch1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) ch1 + 9)
        {
          if (36 <= num1)
            ++traitsWcharTGetffld;
          else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) != (int) ch1 || num1 != 0)
          {
            *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) - (int) ch1 + 48);
            ++numPtr1;
            ++num1;
          }
          flag2 = true;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
            break;
        }
      }
      else
        goto label_44;
      if (flag2 && num1 == 0)
      {
        *numPtr1 = (sbyte) 48;
        ++numPtr1;
      }
label_44:
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Edecimal_point(numpunctWcharTPtr))
      {
        lconv* lconvPtr = \u003CModule\u003E.localeconv();
        *numPtr1 = *(sbyte*) *(int*) lconvPtr;
        ++numPtr1;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
      if (num1 == 0)
      {
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
        {
          while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch1)
          {
            --traitsWcharTGetffld;
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
              break;
          }
        }
        if (traitsWcharTGetffld < 0)
        {
          *numPtr1 = (sbyte) 48;
          ++numPtr1;
          ++traitsWcharTGetffld;
        }
      }
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
      {
        while ((uint) ch1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) ch1 + 9)
        {
          if (num1 < 36)
          {
            *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) - (int) ch1 + 48);
            ++numPtr1;
            ++num1;
          }
          flag2 = true;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
            break;
        }
      }
      if (flag2 && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) && ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 101, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 69, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8))))
      {
        *numPtr1 = (sbyte) 101;
        ++numPtr1;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        flag2 = false;
        int num4 = 0;
        if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
        {
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 43, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
          {
            *numPtr1 = (sbyte) 43;
            ++numPtr1;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
          else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 45, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
          {
            *numPtr1 = (sbyte) 45;
            ++numPtr1;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
        }
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
        {
          while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch1)
          {
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
              break;
          }
          if (flag2)
          {
            *numPtr1 = (sbyte) 48;
            ++numPtr1;
          }
        }
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
        {
          while ((uint) ch1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) ch1 + 9)
          {
            if (num4 < 8)
            {
              *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) - (int) ch1 + 48);
              ++numPtr1;
              ++num4;
            }
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
              break;
          }
        }
      }
      if (flag1 || !flag2)
        numPtr1 = _Ac;
      *numPtr1 = (sbyte) 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return traitsWcharTGetffld;
  }

  internal static unsafe num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe sbyte* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Fmt,
    sbyte _Spec,
    int _Flags)
  {
    *_Fmt = (sbyte) 37;
    sbyte* numPtr1 = _Fmt + 1;
    if ((_Flags & 32) != 0)
    {
      *numPtr1 = (sbyte) 43;
      ++numPtr1;
    }
    if ((_Flags & 16) != 0)
    {
      *numPtr1 = (sbyte) 35;
      ++numPtr1;
    }
    *numPtr1 = (sbyte) 46;
    sbyte* numPtr2 = numPtr1 + 1;
    *numPtr2 = (sbyte) 42;
    sbyte* numPtr3 = numPtr2 + 1;
    if (_Spec != (sbyte) 0)
    {
      *numPtr3 = _Spec;
      ++numPtr3;
    }
    sbyte num1;
    int num2;
    switch (_Flags & 12288)
    {
      case 4096:
        num2 = 101;
        break;
      case 8192:
        num1 = (sbyte) 102;
        goto label_11;
      default:
        num2 = 103;
        break;
    }
    num1 = (sbyte) num2;
label_11:
    *numPtr3 = num1;
    numPtr3[1] = (sbyte) 0;
    return _Fmt;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Fput(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    sbyte* _Buf,
    uint _Beforepoint,
    uint _Afterpoint,
    uint _Trailing,
    uint _Count)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr;
    // ISSUE: fault handler
    try
    {
      numpunctWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Egrouping(numpunctWcharTPtr, &stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      char _Kseparator = \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Ethousands_sep(numpunctWcharTPtr);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2);
      // ISSUE: fault handler
      try
      {
        char _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
        int num1;
        switch (*_Buf)
        {
          case 43:
          case 45:
            num1 = 1;
            break;
          default:
            num1 = 0;
            break;
        }
        lconv* lconvPtr = \u003CModule\u003E.localeconv();
        \u0024ArrayType\u0024\u0024\u0024BY02D arrayTypeBy02D;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy02D = *(sbyte*) *(int*) lconvPtr;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 1) = (sbyte) 101;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 2) = (sbyte) 0;
        sbyte* numPtr1 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, 101, _Count);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        sbyte* numPtr2 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, (int) ^(sbyte&) ref arrayTypeBy02D, _Count);
        if ((IntPtr) numPtr2 == IntPtr.Zero)
          _Trailing = 0U;
        sbyte num2 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
        if (num2 != sbyte.MaxValue && (sbyte) 0 < num2)
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Buf, _Count);
          if ((IntPtr) numPtr1 == IntPtr.Zero)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Trailing, (sbyte) 48);
          }
          else
          {
            if ((IntPtr) numPtr2 == IntPtr.Zero)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Beforepoint, (sbyte) 48);
              _Beforepoint = 0U;
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, (uint) ((IntPtr) numPtr1 - (IntPtr) _Buf), _Trailing, (sbyte) 48);
          }
          if ((IntPtr) numPtr2 == IntPtr.Zero)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Beforepoint, (sbyte) 48);
          }
          else
          {
            uint _Off = (uint) ((IntPtr) numPtr2 - (IntPtr) _Buf);
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off + 1U, _Afterpoint, (sbyte) 48);
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off, _Beforepoint, (sbyte) 48);
            _Afterpoint = 0U;
          }
          _Beforepoint = 0U;
          sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          uint _Off1 = \u003CModule\u003E.strcspn(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, 0U), (sbyte*) &arrayTypeBy02D);
          sbyte num3 = *numPtr3;
          if (num3 != sbyte.MaxValue)
          {
            while ((sbyte) 0 < num3 && (uint) num3 < _Off1 - (uint) num1)
            {
              _Off1 -= (uint) num3;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off1, 1U, (sbyte) 0);
              if ((sbyte) 0 < numPtr3[1])
                ++numPtr3;
              num3 = *numPtr3;
              if (num3 == sbyte.MaxValue)
                break;
            }
          }
          _Buf = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, 0U);
          _Trailing = 0U;
          _Count = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar2);
        }
        uint num4 = _Beforepoint + _Afterpoint + _Trailing + _Count;
        uint _Count1 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= 0 || (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= num4 ? 0U : (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) - num4;
        uint _Count2 = _Count1;
        switch (\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 448)
        {
          case 64:
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            sbyte* numPtr4 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, (int) ^(sbyte&) ref arrayTypeBy02D, _Count);
            if ((IntPtr) numPtr4 != IntPtr.Zero)
            {
              uint num5 = (uint) ((IntPtr) numPtr4 - (IntPtr) _Buf + 1);
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &charTraitsWcharT1, _Dest, _Buf, num5 - 1U, _Kseparator);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr1, 12);
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT2, _Dest, _Ch, _Beforepoint);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr2, 12);
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr3 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT3, _Dest, \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Edecimal_point(numpunctWcharTPtr), 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr3, 12);
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT4;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr4 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT4, _Dest, _Ch, _Afterpoint);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr4, 12);
              _Buf = (sbyte*) ((int) num5 + (IntPtr) _Buf);
              _Count -= num5;
            }
            sbyte* numPtr5 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, 101, _Count);
            if ((IntPtr) numPtr5 != IntPtr.Zero)
            {
              uint num6 = (uint) ((IntPtr) numPtr5 - (IntPtr) _Buf + 1);
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT5;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr5 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &charTraitsWcharT5, _Dest, _Buf, num6 - 1U, _Kseparator);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr5, 12);
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT6;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr6 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT6, _Dest, _Ch, _Trailing);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr6, 12);
              _Trailing = 0U;
              sbyte* _Ptr = (\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 4) == 0 ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KGKMHCOC\u0040e\u003F\u0024AA\u0040 : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01DDCIFGEA\u0040E\u003F\u0024AA\u0040;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT7;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr7 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &charTraitsWcharT7, _Dest, _Ptr, 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr7, 12);
              _Buf = (sbyte*) ((int) num6 + (IntPtr) _Buf);
              _Count -= num6;
            }
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT8;
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr8 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &charTraitsWcharT8, _Dest, _Buf, _Count, _Kseparator);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr8, 12);
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT9;
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr9 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT9, _Dest, _Ch, _Trailing);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr9, 12);
            *(int*) ((IntPtr) _Iosbase + 24) = 0;
            \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count2);
            break;
          case 256:
            if (0U < (uint) num1)
            {
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT10;
              ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr10 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &charTraitsWcharT10, _Dest, _Buf, 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr10, 12);
              ++_Buf;
              --_Count;
            }
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT11;
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr11 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT11, _Dest, _Fill, _Count1);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr11, 12);
            _Count2 = 0U;
            goto case 64;
          default:
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT12;
            ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr12 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT12, _Dest, _Fill, _Count1);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr12, 12);
            _Count2 = 0U;
            goto case 64;
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe sbyte* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Fmt,
    sbyte* _Spec,
    int _Flags)
  {
    *_Fmt = (sbyte) 37;
    sbyte* numPtr1 = _Fmt + 1;
    if ((_Flags & 32) != 0)
    {
      *numPtr1 = (sbyte) 43;
      ++numPtr1;
    }
    if ((_Flags & 8) != 0)
    {
      *numPtr1 = (sbyte) 35;
      ++numPtr1;
    }
    sbyte num1 = *_Spec;
    sbyte* numPtr2;
    if (num1 != (sbyte) 76)
    {
      *numPtr1 = num1;
      numPtr2 = numPtr1 + 1;
    }
    else
    {
      *numPtr1 = (sbyte) 73;
      sbyte* numPtr3 = numPtr1 + 1;
      *numPtr3 = (sbyte) 54;
      sbyte* numPtr4 = numPtr3 + 1;
      *numPtr4 = (sbyte) 52;
      numPtr2 = numPtr4 + 1;
    }
    sbyte num2;
    sbyte num3;
    switch (_Flags & 3584)
    {
      case 1024:
        num2 = (sbyte) 111;
        goto label_12;
      case 2048:
        num3 = (sbyte) (~(_Flags << 3) & 32 | 88);
        break;
      default:
        num3 = _Spec[1];
        break;
    }
    num2 = num3;
label_12:
    *numPtr2 = num2;
    numPtr2[1] = (sbyte) 0;
    return _Fmt;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Iput(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    sbyte* _Buf,
    uint _Count)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr;
    // ISSUE: fault handler
    try
    {
      numpunctWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Egrouping(numpunctWcharTPtr, &stdAllocatorChar);
    // ISSUE: fault handler
    try
    {
      int num1;
      int _Count1;
      switch (*_Buf)
      {
        case 43:
        case 45:
          _Count1 = 1;
          goto label_10;
        case 48:
          switch (_Buf[1])
          {
            case 88:
            case 120:
              num1 = 2;
              break;
            default:
              goto label_7;
          }
          break;
        default:
label_7:
          num1 = 0;
          break;
      }
      _Count1 = num1;
label_10:
      sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
      sbyte num2 = *numPtr1;
      if (num2 != sbyte.MaxValue && (sbyte) 0 < num2)
      {
        sbyte* numPtr2 = numPtr1;
        uint index = _Count;
        sbyte num3 = *numPtr2;
        if (num3 != sbyte.MaxValue)
        {
          while ((sbyte) 0 < num3 && (uint) num3 < index - (uint) _Count1)
          {
            index -= (uint) num3;
            uint num4 = (uint) ((int) _Count - (int) index + 1);
            \u003CModule\u003E.memmove_s((void*) (_Buf + (int) index + 1), num4, (void*) (_Buf + (int) index), num4);
            _Buf[(int) index] = (sbyte) 0;
            ++_Count;
            if ((sbyte) 0 < numPtr2[1])
              ++numPtr2;
            num3 = *numPtr2;
            if (num3 == sbyte.MaxValue)
              break;
          }
        }
      }
      int num5 = *(int*) ((IntPtr) _Iosbase + 24);
      uint _Count2 = num5 <= 0 || (uint) num5 <= _Count ? 0U : (uint) num5 - _Count;
      uint _Count3 = _Count2;
      switch (*(int*) ((IntPtr) _Iosbase + 16) & 448)
      {
        case 64:
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &charTraitsWcharT1, _Dest, _Buf, _Count, \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002Ethousands_sep(numpunctWcharTPtr));
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr1, 12);
          *(int*) ((IntPtr) _Iosbase + 24) = 0;
          \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count3);
          break;
        case 256:
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2;
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &charTraitsWcharT2, _Dest, _Buf, (uint) _Count1);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr2, 12);
          _Buf = (sbyte*) (_Count1 + (IntPtr) _Buf);
          _Count -= (uint) _Count1;
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3;
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr3 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT3, _Dest, _Fill, _Count2);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr3, 12);
          _Count3 = 0U;
          goto case 64;
        default:
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT4;
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr4 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT4, _Dest, _Fill, _Count2);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr4, 12);
          _Count3 = 0U;
          goto case 64;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    char* _Ptr,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, *_Ptr);
        --_Count;
        ++_Ptr;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U2)] char _Ch,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, _Ch);
        --_Count;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002Efalsename(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = obj0;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    ref basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E local = ref stdAllocatorWcharT;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 16))((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) numpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002Etruename(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = obj0;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    ref basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E local = ref stdAllocatorWcharT;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 20))((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) numpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe numpunct\u003Cwchar_t\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Init(obj0, &locinfo);
          numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = (numpunct\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 14);
          if (*(ushort*) numpunctWcharTPtr == (ushort) 0)
          {
            _Cvtvec cvtvec;
            *(short*) numpunctWcharTPtr = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 44, (char*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(&locinfo, &cvtvec));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Init(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) ((IntPtr) obj0 + 20) = 0;
    try
    {
      _Cvtvec cvtvec1;
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) *(int*) ((IntPtr) lconvPtr + 8), (sbyte*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec1));
      _Cvtvec cvtvec2;
      *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05LAPONLG\u0040false\u003F\u0024AA\u0040, (char*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec2));
      _Cvtvec cvtvec3;
      *(int*) ((IntPtr) obj0 + 20) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04LOAJBDKD\u0040true\u003F\u0024AA\u0040, (char*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec3));
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    _Cvtvec cvtvec4 = \u003CModule\u003E._Getcvt();
    *(short*) ((IntPtr) obj0 + 12) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E(*(sbyte*) *(int*) lconvPtr, (char*) 0, &cvtvec4);
    _Cvtvec cvtvec5 = \u003CModule\u003E._Getcvt();
    *(short*) ((IntPtr) obj0 + 14) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E(*(sbyte*) *(int*) ((IntPtr) lconvPtr + 4), (char*) 0, &cvtvec5);
  }

  internal static unsafe void std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Tidy(
    [In] numpunct\u003Cwchar_t\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 20));
  }

  internal static unsafe collate\u003Cwchar_t\u003E* std\u002Ecollate\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] collate\u003Cwchar_t\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Collvec collvec = \u003CModule\u003E._Getcoll();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref collvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe messages\u003Cwchar_t\u003E* std\u002Emessages\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] messages\u003Cwchar_t\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(
    [In] money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr;
      if (_Intl)
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctWcharTPtr = (_Mpunct\u003Cwchar_t\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C1\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      else
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctWcharTPtr = (_Mpunct\u003Cwchar_t\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C0\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      bool flag1 = false;
      bool flag2 = false;
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1);
        num1 = 1U;
        money_base.pattern pattern;
        \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Eneg_format(mpunctWcharTPtr, &pattern);
        uint num2 = 0;
        while (num2 < 4U)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          switch (^(sbyte&) ((int) num2 + (IntPtr) &pattern))
          {
            case 32:
            case 120:
              if (num2 != 3U)
              {
                locale locale;
                locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
                ctype\u003Cwchar_t\u003E* ctypeWcharTPtr;
                // ISSUE: fault handler
                try
                {
                  ctypeWcharTPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cwchar_t\u003E\u0020\u003E(_Loc);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
                }
                \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                {
                  while (\u003CModule\u003E.std\u002Ectype\u003Cwchar_t\u003E\u002Eis(ctypeWcharTPtr, (short) 72, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First)))
                  {
                    \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                    if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                      break;
                  }
                  break;
                }
                break;
              }
              break;
            case 36:
              basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
              \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Ecurr_symbol(mpunctWcharTPtr, &stdAllocatorWcharT2);
              // ISSUE: fault handler
              try
              {
                _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
                \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT3);
                if ((\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 8) == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) != (int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(&stdAllocatorWcharT2))
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(&stdAllocatorWcharT2, 0U, uint.MaxValue);
                else if (num2 == 3U && \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(&stdAllocatorWcharT1) <= 1U && (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) != (int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(&stdAllocatorWcharT2)))
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(&stdAllocatorWcharT2, 0U, uint.MaxValue);
                _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
                _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(&stdAllocatorWcharT2, &stdAllocatorWcharT4);
                // ISSUE: cpblk instruction
                __memcpy(ref stdAllocatorWcharT3, (IntPtr) stdAllocatorWcharTPtr, 8);
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                {
                  _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT5;
                  while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(&stdAllocatorWcharT3, (_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(&stdAllocatorWcharT2, &stdAllocatorWcharT5)))
                  {
                    char* chPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&stdAllocatorWcharT3);
                    if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) *chPtr)
                    {
                      \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&stdAllocatorWcharT3);
                      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                      if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                        break;
                    }
                    else
                      break;
                  }
                }
                _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT6;
                if (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(&stdAllocatorWcharT3, (_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(&stdAllocatorWcharT2, &stdAllocatorWcharT6)))
                  flag1 = true;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT2);
              break;
            case 43:
              if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
              {
                basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT7;
                basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr1 = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epositive_sign(mpunctWcharTPtr, &stdAllocatorWcharT7);
                bool flag3;
                // ISSUE: fault handler
                try
                {
                  num1 |= 2U;
                  basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT8;
                  int num3;
                  if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(stdAllocatorWcharTPtr1))
                  {
                    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr2 = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epositive_sign(mpunctWcharTPtr, &stdAllocatorWcharT8);
                    // ISSUE: fault handler
                    try
                    {
                      num1 |= 4U;
                      if ((int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u005B\u005D(stdAllocatorWcharTPtr2, 0U) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First))
                      {
                        num3 = 1;
                        goto label_75;
                      }
                    }
                    __fault
                    {
                      if (((int) num1 & 4) != 0)
                      {
                        num1 &= 4294967291U;
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT8);
                      }
                    }
                  }
                  // ISSUE: fault handler
                  try
                  {
                    num3 = 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 4) != 0)
                    {
                      num1 &= 4294967291U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT8);
                    }
                  }
label_75:
                  // ISSUE: fault handler
                  try
                  {
                    flag3 = num3 != 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 4) != 0)
                    {
                      num1 &= 4294967291U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT8);
                    }
                  }
                  if (((int) num1 & 4) != 0)
                  {
                    num1 &= 4294967291U;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT8);
                  }
                }
                __fault
                {
                  if (((int) num1 & 2) != 0)
                  {
                    num1 &= 4294967293U;
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT7);
                  }
                }
                if (((int) num1 & 2) != 0)
                {
                  num1 &= 4294967293U;
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT7);
                }
                if (flag3)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT9;
                  basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epositive_sign(mpunctWcharTPtr, &stdAllocatorWcharT9);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT1, _Right);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT9);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT9);
                  break;
                }
                basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT10;
                basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr3 = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Enegative_sign(mpunctWcharTPtr, &stdAllocatorWcharT10);
                bool flag4;
                // ISSUE: fault handler
                try
                {
                  num1 |= 8U;
                  basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT11;
                  int num4;
                  if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(stdAllocatorWcharTPtr3))
                  {
                    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr4 = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Enegative_sign(mpunctWcharTPtr, &stdAllocatorWcharT11);
                    // ISSUE: fault handler
                    try
                    {
                      num1 |= 16U;
                      if ((int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u005B\u005D(stdAllocatorWcharTPtr4, 0U) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First))
                      {
                        num4 = 1;
                        goto label_105;
                      }
                    }
                    __fault
                    {
                      if (((int) num1 & 16) != 0)
                      {
                        num1 &= 4294967279U;
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT11);
                      }
                    }
                  }
                  // ISSUE: fault handler
                  try
                  {
                    num4 = 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 16) != 0)
                    {
                      num1 &= 4294967279U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT11);
                    }
                  }
label_105:
                  // ISSUE: fault handler
                  try
                  {
                    flag4 = num4 != 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 16) != 0)
                    {
                      num1 &= 4294967279U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT11);
                    }
                  }
                  if (((int) num1 & 16) != 0)
                  {
                    num1 &= 4294967279U;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT11);
                  }
                }
                __fault
                {
                  if (((int) num1 & 8) != 0)
                  {
                    num1 &= 4294967287U;
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT10);
                  }
                }
                if (((int) num1 & 8) != 0)
                {
                  num1 &= 4294967287U;
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT10);
                }
                if (flag4)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT12;
                  basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Enegative_sign(mpunctWcharTPtr, &stdAllocatorWcharT12);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT1, _Right);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT12);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT12);
                  flag2 = true;
                  break;
                }
                break;
              }
              break;
            case 118:
              int num5 = 0;
              int num6 = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Efrac_digits(mpunctWcharTPtr);
              char _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
              \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Egrouping(mpunctWcharTPtr, &stdAllocatorChar1);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
              // ISSUE: fault handler
              try
              {
                if ((byte) 127 <= (byte) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1))
                {
                  if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                  {
                    while ((uint) _Ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First))
                    {
                      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                      {
                        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First));
                        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                          break;
                      }
                      else
                        break;
                    }
                    goto label_48;
                  }
                  else
                    goto label_48;
                }
                else
                {
                  char ch = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Ethousands_sep(mpunctWcharTPtr);
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) 0);
                  // ISSUE: fault handler
                  try
                  {
                    uint _Off = 0;
                    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                    {
                      do
                      {
                        if ((uint) _Ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                        {
                          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First));
                          if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
                          {
                            sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                            int num7 = (int) *numPtr + 1;
                            *numPtr = (sbyte) num7;
                          }
                        }
                        else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && ch != char.MinValue && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch)
                        {
                          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
                          ++_Off;
                        }
                        else
                          break;
                        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                      }
                      while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last));
                      if (_Off != 0U)
                      {
                        if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
                          ++_Off;
                        else
                          flag1 = true;
                      }
                    }
                    sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
                    if (!flag1)
                    {
                      while (0U < _Off)
                      {
                        if (*numPtr1 != sbyte.MaxValue)
                        {
                          --_Off;
                          if (0U < _Off)
                          {
                            sbyte* numPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                            if ((int) *numPtr1 != (int) *numPtr2)
                              goto label_40;
                          }
                          if (0U == _Off)
                          {
                            sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                            if ((int) *numPtr1 < (int) *numPtr3)
                              goto label_40;
                          }
                          if ((sbyte) 0 < numPtr1[1])
                          {
                            ++numPtr1;
                            continue;
                          }
                          continue;
label_40:
                          flag1 = true;
                          goto label_42;
                        }
                        else
                          break;
                      }
                      goto label_45;
                    }
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
                  }
label_42:
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
              break;
label_45:
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
              }
label_48:
              // ISSUE: fault handler
              try
              {
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edecimal_point(mpunctWcharTPtr) && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First), _Last))
                {
                  while ((uint) _Ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                  {
                    if (num5 < num6)
                    {
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First));
                      ++num5;
                    }
                    if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First), _Last))
                      break;
                  }
                }
                if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(obj1) == 0U)
                  flag1 = true;
                else if (num5 < num6)
                {
                  uint num8 = (uint) (num6 - num5);
                  do
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(obj1, _Ch);
                    --num8;
                  }
                  while (num8 > 0U);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
              break;
          }
          ++num2;
          if (flag1)
            break;
        }
        if (!flag1)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (1U < (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20))
          {
            _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT13;
            \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT13);
            _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT14;
            _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(&stdAllocatorWcharT1, &stdAllocatorWcharT14);
            // ISSUE: cpblk instruction
            __memcpy(ref stdAllocatorWcharT13, (IntPtr) stdAllocatorWcharTPtr, 8);
            if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
            {
              _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT15;
              while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&stdAllocatorWcharT13), (_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(&stdAllocatorWcharT1, &stdAllocatorWcharT15)))
              {
                char* chPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&stdAllocatorWcharT13);
                if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) *chPtr)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
                    break;
                }
                else
                  break;
              }
            }
            _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT16;
            if (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(&stdAllocatorWcharT13, (_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(&stdAllocatorWcharT1, &stdAllocatorWcharT16)))
              goto label_150;
          }
          if (flag2)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Einsert(obj1, 0U, 1U, \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 45, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)));
            goto label_154;
          }
          else
            goto label_154;
        }
label_150:
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj1, 0U, uint.MaxValue);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
      }
label_154:
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num9 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(
    [In] money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    [MarshalAs(UnmanagedType.U2)] char _Fill,
    [MarshalAs(UnmanagedType.U1)] bool _Neg,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Val)
  {
    // ISSUE: fault handler
    try
    {
      _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr;
      if (_Intl)
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctWcharTPtr = (_Mpunct\u003Cwchar_t\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C1\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      else
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctWcharTPtr = (_Mpunct\u003Cwchar_t\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C0\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      char ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Egrouping(mpunctWcharTPtr, &stdAllocatorChar);
      // ISSUE: fault handler
      try
      {
        int num1 = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Efrac_digits(mpunctWcharTPtr);
        int num2 = num1 >= 0 ? num1 : -num1;
        uint num3 = (uint) *(int*) ((IntPtr) _Val + 20);
        if (num3 <= (uint) num2)
        {
          uint num4 = num3;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Einsert(_Val, 0U, (uint) (num2 - (int) num4 + 1), ch);
        }
        else
        {
          sbyte num5 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
          if (num5 != sbyte.MaxValue && (sbyte) 0 < num5)
          {
            char _Ch = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Ethousands_sep(mpunctWcharTPtr);
            sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
            uint _Off = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val) - (uint) num2;
            sbyte num6 = *numPtr;
            if (num6 != sbyte.MaxValue)
            {
              while ((sbyte) 0 < num6 && (uint) num6 < _Off)
              {
                _Off -= (uint) num6;
                \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Einsert(_Val, _Off, 1U, _Ch);
                if ((sbyte) 0 < numPtr[1])
                  ++numPtr;
                num6 = *numPtr;
                if (num6 == sbyte.MaxValue)
                  break;
              }
            }
          }
        }
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT1;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT1);
        // ISSUE: fault handler
        try
        {
          money_base.pattern pattern1;
          if (_Neg)
          {
            money_base.pattern pattern2;
            money_base.pattern* patternPtr = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Eneg_format(mpunctWcharTPtr, &pattern2);
            // ISSUE: cpblk instruction
            __memcpy(ref pattern1, (IntPtr) patternPtr, 4);
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT2;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Enegative_sign(mpunctWcharTPtr, &stdAllocatorWcharT2);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT1, _Right);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT2);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT2);
          }
          else
          {
            money_base.pattern pattern3;
            money_base.pattern* patternPtr = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epos_format(mpunctWcharTPtr, &pattern3);
            // ISSUE: cpblk instruction
            __memcpy(ref pattern1, (IntPtr) patternPtr, 4);
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT3;
            basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epositive_sign(mpunctWcharTPtr, &stdAllocatorWcharT3);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT1, _Right);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT3);
          }
          basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT4;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorWcharT4);
          // ISSUE: fault handler
          try
          {
            if ((*(int*) ((IntPtr) _Iosbase + 16) & 8) != 0)
            {
              basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT5;
              basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Ecurr_symbol(mpunctWcharTPtr, &stdAllocatorWcharT5);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&stdAllocatorWcharT4, _Right);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT5);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT5);
            }
            bool flag = false;
            uint num7 = 0;
            uint num8 = 0;
            do
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              switch (^(sbyte&) ((int) num8 + (IntPtr) &pattern1))
              {
                case 32:
                  ++num7;
                  goto case 120;
                case 36:
                  num7 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(&stdAllocatorWcharT4) + num7;
                  break;
                case 43:
                  num7 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(&stdAllocatorWcharT1) + num7;
                  break;
                case 118:
                  int num9 = 0U < (uint) num2 ? 1 : 0;
                  uint num10 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val) > (uint) num2 ? 0U : (uint) (num2 - (int) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val) + 1);
                  num7 = (uint) ((int) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val) + (int) num10 + num9) + num7;
                  break;
                case 120:
                  if (num8 != 3U)
                  {
                    flag = true;
                    break;
                  }
                  break;
              }
              ++num8;
            }
            while (num8 < 4U);
            uint _Count1 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= 0 || (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= num7 ? 0U : (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) - num7;
            uint _Count2 = _Count1;
            int num11 = \u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 448;
            switch (num11)
            {
              case 64:
                uint num12 = 0;
                do
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  switch (^(sbyte&) ((int) num12 + (IntPtr) &pattern1))
                  {
                    case 32:
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&charTraitsWcharT1, _Dest, _Fill, 1U);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr1, 12);
                      goto case 120;
                    case 36:
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT6;
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(&stdAllocatorWcharT4, &stdAllocatorWcharT6);
                      _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source1;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source1, (IntPtr) stdAllocatorWcharTPtr1, 8);
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2;
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT2, _Dest, _Source1, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(&stdAllocatorWcharT4));
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr2, 12);
                      break;
                    case 43:
                      if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(&stdAllocatorWcharT1))
                      {
                        _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT7;
                        _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(&stdAllocatorWcharT1, &stdAllocatorWcharT7);
                        _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source2;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source2, (IntPtr) stdAllocatorWcharTPtr2, 8);
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3;
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr3 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT3, _Dest, _Source2, 1U);
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr3, 12);
                        break;
                      }
                      break;
                    case 118:
                      if (num2 == 0)
                      {
                        _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT8;
                        _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(_Val, &stdAllocatorWcharT8);
                        _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source3;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source3, (IntPtr) stdAllocatorWcharTPtr3, 8);
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT4;
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr4 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT4, _Dest, _Source3, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr4, 12);
                        break;
                      }
                      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val) <= (uint) num2)
                      {
                        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, ch);
                        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edecimal_point(mpunctWcharTPtr));
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT5;
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr5 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&charTraitsWcharT5, _Dest, ch, (uint) num2 - \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr5, 12);
                        _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT9;
                        _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(_Val, &stdAllocatorWcharT9);
                        _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source4;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source4, (IntPtr) stdAllocatorWcharTPtr4, 8);
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT6;
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr6 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT6, _Dest, _Source4, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr6, 12);
                        break;
                      }
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT10;
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(_Val, &stdAllocatorWcharT10);
                      _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source5;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source5, (IntPtr) stdAllocatorWcharTPtr5, 8);
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT7;
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr7 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT7, _Dest, _Source5, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(_Val) - (uint) num2);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr7, 12);
                      \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edecimal_point(mpunctWcharTPtr));
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT11;
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT12;
                      _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr6 = \u003CModule\u003E.std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002D(\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(_Val, &stdAllocatorWcharT11), &stdAllocatorWcharT12, num2);
                      _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source6;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source6, (IntPtr) stdAllocatorWcharTPtr6, 8);
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT8;
                      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr8 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT8, _Dest, _Source6, (uint) num2);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr8, 12);
                      break;
                    case 120:
                      if (num11 == 256)
                      {
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT9;
                        ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr9 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&charTraitsWcharT9, _Dest, _Fill, _Count2);
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr9, 12);
                        _Count2 = 0U;
                        break;
                      }
                      break;
                  }
                  ++num12;
                }
                while (num12 < 4U);
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if (1U < (uint) ^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20))
                {
                  _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT13;
                  _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT14;
                  _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = \u003CModule\u003E.std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B(\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(&stdAllocatorWcharT1, &stdAllocatorWcharT13), &stdAllocatorWcharT14, 1);
                  _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source;
                  // ISSUE: cpblk instruction
                  __memcpy(ref _Source, (IntPtr) stdAllocatorWcharTPtr, 8);
                  ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT;
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(&charTraitsWcharT, _Dest, _Source, (uint) (^(int&) ((IntPtr) &stdAllocatorWcharT1 + 20) - 1));
                  // ISSUE: cpblk instruction
                  __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr, 12);
                }
                *(int*) ((IntPtr) _Iosbase + 24) = 0;
                \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj1, _Dest, _Fill, _Count2);
                break;
              case 256:
                if (flag)
                  goto case 64;
                else
                  goto default;
              default:
                ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT10;
                ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr10 = \u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&charTraitsWcharT10, _Dest, _Fill, _Count1);
                // ISSUE: cpblk instruction
                __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr10, 12);
                _Count2 = 0U;
                goto case 64;
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT4);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT4);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT1);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorWcharT1);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) _Val);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(_Val);
    return obj1;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    uint _Count)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Count);
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Ptr);
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Count,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Count, _Ch);
    return obj0;
  }

  [SpecialName]
  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(obj0, 1U, _Ch);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Count,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* stdAllocatorWcharTPtr = obj0;
        int _Off = *(int*) ((IntPtr) stdAllocatorWcharTPtr + 20);
        int _Count1 = (int) _Count;
        int _Ch1 = (int) _Ch;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Chassign(stdAllocatorWcharTPtr, (uint) _Off, (uint) _Count1, (char) _Ch1);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ebegin(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) obj1, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0), (_Container_base*) obj0);
    return obj1;
  }

  internal static unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Off)
  {
    if (_Off > (uint) *(int*) ((IntPtr) obj0 + 20))
      \u003CModule\u003E._invalid_parameter_noinfo();
    return (char*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0));
  }

  internal static unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Ec_str(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0);
  }

  internal static unsafe uint std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Esize(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return (uint) *(int*) ((IntPtr) obj0 + 20);
  }

  internal static unsafe moneypunct\u003Cwchar_t\u002C0\u003E* std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cwchar_t\u002C0\u003E* obj0,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cwchar_t\u003E*) obj0, _Refs, false);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe _Mpunct\u003Cwchar_t\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs,
    [MarshalAs(UnmanagedType.U1)] bool _Intl)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      *(sbyte*) ((IntPtr) obj0 + 40) = (sbyte) _Intl;
      \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Tidy(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 20));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 24));
  }

  internal static unsafe moneypunct\u003Cwchar_t\u002C1\u003E* std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cwchar_t\u002C1\u003E* obj0,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cwchar_t\u003E*) obj0, _Refs, true);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe time_base.dateorder std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edate_order(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<time_base.dateorder (IntPtr)>) *(int*) (*(int*) charTraitsWcharTPtr + 4))((IntPtr) charTraitsWcharTPtr);
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
    ref istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E local = ref charTraitsWcharT1;
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2 = _First;
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3 = _Last;
    ios_base* iosBasePtr = _Iosbase;
    int* numPtr = _State;
    tm* tmPtr = _Pt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*, istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E, istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E, ios_base*, int*, tm*)>) *(int*) (*(int*) obj0 + 20))((tm*) charTraitsWcharTPtr, (int*) ref local, (ios_base*) charTraitsWcharT2, charTraitsWcharT3, (istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E) (IntPtr) iosBasePtr, (istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) numPtr, (IntPtr) tmPtr);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Eget_year(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* charTraitsWcharTPtr = obj0;
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
    ref istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E local = ref charTraitsWcharT1;
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2 = _First;
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT3 = _Last;
    ios_base* iosBasePtr = _Iosbase;
    int* numPtr = _State;
    tm* tmPtr = _Pt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*, istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E, istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E, ios_base*, int*, tm*)>) *(int*) (*(int*) obj0 + 24))((tm*) charTraitsWcharTPtr, (int*) ref local, (ios_base*) charTraitsWcharT2, charTraitsWcharT3, (istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E) (IntPtr) iosBasePtr, (istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) numPtr, (IntPtr) tmPtr);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 12);
    return obj1;
  }

  internal static unsafe time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Init(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Cvt = (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 20);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) _Cvt, ref cvtvec, 8);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 12) = 0;
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E(\u003CModule\u003E.std\u002E_Locinfo\u002E_Getdays(_Lobj), (char*) 0, (_Cvtvec*) _Cvt);
      *(int*) ((IntPtr) obj0 + 12) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E(\u003CModule\u003E.std\u002E_Locinfo\u002E_Getmonths(_Lobj), (char*) 0, (_Cvtvec*) _Cvt);
      *(int*) ((IntPtr) obj0 + 16) = \u003CModule\u003E.std\u002E_Locinfo\u002E_Getdateorder(_Lobj);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
  }

  internal static unsafe int std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getint(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Last,
    int _Lo,
    int _Hi,
    int* _Val)
  {
    char ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 48, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1 = (sbyte*) &arrayTypeBy0CaD;
    if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
    {
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 43, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20)))
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy0CaD = (sbyte) 43;
        numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
      else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E((sbyte) 45, (char*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20)))
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy0CaD = (sbyte) 45;
        numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
    }
    bool flag = false;
    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
    {
      while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) == (int) ch)
      {
        flag = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
          break;
      }
      if (flag)
      {
        *numPtr1 = (sbyte) 48;
        ++numPtr1;
      }
    }
    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
    {
      while ((uint) ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) <= (int) ch + 9)
      {
        *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First) - (int) ch + 48);
        // ISSUE: cast to a reference type
        if ((IntPtr) numPtr1 < (\u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D&) ((IntPtr) &arrayTypeBy0CaD + 31))
          ++numPtr1;
        flag = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
          break;
      }
    }
    if (!flag)
      numPtr1 = (sbyte*) &arrayTypeBy0CaD;
    *numPtr1 = (sbyte) 0;
    int num1 = 0;
    sbyte* numPtr2;
    int num2 = \u003CModule\u003E._Stolx((sbyte*) &arrayTypeBy0CaD, &numPtr2, 10, &num1);
    int traitsWcharTGetint = 0;
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(_First, _Last))
      traitsWcharTGetint = 1;
    if ((IntPtr) numPtr2 != ref arrayTypeBy0CaD && num1 == 0 && num2 >= _Lo && _Hi >= num2)
      *_Val = num2;
    else
      traitsWcharTGetint |= 2;
    return traitsWcharTGetint;
  }

  internal static unsafe void std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(
    [In] time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 12));
  }

  internal static unsafe num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe int std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getifld(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Ac,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Last,
    int _Basefield,
    locale* _Loc)
  {
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(numpunctUnsignedShortPtr, &stdAllocatorChar1);
    int unsignedShortGetifld;
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ushort num1 = ^(int&) ((IntPtr) &stdAllocatorChar1 + 20) != 0 ? \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(numpunctUnsignedShortPtr) : (ushort) 0;
      ushort num2 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
      sbyte* numPtr1 = _Ac;
      if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
      {
        if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 43, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 43;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
        else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 45, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 45;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
      }
      _Basefield &= 3584;
      int num3;
      int num4;
      int num5;
      switch (_Basefield)
      {
        case 0:
          num5 = 0;
          break;
        case 1024:
          num3 = 8;
          goto label_13;
        case 2048:
          num4 = 16;
          goto label_12;
        default:
          num5 = 10;
          break;
      }
      num4 = num5;
label_12:
      num3 = num4;
label_13:
      unsignedShortGetifld = num3;
      bool _Ch = false;
      bool flag = false;
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num2)
      {
        _Ch = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) && ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 120, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 88, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8))) && (num3 == 0 || num3 == 16))
        {
          unsignedShortGetifld = 16;
          _Ch = false;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          goto label_22;
        }
        else if (num3 == 0)
          unsignedShortGetifld = 8;
        else
          goto label_19;
      }
      if (unsignedShortGetifld == 0)
        goto label_24;
label_19:
      int num6;
      if (unsignedShortGetifld != 10)
      {
        if (unsignedShortGetifld == 8)
        {
          num6 = 8;
          goto label_23;
        }
      }
      else
        goto label_24;
label_22:
      num6 = 22;
label_23:
      int num7 = num6;
      goto label_25;
label_24:
      num7 = 10;
label_25:
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) _Ch);
      // ISSUE: fault handler
      try
      {
        uint _Off = 0;
        sbyte* numPtr2 = _Ac + 31;
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
        {
          do
          {
            sbyte num8 = \u003CModule\u003E.std\u002E_Maklocbyte\u003Cunsigned\u0020short\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First), (_Cvtvec*) ((IntPtr) obj0 + 8));
            *numPtr1 = num8;
            if ((IntPtr) \u003CModule\u003E.memchr((void*) &\u003CModule\u003E.\u003F\u003F_C\u0040_0BH\u0040HHDGIIFB\u00400123456789abcdefABCDEF\u003F\u0024AA\u0040, (int) num8, (uint) num7) != IntPtr.Zero)
            {
              if ((flag || *numPtr1 != (sbyte) 48) && numPtr1 < numPtr2)
              {
                ++numPtr1;
                flag = true;
              }
              _Ch = true;
              if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
              {
                sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                int num9 = (int) *numPtr3 + 1;
                *numPtr3 = (sbyte) num9;
              }
            }
            else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && num1 != (ushort) 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num1)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
              ++_Off;
            }
            else
              break;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
          while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last));
          if (_Off != 0U)
          {
            if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
              ++_Off;
            else
              _Ch = false;
          }
        }
        sbyte* numPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Myptr(&stdAllocatorChar1);
        if (_Ch)
        {
          while (0U < _Off && *numPtr4 != sbyte.MaxValue)
          {
            --_Off;
            if (0U < _Off)
            {
              sbyte* numPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
              if ((int) *numPtr4 != (int) *numPtr5)
                goto label_49;
            }
            if (0U == _Off)
            {
              sbyte* numPtr6 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
              if ((int) *numPtr4 < (int) *numPtr6)
                goto label_49;
            }
            sbyte* numPtr7 = numPtr4 + 1;
            if ((sbyte) 0 < *numPtr7)
              numPtr4 = numPtr7;
          }
          if (!flag)
          {
            *numPtr1 = (sbyte) 48;
            ++numPtr1;
            goto label_50;
          }
          else
            goto label_50;
        }
label_49:
        numPtr1 = _Ac;
label_50:
        *numPtr1 = (sbyte) 0;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return unsignedShortGetifld;
  }

  internal static unsafe int std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getffld(
    [In] num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Ac,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Last,
    locale* _Loc)
  {
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(numpunctUnsignedShortPtr, &stdAllocatorChar1);
    int unsignedShortGetffld;
    // ISSUE: fault handler
    try
    {
      ushort num1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
      sbyte* numPtr1 = _Ac;
      bool flag1 = false;
      if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
      {
        if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 43, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 43;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
        else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 45, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
        {
          *_Ac = (sbyte) 45;
          numPtr1 = _Ac + 1;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        }
      }
      bool flag2 = false;
      int num2 = 0;
      unsignedShortGetffld = 0;
      sbyte num3 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
      if (num3 != sbyte.MaxValue && num3 > (sbyte) 0)
      {
        ushort num4 = \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(numpunctUnsignedShortPtr);
        basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) 0);
        // ISSUE: fault handler
        try
        {
          uint _Off = 0;
          if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
          {
            do
            {
              if ((uint) num1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) num1 + 9)
              {
                flag2 = true;
                if (36 <= num2)
                  ++unsignedShortGetffld;
                else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) != (int) num1 || num2 != 0)
                {
                  *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) - (int) num1 + 48);
                  ++numPtr1;
                  ++num2;
                }
                if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
                {
                  sbyte* numPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  int num5 = (int) *numPtr2 + 1;
                  *numPtr2 = (sbyte) num5;
                }
              }
              else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && num4 != (ushort) 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num4)
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
                ++_Off;
              }
              else
                break;
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            }
            while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last));
            if (_Off != 0U)
            {
              if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
                ++_Off;
              else
                flag1 = true;
            }
          }
          sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          if (!flag1)
          {
            while (0U < _Off)
            {
              if (*numPtr3 != sbyte.MaxValue)
              {
                --_Off;
                if (0U < _Off)
                {
                  sbyte* numPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  if ((int) *numPtr3 != (int) *numPtr4)
                    goto label_32;
                }
                if (0U == _Off)
                {
                  sbyte* numPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                  if ((int) *numPtr3 < (int) *numPtr5)
                    goto label_32;
                }
                if ((sbyte) 0 < numPtr3[1])
                {
                  ++numPtr3;
                  continue;
                }
                continue;
label_32:
                flag1 = true;
                break;
              }
              break;
            }
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
      }
      else if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
      {
        while ((uint) num1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) num1 + 9)
        {
          if (36 <= num2)
            ++unsignedShortGetffld;
          else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) != (int) num1 || num2 != 0)
          {
            *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) - (int) num1 + 48);
            ++numPtr1;
            ++num2;
          }
          flag2 = true;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
            break;
        }
      }
      else
        goto label_44;
      if (flag2 && num2 == 0)
      {
        *numPtr1 = (sbyte) 48;
        ++numPtr1;
      }
label_44:
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(numpunctUnsignedShortPtr))
      {
        lconv* lconvPtr = \u003CModule\u003E.localeconv();
        *numPtr1 = *(sbyte*) *(int*) lconvPtr;
        ++numPtr1;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
      if (num2 == 0)
      {
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
        {
          while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num1)
          {
            --unsignedShortGetffld;
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
              break;
          }
        }
        if (unsignedShortGetffld < 0)
        {
          *numPtr1 = (sbyte) 48;
          ++numPtr1;
          ++unsignedShortGetffld;
        }
      }
      if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
      {
        while ((uint) num1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) num1 + 9)
        {
          if (num2 < 36)
          {
            *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) - (int) num1 + 48);
            ++numPtr1;
            ++num2;
          }
          flag2 = true;
          \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
            break;
        }
      }
      if (flag2 && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) && ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 101, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 69, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8))))
      {
        *numPtr1 = (sbyte) 101;
        ++numPtr1;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        flag2 = false;
        int num6 = 0;
        if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
        {
          if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 43, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
          {
            *numPtr1 = (sbyte) 43;
            ++numPtr1;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
          else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 45, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)))
          {
            *numPtr1 = (sbyte) 45;
            ++numPtr1;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
          }
        }
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
        {
          while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num1)
          {
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
              break;
          }
          if (flag2)
          {
            *numPtr1 = (sbyte) 48;
            ++numPtr1;
          }
        }
        if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
        {
          while ((uint) num1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) num1 + 9)
          {
            if (num6 < 8)
            {
              *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) - (int) num1 + 48);
              ++numPtr1;
              ++num6;
            }
            flag2 = true;
            \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
            if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
              break;
          }
        }
      }
      if (flag1 || !flag2)
        numPtr1 = _Ac;
      *numPtr1 = (sbyte) 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return unsignedShortGetffld;
  }

  internal static unsafe num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe sbyte* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ffmt(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Fmt,
    sbyte _Spec,
    int _Flags)
  {
    *_Fmt = (sbyte) 37;
    sbyte* numPtr1 = _Fmt + 1;
    if ((_Flags & 32) != 0)
    {
      *numPtr1 = (sbyte) 43;
      ++numPtr1;
    }
    if ((_Flags & 16) != 0)
    {
      *numPtr1 = (sbyte) 35;
      ++numPtr1;
    }
    *numPtr1 = (sbyte) 46;
    sbyte* numPtr2 = numPtr1 + 1;
    *numPtr2 = (sbyte) 42;
    sbyte* numPtr3 = numPtr2 + 1;
    if (_Spec != (sbyte) 0)
    {
      *numPtr3 = _Spec;
      ++numPtr3;
    }
    sbyte num1;
    int num2;
    switch (_Flags & 12288)
    {
      case 4096:
        num2 = 101;
        break;
      case 8192:
        num1 = (sbyte) 102;
        goto label_11;
      default:
        num2 = 103;
        break;
    }
    num1 = (sbyte) num2;
label_11:
    *numPtr3 = num1;
    numPtr3[1] = (sbyte) 0;
    return _Fmt;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Fput(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    sbyte* _Buf,
    uint _Beforepoint,
    uint _Afterpoint,
    uint _Trailing,
    uint _Count)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr;
    // ISSUE: fault handler
    try
    {
      numpunctUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
    \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(numpunctUnsignedShortPtr, &stdAllocatorChar1);
    // ISSUE: fault handler
    try
    {
      ushort _Kseparator = \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(numpunctUnsignedShortPtr);
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2);
      // ISSUE: fault handler
      try
      {
        ushort _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
        int num1;
        switch (*_Buf)
        {
          case 43:
          case 45:
            num1 = 1;
            break;
          default:
            num1 = 0;
            break;
        }
        lconv* lconvPtr = \u003CModule\u003E.localeconv();
        \u0024ArrayType\u0024\u0024\u0024BY02D arrayTypeBy02D;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy02D = *(sbyte*) *(int*) lconvPtr;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 1) = (sbyte) 101;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 2) = (sbyte) 0;
        sbyte* numPtr1 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, 101, _Count);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        sbyte* numPtr2 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, (int) ^(sbyte&) ref arrayTypeBy02D, _Count);
        if ((IntPtr) numPtr2 == IntPtr.Zero)
          _Trailing = 0U;
        sbyte num2 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
        if (num2 != sbyte.MaxValue && (sbyte) 0 < num2)
        {
          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Buf, _Count);
          if ((IntPtr) numPtr1 == IntPtr.Zero)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Trailing, (sbyte) 48);
          }
          else
          {
            if ((IntPtr) numPtr2 == IntPtr.Zero)
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Beforepoint, (sbyte) 48);
              _Beforepoint = 0U;
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, (uint) ((IntPtr) numPtr1 - (IntPtr) _Buf), _Trailing, (sbyte) 48);
          }
          if ((IntPtr) numPtr2 == IntPtr.Zero)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, _Beforepoint, (sbyte) 48);
          }
          else
          {
            uint _Off = (uint) ((IntPtr) numPtr2 - (IntPtr) _Buf);
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off + 1U, _Afterpoint, (sbyte) 48);
            \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off, _Beforepoint, (sbyte) 48);
            _Afterpoint = 0U;
          }
          _Beforepoint = 0U;
          sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
          uint _Off1 = \u003CModule\u003E.strcspn(\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, 0U), (sbyte*) &arrayTypeBy02D);
          sbyte num3 = *numPtr3;
          if (num3 != sbyte.MaxValue)
          {
            while ((sbyte) 0 < num3 && (uint) num3 < _Off1 - (uint) num1)
            {
              _Off1 -= (uint) num3;
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Einsert(&stdAllocatorChar2, _Off1, 1U, (sbyte) 0);
              if ((sbyte) 0 < numPtr3[1])
                ++numPtr3;
              num3 = *numPtr3;
              if (num3 == sbyte.MaxValue)
                break;
            }
          }
          _Buf = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, 0U);
          _Trailing = 0U;
          _Count = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Esize(&stdAllocatorChar2);
        }
        uint num4 = _Beforepoint + _Afterpoint + _Trailing + _Count;
        uint _Count1 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= 0 || (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= num4 ? 0U : (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) - num4;
        uint _Count2 = _Count1;
        switch (\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 448)
        {
          case 64:
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            sbyte* numPtr4 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, (int) ^(sbyte&) ref arrayTypeBy02D, _Count);
            if ((IntPtr) numPtr4 != IntPtr.Zero)
            {
              uint num5 = (uint) ((IntPtr) numPtr4 - (IntPtr) _Buf + 1);
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &traitsUnsignedShort1, _Dest, _Buf, num5 - 1U, _Kseparator);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr1, 12);
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort2, _Dest, _Ch, _Beforepoint);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr2, 12);
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr3 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort3, _Dest, \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(numpunctUnsignedShortPtr), 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr3, 12);
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort4;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr4 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort4, _Dest, _Ch, _Afterpoint);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr4, 12);
              _Buf = (sbyte*) ((int) num5 + (IntPtr) _Buf);
              _Count -= num5;
            }
            sbyte* numPtr5 = (sbyte*) \u003CModule\u003E.memchr((void*) _Buf, 101, _Count);
            if ((IntPtr) numPtr5 != IntPtr.Zero)
            {
              uint num6 = (uint) ((IntPtr) numPtr5 - (IntPtr) _Buf + 1);
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort5;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr5 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &traitsUnsignedShort5, _Dest, _Buf, num6 - 1U, _Kseparator);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr5, 12);
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort6;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr6 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort6, _Dest, _Ch, _Trailing);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr6, 12);
              _Trailing = 0U;
              sbyte* _Ptr = (\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 4) == 0 ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01KGKMHCOC\u0040e\u003F\u0024AA\u0040 : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01DDCIFGEA\u0040E\u003F\u0024AA\u0040;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort7;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr7 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &traitsUnsignedShort7, _Dest, _Ptr, 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr7, 12);
              _Buf = (sbyte*) ((int) num6 + (IntPtr) _Buf);
              _Count -= num6;
            }
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort8;
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr8 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &traitsUnsignedShort8, _Dest, _Buf, _Count, _Kseparator);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr8, 12);
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort9;
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr9 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort9, _Dest, _Ch, _Trailing);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr9, 12);
            *(int*) ((IntPtr) _Iosbase + 24) = 0;
            \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count2);
            break;
          case 256:
            if (0U < (uint) num1)
            {
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort10;
              ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr10 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &traitsUnsignedShort10, _Dest, _Buf, 1U);
              // ISSUE: cpblk instruction
              __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr10, 12);
              ++_Buf;
              --_Count;
            }
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort11;
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr11 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort11, _Dest, _Fill, _Count1);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr11, 12);
            _Count2 = 0U;
            goto case 64;
          default:
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort12;
            ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr12 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort12, _Dest, _Fill, _Count1);
            // ISSUE: cpblk instruction
            __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr12, 12);
            _Count2 = 0U;
            goto case 64;
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar2, true, 0U);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar1, true, 0U);
    return obj1;
  }

  internal static unsafe sbyte* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Ifmt(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    sbyte* _Fmt,
    sbyte* _Spec,
    int _Flags)
  {
    *_Fmt = (sbyte) 37;
    sbyte* numPtr1 = _Fmt + 1;
    if ((_Flags & 32) != 0)
    {
      *numPtr1 = (sbyte) 43;
      ++numPtr1;
    }
    if ((_Flags & 8) != 0)
    {
      *numPtr1 = (sbyte) 35;
      ++numPtr1;
    }
    sbyte num1 = *_Spec;
    sbyte* numPtr2;
    if (num1 != (sbyte) 76)
    {
      *numPtr1 = num1;
      numPtr2 = numPtr1 + 1;
    }
    else
    {
      *numPtr1 = (sbyte) 73;
      sbyte* numPtr3 = numPtr1 + 1;
      *numPtr3 = (sbyte) 54;
      sbyte* numPtr4 = numPtr3 + 1;
      *numPtr4 = (sbyte) 52;
      numPtr2 = numPtr4 + 1;
    }
    sbyte num2;
    sbyte num3;
    switch (_Flags & 3584)
    {
      case 1024:
        num2 = (sbyte) 111;
        goto label_12;
      case 2048:
        num3 = (sbyte) (~(_Flags << 3) & 32 | 88);
        break;
      default:
        num3 = _Spec[1];
        break;
    }
    num2 = num3;
label_12:
    *numPtr2 = num2;
    numPtr2[1] = (sbyte) 0;
    return _Fmt;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Iput(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ios_base* _Iosbase,
    ushort _Fill,
    sbyte* _Buf,
    uint _Count)
  {
    locale locale;
    locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr;
    // ISSUE: fault handler
    try
    {
      numpunctUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
    }
    \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(numpunctUnsignedShortPtr, &stdAllocatorChar);
    // ISSUE: fault handler
    try
    {
      int num1;
      int _Count1;
      switch (*_Buf)
      {
        case 43:
        case 45:
          _Count1 = 1;
          goto label_10;
        case 48:
          switch (_Buf[1])
          {
            case 88:
            case 120:
              num1 = 2;
              break;
            default:
              goto label_7;
          }
          break;
        default:
label_7:
          num1 = 0;
          break;
      }
      _Count1 = num1;
label_10:
      sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
      sbyte num2 = *numPtr1;
      if (num2 != sbyte.MaxValue && (sbyte) 0 < num2)
      {
        sbyte* numPtr2 = numPtr1;
        uint index = _Count;
        sbyte num3 = *numPtr2;
        if (num3 != sbyte.MaxValue)
        {
          while ((sbyte) 0 < num3 && (uint) num3 < index - (uint) _Count1)
          {
            index -= (uint) num3;
            uint num4 = (uint) ((int) _Count - (int) index + 1);
            \u003CModule\u003E.memmove_s((void*) (_Buf + (int) index + 1), num4, (void*) (_Buf + (int) index), num4);
            _Buf[(int) index] = (sbyte) 0;
            ++_Count;
            if ((sbyte) 0 < numPtr2[1])
              ++numPtr2;
            num3 = *numPtr2;
            if (num3 == sbyte.MaxValue)
              break;
          }
        }
      }
      int num5 = *(int*) ((IntPtr) _Iosbase + 24);
      uint _Count2 = num5 <= 0 || (uint) num5 <= _Count ? 0U : (uint) num5 - _Count;
      uint _Count3 = _Count2;
      switch (*(int*) ((IntPtr) _Iosbase + 16) & 448)
      {
        case 64:
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(obj0, &traitsUnsignedShort1, _Dest, _Buf, _Count, \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(numpunctUnsignedShortPtr));
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr1, 12);
          *(int*) ((IntPtr) _Iosbase + 24) = 0;
          \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, obj1, _Dest, _Fill, _Count3);
          break;
        case 256:
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2;
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &traitsUnsignedShort2, _Dest, _Buf, (uint) _Count1);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr2, 12);
          _Buf = (sbyte*) (_Count1 + (IntPtr) _Buf);
          _Count -= (uint) _Count1;
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3;
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr3 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort3, _Dest, _Fill, _Count2);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr3, 12);
          _Count3 = 0U;
          goto case 64;
        default:
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort4;
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr4 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort4, _Dest, _Fill, _Count2);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr4, 12);
          _Count3 = 0U;
          goto case 64;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ushort* _Ptr,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, *_Ptr);
        --_Count;
        ++_Ptr;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ushort _Ch,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, _Ch);
        --_Count;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Efalsename(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = obj0;
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    ref basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref allocatorUnsignedShort;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 16))((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) numpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Etruename(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = obj0;
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    ref basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref allocatorUnsignedShort;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 20))((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) numpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe numpunct\u003Cunsigned\u0020short\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Init(obj0, &locinfo);
          numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = (numpunct\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 14);
          if (*(ushort*) numpunctUnsignedShortPtr == (ushort) 0)
          {
            _Cvtvec cvtvec;
            *(short*) numpunctUnsignedShortPtr = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 44, (ushort*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(&locinfo, &cvtvec));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Init(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) ((IntPtr) obj0 + 20) = 0;
    try
    {
      _Cvtvec cvtvec1;
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) *(int*) ((IntPtr) lconvPtr + 8), (sbyte*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec1));
      _Cvtvec cvtvec2;
      *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_05LAPONLG\u0040false\u003F\u0024AA\u0040, (ushort*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec2));
      _Cvtvec cvtvec3;
      *(int*) ((IntPtr) obj0 + 20) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04LOAJBDKD\u0040true\u003F\u0024AA\u0040, (ushort*) 0, \u003CModule\u003E.std\u002E_Locinfo\u002E_Getcvt(_Lobj, &cvtvec3));
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    _Cvtvec cvtvec4 = \u003CModule\u003E._Getcvt();
    *(short*) ((IntPtr) obj0 + 12) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(*(sbyte*) *(int*) lconvPtr, (ushort*) 0, &cvtvec4);
    _Cvtvec cvtvec5 = \u003CModule\u003E._Getcvt();
    *(short*) ((IntPtr) obj0 + 14) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(*(sbyte*) *(int*) ((IntPtr) lconvPtr + 4), (ushort*) 0, &cvtvec5);
  }

  internal static unsafe void std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Tidy(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 20));
  }

  internal static unsafe collate\u003Cunsigned\u0020short\u003E* std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] collate\u003Cunsigned\u0020short\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Collvec collvec = \u003CModule\u003E._Getcoll();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref collvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe messages\u003Cunsigned\u0020short\u003E* std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] messages\u003Cunsigned\u0020short\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7messages_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emessages_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getmfld(
    [In] money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Last,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr;
      if (_Intl)
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctUnsignedShortPtr = (_Mpunct\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      else
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctUnsignedShortPtr = (_Mpunct\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      bool flag1 = false;
      bool flag2 = false;
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort1);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1);
        num1 = 1U;
        money_base.pattern pattern;
        \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Eneg_format(mpunctUnsignedShortPtr, &pattern);
        uint num2 = 0;
        while (num2 < 4U)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          switch (^(sbyte&) ((int) num2 + (IntPtr) &pattern))
          {
            case 32:
            case 120:
              if (num2 != 3U)
              {
                locale locale;
                locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
                ctype\u003Cunsigned\u0020short\u003E* ctypeUnsignedShortPtr;
                // ISSUE: fault handler
                try
                {
                  ctypeUnsignedShortPtr = \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Actype\u003Cunsigned\u0020short\u003E\u0020\u003E(_Loc);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
                }
                \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                {
                  while (\u003CModule\u003E.std\u002Ectype\u003Cunsigned\u0020short\u003E\u002Eis(ctypeUnsignedShortPtr, (short) 72, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First)))
                  {
                    \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                    if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                      break;
                  }
                  break;
                }
                break;
              }
              break;
            case 36:
              basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
              \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Ecurr_symbol(mpunctUnsignedShortPtr, &allocatorUnsignedShort2);
              // ISSUE: fault handler
              try
              {
                _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort3;
                \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort3);
                if ((\u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 8) == 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) != (int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ec_str(&allocatorUnsignedShort2))
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(&allocatorUnsignedShort2, 0U, uint.MaxValue);
                else if (num2 == 3U && \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(&allocatorUnsignedShort1) <= 1U && (\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) || (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) != (int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ec_str(&allocatorUnsignedShort2)))
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(&allocatorUnsignedShort2, 0U, uint.MaxValue);
                _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort4;
                _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(&allocatorUnsignedShort2, &allocatorUnsignedShort4);
                // ISSUE: cpblk instruction
                __memcpy(ref allocatorUnsignedShort3, (IntPtr) allocatorUnsignedShortPtr, 8);
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                {
                  _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort5;
                  while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u0021\u003D(&allocatorUnsignedShort3, (_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eend(&allocatorUnsignedShort2, &allocatorUnsignedShort5)))
                  {
                    ushort* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&allocatorUnsignedShort3);
                    if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) *numPtr)
                    {
                      \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&allocatorUnsignedShort3);
                      \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                      if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                        break;
                    }
                    else
                      break;
                  }
                }
                _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort6;
                if (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u0021\u003D(&allocatorUnsignedShort3, (_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eend(&allocatorUnsignedShort2, &allocatorUnsignedShort6)))
                  flag1 = true;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort2);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort2);
              break;
            case 43:
              if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
              {
                basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort7;
                basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr1 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epositive_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort7);
                bool flag3;
                // ISSUE: fault handler
                try
                {
                  num1 |= 2U;
                  basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort8;
                  int num3;
                  if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(allocatorUnsignedShortPtr1))
                  {
                    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr2 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epositive_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort8);
                    // ISSUE: fault handler
                    try
                    {
                      num1 |= 4U;
                      if ((int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u005B\u005D(allocatorUnsignedShortPtr2, 0U) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First))
                      {
                        num3 = 1;
                        goto label_75;
                      }
                    }
                    __fault
                    {
                      if (((int) num1 & 4) != 0)
                      {
                        num1 &= 4294967291U;
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort8);
                      }
                    }
                  }
                  // ISSUE: fault handler
                  try
                  {
                    num3 = 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 4) != 0)
                    {
                      num1 &= 4294967291U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort8);
                    }
                  }
label_75:
                  // ISSUE: fault handler
                  try
                  {
                    flag3 = num3 != 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 4) != 0)
                    {
                      num1 &= 4294967291U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort8);
                    }
                  }
                  if (((int) num1 & 4) != 0)
                  {
                    num1 &= 4294967291U;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort8);
                  }
                }
                __fault
                {
                  if (((int) num1 & 2) != 0)
                  {
                    num1 &= 4294967293U;
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort7);
                  }
                }
                if (((int) num1 & 2) != 0)
                {
                  num1 &= 4294967293U;
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort7);
                }
                if (flag3)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort9;
                  basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epositive_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort9);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&allocatorUnsignedShort1, _Right);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort9);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort9);
                  break;
                }
                basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort10;
                basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr3 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Enegative_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort10);
                bool flag4;
                // ISSUE: fault handler
                try
                {
                  num1 |= 8U;
                  basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort11;
                  int num4;
                  if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(allocatorUnsignedShortPtr3))
                  {
                    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr4 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Enegative_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort11);
                    // ISSUE: fault handler
                    try
                    {
                      num1 |= 16U;
                      if ((int) *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u005B\u005D(allocatorUnsignedShortPtr4, 0U) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First))
                      {
                        num4 = 1;
                        goto label_105;
                      }
                    }
                    __fault
                    {
                      if (((int) num1 & 16) != 0)
                      {
                        num1 &= 4294967279U;
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort11);
                      }
                    }
                  }
                  // ISSUE: fault handler
                  try
                  {
                    num4 = 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 16) != 0)
                    {
                      num1 &= 4294967279U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort11);
                    }
                  }
label_105:
                  // ISSUE: fault handler
                  try
                  {
                    flag4 = num4 != 0;
                  }
                  __fault
                  {
                    if (((int) num1 & 16) != 0)
                    {
                      num1 &= 4294967279U;
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort11);
                    }
                  }
                  if (((int) num1 & 16) != 0)
                  {
                    num1 &= 4294967279U;
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort11);
                  }
                }
                __fault
                {
                  if (((int) num1 & 8) != 0)
                  {
                    num1 &= 4294967287U;
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort10);
                  }
                }
                if (((int) num1 & 8) != 0)
                {
                  num1 &= 4294967287U;
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort10);
                }
                if (flag4)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort12;
                  basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Enegative_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort12);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&allocatorUnsignedShort1, _Right);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort12);
                  }
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort12);
                  flag2 = true;
                  break;
                }
                break;
              }
              break;
            case 118:
              int num5 = 0;
              int num6 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Efrac_digits(mpunctUnsignedShortPtr);
              ushort _Ch = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar1;
              \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(mpunctUnsignedShortPtr, &stdAllocatorChar1);
              basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar2;
              // ISSUE: fault handler
              try
              {
                if ((byte) 127 <= (byte) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1))
                {
                  if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                  {
                    while ((uint) _Ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First))
                    {
                      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                      {
                        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First));
                        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                          break;
                      }
                      else
                        break;
                    }
                    goto label_48;
                  }
                  else
                    goto label_48;
                }
                else
                {
                  ushort num7 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(mpunctUnsignedShortPtr);
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar2, 1U, (sbyte) 0);
                  // ISSUE: fault handler
                  try
                  {
                    uint _Off = 0;
                    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                    {
                      do
                      {
                        if ((uint) _Ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                        {
                          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First));
                          if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != sbyte.MaxValue)
                          {
                            sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                            int num8 = (int) *numPtr + 1;
                            *numPtr = (sbyte) num8;
                          }
                        }
                        else if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off) != (sbyte) 0 && num7 != (ushort) 0 && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num7)
                        {
                          \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Eappend(&stdAllocatorChar2, 1U, (sbyte) 0);
                          ++_Off;
                        }
                        else
                          break;
                        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                      }
                      while (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last));
                      if (_Off != 0U)
                      {
                        if ((sbyte) 0 < *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off))
                          ++_Off;
                        else
                          flag1 = true;
                      }
                    }
                    sbyte* numPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar1);
                    if (!flag1)
                    {
                      while (0U < _Off)
                      {
                        if (*numPtr1 != sbyte.MaxValue)
                        {
                          --_Off;
                          if (0U < _Off)
                          {
                            sbyte* numPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                            if ((int) *numPtr1 != (int) *numPtr2)
                              goto label_40;
                          }
                          if (0U == _Off)
                          {
                            sbyte* numPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar2, _Off);
                            if ((int) *numPtr1 < (int) *numPtr3)
                              goto label_40;
                          }
                          if ((sbyte) 0 < numPtr1[1])
                          {
                            ++numPtr1;
                            continue;
                          }
                          continue;
label_40:
                          flag1 = true;
                          goto label_42;
                        }
                        else
                          break;
                      }
                      goto label_45;
                    }
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar2);
                  }
label_42:
                  \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
              break;
label_45:
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar2);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
              }
label_48:
              // ISSUE: fault handler
              try
              {
                if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(mpunctUnsignedShortPtr) && \u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First), _Last))
                {
                  while ((uint) _Ch <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) _Ch + 9)
                  {
                    if (num5 < num6)
                    {
                      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(obj1, \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First));
                      ++num5;
                    }
                    if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First), _Last))
                      break;
                  }
                }
                if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(obj1) == 0U)
                  flag1 = true;
                else if (num5 < num6)
                {
                  uint num9 = (uint) (num6 - num5);
                  do
                  {
                    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(obj1, _Ch);
                    --num9;
                  }
                  while (num9 > 0U);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar1);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar1);
              break;
          }
          ++num2;
          if (flag1)
            break;
        }
        if (!flag1)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (1U < (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort1 + 20))
          {
            _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort13;
            \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort13);
            _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort14;
            _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(&allocatorUnsignedShort1, &allocatorUnsignedShort14);
            // ISSUE: cpblk instruction
            __memcpy(ref allocatorUnsignedShort13, (IntPtr) allocatorUnsignedShortPtr, 8);
            if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
            {
              _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort15;
              while (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u0021\u003D(\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&allocatorUnsignedShort13), (_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eend(&allocatorUnsignedShort1, &allocatorUnsignedShort15)))
              {
                ushort* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&allocatorUnsignedShort13);
                if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) *numPtr)
                {
                  \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
                  if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
                    break;
                }
                else
                  break;
              }
            }
            _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort16;
            if (\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u0021\u003D(&allocatorUnsignedShort13, (_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eend(&allocatorUnsignedShort1, &allocatorUnsignedShort16)))
              goto label_150;
          }
          if (flag2)
          {
            \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einsert(obj1, 0U, 1U, \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 45, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8)));
            goto label_154;
          }
          else
            goto label_154;
        }
label_150:
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(obj1, 0U, uint.MaxValue);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort1);
      }
label_154:
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort1);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num10 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
          // ISSUE: cpblk instruction
          __memcpy((IntPtr) obj0 + 8, ref cvtvec, 8);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putmfld(
    [In] money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U1)] bool _Intl,
    ios_base* _Iosbase,
    ushort _Fill,
    [MarshalAs(UnmanagedType.U1)] bool _Neg,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Val)
  {
    // ISSUE: fault handler
    try
    {
      _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr;
      if (_Intl)
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctUnsignedShortPtr = (_Mpunct\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      else
      {
        locale locale;
        locale* _Loc = \u003CModule\u003E.std\u002Eios_base\u002Egetloc(_Iosbase, &locale);
        // ISSUE: fault handler
        try
        {
          mpunctUnsignedShortPtr = (_Mpunct\u003Cunsigned\u0020short\u003E*) \u003CModule\u003E.std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u0020\u003E(_Loc);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002E\u007Bdtor\u007D), (void*) &locale);
        }
        \u003CModule\u003E.std\u002Elocale\u002E\u007Bdtor\u007D(&locale);
      }
      ushort num1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 8));
      basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
      \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(mpunctUnsignedShortPtr, &stdAllocatorChar);
      // ISSUE: fault handler
      try
      {
        int num2 = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Efrac_digits(mpunctUnsignedShortPtr);
        int num3 = num2 >= 0 ? num2 : -num2;
        uint num4 = (uint) *(int*) ((IntPtr) _Val + 20);
        if (num4 <= (uint) num3)
        {
          uint num5 = num4;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einsert(_Val, 0U, (uint) (num3 - (int) num5 + 1), num1);
        }
        else
        {
          sbyte num6 = *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
          if (num6 != sbyte.MaxValue && (sbyte) 0 < num6)
          {
            ushort _Ch = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(mpunctUnsignedShortPtr);
            sbyte* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002Ec_str(&stdAllocatorChar);
            uint _Off = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val) - (uint) num3;
            sbyte num7 = *numPtr;
            if (num7 != sbyte.MaxValue)
            {
              while ((sbyte) 0 < num7 && (uint) num7 < _Off)
              {
                _Off -= (uint) num7;
                \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einsert(_Val, _Off, 1U, _Ch);
                if ((sbyte) 0 < numPtr[1])
                  ++numPtr;
                num7 = *numPtr;
                if (num7 == sbyte.MaxValue)
                  break;
              }
            }
          }
        }
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort1;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort1);
        // ISSUE: fault handler
        try
        {
          money_base.pattern pattern1;
          if (_Neg)
          {
            money_base.pattern pattern2;
            money_base.pattern* patternPtr = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Eneg_format(mpunctUnsignedShortPtr, &pattern2);
            // ISSUE: cpblk instruction
            __memcpy(ref pattern1, (IntPtr) patternPtr, 4);
            basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort2;
            basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Enegative_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort2);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&allocatorUnsignedShort1, _Right);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort2);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort2);
          }
          else
          {
            money_base.pattern pattern3;
            money_base.pattern* patternPtr = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epos_format(mpunctUnsignedShortPtr, &pattern3);
            // ISSUE: cpblk instruction
            __memcpy(ref pattern1, (IntPtr) patternPtr, 4);
            basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort3;
            basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epositive_sign(mpunctUnsignedShortPtr, &allocatorUnsignedShort3);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&allocatorUnsignedShort1, _Right);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort3);
            }
            \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort3);
          }
          basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort4;
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(&allocatorUnsignedShort4);
          // ISSUE: fault handler
          try
          {
            if ((*(int*) ((IntPtr) _Iosbase + 16) & 8) != 0)
            {
              basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort5;
              basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Ecurr_symbol(mpunctUnsignedShortPtr, &allocatorUnsignedShort5);
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&allocatorUnsignedShort4, _Right);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort5);
              }
              \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort5);
            }
            bool flag = false;
            uint num8 = 0;
            uint num9 = 0;
            do
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              switch (^(sbyte&) ((int) num9 + (IntPtr) &pattern1))
              {
                case 32:
                  ++num8;
                  goto case 120;
                case 36:
                  num8 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(&allocatorUnsignedShort4) + num8;
                  break;
                case 43:
                  num8 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(&allocatorUnsignedShort1) + num8;
                  break;
                case 118:
                  int num10 = 0U < (uint) num3 ? 1 : 0;
                  uint num11 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val) > (uint) num3 ? 0U : (uint) (num3 - (int) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val) + 1);
                  num8 = (uint) ((int) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val) + (int) num11 + num10) + num8;
                  break;
                case 120:
                  if (num9 != 3U)
                  {
                    flag = true;
                    break;
                  }
                  break;
              }
              ++num9;
            }
            while (num9 < 4U);
            uint _Count1 = \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= 0 || (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) <= num8 ? 0U : (uint) \u003CModule\u003E.std\u002Eios_base\u002Ewidth(_Iosbase) - num8;
            uint _Count2 = _Count1;
            int num12 = \u003CModule\u003E.std\u002Eios_base\u002Eflags(_Iosbase) & 448;
            switch (num12)
            {
              case 64:
                uint num13 = 0;
                do
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  switch (^(sbyte&) ((int) num13 + (IntPtr) &pattern1))
                  {
                    case 32:
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&traitsUnsignedShort1, _Dest, _Fill, 1U);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr1, 12);
                      goto case 120;
                    case 36:
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort6;
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr1 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(&allocatorUnsignedShort4, &allocatorUnsignedShort6);
                      _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source1;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source1, (IntPtr) allocatorUnsignedShortPtr1, 8);
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2;
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort2, _Dest, _Source1, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(&allocatorUnsignedShort4));
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr2, 12);
                      break;
                    case 43:
                      if (0U < \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(&allocatorUnsignedShort1))
                      {
                        _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort7;
                        _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr2 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(&allocatorUnsignedShort1, &allocatorUnsignedShort7);
                        _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source2;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source2, (IntPtr) allocatorUnsignedShortPtr2, 8);
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3;
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr3 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort3, _Dest, _Source2, 1U);
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr3, 12);
                        break;
                      }
                      break;
                    case 118:
                      if (num3 == 0)
                      {
                        _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort8;
                        _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr3 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(_Val, &allocatorUnsignedShort8);
                        _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source3;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source3, (IntPtr) allocatorUnsignedShortPtr3, 8);
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort4;
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr4 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort4, _Dest, _Source3, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr4, 12);
                        break;
                      }
                      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val) <= (uint) num3)
                      {
                        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, num1);
                        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(mpunctUnsignedShortPtr));
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort5;
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr5 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&traitsUnsignedShort5, _Dest, num1, (uint) num3 - \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr5, 12);
                        _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort9;
                        _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr4 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(_Val, &allocatorUnsignedShort9);
                        _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source4;
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Source4, (IntPtr) allocatorUnsignedShortPtr4, 8);
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort6;
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr6 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort6, _Dest, _Source4, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val));
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr6, 12);
                        break;
                      }
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort10;
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr5 = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(_Val, &allocatorUnsignedShort10);
                      _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source5;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source5, (IntPtr) allocatorUnsignedShortPtr5, 8);
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort7;
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr7 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort7, _Dest, _Source5, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(_Val) - (uint) num3);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr7, 12);
                      \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(mpunctUnsignedShortPtr));
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort11;
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort12;
                      _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr6 = \u003CModule\u003E.std\u002E_String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002D(\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eend(_Val, &allocatorUnsignedShort11), &allocatorUnsignedShort12, num3);
                      _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source6;
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Source6, (IntPtr) allocatorUnsignedShortPtr6, 8);
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort8;
                      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr8 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort8, _Dest, _Source6, (uint) num3);
                      // ISSUE: cpblk instruction
                      __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr8, 12);
                      break;
                    case 120:
                      if (num12 == 256)
                      {
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort9;
                        ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr9 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&traitsUnsignedShort9, _Dest, _Fill, _Count2);
                        // ISSUE: cpblk instruction
                        __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr9, 12);
                        _Count2 = 0U;
                        break;
                      }
                      break;
                  }
                  ++num13;
                }
                while (num13 < 4U);
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                if (1U < (uint) ^(int&) ((IntPtr) &allocatorUnsignedShort1 + 20))
                {
                  _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort13;
                  _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort14;
                  _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr = \u003CModule\u003E.std\u002E_String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B(\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(&allocatorUnsignedShort1, &allocatorUnsignedShort13), &allocatorUnsignedShort14, 1);
                  _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source;
                  // ISSUE: cpblk instruction
                  __memcpy(ref _Source, (IntPtr) allocatorUnsignedShortPtr, 8);
                  ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort;
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(&traitsUnsignedShort, _Dest, _Source, (uint) (^(int&) ((IntPtr) &allocatorUnsignedShort1 + 20) - 1));
                  // ISSUE: cpblk instruction
                  __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr, 12);
                }
                *(int*) ((IntPtr) _Iosbase + 24) = 0;
                \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj1, _Dest, _Fill, _Count2);
                break;
              case 256:
                if (flag)
                  goto case 64;
                else
                  goto default;
              default:
                ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort10;
                ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr10 = \u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(&traitsUnsignedShort10, _Dest, _Fill, _Count1);
                // ISSUE: cpblk instruction
                __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr10, 12);
                _Count2 = 0U;
                goto case 64;
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort4);
          }
          \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort4);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort1);
        }
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&allocatorUnsignedShort1);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D(&stdAllocatorChar);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) _Val);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(_Val);
    return obj1;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    uint _Count)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Count);
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Ptr);
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Count,
    ushort _Ch)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Count, _Ch);
    return obj0;
  }

  [SpecialName]
  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, false, 0U);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort _Ch)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(obj0, 1U, _Ch);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Count,
    ushort _Ch)
  {
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* allocatorUnsignedShortPtr = obj0;
        int _Off = *(int*) ((IntPtr) allocatorUnsignedShortPtr + 20);
        int _Count1 = (int) _Count;
        int _Ch1 = (int) _Ch;
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Chassign(allocatorUnsignedShortPtr, (uint) _Off, (uint) _Count1, (ushort) _Ch1);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Right, 0U, uint.MaxValue);
  }

  internal static unsafe _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ebegin(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj1, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0), (_Container_base*) obj0);
    return obj1;
  }

  internal static unsafe ushort* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u005B\u005D(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Off)
  {
    if (_Off > (uint) *(int*) ((IntPtr) obj0 + 20))
      \u003CModule\u003E._invalid_parameter_noinfo();
    return (ushort*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0));
  }

  internal static unsafe ushort* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Ec_str(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0);
  }

  internal static unsafe uint std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esize(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return (uint) *(int*) ((IntPtr) obj0 + 20);
  }

  internal static unsafe moneypunct\u003Cunsigned\u0020short\u002C0\u003E* std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cunsigned\u0020short\u002C0\u003E* obj0,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cunsigned\u0020short\u003E*) obj0, _Refs, false);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe _Mpunct\u003Cunsigned\u0020short\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj,
    uint _Refs,
    [MarshalAs(UnmanagedType.U1)] bool _Intl)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      *(sbyte*) ((IntPtr) obj0 + 40) = (sbyte) _Intl;
      \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Init(obj0, _Lobj);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Tidy(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 16));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 20));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 24));
  }

  internal static unsafe moneypunct\u003Cunsigned\u0020short\u002C1\u003E* std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E\u007Bctor\u007D(
    [In] moneypunct\u003Cunsigned\u0020short\u002C1\u003E* obj0,
    uint _Refs)
  {
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D((_Mpunct\u003Cunsigned\u0020short\u003E*) obj0, _Refs, true);
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe time_base.dateorder std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edate_order(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<time_base.dateorder (IntPtr)>) *(int*) (*(int*) traitsUnsignedShortPtr + 4))((IntPtr) traitsUnsignedShortPtr);
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_monthname(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
    ref istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref traitsUnsignedShort1;
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2 = _First;
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3 = _Last;
    ios_base* iosBasePtr = _Iosbase;
    int* numPtr = _State;
    tm* tmPtr = _Pt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*, istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E, istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E, ios_base*, int*, tm*)>) *(int*) (*(int*) obj0 + 20))((tm*) traitsUnsignedShortPtr, (int*) ref local, (ios_base*) traitsUnsignedShort2, traitsUnsignedShort3, (istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E) (IntPtr) iosBasePtr, (istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) numPtr, (IntPtr) tmPtr);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 12);
    return obj1;
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Eget_year(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Last,
    ios_base* _Iosbase,
    int* _State,
    tm* _Pt)
  {
    time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* traitsUnsignedShortPtr = obj0;
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
    ref istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref traitsUnsignedShort1;
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2 = _First;
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort3 = _Last;
    ios_base* iosBasePtr = _Iosbase;
    int* numPtr = _State;
    tm* tmPtr = _Pt;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*, istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E, istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E, ios_base*, int*, tm*)>) *(int*) (*(int*) obj0 + 24))((tm*) traitsUnsignedShortPtr, (int*) ref local, (ios_base*) traitsUnsignedShort2, traitsUnsignedShort3, (istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E) (IntPtr) iosBasePtr, (istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) numPtr, (IntPtr) tmPtr);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 12);
    return obj1;
  }

  internal static unsafe time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7time_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Etime_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Init(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Cvt = (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 20);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) _Cvt, ref cvtvec, 8);
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 12) = 0;
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E(\u003CModule\u003E.std\u002E_Locinfo\u002E_Getdays(_Lobj), (ushort*) 0, (_Cvtvec*) _Cvt);
      *(int*) ((IntPtr) obj0 + 12) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E(\u003CModule\u003E.std\u002E_Locinfo\u002E_Getmonths(_Lobj), (ushort*) 0, (_Cvtvec*) _Cvt);
      *(int*) ((IntPtr) obj0 + 16) = \u003CModule\u003E.std\u002E_Locinfo\u002E_Getdateorder(_Lobj);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 == 0U)
          return;
        throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
  }

  internal static unsafe int std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getint(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Last,
    int _Lo,
    int _Hi,
    int* _Val)
  {
    ushort num1 = \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 48, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20));
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
    sbyte* numPtr1 = (sbyte*) &arrayTypeBy0CaD;
    if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
    {
      if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 43, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20)))
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy0CaD = (sbyte) 43;
        numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
      else if ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E((sbyte) 45, (ushort*) 0, (_Cvtvec*) ((IntPtr) obj0 + 20)))
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) ref arrayTypeBy0CaD = (sbyte) 45;
        numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CaD + 1);
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
      }
    }
    bool flag = false;
    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
    {
      while ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) == (int) num1)
      {
        flag = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
          break;
      }
      if (flag)
      {
        *numPtr1 = (sbyte) 48;
        ++numPtr1;
      }
    }
    if (\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
    {
      while ((uint) num1 <= (uint) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) && (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) <= (int) num1 + 9)
      {
        *numPtr1 = (sbyte) ((int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First) - (int) num1 + 48);
        // ISSUE: cast to a reference type
        if ((IntPtr) numPtr1 < (\u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D&) ((IntPtr) &arrayTypeBy0CaD + 31))
          ++numPtr1;
        flag = true;
        \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(_First);
        if (!\u003CModule\u003E.std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
          break;
      }
    }
    if (!flag)
      numPtr1 = (sbyte*) &arrayTypeBy0CaD;
    *numPtr1 = (sbyte) 0;
    int num2 = 0;
    sbyte* numPtr2;
    int num3 = \u003CModule\u003E._Stolx((sbyte*) &arrayTypeBy0CaD, &numPtr2, 10, &num2);
    int unsignedShortGetint = 0;
    if (\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(_First, _Last))
      unsignedShortGetint = 1;
    if ((IntPtr) numPtr2 != ref arrayTypeBy0CaD && num2 == 0 && num3 >= _Lo && _Hi >= num3)
      *_Val = num3;
    else
      unsignedShortGetint |= 2;
    return unsignedShortGetint;
  }

  internal static unsafe void std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Tidy(
    [In] time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 8));
    \u003CModule\u003E.delete\u005B\u005D((void*) *(int*) ((IntPtr) obj0 + 12));
  }

  internal static unsafe time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    uint _Refs)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4);
      *(int*) ((IntPtr) obj0 + 8) = 0;
      // ISSUE: fault handler
      try
      {
        bool flag = false;
        int num = 0;
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
          RuntimeHelpers.PrepareConstrainedRegions();
          try
          {
          }
          finally
          {
            \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
            flag = true;
          }
          _Locinfo locinfo;
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Init(obj0, &locinfo);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
          }
          \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
        }
        finally
        {
          if (flag)
            \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Init(
    [In] time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    _Locinfo* _Lobj)
  {
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 12, ref cvtvec, 8);
    _Timevec timevec;
    _Timevec* timevecPtr = \u003CModule\u003E.std\u002E_Locinfo\u002E_Gettnames(_Lobj, &timevec);
    // ISSUE: fault handler
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = *(int*) timevecPtr;
      *(int*) timevecPtr = 0;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Timevec\u002E\u007Bdtor\u007D), (void*) &timevec);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.free((void*) ^(int&) ref timevec);
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U2)] char _Right)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 8);
    if (num == 0U || ushort.MaxValue == \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esputc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) num, _Right))
      *(sbyte*) ((IntPtr) obj0 + 4) = (sbyte) 1;
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    if (*(byte*) ((IntPtr) obj0 + 8) == (byte) 0)
    {
      int num = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    return (char) *(ushort*) ((IntPtr) obj0 + 10);
  }

  internal static unsafe istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Inc(obj0);
    return obj0;
  }

  internal static unsafe ushort std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    if (*(byte*) ((IntPtr) obj0 + 8) == (byte) 0)
    {
      int num = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    return *(ushort*) ((IntPtr) obj0 + 10);
  }

  internal static unsafe istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inc(obj0);
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putc(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count)
  {
    if (0U < _Count)
    {
      num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* _Cvt = (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E(*_Ptr, (char*) 0, (_Cvtvec*) _Cvt));
        --_Count;
        ++_Ptr;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(
    [In] num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count,
    [MarshalAs(UnmanagedType.U2)] char _Kseparator)
  {
    while (true)
    {
      sbyte* numPtr = (sbyte*) \u003CModule\u003E.memchr((void*) _Ptr, 0, _Count);
      uint _Count1 = (IntPtr) numPtr == IntPtr.Zero ? _Count : (uint) ((IntPtr) numPtr - (IntPtr) _Ptr);
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT1;
      ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &charTraitsWcharT1, _Dest, _Ptr, _Count1);
      // ISSUE: cpblk instruction
      __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr1, 12);
      _Ptr = (sbyte*) ((int) _Count1 + (IntPtr) _Ptr);
      _Count -= _Count1;
      if (_Count != 0U)
      {
        if (_Kseparator != char.MinValue)
        {
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E charTraitsWcharT2;
          ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* charTraitsWcharTPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &charTraitsWcharT2, _Dest, _Kseparator, 1U);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) charTraitsWcharTPtr2, 12);
        }
        ++_Ptr;
        --_Count;
      }
      else
        break;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Enumpunct\u003Cwchar_t\u003E\u002Edecimal_point(
    [In] numpunct\u003Cwchar_t\u003E* obj0)
  {
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (char) __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) numpunctWcharTPtr + 4))((IntPtr) numpunctWcharTPtr);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Enumpunct\u003Cwchar_t\u003E\u002Ethousands_sep(
    [In] numpunct\u003Cwchar_t\u003E* obj0)
  {
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (char) __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) numpunctWcharTPtr + 8))((IntPtr) numpunctWcharTPtr);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cwchar_t\u003E\u002Egrouping(
    [In] numpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cwchar_t\u003E* numpunctWcharTPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 12))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) numpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Put(
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E _Source,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        char* chPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(&_Source);
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, *chPtr);
        --_Count;
        \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(&_Source);
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _Dest, 12);
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Rep(
    [In] ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    ostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E _Dest,
    [MarshalAs(UnmanagedType.U2)] char _Ch,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D(&_Dest, _Ch);
        --_Count;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _Dest, 12);
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (_Count < num)
      num = _Count;
    if (obj0 == _Right)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj0, num + _Roff, uint.MaxValue);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj0, 0U, _Roff);
    }
    else if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, num, false))
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (char*) ((int) _Roff * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(_Right)), num);
      *(int*) ((IntPtr) obj0 + 20) = (int) num;
      *(short*) ((int) num * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    uint _Num)
  {
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Inside(obj0, _Ptr))
    {
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right = obj0;
      IntPtr _Roff = (IntPtr) _Ptr - (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0) >> 1;
      int _Count = (int) _Num;
      return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(_Right, _Right, (uint) _Roff, (uint) _Count);
    }
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, _Num, false))
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), _Ptr, _Num);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Num;
      *(short*) ((int) _Num * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr)
  {
    uint _Num = \u003CModule\u003E.wcslen(_Ptr);
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Num);
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Count,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    if (_Count == uint.MaxValue)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, _Count, false))
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Chassign(obj0, 0U, _Count, _Ch);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Count;
      *(short*) ((int) _Count * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Einsert(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) (((int) _Off + (int) _Count) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - _Off - _Count, (char*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 20) - _Off);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Chassign(obj0, _Off, _Count, _Ch);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num1 < _Count)
      _Count = num1;
    if (0U < _Count)
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - _Off, (char*) (((int) _Off + (int) _Count) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), num1 - _Count);
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Count;
      *(int*) ((IntPtr) obj0 + 20) = (int) num2;
      *(short*) ((int) num2 * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eend(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) obj1, (char*) (*(int*) ((IntPtr) obj0 + 20) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), (_Container_base*) obj0);
    return obj1;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eresize(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (_Newsize <= num)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eerase(obj0, _Newsize, uint.MaxValue);
    else
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(obj0, _Newsize - num, _Ch);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Chassign(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    [MarshalAs(UnmanagedType.U2)] char _Ch)
  {
    if (_Count == 1U)
      *(short*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) _Ch;
    else
      \u003CModule\u003E.wmemset((char*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), _Ch, _Count);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U1)] bool _Trim)
  {
    if (2147483646U < _Newsize)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if ((uint) *(int*) ((IntPtr) obj0 + 24) < _Newsize)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Copy(obj0, _Newsize, (uint) *(int*) ((IntPtr) obj0 + 20));
    else if (_Trim && _Newsize < 8U)
    {
      uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
      uint _Newsize1 = _Newsize >= num ? num : _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, _Newsize1);
    }
    else if (_Newsize == 0U)
    {
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0) = char.MinValue;
    }
    return 0U < _Newsize;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Built,
    uint _Newsize)
  {
    if (_Built && 8U <= (uint) *(int*) ((IntPtr) obj0 + 24))
    {
      basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _First1 = (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      char* _First2 = (char*) *(int*) _First1;
      if (0U < _Newsize)
        \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) _First1, 8U, _First2, _Newsize);
      \u003CModule\u003E.delete((void*) _First2);
    }
    *(int*) ((IntPtr) obj0 + 24) = 7;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
    *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  internal static unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (char*) *(int*) ((IntPtr) obj0 + 4) : (char*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe char* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (char*) *(int*) ((IntPtr) obj0 + 4) : (char*) ((IntPtr) obj0 + 4);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edecimal_point(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (char) __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) mpunctWcharTPtr + 4))((IntPtr) mpunctWcharTPtr);
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002E_Mpunct\u003Cwchar_t\u003E\u002Ethousands_sep(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return (char) __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) mpunctWcharTPtr + 8))((IntPtr) mpunctWcharTPtr);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Egrouping(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 12))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) mpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Ecurr_symbol(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    ref basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E local = ref stdAllocatorWcharT;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 16))((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) mpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epositive_sign(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    ref basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E local = ref stdAllocatorWcharT;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 20))((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) mpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Enegative_sign(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    ref basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E local = ref stdAllocatorWcharT;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* (IntPtr, basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 24))((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) mpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorWcharT);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorWcharT, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002E_Mpunct\u003Cwchar_t\u003E\u002Efrac_digits(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0)
  {
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) mpunctWcharTPtr + 28))((IntPtr) mpunctWcharTPtr);
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Epos_format(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    money_base.pattern pattern;
    ref money_base.pattern local = ref pattern;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<money_base.pattern* (IntPtr, money_base.pattern*)>) *(int*) (*(int*) obj0 + 32))((money_base.pattern*) mpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 4);
    return obj1;
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cwchar_t\u003E\u002Eneg_format(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr = obj0;
    money_base.pattern pattern;
    ref money_base.pattern local = ref pattern;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<money_base.pattern* (IntPtr, money_base.pattern*)>) *(int*) (*(int*) obj0 + 36))((money_base.pattern*) mpunctWcharTPtr, (IntPtr) ref local);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 4);
    return obj1;
  }

  internal static unsafe _Mpunct\u003Cwchar_t\u003E* std\u002E_Mpunct\u003Cwchar_t\u003E\u002E\u007Bctor\u007D(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    uint _Refs,
    [MarshalAs(UnmanagedType.U1)] bool _Intl)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4);
      *(sbyte*) ((IntPtr) obj0 + 40) = (sbyte) _Intl;
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Init(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr1 = (_Mpunct\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 44);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) mpunctWcharTPtr1, ref cvtvec, 8);
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) ((IntPtr) obj0 + 20) = 0;
    *(int*) ((IntPtr) obj0 + 24) = 0;
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) *(int*) ((IntPtr) lconvPtr + 28), (sbyte*) 0, (_Cvtvec*) mpunctWcharTPtr1);
      sbyte* _Ptr1 = *(byte*) ((IntPtr) obj0 + 40) == (byte) 0 ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 16) : (sbyte*) *(int*) ((IntPtr) lconvPtr + 12);
      *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E(_Ptr1, (char*) 0, (_Cvtvec*) mpunctWcharTPtr1);
      sbyte* _Ptr2 = (byte) 4 >= (byte) *(sbyte*) ((IntPtr) lconvPtr + 46) ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 32) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
      *(int*) ((IntPtr) obj0 + 20) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E(_Ptr2, (char*) 0, (_Cvtvec*) mpunctWcharTPtr1);
      sbyte* _Ptr3 = (byte) 4 >= (byte) *(sbyte*) ((IntPtr) lconvPtr + 47) ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 36) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01JOAMLHOP\u0040\u003F9\u003F\u0024AA\u0040;
      *(int*) ((IntPtr) obj0 + 24) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cwchar_t\u003E(_Ptr3, (char*) 0, (_Cvtvec*) mpunctWcharTPtr1);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    _Mpunct\u003Cwchar_t\u003E* _Cvt = (_Mpunct\u003Cwchar_t\u003E*) ((IntPtr) obj0 + 44);
    *(short*) ((IntPtr) obj0 + 12) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E(*(sbyte*) *(int*) ((IntPtr) lconvPtr + 20), (char*) 0, (_Cvtvec*) _Cvt);
    *(short*) ((IntPtr) obj0 + 14) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cwchar_t\u003E(*(sbyte*) *(int*) ((IntPtr) lconvPtr + 24), (char*) 0, (_Cvtvec*) _Cvt);
    int num3 = *(byte*) ((IntPtr) obj0 + 40) == (byte) 0 ? (int) *(sbyte*) ((IntPtr) lconvPtr + 41) : (int) *(sbyte*) ((IntPtr) lconvPtr + 40);
    *(int*) ((IntPtr) obj0 + 28) = num3;
    if (num3 < 0 || (int) sbyte.MaxValue <= num3)
      *(int*) ((IntPtr) obj0 + 28) = 0;
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr2 = obj0;
    IntPtr _Pattern1 = (IntPtr) mpunctWcharTPtr2 + 32;
    int _Sepbyspace1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 43);
    int _Symbolprecedes1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 42);
    int _Signposition1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 46);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Makpat(mpunctWcharTPtr2, (money_base.pattern*) _Pattern1, (uint) _Sepbyspace1, (uint) _Symbolprecedes1, (uint) _Signposition1);
    _Mpunct\u003Cwchar_t\u003E* mpunctWcharTPtr3 = obj0;
    IntPtr _Pattern2 = (IntPtr) mpunctWcharTPtr3 + 36;
    int _Sepbyspace2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 45);
    int _Symbolprecedes2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 44);
    int _Signposition2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 47);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Makpat(mpunctWcharTPtr3, (money_base.pattern*) _Pattern2, (uint) _Sepbyspace2, (uint) _Symbolprecedes2, (uint) _Signposition2);
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putc(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count)
  {
    if (0U < _Count)
    {
      num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* _Cvt = (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) ((IntPtr) obj0 + 8);
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(*_Ptr, (ushort*) 0, (_Cvtvec*) _Cvt));
        --_Count;
        ++_Ptr;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putgrouped(
    [In] num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* obj0,
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    sbyte* _Ptr,
    uint _Count,
    ushort _Kseparator)
  {
    while (true)
    {
      sbyte* numPtr = (sbyte*) \u003CModule\u003E.memchr((void*) _Ptr, 0, _Count);
      uint _Count1 = (IntPtr) numPtr == IntPtr.Zero ? _Count : (uint) ((IntPtr) numPtr - (IntPtr) _Ptr);
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort1;
      ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr1 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Putc(obj0, &traitsUnsignedShort1, _Dest, _Ptr, _Count1);
      // ISSUE: cpblk instruction
      __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr1, 12);
      _Ptr = (sbyte*) ((int) _Count1 + (IntPtr) _Ptr);
      _Count -= _Count1;
      if (_Count != 0U)
      {
        if (_Kseparator != (ushort) 0)
        {
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E traitsUnsignedShort2;
          ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* traitsUnsignedShortPtr2 = \u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(obj0, &traitsUnsignedShort2, _Dest, _Kseparator, 1U);
          // ISSUE: cpblk instruction
          __memcpy(ref _Dest, (IntPtr) traitsUnsignedShortPtr2, 12);
        }
        ++_Ptr;
        --_Count;
      }
      else
        break;
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref _Dest, 12);
    return obj1;
  }

  internal static unsafe ushort std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) numpunctUnsignedShortPtr + 4))((IntPtr) numpunctUnsignedShortPtr);
  }

  internal static unsafe ushort std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) numpunctUnsignedShortPtr + 8))((IntPtr) numpunctUnsignedShortPtr);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(
    [In] numpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    numpunct\u003Cunsigned\u0020short\u003E* numpunctUnsignedShortPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 12))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) numpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Put(
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E _Source,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        ushort* numPtr = \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(&_Source);
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, *numPtr);
        --_Count;
        \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(&_Source);
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _Dest, 12);
    return obj0;
  }

  internal static unsafe ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Rep(
    [In] ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E _Dest,
    ushort _Ch,
    uint _Count)
  {
    if (0U < _Count)
    {
      do
      {
        \u003CModule\u003E.std\u002Eostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D(&_Dest, _Ch);
        --_Count;
      }
      while (_Count > 0U);
    }
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0, ref _Dest, 12);
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (_Count < num)
      num = _Count;
    if (obj0 == _Right)
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(obj0, num + _Roff, uint.MaxValue);
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(obj0, 0U, _Roff);
    }
    else if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, num, false))
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), (ushort*) ((int) _Roff * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(_Right)), num);
      *(int*) ((IntPtr) obj0 + 20) = (int) num;
      *(short*) ((int) num * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    uint _Num)
  {
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inside(obj0, _Ptr))
    {
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right = obj0;
      IntPtr _Roff = (IntPtr) _Ptr - (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0) >> 1;
      int _Count = (int) _Num;
      return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(_Right, _Right, (uint) _Roff, (uint) _Count);
    }
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, _Num, false))
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0), (uint) *(int*) ((IntPtr) obj0 + 24), _Ptr, _Num);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Num;
      *(short*) ((int) _Num * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr)
  {
    uint _Num = \u003CModule\u003E.wcslen((char*) _Ptr);
    return \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(obj0, _Ptr, _Num);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Count,
    ushort _Ch)
  {
    if (_Count == uint.MaxValue)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, _Count, false))
    {
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Chassign(obj0, 0U, _Count, _Ch);
      *(int*) ((IntPtr) obj0 + 20) = (int) _Count;
      *(short*) ((int) _Count * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Einsert(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    ushort _Ch)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    if ((uint) (-1 - *(int*) ((IntPtr) obj0 + 20)) <= _Count)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = _Count + (uint) *(int*) ((IntPtr) obj0 + 20);
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) (((int) _Off + (int) _Count) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - _Off - _Count, (ushort*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 20) - _Off);
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Chassign(obj0, _Off, _Count, _Ch);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
      }
    }
    return obj0;
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) obj0 + 20) < _Off)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Off;
    if (num1 < _Count)
      _Count = num1;
    if (0U < _Count)
    {
      \u003CModule\u003E.std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - _Off, (ushort*) (((int) _Off + (int) _Count) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), num1 - _Count);
      uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20) - _Count;
      *(int*) ((IntPtr) obj0 + 20) = (int) num2;
      *(short*) ((int) num2 * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
    }
    return obj0;
  }

  internal static unsafe _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eend(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D((_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) obj1, (ushort*) (*(int*) ((IntPtr) obj0 + 20) * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (_Container_base*) obj0);
    return obj1;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eresize(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Newsize,
    ushort _Ch)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (_Newsize <= num)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eerase(obj0, _Newsize, uint.MaxValue);
    else
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(obj0, _Newsize - num, _Ch);
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Chassign(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Off,
    uint _Count,
    ushort _Ch)
  {
    if (_Count == 1U)
      *(short*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) _Ch;
    else
      \u003CModule\u003E.wmemset((char*) ((int) _Off * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (char) _Ch, _Count);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Newsize,
    [MarshalAs(UnmanagedType.U1)] bool _Trim)
  {
    if (2147483646U < _Newsize)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if ((uint) *(int*) ((IntPtr) obj0 + 24) < _Newsize)
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Copy(obj0, _Newsize, (uint) *(int*) ((IntPtr) obj0 + 20));
    else if (_Trim && _Newsize < 8U)
    {
      uint num = (uint) *(int*) ((IntPtr) obj0 + 20);
      uint _Newsize1 = _Newsize >= num ? num : _Newsize;
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, _Newsize1);
    }
    else if (_Newsize == 0U)
    {
      *(int*) ((IntPtr) obj0 + 20) = 0;
      *\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0) = (ushort) 0;
    }
    return 0U < _Newsize;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _Built,
    uint _Newsize)
  {
    if (_Built && 8U <= (uint) *(int*) ((IntPtr) obj0 + 24))
    {
      basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _First1 = (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) ((IntPtr) obj0 + 4);
      ushort* _First2 = (ushort*) *(int*) _First1;
      if (0U < _Newsize)
        \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) _First1, 8U, _First2, _Newsize);
      \u003CModule\u003E.delete((void*) _First2);
    }
    *(int*) ((IntPtr) obj0 + 24) = 7;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
    *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  internal static unsafe ushort* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (ushort*) *(int*) ((IntPtr) obj0 + 4) : (ushort*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    return 8U <= (uint) *(int*) ((IntPtr) obj0 + 24) ? (ushort*) *(int*) ((IntPtr) obj0 + 4) : (ushort*) ((IntPtr) obj0 + 4);
  }

  internal static unsafe ushort std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edecimal_point(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) mpunctUnsignedShortPtr + 4))((IntPtr) mpunctUnsignedShortPtr);
  }

  internal static unsafe ushort std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Ethousands_sep(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<ushort (IntPtr)>) *(int*) (*(int*) mpunctUnsignedShortPtr + 8))((IntPtr) mpunctUnsignedShortPtr);
  }

  internal static unsafe basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Egrouping(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    ref basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E local = ref stdAllocatorChar;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E* (IntPtr, basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 12))((basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) mpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Ecurr_symbol(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    ref basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref allocatorUnsignedShort;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 16))((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) mpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epositive_sign(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    ref basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref allocatorUnsignedShort;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 20))((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) mpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Enegative_sign(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1)
  {
    uint num1 = 0;
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    ref basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E local = ref allocatorUnsignedShort;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int _Right = (int) __calli((__FnPtr<basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* (IntPtr, basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*)>) *(int*) (*(int*) obj0 + 24))((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) mpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(obj1, (basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) _Right);
        num1 = 1U;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &allocatorUnsignedShort);
      }
      \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(&allocatorUnsignedShort, true, 0U);
      return obj1;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) obj1);
      }
    }
  }

  internal static unsafe int std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Efrac_digits(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0)
  {
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    return __calli((__FnPtr<int (IntPtr)>) *(int*) (*(int*) mpunctUnsignedShortPtr + 28))((IntPtr) mpunctUnsignedShortPtr);
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Epos_format(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    money_base.pattern pattern;
    ref money_base.pattern local = ref pattern;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<money_base.pattern* (IntPtr, money_base.pattern*)>) *(int*) (*(int*) obj0 + 32))((money_base.pattern*) mpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 4);
    return obj1;
  }

  internal static unsafe money_base.pattern* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Eneg_format(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    [In] money_base.pattern* obj1)
  {
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr = obj0;
    money_base.pattern pattern;
    ref money_base.pattern local = ref pattern;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<money_base.pattern* (IntPtr, money_base.pattern*)>) *(int*) (*(int*) obj0 + 36))((money_base.pattern*) mpunctUnsignedShortPtr, (IntPtr) ref local);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, num, 4);
    return obj1;
  }

  internal static unsafe _Mpunct\u003Cunsigned\u0020short\u003E* std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E\u007Bctor\u007D(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    uint _Refs,
    [MarshalAs(UnmanagedType.U1)] bool _Intl)
  {
    *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7facet\u0040locale\u0040std\u0040\u00406B\u0040 + 4);
    *(int*) ((IntPtr) obj0 + 4) = (int) _Refs;
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7money_base\u0040std\u0040\u00406B\u0040 + 4);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Elocale\u002Efacet\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    // ISSUE: fault handler
    try
    {
      *(int*) obj0 = (int) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4);
      *(sbyte*) ((IntPtr) obj0 + 40) = (sbyte) _Intl;
      bool flag = false;
      int num = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
          flag = true;
        }
        _Locinfo locinfo;
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bctor\u007D(&locinfo, (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01GFHCPBMG\u0040C\u003F\u0024AA\u0040);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Init(obj0, &locinfo);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002E_Locinfo\u002E\u007Bdtor\u007D), (void*) &locinfo);
        }
        \u003CModule\u003E.std\u002E_Locinfo\u002E\u007Bdtor\u007D(&locinfo);
      }
      finally
      {
        if (flag)
          \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Emoney_base\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Init(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    _Locinfo* _Lobj)
  {
    // ISSUE: untyped stack allocation
    int num1 = (int) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    _Cvtvec cvtvec = \u003CModule\u003E._Getcvt();
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr1 = (_Mpunct\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 44);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) mpunctUnsignedShortPtr1, ref cvtvec, 8);
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    *(int*) ((IntPtr) obj0 + 8) = 0;
    *(int*) ((IntPtr) obj0 + 16) = 0;
    *(int*) ((IntPtr) obj0 + 20) = 0;
    *(int*) ((IntPtr) obj0 + 24) = 0;
    try
    {
      *(int*) ((IntPtr) obj0 + 8) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cchar\u003E((sbyte*) *(int*) ((IntPtr) lconvPtr + 28), (sbyte*) 0, (_Cvtvec*) mpunctUnsignedShortPtr1);
      sbyte* _Ptr1 = *(byte*) ((IntPtr) obj0 + 40) == (byte) 0 ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 16) : (sbyte*) *(int*) ((IntPtr) lconvPtr + 12);
      *(int*) ((IntPtr) obj0 + 16) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E(_Ptr1, (ushort*) 0, (_Cvtvec*) mpunctUnsignedShortPtr1);
      sbyte* _Ptr2 = (byte) 4 >= (byte) *(sbyte*) ((IntPtr) lconvPtr + 46) ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 32) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_00CNPNBAHC\u0040\u003F\u0024AA\u0040;
      *(int*) ((IntPtr) obj0 + 20) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E(_Ptr2, (ushort*) 0, (_Cvtvec*) mpunctUnsignedShortPtr1);
      sbyte* _Ptr3 = (byte) 4 >= (byte) *(sbyte*) ((IntPtr) lconvPtr + 47) ? (sbyte*) *(int*) ((IntPtr) lconvPtr + 36) : (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01JOAMLHOP\u0040\u003F9\u003F\u0024AA\u0040;
      *(int*) ((IntPtr) obj0 + 24) = (int) \u003CModule\u003E.std\u002E_Maklocstr\u003Cunsigned\u0020short\u003E(_Ptr3, (ushort*) 0, (_Cvtvec*) mpunctUnsignedShortPtr1);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
          \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Tidy(obj0);
          \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
    _Mpunct\u003Cunsigned\u0020short\u003E* _Cvt = (_Mpunct\u003Cunsigned\u0020short\u003E*) ((IntPtr) obj0 + 44);
    *(short*) ((IntPtr) obj0 + 12) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(*(sbyte*) *(int*) ((IntPtr) lconvPtr + 20), (ushort*) 0, (_Cvtvec*) _Cvt);
    *(short*) ((IntPtr) obj0 + 14) = (short) \u003CModule\u003E.std\u002E_Maklocchr\u003Cunsigned\u0020short\u003E(*(sbyte*) *(int*) ((IntPtr) lconvPtr + 24), (ushort*) 0, (_Cvtvec*) _Cvt);
    int num3 = *(byte*) ((IntPtr) obj0 + 40) == (byte) 0 ? (int) *(sbyte*) ((IntPtr) lconvPtr + 41) : (int) *(sbyte*) ((IntPtr) lconvPtr + 40);
    *(int*) ((IntPtr) obj0 + 28) = num3;
    if (num3 < 0 || (int) sbyte.MaxValue <= num3)
      *(int*) ((IntPtr) obj0 + 28) = 0;
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr2 = obj0;
    IntPtr _Pattern1 = (IntPtr) mpunctUnsignedShortPtr2 + 32;
    int _Sepbyspace1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 43);
    int _Symbolprecedes1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 42);
    int _Signposition1 = (int) *(sbyte*) ((IntPtr) lconvPtr + 46);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Makpat(mpunctUnsignedShortPtr2, (money_base.pattern*) _Pattern1, (uint) _Sepbyspace1, (uint) _Symbolprecedes1, (uint) _Signposition1);
    _Mpunct\u003Cunsigned\u0020short\u003E* mpunctUnsignedShortPtr3 = obj0;
    IntPtr _Pattern2 = (IntPtr) mpunctUnsignedShortPtr3 + 36;
    int _Sepbyspace2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 45);
    int _Symbolprecedes2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 44);
    int _Signposition2 = (int) *(sbyte*) ((IntPtr) lconvPtr + 47);
    \u003CModule\u003E.std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Makpat(mpunctUnsignedShortPtr3, (money_base.pattern*) _Pattern2, (uint) _Sepbyspace2, (uint) _Symbolprecedes2, (uint) _Signposition2);
  }

  internal static unsafe void std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Inc(
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num != 0U && ushort.MaxValue != \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esbumpc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) num))
    {
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 4) = 0;
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    }
  }

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Peek(
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 != 0U)
    {
      ushort num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Esgetc((basic_streambuf\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E*) num1);
      if (ushort.MaxValue != num2)
      {
        *(short*) ((IntPtr) obj0 + 10) = (short) num2;
        goto label_4;
      }
    }
    *(int*) ((IntPtr) obj0 + 4) = 0;
label_4:
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    return (char) *(ushort*) ((IntPtr) obj0 + 10);
  }

  internal static unsafe _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = 0;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return obj0;
  }

  internal static unsafe char* std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        return (char*) *(int*) ((IntPtr) obj0 + 4);
      default:
        uint num = (uint) *(int*) obj0;
        if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (*(int*) ((int) num + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) num))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  internal static unsafe _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + 2;
        return obj0;
      default:
        uint num = (uint) *(int*) obj0;
        if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (*(int*) ((int) num + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) num))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u0021\u003D(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    return !\u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D\u003D(obj0, _Right);
  }

  internal static unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B(
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    int _Off)
  {
    _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    // ISSUE: cpblk instruction
    __memcpy(ref stdAllocatorWcharT, (IntPtr) obj0, 8);
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT, _Off);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref stdAllocatorWcharT, 8);
    return obj1;
  }

  internal static unsafe _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002D(
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj1,
    int _Off)
  {
    _String_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E stdAllocatorWcharT;
    // ISSUE: cpblk instruction
    __memcpy(ref stdAllocatorWcharT, (IntPtr) obj0, 8);
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) &stdAllocatorWcharT, -_Off);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref stdAllocatorWcharT, 8);
    return obj1;
  }

  internal static unsafe void std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inc(
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    uint num = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num != 0U && ushort.MaxValue != \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esbumpc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) num))
    {
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 0;
    }
    else
    {
      *(int*) ((IntPtr) obj0 + 4) = 0;
      *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    }
  }

  internal static unsafe ushort std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Peek(
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    uint num1 = (uint) *(int*) ((IntPtr) obj0 + 4);
    if (num1 != 0U)
    {
      ushort num2 = \u003CModule\u003E.std\u002Ebasic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Esgetc((basic_streambuf\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E*) num1);
      if (ushort.MaxValue != num2)
      {
        *(short*) ((IntPtr) obj0 + 10) = (short) num2;
        goto label_4;
      }
    }
    *(int*) ((IntPtr) obj0 + 4) = 0;
label_4:
    *(sbyte*) ((IntPtr) obj0 + 8) = (sbyte) 1;
    return *(ushort*) ((IntPtr) obj0 + 10);
  }

  internal static unsafe _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    *(int*) obj0 = 0;
    *(int*) ((IntPtr) obj0 + 4) = 0;
    return obj0;
  }

  internal static unsafe ushort* std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        return (ushort*) *(int*) ((IntPtr) obj0 + 4);
      default:
        uint num = (uint) *(int*) obj0;
        if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (*(int*) ((int) num + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) num))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  internal static unsafe _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u002B(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + 2;
        return obj0;
      default:
        uint num = (uint) *(int*) obj0;
        if ((UIntPtr) *(int*) ((IntPtr) obj0 + 4) >= (UIntPtr) (*(int*) ((int) num + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) num))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u0021\u003D(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    return !\u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D\u003D(obj0, _Right);
  }

  internal static unsafe _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B(
    [In] _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    int _Off)
  {
    _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    // ISSUE: cpblk instruction
    __memcpy(ref allocatorUnsignedShort, (IntPtr) obj0, 8);
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) &allocatorUnsignedShort, _Off);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref allocatorUnsignedShort, 8);
    return obj1;
  }

  internal static unsafe _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002D(
    [In] _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    [In] _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj1,
    int _Off)
  {
    _String_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E allocatorUnsignedShort;
    // ISSUE: cpblk instruction
    __memcpy(ref allocatorUnsignedShort, (IntPtr) obj0, 8);
    \u003CModule\u003E.std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D((_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) &allocatorUnsignedShort, -_Off);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj1, ref allocatorUnsignedShort, 8);
    return obj1;
  }

  internal static unsafe basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (num1 < _Count)
      _Count = num1;
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (uint.MaxValue - num2 <= _Count || num2 + _Count < num2)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = (uint) *(int*) ((IntPtr) obj0 + 20) + _Count;
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        uint num3 = (uint) *(int*) ((IntPtr) obj0 + 20);
        \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E((char*) ((int) num3 * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - num3, (char*) ((int) _Roff * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(_Right)), _Count);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Copy(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    uint _Newsize,
    uint _Oldlen)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    uint num3 = _Newsize | 7U;
    if (2147483646U < num3)
    {
      num3 = _Newsize;
    }
    else
    {
      uint num4 = (uint) *(int*) ((IntPtr) obj0 + 24);
      uint num5 = num4 >> 1;
      if (num3 / 3U < num5 && num4 <= 2147483646U - num5)
        num3 = num5 + num4;
    }
    char* _First1 = (char*) 0;
    int num6;
    try
    {
      num6 = (int) num1 + num2;
      _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cwchar_t\u003E(num3 + 1U, (char*) 0);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num6);
      try
      {
        try
        {
          num3 = _Newsize;
          try
          {
            _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cwchar_t\u003E(_Newsize + 1U, (char*) 0);
            goto label_23;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num8 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
            try
            {
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
                \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
              }
              catch (Exception ex3) when (
              {
                // ISSUE: unable to correctly present filter
                num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num8 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              if (num8 != 0U)
                throw;
              else
                goto label_23;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
            }
          }
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num6, (int) num7);
      }
    }
label_23:
    if (0U < _Oldlen)
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First1, num3 + 1U, \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0), _Oldlen);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
    *(int*) ((IntPtr) obj0 + 4) = (int) _First1;
    *(int*) ((IntPtr) obj0 + 24) = (int) num3;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Oldlen;
    *(short*) ((int) _Oldlen * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Inside(
    [In] basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr)
  {
    return _Ptr >= \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0) && (UIntPtr) (*(int*) ((IntPtr) obj0 + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr(obj0) > (UIntPtr) _Ptr;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cwchar_t\u003E\u002E_Makpat(
    [In] _Mpunct\u003Cwchar_t\u003E* obj0,
    money_base.pattern* _Pattern,
    uint _Sepbyspace,
    uint _Symbolprecedes,
    uint _Signposition)
  {
    sbyte* numPtr = *(byte*) ((IntPtr) obj0 + 40) != (byte) 0 || 2U < _Sepbyspace || 1U < _Symbolprecedes || 4U < _Signposition ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04FJCIEOIB\u0040\u0024\u003F\u0024CLxv\u003F\u0024AA\u0040 : (sbyte*) ((((int) _Sepbyspace * 2 + (int) _Symbolprecedes) * 5 + (int) _Signposition) * 4 + (IntPtr) &\u003CModule\u003E.\u003F\u003F_C\u0040_0HJ\u0040PJOMAIHM\u0040\u003F\u0024CLv\u0024x\u003F\u0024CLv\u0024xv\u0024\u003F\u0024CLxv\u003F\u0024CL\u0024xv\u0024\u003F\u0024CLx\u003F\u0024CL\u0024vx\u003F\u0024CL\u0024vx\u0024v\u003F\u0024CLx\u0040);
    \u003CModule\u003E.memcpy_s((void*) _Pattern, 4U, (void*) numPtr, 4U);
  }

  internal static unsafe basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eappend(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right,
    uint _Roff,
    uint _Count)
  {
    if ((uint) *(int*) ((IntPtr) _Right + 20) < _Roff)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xran();
    uint num1 = (uint) *(int*) ((IntPtr) _Right + 20) - _Roff;
    if (num1 < _Count)
      _Count = num1;
    uint num2 = (uint) *(int*) ((IntPtr) obj0 + 20);
    if (uint.MaxValue - num2 <= _Count || num2 + _Count < num2)
      \u003CModule\u003E.std\u002E_String_base\u002E_Xlen();
    if (0U < _Count)
    {
      uint _Newsize = (uint) *(int*) ((IntPtr) obj0 + 20) + _Count;
      if (\u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Grow(obj0, _Newsize, false))
      {
        uint num3 = (uint) *(int*) ((IntPtr) obj0 + 20);
        \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E((ushort*) ((int) num3 * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)), (uint) *(int*) ((IntPtr) obj0 + 24) - num3, (ushort*) ((int) _Roff * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(_Right)), _Count);
        *(int*) ((IntPtr) obj0 + 20) = (int) _Newsize;
        *(short*) ((int) _Newsize * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
      }
    }
    return obj0;
  }

  internal static unsafe void std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Copy(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    uint _Newsize,
    uint _Oldlen)
  {
    uint num1 = (uint) \u003CModule\u003E.__CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int num2 = (int) __untypedstackalloc((int) num1 << 1);
    uint num3 = _Newsize | 7U;
    if (2147483646U < num3)
    {
      num3 = _Newsize;
    }
    else
    {
      uint num4 = (uint) *(int*) ((IntPtr) obj0 + 24);
      uint num5 = num4 >> 1;
      if (num3 / 3U < num5 && num4 <= 2147483646U - num5)
        num3 = num5 + num4;
    }
    ushort* _First1 = (ushort*) 0;
    int num6;
    try
    {
      num6 = (int) num1 + num2;
      _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cunsigned\u0020short\u003E(num3 + 1U, (ushort*) 0);
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num7 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num6);
      try
      {
        try
        {
          num3 = _Newsize;
          try
          {
            _First1 = \u003CModule\u003E.std\u002E_Allocate\u003Cunsigned\u0020short\u003E(_Newsize + 1U, (ushort*) 0);
            goto label_23;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint num8 = 0;
            \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num2);
            try
            {
              try
              {
                \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
                \u003CModule\u003E._CxxThrowException((void*) 0, (_s__ThrowInfo*) 0);
              }
              catch (Exception ex3) when (
              {
                // ISSUE: unable to correctly present filter
                num8 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (num8 != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              if (num8 != 0U)
                throw;
              else
                goto label_23;
            }
            finally
            {
              \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num2, (int) num8);
            }
          }
        }
        catch (Exception ex4) when (
        {
          // ISSUE: unable to correctly present filter
          num7 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num7 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        if (num7 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num6, (int) num7);
      }
    }
label_23:
    if (0U < _Oldlen)
      \u003CModule\u003E.std\u002E_Traits_helper\u002Ecopy_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First1, num3 + 1U, \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0), _Oldlen);
    \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Tidy(obj0, true, 0U);
    *(int*) ((IntPtr) obj0 + 4) = (int) _First1;
    *(int*) ((IntPtr) obj0 + 24) = (int) num3;
    *(int*) ((IntPtr) obj0 + 20) = (int) _Oldlen;
    *(short*) ((int) _Oldlen * 2 + (IntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0)) = (short) 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inside(
    [In] basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr)
  {
    return _Ptr >= \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0) && (UIntPtr) (*(int*) ((IntPtr) obj0 + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr(obj0) > (UIntPtr) _Ptr;
  }

  internal static unsafe void std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E_Makpat(
    [In] _Mpunct\u003Cunsigned\u0020short\u003E* obj0,
    money_base.pattern* _Pattern,
    uint _Sepbyspace,
    uint _Symbolprecedes,
    uint _Signposition)
  {
    sbyte* numPtr = *(byte*) ((IntPtr) obj0 + 40) != (byte) 0 || 2U < _Sepbyspace || 1U < _Symbolprecedes || 4U < _Signposition ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_04FJCIEOIB\u0040\u0024\u003F\u0024CLxv\u003F\u0024AA\u0040 : (sbyte*) ((((int) _Sepbyspace * 2 + (int) _Symbolprecedes) * 5 + (int) _Signposition) * 4 + (IntPtr) &\u003CModule\u003E.\u003F\u003F_C\u0040_0HJ\u0040PJOMAIHM\u0040\u003F\u0024CLv\u0024x\u003F\u0024CLv\u0024xv\u0024\u003F\u0024CLxv\u003F\u0024CL\u0024xv\u0024\u003F\u0024CLx\u003F\u0024CL\u0024vx\u003F\u0024CL\u0024vx\u0024v\u003F\u0024CLx\u0040);
    \u003CModule\u003E.memcpy_s((void*) _Pattern, 4U, (void*) numPtr, 4U);
  }

  internal static unsafe _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    char* _Ptr,
    _Container_base* _Pstring)
  {
    *(int*) obj0 = 0;
    if ((IntPtr) _Pstring != IntPtr.Zero && (IntPtr) _Ptr != IntPtr.Zero)
    {
      char* chPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) _Pstring);
      if (chPtr <= _Ptr && (UIntPtr) _Ptr <= (UIntPtr) (*(int*) ((IntPtr) _Pstring + 20) * 2) + (UIntPtr) chPtr)
        goto label_3;
    }
    \u003CModule\u003E._invalid_parameter_noinfo();
label_3:
    *(int*) obj0 = (int) _Pstring;
    *(int*) ((IntPtr) obj0 + 4) = (int) _Ptr;
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u003D\u003D(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    uint num = (uint) *(int*) obj0;
    switch (num)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto case 4294967294;
      case 4294967294:
        return *(int*) ((IntPtr) obj0 + 4) == *(int*) ((IntPtr) _Right + 4);
      default:
        if ((int) num == *(int*) _Right)
          goto case 4294967294;
        else
          goto case 0;
    }
  }

  internal static unsafe _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u007Bctor\u007D(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    ushort* _Ptr,
    _Container_base* _Pstring)
  {
    *(int*) obj0 = 0;
    if ((IntPtr) _Pstring != IntPtr.Zero && (IntPtr) _Ptr != IntPtr.Zero)
    {
      ushort* numPtr = \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) _Pstring);
      if (numPtr <= _Ptr && (UIntPtr) _Ptr <= (UIntPtr) (*(int*) ((IntPtr) _Pstring + 20) * 2) + (UIntPtr) numPtr)
        goto label_3;
    }
    \u003CModule\u003E._invalid_parameter_noinfo();
label_3:
    *(int*) obj0 = (int) _Pstring;
    *(int*) ((IntPtr) obj0 + 4) = (int) _Ptr;
    return obj0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u003D\u003D(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    uint num = (uint) *(int*) obj0;
    switch (num)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto case 4294967294;
      case 4294967294:
        return *(int*) ((IntPtr) obj0 + 4) == *(int*) ((IntPtr) _Right + 4);
      default:
        if ((int) num == *(int*) _Right)
          goto case 4294967294;
        else
          goto case 0;
    }
  }

  internal static unsafe _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] _String_const_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E* obj0,
    int _Off)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + (_Off << 1);
        return obj0;
      default:
        uint num1 = (uint) *(int*) obj0;
        uint num2 = (uint) (_Off * 2 + *(int*) ((IntPtr) obj0 + 4));
        if ((UIntPtr) (int) num2 > (UIntPtr) (*(int*) ((int) num1 + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) num1) || (UIntPtr) (int) num2 < (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u002Cstd\u003A\u003Aallocator\u003Cwchar_t\u003E\u0020\u003E*) num1))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  internal static unsafe _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* std\u002E_String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002B\u003D(
    [In] _String_const_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    int _Off)
  {
    switch ((uint) *(int*) obj0)
    {
      case 0:
        \u003CModule\u003E._invalid_parameter_noinfo();
        goto default;
      case 4294967294:
        *(int*) ((IntPtr) obj0 + 4) = *(int*) ((IntPtr) obj0 + 4) + (_Off << 1);
        return obj0;
      default:
        uint num1 = (uint) *(int*) obj0;
        uint num2 = (uint) (_Off * 2 + *(int*) ((IntPtr) obj0 + 4));
        if ((UIntPtr) (int) num2 > (UIntPtr) (*(int*) ((int) num1 + 20) * 2) + (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) num1) || (UIntPtr) (int) num2 < (UIntPtr) \u003CModule\u003E.std\u002Ebasic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Myptr((basic_string\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u002Cstd\u003A\u003Aallocator\u003Cunsigned\u0020short\u003E\u0020\u003E*) num1))
        {
          \u003CModule\u003E._invalid_parameter_noinfo();
          goto case 4294967294;
        }
        else
          goto case 4294967294;
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_get\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* charTraitsWcharT = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) charTraitsWcharT == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          charTraitsWcharT = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          charTraitsWcharT = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (num_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) charTraitsWcharT;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_put\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (num_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe numpunct\u003Cwchar_t\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cwchar_t\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enumpunct\u003Cwchar_t\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (numpunct\u003Cwchar_t\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe collate\u003Cwchar_t\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acollate\u003Cwchar_t\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecollate\u003Cwchar_t\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (collate\u003Cwchar_t\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe messages\u003Cwchar_t\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amessages\u003Cwchar_t\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emessages\u003Cwchar_t\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (messages\u003Cwchar_t\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_get\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* charTraitsWcharT = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) charTraitsWcharT == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          charTraitsWcharT = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          charTraitsWcharT = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (money_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) charTraitsWcharT;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_put\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (money_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe moneypunct\u003Cwchar_t\u002C0\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C0\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (moneypunct\u003Cwchar_t\u002C0\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe moneypunct\u003Cwchar_t\u002C1\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cwchar_t\u002C1\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (moneypunct\u003Cwchar_t\u002C1\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_get\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* charTraitsWcharT = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) charTraitsWcharT == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          charTraitsWcharT = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          charTraitsWcharT = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (time_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) charTraitsWcharT;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_put\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (time_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_get\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* traitsUnsignedShort = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) traitsUnsignedShort == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          traitsUnsignedShort = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          traitsUnsignedShort = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (num_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) traitsUnsignedShort;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anum_put\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (num_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe numpunct\u003Cunsigned\u0020short\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Anumpunct\u003Cunsigned\u0020short\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (numpunct\u003Cunsigned\u0020short\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe collate\u003Cunsigned\u0020short\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Acollate\u003Cunsigned\u0020short\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (collate\u003Cunsigned\u0020short\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe messages\u003Cunsigned\u0020short\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amessages\u003Cunsigned\u0020short\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (messages\u003Cunsigned\u0020short\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_get\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* traitsUnsignedShort = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) traitsUnsignedShort == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          traitsUnsignedShort = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          traitsUnsignedShort = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (money_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) traitsUnsignedShort;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoney_put\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (money_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe moneypunct\u003Cunsigned\u0020short\u002C0\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (moneypunct\u003Cunsigned\u0020short\u002C0\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe moneypunct\u003Cunsigned\u0020short\u002C1\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Amoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (moneypunct\u003Cunsigned\u0020short\u002C1\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_get\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* traitsUnsignedShort = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) traitsUnsignedShort == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          traitsUnsignedShort = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          traitsUnsignedShort = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (time_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) traitsUnsignedShort;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static void \u003FA0xf64de732\u002E\u003F\u003F__E\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A\u0040\u0040YMXXZ() => ^(int&) ref \u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A = 0;

  internal static unsafe time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E* std\u002Euse_facet\u003Cclass\u0020std\u003A\u003Atime_put\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u0020\u003E(
    locale* _Loc)
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      locale.facet* pbVfacetLocale2B = \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B;
      uint _Id = \u003CModule\u003E.std\u002Elocale\u002Eid\u002E\u002EI(&\u003CModule\u003E.\u003Fid\u0040\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2V0locale\u00402\u0040A);
      locale.facet* facetPtr = \u003CModule\u003E.std\u002Elocale\u002E_Getfacet(_Loc, _Id);
      if ((IntPtr) facetPtr == IntPtr.Zero)
      {
        if ((IntPtr) pbVfacetLocale2B != IntPtr.Zero)
          facetPtr = pbVfacetLocale2B;
        else if (\u003CModule\u003E.std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E_Getcat(&pbVfacetLocale2B) == uint.MaxValue)
        {
          \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
        }
        else
        {
          facetPtr = pbVfacetLocale2B;
          \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = pbVfacetLocale2B;
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Incref(pbVfacetLocale2B);
          \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Register(pbVfacetLocale2B);
        }
      }
      return (time_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E*) facetPtr;
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe int std\u002E_Getloctxt\u003Cwchar_t\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E(
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Last,
    uint _Numfields,
    char* _Ptr)
  {
    uint num1 = 0;
    ushort num2 = (ushort) *_Ptr;
    if (num2 != (ushort) 0)
    {
      ushort num3 = num2;
      do
      {
        if ((int) num3 == (int) num2)
          ++_Numfields;
        ++num1;
        num3 = *(ushort*) ((int) num1 * 2 + (IntPtr) _Ptr);
      }
      while (num3 != (ushort) 0);
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, _Numfields, (sbyte) 0);
    int num4;
    // ISSUE: fault handler
    try
    {
      num4 = -2;
      uint num5 = 1;
      while (true)
      {
        bool flag = false;
        uint num6 = 0;
        uint _Off = 0;
        if (0U < _Numfields)
        {
          do
          {
            ushort num7 = *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr);
            if (num7 != (ushort) 0)
            {
              ushort num8 = (ushort) *_Ptr;
              while ((int) num7 != (int) num8)
              {
                ++num6;
                num7 = *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr);
                if (num7 == (ushort) 0)
                  break;
              }
            }
            if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) != (sbyte) 0)
            {
              num6 = (uint) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) + num6;
            }
            else
            {
              num6 = num5 + num6;
              ushort num9 = *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr);
              if ((int) num9 != (int) *_Ptr && num9 != (ushort) 0)
              {
                if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last) && (int) *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E\u002A(_First))
                {
                  flag = true;
                }
                else
                {
                  uint num10 = num5 >= (uint) sbyte.MaxValue ? (uint) sbyte.MaxValue : num5;
                  *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) = (sbyte) num10;
                }
              }
              else
              {
                uint num11 = num5 >= (uint) sbyte.MaxValue ? (uint) sbyte.MaxValue : num5;
                *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) = (sbyte) num11;
                num4 = (int) _Off;
              }
            }
            ++_Off;
          }
          while (_Off < _Numfields);
          if (flag)
          {
            if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(_First, _Last))
            {
              ++num5;
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Inc(_First);
              num4 = -1;
            }
            else
              break;
          }
          else
            break;
        }
        else
          break;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return num4;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u003D\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(_Left, _Right);
  }

  internal static unsafe int std\u002E_Getloctxt\u003Cunsigned\u0020short\u002Cclass\u0020std\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E(
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _First,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Last,
    uint _Numfields,
    ushort* _Ptr)
  {
    uint num1 = 0;
    ushort num2 = *_Ptr;
    if (num2 != (ushort) 0)
    {
      ushort num3 = num2;
      do
      {
        if ((int) num3 == (int) num2)
          ++_Numfields;
        ++num1;
        num3 = *(ushort*) ((int) num1 * 2 + (IntPtr) _Ptr);
      }
      while (num3 != (ushort) 0);
    }
    basic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E stdAllocatorChar;
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bctor\u007D(&stdAllocatorChar, _Numfields, (sbyte) 0);
    int num4;
    // ISSUE: fault handler
    try
    {
      num4 = -2;
      uint num5 = 1;
      while (true)
      {
        bool flag = false;
        uint num6 = 0;
        uint _Off = 0;
        if (0U < _Numfields)
        {
          do
          {
            ushort num7 = *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr);
            if (num7 != (ushort) 0)
            {
              ushort num8 = *_Ptr;
              while ((int) num7 != (int) num8)
              {
                ++num6;
                num7 = *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr);
                if (num7 == (ushort) 0)
                  break;
              }
            }
            if (*\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) != (sbyte) 0)
            {
              num6 = (uint) *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) + num6;
            }
            else
            {
              num6 = num5 + num6;
              ushort num9 = *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr);
              if ((int) num9 != (int) *_Ptr && num9 != (ushort) 0)
              {
                if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last) && (int) *(ushort*) ((int) num6 * 2 + (IntPtr) _Ptr) == (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E\u002A(_First))
                {
                  flag = true;
                }
                else
                {
                  uint num10 = num5 >= (uint) sbyte.MaxValue ? (uint) sbyte.MaxValue : num5;
                  *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) = (sbyte) num10;
                }
              }
              else
              {
                uint num11 = num5 >= (uint) sbyte.MaxValue ? (uint) sbyte.MaxValue : num5;
                *\u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u005B\u005D(&stdAllocatorChar, _Off) = (sbyte) num11;
                num4 = (int) _Off;
              }
            }
            ++_Off;
          }
          while (_Off < _Numfields);
          if (flag)
          {
            if (!\u003CModule\u003E.std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(_First, _Last))
            {
              ++num5;
              \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Inc(_First);
              num4 = -1;
            }
            else
              break;
          }
          else
            break;
        }
        else
          break;
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E\u007Bdtor\u007D), (void*) &stdAllocatorChar);
    }
    \u003CModule\u003E.std\u002Ebasic_string\u003Cchar\u002Cstd\u003A\u003Achar_traits\u003Cchar\u003E\u002Cstd\u003A\u003Aallocator\u003Cchar\u003E\u0020\u003E\u002E_Tidy(&stdAllocatorChar, true, 0U);
    return num4;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u003D\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    return \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(_Left, _Right);
  }

  internal static unsafe int std\u002E_LStrcoll\u003Cunsigned\u0020short\u003E(
    ushort* _First1,
    ushort* _Last1,
    ushort* _First2,
    ushort* _Last2,
    _Collvec* __unnamed004)
  {
    if (_First1 != _Last1)
    {
      while (_First2 != _Last2)
      {
        ushort num1 = *_First1;
        ushort num2 = *_First2;
        if ((uint) num1 < (uint) num2)
          return -1;
        if ((uint) num2 < (uint) num1)
          return 1;
        ++_First1;
        ++_First2;
        if (_First1 == _Last1)
          goto label_7;
      }
      goto label_9;
    }
label_7:
    int num;
    if (_First2 != _Last2)
    {
      num = -1;
      goto label_10;
    }
label_9:
    num = _First1 != _Last1 ? 1 : 0;
label_10:
    return num;
  }

  internal static unsafe uint std\u002E_LStrxfrm\u003Cunsigned\u0020short\u003E(
    ushort* _First1,
    ushort* _Last1,
    ushort* _First2,
    ushort* _Last2,
    _Collvec* __unnamed004)
  {
    uint num1 = (uint) ((IntPtr) _Last2 - (IntPtr) _First2 >> 1);
    int num2 = (int) ((IntPtr) _Last1 - (IntPtr) _First1 >> 1);
    if (num1 <= (uint) num2)
      \u003CModule\u003E.memcpy_s((void*) _First1, (uint) (num2 << 1), (void*) _First2, num1 << 1);
    return num1;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u0021\u003D\u003Cwchar_t\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    return !\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(_Left, _Right);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eoperator\u0021\u003D\u003Cunsigned\u0020short\u002Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Left,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    return !\u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(_Left, _Right);
  }

  internal static unsafe char* std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E(
    char* _First1,
    uint _Size,
    char* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memmove_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe ushort* std\u002E_Traits_helper\u002Emove_s\u003Cstruct\u0020std\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E(
    ushort* _First1,
    uint _Size,
    ushort* _First2,
    uint _Count)
  {
    \u003CModule\u003E.memmove_s((void*) _First1, _Size << 1, (void*) _First2, _Count << 1);
    return _First1;
  }

  internal static unsafe char* std\u002E_Allocate\u003Cwchar_t\u003E(
    uint _Count,
    char* __unnamed001)
  {
    if (_Count <= 0U)
      _Count = 0U;
    else if (uint.MaxValue / _Count < 2U)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return (char*) \u003CModule\u003E.@new(_Count << 1);
  }

  internal static unsafe ushort* std\u002E_Allocate\u003Cunsigned\u0020short\u003E(
    uint _Count,
    ushort* __unnamed001)
  {
    if (_Count <= 0U)
      _Count = 0U;
    else if (uint.MaxValue / _Count < 2U)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    return (ushort*) \u003CModule\u003E.@new(_Count << 1);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002Eequal(
    [In] istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E* _Right)
  {
    if (*(byte*) ((IntPtr) obj0 + 8) == (byte) 0)
    {
      int num1 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    if (*(byte*) ((IntPtr) _Right + 8) == (byte) 0)
    {
      int num2 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u002E_Peek(_Right);
    }
    uint num3 = (uint) *(int*) ((IntPtr) obj0 + 4);
    return num3 == 0U && *(int*) ((IntPtr) _Right + 4) == 0 || num3 != 0U && *(int*) ((IntPtr) _Right + 4) != 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002Eequal(
    [In] istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* obj0,
    istreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E* _Right)
  {
    if (*(byte*) ((IntPtr) obj0 + 8) == (byte) 0)
    {
      int num1 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Peek(obj0);
    }
    if (*(byte*) ((IntPtr) _Right + 8) == (byte) 0)
    {
      int num2 = (int) \u003CModule\u003E.std\u002Eistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u002E_Peek(_Right);
    }
    uint num3 = (uint) *(int*) ((IntPtr) obj0 + 4);
    return num3 == 0U && *(int*) ((IntPtr) _Right + 4) == 0 || num3 != 0U && *(int*) ((IntPtr) _Right + 4) != 0;
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024numpunct\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024collate\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024messages\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003F_Psave\u0040\u003F\u0024_Facetptr\u0040V\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u0040\u0024\u0024Q2PBVfacet\u0040locale\u00402\u0040B = (locale.facet*) 0;

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Enum_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Enum_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecollate\u003Cwchar_t\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecollate\u003Cwchar_t\u003E\u002Edo_compare);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecollate\u003Cwchar_t\u003E\u002Edo_transform);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040_W\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecollate\u003Cwchar_t\u003E\u002Edo_hash);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_falsename);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enumpunct\u003Cwchar_t\u003E\u002Edo_truename);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Enum_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 44) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024num_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 48) = (int) __methodptr(std\u002Enum_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emessages\u003Cwchar_t\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emessages\u003Cwchar_t\u003E\u002Edo_open);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emessages\u003Cwchar_t\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040_W\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Emessages\u003Cwchar_t\u003E\u002Edo_close);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emoney_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emoney_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoneypunct\u003Cwchar_t\u002C0\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoneypunct\u003Cwchar_t\u002C1\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040_W\u002400\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_date_order);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_time);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_date);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_weekday);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_monthname);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040_WV\u003F\u0024istreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Etime_get\u003Cwchar_t\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_get_year);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040_WV\u003F\u0024ostreambuf_iterator\u0040_WU\u003F\u0024char_traits\u0040_W\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Etime_put\u003Cwchar_t\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cwchar_t\u002Cstd\u003A\u003Achar_traits\u003Cwchar_t\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040_W\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cwchar_t\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_falsename);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024numpunct\u0040G\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Enumpunct\u003Cunsigned\u0020short\u003E\u002Edo_truename);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002Edo_compare);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002Edo_transform);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024collate\u0040G\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Ecollate\u003Cunsigned\u0020short\u003E\u002Edo_hash);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emessages\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emessages\u003Cunsigned\u0020short\u003E\u002Edo_open);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emessages\u003Cunsigned\u0020short\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024messages\u0040G\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Emessages\u003Cunsigned\u0020short\u003E\u002Edo_close);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emoney_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024money_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Emoney_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoneypunct\u003Cunsigned\u0020short\u002C0\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u00240A\u0040\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Emoneypunct\u003Cunsigned\u0020short\u002C1\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024moneypunct\u0040G\u002400\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_neg_format);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_date_order);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_time);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_date);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_weekday);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_monthname);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_get\u0040GV\u003F\u0024istreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002Etime_get\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aistreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_get_year);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024time_put\u0040GV\u003F\u0024ostreambuf_iterator\u0040GU\u003F\u0024char_traits\u0040G\u0040std\u0040\u0040\u0040std\u0040\u0040\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002Etime_put\u003Cunsigned\u0020short\u002Cstd\u003A\u003Aostreambuf_iterator\u003Cunsigned\u0020short\u002Cstd\u003A\u003Achar_traits\u003Cunsigned\u0020short\u003E\u0020\u003E\u0020\u003E\u002Edo_put);
  }

  internal static unsafe void \u003FA0xf64de732\u002E\u003F\u003F__E\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040\u0040\u0040YMXXZ()
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 = (int) &\u003CModule\u003E.\u003F\u003F_R4\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 4) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002E__vecDelDtor);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 8) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_decimal_point);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 12) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_thousands_sep);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 16) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_grouping);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 20) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_curr_symbol);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 24) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_positive_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 28) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_negative_sign);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 32) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_frac_digits);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 36) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_pos_format);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: method pointer
    ^(int&) ((IntPtr) &\u003CModule\u003E.\u003F\u003F_7\u003F\u0024_Mpunct\u0040G\u0040std\u0040\u00406B\u0040 + 40) = (int) __methodptr(std\u002E_Mpunct\u003Cunsigned\u0020short\u003E\u002Edo_neg_format);
  }

  internal static unsafe int _Getdateorder()
  {
    \u0024ArrayType\u0024\u0024\u0024BY01D arrayTypeBy01D;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy01D = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY01D&) ((IntPtr) &arrayTypeBy01D + 1), 0, 1);
    \u003CModule\u003E.GetLocaleInfoA(\u003CModule\u003E.___lc_handle_func()[5], 34U, (sbyte*) &arrayTypeBy01D, 2);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return ^(sbyte&) ref arrayTypeBy01D != (sbyte) 48 ? (^(sbyte&) ref arrayTypeBy01D != (sbyte) 49 ? (^(sbyte&) ref arrayTypeBy01D != (sbyte) 50 ? 0 : 3) : 1) : 2;
  }

  internal static unsafe double __Stodx(sbyte* s, sbyte** endptr, int pten, int* perr)
  {
    sbyte* s0 = s;
    int num1 = \u003CModule\u003E._Stopfx(&s, endptr);
    int num2 = num1 & 8;
    if ((IntPtr) perr != IntPtr.Zero)
      *perr = 0;
    if ((IntPtr) endptr != IntPtr.Zero)
      *(int*) endptr = 0;
    double num3;
    switch (num1 & -9)
    {
      case 1:
        \u0024ArrayType\u0024\u0024\u0024BY02J arrayTypeBy02J1;
        int num4 = \u003CModule\u003E._Stoflt(s0, s, endptr, (int*) &arrayTypeBy02J1, 2);
        double x1;
        if (num4 == 0)
        {
          x1 = 0.0;
        }
        else
        {
          int num5 = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          x1 = (double) ^(int&) ((IntPtr) &arrayTypeBy02J1 + 4);
          if (1 < num4)
          {
            do
            {
              ++num5;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              x1 = (double) ^(int&) (num5 * 4 + (IntPtr) &arrayTypeBy02J1) + x1 * 1000000000.0;
            }
            while (num5 < num4);
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = \u003CModule\u003E._Dtentox(x1, ^(int&) ref arrayTypeBy02J1 + pten, perr);
        break;
      case 2:
        \u0024ArrayType\u0024\u0024\u0024BY02J arrayTypeBy02J2;
        int num6 = \u003CModule\u003E._Stoxflt(s0, s, endptr, (int*) &arrayTypeBy02J2, 2);
        double x2;
        if (num6 == 0)
        {
          x2 = 0.0;
        }
        else
        {
          int num7 = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          x2 = (double) ^(int&) ((IntPtr) &arrayTypeBy02J2 + 4);
          if (1 < num6)
          {
            do
            {
              ++num7;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              x2 = (double) ^(int&) (num7 * 4 + (IntPtr) &arrayTypeBy02J2) + x2 * 268435456.0;
            }
            while (num7 < num6);
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num8 = (int) \u003CModule\u003E._Dscale(&x2, ^(int&) ref arrayTypeBy02J2);
        num3 = \u003CModule\u003E._Dtentox(x2, pten, perr);
        break;
      case 3:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = ^(double&) ref \u003CModule\u003E._Inf;
        break;
      case 4:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = ^(double&) ref \u003CModule\u003E._Nan;
        break;
      default:
        num3 = 0.0;
        break;
    }
    return num2 == 0 ? num3 : -num3;
  }

  internal static unsafe double _Stodx(sbyte* s, sbyte** endptr, int pten, int* perr)
  {
    int num1 = *\u003CModule\u003E._errno();
    *\u003CModule\u003E._errno() = 0;
    double num2 = \u003CModule\u003E.strtod(s, endptr);
    int* numPtr = \u003CModule\u003E._errno();
    *perr = *numPtr;
    *\u003CModule\u003E._errno() = num1;
    if (0 < pten)
    {
      do
      {
        num2 *= 10.0;
        --pten;
      }
      while (pten > 0);
    }
    if (pten < 0)
    {
      uint num3 = (uint) -pten;
      do
      {
        num2 /= 10.0;
        --num3;
      }
      while (num3 > 0U);
    }
    return num2;
  }

  internal static unsafe double _Stod(sbyte* s, sbyte** endptr, int pten)
  {
    int num;
    return \u003CModule\u003E._Stodx(s, endptr, pten, &num);
  }

  internal static unsafe short _Getwctype([MarshalAs(UnmanagedType.U2)] char _Ch, _Ctypevec* _Ctype)
  {
    short num;
    return \u003CModule\u003E.__crtGetStringTypeW((localeinfo_struct*) 0, 1U, &_Ch, 1, (ushort*) &num, *(int*) ((IntPtr) _Ctype + 4), *(int*) _Ctype) != 0 ? num : (short) 0;
  }

  internal static unsafe char* _Getwctypes(
    char* _First,
    char* _Last,
    short* _Dest,
    _Ctypevec* _Ctype)
  {
    \u003CModule\u003E.__crtGetStringTypeW((localeinfo_struct*) 0, 1U, _First, (int) ((IntPtr) _Last - (IntPtr) _First >> 1), (ushort*) _Dest, *(int*) ((IntPtr) _Ctype + 4), *(int*) _Ctype);
    return _Last;
  }

  internal static unsafe short _Getwctype(ushort _Ch, _Ctypevec* _Ctype) => \u003CModule\u003E._Getwctype((char) _Ch, _Ctype);

  internal static unsafe ushort* _Getwctypes(
    ushort* _First,
    ushort* _Last,
    short* _Dest,
    _Ctypevec* _Ctype)
  {
    return (ushort*) \u003CModule\u003E._Getwctypes((char*) _First, (char*) _Last, _Dest, _Ctype);
  }

  internal static unsafe void* __InlineInterlockedCompareExchangePointer(
    void** Destination,
    void* ExChange,
    void* Comperand)
  {
    return (void*) \u003CModule\u003E.InterlockedCompareExchange((int*) Destination, (int) ExChange, (int) Comperand);
  }

  internal static unsafe int _Mbrtowc(char* pwc, sbyte* s, uint n, int* pst, _Cvtvec* ploc)
  {
    if ((IntPtr) s == IntPtr.Zero || n == 0U)
      return 0;
    if (*s == (sbyte) 0)
    {
      if ((IntPtr) pwc != IntPtr.Zero)
        *pwc = char.MinValue;
      return 0;
    }
    uint num1;
    int num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      int num3 = (int) \u003CModule\u003E.___lc_handle_func()[2];
      num1 = \u003CModule\u003E.___lc_codepage_func();
      num2 = num3;
    }
    else
    {
      num2 = *(int*) ploc;
      num1 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num2 == 0)
    {
      if ((IntPtr) pwc != IntPtr.Zero)
        *pwc = (char) (byte) *s;
      return 1;
    }
    localeinfo_struct* localeForCp = \u003CModule\u003E._GetLocaleForCP(num1);
    if (*pst != 0)
    {
      ((byte*) pst)[1] = (byte) *s;
      if (\u003CModule\u003E.___mb_cur_max_l_func(localeForCp) > 1)
      {
        int num4 = (IntPtr) pwc != IntPtr.Zero ? 1 : 0;
        if (\u003CModule\u003E.MultiByteToWideChar(num1, 9U, (sbyte*) pst, 2, pwc, num4) != 0)
        {
          *pst = 0;
          return \u003CModule\u003E.___mb_cur_max_l_func(localeForCp);
        }
      }
      *pst = 0;
      *\u003CModule\u003E._errno() = 42;
      return -1;
    }
    if (((IntPtr) localeForCp != IntPtr.Zero ? (int) *(byte*) ((int) (byte) *s + *(int*) ((IntPtr) localeForCp + 4) + 29) & 4 : (int) *(ushort*) ((int) (byte) *s * 2 + (IntPtr) \u003CModule\u003E.__pctype_func()) & 32768) != 0)
    {
      if (n < (uint) \u003CModule\u003E.___mb_cur_max_l_func(localeForCp))
      {
        *(sbyte*) pst = *s;
        return -2;
      }
      if (\u003CModule\u003E.___mb_cur_max_l_func(localeForCp) > 1)
      {
        int num5 = (IntPtr) pwc != IntPtr.Zero ? 1 : 0;
        if (\u003CModule\u003E.MultiByteToWideChar(num1, 9U, s, \u003CModule\u003E.___mb_cur_max_l_func(localeForCp), pwc, num5) != 0)
          goto label_24;
      }
      if (s[1] == (sbyte) 0)
      {
        *pst = 0;
        *\u003CModule\u003E._errno() = 42;
        return -1;
      }
label_24:
      return \u003CModule\u003E.___mb_cur_max_l_func(localeForCp);
    }
    int num6 = (IntPtr) pwc != IntPtr.Zero ? 1 : 0;
    if (\u003CModule\u003E.MultiByteToWideChar(num1, 9U, s, 1, pwc, num6) != 0)
      return 1;
    *\u003CModule\u003E._errno() = 42;
    return -1;
  }

  internal static unsafe int _Mbrtowc(ushort* pwc, sbyte* s, uint n, int* pst, _Cvtvec* ploc) => \u003CModule\u003E._Mbrtowc((char*) pwc, s, n, pst, ploc);

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char _Towlower([MarshalAs(UnmanagedType.U2)] char _Ch, _Ctypevec* _Ctype)
  {
    char ch = _Ch;
    if (_Ch != char.MaxValue)
    {
      uint num = (uint) *(int*) _Ctype;
      if (num == 0U && _Ch < 'Ā')
      {
        if ((ushort) ((uint) _Ch + 65471U) <= (ushort) 25)
          ch = (char) ((int) _Ch + 32);
      }
      else if (\u003CModule\u003E.__crtLCMapStringW((localeinfo_struct*) 0, num, 256U, &_Ch, 1, &ch, 1, *(int*) ((IntPtr) _Ctype + 4)) == 0)
        ch = _Ch;
    }
    return ch;
  }

  internal static unsafe ushort _Towlower(ushort _Ch, _Ctypevec* _Ctype) => (ushort) \u003CModule\u003E._Towlower((char) _Ch, _Ctype);

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char _Towupper([MarshalAs(UnmanagedType.U2)] char _Ch, _Ctypevec* _Ctype)
  {
    char ch = _Ch;
    if (_Ch != char.MaxValue)
    {
      uint num = (uint) *(int*) _Ctype;
      if (num == 0U && _Ch < 'Ā')
      {
        if ((ushort) ((uint) _Ch + 65439U) <= (ushort) 25)
          ch = (char) ((int) _Ch - 32);
      }
      else if (\u003CModule\u003E.__crtLCMapStringW((localeinfo_struct*) 0, num, 512U, &_Ch, 1, &ch, 1, *(int*) ((IntPtr) _Ctype + 4)) == 0)
        ch = _Ch;
    }
    return ch;
  }

  internal static unsafe ushort _Towupper(ushort _Ch, _Ctypevec* _Ctype) => (ushort) \u003CModule\u003E._Towupper((char) _Ch, _Ctype);

  internal static unsafe int _Strcoll(
    sbyte* _string1,
    sbyte* _end1,
    sbyte* _string2,
    sbyte* _end2,
    _Collvec* ploc)
  {
    int num1 = (int) ((IntPtr) _end1 - (IntPtr) _string1);
    int num2 = (int) ((IntPtr) _end2 - (IntPtr) _string2);
    uint num3;
    uint num4;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      num3 = \u003CModule\u003E.___lc_handle_func()[1];
      num4 = \u003CModule\u003E.___lc_collate_cp_func();
    }
    else
    {
      num3 = (uint) *(int*) ploc;
      num4 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    int num5;
    if (num3 == 0U)
    {
      int num6 = num1 >= num2 ? num2 : num1;
      int num7 = \u003CModule\u003E.memcmp((void*) _string1, (void*) _string2, (uint) num6);
      int num8;
      if (num7 == 0 && num1 != num2)
      {
        int num9 = -1;
        if (num1 >= num2)
          num9 = -num9;
        num8 = num9;
      }
      else
        num8 = num7;
      num5 = num8;
    }
    else
    {
      int num10 = \u003CModule\u003E.__crtCompareStringA((localeinfo_struct*) 0, num3, 4096U, _string1, num1, _string2, num2, (int) num4);
      if (0 == num10)
      {
        *\u003CModule\u003E._errno() = 22;
        num5 = int.MaxValue;
      }
      else
        num5 = num10 - 2;
    }
    return num5;
  }

  internal static unsafe _Collvec _Getcoll()
  {
    _Collvec collvec;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref collvec = (int) \u003CModule\u003E.___lc_handle_func()[1];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &collvec + 4) = (int) \u003CModule\u003E.___lc_collate_cp_func();
    return collvec;
  }

  internal static unsafe uint _Strxfrm(
    sbyte* _string1,
    sbyte* _end1,
    sbyte* _string2,
    sbyte* _end2,
    _Collvec* ploc)
  {
    uint num1 = (uint) ((IntPtr) _end1 - (IntPtr) _string1);
    uint num2 = (uint) ((IntPtr) _end2 - (IntPtr) _string2);
    uint num3 = uint.MaxValue;
    uint num4;
    uint num5;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      num4 = \u003CModule\u003E.___lc_handle_func()[1];
      num5 = \u003CModule\u003E.___lc_collate_cp_func();
    }
    else
    {
      num4 = (uint) *(int*) ploc;
      num5 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num4 == 0U && num5 == 0U)
    {
      if (num2 <= num1)
        \u003CModule\u003E.memcpy((void*) _string1, (void*) _string2, num2);
      num3 = num2;
    }
    else
    {
      int num6 = \u003CModule\u003E.__crtLCMapStringA((localeinfo_struct*) 0, num4, 1024U, _string2, (int) num2, (sbyte*) 0, 0, (int) num5, 1);
      if (0 != num6)
      {
        num3 = (uint) num6;
        if (num6 <= (int) num1)
          \u003CModule\u003E.__crtLCMapStringA((localeinfo_struct*) 0, num4, 1024U, _string2, (int) num2, _string1, (int) num1, (int) num5, 1);
      }
    }
    return num3;
  }

  internal static unsafe int \u003FA0x46569a4e\u002E_Wmemcmp(char* s1, char* s2, int n)
  {
    if (0 < n)
    {
      while ((int) *s1 == (int) *s2)
      {
        ++s1;
        ++s2;
        --n;
        if (0 >= n)
          goto label_6;
      }
      int num = -1;
      return (uint) *s1 < (uint) *s2 ? num : -num;
    }
label_6:
    return 0;
  }

  internal static unsafe int _Wcscoll(
    char* _string1,
    char* _end1,
    char* _string2,
    char* _end2,
    _Collvec* ploc)
  {
    int num1 = (int) ((IntPtr) _end1 - (IntPtr) _string1 >> 1);
    int num2 = (int) ((IntPtr) _end2 - (IntPtr) _string2 >> 1);
    uint num3 = (IntPtr) ploc != IntPtr.Zero ? (uint) *(int*) ploc : \u003CModule\u003E.___lc_handle_func()[1];
    int num4;
    if (num3 == 0U)
    {
      int n = num1 >= num2 ? num2 : num1;
      int num5 = \u003CModule\u003E.\u003FA0x46569a4e\u002E_Wmemcmp(_string1, _string2, n);
      int num6;
      if (num5 == 0 && num1 != num2)
      {
        int num7 = -1;
        if (num1 >= num2)
          num7 = -num7;
        num6 = num7;
      }
      else
        num6 = num5;
      num4 = num6;
    }
    else
    {
      int num8 = \u003CModule\u003E.__crtCompareStringW((localeinfo_struct*) 0, num3, 4096U, _string1, num1, _string2, num2, (int) \u003CModule\u003E.___lc_collate_cp_func());
      if (0 == num8)
      {
        *\u003CModule\u003E._errno() = 22;
        num4 = int.MaxValue;
      }
      else
        num4 = num8 - 2;
    }
    return num4;
  }

  internal static unsafe int _Wcscoll(
    ushort* _string1,
    ushort* _end1,
    ushort* _string2,
    ushort* _end2,
    _Collvec* ploc)
  {
    return \u003CModule\u003E._Wcscoll((char*) _string1, (char*) _end1, (char*) _string2, (char*) _end2, ploc);
  }

  internal static unsafe uint _Wcsxfrm(
    char* _string1,
    char* _end1,
    char* _string2,
    char* _end2,
    _Collvec* ploc)
  {
    uint num1 = (uint) ((IntPtr) _end1 - (IntPtr) _string1 >> 1);
    uint num2 = (uint) ((IntPtr) _end2 - (IntPtr) _string2 >> 1);
    uint num3 = uint.MaxValue;
    uint num4 = (IntPtr) ploc != IntPtr.Zero ? (uint) *(int*) ploc : \u003CModule\u003E.___lc_handle_func()[1];
    if (num4 == 0U)
    {
      if (num2 <= num1)
        \u003CModule\u003E.memcpy((void*) _string1, (void*) _string2, num2 << 1);
      num3 = num2;
    }
    else
    {
      byte* numPtr = (byte*) \u003CModule\u003E.malloc(num1);
      if (IntPtr.Zero != (IntPtr) numPtr)
      {
        num3 = (uint) \u003CModule\u003E.__crtLCMapStringW((localeinfo_struct*) 0, num4, 1024U, _string2, (int) num2, (char*) numPtr, (int) num1, (int) \u003CModule\u003E.___lc_collate_cp_func());
        if (0U == num3)
        {
          num3 = (uint) \u003CModule\u003E.__crtLCMapStringW((localeinfo_struct*) 0, num4, 1024U, _string2, (int) num2, (char*) 0, 0, (int) \u003CModule\u003E.___lc_collate_cp_func());
          if (0U == num3)
            num3 = (uint) int.MaxValue;
        }
        else
        {
          uint num5 = 0;
          if (0U < num3)
          {
            do
            {
              *(short*) ((int) num5 * 2 + (IntPtr) _string1) = (short) (ushort) *(byte*) ((int) num5 + (IntPtr) numPtr);
              ++num5;
            }
            while (num5 < num3);
          }
        }
        \u003CModule\u003E.free((void*) numPtr);
      }
    }
    return num3;
  }

  internal static unsafe uint _Wcsxfrm(
    ushort* _string1,
    ushort* _end1,
    ushort* _string2,
    ushort* _end2,
    _Collvec* ploc)
  {
    return \u003CModule\u003E._Wcsxfrm((char*) _string1, (char*) _end1, (char*) _string2, (char*) _end2, ploc);
  }

  internal static unsafe int __Wcrtomb_lk(sbyte* s, [MarshalAs(UnmanagedType.U2)] char wchar, int* pst, _Cvtvec* ploc) => \u003CModule\u003E._Wcrtomb(s, wchar, pst, ploc);

  internal static unsafe int _Wcrtomb(sbyte* s, [MarshalAs(UnmanagedType.U2)] char wchar, int* pst, _Cvtvec* ploc)
  {
    uint num1;
    int num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      int num3 = (int) \u003CModule\u003E.___lc_handle_func()[2];
      num1 = \u003CModule\u003E.___lc_codepage_func();
      num2 = num3;
    }
    else
    {
      num2 = *(int*) ploc;
      num1 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num2 == 0)
    {
      if (wchar > 'ÿ')
      {
        *\u003CModule\u003E._errno() = 42;
        return -1;
      }
      *s = (sbyte) wchar;
      return 1;
    }
    int num4 = 0;
    localeinfo_struct* localeForCp = \u003CModule\u003E._GetLocaleForCP(num1);
    int multiByte = \u003CModule\u003E.WideCharToMultiByte(num1, 0U, &wchar, 1, s, \u003CModule\u003E.___mb_cur_max_l_func(localeForCp), (sbyte*) 0, &num4);
    if (multiByte != 0 && num4 == 0)
      return multiByte;
    *\u003CModule\u003E._errno() = 42;
    return -1;
  }

  internal static unsafe int _Wcrtomb(sbyte* s, ushort wchar, int* pst, _Cvtvec* ploc) => \u003CModule\u003E._Wcrtomb(s, (char) wchar, pst, ploc);

  internal static unsafe _Cvtvec _Getcvt()
  {
    _Cvtvec cvtvec;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref cvtvec = (int) \u003CModule\u003E.___lc_handle_func()[2];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &cvtvec + 4) = (int) \u003CModule\u003E.___lc_codepage_func();
    return cvtvec;
  }

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_ctor(_Mutex* _param0)
  {
    void* _Mtx = \u003CModule\u003E.@new(24U);
    *(int*) _param0 = (int) _Mtx;
    \u003CModule\u003E._Mtxinit((_RTL_CRITICAL_SECTION*) _Mtx);
  }

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_dtor(_Mutex* _param0)
  {
    \u003CModule\u003E._Mtxdst((_RTL_CRITICAL_SECTION*) *(int*) _param0);
    \u003CModule\u003E.delete((void*) *(int*) _param0);
  }

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_Lock(_Mutex* _param0) => \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) *(int*) _param0);

  internal static unsafe void std\u002E_Mutex\u002E_Mutex_Unlock(_Mutex* _param0) => \u003CModule\u003E._Mtxunlock((_RTL_CRITICAL_SECTION*) *(int*) _param0);

  internal static unsafe void std\u002E_Init_locks\u002E_Init_locks_ctor(_Init_locks* _param0)
  {
    if (\u003CModule\u003E.InterlockedIncrement(&\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Einit) != 0)
      return;
    _RTL_CRITICAL_SECTION* _Mtx = (_RTL_CRITICAL_SECTION*) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx;
    // ISSUE: cast to a reference type
    do
    {
      \u003CModule\u003E._Mtxinit(_Mtx);
      _Mtx += 24;
    }
    while ((IntPtr) _Mtx < (\u0024ArrayType\u0024\u0024\u0024BY03U_RTL_CRITICAL_SECTION\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx + 96));
  }

  internal static unsafe void std\u002E_Init_locks\u002E_Init_locks_dtor(_Init_locks* _param0)
  {
    if (\u003CModule\u003E.InterlockedDecrement(&\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Einit) >= 0)
      return;
    _RTL_CRITICAL_SECTION* _Mtx = (_RTL_CRITICAL_SECTION*) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx;
    // ISSUE: cast to a reference type
    do
    {
      \u003CModule\u003E._Mtxdst(_Mtx);
      _Mtx += 24;
    }
    while ((IntPtr) _Mtx < (\u0024ArrayType\u0024\u0024\u0024BY03U_RTL_CRITICAL_SECTION\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx + 96));
  }

  internal static unsafe void \u003FA0x15dc9b6c\u002E\u003F\u003F__E\u003FA0x15dc9b6c\u0040initlocks\u0040std\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_ctor(&\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Einitlocks);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x15dc9b6c\u002E\u003F\u003F__F\u003FA0x15dc9b6c\u0040initlocks\u0040std\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x15dc9b6c\u002E\u003F\u003F__F\u003FA0x15dc9b6c\u0040initlocks\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.std\u002E_Init_locks\u002E_Init_locks_dtor(&\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Einitlocks);

  internal static unsafe void std\u002E_Lockit\u002E_Lockit_ctor(_Lockit* _param0) => \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx);

  internal static unsafe void std\u002E_Lockit\u002E_Lockit_ctor(_Lockit* _param0, int _param1)
  {
    int num = _param1 & 3;
    *(int*) _param0 = num;
    \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) (num * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx));
  }

  internal static unsafe void std\u002E_Lockit\u002E_Lockit_dtor(_Lockit* _param0) => \u003CModule\u003E._Mtxunlock((_RTL_CRITICAL_SECTION*) (*(int*) _param0 * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx));

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void std\u002E_Lockit\u002E_Lockit_ctor(int _param0) => \u003CModule\u003E._Mtxlock((_RTL_CRITICAL_SECTION*) ((_param0 & 3) * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx));

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void std\u002E_Lockit\u002E_Lockit_dtor(int _param0) => \u003CModule\u003E._Mtxunlock((_RTL_CRITICAL_SECTION*) ((_param0 & 3) * 24 + (IntPtr) &\u003CModule\u003E.std\u002E\u003FA0x15dc9b6c\u002Emtx));

  internal static unsafe void _Once(int* _Cntrl, __FnPtr<void ()> _Func)
  {
    if (*_Cntrl == 2)
      return;
    switch (\u003CModule\u003E.InterlockedExchange(_Cntrl, 1))
    {
      case 0:
        // ISSUE: function pointer call
        __calli(_Func)();
        *_Cntrl = 2;
        break;
      case 2:
        *_Cntrl = 2;
        break;
      default:
        if (*_Cntrl == 2)
          break;
        do
        {
          \u003CModule\u003E.Sleep(1U);
        }
        while (*_Cntrl != 2);
        break;
    }
  }

  internal static unsafe void _Mtxinit(_RTL_CRITICAL_SECTION* _Mtx) => \u003CModule\u003E.InitializeCriticalSection(_Mtx);

  internal static unsafe void _Mtxdst(_RTL_CRITICAL_SECTION* _Mtx) => \u003CModule\u003E.DeleteCriticalSection(_Mtx);

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void _Mtxlock(_RTL_CRITICAL_SECTION* _Mtx)
  {
    Thread.BeginThreadAffinity();
    \u003CModule\u003E.EnterCriticalSection(_Mtx);
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void _Mtxunlock(_RTL_CRITICAL_SECTION* _Mtx)
  {
    \u003CModule\u003E.LeaveCriticalSection(_Mtx);
    Thread.EndThreadAffinity();
  }

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("kernel32.dll")]
  public static extern unsafe void EnterCriticalSection(_RTL_CRITICAL_SECTION* lpCriticalSection);

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [DllImport("kernel32.dll")]
  public static extern unsafe void LeaveCriticalSection(_RTL_CRITICAL_SECTION* lpCriticalSection);

  internal static unsafe double _Cosh(double x, double y)
  {
    switch (\u003CModule\u003E._Dtest(&x))
    {
      case 0:
        return y;
      case 1:
      case 2:
        return x;
      default:
        if (y == 0.0)
          return y;
        if (x < 0.0)
          x = -x;
        if (x < \u003CModule\u003E._Xbig)
        {
          int num = (int) \u003CModule\u003E._Exp(&x, 1.0, (short) -1);
          return (0.25 / x + x) * y;
        }
        switch (\u003CModule\u003E._Exp(&x, y, (short) -1))
        {
          case 0:
            \u003CModule\u003E._Feraise(16);
            break;
          case 1:
            \u003CModule\u003E._Feraise(8);
            break;
        }
        return x;
    }
  }

  internal static unsafe short _Dnorm(ushort* ps)
  {
    ushort num1 = ps[3];
    ushort num2 = (ushort) ((int) num1 & 32768);
    short num3 = 1;
    ushort num4 = (ushort) ((int) num1 & 15);
    ps[3] = num4;
    if (num4 == (ushort) 0)
    {
      if (ps[2] != (ushort) 0 || ps[1] != (ushort) 0 || *ps != (ushort) 0)
      {
        do
        {
          ps[3] = ps[2];
          ps[2] = ps[1];
          ps[1] = *ps;
          *ps = (ushort) 0;
          num3 -= (short) 16;
        }
        while (ps[3] == (ushort) 0);
      }
      else
        goto label_8;
    }
    if (ps[3] < (ushort) 16)
    {
      do
      {
        ushort num5 = ps[2];
        ps[3] = (ushort) ((int) (ushort) ((uint) ps[3] << 1) | (int) ((uint) num5 >> 15));
        ushort num6 = ps[1];
        ps[2] = (ushort) ((int) (ushort) ((uint) num5 << 1) | (int) ((uint) num6 >> 15));
        ushort num7 = *ps;
        ps[1] = (ushort) ((int) (ushort) ((uint) num6 << 1) | (int) ((uint) num7 >> 15));
        *ps = (ushort) ((int) num7 << 1);
        --num3;
      }
      while (ps[3] < (ushort) 16);
    }
    if ((ushort) 32 <= ps[3])
    {
      do
      {
        ushort num8 = ps[1];
        *ps = (ushort) ((int) (ushort) ((uint) num8 << 15) | (int) ((uint) *ps >> 1));
        ushort num9 = ps[2];
        ps[1] = (ushort) ((int) (ushort) ((uint) num9 << 15) | (int) ((uint) num8 >> 1));
        ushort num10 = ps[3];
        ps[2] = (ushort) ((int) (ushort) ((uint) num10 << 15) | (int) ((uint) num9 >> 1));
        ps[3] = (ushort) ((uint) num10 >> 1);
        ++num3;
      }
      while ((ushort) 32 <= ps[3]);
    }
    num4 = (ushort) ((int) ps[3] & 15);
    ps[3] = num4;
label_8:
    ps[3] = (ushort) ((int) num4 | (int) num2);
    return num3;
  }

  internal static unsafe short _Dscale(double* px, int lexp)
  {
    ushort num1 = *(ushort*) ((byte*) px + 6);
    short num2 = (short) ((uint) (ushort) ((uint) num1 & 32752U) >> 4);
    switch (num2)
    {
      case 0:
        num2 = \u003CModule\u003E._Dnorm((ushort*) px);
        if ((short) 0 < num2)
          return 0;
        break;
      case 2047:
        return (ushort) ((uint) num1 & 15U) != (ushort) 0 || *(ushort*) ((byte*) px + 4) != (ushort) 0 || *(ushort*) ((byte*) px + 2) != (ushort) 0 || *(ushort*) px != (ushort) 0 ? (short) 2 : (short) 1;
    }
    if (0 < lexp && 2047 - (int) num2 <= lexp)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      double num3 = (ushort) ((uint) *(ushort*) ((byte*) px + 6) & 32768U) == (ushort) 0 ? ^(double&) ref \u003CModule\u003E._Inf : -^(double&) ref \u003CModule\u003E._Inf;
      *px = num3;
      return 1;
    }
    if ((int) -num2 < lexp)
    {
      *(short*) ((byte*) px + 6) = (short) (((int) num2 + lexp) * 16 | (int) *(ushort*) ((byte*) px + 6) & 32783);
      return -1;
    }
    ushort num4 = *(ushort*) ((byte*) px + 6);
    ushort num5 = (ushort) ((int) num4 & 32768);
    ushort num6 = (ushort) ((int) num4 & 15 | 16);
    ushort num7 = num6;
    *(short*) ((byte*) px + 6) = (short) num6;
    lexp = (int) num2 + lexp - 1;
    if ((uint) (lexp + 53) <= 52U)
    {
      short num8 = (short) lexp;
      ushort num9 = 0;
      if (num8 <= (short) -16)
      {
        ushort num10 = num7;
        ushort num11 = *(ushort*) ((byte*) px + 4);
        ushort num12 = *(ushort*) ((byte*) px + 2);
        ushort num13 = *(ushort*) px;
        do
        {
          int num14 = num9 != (ushort) 0 ? 1 : 0;
          num9 = (ushort) ((int) num13 | (int) (ushort) num14);
          num13 = num12;
          num12 = num11;
          num11 = num10;
          num10 = (ushort) 0;
          num8 += (short) 16;
        }
        while (num8 <= (short) -16);
        *(short*) ((byte*) px + 6) = (short) 0;
        *(short*) ((byte*) px + 4) = (short) num11;
        *(short*) ((byte*) px + 2) = (short) num12;
        *(short*) px = (short) num13;
      }
      short num15 = -num8;
      if (num15 != (short) 0)
      {
        int num16 = num9 != (ushort) 0 ? 1 : 0;
        int num17 = 16 - (int) num15;
        ushort num18 = *(ushort*) px;
        num9 = (ushort) ((int) num18 << num17 | num16);
        ushort num19 = *(ushort*) ((byte*) px + 2);
        ushort num20 = (ushort) num15;
        *(short*) px = (short) ((int) (ushort) ((uint) num19 << num17) | (int) ((uint) num18 >> (int) num20));
        ushort num21 = *(ushort*) ((byte*) px + 4);
        *(short*) ((byte*) px + 2) = (short) ((int) (ushort) ((uint) num21 << num17) | (int) ((uint) num19 >> (int) num20));
        ushort num22 = *(ushort*) ((byte*) px + 6);
        *(short*) ((byte*) px + 4) = (short) ((int) (ushort) ((uint) num22 << num17) | (int) ((uint) num21 >> (int) num20));
        *(short*) ((byte*) px + 6) = (short) ((uint) num22 >> (int) num15);
      }
      ushort num23 = (ushort) ((int) num5 | (int) *(ushort*) ((byte*) px + 6));
      *(short*) ((byte*) px + 6) = (short) num23;
      if ((ushort) 32768 < num9 || (ushort) 32768 == num9 && (ushort) ((uint) *(ushort*) px & 1U) != (ushort) 0)
      {
        ushort num24 = (ushort) ((int) *(ushort*) px + 1);
        *(short*) px = (short) num24;
        if (num24 == (ushort) 0)
        {
          ushort num25 = (ushort) ((int) *(ushort*) ((byte*) px + 2) + 1);
          *(short*) ((byte*) px + 2) = (short) num25;
          if (num25 == (ushort) 0)
          {
            ushort num26 = (ushort) ((int) *(ushort*) ((byte*) px + 4) + 1);
            *(short*) ((byte*) px + 4) = (short) num26;
            if (num26 == (ushort) 0)
            {
              *(short*) ((byte*) px + 6) = (short) ((int) num23 + 1);
              goto label_22;
            }
          }
        }
      }
      if ((int) num23 == (int) num5 && *(ushort*) ((byte*) px + 4) == (ushort) 0 && *(ushort*) ((byte*) px + 2) == (ushort) 0 && *(ushort*) px == (ushort) 0)
        return 0;
label_22:
      return -1;
    }
    *(short*) ((byte*) px + 6) = (short) num5;
    *(short*) ((byte*) px + 4) = (short) 0;
    *(short*) ((byte*) px + 2) = (short) 0;
    *(short*) px = (short) 0;
    return 0;
  }

  internal static unsafe short _Dtest(double* px)
  {
    ushort num1 = *(ushort*) ((byte*) px + 6);
    ushort num2 = (ushort) ((int) num1 & 32752);
    if (num2 == (ushort) 32752)
      return (ushort) ((uint) num1 & 15U) != (ushort) 0 || *(ushort*) ((byte*) px + 4) != (ushort) 0 || *(ushort*) ((byte*) px + 2) != (ushort) 0 || *(ushort*) px != (ushort) 0 ? (short) 2 : (short) 1;
    return ((int) num1 & -32769) == 0 && *(ushort*) ((byte*) px + 4) == (ushort) 0 && *(ushort*) ((byte*) px + 2) == (ushort) 0 && *(ushort*) px == (ushort) 0 ? (short) 0 : (num2 == (ushort) 0 ? (short) -2 : (short) -1);
  }

  internal static unsafe short _Exp(double* px, double y, short eoff)
  {
    if (*px >= -1842.0 && y != 0.0)
    {
      if (1842.0 < *px)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        *px = ^(double&) ref \u003CModule\u003E._Inf;
        return 1;
      }
      double num1 = *px * 1.4426950408889634;
      short num2 = (short) (int) ((num1 >= 0.0 ? 0.5 : -0.5) + num1);
      double num3 = (double) num2;
      double num4 = *px - num3 * 0.693145751953125 - num3 * 1.4286068203094173E-06;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (-^(double&) ref \u003CModule\u003E._Eps < num4 && num4 < ^(double&) ref \u003CModule\u003E._Eps)
      {
        *px = y;
      }
      else
      {
        double num5 = num4;
        double num6 = num5 * num5;
        double num7 = (num6 * 30.015112906833171 + 3362.7215441655303) * num6 + 30265.401893609498;
        double num8 = ((num6 + 420.30235984910632) * num6 + 15132.700946804747) * num4;
        *px = (num7 + num8) / (num7 - num8) * 2.0 * y;
        --num2;
      }
      return \u003CModule\u003E._Dscale(px, (int) num2 + (int) eoff);
    }
    *px = 0.0;
    return 0;
  }

  internal static unsafe double _Sinh(double x, double y)
  {
    switch (\u003CModule\u003E._Dtest(&x))
    {
      case 0:
        return x * y;
      case 1:
        return y == 0.0 ? ((ushort) ((uint) *(ushort*) ((byte*) &x + 6) & 32768U) == (ushort) 0 ? y : -y) : x;
      case 2:
        return x;
      default:
        if (y == 0.0)
          return x >= 0.0 ? y : -y;
        short num1;
        if (x < 0.0)
        {
          x = -x;
          num1 = (short) 1;
        }
        else
          num1 = (short) 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (x < ^(double&) ref \u003CModule\u003E._Rteps)
          x *= y;
        else if (x < 1.0)
        {
          double num2 = x;
          double x1 = num2 * num2;
          x = (\u003CModule\u003E._Poly(x1, (double*) &\u003CModule\u003E.\u003FA0xfd7f576c\u002Ep, 5) * (x1 * x) + x) * y;
        }
        else if (x < \u003CModule\u003E._Xbig)
        {
          int num3 = (int) \u003CModule\u003E._Exp(&x, 1.0, (short) -1);
          x = (x - 0.25 / x) * y;
        }
        else
        {
          switch (\u003CModule\u003E._Exp(&x, y, (short) -1))
          {
            case 0:
              \u003CModule\u003E._Feraise(16);
              break;
            case 1:
              \u003CModule\u003E._Feraise(8);
              break;
          }
        }
        return num1 == (short) 0 ? x : -x;
    }
  }

  internal static unsafe double _Poly(double x, double* tab, int n)
  {
    double num = *tab;
    --n;
    if (0 <= n)
    {
      do
      {
        ++tab;
        num = num * x + *tab;
        --n;
      }
      while (n >= 0);
    }
    return num;
  }

  internal static unsafe float _FCosh(float x, float y)
  {
    switch (\u003CModule\u003E._FDtest(&x))
    {
      case 0:
        return y;
      case 1:
      case 2:
        return x;
      default:
        if ((double) y == 0.0)
          return y;
        if ((double) x < 0.0)
          x = -x;
        if ((double) x < (double) \u003CModule\u003E._FXbig)
        {
          int num = (int) \u003CModule\u003E._FExp(&x, 1f, (short) -1);
          return (0.25f / x + x) * y;
        }
        switch (\u003CModule\u003E._FExp(&x, y, (short) -1))
        {
          case 0:
            \u003CModule\u003E._Feraise(16);
            break;
          case 1:
            \u003CModule\u003E._Feraise(8);
            break;
        }
        return x;
    }
  }

  internal static unsafe short _FDnorm(ushort* ps)
  {
    ushort num1 = ps[1];
    ushort num2 = (ushort) ((int) num1 & 32768);
    short num3 = 1;
    ushort num4 = (ushort) ((int) num1 & (int) sbyte.MaxValue);
    ps[1] = num4;
    if (num4 == (ushort) 0)
    {
      ushort num5 = *ps;
      if (num5 != (ushort) 0)
      {
        ps[1] = num5;
        *ps = (ushort) 0;
        num3 = (short) -15;
      }
      else
        goto label_8;
    }
    if (ps[1] < (ushort) 128)
    {
      do
      {
        ushort num6 = *ps;
        ps[1] = (ushort) ((int) (ushort) ((uint) ps[1] << 1) | (int) ((uint) num6 >> 15));
        *ps = (ushort) ((int) num6 << 1);
        --num3;
      }
      while (ps[1] < (ushort) 128);
    }
    if ((ushort) 256 <= ps[1])
    {
      do
      {
        ushort num7 = ps[1];
        *ps = (ushort) ((int) (ushort) ((uint) num7 << 15) | (int) ((uint) *ps >> 1));
        ps[1] = (ushort) ((uint) num7 >> 1);
        ++num3;
      }
      while ((ushort) 256 <= ps[1]);
    }
    num4 = (ushort) ((int) ps[1] & (int) sbyte.MaxValue);
    ps[1] = num4;
label_8:
    ps[1] = (ushort) ((int) num4 | (int) num2);
    return num3;
  }

  internal static unsafe short _FDscale(float* px, int lexp)
  {
    ushort num1 = *(ushort*) ((byte*) px + 2);
    short num2 = (short) ((uint) (ushort) ((uint) num1 & 32640U) >> 7);
    switch (num2)
    {
      case 0:
        num2 = \u003CModule\u003E._FDnorm((ushort*) px);
        if ((short) 0 < num2)
          return 0;
        break;
      case (short) byte.MaxValue:
        return (ushort) ((uint) num1 & (uint) sbyte.MaxValue) != (ushort) 0 || *(ushort*) px != (ushort) 0 ? (short) 2 : (short) 1;
    }
    if (0 < lexp && (int) byte.MaxValue - (int) num2 <= lexp)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      float num3 = (ushort) ((uint) *(ushort*) ((byte*) px + 2) & 32768U) == (ushort) 0 ? ^(float&) ref \u003CModule\u003E._FInf : -^(float&) ref \u003CModule\u003E._FInf;
      *px = num3;
      return 1;
    }
    if ((int) -num2 < lexp)
    {
      *(short*) ((byte*) px + 2) = (short) (((int) num2 + lexp) * 128 | (int) *(ushort*) ((byte*) px + 2) & 32895);
      return -1;
    }
    ushort num4 = *(ushort*) ((byte*) px + 2);
    ushort num5 = (ushort) ((int) num4 & 32768);
    ushort num6 = (ushort) ((int) num4 & (int) sbyte.MaxValue | 128);
    *(short*) ((byte*) px + 2) = (short) num6;
    lexp = (int) num2 + lexp - 1;
    if ((uint) (lexp + 24) <= 23U)
    {
      short num7 = (short) lexp;
      ushort num8 = 0;
      if (num7 <= (short) -16)
      {
        num8 = *(ushort*) px;
        *(short*) px = (short) num6;
        *(short*) ((byte*) px + 2) = (short) 0;
        num7 += (short) 16;
      }
      short num9 = -num7;
      if (num9 != (short) 0)
      {
        int num10 = num8 != (ushort) 0 ? 1 : 0;
        int num11 = 16 - (int) num9;
        ushort num12 = *(ushort*) px;
        num8 = (ushort) ((int) num12 << num11 | num10);
        ushort num13 = *(ushort*) ((byte*) px + 2);
        *(short*) px = (short) ((int) (ushort) ((uint) num13 << num11) | (int) ((uint) num12 >> (int) (ushort) num9));
        *(short*) ((byte*) px + 2) = (short) ((uint) num13 >> (int) num9);
      }
      ushort num14 = (ushort) ((int) num5 | (int) *(ushort*) ((byte*) px + 2));
      *(short*) ((byte*) px + 2) = (short) num14;
      if ((ushort) 32768 < num8 || (ushort) 32768 == num8 && (ushort) ((uint) *(ushort*) px & 1U) != (ushort) 0)
      {
        ushort num15 = (ushort) ((int) *(ushort*) px + 1);
        *(short*) px = (short) num15;
        if (num15 == (ushort) 0)
        {
          *(short*) ((byte*) px + 2) = (short) ((int) num14 + 1);
          goto label_18;
        }
      }
      if ((int) num14 == (int) num5 && *(ushort*) px == (ushort) 0)
        return 0;
label_18:
      return -1;
    }
    *(short*) ((byte*) px + 2) = (short) num5;
    *(short*) px = (short) 0;
    return 0;
  }

  internal static unsafe short _FDtest(float* px)
  {
    ushort num1 = *(ushort*) ((byte*) px + 2);
    ushort num2 = (ushort) ((int) num1 & 32640);
    if (num2 == (ushort) 32640)
      return (ushort) ((uint) num1 & (uint) sbyte.MaxValue) != (ushort) 0 || *(ushort*) px != (ushort) 0 ? (short) 2 : (short) 1;
    return ((int) num1 & -32769) == 0 && *(ushort*) px == (ushort) 0 ? (short) 0 : (num2 == (ushort) 0 ? (short) -2 : (short) -1);
  }

  internal static unsafe short _FExp(float* px, float y, short eoff)
  {
    if ((double) *px >= -229.0 && (double) y != 0.0)
    {
      if (229.0 < (double) *px)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        *px = ^(float&) ref \u003CModule\u003E._FInf;
        return 1;
      }
      float num1 = *px * 1.442695f;
      short num2 = (short) (int) (((double) num1 >= 0.0 ? 0.5 : -0.5) + (double) num1);
      float num3 = (float) num2;
      float num4 = (float) ((double) *px - (double) num3 * 0.693145751953125 - (double) num3 * 1.428606765330187E-06);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (-(double) ^(float&) ref \u003CModule\u003E._FEps < (double) num4 && (double) num4 < (double) ^(float&) ref \u003CModule\u003E._FEps)
      {
        *px = y;
      }
      else
      {
        double num5 = (double) num4;
        float num6 = (float) (num5 * num5);
        float num7 = (float) ((double) num6 * 12.015174865722656 + 120.18228912353516);
        float num8 = (num6 + 60.0911446f) * num4;
        *px = (float) (((double) num7 + (double) num8) / ((double) num7 - (double) num8) * 2.0) * y;
        --num2;
      }
      return \u003CModule\u003E._FDscale(px, (int) num2 + (int) eoff);
    }
    *px = 0.0f;
    return 0;
  }

  internal static unsafe float _FSinh(float x, float y)
  {
    switch (\u003CModule\u003E._FDtest(&x))
    {
      case 0:
        return x * y;
      case 1:
        return (double) y == 0.0 ? ((ushort) ((uint) *(ushort*) ((byte*) &x + 2) & 32768U) == (ushort) 0 ? y : -y) : x;
      case 2:
        return x;
      default:
        if ((double) y == 0.0)
          return (double) x >= 0.0 ? y : -y;
        short num1;
        if ((double) x < 0.0)
        {
          x = -x;
          num1 = (short) 1;
        }
        else
          num1 = (short) 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if ((double) x < (double) ^(float&) ref \u003CModule\u003E._FRteps)
          x *= y;
        else if ((double) x < 1.0)
        {
          double num2 = (double) x;
          float num3 = (float) (num2 * num2);
          x = ((float) (((double) num3 * 0.00020399999630171806 + 0.0083298301324248314) * (double) num3 + 0.16666737198829651) * num3 * x + x) * y;
        }
        else if ((double) x < (double) \u003CModule\u003E._FXbig)
        {
          int num4 = (int) \u003CModule\u003E._FExp(&x, 1f, (short) -1);
          double num5 = (double) x;
          x = (float) (num5 - 0.25 / num5) * y;
        }
        else
        {
          switch (\u003CModule\u003E._FExp(&x, y, (short) -1))
          {
            case 0:
              \u003CModule\u003E._Feraise(16);
              break;
            case 1:
              \u003CModule\u003E._Feraise(8);
              break;
          }
        }
        return num1 == (short) 0 ? x : -x;
    }
  }

  internal static unsafe double _LCosh(double x, double y)
  {
    switch (\u003CModule\u003E._LDtest(&x))
    {
      case 0:
        return y;
      case 1:
      case 2:
        return x;
      default:
        if (y == 0.0)
          return y;
        if (x < 0.0)
          x = -x;
        if (x < \u003CModule\u003E._LXbig)
        {
          int num = (int) \u003CModule\u003E._LExp(&x, 1.0, (short) -1);
          return (0.25 / x + x) * y;
        }
        switch (\u003CModule\u003E._LExp(&x, y, (short) -1))
        {
          case 0:
            \u003CModule\u003E._Feraise(16);
            break;
          case 1:
            \u003CModule\u003E._Feraise(8);
            break;
        }
        return x;
    }
  }

  internal static unsafe short _LDscale(double* px, int lexp) => \u003CModule\u003E._Dscale(px, lexp);

  internal static unsafe short _LDtest(double* px) => \u003CModule\u003E._Dtest(px);

  internal static unsafe short _LExp(double* px, double y, short eoff)
  {
    if (*px >= -29490.0 && y != 0.0)
    {
      if (29490.0 < *px)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        *px = ^(double&) ref \u003CModule\u003E._LInf;
        return 1;
      }
      double num1 = *px * 1.4426950408889634;
      short num2 = (short) (int) ((num1 >= 0.0 ? 0.5 : -0.5) + num1);
      double num3 = (double) num2;
      double num4 = *px - num3 * 0.693145751953125 - num3 * 1.4286068203094173E-06;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (-^(double&) ref \u003CModule\u003E._LEps < num4 && num4 < ^(double&) ref \u003CModule\u003E._LEps)
      {
        *px = y;
      }
      else
      {
        double num5 = num4;
        double num6 = num5 * num5;
        double num7 = ((num6 + 841.16788052653078) * num6 + 75730.83407547629) * num6 + 666457.53443902521;
        double num8 = ((num6 * 42.038913947607355 + 10096.353102778763) * num6 + 333228.76721951261) * num4;
        *px = (num7 + num8) / (num7 - num8) * 2.0 * y;
        --num2;
      }
      return \u003CModule\u003E._LDscale(px, (int) num2 + (int) eoff);
    }
    *px = 0.0;
    return 0;
  }

  internal static unsafe double _LSinh(double x, double y)
  {
    switch (\u003CModule\u003E._LDtest(&x))
    {
      case 0:
        return x * y;
      case 1:
        return y == 0.0 ? ((ushort) ((uint) *(ushort*) ((byte*) &x + 6) & 32768U) == (ushort) 0 ? y : -y) : x;
      case 2:
        return x;
      default:
        if (y == 0.0)
          return x >= 0.0 ? y : -y;
        short num1;
        if (x < 0.0)
        {
          x = -x;
          num1 = (short) 1;
        }
        else
          num1 = (short) 0;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (x < ^(double&) ref \u003CModule\u003E._LRteps)
          x *= y;
        else if (x < 1.0)
        {
          double num2 = x;
          double x1 = num2 * num2;
          x = (\u003CModule\u003E._LPoly(x1, (double*) &\u003CModule\u003E.\u003FA0x3864562d\u002Ep, 7) * (x1 * x) + x) * y;
        }
        else if (x < \u003CModule\u003E._LXbig)
        {
          int num3 = (int) \u003CModule\u003E._LExp(&x, 1.0, (short) -1);
          x = (x - 0.25 / x) * y;
        }
        else
        {
          switch (\u003CModule\u003E._LExp(&x, y, (short) -1))
          {
            case 0:
              \u003CModule\u003E._Feraise(16);
              break;
            case 1:
              \u003CModule\u003E._Feraise(8);
              break;
          }
        }
        return num1 == (short) 0 ? x : -x;
    }
  }

  internal static unsafe double _LPoly(double x, double* tab, int n)
  {
    double num = *tab;
    --n;
    if (0 <= n)
    {
      do
      {
        ++tab;
        num = num * x + *tab;
        --n;
      }
      while (n >= 0);
    }
    return num;
  }

  internal static unsafe void _Feraise(int except)
  {
    if ((except & 5) != 0)
    {
      *\u003CModule\u003E._errno() = 33;
    }
    else
    {
      if ((except & 24) == 0)
        return;
      *\u003CModule\u003E._errno() = 34;
    }
  }

  internal static unsafe _iobuf* std\u002E_Fiopen(sbyte* filename, int mode, int prot)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
    return \u003CModule\u003E.mbstowcs_s((uint*) 0, (char*) &arrayTypeBy0BaeW, 260U, filename, 259U) != 0 ? (_iobuf*) 0 : \u003CModule\u003E.std\u002E_Fiopen((char*) &arrayTypeBy0BaeW, mode, prot);
  }

  internal static unsafe _iobuf* std\u002E_Xfsopen(char* filename, char* mode, int prot)
  {
    uint num = 0;
    if (\u003CModule\u003E._get_osplatform(&num) != 0)
      \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);
    if (num != 1U)
      return \u003CModule\u003E._wfsopen(filename, mode, prot);
    \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040D arrayTypeBy0BaeD;
    if (\u003CModule\u003E.wcstombs_s((uint*) 0, (sbyte*) &arrayTypeBy0BaeD, 260U, filename, 259U) != 0)
      return (_iobuf*) 0;
    \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040D arrayTypeBy0BeD;
    return \u003CModule\u003E.wcstombs_s((uint*) 0, (sbyte*) &arrayTypeBy0BeD, 20U, mode, 19U) != 0 ? (_iobuf*) 0 : \u003CModule\u003E._fsopen((sbyte*) &arrayTypeBy0BaeD, (sbyte*) &arrayTypeBy0BeD, prot);
  }

  internal static unsafe _iobuf* std\u002E_Fiopen(char* filename, int mode, int prot)
  {
    int num1 = mode & 4;
    int num2 = mode & 128;
    if ((mode & 64) != 0)
      mode |= 1;
    if ((mode & 8) != 0)
      mode |= 2;
    mode &= -197;
    int num3 = 0;
    int num4 = 1;
    while (num4 != mode)
    {
      ++num3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      num4 = ^(int&) (num3 * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x3e1b8fe7\u002E\u003Fvalid\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404QBHB);
      if (num4 == 0)
        break;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) (num3 * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x3e1b8fe7\u002E\u003Fvalid\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404QBHB) == 0)
      return (_iobuf*) 0;
    if (num2 != 0 && (mode & 1) != 0)
    {
      _iobuf* iobufPtr = \u003CModule\u003E.std\u002E_Xfsopen(filename, (char*) &\u003CModule\u003E.\u003F\u003F_C\u0040_13BPINEIPE\u0040\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040, prot);
      if ((IntPtr) iobufPtr != IntPtr.Zero)
      {
        \u003CModule\u003E.fclose(iobufPtr);
        return (_iobuf*) 0;
      }
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    _iobuf* iobufPtr1 = \u003CModule\u003E.std\u002E_Xfsopen(filename, (char*) ^(int&) (num3 * 4 + (IntPtr) &\u003CModule\u003E.\u003FA0x3e1b8fe7\u002E\u003Fmods\u0040\u003F1\u003F\u003F_Fiopen\u0040std\u0040\u0040YAPAU_iobuf\u0040\u0040PB_WHH\u0040Z\u00404PAPB_WA), prot);
    if ((IntPtr) iobufPtr1 == IntPtr.Zero)
      return (_iobuf*) 0;
    if (num1 == 0 || \u003CModule\u003E.fseek(iobufPtr1, 0, 2) == 0)
      return iobufPtr1;
    \u003CModule\u003E.fclose(iobufPtr1);
    return (_iobuf*) 0;
  }

  internal static unsafe _iobuf* std\u002E_Fiopen(ushort* _Filename, int _Mode, int _Prot) => \u003CModule\u003E.std\u002E_Fiopen((char*) _Filename, _Mode, _Prot);

  internal static unsafe void std\u002E_String_base\u002E_Xlen() => \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);

  internal static unsafe void std\u002E_String_base\u002E_Xran() => \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);

  internal static unsafe void std\u002E_String_base\u002E_Xinvarg() => \u003CModule\u003E._invoke_watson((char*) 0, (char*) 0, (char*) 0, 0U, 0U);

  internal static unsafe void std\u002E_Debug_message(sbyte* s1, sbyte* s2)
  {
    \u003CModule\u003E.fflush((_iobuf*) 0);
    \u003CModule\u003E.fputs(s1, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    \u003CModule\u003E.fputs((IntPtr) s2 == IntPtr.Zero ? (sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_07CIFAGBMG\u0040unknown\u003F\u0024AA\u0040 : (sbyte*) &*(\u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD*) s2, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    \u003CModule\u003E.fputs((sbyte*) &\u003CModule\u003E.\u003F\u003F_C\u0040_01EEMJAFIK\u0040\u003F6\u003F\u0024AA\u0040, (_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 64));
    \u003CModule\u003E.abort();
  }

  internal static unsafe void std\u002E_Throw(stdext.exception* ex)
  {
    ref \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD local = ref \u003CModule\u003E.\u003F\u003F_C\u0040_0M\u0040LLHBPFNE\u0040exception\u003F3\u003F5\u003F\u0024AA\u0040;
    stdext.exception* exceptionPtr = ex;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    sbyte* s2 = __calli((__FnPtr<sbyte* (IntPtr)>) *(int*) (*(int*) exceptionPtr + 4))((IntPtr) exceptionPtr);
    \u003CModule\u003E.std\u002E_Debug_message((sbyte*) ref local, s2);
  }

  internal static unsafe void std\u002E_Nomemory()
  {
    if (((int) \u003CModule\u003E.\u003FA0xcfe6d8a4\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA & 1) == 0)
    {
      \u003CModule\u003E.\u003FA0xcfe6d8a4\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA |= 1U;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0xcfe6d8a4\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B);
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0xcfe6d8a4\u002E\u003F\u003F__Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u0040YMXXZ));
      }
      __fault
      {
        \u003CModule\u003E.\u003FA0xcfe6d8a4\u002E\u003F\u0024S1\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404IA &= 4294967294U;
      }
    }
    bad_alloc badAlloc;
    \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bctor\u007D(&badAlloc, &\u003CModule\u003E.\u003FA0xcfe6d8a4\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B);
    \u003CModule\u003E._CxxThrowException((void*) &badAlloc, &\u003CModule\u003E._TI2\u003FAVbad_alloc\u0040std\u0040\u0040);
  }

  internal static unsafe void \u003FA0xcfe6d8a4\u002E\u003F\u003F__Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u0040YMXXZ() => \u003CModule\u003E.std\u002Ebad_alloc\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0xcfe6d8a4\u002E\u003Fnomem\u0040\u003F1\u003F\u003F_Nomemory\u0040std\u0040\u0040YAXXZ\u00404Vbad_alloc\u00402\u0040B);

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool std\u002E_uncaught_exception_m() => \u003CModule\u003E.__uncaught_exception();

  internal static unsafe int _Tolower(int c, _Ctypevec* ploc)
  {
    uint num1;
    uint num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      num1 = \u003CModule\u003E.___lc_handle_func()[2];
      num2 = \u003CModule\u003E.___lc_codepage_func();
    }
    else
    {
      num1 = (uint) *(int*) ploc;
      num2 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num1 == 0U)
    {
      if ((uint) (c - 65) <= 25U)
        c += 32;
      return c;
    }
    if ((uint) c < 256U)
    {
      if ((IntPtr) ploc == IntPtr.Zero)
      {
        if (\u003CModule\u003E.isupper(c) == 0)
          return c;
        goto label_14;
      }
      else if ((short) ((int) *(short*) (c * 2 + *(int*) ((IntPtr) ploc + 8)) & 1) == (short) 0)
        return c;
    }
    int num3;
    int num4;
    if ((IntPtr) ploc != IntPtr.Zero)
    {
      num3 = c >> 8;
      if ((ushort) ((uint) *(short*) ((num3 & (int) byte.MaxValue) * 2 + *(int*) ((IntPtr) ploc + 8)) & 32768U) == (ushort) 0)
      {
        num4 = 0;
        goto label_17;
      }
      else
        goto label_18;
    }
label_14:
    num3 = c >> 8;
    num4 = (int) *(ushort*) ((int) (byte) num3 * 2 + (IntPtr) \u003CModule\u003E.__pctype_func()) & 32768;
label_17:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E1;
    int num5;
    if (num4 == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) c;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) 0;
      num5 = 1;
      goto label_20;
    }
label_18:
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) num3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) (byte) c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 2) = (sbyte) 0;
    num5 = 2;
label_20:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E2;
    int num6 = \u003CModule\u003E.__crtLCMapStringA((localeinfo_struct*) 0, num1, 256U, (sbyte*) &arrayTypeBy02E1, num5, (sbyte*) &arrayTypeBy02E2, 3, (int) num2, 1);
    if (0 == num6)
      return c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return num6 == 1 ? (int) ^(byte&) ref arrayTypeBy02E2 : (int) ^(byte&) ref arrayTypeBy02E2 << 8 | (int) ^(byte&) ((IntPtr) &arrayTypeBy02E2 + 1);
  }

  internal static unsafe _Ctypevec _Getctype()
  {
    _Ctypevec ctypevec;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref ctypevec = (int) \u003CModule\u003E.___lc_handle_func()[1];
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &ctypevec + 4) = (int) \u003CModule\u003E.___lc_codepage_func();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &ctypevec + 8) = (int) \u003CModule\u003E.calloc(256U, 2U);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &ctypevec + 8) != 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.memcpy((void*) ^(int&) ((IntPtr) &ctypevec + 8), (void*) \u003CModule\u003E.__pctype_func(), 512U);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &ctypevec + 12) = 1;
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &ctypevec + 8) = (int) \u003CModule\u003E.__pctype_func();
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &ctypevec + 12) = 0;
    }
    return ctypevec;
  }

  internal static unsafe int _Toupper(int c, _Ctypevec* ploc)
  {
    uint num1;
    uint num2;
    if ((IntPtr) ploc == IntPtr.Zero)
    {
      num1 = \u003CModule\u003E.___lc_handle_func()[2];
      num2 = \u003CModule\u003E.___lc_codepage_func();
    }
    else
    {
      num1 = (uint) *(int*) ploc;
      num2 = (uint) *(int*) ((IntPtr) ploc + 4);
    }
    if (num1 == 0U)
    {
      if ((uint) (c - 97) <= 25U)
        c -= 32;
      return c;
    }
    if ((uint) c < 256U)
    {
      if ((IntPtr) ploc == IntPtr.Zero)
      {
        if (\u003CModule\u003E.islower(c) == 0)
          return c;
        goto label_14;
      }
      else if ((short) ((int) *(short*) (c * 2 + *(int*) ((IntPtr) ploc + 8)) & 2) == (short) 0)
        return c;
    }
    int num3;
    int num4;
    if ((IntPtr) ploc != IntPtr.Zero)
    {
      num3 = c >> 8;
      if ((ushort) ((uint) *(short*) ((num3 & (int) byte.MaxValue) * 2 + *(int*) ((IntPtr) ploc + 8)) & 32768U) == (ushort) 0)
      {
        num4 = 0;
        goto label_17;
      }
      else
        goto label_18;
    }
label_14:
    num3 = c >> 8;
    num4 = (int) *(ushort*) ((int) (byte) num3 * 2 + (IntPtr) \u003CModule\u003E.__pctype_func()) & 32768;
label_17:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E1;
    int num5;
    if (num4 == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) c;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) 0;
      num5 = 1;
      goto label_20;
    }
label_18:
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy02E1 = (sbyte) (byte) num3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 1) = (sbyte) (byte) c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &arrayTypeBy02E1 + 2) = (sbyte) 0;
    num5 = 2;
label_20:
    \u0024ArrayType\u0024\u0024\u0024BY02E arrayTypeBy02E2;
    int num6 = \u003CModule\u003E.__crtLCMapStringA((localeinfo_struct*) 0, num1, 512U, (sbyte*) &arrayTypeBy02E1, num5, (sbyte*) &arrayTypeBy02E2, 3, (int) num2, 1);
    if (0 == num6)
      return c;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    return num6 == 1 ? (int) ^(byte&) ref arrayTypeBy02E2 : (int) ^(byte&) ref arrayTypeBy02E2 << 8 | (int) ^(byte&) ((IntPtr) &arrayTypeBy02E2 + 1);
  }

  internal static ushort towctrans(ushort c, [MarshalAs(UnmanagedType.U2)] char val) => val != '\u0001' ? \u003CModule\u003E.towlower(c) : \u003CModule\u003E.towupper(c);

  [return: MarshalAs(UnmanagedType.U2)]
  internal static unsafe char wctrans(sbyte* name)
  {
    int num = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref \u003CModule\u003E.\u003FA0x75aadbaf\u002Etab != 0)
    {
      wctab* wctabPtr = (wctab*) &\u003CModule\u003E.\u003FA0x75aadbaf\u002Etab;
      while (\u003CModule\u003E.strcmp((sbyte*) *(int*) wctabPtr, name) != 0)
      {
        ++num;
        wctabPtr = (wctab*) (num * 8 + (IntPtr) &\u003CModule\u003E.\u003FA0x75aadbaf\u002Etab);
        if (*(int*) wctabPtr == 0)
          goto label_5;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      return (char) ^(ushort&) (num * 8 + ((IntPtr) &\u003CModule\u003E.\u003FA0x75aadbaf\u002Etab + 4));
    }
label_5:
    return char.MinValue;
  }

  internal static unsafe ushort wctype(sbyte* name)
  {
    int num = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref \u003CModule\u003E.\u003FA0xd536467b\u002Etab != 0)
    {
      wctab* wctabPtr = (wctab*) &\u003CModule\u003E.\u003FA0xd536467b\u002Etab;
      while (\u003CModule\u003E.strcmp((sbyte*) *(int*) wctabPtr, name) != 0)
      {
        ++num;
        wctabPtr = (wctab*) (num * 8 + (IntPtr) &\u003CModule\u003E.\u003FA0xd536467b\u002Etab);
        if (*(int*) wctabPtr == 0)
          goto label_5;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      return ^(ushort&) (num * 8 + ((IntPtr) &\u003CModule\u003E.\u003FA0xd536467b\u002Etab + 4));
    }
label_5:
    return 0;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EInitialize()
  {
    object obj = new object();
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A = 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A, obj);
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A) != null;

  internal static void \u003FA0x23130d9f\u002E\u003F\u003F__E\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x23130d9f\u002E\u003F\u003F__F\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ));

  internal static unsafe void \u003FA0x23130d9f\u002E\u003F\u003F__F\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A);

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x23130d9f\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003FA0x23130d9f\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(&\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0V\u003F\u0024Handle\u0040P\u0024AAVObject\u0040System\u0040\u0040\u00402\u0040A));
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x23130d9f\u002E__alloc_global_lock()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EInitialize();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend,
    __FnPtr<void ()>** __ponexitbegin)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x23130d9f\u002E__global_lock())
    {
      try
      {
        if (*__pexit_list_size - 1U < (uint) (*(int*) __ponexitend - *(int*) __ponexitbegin) >> 2)
        {
          try
          {
            uint num2 = *__pexit_list_size * 4U;
            uint num3 = num2 >= 2048U ? 2048U : num2;
            IntPtr cb = new IntPtr((int) num2 + (int) num3);
            IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) __ponexitbegin), cb);
            __FnPtr<void ()>** local2 = __ponexitend;
            IntPtr num5 = *(int*) local2 + ((IntPtr) num4.ToPointer() - *(int*) __ponexitbegin);
            *(int*) local2 = (int) num5;
            *(int*) __ponexitbegin = (int) num4.ToPointer();
            uint num6 = *__pexit_list_size;
            uint num7 = 512U >= num6 ? num6 : 512U;
            *__pexit_list_size = num6 + num7;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) __ponexitbegin), cb);
            __FnPtr<void ()>** local3 = __ponexitend;
            IntPtr num9 = *(int*) local3 + ((IntPtr) num8.ToPointer() - *(int*) __ponexitbegin);
            *(int*) local3 = (int) num9;
            *(int*) __ponexitbegin = (int) num8.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num10 = (int) *numPtr + 4;
            *numPtr = (uint) num10;
          }
        }
        *(int*) *(int*) __ponexitend = (int) func;
        __FnPtr<void ()>** local4 = __ponexitend;
        int num11 = *(int*) local4 + 4;
        *(int*) local4 = num11;
        local1 = func;
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x23130d9f\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  internal static unsafe void _exit_callback()
  {
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitend_m);
    if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
      return;
    __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) ((IntPtr) local2 - 4);
    if (local3 >= local1)
    {
      do
      {
        uint num = (uint) *(int*) local3;
        if ((IntPtr) (int) num != (IntPtr) \u003CModule\u003E._encoded_null())
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) num))();
        }
        local3 -= 4;
      }
      while (local3 >= local1);
    }
    Marshal.FreeHGlobal(new IntPtr((void*) local1));
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x23130d9f\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
    \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x23130d9f\u002E__exit_list_size = 32U;
    return 1;
  }

  internal static unsafe int _atexit_m(__FnPtr<void ()> func)
  {
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitend_m);
    // ISSUE: cast to a function pointer type
    int num = \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.\u003FA0x23130d9f\u002E__exit_list_size, &local2, &local1);
    \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer((void*) local1);
    \u003CModule\u003E.\u003FA0x23130d9f\u002E__onexitend_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer((void*) local2);
    return num;
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x23130d9f\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero)
      return;
    if ((IntPtr) local2 == IntPtr.Zero)
      return;
    try
    {
      while (true)
      {
        do
        {
          local2 -= 4;
          if (local2 < local1)
            goto label_8;
        }
        while ((IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) *(int*) local2))();
      }
label_8:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
  }

  [DebuggerStepThrough]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func)
  {
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    // ISSUE: cast to a function pointer type
    int num = \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.__exit_list_size_app_domain, &local2, &local1);
    \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer((void*) local1);
    \u003CModule\u003E.__onexitend_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer((void*) local2);
    return num;
  }

  [DebuggerStepThrough]
  internal static unsafe object \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002EGet(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0)
  {
    uint num = (uint) *(int*) obj0;
    return num != 0U ? (ValueType) GCHandle.FromIntPtr(new IntPtr((void*) num)) : (ValueType) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002ESet(
    [In] Handle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E* obj0,
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EHandle\u003CSystem\u003A\u003AObject\u0020\u005E\u003E\u002E_handle(obj0);
    if (valueType == null)
    {
      IntPtr intPtr = GCHandle.ToIntPtr(GCHandle.Alloc(value));
      *(int*) obj0 = (int) intPtr.ToPointer();
    }
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((int) size * count + (IntPtr) ptr);
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int \u003FA0x21b573b5\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(int*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        --count;
        if (count >= 0)
        {
          ptr -= (int) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0x21b573b5\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  internal static uint _Stoulx(sbyte* s, sbyte** endptr, int @base, int* perr)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe uint _Stoul(sbyte* s, sbyte** endptr, int @base) => \u003CModule\u003E._Stoulx(s, endptr, @base, (int*) 0);

  internal static unsafe int _Stolx(sbyte* s, sbyte** endptr, int @base, int* perr)
  {
    if ((IntPtr) endptr == IntPtr.Zero)
    {
      sbyte* numPtr;
      endptr = &numPtr;
    }
    sbyte* s1 = s;
    if (\u003CModule\u003E.isspace((int) (byte) *s) != 0)
    {
      do
      {
        ++s1;
      }
      while (\u003CModule\u003E.isspace((int) (byte) *s1) != 0);
    }
    sbyte num1 = *s1;
    sbyte num2;
    switch (num1)
    {
      case 43:
      case 45:
        num2 = num1;
        ++s1;
        break;
      default:
        num2 = (sbyte) 43;
        break;
    }
    uint num3 = \u003CModule\u003E._Stoulx(s1, endptr, @base, perr);
    if ((IntPtr) s1 == (IntPtr) *(int*) endptr)
      *(int*) endptr = (int) s;
    if (((IntPtr) s != (IntPtr) *(int*) endptr || num3 == 0U) && (num2 != (sbyte) 43 || (uint) int.MaxValue >= num3))
    {
      uint num4;
      if (num2 == (sbyte) 45)
      {
        if (2147483648U >= num3)
          num4 = (uint) -(int) num3;
        else
          goto label_12;
      }
      else
        num4 = num3;
      return (int) num4;
    }
label_12:
    *\u003CModule\u003E._errno() = 34;
    if ((IntPtr) perr != IntPtr.Zero)
      *perr = 1;
    int minValue = int.MinValue;
    return num2 == (sbyte) 45 ? minValue : ~minValue;
  }

  internal static unsafe float __Stofx(sbyte* s, sbyte** endptr, int pten, int* perr)
  {
    sbyte* s0 = s;
    int num1 = \u003CModule\u003E._Stopfx(&s, endptr);
    int num2 = num1 & 8;
    if ((IntPtr) perr != IntPtr.Zero)
      *perr = 0;
    if ((IntPtr) endptr != IntPtr.Zero)
      *(int*) endptr = 0;
    float num3;
    switch (num1 & -9)
    {
      case 1:
        \u0024ArrayType\u0024\u0024\u0024BY01J arrayTypeBy01J1;
        int num4 = \u003CModule\u003E._Stoflt(s0, s, endptr, (int*) &arrayTypeBy01J1, 1);
        float x1;
        if (num4 == 0)
        {
          x1 = 0.0f;
        }
        else
        {
          int num5 = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          x1 = (float) ^(int&) ((IntPtr) &arrayTypeBy01J1 + 4);
          if (1 < num4)
          {
            do
            {
              ++num5;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              x1 = (float) ^(int&) (num5 * 4 + (IntPtr) &arrayTypeBy01J1) + x1 * 1E+09f;
            }
            while (num5 < num4);
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = \u003CModule\u003E._FDtentox(x1, ^(int&) ref arrayTypeBy01J1 + pten, perr);
        break;
      case 2:
        \u0024ArrayType\u0024\u0024\u0024BY01J arrayTypeBy01J2;
        int num6 = \u003CModule\u003E._Stoxflt(s0, s, endptr, (int*) &arrayTypeBy01J2, 1);
        float x2;
        if (num6 == 0)
        {
          x2 = 0.0f;
        }
        else
        {
          int num7 = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          x2 = (float) ^(int&) ((IntPtr) &arrayTypeBy01J2 + 4);
          if (1 < num6)
          {
            do
            {
              ++num7;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              x2 = (float) ^(int&) (num7 * 4 + (IntPtr) &arrayTypeBy01J2) + x2 * 268435456f;
            }
            while (num7 < num6);
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num8 = (int) \u003CModule\u003E._FDscale(&x2, ^(int&) ref arrayTypeBy01J2);
        num3 = \u003CModule\u003E._FDtentox(x2, pten, perr);
        break;
      case 3:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = ^(float&) ref \u003CModule\u003E._FInf;
        break;
      case 4:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = ^(float&) ref \u003CModule\u003E._FNan;
        break;
      default:
        num3 = 0.0f;
        break;
    }
    return num2 == 0 ? num3 : -num3;
  }

  internal static unsafe float _Stofx(sbyte* s, sbyte** endptr, int pten, int* perr) => (float) \u003CModule\u003E._Stodx(s, endptr, pten, perr);

  internal static unsafe float _Stof(sbyte* s, sbyte** endptr, int pten, int* perr) => (float) \u003CModule\u003E._Stod(s, endptr, pten);

  internal static unsafe double __Stoldx(sbyte* s, sbyte** endptr, int pten, int* perr)
  {
    sbyte* s0 = s;
    int num1 = \u003CModule\u003E._Stopfx(&s, endptr);
    int num2 = num1 & 8;
    if ((IntPtr) perr != IntPtr.Zero)
      *perr = 0;
    if ((IntPtr) endptr != IntPtr.Zero)
      *(int*) endptr = 0;
    double num3;
    switch (num1 & -9)
    {
      case 1:
        \u0024ArrayType\u0024\u0024\u0024BY02J arrayTypeBy02J1;
        int num4 = \u003CModule\u003E._Stoflt(s0, s, endptr, (int*) &arrayTypeBy02J1, 2);
        double x1;
        if (num4 == 0)
        {
          x1 = 0.0;
        }
        else
        {
          int num5 = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          x1 = (double) ^(int&) ((IntPtr) &arrayTypeBy02J1 + 4);
          if (1 < num4)
          {
            do
            {
              ++num5;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              x1 = (double) ^(int&) (num5 * 4 + (IntPtr) &arrayTypeBy02J1) + x1 * 1000000000.0;
            }
            while (num5 < num4);
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = \u003CModule\u003E._LDtentox(x1, ^(int&) ref arrayTypeBy02J1 + pten, perr);
        break;
      case 2:
        \u0024ArrayType\u0024\u0024\u0024BY02J arrayTypeBy02J2;
        int num6 = \u003CModule\u003E._Stoxflt(s0, s, endptr, (int*) &arrayTypeBy02J2, 2);
        double x2;
        if (num6 == 0)
        {
          x2 = 0.0;
        }
        else
        {
          int num7 = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          x2 = (double) ^(int&) ((IntPtr) &arrayTypeBy02J2 + 4);
          if (1 < num6)
          {
            do
            {
              ++num7;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              x2 = (double) ^(int&) (num7 * 4 + (IntPtr) &arrayTypeBy02J2) + x2 * 268435456.0;
            }
            while (num7 < num6);
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num8 = (int) \u003CModule\u003E._LDscale(&x2, ^(int&) ref arrayTypeBy02J2);
        num3 = \u003CModule\u003E._LDtentox(x2, pten, perr);
        break;
      case 3:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = ^(double&) ref \u003CModule\u003E._LInf;
        break;
      case 4:
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        num3 = ^(double&) ref \u003CModule\u003E._LNan;
        break;
      default:
        num3 = 0.0;
        break;
    }
    return num2 == 0 ? num3 : -num3;
  }

  internal static unsafe double _Stoldx(sbyte* s, sbyte** endptr, int pten, int* perr) => \u003CModule\u003E._Stodx(s, endptr, pten, perr);

  internal static unsafe double _Stold(sbyte* s, sbyte** endptr, int pten, int* perr) => \u003CModule\u003E._Stod(s, endptr, pten);

  internal static int _Stoxflt(sbyte* s0, sbyte* s, sbyte** endptr, int* lo, int maxsig)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe short \u003FA0x83709a7a\u002Edmul(double* px, double y)
  {
    short lexp;
    int num1 = (int) \u003CModule\u003E._Dunscale(&lexp, px);
    double* numPtr = px;
    double num2 = *numPtr * y;
    *numPtr = num2;
    return \u003CModule\u003E._Dscale(px, (int) lexp);
  }

  internal static unsafe double _Dtentox(double x, int n, int* perr)
  {
    if (n == 0 || x == 0.0)
      return x;
    double y = 1.0;
    short num1;
    if (n < 0)
    {
      uint num2 = (uint) -n;
      if (0U < num2)
      {
        int num3 = 0;
        while ((uint) num3 < 64U)
        {
          if (((int) num2 & 1) != 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            y = ^(double&) (num3 + (IntPtr) &\u003CModule\u003E.\u003FA0x83709a7a\u002Epows) * y;
          }
          num2 >>= 1;
          num3 += 8;
          if (0U >= num2)
            break;
        }
      }
      num1 = \u003CModule\u003E.\u003FA0x83709a7a\u002Edmul(&x, 1.0 / y);
      if (num1 < (short) 0 && 0U < num2)
      {
        do
        {
          num1 = \u003CModule\u003E.\u003FA0x83709a7a\u002Edmul(&x, 1E-256);
          if ((short) 0 > num1)
            --num2;
          else
            break;
        }
        while (0U < num2);
      }
    }
    else if (0 < n)
    {
      int num4 = 0;
      while ((uint) num4 < 64U)
      {
        if ((n & 1) != 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          y = ^(double&) (num4 + (IntPtr) &\u003CModule\u003E.\u003FA0x83709a7a\u002Epows) * y;
        }
        n >>= 1;
        num4 += 8;
        if (0 >= n)
          break;
      }
      num1 = \u003CModule\u003E.\u003FA0x83709a7a\u002Edmul(&x, y);
      if (num1 < (short) 0 && 0 < n)
      {
        do
        {
          num1 = \u003CModule\u003E.\u003FA0x83709a7a\u002Edmul(&x, 1E+256);
          if ((short) 0 > num1)
            --n;
          else
            break;
        }
        while (0 < n);
      }
    }
    if (num1 == (short) 0 || num1 == (short) 1)
    {
      *\u003CModule\u003E._errno() = 34;
      if ((IntPtr) perr != IntPtr.Zero)
      {
        int* numPtr = perr;
        int num5 = *numPtr | 1;
        *numPtr = num5;
      }
    }
    return x;
  }

  internal static unsafe int _Stoflt(sbyte* s0, sbyte* s, sbyte** endptr, int* lo, int maxsig)
  {
    maxsig *= 9;
    if (45 < maxsig)
      maxsig = 45;
    if (maxsig < 1)
      maxsig = 1;
    *lo = 0;
    lo[1] = 0;
    int num1 = 0;
    if (*s == (sbyte) 48)
    {
      num1 = 1;
      do
      {
        ++s;
      }
      while (*s == (sbyte) 48);
    }
    int index = 0;
    \u0024ArrayType\u0024\u0024\u0024BY0CO\u0040D arrayTypeBy0CoD;
    if (\u003CModule\u003E.isdigit((int) (byte) *s) != 0)
    {
      num1 = 1;
      do
      {
        if (index <= maxsig)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(sbyte&) (index + (IntPtr) &arrayTypeBy0CoD) = (sbyte) ((int) *s - 48);
          ++index;
        }
        else
        {
          int* numPtr = lo;
          int num2 = *numPtr + 1;
          *numPtr = num2;
        }
        ++s;
      }
      while (\u003CModule\u003E.isdigit((int) (byte) *s) != 0);
    }
    lconv* lconvPtr = \u003CModule\u003E.localeconv();
    if ((int) *s == (int) *(sbyte*) *(int*) lconvPtr)
      ++s;
    if (index == 0 && *s == (sbyte) 48)
    {
      num1 = 1;
      do
      {
        int* numPtr = lo;
        int num3 = *numPtr - 1;
        *numPtr = num3;
        ++s;
      }
      while (*s == (sbyte) 48);
    }
    if (\u003CModule\u003E.isdigit((int) (byte) *s) != 0)
    {
      num1 = 1;
      do
      {
        if (index <= maxsig)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(sbyte&) (index + (IntPtr) &arrayTypeBy0CoD) = (sbyte) ((int) *s - 48);
          ++index;
          int* numPtr = lo;
          int num4 = *numPtr - 1;
          *numPtr = num4;
        }
        ++s;
      }
      while (\u003CModule\u003E.isdigit((int) (byte) *s) != 0);
    }
    if (maxsig < index)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if ((sbyte) 5 <= ^(sbyte&) (maxsig + (IntPtr) &arrayTypeBy0CoD))
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(sbyte&) (maxsig + (IntPtr) &arrayTypeBy0CoD - 1) = (sbyte) ((int) ^(sbyte&) (maxsig + (IntPtr) &arrayTypeBy0CoD - 1) + 1);
      }
      index = maxsig;
      int* numPtr = lo;
      int num5 = *numPtr + 1;
      *numPtr = num5;
    }
    if (0 < index)
    {
      sbyte* numPtr1 = (sbyte*) ((IntPtr) &arrayTypeBy0CoD - 1);
      while (numPtr1[index] == (sbyte) 0)
      {
        int* numPtr2 = lo;
        int num6 = *numPtr2 + 1;
        *numPtr2 = num6;
        --index;
        if (0 >= index)
          break;
      }
    }
    if (index == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref arrayTypeBy0CoD = (sbyte) 0;
      index = 1;
    }
    int num7;
    if (num1 != 0)
    {
      int num8 = 0;
      int num9 = 9 - index % 9;
      int num10 = num9 % 9 == 0 ? 0 : 1;
      num7 = num10;
      if (0 < index)
      {
        int* numPtr = (int*) (num10 * 4 + (IntPtr) lo);
        int num11 = num9;
        do
        {
          if (num11 % 9 == 0)
          {
            ++num7;
            numPtr = (int*) (num7 * 4 + (IntPtr) lo);
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            *numPtr = (int) ^(sbyte&) (num8 + (IntPtr) &arrayTypeBy0CoD);
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            *numPtr = (int) ^(sbyte&) (num8 + (IntPtr) &arrayTypeBy0CoD) + *numPtr * 10;
          }
          ++num8;
          ++num11;
        }
        while (num8 < index);
      }
      switch (*s)
      {
        case 69:
        case 101:
          sbyte* numPtr3 = s;
          ++s;
          sbyte num12 = *s;
          sbyte num13;
          switch (num12)
          {
            case 43:
            case 45:
              num13 = num12;
              ++s;
              break;
            default:
              num13 = (sbyte) 43;
              break;
          }
          int num14 = 0;
          int num15 = 0;
          if (\u003CModule\u003E.isdigit((int) (byte) *s) != 0)
          {
            num14 = 1;
            do
            {
              if (num15 < 100000000)
                num15 = (int) (byte) *s + num15 * 10 - 48;
              ++s;
            }
            while (\u003CModule\u003E.isdigit((int) (byte) *s) != 0);
          }
          if (num13 == (sbyte) 45)
            num15 = -num15;
          int* numPtr4 = lo;
          int num16 = *numPtr4 + num15;
          *numPtr4 = num16;
          if (num14 == 0)
          {
            s = numPtr3;
            break;
          }
          break;
      }
    }
    else
      num7 = 0;
    if ((IntPtr) endptr != IntPtr.Zero)
    {
      sbyte* numPtr = num1 == 0 ? s0 : s;
      *(int*) endptr = (int) numPtr;
    }
    return num7;
  }

  internal static unsafe int _Stopfx(sbyte** ps, sbyte** endptr)
  {
    sbyte* numPtr1 = (sbyte*) *(int*) ps;
    int num1 = 0;
    if (\u003CModule\u003E.isspace((int) (byte) *numPtr1) != 0)
    {
      do
      {
        ++numPtr1;
      }
      while (\u003CModule\u003E.isspace((int) (byte) *numPtr1) != 0);
    }
    switch (*numPtr1)
    {
      case 43:
        ++numPtr1;
        break;
      case 45:
        num1 = 8;
        ++numPtr1;
        break;
    }
    int num2;
    switch (*numPtr1)
    {
      case 73:
      case 105:
        sbyte* numPtr2 = numPtr1 + 1;
        switch (*numPtr2)
        {
          case 78:
          case 110:
            sbyte* numPtr3 = numPtr2 + 1;
            switch (*numPtr3)
            {
              case 70:
              case 102:
                numPtr1 = numPtr3 + 1;
                num2 = num1 | 3;
                switch (*numPtr1)
                {
                  case 73:
                  case 105:
                    sbyte* numPtr4 = numPtr1 + 1;
                    switch (*numPtr4)
                    {
                      case 78:
                      case 110:
                        sbyte* numPtr5 = numPtr4 + 1;
                        switch (*numPtr5)
                        {
                          case 73:
                          case 105:
                            sbyte* numPtr6 = numPtr5 + 1;
                            switch (*numPtr6)
                            {
                              case 84:
                              case 116:
                                sbyte* numPtr7 = numPtr6 + 1;
                                switch (*numPtr7)
                                {
                                  case 89:
                                  case 121:
                                    numPtr1 = numPtr7 + 1;
                                    break;
                                }
                                break;
                            }
                            break;
                        }
                        break;
                    }
                    break;
                }
                break;
              default:
                goto label_9;
            }
          default:
label_9:
            numPtr1 = (sbyte*) *(int*) ps;
            num2 = 0;
            break;
        }
        if ((IntPtr) endptr != IntPtr.Zero)
        {
          *(int*) endptr = (int) numPtr1;
          break;
        }
        break;
      case 78:
      case 110:
        sbyte* numPtr8 = numPtr1 + 1;
        switch (*numPtr8)
        {
          case 65:
          case 97:
            sbyte* numPtr9 = numPtr8 + 1;
            switch (*numPtr9)
            {
              case 78:
              case 110:
                numPtr1 = numPtr9 + 1;
                sbyte* numPtr10 = numPtr1;
                num2 = 4;
                if (*numPtr1 == (sbyte) 40)
                {
                  do
                  {
                    ++numPtr10;
                  }
                  while (\u003CModule\u003E.isalnum((int) (byte) *numPtr10) != 0 || *numPtr10 == (sbyte) 95);
                  if (*numPtr10 == (sbyte) 41)
                  {
                    numPtr1 = numPtr10 + 1;
                    break;
                  }
                  break;
                }
                break;
              default:
                goto label_20;
            }
            break;
          default:
label_20:
            numPtr1 = (sbyte*) *(int*) ps;
            num2 = 0;
            break;
        }
        if ((IntPtr) endptr != IntPtr.Zero)
        {
          *(int*) endptr = (int) numPtr1;
          break;
        }
        break;
      default:
        num2 = num1 | 1;
        break;
    }
    *(int*) ps = (int) numPtr1;
    return num2;
  }

  internal static unsafe short \u003FA0x0a37817a\u002Edmul(float* px, float y)
  {
    short lexp;
    int num1 = (int) \u003CModule\u003E._FDunscale(&lexp, px);
    float* numPtr = px;
    double num2 = (double) (*numPtr * y);
    *numPtr = (float) num2;
    return \u003CModule\u003E._FDscale(px, (int) lexp);
  }

  internal static unsafe float _FDtentox(float x, int n, int* perr)
  {
    if (n == 0 || (double) x == 0.0)
      return x;
    float y = 1f;
    short num1;
    if (n < 0)
    {
      uint num2 = (uint) -n;
      if (0U < num2)
      {
        int num3 = 0;
        while ((uint) num3 < 20U)
        {
          if (((int) num2 & 1) != 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            y = ^(float&) (num3 + (IntPtr) &\u003CModule\u003E.\u003FA0x0a37817a\u002Epows) * y;
          }
          num2 >>= 1;
          num3 += 4;
          if (0U >= num2)
            break;
        }
      }
      num1 = \u003CModule\u003E.\u003FA0x0a37817a\u002Edmul(&x, 1f / y);
      if (num1 < (short) 0 && 0U < num2)
      {
        do
        {
          num1 = \u003CModule\u003E.\u003FA0x0a37817a\u002Edmul(&x, 9.9999995E-33f);
          if ((short) 0 > num1)
            --num2;
          else
            break;
        }
        while (0U < num2);
      }
    }
    else if (0 < n)
    {
      int num4 = 0;
      while ((uint) num4 < 20U)
      {
        if ((n & 1) != 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          y = ^(float&) (num4 + (IntPtr) &\u003CModule\u003E.\u003FA0x0a37817a\u002Epows) * y;
        }
        n >>= 1;
        num4 += 4;
        if (0 >= n)
          break;
      }
      num1 = \u003CModule\u003E.\u003FA0x0a37817a\u002Edmul(&x, y);
      if (num1 < (short) 0 && 0 < n)
      {
        do
        {
          num1 = \u003CModule\u003E.\u003FA0x0a37817a\u002Edmul(&x, 1E+32f);
          if ((short) 0 > num1)
            --n;
          else
            break;
        }
        while (0 < n);
      }
    }
    if (num1 == (short) 0 || num1 == (short) 1)
    {
      *\u003CModule\u003E._errno() = 34;
      if ((IntPtr) perr != IntPtr.Zero)
      {
        int* numPtr = perr;
        int num5 = *numPtr | 1;
        *numPtr = num5;
      }
    }
    return x;
  }

  internal static unsafe short \u003FA0x1d1511b3\u002Edmul(double* px, double y)
  {
    short lexp;
    int num1 = (int) \u003CModule\u003E._LDunscale(&lexp, px);
    double* numPtr = px;
    double num2 = *numPtr * y;
    *numPtr = num2;
    return \u003CModule\u003E._LDscale(px, (int) lexp);
  }

  internal static unsafe double _LDtentox(double x, int n, int* perr)
  {
    if (n == 0 || x == 0.0)
      return x;
    double y = 1.0;
    short num1;
    if (n < 0)
    {
      uint num2 = (uint) -n;
      if (0U < num2)
      {
        int num3 = 0;
        while ((uint) num3 < 64U)
        {
          if (((int) num2 & 1) != 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            y = ^(double&) (num3 + (IntPtr) &\u003CModule\u003E.\u003FA0x1d1511b3\u002Epows) * y;
          }
          num2 >>= 1;
          num3 += 8;
          if (0U >= num2)
            break;
        }
      }
      num1 = \u003CModule\u003E.\u003FA0x1d1511b3\u002Edmul(&x, 1.0 / y);
      if (num1 < (short) 0 && 0U < num2)
      {
        do
        {
          num1 = \u003CModule\u003E.\u003FA0x1d1511b3\u002Edmul(&x, 1E-256);
          if ((short) 0 > num1)
            --num2;
          else
            break;
        }
        while (0U < num2);
      }
    }
    else if (0 < n)
    {
      int num4 = 0;
      while ((uint) num4 < 64U)
      {
        if ((n & 1) != 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          y = ^(double&) (num4 + (IntPtr) &\u003CModule\u003E.\u003FA0x1d1511b3\u002Epows) * y;
        }
        n >>= 1;
        num4 += 8;
        if (0 >= n)
          break;
      }
      num1 = \u003CModule\u003E.\u003FA0x1d1511b3\u002Edmul(&x, y);
      if (num1 < (short) 0 && 0 < n)
      {
        do
        {
          num1 = \u003CModule\u003E.\u003FA0x1d1511b3\u002Edmul(&x, 1E+256);
          if ((short) 0 > num1)
            --n;
          else
            break;
        }
        while (0 < n);
      }
    }
    if (num1 == (short) 0 || num1 == (short) 1)
    {
      *\u003CModule\u003E._errno() = 34;
      if ((IntPtr) perr != IntPtr.Zero)
      {
        int* numPtr = perr;
        int num5 = *numPtr | 1;
        *numPtr = num5;
      }
    }
    return x;
  }

  internal static unsafe short _Dunscale(short* pex, double* px)
  {
    short num = (short) ((uint) (ushort) ((uint) *(ushort*) ((byte*) px + 6) & 32752U) >> 4);
    if (num == (short) 2047)
    {
      *pex = (short) 0;
      return (ushort) ((uint) *(ushort*) ((byte*) px + 6) & 15U) != (ushort) 0 || *(ushort*) ((byte*) px + 4) != (ushort) 0 || *(ushort*) ((byte*) px + 2) != (ushort) 0 || *(ushort*) px != (ushort) 0 ? (short) 2 : (short) 1;
    }
    if ((short) 0 >= num)
    {
      num = \u003CModule\u003E._Dnorm((ushort*) px);
      if (num > (short) 0)
      {
        *pex = (short) 0;
        return 0;
      }
    }
    *(short*) ((byte*) px + 6) = (short) ((int) *(ushort*) ((byte*) px + 6) & 32783 | 16352);
    *pex = (short) ((int) num - 1022);
    return -1;
  }

  internal static unsafe short _FDunscale(short* pex, float* px)
  {
    short num = (short) ((uint) (ushort) ((uint) *(ushort*) ((byte*) px + 2) & 32640U) >> 7);
    if (num == (short) byte.MaxValue)
    {
      *pex = (short) 0;
      return (ushort) ((uint) *(ushort*) ((byte*) px + 2) & (uint) sbyte.MaxValue) != (ushort) 0 || *(ushort*) px != (ushort) 0 ? (short) 2 : (short) 1;
    }
    if ((short) 0 >= num)
    {
      num = \u003CModule\u003E._FDnorm((ushort*) px);
      if (num > (short) 0)
      {
        *pex = (short) 0;
        return 0;
      }
    }
    *(short*) ((byte*) px + 2) = (short) ((int) *(ushort*) ((byte*) px + 2) & 32895 | 16128);
    *pex = (short) ((int) num - 126);
    return -1;
  }

  internal static unsafe short _LDunscale(short* pex, double* px) => \u003CModule\u003E._Dunscale(pex, px);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _decode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encoded_null();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void __setusermatherr([In] __FnPtr<int (_exception*)> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* GetModuleHandleA([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<int (uint)> _query_new_handler();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe __FnPtr<int ()> GetProcAddress([In] HINSTANCE__* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<int (uint)> _set_new_handler([In] __FnPtr<int (uint)> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int* _errno();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CorBindToRuntimeEx(
    [In] char* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] _GUID* obj4,
    [In] void** obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void (int)> signal([In] int obj0, [In] __FnPtr<void (int)> obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _invalid_parameter(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CoCreateInstance(
    [In] _GUID* obj0,
    [In] IUnknown* obj1,
    [In] uint obj2,
    [In] _GUID* obj3,
    [In] void** obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _get_purecall_handler();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void (char*, char*, char*, uint, uint)> _set_invalid_parameter_handler(
    [In] __FnPtr<void (char*, char*, char*, uint, uint)> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _get_unexpected();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> set_unexpected([In] __FnPtr<void ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _get_terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> _set_purecall_handler([In] __FnPtr<void ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void ()> set_terminate([In] __FnPtr<void ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void (char*, char*, char*, uint, uint)> _get_invalid_parameter_handler();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _fpieee_flt(
    [In] uint obj0,
    [In] _EXCEPTION_POINTERS* obj1,
    [In] __FnPtr<int (_FPIEEE_RECORD*)> obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int strcpy_s([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint strlen([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* malloc([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void free([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateThread(
    [In] _SECURITY_ATTRIBUTES* obj0,
    [In] uint obj1,
    [In] __FnPtr<uint (void*)> obj2,
    [In] void* obj3,
    [In] uint obj4,
    [In] uint* obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint ResumeThread([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _dosmaperr([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _XcptFilter([In] uint obj0, [In] _EXCEPTION_POINTERS* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern __FnPtr<void* (uint)> __set_flsgetvalue();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _tiddata* _getptd();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __fls_setvalue([In] uint obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void ExitThread([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _initptd([In] _tiddata* obj0, [In] threadlocaleinfostruct* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* __fls_getvalue([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _freefls([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* calloc([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _endthread();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint __get_flsindex();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetCurrentThreadId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _endthreadex([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memcpy_s([In] void* obj0, [In] uint obj1, [In] void* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memset([In] void* obj0, [In] int obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _invalid_parameter_noinfo();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint wcslen([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memchr([In] void* obj0, [In] int obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memcmp([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int memmove_s([In] void* obj0, [In] uint obj1, [In] void* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _invoke_watson(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void abort();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fclose([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fseek([In] _iobuf* obj0, [In] int obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint fwrite([In] void* obj0, [In] uint obj1, [In] uint obj2, [In] _iobuf* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int setvbuf([In] _iobuf* obj0, [In] sbyte* obj1, [In] int obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fsetpos([In] _iobuf* obj0, [In] long* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fgetc([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fflush([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fgetpos([In] _iobuf* obj0, [In] long* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* __iob_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int ungetc([In] int obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fputc([In] int obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort fgetwc([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort ungetwc([In] ushort obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort fputwc([MarshalAs(UnmanagedType.U2)] char _param0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* setlocale([In] int obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* realloc([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint strcspn([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int sprintf_s([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe lconv* localeconv();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe long _strtoi64([In] sbyte* obj0, [In] sbyte** obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ulong _strtoui64([In] sbyte* obj0, [In] sbyte** obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* new\u005B\u005D([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _Gettnames();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* _Getdays();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint _Strftime(
    [In] sbyte* obj0,
    [In] uint obj1,
    [In] sbyte* obj2,
    [In] tm* obj3,
    [In] void* obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* _Getmonths();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint* ___lc_handle_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int GetLocaleInfoA([In] uint obj0, [In] uint obj1, [In] sbyte* obj2, [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe double strtod([In] sbyte* obj0, [In] sbyte** obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtGetStringTypeW(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] ushort* obj4,
    [In] int obj5,
    [In] int obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe localeinfo_struct* _GetLocaleForCP([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern int \u003FA0x9284953a\u002E_InitCPLocHash();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint ___lc_codepage_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe ushort* __pctype_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int MultiByteToWideChar(
    [In] uint obj0,
    [In] uint obj1,
    [In] sbyte* obj2,
    [In] int obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int ___mb_cur_max_l_func([In] localeinfo_struct* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedCompareExchange([In] int* obj0, [In] int obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtLCMapStringW(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] char* obj3,
    [In] int obj4,
    [In] char* obj5,
    [In] int obj6,
    [In] int obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint ___lc_collate_cp_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtCompareStringA(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] sbyte* obj3,
    [In] int obj4,
    [In] sbyte* obj5,
    [In] int obj6,
    [In] int obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtLCMapStringA(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] sbyte* obj3,
    [In] int obj4,
    [In] sbyte* obj5,
    [In] int obj6,
    [In] int obj7,
    [In] int obj8);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memcpy([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __crtCompareStringW(
    [In] localeinfo_struct* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] char* obj3,
    [In] int obj4,
    [In] char* obj5,
    [In] int obj6,
    [In] int obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int WideCharToMultiByte(
    [In] uint obj0,
    [In] uint obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] sbyte* obj4,
    [In] int obj5,
    [In] sbyte* obj6,
    [In] int* obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedDecrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedIncrement([In] int* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void DeleteCriticalSection([In] _RTL_CRITICAL_SECTION* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int InterlockedExchange([In] int* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void InitializeCriticalSection([In] _RTL_CRITICAL_SECTION* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _get_osplatform([In] uint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int mbstowcs_s(
    [In] uint* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] sbyte* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int wcstombs_s(
    [In] uint* obj0,
    [In] sbyte* obj1,
    [In] uint obj2,
    [In] char* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* _wfsopen([In] char* obj0, [In] char* obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* _fsopen([In] sbyte* obj0, [In] sbyte* obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fputs([In] sbyte* obj0, [In] _iobuf* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern bool __uncaught_exception();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isupper([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int islower([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern ushort towupper([In] ushort obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int strcmp([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern ushort towlower([In] ushort obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int tolower([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isspace([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isdigit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int isalnum([In] int obj0);
}
