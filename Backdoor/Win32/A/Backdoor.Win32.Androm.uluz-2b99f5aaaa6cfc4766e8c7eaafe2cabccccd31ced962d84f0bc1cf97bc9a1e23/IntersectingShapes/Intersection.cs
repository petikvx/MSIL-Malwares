// Decompiled with JetBrains decompiler
// Type: IntersectingShapes.Intersection
// Assembly: 太城hضd氏bTنH, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FB883643-FAF4-44BB-B4FC-F1B0FC1059A6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Backdoor.Win32.Androm.uluz-2b99f5aaaa6cfc4766e8c7eaafe2cabccccd31ced962d84f0bc1cf97bc9a1e23.exe

using System;
using System.Collections.Generic;

namespace IntersectingShapes
{
  public class Intersection
  {
    private const int axisX = 101;
    private const int axisY = 21;
    private int minX;
    private int minY;
    private int maxX;
    private int maxY;
    private ConsoleColor[,] px = new ConsoleColor[21, 101];

    public List<Shape> ProvidedShapes { get; set; }

    public bool[,] IsAnIntersectingShape { get; set; }

    private bool[] IntersectingIndex { get; set; }

    public bool AnyIntersectionFound { get; set; }

    public void FindIntersecingShapes(bool printOnConsole = false)
    {
      int count = this.ProvidedShapes.Count;
      this.IntersectingIndex = new bool[count];
      this.IsAnIntersectingShape = new bool[count, count];
      this.AnyIntersectionFound = false;
      for (int index1 = 0; index1 < count; ++index1)
      {
        for (int index2 = 0; index2 < count; ++index2)
        {
          if (index1 == index2)
            this.IsAnIntersectingShape[index1, index2] = false;
          else if (index2 > index1)
          {
            this.IsAnIntersectingShape[index1, index2] = this.AreShapesIntersecting(this.ProvidedShapes[index1], this.ProvidedShapes[index2]);
            if (this.IsAnIntersectingShape[index1, index2])
            {
              this.IntersectingIndex[index1] = true;
              this.IntersectingIndex[index2] = true;
              this.AnyIntersectionFound = true;
            }
          }
          else
            this.IsAnIntersectingShape[index1, index2] = this.IsAnIntersectingShape[index2, index1];
        }
      }
      if (!printOnConsole)
        return;
      this.PrintIntersections();
    }

    private bool AreShapesIntersecting(Shape shape1, Shape shape2)
    {
      Vector[] destinationArray = new Vector[shape1.Edges.Length + shape2.Edges.Length];
      Array.Copy((Array) shape1.Edges, (Array) destinationArray, shape1.Edges.Length);
      Array.Copy((Array) shape2.Edges, 0, (Array) destinationArray, shape1.Edges.Length, shape2.Edges.Length);
      foreach (Vector vector in destinationArray)
      {
        Vector axis = new Vector(-vector.Y, vector.X);
        double maxValue1 = double.MaxValue;
        double maxValue2 = double.MaxValue;
        double minValue1 = double.MinValue;
        double minValue2 = double.MinValue;
        this.ProjectShape(axis, shape1, ref maxValue1, ref minValue1);
        this.ProjectShape(axis, shape2, ref maxValue2, ref minValue2);
        if (!this.AreProjectionsOverrlapping(maxValue1, minValue1, maxValue2, minValue2))
          return false;
      }
      return true;
    }

    private void ProjectShape(Vector axis, Shape shape, ref double min, ref double max)
    {
      for (int index = 0; index < shape.Coordinates.Length; ++index)
      {
        double num = axis.DotProduct(shape.Coordinates[index]);
        if (num < min)
          min = num;
        if (num > max)
          max = num;
      }
    }

    private bool AreProjectionsOverrlapping(double minA, double maxA, double minB, double maxB) => (minA >= minB ? minA - maxB : minB - maxA) < 0.0;

    private void PrintIntersections()
    {
      for (int index1 = 0; index1 < this.ProvidedShapes.Count; ++index1)
      {
        bool flag = false;
        Console.Write("Shapes intersecting with shape {0}: ", (object) (index1 + 1));
        for (int index2 = 0; index2 < this.ProvidedShapes.Count; ++index2)
        {
          if (this.IsAnIntersectingShape[index1, index2])
          {
            Console.Write("{0} ", (object) (index2 + 1));
            flag = true;
          }
        }
        if (!flag)
          Console.Write("No intersections!");
        Console.WriteLine();
      }
    }

    public Intersection() => this.ProvidedShapes = new List<Shape>();

    public void Draw()
    {
      this.FindMinMax();
      if (this.minX < -50 || this.maxX > 50 || this.minY < -10 || this.maxY > 10)
      {
        Console.WriteLine("This range of coordinates cannot be plotted");
      }
      else
      {
        for (int index1 = 0; index1 < 21; ++index1)
        {
          for (int index2 = 0; index2 < 101; ++index2)
            this.px[index1, index2] = Console.BackgroundColor;
        }
        this.FindIntersecingShapes();
        for (int index3 = 0; index3 < this.ProvidedShapes.Count; ++index3)
        {
          ConsoleColor color = ConsoleColor.White;
          if (this.IntersectingIndex[index3])
            color = ConsoleColor.Red;
          for (int index4 = 0; index4 < this.ProvidedShapes[index3].Segments.Length; ++index4)
            this.DrawLineSegment((int) this.ProvidedShapes[index3].Segments[index4][0].x, (int) this.ProvidedShapes[index3].Segments[index4][0].y, (int) this.ProvidedShapes[index3].Segments[index4][1].x, (int) this.ProvidedShapes[index3].Segments[index4][1].y, color);
        }
        this.DrawOnConsole();
      }
    }

    private void FindMinMax()
    {
      this.minX = int.MaxValue;
      this.maxX = int.MinValue;
      this.minY = int.MaxValue;
      this.maxY = int.MinValue;
      for (int index1 = 0; index1 < this.ProvidedShapes.Count; ++index1)
      {
        for (int index2 = 0; index2 < this.ProvidedShapes[index1].Coordinates.Length; ++index2)
        {
          if ((double) this.minX > this.ProvidedShapes[index1].Coordinates[index2].x)
            this.minX = (int) this.ProvidedShapes[index1].Coordinates[index2].x;
          if ((double) this.maxX < this.ProvidedShapes[index1].Coordinates[index2].x)
            this.maxX = (int) this.ProvidedShapes[index1].Coordinates[index2].x;
          if ((double) this.minY > this.ProvidedShapes[index1].Coordinates[index2].y)
            this.minY = (int) this.ProvidedShapes[index1].Coordinates[index2].y;
          if ((double) this.maxY < this.ProvidedShapes[index1].Coordinates[index2].y)
            this.maxY = (int) this.ProvidedShapes[index1].Coordinates[index2].y;
        }
      }
    }

    private void DrawLineSegment(int x1, int y1, int x2, int y2, ConsoleColor color)
    {
      int num = (x2 - x1) * y1 - (y2 - y1) * x1;
      for (int index1 = Math.Min(y1, y2); index1 <= Math.Max(y1, y2); ++index1)
      {
        for (int index2 = Math.Min(x1, x2); index2 <= Math.Max(x1, x2); ++index2)
        {
          if ((x2 - x1) * index1 == (y2 - y1) * index2 + num)
            this.px[index1 + 10, index2 + 50] = color;
        }
      }
    }

    private void DrawOnConsole()
    {
      for (int index1 = 20; index1 >= 0; --index1)
      {
        for (int index2 = 0; index2 < 101; ++index2)
        {
          Console.ForegroundColor = this.px[index1, index2];
          Console.Write(".");
        }
        Console.WriteLine();
      }
      Console.ForegroundColor = ConsoleColor.White;
    }
  }
}
