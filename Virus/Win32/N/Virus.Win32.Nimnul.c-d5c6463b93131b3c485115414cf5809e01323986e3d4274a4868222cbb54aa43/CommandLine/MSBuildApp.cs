// Decompiled with JetBrains decompiler
// Type: Microsoft.Build.CommandLine.MSBuildApp
// Assembly: MSBuild, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: E42BAB90-704E-4C03-B5C0-D4E3A6B884E3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Virus.Win32.Nimnul.c-d5c6463b93131b3c485115414cf5809e01323986e3d4274a4868222cbb54aa43.exe

using Microsoft.Build.BuildEngine;
using Microsoft.Build.Framework;
using Microsoft.Build.Shared;
using System;
using System.Collections;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Security;
using System.Text;
using System.Threading;

namespace Microsoft.Build.CommandLine
{
  public static class MSBuildApp
  {
    private const string autoResponseFileName = "MSBuild.rsp";
    private static readonly string binPath = Path.GetDirectoryName(new Uri(Assembly.GetExecutingAssembly().EscapedCodeBase).LocalPath);
    private static ArrayList includedResponseFiles;
    internal static bool usingSwitchesFromAutoResponseFile = false;
    private static readonly char[] propertyValueSeparator = new char[1]
    {
      '='
    };
    private static readonly TypeFilter loggerClassFilter = new TypeFilter(MSBuildApp.IsLoggerClass);

    [STAThread]
    public static int Main() => MSBuildApp.Execute(Environment.CommandLine) != MSBuildApp.ExitType.Success ? 1 : 0;

    public static MSBuildApp.ExitType Execute(string commandLine)
    {
      ErrorUtilities.VerifyThrowArgumentLength(commandLine, nameof (commandLine));
      MSBuildApp.ExitType exitType = MSBuildApp.ExitType.Success;
      try
      {
        MSBuildApp.VerifyThrowSupportedOS();
        MSBuildApp.SetConsoleUI();
        MSBuildApp.ResetBuildState();
        string projectFile = (string) null;
        string[] targets = new string[0];
        BuildPropertyGroup propertyBag = (BuildPropertyGroup) null;
        ILogger[] loggers = new ILogger[0];
        bool needToValidateProject = false;
        string schemaFile = (string) null;
        if (MSBuildApp.ProcessCommandLineSwitches(MSBuildApp.GatherAllSwitches(commandLine), ref projectFile, ref targets, ref propertyBag, ref loggers, ref needToValidateProject, ref schemaFile))
        {
          if (!MSBuildApp.BuildProject(projectFile, targets, propertyBag, loggers, needToValidateProject, schemaFile))
            exitType = MSBuildApp.ExitType.BuildError;
        }
      }
      catch (CommandLineSwitchException ex)
      {
        Console.WriteLine(ex.Message);
        Console.WriteLine();
        MSBuildApp.ShowHelpPrompt();
        exitType = MSBuildApp.ExitType.SwitchError;
      }
      catch (InitializationException ex)
      {
        Console.WriteLine(ex.Message);
        exitType = MSBuildApp.ExitType.InitializationError;
      }
      catch (LoggerException ex)
      {
        if (ex.ErrorCode != null)
          Console.WriteLine(ResourceUtilities.FormatResourceString("LoggerFailurePrefixNoErrorCode", (object) ex.ErrorCode, (object) ex.Message));
        else
          Console.WriteLine(ResourceUtilities.FormatResourceString("LoggerFailurePrefixWithErrorCode", (object) ex.Message));
        if (ex.InnerException != null)
          Console.WriteLine(ex.InnerException.Message);
        exitType = MSBuildApp.ExitType.LoggerAbort;
      }
      catch (InternalLoggerException ex)
      {
        Console.WriteLine("MSBUILD : error " + ex.ErrorCode + ": " + ex.Message);
        Console.WriteLine(ex.InnerException.ToString());
        exitType = MSBuildApp.ExitType.LoggerFailure;
      }
      catch
      {
        Console.WriteLine(AssemblyResources.GetString("FatalError"));
        throw;
      }
      return exitType;
    }

    private static void ResetBuildState()
    {
      MSBuildApp.includedResponseFiles = new ArrayList();
      MSBuildApp.usingSwitchesFromAutoResponseFile = false;
    }

    private static bool BuildProject(
      string projectFile,
      string[] targets,
      BuildPropertyGroup propertyBag,
      ILogger[] loggers,
      bool needToValidateProject,
      string schemaFile)
    {
      bool flag = false;
      Engine engine = new Engine(MSBuildApp.binPath);
      engine.GlobalProperties = propertyBag;
      try
      {
        foreach (ILogger logger in loggers)
          engine.RegisterLogger(logger);
        Project newProject = engine.CreateNewProject();
        newProject.IsValidated = needToValidateProject;
        newProject.SchemaFile = schemaFile;
        newProject.Load(projectFile);
        flag = engine.BuildProject(newProject, targets);
      }
      catch (InvalidProjectFileException ex)
      {
      }
      finally
      {
        engine.UnregisterAllLoggers();
      }
      return flag;
    }

    private static void VerifyThrowSupportedOS()
    {
      if (Environment.OSVersion.Platform != PlatformID.Win32S && Environment.OSVersion.Platform != PlatformID.Win32Windows && Environment.OSVersion.Platform != PlatformID.WinCE && (Environment.OSVersion.Platform != PlatformID.Win32NT || Environment.OSVersion.Version.Major > 4))
        return;
      InitializationException.VerifyThrow(false, "UnsupportedOS");
    }

    internal static void SetConsoleUI()
    {
      Thread currentThread = Thread.CurrentThread;
      currentThread.CurrentUICulture = CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture();
      int codePage = Console.OutputEncoding.CodePage;
      if (codePage == 65001 || codePage == currentThread.CurrentUICulture.TextInfo.OEMCodePage || codePage == currentThread.CurrentUICulture.TextInfo.ANSICodePage)
        return;
      currentThread.CurrentUICulture = new CultureInfo("en-US");
    }

    private static CommandLineSwitches GatherAllSwitches(string commandLine)
    {
      ArrayList commandLineArgs = QuotingUtilities.SplitUnquoted(commandLine);
      commandLineArgs.RemoveAt(0);
      CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
      MSBuildApp.GatherCommandLineSwitches(commandLineArgs, commandLineSwitches);
      return MSBuildApp.GatherAutoResponseFileSwitches(commandLineSwitches);
    }

    private static void GatherCommandLineSwitches(
      ArrayList commandLineArgs,
      CommandLineSwitches commandLineSwitches)
    {
      foreach (string commandLineArg in commandLineArgs)
      {
        int doubleQuotesRemoved;
        string str = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemoved);
        if (str.Length > 0)
        {
          if (str.StartsWith("@", StringComparison.Ordinal))
          {
            MSBuildApp.GatherResponseFileSwitch(str, commandLineSwitches);
          }
          else
          {
            string switchName;
            string switchParameters;
            if (!str.StartsWith("-", StringComparison.Ordinal) && !str.StartsWith("/", StringComparison.Ordinal))
            {
              switchName = (string) null;
              switchParameters = ":" + commandLineArg;
            }
            else
            {
              int switchParameterIndicator = str.IndexOf(':');
              if (switchParameterIndicator == -1)
              {
                switchName = str.Substring(1);
                switchParameters = string.Empty;
              }
              else
              {
                switchName = str.Substring(1, switchParameterIndicator - 1);
                switchParameters = MSBuildApp.ExtractSwitchParameters(commandLineArg, str, doubleQuotesRemoved, switchName, switchParameterIndicator);
              }
            }
            CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
            string duplicateSwitchErrorMessage;
            if (CommandLineSwitches.IsParameterlessSwitch(switchName, out parameterlessSwitch, out duplicateSwitchErrorMessage))
            {
              MSBuildApp.GatherParameterlessCommandLineSwitch(commandLineSwitches, parameterlessSwitch, switchParameters, duplicateSwitchErrorMessage, str);
            }
            else
            {
              CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
              bool multipleParametersAllowed;
              string missingParametersErrorMessage;
              bool unquoteParameters;
              if (CommandLineSwitches.IsParameterizedSwitch(switchName, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters))
                MSBuildApp.GatherParameterizedCommandLineSwitch(commandLineSwitches, parameterizedSwitch, switchParameters, duplicateSwitchErrorMessage, multipleParametersAllowed, missingParametersErrorMessage, unquoteParameters, str);
              else
                commandLineSwitches.SetUnknownSwitchError(str);
            }
          }
        }
      }
    }

    internal static string ExtractSwitchParameters(
      string commandLineArg,
      string unquotedCommandLineArg,
      int doubleQuotesRemovedFromArg,
      string switchName,
      int switchParameterIndicator)
    {
      int num1 = commandLineArg.IndexOf(':');
      int doubleQuotesRemoved;
      string str = QuotingUtilities.Unquote(commandLineArg.Substring(0, num1), out doubleQuotesRemoved);
      ErrorUtilities.VerifyThrow(switchName == str.Substring(1), "The switch name extracted from either the partially or completely unquoted arg should be the same.");
      ErrorUtilities.VerifyThrow(doubleQuotesRemovedFromArg >= doubleQuotesRemoved, "The name portion of the switch cannot contain more quoting than the arg itself.");
      string switchParameters;
      if (doubleQuotesRemoved % 2 == 0)
      {
        switchParameters = commandLineArg.Substring(num1);
      }
      else
      {
        int num2 = commandLineArg.IndexOf('"', num1 + 1);
        switchParameters = doubleQuotesRemovedFromArg - doubleQuotesRemoved > 1 || num2 != -1 && num2 != commandLineArg.Length - 1 ? ":\"" + commandLineArg.Substring(num1 + 1) : unquotedCommandLineArg.Substring(switchParameterIndicator);
      }
      ErrorUtilities.VerifyThrow(switchParameters != null, "We must be able to extract the switch parameters.");
      return switchParameters;
    }

    private static void GatherResponseFileSwitch(
      string unquotedCommandLineArg,
      CommandLineSwitches commandLineSwitches)
    {
      try
      {
        string path = unquotedCommandLineArg.Substring(1);
        if (path.Length == 0)
          commandLineSwitches.SetSwitchError("MissingResponseFileError", unquotedCommandLineArg);
        else if (!File.Exists(path))
        {
          commandLineSwitches.SetParameterError("ResponseFileNotFoundError", unquotedCommandLineArg);
        }
        else
        {
          string fullPath = Path.GetFullPath(path);
          bool flag = false;
          foreach (string includedResponseFile in MSBuildApp.includedResponseFiles)
          {
            if (string.Compare(fullPath, includedResponseFile, StringComparison.OrdinalIgnoreCase) == 0)
            {
              commandLineSwitches.SetParameterError("RepeatedResponseFileError", unquotedCommandLineArg);
              flag = true;
              break;
            }
          }
          if (flag)
            return;
          MSBuildApp.includedResponseFiles.Add((object) fullPath);
          ArrayList commandLineArgs;
          using (StreamReader streamReader = new StreamReader(fullPath, Encoding.Default))
          {
            commandLineArgs = new ArrayList();
            while (streamReader.Peek() != -1)
            {
              string name = streamReader.ReadLine().TrimStart();
              if (!name.StartsWith("#", StringComparison.Ordinal))
                commandLineArgs.AddRange((ICollection) QuotingUtilities.SplitUnquoted(Environment.ExpandEnvironmentVariables(name)));
            }
          }
          MSBuildApp.GatherCommandLineSwitches(commandLineArgs, commandLineSwitches);
        }
      }
      catch (NotSupportedException ex)
      {
        commandLineSwitches.SetParameterError("ReadResponseFileError", unquotedCommandLineArg, (Exception) ex);
      }
      catch (SecurityException ex)
      {
        commandLineSwitches.SetParameterError("ReadResponseFileError", unquotedCommandLineArg, (Exception) ex);
      }
      catch (UnauthorizedAccessException ex)
      {
        commandLineSwitches.SetParameterError("ReadResponseFileError", unquotedCommandLineArg, (Exception) ex);
      }
      catch (IOException ex)
      {
        commandLineSwitches.SetParameterError("ReadResponseFileError", unquotedCommandLineArg, (Exception) ex);
      }
    }

    private static void GatherParameterlessCommandLineSwitch(
      CommandLineSwitches commandLineSwitches,
      CommandLineSwitches.ParameterlessSwitch parameterlessSwitch,
      string switchParameters,
      string duplicateSwitchErrorMessage,
      string unquotedCommandLineArg)
    {
      if (switchParameters.Length == 0)
      {
        if (!commandLineSwitches.IsParameterlessSwitchSet(parameterlessSwitch) || duplicateSwitchErrorMessage == null)
          commandLineSwitches.SetParameterlessSwitch(parameterlessSwitch, unquotedCommandLineArg);
        else
          commandLineSwitches.SetSwitchError(duplicateSwitchErrorMessage, unquotedCommandLineArg);
      }
      else
        commandLineSwitches.SetUnexpectedParametersError(unquotedCommandLineArg);
    }

    private static void GatherParameterizedCommandLineSwitch(
      CommandLineSwitches commandLineSwitches,
      CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
      string switchParameters,
      string duplicateSwitchErrorMessage,
      bool multipleParametersAllowed,
      string missingParametersErrorMessage,
      bool unquoteParameters,
      string unquotedCommandLineArg)
    {
      if (switchParameters.Length > 1 || missingParametersErrorMessage == null)
      {
        if (!commandLineSwitches.IsParameterizedSwitchSet(parameterizedSwitch) || duplicateSwitchErrorMessage == null)
        {
          if (switchParameters.Length > 0)
            switchParameters = switchParameters.Substring(1);
          if (commandLineSwitches.SetParameterizedSwitch(parameterizedSwitch, unquotedCommandLineArg, switchParameters, multipleParametersAllowed, unquoteParameters) || missingParametersErrorMessage == null)
            return;
          commandLineSwitches.SetSwitchError(missingParametersErrorMessage, unquotedCommandLineArg);
        }
        else
          commandLineSwitches.SetSwitchError(duplicateSwitchErrorMessage, unquotedCommandLineArg);
      }
      else
        commandLineSwitches.SetSwitchError(missingParametersErrorMessage, unquotedCommandLineArg);
    }

    private static CommandLineSwitches GatherAutoResponseFileSwitches(
      CommandLineSwitches commandLineSwitches)
    {
      CommandLineSwitches commandLineSwitches1 = commandLineSwitches;
      if (!commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
      {
        string path = Path.Combine(MSBuildApp.binPath, "MSBuild.rsp");
        if (File.Exists(path))
        {
          commandLineSwitches1 = new CommandLineSwitches();
          MSBuildApp.GatherResponseFileSwitch("@" + path, commandLineSwitches1);
          if (commandLineSwitches1[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
            commandLineSwitches1.SetSwitchError("CannotAutoDisableAutoResponseFile", commandLineSwitches1.GetParameterlessSwitchCommandLineArg(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse));
          if (commandLineSwitches1.HaveAnySwitchesBeenSet())
            MSBuildApp.usingSwitchesFromAutoResponseFile = true;
          commandLineSwitches1.Append(commandLineSwitches);
        }
      }
      return commandLineSwitches1;
    }

    private static bool ProcessCommandLineSwitches(
      CommandLineSwitches commandLineSwitches,
      ref string projectFile,
      ref string[] targets,
      ref BuildPropertyGroup propertyBag,
      ref ILogger[] loggers,
      ref bool needToValidateProject,
      ref string schemaFile)
    {
      bool flag = false;
      if (!commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo])
        MSBuildApp.DisplayCopyrightMessage();
      if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
      {
        MSBuildApp.ShowHelpMessage();
      }
      else
      {
        commandLineSwitches.ThrowErrors();
        if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Version])
        {
          MSBuildApp.ShowVersion();
        }
        else
        {
          projectFile = MSBuildApp.ProcessProjectSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Project]);
          targets = MSBuildApp.ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
          propertyBag = MSBuildApp.ProcessPropertySwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Property]);
          LoggerVerbosity verbosity;
          loggers = MSBuildApp.ProcessLoggingSwitches(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Logger], commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity], commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger], commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters], out verbosity);
          if (MSBuildApp.usingSwitchesFromAutoResponseFile && LoggerVerbosity.Diagnostic == verbosity)
            Console.WriteLine(ResourceUtilities.FormatResourceString("PickedUpSwitchesFromAutoResponse", (object) "MSBuild.rsp"));
          needToValidateProject = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Validate);
          schemaFile = MSBuildApp.ProcessValidateSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Validate]);
          flag = true;
        }
      }
      ErrorUtilities.VerifyThrow(!flag || projectFile != null, "We should have a project file if we're going to build.");
      return flag;
    }

    private static string ProcessProjectSwitch(string[] parameters)
    {
      ErrorUtilities.VerifyThrow(parameters.Length <= 1, "It should not be possible to specify more than 1 project at a time.");
      string str;
      if (parameters.Length == 0)
      {
        string[] files1 = Directory.GetFiles(".", "*.*proj");
        string[] files2 = Directory.GetFiles(".", "*.sln");
        if (files1.Length == 1 && files2.Length == 1)
          InitializationException.VerifyThrow(string.Compare(Path.GetFileNameWithoutExtension(files2[0]), Path.GetFileNameWithoutExtension(files1[0]), StringComparison.OrdinalIgnoreCase) == 0, "AmbiguousProjectError");
        else if (files2.Length > 1 || files1.Length > 1)
          InitializationException.VerifyThrow(false, "AmbiguousProjectError");
        else if (files1.Length == 0 && files2.Length == 0)
          InitializationException.VerifyThrow(false, "MissingProjectError");
        str = files2.Length == 1 ? files2[0] : files1[0];
      }
      else
      {
        InitializationException.VerifyThrow(File.Exists(parameters[0]), "ProjectNotFoundError", parameters[0]);
        str = parameters[0];
      }
      return str;
    }

    private static string[] ProcessTargetSwitch(string[] parameters) => parameters;

    internal static BuildPropertyGroup ProcessPropertySwitch(string[] parameters)
    {
      BuildPropertyGroup buildPropertyGroup = new BuildPropertyGroup();
      foreach (string parameter in parameters)
      {
        string[] strArray = parameter.Split(MSBuildApp.propertyValueSeparator, 2);
        CommandLineSwitchException.VerifyThrow(strArray[0].Length > 0 && strArray.Length == 2, "InvalidPropertyError", parameter);
        try
        {
          buildPropertyGroup.SetProperty(strArray[0], strArray[1]);
        }
        catch (ArgumentException ex)
        {
          InitializationException.Throw("InvalidPropertyError", parameter, (Exception) ex, false);
        }
        catch (InvalidOperationException ex)
        {
          InitializationException.Throw(ex.Message, parameter);
        }
      }
      return buildPropertyGroup;
    }

    private static ILogger[] ProcessLoggingSwitches(
      string[] loggerSwitchParameters,
      string[] verbositySwitchParameters,
      bool noConsoleLogger,
      string[] consoleLoggerParameters,
      out LoggerVerbosity verbosity)
    {
      verbosity = MSBuildApp.ProcessVerbositySwitch(verbositySwitchParameters);
      ArrayList arrayList = MSBuildApp.ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
      if (!noConsoleLogger)
      {
        ConsoleLogger consoleLogger = new ConsoleLogger(verbosity);
        if (consoleLoggerParameters != null && consoleLoggerParameters.Length > 0)
          consoleLogger.Parameters = consoleLoggerParameters[consoleLoggerParameters.Length - 1];
        arrayList.Add((object) consoleLogger);
      }
      return (ILogger[]) arrayList.ToArray(typeof (ILogger));
    }

    private static LoggerVerbosity ProcessVerbositySwitch(string[] parameters)
    {
      LoggerVerbosity loggerVerbosity = LoggerVerbosity.Normal;
      if (parameters.Length > 0)
      {
        try
        {
          loggerVerbosity = (LoggerVerbosity) Enum.Parse(typeof (LoggerVerbosity), parameters[parameters.Length - 1], true);
        }
        catch (ArgumentException ex)
        {
          if (string.Compare(parameters[parameters.Length - 1], "q", StringComparison.OrdinalIgnoreCase) == 0)
            loggerVerbosity = LoggerVerbosity.Quiet;
          else if (string.Compare(parameters[parameters.Length - 1], "m", StringComparison.OrdinalIgnoreCase) == 0)
            loggerVerbosity = LoggerVerbosity.Minimal;
          else if (string.Compare(parameters[parameters.Length - 1], "n", StringComparison.OrdinalIgnoreCase) == 0)
            loggerVerbosity = LoggerVerbosity.Normal;
          else if (string.Compare(parameters[parameters.Length - 1], "d", StringComparison.OrdinalIgnoreCase) == 0)
            loggerVerbosity = LoggerVerbosity.Detailed;
          else if (string.Compare(parameters[parameters.Length - 1], "diag", StringComparison.OrdinalIgnoreCase) == 0)
            loggerVerbosity = LoggerVerbosity.Diagnostic;
          else
            CommandLineSwitchException.Throw("InvalidVerbosityError", parameters[parameters.Length - 1]);
        }
      }
      return loggerVerbosity;
    }

    private static ArrayList ProcessLoggerSwitch(
      string[] parameters,
      LoggerVerbosity verbosity)
    {
      ArrayList arrayList1 = new ArrayList();
      foreach (string parameter in parameters)
      {
        string str = QuotingUtilities.Unquote(parameter);
        int emptySplits;
        ArrayList arrayList2 = QuotingUtilities.SplitUnquoted(parameter, 2, true, false, out emptySplits, ';');
        ErrorUtilities.VerifyThrow(arrayList2.Count >= 1 && arrayList2.Count <= 2, "SplitUnquoted() must return at least one string, and no more than two.");
        CommandLineSwitchException.VerifyThrow(((string) arrayList2[0]).Length > 0, "InvalidLoggerError", str);
        ArrayList arrayList3 = QuotingUtilities.SplitUnquoted((string) arrayList2[0], 2, true, false, out emptySplits, ',');
        ErrorUtilities.VerifyThrow(arrayList3.Count >= 1 && arrayList3.Count <= 2, "SplitUnquoted() must return at least one string, and no more than two.");
        string loggerClassName;
        string path;
        if (arrayList3.Count == 2)
        {
          loggerClassName = QuotingUtilities.Unquote((string) arrayList3[0]);
          path = QuotingUtilities.Unquote((string) arrayList3[1]);
        }
        else
        {
          loggerClassName = string.Empty;
          path = QuotingUtilities.Unquote((string) arrayList3[0]);
        }
        CommandLineSwitchException.VerifyThrow(path.Length > 0, "InvalidLoggerError", str);
        string assemblyName = (string) null;
        string assemblyFile = (string) null;
        if (File.Exists(path))
          assemblyFile = path;
        else
          assemblyName = path;
        AssemblyLoadInfo loggerAssembly = new AssemblyLoadInfo(assemblyName, assemblyFile);
        ILogger logger = MSBuildApp.CreateLogger(loggerClassName, loggerAssembly, str);
        try
        {
          logger.Verbosity = verbosity;
          if (arrayList2.Count == 2)
            logger.Parameters = QuotingUtilities.Unquote((string) arrayList2[1]);
        }
        catch (LoggerException ex)
        {
          throw;
        }
        catch (Exception ex)
        {
          InitializationException.Throw("LoggerFatalError", str, ex, true);
        }
        arrayList1.Add((object) logger);
      }
      return arrayList1;
    }

    private static ILogger CreateLogger(
      string loggerClassName,
      AssemblyLoadInfo loggerAssembly,
      string loggerSwitchParameters)
    {
      ILogger logger = (ILogger) null;
      try
      {
        LoadedType loadedType = new TypeLoader(MSBuildApp.loggerClassFilter).Load(loggerClassName, loggerAssembly);
        InitializationException.VerifyThrow(loadedType != null, "LoggerNotFoundError", loggerSwitchParameters);
        logger = (ILogger) Activator.CreateInstance(loadedType.Type);
      }
      catch (IOException ex)
      {
        InitializationException.Throw("LoggerCreationError", loggerSwitchParameters, (Exception) ex, false);
      }
      catch (BadImageFormatException ex)
      {
        InitializationException.Throw("LoggerCreationError", loggerSwitchParameters, (Exception) ex, false);
      }
      catch (SecurityException ex)
      {
        InitializationException.Throw("LoggerCreationError", loggerSwitchParameters, (Exception) ex, false);
      }
      catch (ReflectionTypeLoadException ex)
      {
        InitializationException.Throw("LoggerCreationError", loggerSwitchParameters, (Exception) ex, false);
      }
      catch (TargetInvocationException ex)
      {
        Exception innerException = ex.InnerException;
        if (innerException is LoggerException)
          throw innerException;
        InitializationException.Throw("LoggerFatalError", loggerSwitchParameters, innerException, true);
      }
      catch (MemberAccessException ex)
      {
        InitializationException.Throw("LoggerCreationError", loggerSwitchParameters, (Exception) ex, false);
      }
      return logger;
    }

    private static bool IsLoggerClass(Type type, object unused) => type.IsClass && !type.IsAbstract && (object) type.GetInterface("ILogger") != null;

    private static string ProcessValidateSwitch(string[] parameters)
    {
      string str = (string) null;
      foreach (string parameter in parameters)
      {
        InitializationException.VerifyThrow(str == null, "MultipleSchemasError", parameter);
        InitializationException.VerifyThrow(File.Exists(parameter), "SchemaNotFoundError", parameter);
        str = Path.Combine(Directory.GetCurrentDirectory(), parameter);
      }
      return str;
    }

    private static void DisplayCopyrightMessage() => Console.WriteLine(ResourceUtilities.FormatResourceString("CopyrightMessage", (object) Engine.Version.ToString(), (object) Environment.Version.ToString()));

    private static void ShowHelpMessage() => Console.WriteLine(AssemblyResources.GetString("HelpMessage"));

    private static void ShowHelpPrompt() => Console.WriteLine(AssemblyResources.GetString("HelpPrompt"));

    private static void ShowVersion() => Console.Write(Engine.Version.ToString());

    public enum ExitType
    {
      Success,
      SwitchError,
      InitializationError,
      BuildError,
      LoggerAbort,
      LoggerFailure,
    }
  }
}
