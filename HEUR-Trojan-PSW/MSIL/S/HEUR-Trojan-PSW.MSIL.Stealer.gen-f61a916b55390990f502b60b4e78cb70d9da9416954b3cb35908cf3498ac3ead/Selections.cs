// Decompiled with JetBrains decompiler
// Type: SimpleVideoCutter.Selections
// Assembly: SimpleVideoCutter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EC3F1699-ABA1-43FB-A799-9F64138760E7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f61a916b55390990f502b60b4e78cb70d9da9416954b3cb35908cf3498ac3ead.exe

using System;
using System.Collections.Generic;
using System.Linq;

namespace SimpleVideoCutter
{
  public class Selections
  {
    private List<Selection> selections = new List<Selection>();

    public event EventHandler<EventArgs> SelectionsChanged;

    public int Count => this.selections.Count;

    public Selection this[int i] => this.selections[i];

    public void AddSelection(long start, long end)
    {
      if (!this.CanAddSelection(start, end))
        return;
      this.selections.Add(new Selection()
      {
        Start = start,
        End = end
      });
      Selection[] array = this.selections.OrderBy<Selection, long>((Func<Selection, long>) (s => s.Start)).ToArray<Selection>();
      this.selections.Clear();
      this.selections.AddRange((IEnumerable<Selection>) array);
      this.OnSelectionsChanged();
    }

    public bool Empty => this.selections.Count == 0;

    public long? OverallStart => this.selections.FirstOrDefault<Selection>()?.Start;

    public long? OverallEnd => this.selections.LastOrDefault<Selection>()?.End;

    public long OverallDuration
    {
      get
      {
        long? overallEnd = this.OverallEnd;
        if (overallEnd.HasValue)
          return overallEnd.GetValueOrDefault();
        long? overallStart = this.OverallStart;
        return (overallStart.HasValue ? new long?(-overallStart.GetValueOrDefault()) : new long?()) ?? 0L;
      }
    }

    public List<Selection> AllSelections => this.selections;

    public void Clear()
    {
      this.selections.Clear();
      this.OnSelectionsChanged();
    }

    public void ReplaceAll(IList<Selection> newSelections)
    {
      this.selections.Clear();
      this.selections.AddRange((IEnumerable<Selection>) newSelections);
      this.OnSelectionsChanged();
    }

    private void OnSelectionsChanged()
    {
      EventHandler<EventArgs> selectionsChanged = this.SelectionsChanged;
      if (selectionsChanged == null)
        return;
      selectionsChanged((object) this, new EventArgs());
    }

    public int? IsInSelection(long position)
    {
      int index = this.selections.FindIndex((Predicate<Selection>) (s => s.Includes(position)));
      return index == -1 ? new int?() : new int?(index);
    }

    public void DeleteSelection(int index)
    {
      this.selections.RemoveAt(index);
      this.OnSelectionsChanged();
    }

    public long? FindNextValidPosition(long position) => this.IsInSelection(position).HasValue ? new long?(position) : this.selections.FirstOrDefault<Selection>((Func<Selection, bool>) (s => s.Start > position))?.Start;

    public bool SetSelectionStart(int index, long value)
    {
      Selection selection1 = this.selections[index];
      Selection selection2 = index > 0 ? this.selections[index - 1] : (Selection) null;
      if (selection2 != null && selection2.End > value)
      {
        this.selections[index].Start = selection2.End + 1L;
        return false;
      }
      this.selections[index].Start = value > this.selections[index].End ? this.selections[index].End : value;
      return true;
    }

    public bool SetSelectionEnd(int index, long value)
    {
      Selection selection1 = this.selections[index];
      Selection selection2 = index < this.selections.Count - 1 ? this.selections[index + 1] : (Selection) null;
      if (selection2 != null && selection2.Start < value)
      {
        this.selections[index].End = selection2.Start - 1L;
        return false;
      }
      this.selections[index].End = value < this.selections[index].Start ? this.selections[index].Start : value;
      return true;
    }

    public bool CanStartSelectionAtFrame(long frame) => !this.selections.Any<Selection>((Func<Selection, bool>) (s => s.Includes(frame)));

    public bool CanAddSelection(long start, long end)
    {
      if (end <= start)
        return false;
      Selection newSelection = new Selection()
      {
        Start = start,
        End = end
      };
      return !this.selections.Any<Selection>((Func<Selection, bool>) (s => s.Overlaps(newSelection)));
    }
  }
}
