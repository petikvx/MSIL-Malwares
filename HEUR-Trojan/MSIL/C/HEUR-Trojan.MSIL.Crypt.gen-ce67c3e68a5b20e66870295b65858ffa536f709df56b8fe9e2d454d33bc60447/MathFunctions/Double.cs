// Decompiled with JetBrains decompiler
// Type: GenericMath.MathFunctions.Double
// Assembly: NDp6, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 1E52A124-4038-410B-8375-93D4A037FA1F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.Crypt.gen-ce67c3e68a5b20e66870295b65858ffa536f709df56b8fe9e2d454d33bc60447.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;

namespace GenericMath.MathFunctions
{
  [StandardModule]
  [HideModuleName]
  internal sealed class Double
  {
    private static double UnitStep(double value) => value <= 0.0 ? 0.0 : 1.0;

    private static double Asinh(double value) => Math.Log(value + Math.Sqrt(value * value + 1.0));

    private static double Acosh(double value) => Math.Log(value + Math.Sqrt(value * value - 1.0));

    private static double Atanh(double value) => 0.5 * Math.Log((1.0 + value) / (1.0 - value));

    private static double Acosech(double value)
    {
      value = 1.0 / value;
      return Math.Log(value + Math.Sqrt(value * value + 1.0));
    }

    private static double Asech(double value)
    {
      value = 1.0 / value;
      return Math.Log(value + Math.Sqrt(value * value - 1.0));
    }

    private static double Acoth(double value) => 0.5 * Math.Log((value + 1.0) / (value - 1.0));

    internal static void Initialize()
    {
      Math<double>.Sqrt = new Func<double, double>(Math.Sqrt);
      Func<double, double> func1;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D0 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func1 = Double._Closure\u0024__.\u0024I7\u002D0;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D0 = func1 = (Func<double, double>) (V => Math.Pow(V, 1.0 / 3.0));
      }
      Math<double>.Cubrt = func1;
      Math<double>.Abs = new Func<double, double>(Math.Abs);
      Func<double, double> func2;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024IR7\u002D1 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func2 = Double._Closure\u0024__.\u0024IR7\u002D1;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024IR7\u002D1 = func2 = (Func<double, double>) (a0 => (double) Math.Sign(a0));
      }
      Math<double>.Sign = func2;
      Math<double>.Ceiling = new Func<double, double>(Math.Ceiling);
      Math<double>.Floor = new Func<double, double>(Math.Floor);
      Math<double>.Truncate = new Func<double, double>(Math.Truncate);
      Math<double>.UnitStep = new Func<double, double>(Double.UnitStep);
      Math<double>.Sin = new Func<double, double>(Math.Sin);
      Math<double>.Cos = new Func<double, double>(Math.Cos);
      Math<double>.Tan = new Func<double, double>(Math.Tan);
      Func<double, double> func3;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D1 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func3 = Double._Closure\u0024__.\u0024I7\u002D1;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D1 = func3 = (Func<double, double>) (V => 1.0 / Math.Sin(V));
      }
      Math<double>.Cosec = func3;
      Func<double, double> func4;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D2 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func4 = Double._Closure\u0024__.\u0024I7\u002D2;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D2 = func4 = (Func<double, double>) (V => 1.0 / Math.Cos(V));
      }
      Math<double>.Sec = func4;
      Func<double, double> func5;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D3 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func5 = Double._Closure\u0024__.\u0024I7\u002D3;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D3 = func5 = (Func<double, double>) (V => 1.0 / Math.Tan(V));
      }
      Math<double>.Cot = func5;
      Math<double>.Sinh = new Func<double, double>(Math.Sinh);
      Math<double>.Cosh = new Func<double, double>(Math.Cosh);
      Math<double>.Tanh = new Func<double, double>(Math.Tanh);
      Func<double, double> func6;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D4 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func6 = Double._Closure\u0024__.\u0024I7\u002D4;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D4 = func6 = (Func<double, double>) (V => 1.0 / Math.Sinh(V));
      }
      Math<double>.Cosech = func6;
      Func<double, double> func7;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D5 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func7 = Double._Closure\u0024__.\u0024I7\u002D5;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D5 = func7 = (Func<double, double>) (V => 1.0 / Math.Cosh(V));
      }
      Math<double>.Sech = func7;
      Func<double, double> func8;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D6 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func8 = Double._Closure\u0024__.\u0024I7\u002D6;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D6 = func8 = (Func<double, double>) (V => 1.0 / Math.Tanh(V));
      }
      Math<double>.Coth = func8;
      Math<double>.Asin = new Func<double, double>(Math.Asin);
      Math<double>.Acos = new Func<double, double>(Math.Acos);
      Math<double>.Atan = new Func<double, double>(Math.Atan);
      Func<double, double> func9;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D7 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func9 = Double._Closure\u0024__.\u0024I7\u002D7;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D7 = func9 = (Func<double, double>) (V => Math.Asin(1.0 / V));
      }
      Math<double>.Acosec = func9;
      Func<double, double> func10;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D8 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func10 = Double._Closure\u0024__.\u0024I7\u002D8;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D8 = func10 = (Func<double, double>) (V => Math.Acos(1.0 / V));
      }
      Math<double>.Asec = func10;
      Func<double, double> func11;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D9 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func11 = Double._Closure\u0024__.\u0024I7\u002D9;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D9 = func11 = (Func<double, double>) (V => Math.Atan(1.0 / V));
      }
      Math<double>.Acot = func11;
      Math<double>.Asinh = new Func<double, double>(Double.Asinh);
      Math<double>.Acosh = new Func<double, double>(Double.Acosh);
      Math<double>.Atanh = new Func<double, double>(Double.Atanh);
      Math<double>.Acosech = new Func<double, double>(Double.Acosech);
      Math<double>.Asech = new Func<double, double>(Double.Asech);
      Math<double>.Acoth = new Func<double, double>(Double.Acoth);
      Math<double>.Exp = new Func<double, double>(Math.Exp);
      Func<double, double> func12;
      // ISSUE: reference to a compiler-generated field
      if (Double._Closure\u0024__.\u0024I7\u002D10 != null)
      {
        // ISSUE: reference to a compiler-generated field
        func12 = Double._Closure\u0024__.\u0024I7\u002D10;
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        Double._Closure\u0024__.\u0024I7\u002D10 = func12 = (Func<double, double>) (V => Math.Pow(10.0, V));
      }
      Math<double>.Exp10 = func12;
      Math<double>.Log = new Func<double, double>(Math.Log);
      Math<double>.Log10 = new Func<double, double>(Math.Log10);
    }
  }
}
