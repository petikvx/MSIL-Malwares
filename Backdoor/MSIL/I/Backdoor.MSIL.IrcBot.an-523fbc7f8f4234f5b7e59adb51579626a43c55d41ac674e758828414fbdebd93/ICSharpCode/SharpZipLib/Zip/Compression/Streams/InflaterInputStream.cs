// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.Streams.InflaterInputStream
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using System;
using System.IO;
using System.Security.Cryptography;

namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
{
  public class InflaterInputStream : Stream
  {
    protected Inflater inf;
    protected InflaterInputBuffer inputBuffer;
    protected Stream baseInputStream;
    protected long csize;
    private bool \uE001;
    private bool \uE000 = true;

    public InflaterInputStream(Stream baseInputStream)
      : this(baseInputStream, new Inflater(), 4096)
    {
    }

    public InflaterInputStream(Stream baseInputStream, Inflater inf)
      : this(baseInputStream, inf, 4096)
    {
    }

    public InflaterInputStream(Stream baseInputStream, Inflater inflater, int bufferSize)
    {
      if (baseInputStream == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uF5BB\uF5B8\uF5AA\uF5BC\uF590\uF5B7\uF5A9\uF5AC\uF5AD\uF58A\uF5AD\uF5AB\uF5BC\uF5B8\uF5B4", 62937));
      if (inflater == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uF68F\uF688\uF680\uF68A\uF687\uF692\uF683\uF694", 63206));
      if (bufferSize <= 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uEDCB\uEDDC\uEDCF\uEDCF\uEDCC\uEDDB\uEDFA\uEDC0\uEDD3\uEDCC", 60841));
      this.baseInputStream = baseInputStream;
      this.inf = inflater;
      this.inputBuffer = new InflaterInputBuffer(baseInputStream, bufferSize);
    }

    public bool IsStreamOwner
    {
      get => this.\uE000;
      set => this.\uE000 = value;
    }

    public long Skip(long count)
    {
      if (count <= 0L)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uED5B\uED57\uED4D\uED56\uED4C", 60728));
      if (this.baseInputStream.CanSeek)
      {
        this.baseInputStream.Seek(count, SeekOrigin.Current);
        return count;
      }
      int count1 = 2048;
      if (count < (long) count1)
        count1 = (int) count;
      byte[] buffer = new byte[count1];
      int num1 = 1;
      long num2;
      for (num2 = count; num2 > 0L && num1 > 0; num2 -= (long) num1)
      {
        if (num2 < (long) count1)
          count1 = (int) num2;
        num1 = this.baseInputStream.Read(buffer, 0, count1);
      }
      return count - num2;
    }

    protected void StopDecrypting() => this.inputBuffer.CryptoTransform = (ICryptoTransform) null;

    public virtual int Available => !this.inf.IsFinished ? 1 : 0;

    protected void Fill()
    {
      this.inputBuffer.Fill();
      this.inputBuffer.SetInflaterInput(this.inf);
    }

    public override bool CanRead => this.baseInputStream.CanRead;

    public override bool CanSeek => false;

    public override bool CanWrite => false;

    public override long Length => (long) this.inputBuffer.RawLength;

    public override long Position
    {
      get => this.baseInputStream.Position;
      set => throw new NotSupportedException(\uE01B.\uE000("\uF2DE\uF2F9\uF2F1\uF2FB\uF2F6\uF2E3\uF2F2\uF2E5\uF2DE\uF2F9\uF2E7\uF2E2\uF2E3\uF2C4\uF2E3\uF2E5\uF2F2\uF2F6\uF2FA\uF2B7\uF2C7\uF2F8\uF2E4\uF2FE\uF2E3\uF2FE\uF2F8\uF2F9\uF2B7\uF2F9\uF2F8\uF2E3\uF2B7\uF2E4\uF2E2\uF2E7\uF2E7\uF2F8\uF2E5\uF2E3\uF2F2\uF2F3", 62103));
    }

    public override void Flush() => this.baseInputStream.Flush();

    public override long Seek(long offset, SeekOrigin origin) => throw new NotSupportedException(\uE01B.\uE000("\uF788\uF7BE\uF7BE\uF7B0\uF7FB\uF7B5\uF7B4\uF7AF\uF7FB\uF7A8\uF7AE\uF7AB\uF7AB\uF7B4\uF7A9\uF7AF\uF7BE\uF7BF", 63451));

    public override void SetLength(long value) => throw new NotSupportedException(\uE01B.\uE000("\uF1A6\uF181\uF189\uF183\uF18E\uF19B\uF18A\uF19D\uF1A6\uF181\uF19F\uF19A\uF19B\uF1BC\uF19B\uF19D\uF18A\uF18E\uF182\uF1CF\uF1BC\uF18A\uF19B\uF1A3\uF18A\uF181\uF188\uF19B\uF187\uF1CF\uF181\uF180\uF19B\uF1CF\uF19C\uF19A\uF19F\uF19F\uF180\uF19D\uF19B\uF18A\uF18B", 61935));

    public override void Write(byte[] buffer, int offset, int count) => throw new NotSupportedException(\uE01B.\uE000("\uE3E8\uE3CF\uE3C7\uE3CD\uE3C0\uE3D5\uE3C4\uE3D3\uE3E8\uE3CF\uE3D1\uE3D4\uE3D5\uE3F2\uE3D5\uE3D3\uE3C4\uE3C0\uE3CC\uE381\uE3F6\uE3D3\uE3C8\uE3D5\uE3C4\uE381\uE3CF\uE3CE\uE3D5\uE381\uE3D2\uE3D4\uE3D1\uE3D1\uE3CE\uE3D3\uE3D5\uE3C4\uE3C5", 58273));

    public override void WriteByte(byte value) => throw new NotSupportedException(\uE01B.\uE000("\uE5D6\uE5F1\uE5F9\uE5F3\uE5FE\uE5EB\uE5FA\uE5ED\uE5D6\uE5F1\uE5EF\uE5EA\uE5EB\uE5CC\uE5EB\uE5ED\uE5FA\uE5FE\uE5F2\uE5BF\uE5C8\uE5ED\uE5F6\uE5EB\uE5FA\uE5DD\uE5E6\uE5EB\uE5FA\uE5BF\uE5F1\uE5F0\uE5EB\uE5BF\uE5EC\uE5EA\uE5EF\uE5EF\uE5F0\uE5ED\uE5EB\uE5FA\uE5FB", 58783));

    public override IAsyncResult BeginWrite(
      byte[] buffer,
      int offset,
      int count,
      AsyncCallback callback,
      object state)
    {
      throw new NotSupportedException(\uE01B.\uE000("\uEA45\uEA62\uEA6A\uEA60\uEA6D\uEA78\uEA69\uEA7E\uEA45\uEA62\uEA7C\uEA79\uEA78\uEA5F\uEA78\uEA7E\uEA69\uEA6D\uEA61\uEA2C\uEA4E\uEA69\uEA6B\uEA65\uEA62\uEA5B\uEA7E\uEA65\uEA78\uEA69\uEA2C\uEA62\uEA63\uEA78\uEA2C\uEA7F\uEA79\uEA7C\uEA7C\uEA63\uEA7E\uEA78\uEA69\uEA68", 59916));
    }

    public override void Close()
    {
      if (this.\uE001)
        return;
      this.\uE001 = true;
      if (!this.\uE000)
        return;
      this.baseInputStream.Close();
    }

    public override int Read(byte[] buffer, int offset, int count)
    {
      if (this.inf.IsNeedingDictionary)
        throw new SharpZipBaseException(\uE01B.\uE000("\uF2E9\uF2C2\uF2C2\uF2C3\uF287\uF2C6\uF287\uF2C3\uF2CE\uF2C4\uF2D3\uF2CE\uF2C8\uF2C9\uF2C6\uF2D5\uF2DE", 62119));
      int count1 = count;
      int num;
      do
      {
        num = this.inf.Inflate(buffer, offset, count1);
        offset += num;
        count1 -= num;
        if (count1 != 0 && !this.inf.IsFinished)
        {
          if (this.inf.IsNeedingInput)
            this.Fill();
        }
        else
          goto label_8;
      }
      while (num != 0);
      throw new ZipException(\uE01B.\uE000("\uEED6\uEEFD\uEEFC\uEEE6\uEEB2\uEEF9\uEEFC\uEEFD\uEEE5\uEEB2\uEEE5\uEEFA\uEEF3\uEEE6\uEEB2\uEEE6\uEEFD\uEEB2\uEEF6\uEEFD", 61074));
label_8:
      return count - count1;
    }
  }
}
