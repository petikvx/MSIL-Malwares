// Decompiled with JetBrains decompiler
// Type: SmartAssembly.StringsEncoding.Strings
// Assembly: chaddad, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6BDE87D8-B0AC-468F-B40C-8A894553F651
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.07-msil\HEUR-Trojan-Ransom.MSIL.Thanos.gen-66ed5384220ff3091903e14a54849f824fdd13ac70dc4e0127eb59c1de801fc2.exe

using SmartAssembly.Zip;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace SmartAssembly.StringsEncoding
{
  public sealed class Strings
  {
    private static readonly string MustUseCache = "1";
    private static readonly string OffsetValue = "101";
    private static readonly byte[] bytes = (byte[]) null;
    private static readonly Dictionary<int, string> hashtable;
    private static readonly object hashtableLock = new object();
    private static readonly bool cacheStrings = false;
    private static readonly int offset = 0;

    public static string Get([In] int obj0)
    {
      obj0 ^= 107396847;
      obj0 -= Strings.offset;
      return !Strings.cacheStrings ? Strings.GetFromResource(obj0) : Strings.GetCachedOrResource(obj0);
    }

    public static string GetCachedOrResource([In] int obj0)
    {
      lock (Strings.hashtableLock)
      {
        string cachedOrResource;
        Strings.hashtable.TryGetValue(obj0, out cachedOrResource);
        if (cachedOrResource != null)
          return cachedOrResource;
      }
      return Strings.GetFromResource(obj0);
    }

    public static string GetFromResource([In] int obj0)
    {
      int num1 = obj0;
      byte[] bytes1 = Strings.bytes;
      int index1 = num1;
      int index2 = index1 + 1;
      int num2 = (int) bytes1[index1];
      int count;
      if ((num2 & 128) == 0)
      {
        count = num2;
        if (count == 0)
          return string.Empty;
      }
      else if ((num2 & 64) == 0)
      {
        count = ((num2 & 63) << 8) + (int) Strings.bytes[index2++];
      }
      else
      {
        int num3 = (num2 & 31) << 24;
        byte[] bytes2 = Strings.bytes;
        int index3 = index2;
        int num4 = index3 + 1;
        int num5 = (int) bytes2[index3] << 16;
        int num6 = num3 + num5;
        byte[] bytes3 = Strings.bytes;
        int index4 = num4;
        int num7 = index4 + 1;
        int num8 = (int) bytes3[index4] << 8;
        int num9 = num6 + num8;
        byte[] bytes4 = Strings.bytes;
        int index5 = num7;
        index2 = index5 + 1;
        int num10 = (int) bytes4[index5];
        count = num9 + num10;
      }
      try
      {
        byte[] bytes5 = Convert.FromBase64String(Encoding.UTF8.GetString(Strings.bytes, index2, count));
        string fromResource = string.Intern(Encoding.UTF8.GetString(bytes5, 0, bytes5.Length));
        if (Strings.cacheStrings)
          Strings.CacheString(obj0, fromResource);
        return fromResource;
      }
      catch
      {
        return (string) null;
      }
    }

    public static void CacheString([In] int obj0, [In] string obj1)
    {
      try
      {
        lock (Strings.hashtableLock)
          Strings.hashtable.Add(obj0, obj1);
      }
      catch
      {
      }
    }

    static Strings()
    {
      if (Strings.MustUseCache == "1")
      {
        Strings.cacheStrings = true;
        Strings.hashtable = new Dictionary<int, string>();
      }
      Strings.offset = Convert.ToInt32(Strings.OffsetValue);
      using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("{4b195894-0f06-4fdd-afb4-b17fb9246a59}"))
      {
        int int32 = Convert.ToInt32(manifestResourceStream.Length);
        byte[] buffer = new byte[int32];
        manifestResourceStream.Read(buffer, 0, int32);
        Strings.bytes = SimpleZip.Unzip(buffer);
      }
    }
  }
}
