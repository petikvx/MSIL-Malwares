// Decompiled with JetBrains decompiler
// Type: Procurios.Public.JSON
// Assembly: AnsiCharMarsha, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 45449883-CB33-464D-BFFF-85C1D8F95247
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-PSW.Win32.Stealer.aipl-731355759034e0ae5cff6011792f40d5154dccd99fac792da878777bbc532ce2.exe

using System;
using System.Collections;
using System.Globalization;
using System.Text;

namespace Procurios.Public
{
  public class JSON
  {
    public const int TOKEN_NONE = 0;
    public const int TOKEN_CURLY_OPEN = 1;
    public const int TOKEN_CURLY_CLOSE = 2;
    public const int TOKEN_SQUARED_OPEN = 3;
    public const int TOKEN_SQUARED_CLOSE = 4;
    public const int TOKEN_COLON = 5;
    public const int TOKEN_COMMA = 6;
    public const int TOKEN_STRING = 7;
    public const int TOKEN_NUMBER = 8;
    public const int TOKEN_TRUE = 9;
    public const int TOKEN_FALSE = 10;
    public const int TOKEN_NULL = 11;
    private const int BUILDER_CAPACITY = 2000;

    public static object JsonDecode(string json)
    {
      bool success = true;
      return JSON.JsonDecode(json, ref success);
    }

    public static object JsonDecode(string json, ref bool success)
    {
      success = true;
      if (json == null)
        return (object) null;
      char[] charArray = json.ToCharArray();
      int num = 0;
      ref int local1 = ref num;
      ref bool local2 = ref success;
      return JSON.ParseValue(charArray, ref local1, ref local2);
    }

    public static string JsonEncode(object json)
    {
      StringBuilder builder = new StringBuilder(2000);
      return !JSON.SerializeValue(json, builder) ? (string) null : builder.ToString();
    }

    protected static Hashtable ParseObject(char[] json, ref int index, ref bool success)
    {
      Hashtable hashtable = new Hashtable();
      JSON.NextToken(json, ref index);
      bool flag = false;
      while (!flag)
      {
        switch (JSON.LookAhead(json, index))
        {
          case 0:
            success = false;
            return (Hashtable) null;
          case 2:
            JSON.NextToken(json, ref index);
            return hashtable;
          case 6:
            JSON.NextToken(json, ref index);
            continue;
          default:
            string key = JSON.ParseString(json, ref index, ref success);
            if (!success)
            {
              success = false;
              return (Hashtable) null;
            }
            if (JSON.NextToken(json, ref index) != 5)
            {
              success = false;
              return (Hashtable) null;
            }
            object obj = JSON.ParseValue(json, ref index, ref success);
            if (!success)
            {
              success = false;
              return (Hashtable) null;
            }
            hashtable[(object) key] = obj;
            continue;
        }
      }
      return hashtable;
    }

    protected static ArrayList ParseArray(char[] json, ref int index, ref bool success)
    {
      ArrayList array = new ArrayList();
      JSON.NextToken(json, ref index);
      bool flag = false;
      while (!flag)
      {
        switch (JSON.LookAhead(json, index))
        {
          case 0:
            success = false;
            return (ArrayList) null;
          case 4:
            JSON.NextToken(json, ref index);
            goto label_9;
          case 6:
            JSON.NextToken(json, ref index);
            continue;
          default:
            object obj = JSON.ParseValue(json, ref index, ref success);
            if (!success)
              return (ArrayList) null;
            array.Add(obj);
            continue;
        }
      }
label_9:
      return array;
    }

    protected static object ParseValue(char[] json, ref int index, ref bool success)
    {
      switch (JSON.LookAhead(json, index))
      {
        case 1:
          return (object) JSON.ParseObject(json, ref index, ref success);
        case 3:
          return (object) JSON.ParseArray(json, ref index, ref success);
        case 7:
          return (object) JSON.ParseString(json, ref index, ref success);
        case 8:
          return (object) JSON.ParseNumber(json, ref index);
        case 9:
          JSON.NextToken(json, ref index);
          return (object) bool.Parse("TRUE");
        case 10:
          JSON.NextToken(json, ref index);
          return (object) bool.Parse("FALSE");
        case 11:
          JSON.NextToken(json, ref index);
          return (object) null;
        default:
          success = false;
          return (object) null;
      }
    }

    protected static string ParseString(char[] json, ref int index, ref bool success)
    {
      StringBuilder stringBuilder = new StringBuilder(2000);
      JSON.EatWhitespace(json, ref index);
      char ch1 = json[index++];
      bool flag = false;
      while (!flag && index != json.Length)
      {
        char ch2 = json[index++];
        switch (ch2)
        {
          case '"':
            flag = true;
            goto label_17;
          case '\\':
            if (index != json.Length)
            {
              switch (json[index++])
              {
                case '"':
                  stringBuilder.Append('"');
                  continue;
                case '/':
                  stringBuilder.Append('/');
                  continue;
                case '\\':
                  stringBuilder.Append('\\');
                  continue;
                case 'b':
                  stringBuilder.Append('\b');
                  continue;
                case 'f':
                  stringBuilder.Append('\f');
                  continue;
                case 'n':
                  stringBuilder.Append('\n');
                  continue;
                case 'r':
                  stringBuilder.Append('\r');
                  continue;
                case 't':
                  stringBuilder.Append('\t');
                  continue;
                case 'u':
                  if (json.Length - index >= 4)
                  {
                    char[] destinationArray = new char[4];
                    Array.Copy((Array) json, index, (Array) destinationArray, 0, 4);
                    uint utf32 = uint.Parse(new string(destinationArray), NumberStyles.HexNumber);
                    stringBuilder.Append(char.ConvertFromUtf32((int) utf32));
                    index += 4;
                    continue;
                  }
                  goto label_17;
                default:
                  continue;
              }
            }
            else
              goto label_17;
          default:
            stringBuilder.Append(ch2);
            continue;
        }
      }
label_17:
      if (flag)
        return stringBuilder.ToString();
      success = false;
      return (string) null;
    }

    protected static double ParseNumber(char[] json, ref int index)
    {
      JSON.EatWhitespace(json, ref index);
      int lastIndexOfNumber = JSON.GetLastIndexOfNumber(json, index);
      int length = lastIndexOfNumber - index + 1;
      char[] destinationArray = new char[length];
      Array.Copy((Array) json, index, (Array) destinationArray, 0, length);
      index = lastIndexOfNumber + 1;
      return double.Parse(new string(destinationArray), (IFormatProvider) CultureInfo.InvariantCulture);
    }

    protected static int GetLastIndexOfNumber(char[] json, int index)
    {
      int index1 = index;
      while (index1 < json.Length && "0123456789+-.eE".IndexOf(json[index1]) != -1)
        ++index1;
      return index1 - 1;
    }

    protected static void EatWhitespace(char[] json, ref int index)
    {
      while (index < json.Length && " \t\n\r".IndexOf(json[index]) != -1)
        ++index;
    }

    protected static int LookAhead(char[] json, int index)
    {
      int index1 = index;
      return JSON.NextToken(json, ref index1);
    }

    protected static int NextToken(char[] json, ref int index)
    {
      JSON.EatWhitespace(json, ref index);
      if (index == json.Length)
        return 0;
      char ch = json[index];
      ++index;
      switch (ch)
      {
        case '"':
          return 7;
        case ',':
          return 6;
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          return 8;
        case ':':
          return 5;
        case '[':
          return 3;
        case ']':
          return 4;
        case '{':
          return 1;
        case '}':
          return 2;
        default:
          --index;
          int num = json.Length - index;
          if (num >= 5 && json[index] == 'f' && json[index + 1] == 'a' && json[index + 2] == 'l' && json[index + 3] == 's' && json[index + 4] == 'e')
          {
            index += 5;
            return 10;
          }
          if (num >= 4 && json[index] == 't' && json[index + 1] == 'r' && json[index + 2] == 'u' && json[index + 3] == 'e')
          {
            index += 4;
            return 9;
          }
          if (num < 4 || json[index] != 'n' || json[index + 1] != 'u' || json[index + 2] != 'l' || json[index + 3] != 'l')
            return 0;
          index += 4;
          return 11;
      }
    }

    protected static bool SerializeObjectOrArray(object objectOrArray, StringBuilder builder)
    {
      switch (objectOrArray)
      {
        case Hashtable _:
          return JSON.SerializeObject((Hashtable) objectOrArray, builder);
        case ArrayList _:
          return JSON.SerializeArray((ArrayList) objectOrArray, builder);
        default:
          return false;
      }
    }

    protected static bool SerializeObject(Hashtable anObject, StringBuilder builder)
    {
      builder.Append("{");
      IDictionaryEnumerator enumerator = anObject.GetEnumerator();
      bool flag = true;
      while (enumerator.MoveNext())
      {
        string aString = enumerator.Key.ToString();
        object obj = enumerator.Value;
        if (!flag)
          builder.Append(", ");
        JSON.SerializeString(aString, builder);
        builder.Append(":");
        StringBuilder builder1 = builder;
        if (!JSON.SerializeValue(obj, builder1))
          return false;
        flag = false;
      }
      builder.Append("}");
      return true;
    }

    protected static bool SerializeArray(ArrayList anArray, StringBuilder builder)
    {
      builder.Append("[");
      bool flag = true;
      for (int index = 0; index < anArray.Count; ++index)
      {
        object an = anArray[index];
        if (!flag)
          builder.Append(", ");
        StringBuilder builder1 = builder;
        if (!JSON.SerializeValue(an, builder1))
          return false;
        flag = false;
      }
      builder.Append("]");
      return true;
    }

    protected static bool SerializeValue(object value, StringBuilder builder)
    {
      switch (value)
      {
        case string _:
          JSON.SerializeString((string) value, builder);
          break;
        case Hashtable _:
          JSON.SerializeObject((Hashtable) value, builder);
          break;
        case ArrayList _:
          JSON.SerializeArray((ArrayList) value, builder);
          break;
        default:
          if (JSON.IsNumeric(value))
          {
            JSON.SerializeNumber(Convert.ToDouble(value), builder);
            break;
          }
          switch (value)
          {
            case bool flag1 when flag1:
              builder.Append("true");
              break;
            case bool flag2 when !flag2:
              builder.Append("false");
              break;
            case null:
              builder.Append("null");
              break;
            default:
              return false;
          }
          break;
      }
      return true;
    }

    protected static void SerializeString(string aString, StringBuilder builder)
    {
      builder.Append("\"");
      foreach (char ch in aString.ToCharArray())
      {
        switch (ch)
        {
          case '\b':
            builder.Append("\\b");
            break;
          case '\t':
            builder.Append("\\t");
            break;
          case '\n':
            builder.Append("\\n");
            break;
          case '\f':
            builder.Append("\\f");
            break;
          case '\r':
            builder.Append("\\r");
            break;
          case '"':
            builder.Append("\\\"");
            break;
          case '\\':
            builder.Append("\\\\");
            break;
          default:
            int int32 = Convert.ToInt32(ch);
            if (int32 >= 32 && int32 <= 126)
            {
              builder.Append(ch);
              break;
            }
            builder.Append("\\u" + Convert.ToString(int32, 16).PadLeft(4, '0'));
            break;
        }
      }
      builder.Append("\"");
    }

    protected static void SerializeNumber(double number, StringBuilder builder) => builder.Append(Convert.ToString(number, (IFormatProvider) CultureInfo.InvariantCulture));

    protected static bool IsNumeric(object o) => o != null && double.TryParse(o.ToString(), out double _);
  }
}
