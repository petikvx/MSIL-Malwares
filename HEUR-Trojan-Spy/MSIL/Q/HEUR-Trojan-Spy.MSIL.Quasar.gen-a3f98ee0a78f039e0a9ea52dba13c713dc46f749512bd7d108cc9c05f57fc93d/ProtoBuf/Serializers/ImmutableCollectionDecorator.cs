// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Serializers.ImmutableCollectionDecorator
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using ProtoBuf.Meta;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace ProtoBuf.Serializers
{
  internal sealed class ImmutableCollectionDecorator : ListDecorator
  {
    private readonly MethodInfo builderFactory;
    private readonly MethodInfo add;
    private readonly MethodInfo addRange;
    private readonly MethodInfo finish;

    protected override bool RequireAdd => false;

    private static Type ResolveIReadOnlyCollection(Type declaredType, Type t)
    {
      foreach (Type type in declaredType.GetInterfaces())
      {
        if (type.IsGenericType && type.Name.StartsWith("IReadOnlyCollection`"))
        {
          if ((object) t != null)
          {
            Type[] genericArguments = type.GetGenericArguments();
            if (genericArguments.Length != 1 && (object) genericArguments[0] != (object) t)
              continue;
          }
          return type;
        }
      }
      return (Type) null;
    }

    internal static bool IdentifyImmutable(
      TypeModel model,
      Type declaredType,
      out MethodInfo builderFactory,
      out MethodInfo add,
      out MethodInfo addRange,
      out MethodInfo finish)
    {
      builderFactory = add = addRange = finish = (MethodInfo) null;
      if (model == null || (object) declaredType == null)
        return false;
      Type type1 = declaredType;
      if (!type1.IsGenericType)
        return false;
      Type[] genericArguments = type1.GetGenericArguments();
      Type[] types;
      switch (genericArguments.Length)
      {
        case 1:
          types = genericArguments;
          break;
        case 2:
          Type type2 = model.MapType(typeof (KeyValuePair<,>));
          if ((object) type2 == null)
            return false;
          types = new Type[1]
          {
            type2.MakeGenericType(genericArguments)
          };
          break;
        default:
          return false;
      }
      if ((object) ImmutableCollectionDecorator.ResolveIReadOnlyCollection(declaredType, (Type) null) == null)
        return false;
      string name = declaredType.Name;
      int length = name.IndexOf('`');
      if (length <= 0)
        return false;
      string str = type1.IsInterface ? name.Substring(1, length - 1) : name.Substring(0, length);
      Type type3 = model.GetType(declaredType.Namespace + "." + str, type1.Assembly);
      if ((object) type3 == null && str == "ImmutableSet")
        type3 = model.GetType(declaredType.Namespace + ".ImmutableHashSet", type1.Assembly);
      if ((object) type3 == null)
        return false;
      foreach (MethodInfo method in type3.GetMethods())
      {
        if (method.IsStatic && !(method.Name != "CreateBuilder") && method.IsGenericMethodDefinition && method.GetParameters().Length == 0 && method.GetGenericArguments().Length == genericArguments.Length)
        {
          builderFactory = method.MakeGenericMethod(genericArguments);
          break;
        }
      }
      Type type4 = model.MapType(typeof (void));
      if ((object) builderFactory == null || (object) builderFactory.ReturnType == null || (object) builderFactory.ReturnType == (object) type4)
        return false;
      add = Helpers.GetInstanceMethod(builderFactory.ReturnType, "Add", types);
      if ((object) add == null)
        return false;
      finish = Helpers.GetInstanceMethod(builderFactory.ReturnType, "ToImmutable", Helpers.EmptyTypes);
      if ((object) finish == null || (object) finish.ReturnType == null || (object) finish.ReturnType == (object) type4 || (object) finish.ReturnType != (object) declaredType && !Helpers.IsAssignableFrom(declaredType, finish.ReturnType))
        return false;
      addRange = Helpers.GetInstanceMethod(builderFactory.ReturnType, "AddRange", new Type[1]
      {
        declaredType
      });
      if ((object) addRange == null)
      {
        Type type5 = model.MapType(typeof (IEnumerable<>), false);
        if ((object) type5 != null)
          addRange = Helpers.GetInstanceMethod(builderFactory.ReturnType, "AddRange", new Type[1]
          {
            type5.MakeGenericType(types)
          });
      }
      return true;
    }

    internal ImmutableCollectionDecorator(
      TypeModel model,
      Type declaredType,
      Type concreteType,
      IProtoSerializer tail,
      int fieldNumber,
      bool writePacked,
      WireType packedWireType,
      bool returnList,
      bool overwriteList,
      bool supportNull,
      MethodInfo builderFactory,
      MethodInfo add,
      MethodInfo addRange,
      MethodInfo finish)
      : base(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull)
    {
      this.builderFactory = builderFactory;
      this.add = add;
      this.addRange = addRange;
      this.finish = finish;
    }

    public override object Read(object value, ProtoReader source)
    {
      object obj1 = this.builderFactory.Invoke((object) null, (object[]) null);
      int fieldNumber = source.FieldNumber;
      object[] parameters = new object[1];
      if (this.AppendToCollection && value != null && ((ICollection) value).Count != 0)
      {
        if ((object) this.addRange != null)
        {
          parameters[0] = value;
          this.addRange.Invoke(obj1, parameters);
        }
        else
        {
          foreach (object obj2 in (IEnumerable) value)
          {
            parameters[0] = obj2;
            this.add.Invoke(obj1, parameters);
          }
        }
      }
      if (this.packedWireType != WireType.None && source.WireType == WireType.String)
      {
        SubItemToken token = ProtoReader.StartSubItem(source);
        while (ProtoReader.HasSubValue(this.packedWireType, source))
        {
          parameters[0] = this.Tail.Read((object) null, source);
          this.add.Invoke(obj1, parameters);
        }
        ProtoReader.EndSubItem(token, source);
      }
      else
      {
        do
        {
          parameters[0] = this.Tail.Read((object) null, source);
          this.add.Invoke(obj1, parameters);
        }
        while (source.TryReadFieldHeader(fieldNumber));
      }
      return this.finish.Invoke(obj1, (object[]) null);
    }
  }
}
