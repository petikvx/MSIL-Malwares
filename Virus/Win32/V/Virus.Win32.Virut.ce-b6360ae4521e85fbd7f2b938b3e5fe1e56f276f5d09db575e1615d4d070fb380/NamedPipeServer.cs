// Decompiled with JetBrains decompiler
// Type: Microsoft.Windows.PowerShell.GuiExe.Internal.NamedPipeServer
// Assembly: powershell_ise, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 8E61B2A9-9D1B-4E14-B095-A239B1610C71
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Virut.ce-b6360ae4521e85fbd7f2b938b3e5fe1e56f276f5d09db575e1615d4d070fb380.exe

using System;
using System.Globalization;
using System.IO;
using System.Management.Automation;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text;
using System.Threading;

namespace Microsoft.Windows.PowerShell.GuiExe.Internal
{
  internal class NamedPipeServer
  {
    [TraceSource("PowerShellISENamedPipe", "tracer for NamedPipe")]
    internal static readonly PSTraceSource Tracer = PSTraceSource.GetTracer("PowerShellISENamedPipe", "tracer for NamedPipe");
    private static readonly uint BufferSize = 1024;
    private static SecurityIdentifier logonSid = (SecurityIdentifier) null;
    private static bool useTestName;
    private Thread startListeningThread;
    private IntPtr stopListeningEvent;
    private MethodInfo openMethod;
    private NamedPipeSafeHandle pipeHandle;
    private FileInfo pipeNameFile;
    private IntPtr pipeEvent;
    private AutoResetEvent testServerPauseEvent;
    private AutoResetEvent testPauseEvent;
    private SendOrPostCallback testResultCallback;

    internal NamedPipeServer(MethodInfo openMethod) => this.openMethod = openMethod;

    internal static SecurityIdentifier LogonSid
    {
      get
      {
        if (NamedPipeServer.logonSid == (SecurityIdentifier) null)
          NamedPipeServer.logonSid = NamedPipeServer.GetLogonSid();
        return NamedPipeServer.logonSid;
      }
    }

    internal static bool UseTestName
    {
      get => NamedPipeServer.useTestName;
      set => NamedPipeServer.useTestName = value;
    }

    internal AutoResetEvent TestServerPauseEvent
    {
      get => this.testServerPauseEvent;
      set => this.testServerPauseEvent = value;
    }

    internal AutoResetEvent TestPauseEvent
    {
      get => this.testPauseEvent;
      set => this.testPauseEvent = value;
    }

    internal SendOrPostCallback TestResultCallback
    {
      get => this.testResultCallback;
      set => this.testResultCallback = value;
    }

    internal static string[] GetLogonSidPath() => new string[3]
    {
      "microsoft",
      Path.GetFileNameWithoutExtension(typeof (NamedPipeServer).Assembly.Location),
      NamedPipeServer.LogonSid.ToString()
    };

    internal static string GetPipeNameStart() => "PowerShellISEPipeName_" + (NamedPipeServer.UseTestName ? "2" : (NamedPipeServer.IsAdmin() ? "1" : "0")) + "_";

    internal static DirectoryInfo GetApplicationDataPath(string[] path)
    {
      DirectoryInfo directoryInfo = NamedPipeServer.CreateDirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));
      if (directoryInfo == null || !directoryInfo.Exists)
        return (DirectoryInfo) null;
      foreach (string path2 in path)
      {
        directoryInfo = NamedPipeServer.CreateDirectoryInfo(Path.Combine(directoryInfo.FullName, path2));
        if (directoryInfo == null || !directoryInfo.Exists)
          return (DirectoryInfo) null;
      }
      return directoryInfo;
    }

    internal static FileInfo GetFirstFileInfoStartingWith(DirectoryInfo parent, string str)
    {
      foreach (FileInfo file in parent.GetFiles())
      {
        if (file.Name.StartsWith(str, StringComparison.Ordinal))
          return file;
      }
      return (FileInfo) null;
    }

    internal void StopListening()
    {
      if (!NativeMethods.SetEvent(this.stopListeningEvent))
        NamedPipeServer.Tracer.TraceError("Server: Could not set the cancelling event.");
      this.startListeningThread.Join();
      if (this.pipeEvent != IntPtr.Zero)
        NativeMethods.CloseHandle(this.pipeEvent);
      if (this.stopListeningEvent != IntPtr.Zero)
        NativeMethods.CloseHandle(this.stopListeningEvent);
      this.pipeHandle.Dispose();
      this.TryDecrementCountOrDeletePipeNameFile();
    }

    internal bool CreateNamedPipe(bool resetReferenceCount)
    {
      if (NamedPipeServer.LogonSid == (SecurityIdentifier) null)
      {
        NamedPipeServer.Tracer.TraceError("Server: Error retrieving log on sid, creation of pipe canceled");
        return false;
      }
      this.stopListeningEvent = NativeMethods.CreateEvent(IntPtr.Zero, true, false, (string) null);
      if (this.stopListeningEvent == IntPtr.Zero)
      {
        NamedPipeServer.Tracer.TraceError("Server: Could not create cancelation event");
        return false;
      }
      this.pipeEvent = NativeMethods.CreateEvent(IntPtr.Zero, true, true, (string) null);
      if (this.pipeEvent == IntPtr.Zero)
      {
        NamedPipeServer.Tracer.TraceError("Server: Could not create pipe event");
        return false;
      }
      this.pipeNameFile = NamedPipeServer.CreatePipeNameIfNecessary();
      if (this.pipeNameFile == null)
      {
        NamedPipeServer.Tracer.TraceError("Server: Error retrieving pipe name, creation of pipe canceled");
        return false;
      }
      string lpName = "\\\\.\\pipe\\" + this.pipeNameFile.Name;
      GCHandle securityDescriptor = NamedPipeServer.CreateSecurityDescriptor(NamedPipeServer.LogonSid);
      this.pipeHandle = NativeMethods.CreateNamedPipe(lpName, 1073741825U, 6U, (uint) byte.MaxValue, 0U, 2U * NamedPipeServer.BufferSize, 0U, NamedPipeServer.GetSessionSecurityAttributes(securityDescriptor));
      int lastWin32Error = Marshal.GetLastWin32Error();
      securityDescriptor.Free();
      if (this.pipeHandle.IsInvalid)
      {
        NamedPipeServer.Tracer.TraceError("Server: Invalid Handle. error: '{0}'", (object) lastWin32Error);
        return false;
      }
      if (resetReferenceCount)
      {
        if (!NamedPipeServer.TrySetPipeNameReferenceCount(this.pipeNameFile, 1))
          NamedPipeServer.Tracer.TraceError("Server: Could not set Named pipe reference count");
      }
      else
      {
        int num;
        if (NamedPipeServer.TryGetPipeNameReferenceCount(this.pipeNameFile, out num))
        {
          if (!NamedPipeServer.TrySetPipeNameReferenceCount(this.pipeNameFile, num + 1))
            NamedPipeServer.Tracer.TraceError("Server: Could not set decremented Named pipe reference count");
        }
        else
          NamedPipeServer.Tracer.TraceError("Server: Could not get initial Named pipe reference count");
      }
      NamedPipeServer.Tracer.WriteLine("Server: Created Pipe");
      return true;
    }

    internal void StartListening()
    {
      this.startListeningThread = new Thread(new ThreadStart(this.StartListeningThreadStart));
      this.startListeningThread.Name = "PowerShell ISE NamedPipe Server";
      this.startListeningThread.Start();
    }

    private static bool TryCreateText(FileInfo file, out StreamWriter stream)
    {
      stream = (StreamWriter) null;
      try
      {
        stream = file.CreateText();
      }
      catch (IOException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (UnauthorizedAccessException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (SecurityException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      return true;
    }

    private static bool TryOpenText(FileInfo file, out StreamReader stream)
    {
      stream = (StreamReader) null;
      try
      {
        stream = file.OpenText();
      }
      catch (FileNotFoundException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (DirectoryNotFoundException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (UnauthorizedAccessException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (SecurityException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      return true;
    }

    private static bool TryGetPipeNameReferenceCount(FileInfo file, out int value)
    {
      value = 0;
      StreamReader stream;
      if (!NamedPipeServer.TryOpenText(file, out stream))
        return false;
      using (stream)
      {
        try
        {
          if (int.TryParse(stream.ReadToEnd(), out value))
          {
            if (value >= 0)
              goto label_10;
          }
          NamedPipeServer.Tracer.TraceError("Server: NamedPipe file contents was not a positive integer");
          return false;
        }
        catch (IOException ex)
        {
          NamedPipeServer.Tracer.TraceException((Exception) ex);
          return false;
        }
      }
label_10:
      return true;
    }

    private static bool TrySetPipeNameReferenceCount(FileInfo file, int value)
    {
      StreamWriter stream;
      if (!NamedPipeServer.TryCreateText(file, out stream))
        return false;
      using (stream)
      {
        try
        {
          stream.WriteLine(value.ToString((IFormatProvider) CultureInfo.InvariantCulture));
        }
        catch (IOException ex)
        {
          NamedPipeServer.Tracer.TraceException((Exception) ex);
          return false;
        }
      }
      return true;
    }

    private static SecurityIdentifier GetLogonSid()
    {
      IntPtr currentProcess = NativeMethods.GetCurrentProcess();
      if (currentProcess == IntPtr.Zero)
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        NamedPipeServer.Tracer.TraceError("Retrieved null process handle: '{0}'.", (object) lastWin32Error);
        return (SecurityIdentifier) null;
      }
      IntPtr TokenHandle;
      if (!NativeMethods.OpenProcessToken(currentProcess, 8U, out TokenHandle))
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        NamedPipeServer.Tracer.TraceError("Could not retrieve process token: '{0}'.", (object) lastWin32Error);
        return (SecurityIdentifier) null;
      }
      uint ReturnLength = 0;
      if (NativeMethods.GetTokenInformation(TokenHandle, 2, IntPtr.Zero, 0U, ref ReturnLength) != 0)
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        NamedPipeServer.Tracer.TraceError("Error retrieving group byte length for process token: '{0}'.", (object) lastWin32Error);
        return (SecurityIdentifier) null;
      }
      IntPtr num = Marshal.AllocHGlobal((int) ReturnLength);
      try
      {
        if (NativeMethods.GetTokenInformation(TokenHandle, 2, num, ReturnLength, ref ReturnLength) == 0)
        {
          int lastWin32Error = Marshal.GetLastWin32Error();
          NamedPipeServer.Tracer.TraceError("Error retrieving groups for process token: '{0}'.", (object) lastWin32Error);
          return (SecurityIdentifier) null;
        }
        NativeMethods.TOKEN_GROUPS structure1 = (NativeMethods.TOKEN_GROUPS) Marshal.PtrToStructure(num, typeof (NativeMethods.TOKEN_GROUPS));
        IntPtr ptr = new IntPtr(num.ToInt64() + (long) Marshal.SizeOf(typeof (NativeMethods.TOKEN_GROUPS)) - (long) Marshal.SizeOf(typeof (NativeMethods.SID_AND_ATTRIBUTES)));
        for (int index = 0; index < structure1.GroupCount; ++index)
        {
          NativeMethods.SID_AND_ATTRIBUTES structure2 = (NativeMethods.SID_AND_ATTRIBUTES) Marshal.PtrToStructure(ptr, typeof (NativeMethods.SID_AND_ATTRIBUTES));
          if (((int) structure2.Attributes & -1073741824) != 0)
            return new SecurityIdentifier(structure2.Sid);
          ptr = new IntPtr(ptr.ToInt64() + (long) Marshal.SizeOf((object) structure2));
        }
      }
      finally
      {
        Marshal.FreeHGlobal(num);
      }
      return (SecurityIdentifier) null;
    }

    private static DirectoryInfo CreateDirectoryInfo(string fullPath)
    {
      try
      {
        return new DirectoryInfo(fullPath);
      }
      catch (SecurityException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return (DirectoryInfo) null;
      }
    }

    private static DirectoryInfo CreateChildPathIfNecessary(
      DirectoryInfo parent,
      string childPath)
    {
      DirectoryInfo directoryInfo = NamedPipeServer.CreateDirectoryInfo(Path.Combine(parent.FullName, childPath));
      if (directoryInfo == null)
        return (DirectoryInfo) null;
      if (!directoryInfo.Exists)
      {
        try
        {
          directoryInfo.Create();
        }
        catch (IOException ex)
        {
          NamedPipeServer.Tracer.TraceException((Exception) ex);
          return (DirectoryInfo) null;
        }
        directoryInfo.Refresh();
      }
      return directoryInfo;
    }

    private static DirectoryInfo CreateApplicationDataPath(string[] path)
    {
      DirectoryInfo parent = NamedPipeServer.CreateDirectoryInfo(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));
      if (parent == null || !parent.Exists)
        return (DirectoryInfo) null;
      foreach (string childPath in path)
      {
        parent = NamedPipeServer.CreateChildPathIfNecessary(parent, childPath);
        if (parent == null)
          return (DirectoryInfo) null;
      }
      return parent;
    }

    private static FileInfo CreatePipeNameIfNecessary()
    {
      if (NamedPipeServer.LogonSid == (SecurityIdentifier) null)
        return (FileInfo) null;
      DirectoryInfo applicationDataPath = NamedPipeServer.CreateApplicationDataPath(NamedPipeServer.GetLogonSidPath());
      if (applicationDataPath == null)
        return (FileInfo) null;
      string pipeNameStart = NamedPipeServer.GetPipeNameStart();
      FileInfo infoStartingWith = NamedPipeServer.GetFirstFileInfoStartingWith(applicationDataPath, pipeNameStart);
      if (infoStartingWith != null)
        return infoStartingWith;
      string str = Path.Combine(applicationDataPath.FullName, pipeNameStart + Guid.NewGuid().ToString());
      try
      {
        File.CreateText(str).Close();
      }
      catch (UnauthorizedAccessException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return (FileInfo) null;
      }
      return new FileInfo(str);
    }

    private static bool IsAdmin() => new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);

    private static GCHandle CreateSecurityDescriptor(SecurityIdentifier sid)
    {
      DiscretionaryAcl discretionaryAcl = new DiscretionaryAcl(false, false, 1);
      discretionaryAcl.AddAccess(AccessControlType.Allow, sid, -1, InheritanceFlags.None, PropagationFlags.None);
      CommonSecurityDescriptor securityDescriptor = new CommonSecurityDescriptor(false, false, ControlFlags.OwnerDefaulted | ControlFlags.GroupDefaulted | ControlFlags.DiscretionaryAclPresent, (SecurityIdentifier) null, (SecurityIdentifier) null, (SystemAcl) null, discretionaryAcl);
      byte[] binaryForm = new byte[securityDescriptor.BinaryLength];
      securityDescriptor.GetBinaryForm(binaryForm, 0);
      return GCHandle.Alloc((object) binaryForm, GCHandleType.Pinned);
    }

    private static NativeMethods.SECURITY_ATTRIBUTES GetSessionSecurityAttributes(
      GCHandle securityDescriptor)
    {
      NativeMethods.SECURITY_ATTRIBUTES structure = new NativeMethods.SECURITY_ATTRIBUTES()
      {
        InheritHandle = true
      };
      structure.NLength = Marshal.SizeOf((object) structure);
      structure.LPSecurityDescriptor = securityDescriptor.AddrOfPinnedObject();
      return structure;
    }

    private static bool TryDeleteFile(FileInfo file)
    {
      try
      {
        file.Delete();
      }
      catch (SecurityException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (IOException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (UnauthorizedAccessException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      return true;
    }

    private static bool TryDeleteDirectory(DirectoryInfo directory)
    {
      try
      {
        directory.Delete();
      }
      catch (SecurityException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      catch (IOException ex)
      {
        NamedPipeServer.Tracer.TraceException((Exception) ex);
        return false;
      }
      return true;
    }

    private void StartListeningThreadStart()
    {
      byte[] numArray = new byte[(IntPtr) NamedPipeServer.BufferSize];
      NativeOverlapped lpOverlapped = new NativeOverlapped();
      lpOverlapped.EventHandle = this.pipeEvent;
      IntPtr[] lpHandles = new IntPtr[2]
      {
        this.pipeEvent,
        this.stopListeningEvent
      };
      while (true)
      {
        this.TestPause();
        NativeMethods.ConnectNamedPipe(this.pipeHandle, ref lpOverlapped);
        int lastWin32Error1 = Marshal.GetLastWin32Error();
        uint count;
        switch (lastWin32Error1)
        {
          case 535:
            this.TestCallback(NamedPipeServer.TestResults.ConnectionSuccededWithErrorConnected);
            break;
          case 997:
            this.TestCallback(NamedPipeServer.TestResults.ConnectionPending);
            this.TestPause();
            if (NativeMethods.WaitForMultipleObjects(2U, lpHandles, false, uint.MaxValue) == 0U)
            {
              this.TestCallback(NamedPipeServer.TestResults.ConnectionReadyToGetResult);
              bool overlappedResult = NativeMethods.GetOverlappedResult(this.pipeHandle, ref lpOverlapped, out count, false);
              int lastWin32Error2 = Marshal.GetLastWin32Error();
              if (!overlappedResult)
              {
                this.TestCallback(NamedPipeServer.TestResults.ConnectionResultFailedAfterWait);
                this.TestCallback((NamedPipeServer.TestResults) lastWin32Error2);
                NamedPipeServer.Tracer.TraceError("Server: GetOverlappedResult after a ConnectNamedPipe failed with {0}", (object) lastWin32Error2);
                continue;
              }
              this.TestCallback(NamedPipeServer.TestResults.ConnectionSuccededAfterWait);
              break;
            }
            goto label_3;
          default:
            this.TestCallback(NamedPipeServer.TestResults.ConnectionResultFailedBeforeWait);
            this.TestCallback((NamedPipeServer.TestResults) lastWin32Error1);
            if (!NativeMethods.DisconnectNamedPipe(this.pipeHandle))
            {
              int lastWin32Error3 = Marshal.GetLastWin32Error();
              this.TestCallback(NamedPipeServer.TestResults.DisconnectionFailure);
              NamedPipeServer.Tracer.TraceError("Server: DisconnectNamedPipe failed with {0}", (object) lastWin32Error3);
            }
            NamedPipeServer.Tracer.TraceError("Server: ConnectNamedPipe failed with {0}.", (object) lastWin32Error1);
            continue;
        }
        this.TestCallback(NamedPipeServer.TestResults.ConnectionResultSuccesfull);
        StringBuilder stringSoFar = new StringBuilder();
        int lastWin32Error4;
        int lastWin32Error5;
        while (true)
        {
          this.TestPause();
          bool flag = NativeMethods.ReadFile(this.pipeHandle, numArray, NamedPipeServer.BufferSize, out count, ref lpOverlapped);
          lastWin32Error4 = Marshal.GetLastWin32Error();
          if (!flag)
          {
            if (lastWin32Error4 == 234 || lastWin32Error4 == 997)
            {
              this.TestPause();
              if (NativeMethods.WaitForMultipleObjects(2U, lpHandles, false, uint.MaxValue) == 0U)
              {
                bool overlappedResult = NativeMethods.GetOverlappedResult(this.pipeHandle, ref lpOverlapped, out count, false);
                lastWin32Error5 = Marshal.GetLastWin32Error();
                if (!overlappedResult)
                {
                  if (lastWin32Error5 == 234)
                  {
                    this.TestCallback(NamedPipeServer.TestResults.ReadMoreData);
                    string str = Encoding.Unicode.GetString(numArray, 0, (int) count);
                    NamedPipeServer.Tracer.WriteLine("Server: Read partial string: {0}", (object) str);
                    stringSoFar.Append(str);
                  }
                  else
                    goto label_24;
                }
                else
                  goto label_21;
              }
              else
                goto label_17;
            }
            else
              goto label_15;
          }
          else
            break;
        }
        this.TestCallback(NamedPipeServer.TestResults.ReadResultSuccessfull);
        string finalString1 = Encoding.Unicode.GetString(numArray, 0, (int) count);
        this.InvokeOpenMethod(stringSoFar, finalString1);
        goto label_25;
label_15:
        this.TestCallback(NamedPipeServer.TestResults.ReadFailureNoWaiting);
        this.TestCallback((NamedPipeServer.TestResults) lastWin32Error4);
        NamedPipeServer.Tracer.TraceError("Server: ReadFile failed with {0}", (object) lastWin32Error4);
        goto label_25;
label_21:
        this.TestCallback(NamedPipeServer.TestResults.ReadOverlappedResultSuccessfull);
        string finalString2 = Encoding.Unicode.GetString(numArray, 0, (int) count);
        this.InvokeOpenMethod(stringSoFar, finalString2);
        goto label_25;
label_24:
        this.TestCallback(NamedPipeServer.TestResults.ReadFailureWaiting);
        this.TestCallback((NamedPipeServer.TestResults) lastWin32Error5);
        NamedPipeServer.Tracer.TraceError("Server: GetOverlappedResult after a ReadFile failed with{0}", (object) lastWin32Error5);
label_25:
        this.TestPause();
        if (!NativeMethods.DisconnectNamedPipe(this.pipeHandle))
        {
          int lastWin32Error6 = Marshal.GetLastWin32Error();
          this.TestCallback(NamedPipeServer.TestResults.DisconnectionFailure);
          NamedPipeServer.Tracer.TraceError("Server: DisconnectNamedPipe failed with {0}", (object) lastWin32Error6);
        }
        this.TestCallback(NamedPipeServer.TestResults.DisconnectionSuccess);
      }
label_3:
      this.TestCallback(NamedPipeServer.TestResults.CancelConnection);
      return;
label_17:
      if (!NativeMethods.DisconnectNamedPipe(this.pipeHandle))
      {
        int lastWin32Error = Marshal.GetLastWin32Error();
        this.TestCallback((NamedPipeServer.TestResults) lastWin32Error);
        NamedPipeServer.Tracer.TraceError("Server: DisconnectNamedPipe failed after cancelling with {0}", (object) lastWin32Error);
      }
      this.TestCallback(NamedPipeServer.TestResults.CancelRead);
    }

    private void TestCallback(NamedPipeServer.TestResults result)
    {
      if (this.testResultCallback == null)
        return;
      this.testResultCallback((object) result);
    }

    private void TestPause()
    {
      if (this.testServerPauseEvent == null || this.testPauseEvent == null)
        return;
      this.testPauseEvent.Set();
      this.testServerPauseEvent.WaitOne();
    }

    private void InvokeOpenMethod(StringBuilder stringSoFar, string finalString)
    {
      stringSoFar.Append(finalString);
      finalString = stringSoFar.ToString();
      if (!finalString.Equals("fe886c82-edda-4016-bcbb-bd5788201338", StringComparison.Ordinal))
        this.openMethod.Invoke((object) null, new object[1]
        {
          (object) new string[1]{ finalString }
        });
      NamedPipeServer.Tracer.WriteLine("Server: Read final string: {0}", (object) finalString);
    }

    private void TryDecrementCountOrDeletePipeNameFile()
    {
      int num;
      if (!NamedPipeServer.TryGetPipeNameReferenceCount(this.pipeNameFile, out num))
      {
        NamedPipeServer.Tracer.TraceError("Server: Could not get Named pipe reference count, will try to delete the file.");
        this.TryDeletePipeNameFile();
      }
      else if (num == 1)
      {
        this.TryDeletePipeNameFile();
      }
      else
      {
        if (NamedPipeServer.TrySetPipeNameReferenceCount(this.pipeNameFile, num - 1))
          return;
        NamedPipeServer.Tracer.TraceError("Server: Could not decrement Named pipe reference count");
      }
    }

    private void TryDeletePipeNameFile()
    {
      if (!NamedPipeServer.TryDeleteFile(this.pipeNameFile))
      {
        NamedPipeServer.Tracer.TraceError("Server: Could not delete pipe name file '{0}'.", (object) this.pipeNameFile.FullName);
      }
      else
      {
        if (this.pipeNameFile.Directory.GetFiles().Length != 0 || NamedPipeServer.TryDeleteDirectory(this.pipeNameFile.Directory))
          return;
        NamedPipeServer.Tracer.TraceError("Server: Could not delete pipe name directory '{0}'.", (object) this.pipeNameFile.Directory.FullName);
      }
    }

    internal enum TestResults
    {
      ConnectionPending = 1,
      CancelConnection = 2,
      ConnectionResultFailedBeforeWait = 3,
      ConnectionResultFailedAfterWait = 4,
      ConnectionSuccededWithErrorConnected = 5,
      ConnectionSuccededAfterWait = 6,
      ConnectionReadyToGetResult = 7,
      ConnectionResultSuccesfull = 8,
      ReadResultSuccessfull = 9,
      CancelRead = 10, // 0x0000000A
      ReadOverlappedResultSuccessfull = 11, // 0x0000000B
      ReadMoreData = 12, // 0x0000000C
      ReadFailureWaiting = 13, // 0x0000000D
      ReadFailureNoWaiting = 14, // 0x0000000E
      DisconnectionFailure = 15, // 0x0000000F
      DisconnectionSuccess = 16, // 0x00000010
    }
  }
}
