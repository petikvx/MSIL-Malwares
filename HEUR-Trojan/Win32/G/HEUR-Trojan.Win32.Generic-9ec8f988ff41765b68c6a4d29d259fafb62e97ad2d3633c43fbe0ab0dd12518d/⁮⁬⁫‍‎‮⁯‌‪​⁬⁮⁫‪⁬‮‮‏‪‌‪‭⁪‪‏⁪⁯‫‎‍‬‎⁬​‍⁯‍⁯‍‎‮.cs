// Decompiled with JetBrains decompiler
// Type: ⁮⁬⁫‍‎‮⁯‌‪​⁬⁮⁫‪⁬‮‮‏‪‌‪‭⁪‪‏⁪⁯‫‎‍‬‎⁬​‍⁯‍⁯‍‎‮
// Assembly: ReadLineS0SAT, Version=2.0.8.1, Culture=neutral, PublicKeyToken=null
// MVID: 826822DE-6F21-4D67-9238-0DAF50EB618B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-9ec8f988ff41765b68c6a4d29d259fafb62e97ad2d3633c43fbe0ab0dd12518d.exe

using System;

public class \u206E⁬⁫‍‎‮⁯‌‪​⁬⁮⁫‪⁬‮‮‏‪‌‪‭⁪‪‏⁪⁯‫‎‍‬‎⁬​‍⁯‍⁯‍‎‮ : 
  \u206F⁪‍⁯‬‌‮‏⁬​⁮‫⁮⁬‬‭‪⁫⁪⁪⁯⁮⁮‎‌‭‮‎​‌⁫‭⁮⁬‮‌⁫​⁯⁪‮
{
  private readonly \u206F‮‪⁭⁮‮‏⁭⁮⁫‏‬‫‏‬‍‪‫⁯⁪‏⁫⁯‫⁫‮‪‮‌‌⁭‪‪‌⁮‫‭⁪⁭‪‮ \u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮;
  private \u200C⁭‎‪‬⁪⁭⁮‌​⁯‫⁪⁭⁬⁭‌‎⁮⁮⁯⁯​‏‎⁮‌‬⁪⁭⁬​⁯‏⁪‌‮‍⁮‮ \u200F⁫‭‪‌⁪⁫‎‍⁭⁫‍‬‎‬‬⁭‬⁬‬⁭⁮‮‍⁮⁫​‍‎⁪⁮⁪⁭⁪‪⁬⁪‬⁬⁬‮;
  private bool \u200B‫⁪⁭‭⁭‍‍⁯‮⁪⁮⁪‍‬‮‌‏‫‭⁬⁫‌‌‮‪‭‌‬‌⁪‮‪⁪‫​‭⁬⁪⁮‮;
  private byte[] \u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮ = new byte[8]
  {
    (byte) 166,
    (byte) 166,
    (byte) 166,
    (byte) 166,
    (byte) 166,
    (byte) 166,
    (byte) 166,
    (byte) 166
  };

  public \u206E⁬⁫‍‎‮⁯‌‪​⁬⁮⁫‪⁬‮‮‏‪‌‪‭⁪‪‏⁪⁯‫‎‍‬‎⁬​‍⁯‍⁯‍‎‮(
    \u206F‮‪⁭⁮‮‏⁭⁮⁫‏‬‫‏‬‍‪‫⁯⁪‏⁫⁯‫⁫‮‪‮‌‌⁭‪‪‌⁮‫‭⁪⁭‪‮ _param1)
  {
    this.\u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮ = _param1;
  }

  public virtual void \u206A⁭⁫‪‫‬⁪‎​⁯‎‪⁬⁭​‍⁪⁫‌⁪‫⁯​⁪⁫⁫‪‬⁬‏‫‮⁬‬⁭⁬⁫‍⁮‮(
    bool _param1,
    \u202B⁭⁮‬‎⁪‬⁪‬⁮⁪‮‬‍‎⁮‎⁫‎​‌⁫⁪‭‬‮‏‮​⁮‌‌‬‌⁯‮⁫‮‬⁫‮ _param2)
  {
    this.\u200B‫⁪⁭‭⁭‍‍⁯‮⁪⁮⁪‍‬‮‌‏‫‭⁬⁫‌‌‮‪‭‌‬‌⁪‮‪⁪‫​‭⁬⁪⁮‮ = _param1;
    if (_param2 is \u206A‍‫‫‪⁮‏‪‫⁫‎⁮‭⁭⁮​‬⁬⁮‫‮‎⁮⁫⁯‫‏⁯⁭⁬⁯⁪‬⁬‫⁪​‫⁪‌‮)
      _param2 = ((\u206A‍‫‫‪⁮‏‪‫⁫‎⁮‭⁭⁮​‬⁬⁮‫‮‎⁮⁫⁯‫‏⁯⁭⁬⁯⁪‬⁬‫⁪​‫⁪‌‮) _param2).\u202C⁬⁮⁮‮⁮​‫⁪⁬⁬⁬​‎‍⁭⁫‍⁯‬⁪‬⁮⁪‬‬⁭⁭⁫⁫‏‭⁪‬​‮​‫‫⁫‮;
    if (_param2 is \u200C⁭‎‪‬⁪⁭⁮‌​⁯‫⁪⁭⁬⁭‌‎⁮⁮⁯⁯​‏‎⁮‌‬⁪⁭⁬​⁯‏⁪‌‮‍⁮‮)
    {
      this.\u200F⁫‭‪‌⁪⁫‎‍⁭⁫‍‬‎‬‬⁭‬⁬‬⁭⁮‮‍⁮⁫​‍‎⁪⁮⁪⁭⁪‪⁬⁪‬⁬⁬‮ = (\u200C⁭‎‪‬⁪⁭⁮‌​⁯‫⁪⁭⁬⁭‌‎⁮⁮⁯⁯​‏‎⁮‌‬⁪⁭⁬​⁯‏⁪‌‮‍⁮‮) _param2;
    }
    else
    {
      if (!(_param2 is \u200C⁯‭‏⁯‬‌‌‏​‌‫⁬‮⁮⁫‬⁬‮⁪‍​⁯‮⁭‏‫‪‍‬⁮​‬⁭⁯‍⁭‭‪⁬‮))
        return;
      \u200C⁯‭‏⁯‬‌‌‏​‌‫⁬‮⁮⁫‬⁬‮⁪‍​⁯‮⁭‏‫‪‍‬⁮​‬⁭⁯‍⁭‭‪⁬‮ obj = (\u200C⁯‭‏⁯‬‌‌‏​‌‫⁬‮⁮⁫‬⁬‮⁪‍​⁯‮⁭‏‫‪‍‬⁮​‬⁭⁯‍⁭‭‪⁬‮) _param2;
      byte[] numArray = obj.\u202A‌⁭‍‪‭‍‍⁪⁭⁫‮⁬‍⁪⁪‪⁬‏⁭⁫⁫⁬‫⁬‪‏⁯‍⁪‍‮‫⁪‏‬⁯‭‏‪‮();
      this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮ = numArray.Length == 8 ? numArray : throw new ArgumentException("IV length not equal to 8", "parameters");
      this.\u200F⁫‭‪‌⁪⁫‎‍⁭⁫‍‬‎‬‬⁭‬⁬‬⁭⁮‮‍⁮⁫​‍‎⁪⁮⁪⁭⁪‪⁬⁪‬⁬⁬‮ = (\u200C⁭‎‪‬⁪⁭⁮‌​⁯‫⁪⁭⁬⁭‌‎⁮⁮⁯⁯​‏‎⁮‌‬⁪⁭⁬​⁯‏⁪‌‮‍⁮‮) obj.\u202C⁬⁮⁮‮⁮​‫⁪⁬⁬⁬​‎‍⁭⁫‍⁯‬⁪‬⁮⁪‬‬⁭⁭⁫⁫‏‭⁪‬​‮​‫‫⁫‮;
    }
  }

  public virtual string \u206B‪⁭‪⁮‍⁮‪⁭⁪‪​⁮‭‭⁬⁯‍‎⁮⁬‫‍‏‌⁬⁯⁯‮⁪‪‬‫⁯‬⁪‌‍‮‎‮ => this.\u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮.\u206B‪⁭‪⁮‍⁮‪⁭⁪‪​⁮‭‭⁬⁯‍‎⁮⁬‫‍‏‌⁬⁯⁯‮⁪‪‬‫⁯‬⁪‌‍‮‎‮;

  public virtual byte[] \u202B⁯‏⁮​‏⁭⁯⁯⁯‭​⁪⁮⁫‎‌‮‪‫⁮‏‭⁬⁬⁯⁫‍⁪‮‏‌‍‌‬‪‎⁭‬⁭‮(
    byte[] _param1,
    int _param2,
    int _param3)
  {
    if (!this.\u200B‫⁪⁭‭⁭‍‍⁯‮⁪⁮⁪‍‬‮‌‏‫‭⁬⁫‌‌‮‪‭‌‬‌⁪‮‪⁪‫​‭⁬⁪⁮‮)
      throw new InvalidOperationException("not set for wrapping");
    int num1 = _param3 / 8;
    if (num1 * 8 != _param3)
      throw new \u202A⁯⁬⁬‪⁫‌‏‎‬⁮‬⁪⁬‬⁯‍‍‍‌‎‍‍‬‍‮‬⁫​⁬‎⁯‪‏‏‫‍‫‌‫‮("wrap data must be a multiple of 8 bytes");
    byte[] numArray1 = new byte[_param3 + this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length];
    byte[] numArray2 = new byte[8 + this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length];
    Array.Copy((Array) this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮, 0, (Array) numArray1, 0, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length);
    Array.Copy((Array) _param1, _param2, (Array) numArray1, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length, _param3);
    this.\u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮.\u206A⁭⁫‪‫‬⁪‎​⁯‎‪⁬⁭​‍⁪⁫‌⁪‫⁯​⁪⁫⁫‪‬⁬‏‫‮⁬‬⁭⁬⁫‍⁮‮(true, (\u202B⁭⁮‬‎⁪‬⁪‬⁮⁪‮‬‍‎⁮‎⁫‎​‌⁫⁪‭‬‮‏‮​⁮‌‌‬‌⁯‮⁫‮‬⁫‮) this.\u200F⁫‭‪‌⁪⁫‎‍⁭⁫‍‬‎‬‬⁭‬⁬‬⁭⁮‮‍⁮⁫​‍‎⁪⁮⁪⁭⁪‪⁬⁪‬⁬⁬‮);
    for (int index1 = 0; index1 != 6; ++index1)
    {
      for (int index2 = 1; index2 <= num1; ++index2)
      {
        Array.Copy((Array) numArray1, 0, (Array) numArray2, 0, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length);
        Array.Copy((Array) numArray1, 8 * index2, (Array) numArray2, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length, 8);
        this.\u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮.\u206D‌‍‪⁮⁮⁮⁯‭⁪‍‬‭‏‍⁬⁭⁯‪‏‍‭‬‮‬⁮​⁫⁭⁯‭‫‌​‫‍⁭‬⁯‍‮(numArray2, 0, numArray2, 0);
        int num2 = num1 * index1 + index2;
        int num3 = 1;
        while (num2 != 0)
        {
          byte num4 = (byte) num2;
          numArray2[this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length - num3] ^= num4;
          num2 = (int) ((uint) num2 >> 8);
          ++num3;
        }
        Array.Copy((Array) numArray2, 0, (Array) numArray1, 0, 8);
        Array.Copy((Array) numArray2, 8, (Array) numArray1, 8 * index2, 8);
      }
    }
    return numArray1;
  }

  public virtual byte[] \u206D‬‍⁫⁯‮‮​‌​‍‎‏‫⁪‬⁬⁪‪​⁬​⁫​‫‫⁬​⁫‭⁯‪⁪⁪⁭‍⁮​‬‍‮(
    byte[] _param1,
    int _param2,
    int _param3)
  {
    if (this.\u200B‫⁪⁭‭⁭‍‍⁯‮⁪⁮⁪‍‬‮‌‏‫‭⁬⁫‌‌‮‪‭‌‬‌⁪‮‪⁪‫​‭⁬⁪⁮‮)
      throw new InvalidOperationException("not set for unwrapping");
    int num1 = _param3 / 8;
    if (num1 * 8 != _param3)
      throw new \u206F⁭‭‫‎‍‏⁯‬‍‌​⁭⁮‬⁪⁬⁮⁯‪⁪‏‬‭⁬⁫‪​‬‬‎⁪‪⁪‭‏‫‬⁪‏‮("unwrap data must be a multiple of 8 bytes");
    byte[] numArray1 = new byte[_param3 - this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length];
    byte[] numArray2 = new byte[this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length];
    byte[] numArray3 = new byte[8 + this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length];
    Array.Copy((Array) _param1, _param2, (Array) numArray2, 0, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length);
    Array.Copy((Array) _param1, _param2 + this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length, (Array) numArray1, 0, _param3 - this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length);
    this.\u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮.\u206A⁭⁫‪‫‬⁪‎​⁯‎‪⁬⁭​‍⁪⁫‌⁪‫⁯​⁪⁫⁫‪‬⁬‏‫‮⁬‬⁭⁬⁫‍⁮‮(false, (\u202B⁭⁮‬‎⁪‬⁪‬⁮⁪‮‬‍‎⁮‎⁫‎​‌⁫⁪‭‬‮‏‮​⁮‌‌‬‌⁯‮⁫‮‬⁫‮) this.\u200F⁫‭‪‌⁪⁫‎‍⁭⁫‍‬‎‬‬⁭‬⁬‬⁭⁮‮‍⁮⁫​‍‎⁪⁮⁪⁭⁪‪⁬⁪‬⁬⁬‮);
    int num2 = num1 - 1;
    for (int index1 = 5; index1 >= 0; --index1)
    {
      for (int index2 = num2; index2 >= 1; --index2)
      {
        Array.Copy((Array) numArray2, 0, (Array) numArray3, 0, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length);
        Array.Copy((Array) numArray1, 8 * (index2 - 1), (Array) numArray3, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length, 8);
        int num3 = num2 * index1 + index2;
        int num4 = 1;
        while (num3 != 0)
        {
          byte num5 = (byte) num3;
          numArray3[this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮.Length - num4] ^= num5;
          num3 = (int) ((uint) num3 >> 8);
          ++num4;
        }
        this.\u200D⁯‌‎‏⁪⁬‏‭‮‍⁯‪‍⁪‍‫‪‍⁮⁯‬‍⁫‬⁮⁬​⁪‌‭‫⁫‍⁭‮‌‭⁫⁭‮.\u206D‌‍‪⁮⁮⁮⁯‭⁪‍‬‭‏‍⁬⁭⁯‪‏‍‭‬‮‬⁮​⁫⁭⁯‭‫‌​‫‍⁭‬⁯‍‮(numArray3, 0, numArray3, 0);
        Array.Copy((Array) numArray3, 0, (Array) numArray2, 0, 8);
        Array.Copy((Array) numArray3, 8, (Array) numArray1, 8 * (index2 - 1), 8);
      }
    }
    if (!\u206D‭‎‏⁪⁫‌⁫⁫‮‮​‮‫⁯‎​⁮‭‍⁬⁫⁭⁬‎⁭‫‮‫⁬⁫‬‮⁪‌⁮⁬⁭⁬‪‮.\u200F⁬‌‬⁭⁪⁪‏‫⁮⁭‪⁮‎​‍⁬‭⁪⁯⁬‭‌⁬⁬‬‫‮⁫⁯‏⁫⁪‌⁬⁫⁫‬‬‬‮(numArray2, this.\u202B‍⁬⁭‌‬‬‍‏‭‬‎​‮‍‭⁮⁯⁯‮⁮⁬‬​‏‍‪​⁭‌⁪‎⁬⁬‌‌‍⁭⁬‎‮))
      throw new \u206F⁭‭‫‎‍‏⁯‬‍‌​⁭⁮‬⁪⁬⁮⁯‪⁪‏‬‭⁬⁫‪​‬‬‎⁪‪⁪‭‏‫‬⁪‏‮("checksum failed");
    return numArray1;
  }
}
