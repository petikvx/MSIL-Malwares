// Decompiled with JetBrains decompiler
// Type: Pass
// Assembly: Stub, Version=2.0.2.0, Culture=neutral, PublicKeyToken=null
// MVID: 2ADEE861-B489-4B94-AFAF-878A34E8554C
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Worm.Win32.AutoRun.hvq-b4e08d063731bcd4e24e51e4eaa0b9d4f13fad74fdaaefae78fc5583932f35af.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Security.Cryptography;

[StandardModule]
internal sealed class Pass
{
  public class RandomPassword
  {
    private static int DEFAULT_MIN_PASSWORD_LENGTH = 8;
    private static int DEFAULT_MAX_PASSWORD_LENGTH = 10;
    private static string PASSWORD_CHARS_LCASE = "abcdefgijkmnopqrstwxyz";
    private static string PASSWORD_CHARS_UCASE = "ABCDEFGHJKLMNPQRSTWXYZ";
    private static string PASSWORD_CHARS_NUMERIC = "0123456789";
    private static string PASSWORD_CHARS_SPECIAL = "*$-+?_&=!%{}/";

    [DebuggerNonUserCode]
    public RandomPassword()
    {
    }

    public static string Generate() => Pass.RandomPassword.Generate(Pass.RandomPassword.DEFAULT_MIN_PASSWORD_LENGTH, Pass.RandomPassword.DEFAULT_MAX_PASSWORD_LENGTH);

    public static string Generate(int length) => Pass.RandomPassword.Generate(length, length);

    public static string Generate(int minLength, int maxLength)
    {
      if (minLength <= 0 | maxLength <= 0 | minLength > maxLength)
        ;
      char[][] chArray1 = new char[4][]
      {
        Pass.RandomPassword.PASSWORD_CHARS_LCASE.ToCharArray(),
        Pass.RandomPassword.PASSWORD_CHARS_UCASE.ToCharArray(),
        Pass.RandomPassword.PASSWORD_CHARS_NUMERIC.ToCharArray(),
        Pass.RandomPassword.PASSWORD_CHARS_SPECIAL.ToCharArray()
      };
      int[] numArray1 = new int[checked (chArray1.Length - 1 + 1)];
      int num1 = checked (numArray1.Length - 1);
      int index1 = 0;
      while (index1 <= num1)
      {
        numArray1[index1] = chArray1[index1].Length;
        checked { ++index1; }
      }
      int[] numArray2 = new int[checked (chArray1.Length - 1 + 1)];
      int num2 = checked (numArray2.Length - 1);
      int index2 = 0;
      while (index2 <= num2)
      {
        numArray2[index2] = index2;
        checked { ++index2; }
      }
      byte[] data = new byte[4];
      new RNGCryptoServiceProvider().GetBytes(data);
      Random random = new Random(((int) data[0] & (int) sbyte.MaxValue) << 24 | (int) (byte) ((uint) data[1] << 0) | (int) (byte) ((uint) data[2] << 0) | (int) data[3]);
      char[] chArray2 = minLength >= maxLength ? new char[checked (minLength - 1 + 1)] : new char[checked (random.Next(minLength - 1, maxLength) + 1)];
      int maxValue = checked (numArray2.Length - 1);
      int num3 = checked (chArray2.Length - 1);
      int index3 = 0;
      while (index3 <= num3)
      {
        int index4 = maxValue != 0 ? random.Next(0, maxValue) : 0;
        int index5 = numArray2[index4];
        int index6 = checked (numArray1[index5] - 1);
        int index7 = index6 != 0 ? random.Next(0, checked (index6 + 1)) : 0;
        chArray2[index3] = chArray1[index5][index7];
        if (index6 == 0)
        {
          numArray1[index5] = chArray1[index5].Length;
        }
        else
        {
          if (index6 != index7)
          {
            char ch = chArray1[index5][index6];
            chArray1[index5][index6] = chArray1[index5][index7];
            chArray1[index5][index7] = ch;
          }
          numArray1[index5] = checked (numArray1[index5] - 1);
        }
        if (maxValue == 0)
        {
          maxValue = checked (numArray2.Length - 1);
        }
        else
        {
          if (maxValue != index4)
          {
            int num4 = numArray2[maxValue];
            numArray2[maxValue] = numArray2[index4];
            numArray2[index4] = num4;
          }
          checked { --maxValue; }
        }
        checked { ++index3; }
      }
      return new string(chArray2);
    }
  }
}
