// Decompiled with JetBrains decompiler
// Type: MentQ.GlobalHelpers
// Assembly: جdk6氏صڤSnb, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: DC493AC2-8E19-4B7E-8F8B-A7CB6CD6346F
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-PSW.MSIL.Fareit.gen-125c88c0a34185a8a6c38ba5e7d461ccc5b9d8a1acc87871a618c3e15c32be42.exe

using System.Drawing;
using System.Drawing.Drawing2D;

namespace MentQ
{
  internal static class GlobalHelpers
  {
    public static readonly string DownArrowBase64String = " ";

    public static GraphicsPath GetRoundedRect(Rectangle baseRect, int radius)
    {
      int num = radius * 2;
      GraphicsPath roundedRect = new GraphicsPath();
      roundedRect.AddArc(new Rectangle(baseRect.X, baseRect.Y, num, num), -180f, 90f);
      roundedRect.AddArc(new Rectangle(baseRect.Width - num + baseRect.X, baseRect.Y, num, num), -90f, 90f);
      roundedRect.AddArc(new Rectangle(baseRect.Width - num + baseRect.X, baseRect.Height - num + baseRect.Y, num, num), 0.0f, 90f);
      roundedRect.AddArc(new Rectangle(baseRect.X, baseRect.Height - num + baseRect.Y, num, num), 90f, 90f);
      roundedRect.CloseAllFigures();
      return roundedRect;
    }

    public static GraphicsPath GetRoundedRect(RectangleF baseRect, float radius)
    {
      float num = radius * 2f;
      GraphicsPath roundedRect = new GraphicsPath();
      roundedRect.AddArc(new RectangleF(baseRect.X, baseRect.Y, num, num), -180f, 90f);
      roundedRect.AddArc(new RectangleF(baseRect.Width - num + baseRect.X, baseRect.Y, num, num), -90f, 90f);
      roundedRect.AddArc(new RectangleF(baseRect.Width - num + baseRect.X, baseRect.Height - num + baseRect.Y, num, num), 0.0f, 90f);
      roundedRect.AddArc(new RectangleF(baseRect.X, baseRect.Height - num + baseRect.Y, num, num), 90f, 90f);
      roundedRect.CloseAllFigures();
      return roundedRect;
    }

    public static void DrawDownFade(Graphics g, Rectangle area, Color finalColor)
    {
      using (LinearGradientBrush linearGradientBrush = new LinearGradientBrush(area, Color.Transparent, finalColor, 270f))
        g.FillRectangle((Brush) linearGradientBrush, area);
    }

    public static Image TuneTransparency(Image originalImage, int alpha, bool antialias)
    {
      Bitmap bitmap = new Bitmap(originalImage);
      int num = (int) byte.MaxValue / alpha;
      for (int x = 0; x < originalImage.Width; ++x)
      {
        for (int y = 0; y < originalImage.Height; ++y)
        {
          Color pixel = bitmap.GetPixel(x, y);
          if (pixel.A > (byte) 0)
            bitmap.SetPixel(x, y, Color.FromArgb(antialias ? (int) pixel.A / num : alpha, pixel));
        }
      }
      return (Image) bitmap;
    }

    public static Color ChangeColor(Color originalColor, int difference) => Color.FromArgb((int) originalColor.R + difference > (int) byte.MaxValue ? (int) byte.MaxValue : (int) originalColor.R + difference, (int) originalColor.G + difference > (int) byte.MaxValue ? (int) byte.MaxValue : (int) originalColor.G + difference, (int) originalColor.B + difference > (int) byte.MaxValue ? (int) byte.MaxValue : (int) originalColor.B + difference);

    public static Image Base64ToImage(string base64string) => (Image) null;
  }
}
