// Decompiled with JetBrains decompiler
// Type: ۣا΅޴�.ΠҏƜϫϒ
// Assembly: iJMJnUDAnLMGBkvrphkwZ, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8BCFE5CC-61DE-4CD2-8DAF-2FBF230839CD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-eaa07c9bde4c048e900f10410f38506ecb28371240e38a824e8043477d5e89a5.exe

using ş\u02E8\u1CFC\uFFFD\uFFFD;
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace \u06E3ا\u0385\u07B4\uFFFD
{
  internal class ΠҏƜϫϒ
  {
    public byte[] Ŏ\uFFFD\uDB77\uDC77\u07B9(
      byte[] _param1,
      byte[] _param2,
      byte[] _param3,
      byte[] _param4,
      byte[] _param5)
    {
      IntPtr num1 = this.\u0097\uDBB6\uDC33\uFFFD̆(Α꾯یƚ\uFFFD.꾯C\uFFFDϒ늻, Α꾯یƚ\uFFFD.\uFFFDɇՄۨ泮, Α꾯یƚ\uFFFD.У\uDAE4\uDD16ی恁);
      IntPtr num2;
      IntPtr hglobal = this.\u061DôK\uFFFD\uFFFD(num1, _param1, out num2);
      Α꾯یƚ\uFFFD.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authenticatedCipherModeInfo = new Α꾯یƚ\uFFFD.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(_param2, _param3, _param5);
      byte[] numArray1;
      using (authenticatedCipherModeInfo)
      {
        byte[] numArray2 = new byte[checked (this.\uFFFD丐\uDB8E\uDC0BU(num1) - 1 + 1)];
        int num3 = 0;
        uint num4 = Α꾯یƚ\uFFFD.εéٚӚܹ(num2, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, (byte[]) null, 0, ref num3, 0);
        if (num4 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", (object) num4));
        numArray1 = new byte[checked (num3 - 1 + 1)];
        uint num5 = Α꾯یƚ\uFFFD.εéٚӚܹ(num2, _param4, _param4.Length, ref authenticatedCipherModeInfo, numArray2, numArray2.Length, numArray1, numArray1.Length, ref num3, 0);
        if ((int) num5 == (int) Α꾯یƚ\uFFFD.ϱߡζ\u0089ی)
          throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
        if (num5 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", (object) num5));
      }
      int num6 = (int) Α꾯یƚ\uFFFD.jꓞZƟҟ(num2);
      Marshal.FreeHGlobal(hglobal);
      int num7 = (int) Α꾯یƚ\uFFFD.ņ\u002DˤΑ늻(num1, 0U);
      return numArray1;
    }

    private int \uFFFD丐\uDB8E\uDC0BU(IntPtr _param1)
    {
      byte[] numArray = this.\u0385ôj鈇O(_param1, Α꾯یƚ\uFFFD.\u07B4蠺\uFFFD뜸ב);
      return BitConverter.ToInt32(new byte[4]
      {
        numArray[4],
        numArray[5],
        numArray[6],
        numArray[7]
      }, 0);
    }

    private IntPtr \u0097\uDBB6\uDC33\uFFFD̆(string _param1, string _param2, string _param3)
    {
      IntPtr zero = IntPtr.Zero;
      uint num1 = Α꾯یƚ\uFFFD.\u07C2\uFFFDУɇک(out zero, _param1, _param2, 0U);
      if (num1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(_param3);
      uint num2 = Α꾯یƚ\uFFFD.JK\uFFFDήՄ(zero, Α꾯یƚ\uFFFD.cŔŎ\u07BBȨ, bytes, bytes.Length, 0);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", (object) num2));
      return zero;
    }

    private IntPtr \u061DôK\uFFFD\uFFFD(IntPtr _param1, byte[] _param2, out IntPtr _param3)
    {
      int int32 = BitConverter.ToInt32(this.\u0385ôj鈇O(_param1, Α꾯یƚ\uFFFD.\uFFFDԹcˤԹ), 0);
      IntPtr num1 = Marshal.AllocHGlobal(int32);
      byte[] numArray = this.\uFFFDɩ̲ņި(Α꾯یƚ\uFFFD.뫆ٗ\u05C9\u060C\uFFFD, BitConverter.GetBytes(1), BitConverter.GetBytes(_param2.Length), _param2);
      uint num2 = Α꾯یƚ\uFFFD.\u0333Uۣꓞٵ(_param1, IntPtr.Zero, Α꾯یƚ\uFFFD.Ω\uFFFD̮쐬늻, out _param3, num1, int32, numArray, numArray.Length, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", (object) num2));
      return num1;
    }

    private byte[] \u0385ôj鈇O(IntPtr _param1, string _param2)
    {
      int num1 = 0;
      uint num2 = Α꾯یƚ\uFFFD.\u0331ˤג2\u02F3(_param1, _param2, (byte[]) null, 0, ref num1, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", (object) num2));
      byte[] numArray = new byte[checked (num1 - 1 + 1)];
      uint num3 = Α꾯یƚ\uFFFD.\u0331ˤג2\u02F3(_param1, _param2, numArray, numArray.Length, ref num1, 0U);
      if (num3 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", (object) num3));
      return numArray;
    }

    public byte[] \uFFFDɩ̲ņި(params byte[][] _param1)
    {
      int num = 0;
      byte[][] numArray1 = _param1;
      int index1 = 0;
      while (index1 < numArray1.Length)
      {
        byte[] numArray2 = numArray1[index1];
        if (numArray2 != null)
          checked { num += numArray2.Length; }
        checked { ++index1; }
      }
      byte[] dst = new byte[checked (num - 1 + 1 - 1 + 1)];
      int dstOffset = 0;
      byte[][] numArray3 = _param1;
      int index2 = 0;
      while (index2 < numArray3.Length)
      {
        byte[] src = numArray3[index2];
        if (src != null)
        {
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, src.Length);
          checked { dstOffset += src.Length; }
        }
        checked { ++index2; }
      }
      return dst;
    }
  }
}
