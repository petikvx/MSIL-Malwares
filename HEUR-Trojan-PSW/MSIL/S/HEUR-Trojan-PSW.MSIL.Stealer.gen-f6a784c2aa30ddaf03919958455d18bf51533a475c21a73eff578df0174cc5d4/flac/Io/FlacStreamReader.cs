// Decompiled with JetBrains decompiler
// Type: flac.Io.FlacStreamReader
// Assembly: STAThreadAttrib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6EE3DE1A-E148-4FBA-A193-65BEA1824C00
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-PSW.MSIL.Stealer.gen-f6a784c2aa30ddaf03919958455d18bf51533a475c21a73eff578df0174cc5d4.exe

using System;
using System.IO;

namespace flac.Io
{
  public class FlacStreamReader
  {
    private FileStream stream_;
    private CRC crc_;
    private byte cache_;
    private int bitsInCache_;

    public long Debug_BytesRead => this.stream_.Position;

    public long Debug_BitsRead => this.stream_.Position * 8L - (long) this.bitsInCache_;

    public long BytesRemaining => this.stream_.Length - this.stream_.Position;

    public bool Done => this.BytesRemaining == 0L;

    public int BitsToByteBoundary => Bit.ModBy8((long) this.bitsInCache_);

    public CRC Crc => this.crc_;

    public FlacStreamReader(FileStream stream)
    {
      this.stream_ = stream;
      this.crc_ = new CRC();
    }

    public void Seek(long offset)
    {
      this.stream_.Seek(offset, SeekOrigin.Begin);
      this.cache_ = (byte) 0;
      this.bitsInCache_ = 0;
    }

    private void Update()
    {
      this.cache_ = (byte) this.stream_.ReadByte();
      this.bitsInCache_ = 8;
      if (!this.crc_.Running)
        return;
      this.crc_.AddByte(this.cache_);
    }

    private byte getBit()
    {
      if (this.bitsInCache_ == 0)
        this.Update();
      byte bit = (byte) ((uint) this.cache_ >> 7);
      this.cache_ <<= 1;
      --this.bitsInCache_;
      return bit;
    }

    private byte getByte()
    {
      byte cache = this.cache_;
      int bitsInCache = this.bitsInCache_;
      int num1 = 8 - bitsInCache;
      this.Update();
      byte num2 = (byte) ((uint) cache | (uint) this.cache_ >> bitsInCache);
      this.cache_ <<= num1;
      this.bitsInCache_ -= num1;
      return num2;
    }

    private byte getBits(int bitCount)
    {
      Debug.Assert(bitCount >= 0 && bitCount < 8);
      byte bits = 0;
      for (; bitCount > 0; --bitCount)
        bits = (byte) ((uint) bits << 1 | (uint) this.getBit());
      return bits;
    }

    public uint ReadBits(int bitCount)
    {
      uint num = 0;
      if (bitCount >= 16)
      {
        num = (uint) this.ReadUShort();
        bitCount -= 16;
      }
      if (bitCount >= 8)
      {
        num = num << 8 | (uint) this.getByte();
        bitCount -= 8;
      }
      return num << bitCount | (uint) this.getBits(bitCount);
    }

    public ulong ReadBitsAsULong(int bitCount)
    {
      ulong num = 0;
      if (bitCount >= 32)
      {
        num = (ulong) this.ReadUInt();
        bitCount -= 32;
      }
      return num << bitCount | (ulong) this.ReadBits(bitCount);
    }

    public sbyte ReadBitsAsSByte(int bitCount) => (sbyte) this.getBits(bitCount);

    public short ReadBitsAsShort(int bitCount) => (short) this.ReadBits(bitCount);

    public ushort ReadBitsAsUShort(int bitCount) => (ushort) this.ReadBits(bitCount);

    public int ReadBitsAsInt(int bitCount) => (int) this.ReadBits(bitCount);

    public uint ReadBitsAsUInt(int bitCount) => this.ReadBits(bitCount);

    public long ReadBitsAsLong(int bitCount) => (long) this.ReadBitsAsULong(bitCount);

    public sbyte ReadBit() => (sbyte) this.getBit();

    public byte ReadByte() => this.getByte();

    public ushort ReadUShort() => (ushort) ((uint) this.getByte() << 8 | (uint) this.getByte());

    public uint ReadUInt() => (((uint) this.getByte() << 8 | (uint) this.getByte()) << 8 | (uint) this.getByte()) << 8 | (uint) this.getByte();

    public int ReadInt() => (int) this.ReadUInt();

    public string ReadString(int bitCount)
    {
      string empty = string.Empty;
      int result;
      int num = Math.DivRem(bitCount, 8, out result);
      Debug.Assert(result == 0);
      for (; num > 0; --num)
        empty += ((char) this.getByte()).ToString();
      return empty;
    }

    public void SkipToByteBoundary()
    {
      int num = (int) this.ReadBits(this.BitsToByteBoundary);
    }

    public int GetUnaryBitStreamLength()
    {
      int unaryBitStreamLength = 0;
      while (this.getBit() != (byte) 1)
        ++unaryBitStreamLength;
      return unaryBitStreamLength;
    }

    public void SkipBits(int bitCount)
    {
      int bitsToByteBoundary = this.BitsToByteBoundary;
      if (bitCount - bitsToByteBoundary > 0)
      {
        int bits = (int) this.getBits(bitsToByteBoundary);
        bitCount -= bitsToByteBoundary;
        this.cache_ = (byte) 0;
        this.bitsInCache_ = 0;
        this.stream_.Position += (long) Bit.DivideBy8(bitCount);
        bitCount = Bit.ModBy8((long) bitCount);
      }
      int bits1 = (int) this.getBits(bitCount);
    }
  }
}
