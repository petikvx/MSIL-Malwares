// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Meta.AttributeMap
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Reflection;

namespace ProtoBuf.Meta
{
  internal abstract class AttributeMap
  {
    public abstract bool TryGet(string key, bool publicOnly, out object value);

    public bool TryGet(string key, out object value) => this.TryGet(key, true, out value);

    public abstract Type AttributeType { get; }

    public static AttributeMap[] Create(TypeModel model, Type type, bool inherit)
    {
      object[] customAttributes = type.GetCustomAttributes(inherit);
      AttributeMap[] attributeMapArray = new AttributeMap[customAttributes.Length];
      for (int index = 0; index < customAttributes.Length; ++index)
        attributeMapArray[index] = (AttributeMap) new AttributeMap.ReflectionAttributeMap((Attribute) customAttributes[index]);
      return attributeMapArray;
    }

    public static AttributeMap[] Create(
      TypeModel model,
      MemberInfo member,
      bool inherit)
    {
      object[] customAttributes = member.GetCustomAttributes(inherit);
      AttributeMap[] attributeMapArray = new AttributeMap[customAttributes.Length];
      for (int index = 0; index < customAttributes.Length; ++index)
        attributeMapArray[index] = (AttributeMap) new AttributeMap.ReflectionAttributeMap((Attribute) customAttributes[index]);
      return attributeMapArray;
    }

    public static AttributeMap[] Create(TypeModel model, Assembly assembly)
    {
      object[] customAttributes = assembly.GetCustomAttributes(false);
      AttributeMap[] attributeMapArray = new AttributeMap[customAttributes.Length];
      for (int index = 0; index < customAttributes.Length; ++index)
        attributeMapArray[index] = (AttributeMap) new AttributeMap.ReflectionAttributeMap((Attribute) customAttributes[index]);
      return attributeMapArray;
    }

    public abstract object Target { get; }

    private sealed class ReflectionAttributeMap : AttributeMap
    {
      private readonly Attribute attribute;

      public override object Target => (object) this.attribute;

      public override Type AttributeType => this.attribute.GetType();

      public override bool TryGet(string key, bool publicOnly, out object value)
      {
        foreach (MemberInfo fieldsAndProperty in Helpers.GetInstanceFieldsAndProperties(this.attribute.GetType(), publicOnly))
        {
          if (string.Equals(fieldsAndProperty.Name, key, StringComparison.OrdinalIgnoreCase))
          {
            PropertyInfo propertyInfo = fieldsAndProperty as PropertyInfo;
            if ((object) propertyInfo != null)
            {
              value = propertyInfo.GetValue((object) this.attribute, (object[]) null);
              return true;
            }
            value = (fieldsAndProperty as FieldInfo ?? throw new NotSupportedException(fieldsAndProperty.GetType().Name)).GetValue((object) this.attribute);
            return true;
          }
        }
        value = (object) null;
        return false;
      }

      public ReflectionAttributeMap(Attribute attribute) => this.attribute = attribute;
    }
  }
}
