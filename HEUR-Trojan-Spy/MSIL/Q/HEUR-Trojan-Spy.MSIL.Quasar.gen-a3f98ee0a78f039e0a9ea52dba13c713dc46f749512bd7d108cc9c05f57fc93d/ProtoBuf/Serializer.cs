// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Serializer
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using ProtoBuf.Meta;
using System;
using System.Collections.Generic;
using System.IO;

namespace ProtoBuf
{
  public static class Serializer
  {
    private const string ProtoBinaryField = "proto";
    public const int ListItemTag = 1;

    public static string GetProto<T>() => RuntimeTypeModel.Default.GetSchema(RuntimeTypeModel.Default.MapType(typeof (T)));

    public static T DeepClone<T>(T instance) => (object) instance != null ? (T) RuntimeTypeModel.Default.DeepClone((object) instance) : instance;

    public static T Merge<T>(Stream source, T instance) => (T) RuntimeTypeModel.Default.Deserialize(source, (object) instance, typeof (T));

    public static T Deserialize<T>(Stream source) => (T) RuntimeTypeModel.Default.Deserialize(source, (object) null, typeof (T));

    public static void Serialize<T>(Stream destination, T instance)
    {
      if ((object) instance == null)
        return;
      RuntimeTypeModel.Default.Serialize(destination, (object) instance);
    }

    public static TTo ChangeType<TFrom, TTo>(TFrom instance)
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        Serializer.Serialize<TFrom>((Stream) memoryStream, instance);
        memoryStream.Position = 0L;
        return Serializer.Deserialize<TTo>((Stream) memoryStream);
      }
    }

    public static void PrepareSerializer<T>()
    {
    }

    public static IEnumerable<T> DeserializeItems<T>(
      Stream source,
      PrefixStyle style,
      int fieldNumber)
    {
      return RuntimeTypeModel.Default.DeserializeItems<T>(source, style, fieldNumber);
    }

    public static T DeserializeWithLengthPrefix<T>(Stream source, PrefixStyle style) => Serializer.DeserializeWithLengthPrefix<T>(source, style, 0);

    public static T DeserializeWithLengthPrefix<T>(
      Stream source,
      PrefixStyle style,
      int fieldNumber)
    {
      RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
      return (T) runtimeTypeModel.DeserializeWithLengthPrefix(source, (object) null, runtimeTypeModel.MapType(typeof (T)), style, fieldNumber);
    }

    public static T MergeWithLengthPrefix<T>(Stream source, T instance, PrefixStyle style)
    {
      RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
      return (T) runtimeTypeModel.DeserializeWithLengthPrefix(source, (object) instance, runtimeTypeModel.MapType(typeof (T)), style, 0);
    }

    public static void SerializeWithLengthPrefix<T>(
      Stream destination,
      T instance,
      PrefixStyle style)
    {
      Serializer.SerializeWithLengthPrefix<T>(destination, instance, style, 0);
    }

    public static void SerializeWithLengthPrefix<T>(
      Stream destination,
      T instance,
      PrefixStyle style,
      int fieldNumber)
    {
      RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
      runtimeTypeModel.SerializeWithLengthPrefix(destination, (object) instance, runtimeTypeModel.MapType(typeof (T)), style, fieldNumber);
    }

    public static bool TryReadLengthPrefix(Stream source, PrefixStyle style, out int length)
    {
      int bytesRead;
      length = ProtoReader.ReadLengthPrefix(source, false, style, out int _, out bytesRead);
      return bytesRead > 0;
    }

    public static bool TryReadLengthPrefix(
      byte[] buffer,
      int index,
      int count,
      PrefixStyle style,
      out int length)
    {
      using (Stream source = (Stream) new MemoryStream(buffer, index, count))
        return Serializer.TryReadLengthPrefix(source, style, out length);
    }

    public static void FlushPool() => BufferPool.Flush();

    public static class NonGeneric
    {
      public static object DeepClone(object instance) => instance != null ? RuntimeTypeModel.Default.DeepClone(instance) : (object) null;

      public static void Serialize(Stream dest, object instance)
      {
        if (instance == null)
          return;
        RuntimeTypeModel.Default.Serialize(dest, instance);
      }

      public static object Deserialize(Type type, Stream source) => RuntimeTypeModel.Default.Deserialize(source, (object) null, type);

      public static object Merge(Stream source, object instance)
      {
        if (instance == null)
          throw new ArgumentNullException(nameof (instance));
        return RuntimeTypeModel.Default.Deserialize(source, instance, instance.GetType(), (SerializationContext) null);
      }

      public static void SerializeWithLengthPrefix(
        Stream destination,
        object instance,
        PrefixStyle style,
        int fieldNumber)
      {
        if (instance == null)
          throw new ArgumentNullException(nameof (instance));
        RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
        runtimeTypeModel.SerializeWithLengthPrefix(destination, instance, runtimeTypeModel.MapType(instance.GetType()), style, fieldNumber);
      }

      public static bool TryDeserializeWithLengthPrefix(
        Stream source,
        PrefixStyle style,
        Serializer.TypeResolver resolver,
        out object value)
      {
        value = RuntimeTypeModel.Default.DeserializeWithLengthPrefix(source, (object) null, (Type) null, style, 0, resolver);
        return value != null;
      }

      public static bool CanSerialize(Type type) => RuntimeTypeModel.Default.IsDefined(type);
    }

    public static class GlobalOptions
    {
      [Obsolete("Please use RuntimeTypeModel.Default.InferTagFromNameDefault instead (or on a per-model basis)", false)]
      public static bool InferTagFromName
      {
        get => RuntimeTypeModel.Default.InferTagFromNameDefault;
        set => RuntimeTypeModel.Default.InferTagFromNameDefault = value;
      }
    }

    public delegate Type TypeResolver(int fieldNumber);
  }
}
