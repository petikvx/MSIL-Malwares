// Decompiled with JetBrains decompiler
// Type: Costura.AssemblyLoader
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 1950B17F-8BE4-40AB-B698-96070A0C2297
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Win.Ransomware.Jigsaw-6866216-0-9580e6c4deba3bd46419a402b6309f77c2ed47ad62299c82ec8578400c2a3a64.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace Costura
{
  [CompilerGenerated]
  internal static class AssemblyLoader
  {
    private static readonly Dictionary<string, bool> nullCache;
    private static readonly Dictionary<string, string> assemblyNames;
    private static readonly Dictionary<string, string> symbolNames;
    private static ResolveEventHandler CS\u0024\u003C\u003E9__CachedAnonymousMethodDelegate1;

    private static string CultureToString(CultureInfo culture)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Assembly ReadExistingAssembly(AssemblyName name)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void CopyTo(Stream source, Stream destination)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Stream LoadStream(string fullname)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Stream LoadStream(Dictionary<string, string> resourceNames, string name)
    {
      // ISSUE: unable to decompile the method.
    }

    private static byte[] ReadStream(Stream stream)
    {
      // ISSUE: unable to decompile the method.
    }

    private static Assembly ReadFromEmbeddedResources(
      Dictionary<string, string> assemblyNames,
      Dictionary<string, string> symbolNames,
      AssemblyName requestedAssemblyName)
    {
      // ISSUE: unable to decompile the method.
    }

    public static Assembly ResolveAssembly(string assemblyName)
    {
      // ISSUE: unable to decompile the method.
    }

    static AssemblyLoader()
    {
      // ISSUE: unable to decompile the method.
    }

    private static Assembly \u003CAttach\u003Eb__0(object s, ResolveEventArgs e)
    {
      // ISSUE: unable to decompile the method.
    }

    public static void Attach()
    {
      // ISSUE: unable to decompile the method.
    }

    static string \u200C⁮⁭‍⁪‏‏⁪⁮‍⁭‏‎‏‌‭‍‎‭⁬‏⁯‮‏‍‍⁫⁪‍‪⁯⁪‫‎‌⁫⁬‌⁮⁯‮([In] CultureInfo obj0) => obj0.Name;

    static AppDomain \u206B‎‏‌‬⁭‫⁬⁭‪‬‍‭⁮‬‮‪‮‬‪‬‮⁫‬​⁪⁫‌‎‎⁭⁬‎‌⁬⁯⁮‬⁪⁭‮() => AppDomain.CurrentDomain;

    static Assembly[] \u200E‭‌⁮‍⁮‪⁪⁭‮⁮⁫‍‬⁬⁫⁬‍⁫‎‌⁫‭‭⁪⁮‪​‮‏‬‌‌‌‌‎‍‬⁬‮‮([In] AppDomain obj0) => obj0.GetAssemblies();

    static AssemblyName \u206B‌⁮​‏‬⁬‌‏‪‎‎​‬‎‭⁬⁯‫‌⁫‪⁪⁭⁪⁮⁪⁪​‏​⁭⁭‮‮⁬​‪‪‬‮([In] Assembly obj0) => obj0.GetName();

    static string \u200D‪⁪⁮⁫⁭‫​‍‮⁮⁮⁯⁪⁭‎​⁭⁯‏⁫‬⁭⁭‎‌‍‪‫‮⁬⁮‏‍⁬‮‫⁪⁮‪‮([In] AssemblyName obj0) => obj0.Name;

    static bool \u206F‫‎‫‭⁪⁬‭⁪‪‭‏‏⁬‎⁪⁮⁪‪⁮‌⁮⁮‮‏‍‎⁭‏‬‫​⁫⁬‫⁯‍⁮⁪⁬‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return string.Equals(obj0, obj1, obj2);
    }

    static CultureInfo \u202C⁪‏‍⁭⁪⁬‍‍‫‎⁭‬‮‫‎‫‭⁭⁯⁫⁭⁬‪‭‫⁪‎⁬⁭‍​‭⁬​‏⁮‮‪‏‮([In] AssemblyName obj0) => obj0.CultureInfo;

    static void \u202D⁫‎⁫⁮‪‍⁯⁮‍‌‏‎‫‫‎‭⁬‪‪⁯‌‮‭‍⁭‬‭​‎‮​‫‌⁭‫‌‎‍‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static int \u206E‍⁫⁪‎⁫⁮‮‭‪‪⁫‫‏‎‭⁪‏‌‎‫‭‫‬⁬⁬⁮‪⁬‫⁫‫‬‬‬⁮⁯‪‍‫‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static Assembly \u206F‍‪⁭‭⁯⁭‬‏⁯‮‍‌⁪⁬⁭‌​‭‏⁮‌‭‪‌‬​‬​‮‬‪‍⁭‫⁪‍‫⁭⁯‮() => Assembly.GetExecutingAssembly();

    static bool \u202E⁫‏‫‏⁬‪‌‍⁯⁬⁭‎​‍⁪⁪‭⁯‪‍‎‮⁮⁫‬‭⁮‍‬​‌‪‎‍‏⁫⁪⁪‍‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static Stream \u206B‫‪⁫‪‍⁬‎⁯​‮‫‍‏⁯⁫‍‬‎⁮‪⁯‏‮‌‏⁯‏‌⁬‏‭‍‮⁬‬‎‮‌⁯‮([In] Assembly obj0, [In] string obj1) => obj0.GetManifestResourceStream(obj1);

    static DeflateStream \u200C⁪​‎⁯⁯⁫⁬‬​​‎⁪‮⁭‪‎⁪​⁯‍⁫⁫‫⁬‭​‏⁫⁬‎‮‭⁪⁫‫⁫‪‎⁭‮(
      [In] Stream obj0,
      [In] CompressionMode obj1)
    {
      return new DeflateStream(obj0, obj1);
    }

    static MemoryStream \u206F⁪‏⁪⁬⁫‬⁭‍​​‌⁪⁫⁮⁫‮‫⁫⁭‍‎⁬‭‪‍⁭‪⁭‫⁮‌‍⁯‮‌⁪​‫‭‮() => new MemoryStream();

    static void \u206A‪⁪‍‪⁬⁭‎‬⁮‎⁪‪⁪⁯‮⁭‎⁮‌⁮‏‏⁭⁫‫‍⁯‍‎​‌⁯‍⁫‌‏⁭⁭⁭‮([In] Stream obj0, [In] long obj1) => obj0.Position = obj1;

    static void \u206C⁪​‬‏⁪⁫‍⁪⁪‌‭‎‪⁪⁫⁭‪‪⁮⁯‪⁬‪⁬‍⁬‏⁯​⁫‍‌‭​⁭​⁬⁪‪‮([In] IDisposable obj0) => obj0.Dispose();

    static long \u206C‬⁪‬‍‪​⁮⁮⁪⁫‫⁯⁮‫‮⁭⁬⁯‌⁫‮‮‪⁭‫⁬⁯‏⁪‍⁮​⁪‮​⁬⁬‭‌‮([In] Stream obj0) => obj0.Length;

    static string \u206F‌‏‌⁮‎⁬‏⁪​‏‭⁫‮‌‫‏⁭‏⁬⁯⁭⁮‫‮‮​​⁫⁪⁭⁪⁮⁬‬​‎⁪⁭⁬‮([In] string obj0) => obj0.ToLowerInvariant();

    static bool \u200C‍‌⁪‌‌‌⁬⁫‪⁮‭⁪‮‫‮‏‍‏‏⁮⁯‪​‭‬⁭⁯⁮⁬‌⁫‬⁬⁯‭‏‌⁯‭‮([In] string obj0) => string.IsNullOrEmpty(obj0);

    static string \u202C‎‪⁬⁯‍‬‌‏‎‎‭‍‭⁪‫⁬⁬‭⁯⁮‬⁫⁬‭​‬‏⁬⁪‪​⁪‮‎‎‫‭‍⁭‮(
      [In] string obj0,
      [In] object obj1,
      [In] object obj2)
    {
      return string.Format(obj0, obj1, obj2);
    }

    static Assembly \u200E⁪​⁬‭‬‭‭‬‎​⁫⁪‍⁫‪‏⁪⁬‍⁫⁪‏‌‫⁭‍⁬‭⁭⁬​‍‍⁬⁭⁬⁬‌‎‮([In] byte[] obj0, [In] byte[] obj1) => Assembly.Load(obj0, obj1);

    static Assembly \u206A⁭‏⁪‭‎‭⁯⁯⁯‫‍⁮‎‍⁮‬‎‬‎⁪⁬‪‪⁭‬‪⁪⁭‫⁭⁭‪‏​‮⁫⁫⁯‎‮([In] byte[] obj0) => Assembly.Load(obj0);

    static AssemblyName \u202D‬‪‬⁯‌‬⁪⁯⁯​⁯⁫‬‌‌‪‎‪‌‬‪⁮‎⁭‫‫‍‭‎⁯‭⁯‭⁪⁫⁪‬‮‪‮([In] string obj0) => new AssemblyName(obj0);

    static AssemblyNameFlags \u202B⁮⁬‍‫⁫‏‮‏‬⁫‭⁭‎‬‮‫‮‭‮⁯‎⁪‍‌⁬⁫‌⁭‫‫⁯‫⁬​⁭‮‌‭‏‮(
      [In] AssemblyName obj0)
    {
      return obj0.Flags;
    }

    static Assembly \u202E‏‍‮⁪⁭​⁪‬‬‬⁮‭⁬⁬⁫‮‎​‎‪‌‪‪‌⁫‎‏‎‪​‬‫​‮⁫⁯‮‎‪‮([In] AssemblyName obj0) => Assembly.Load(obj0);

    static string \u206B⁮‫‌‍⁭⁬⁪⁫‭⁭‌⁬⁪⁫⁭‏‍‍⁫⁬⁭‎‎⁪⁬‍​⁬⁮⁬‍‪⁮‭⁭‎‍‌‭‮([In] ResolveEventArgs obj0) => obj0.Name;

    static void \u202B⁫‍‬⁪​⁪‍⁭‍‬‭⁪‬‫⁭‫‏‏⁫‭⁭⁭⁬‮⁮‬⁪‬⁫⁬⁫‌⁮‎‮⁫‮⁭‌‮(
      [In] AppDomain obj0,
      [In] ResolveEventHandler obj1)
    {
      obj0.AssemblyResolve += obj1;
    }
  }
}
