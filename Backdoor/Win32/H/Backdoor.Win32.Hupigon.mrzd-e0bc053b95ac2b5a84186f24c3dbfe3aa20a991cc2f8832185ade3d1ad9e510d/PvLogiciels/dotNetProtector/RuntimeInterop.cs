// Decompiled with JetBrains decompiler
// Type: PvLogiciels.dotNetProtector.RuntimeInterop
// Assembly: Cursor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4B47A1CB-CB7F-48AE-B796-614CD24341D7
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.Win32.Hupigon.mrzd-e0bc053b95ac2b5a84186f24c3dbfe3aa20a991cc2f8832185ade3d1ad9e510d.exe

using \u0081é;
using \u0082\u00BC;
using ø;
using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace PvLogiciels.dotNetProtector
{
  public class RuntimeInterop : IRuntime
  {
    internal Assembly[] õ;
    internal Assembly \u0081\u00BE;
    internal string \u0082\u00B4;

    private static unsafe byte* Ø(Assembly _param0) => (byte*) Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]).ToPointer();

    internal RuntimeInterop() => this.õ = new Assembly[0];

    internal unsafe Assembly \u0081ã(IntPtr _param1)
    {
      int id = AppDomain.CurrentDomain.Id;
      byte* numPtr = (byte*) \u0082\u00BB.\u00B9(_param1.ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      _param1 = ptr;
      int num1 = Marshal.ReadInt32(ptr);
      int length1 = Marshal.ReadInt32(_param1, 4);
      int length2 = Marshal.ReadInt32(_param1, 8);
      IntPtr source1 = (IntPtr) (void*) (numPtr + 12);
      IntPtr source2 = (IntPtr) (void*) (numPtr + length1 + 12);
      byte[] numArray = new byte[length1];
      byte[] destination = numArray;
      int length3 = length1;
      Marshal.Copy(source1, destination, 0, length3);
      Assembly assembly;
      if (length2 != 0)
      {
        byte[] rawSymbolStore = new byte[length2];
        Marshal.Copy(source2, numArray, 0, length2);
        assembly = Assembly.Load(numArray, rawSymbolStore);
      }
      else
        assembly = Assembly.Load(numArray);
      Marshal.FreeCoTaskMem(_param1);
      if ((object) assembly != null && num1 >= 0)
      {
        Type[] types = assembly.GetTypes();
        IntPtr num2 = types[types.Length - 1].TypeHandle.Value;
        \u0082\u00BB.\u0081\u0084((byte*) Marshal.GetHINSTANCE(assembly.GetLoadedModules()[0]).ToPointer(), num2.ToPointer(), num1, id);
      }
      return assembly;
    }

    internal static unsafe void Ò(Assembly _param0)
    {
      string assemblyString = PvLogiciels.dotNetProtector.Runtime.GetAssemblyString(_param0);
      IntPtr ptr = IntPtr.Zero;
      if (assemblyString != (string) null)
        ptr = Marshal.StringToCoTaskMemAnsi(assemblyString);
      \u0082\u00BB.\u0081\u0084((byte*) Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]).ToPointer(), (void*) 0, (int*) 0, (sbyte*) ptr.ToPointer(), AppDomain.CurrentDomain.Id);
      if (!(ptr != IntPtr.Zero))
        return;
      Marshal.FreeCoTaskMem(ptr);
    }

    public virtual Assembly GetEntryAssembly()
    {
      if ((object) \u0081ê.\u0081\u009A != null)
        return \u0081ê.\u0081\u009A;
      Assembly entryAssembly = Assembly.GetEntryAssembly();
      if ((object) entryAssembly != null)
      {
        \u0081ê.\u0081\u009A = entryAssembly;
        return entryAssembly;
      }
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if (executingAssembly.FullName.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      \u0081ê.\u0081\u009A = executingAssembly;
      return executingAssembly;
    }

    public static IRuntime InitRuntime()
    {
      RuntimeInterop runtimeInterop = new RuntimeInterop();
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        AppDomain.CurrentDomain.ProcessExit += new EventHandler(RuntimeInterop.AppDomain_ProcessExit);
        return (IRuntime) runtimeInterop;
      }
      AppDomain.CurrentDomain.DomainUnload += new EventHandler(new \u0081ß(AppDomain.CurrentDomain, AppDomain.CurrentDomain.Id).\u0098);
      return (IRuntime) runtimeInterop;
    }

    public static void AppDomain_ProcessExit(object sender, EventArgs e)
    {
      GC.Collect();
      GC.WaitForPendingFinalizers();
      \u0082\u00BB.\u00BF();
    }

    public virtual void NGenInitRuntime()
    {
    }

    public virtual ulong GetComputerHash() => \u0082\u00BB.\u0081\u008D();

    public virtual long GetMacAddress() => \u0082\u00BB.Ë();

    public virtual ulong GetBiosHash() => \u0082\u00BB.Ó();

    public virtual int UnloadDomain() => \u0082\u00BB.\u0095(AppDomain.CurrentDomain.Id);

    public virtual unsafe int InitModule(Type pReserved1, IntPtr pReserved2, string Reserved3)
    {
      IntPtr ptr = IntPtr.Zero;
      if (Reserved3 != (string) null)
        ptr = Marshal.StringToCoTaskMemAnsi(Reserved3);
      IntPtr num1 = pReserved1.TypeHandle.Value;
      int num2 = \u0082\u00BB.\u0081\u0084((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer(), num1.ToPointer(), (int*) pReserved2.ToPointer(), (sbyte*) ptr.ToPointer(), AppDomain.CurrentDomain.Id);
      if (ptr != IntPtr.Zero)
        Marshal.FreeCoTaskMem(ptr);
      if (num2 == 2)
      {
        this.\u0081\u00BE = pReserved1.Assembly;
        this.\u0082\u00B4 = pReserved1.Assembly.GetName().Name;
        int length = \u0082\u00BB.\u0081\u009D();
        if (length != 0)
        {
          this.õ = new Assembly[length];
          int index = 0;
          if (0 < length)
          {
            do
            {
              this.õ[index] = (Assembly) null;
              ++index;
            }
            while (index < length);
          }
        }
      }
      return num2;
    }

    public virtual unsafe string DesignLicenseKey(Type pReserved1, string pReserved2)
    {
      IntPtr ptr = Marshal.AllocCoTaskMem(IntPtr.Size);
      IntPtr coTaskMemAnsi = Marshal.StringToCoTaskMemAnsi(pReserved2);
      \u0082\u00BB.à((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer(), (sbyte*) coTaskMemAnsi.ToPointer(), (sbyte**) ptr.ToPointer());
      IntPtr num = Marshal.ReadIntPtr(ptr);
      string str = (string) null;
      if (num != IntPtr.Zero)
      {
        string stringAnsi = Marshal.PtrToStringAnsi(num);
        Marshal.FreeHGlobal(num);
        str = stringAnsi;
      }
      Marshal.FreeCoTaskMem(ptr);
      if (!(coTaskMemAnsi != IntPtr.Zero))
        return str;
      Marshal.FreeCoTaskMem(coTaskMemAnsi);
      return str;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool SameSoftware(Assembly pReserved, IntPtr pSoft, ulong SwMajor)
    {
      int num;
      if (\u0082\u00BB.\u0081\u00A7((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pSoft.ToPointer(), SwMajor, &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool IsLicensed(Assembly pReserved, string licenseKey, [MarshalAs(UnmanagedType.U1)] bool usb)
    {
      IntPtr coTaskMemAnsi = Marshal.StringToCoTaskMemAnsi(licenseKey);
      int num1 = usb ? 1 : 0;
      int num2 = \u0082\u00BB.\u0081\u00AB((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) coTaskMemAnsi.ToPointer(), num1);
      if (coTaskMemAnsi != IntPtr.Zero)
        Marshal.FreeCoTaskMem(coTaskMemAnsi);
      return num2 != 0;
    }

    public virtual unsafe int HardwareScore(Assembly pReserved, ulong HwConfig1, ulong HwConfig2)
    {
      int num;
      if (\u0082\u00BB.\u00A2((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), HwConfig1, HwConfig2, &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num;
    }

    public virtual unsafe IntPtr GenProductKey(
      Assembly pReserved,
      IntPtr pKeys,
      uint LicenseID,
      ulong data)
    {
      sbyte* numPtr;
      if (\u0082\u00BB.\u0081\u00B6((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), LicenseID, data, &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr GenProductKey(
      Assembly pReserved,
      IntPtr pKeys,
      uint LicenseID)
    {
      sbyte* numPtr;
      if (\u0082\u00BB.\u0081\u00B6((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), LicenseID, &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe uint GetLicenseId(Assembly pReserved, IntPtr pProductKey)
    {
      uint licenseId;
      if (\u0082\u00BB.\u0081\u00BD((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pProductKey.ToPointer(), &licenseId) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return licenseId;
    }

    public virtual unsafe ulong GetProductkeyData(Assembly pReserved, IntPtr pProductKey)
    {
      uint num;
      ulong productkeyData;
      if (\u0082\u00BB.\u0081\u00BD((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pProductKey.ToPointer(), &num, &productkeyData) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return productkeyData;
    }

    public virtual unsafe IntPtr DecodeActivationString(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr pActivationString)
    {
      byte* numPtr;
      if (\u0082\u00BB.\u0081Å((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), (sbyte*) pActivationString.ToPointer(), &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr EncodeActivationRequest(Assembly pReserved, IntPtr preq)
    {
      sbyte* numPtr;
      if (\u0082\u00BB.Ç((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), preq.ToPointer(), &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) numPtr;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration)
    {
      sbyte* config;
      if (\u0082\u00BB.\u0081Ò((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, &config) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      IntPtr pAssemblyFile)
    {
      sbyte* config;
      if (\u0082\u00BB.\u0081Ò((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, (sbyte*) pAssemblyFile.ToPointer(), &config) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe IntPtr GetConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      AssemblyName Name)
    {
      string name = Name.Name;
      byte[] bytes = Encoding.UTF8.GetBytes(string.Concat((object) "\0"));
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      sbyte* config;
      int num2 = \u0082\u00BB.\u0081Ò((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, (byte*) num1.ToPointer(), (ushort) Name.Version.Major, (ushort) Name.Version.Minor, &config);
      gcHandle.Free();
      if (num2 == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) config;
    }

    public virtual unsafe string GetThumbPrint(Assembly pReserved)
    {
      \u0081Ð ð;
      if (\u0082\u00BB.\u0081Ø((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (byte*) &ð) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      StringBuilder stringBuilder = new StringBuilder();
      int num = 0;
      do
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        stringBuilder.Append(string.Format("{0:x}", (object) ^(byte&) (num + (IntPtr) &ð)).PadLeft(2, '0'));
        ++num;
      }
      while (num < 20);
      return stringBuilder.ToString();
    }

    public virtual unsafe byte[] GetConfigForDemo(Assembly pReserved)
    {
      uint length;
      byte* numPtr;
      if (\u0082\u00BB.\u0081µ((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &length, &numPtr) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      byte[] destination = new byte[(int) length];
      IntPtr num = (IntPtr) (void*) numPtr;
      Marshal.Copy(num, destination, 0, (int) length);
      Marshal.FreeCoTaskMem(num);
      return destination;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity)
    {
      sbyte* usbConfig;
      if (\u0082\u00BB.\u0081è((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, &usbConfig) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity,
      IntPtr pAssemblyFile)
    {
      sbyte* usbConfig;
      if (\u0082\u00BB.\u0081è((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, (sbyte*) pAssemblyFile.ToPointer(), &usbConfig) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GetUsbConfig(
      Assembly pReserved,
      uint LicenseID,
      ushort ActivationDuration,
      ulong UsbHash,
      ulong UsbIdentity,
      AssemblyName Name)
    {
      string name = Name.Name;
      byte[] bytes = Encoding.UTF8.GetBytes(string.Concat((object) "\0"));
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      sbyte* usbConfig;
      int num2 = \u0082\u00BB.\u0081è((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), LicenseID, ActivationDuration, UsbHash, UsbIdentity, (byte*) num1.ToPointer(), (ushort) Name.Version.Major, (ushort) Name.Version.Minor, &usbConfig);
      gcHandle.Free();
      if (num2 == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbConfig;
    }

    public virtual unsafe IntPtr GenerateLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq)
    {
      sbyte* license;
      if (\u0082\u00BB.\u0081ð((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), &license) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) license;
    }

    public virtual unsafe IntPtr GenerateLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq,
      int tolerance,
      [MarshalAs(UnmanagedType.U1)] bool ignoreMinor,
      long RuntimeLicensesLimit)
    {
      sbyte* license;
      if (\u0082\u00BB.\u0081ð((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), tolerance, ignoreMinor ? 1 : 0, RuntimeLicensesLimit, &license) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) license;
    }

    public virtual unsafe IntPtr GenerateUsbLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq)
    {
      sbyte* usbLicense;
      if (\u0082\u00BB.\u0081\u00AD((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), &usbLicense, (byte) 0) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbLicense;
    }

    public virtual unsafe IntPtr GenerateUsbLicense(
      Assembly pReserved,
      IntPtr pKeys,
      IntPtr preq,
      int tolerance,
      [MarshalAs(UnmanagedType.U1)] bool ignoreMinor,
      long RuntimeLicensesLimit)
    {
      sbyte* usbLicense;
      if (\u0082\u00BB.\u0081\u00AD((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), pKeys.ToPointer(), preq.ToPointer(), tolerance, ignoreMinor ? 1 : 0, RuntimeLicensesLimit, &usbLicense, (byte) 0) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return (IntPtr) (void*) usbLicense;
    }

    public virtual unsafe Assembly ResolveAssembly(string Name)
    {
      // ISSUE: untyped stack allocation
      int num1 = (int) __untypedstackalloc(\u0082\u00BB.Ù());
      try
      {
        AssemblyName assemblyName = new AssemblyName(Name);
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        uint exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u0082\u00BB.\u0082\u00AE((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num2 = 0;
        \u0082\u00BB.\u0081\u009B((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
            return (Assembly) null;
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num2 = (uint) \u0082\u00BB.\u0084((void*) Marshal.GetExceptionPointers());
            if (num2 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          if (num2 != 0U)
            throw;
        }
        finally
        {
          \u0082\u00BB.æ((void*) num1, (int) num2);
        }
      }
      byte[] bytes = Encoding.UTF8.GetBytes(Name);
      GCHandle gcHandle = GCHandle.Alloc((object) bytes, GCHandleType.Pinned);
      IntPtr num3 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) bytes, 0);
      int index = \u0082\u00BB.\u00B2(num3.ToPointer());
      if (index >= 0)
      {
        Assembly[] õ = this.õ;
        if (index < õ.Length)
        {
          if ((object) õ[index] == null)
            this.õ[index] = this.\u0081ã(num3);
          gcHandle.Free();
          return this.õ[index];
        }
      }
      gcHandle.Free();
      return new AssemblyName(Name).Name == this.\u0082\u00B4 ? this.\u0081\u00BE : (Assembly) null;
    }

    public virtual int ExecuteEmbLockAssembly(Type pReserved1, int Reserved2) => \u0081Ú.\u0081\u00D7(pReserved1.Assembly, Reserved2);

    public virtual unsafe Assembly GetEmbLockAssembly(Type pReserved1)
    {
      byte* numPtr = (byte*) \u0082\u00BB.ñ((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      int length1 = Marshal.ReadInt32(ptr);
      IntPtr source = (IntPtr) (void*) (numPtr + 4);
      byte[] rawAssembly = new byte[length1];
      byte[] destination = rawAssembly;
      int length2 = length1;
      Marshal.Copy(source, destination, 0, length2);
      Assembly embLockAssembly = Assembly.Load(rawAssembly);
      Marshal.FreeCoTaskMem(ptr);
      return embLockAssembly;
    }

    public virtual unsafe Assembly GetEmbLockAssemblyName(Type pReserved1)
    {
      byte* numPtr = (byte*) \u0082\u00BB.\u00F7((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      string stringAnsi = Marshal.PtrToStringAnsi(ptr);
      Marshal.FreeCoTaskMem(ptr);
      Assembly lockAssemblyName = (Assembly) null;
      try
      {
        lockAssemblyName = Assembly.Load(stringAnsi);
      }
      catch (Exception ex)
      {
      }
      return lockAssemblyName;
    }

    public virtual unsafe ArrayList GetEmbLockAssemblyServices(Type pReserved1)
    {
      byte* ptr1 = (byte*) \u0082\u00BB.\u0082\u008B((byte*) Marshal.GetHINSTANCE(pReserved1.Assembly.GetLoadedModules()[0]).ToPointer());
      if ((IntPtr) ptr1 == IntPtr.Zero)
        return (ArrayList) null;
      IntPtr ptr2 = (IntPtr) (void*) ptr1;
      ArrayList assemblyServices = new ArrayList();
      if (*ptr1 != (byte) 0)
      {
        do
        {
          string stringAnsi = Marshal.PtrToStringAnsi((IntPtr) (void*) ptr1);
          assemblyServices.Add((object) stringAnsi);
          ptr1 = (byte*) (stringAnsi.Length + (IntPtr) ptr1 + 1);
        }
        while (*ptr1 != (byte) 0);
      }
      Marshal.FreeCoTaskMem(ptr2);
      return assemblyServices;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool ProductKeyChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082\u00BB.\u0082\u0096((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool ConfigStringChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082\u00BB.\u0082\u00A1((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool LicenseKeyChecksumIsOk(Assembly pReserved, IntPtr pString)
    {
      int num;
      if (\u0082\u00BB.\u0081Ù((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (sbyte*) pString.ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    public virtual unsafe bool IsDemo(Assembly pReserved)
    {
      int num;
      if (\u0082\u00BB.\u0082\u00AB((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) == 0)
        throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
      return num != 0;
    }

    public virtual unsafe int DaysLeft(Assembly pReserved)
    {
      int num;
      return \u0082\u00BB.\u0082\u00AF((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) != 0 ? num : throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
    }

    public virtual unsafe int MinutesLeft(Assembly pReserved)
    {
      int num;
      return \u0082\u00BB.\u0082\u00B9((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), &num) != 0 ? num : throw new LicenseException(typeof (PvLogiciels.dotNetProtector.Runtime));
    }

    public virtual unsafe uint GetProductID(Assembly pReserved) => \u0082\u00BB.\u0082((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer());

    public virtual void UnloadAppdomain(AppDomain domain)
    {
      int id = domain.Id;
      AppDomain.Unload(domain);
      \u0082\u00BB.\u0095(id);
    }

    public virtual unsafe IntPtr StartUsbDetect() => (IntPtr) \u0082\u00BB.\u0081ø();

    public virtual unsafe void EndUsbDetect(IntPtr handle) => \u0082\u00BB.\u008B(handle.ToPointer());

    public virtual unsafe IntPtr LoadNativeLibrary(Assembly pReserved, IntPtr[] pointers)
    {
      GCHandle gcHandle = GCHandle.Alloc((object) pointers, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) pointers, 0);
      IntPtr num2 = (IntPtr) \u0082\u00BB.\u0082\u0087((byte*) Marshal.GetHINSTANCE(pReserved.GetLoadedModules()[0]).ToPointer(), (void**) num1.ToPointer());
      gcHandle.Free();
      return num2;
    }

    public virtual unsafe void FreeNativeLibrary(IntPtr pLib) => \u0082\u00BB.\u0096(pLib.ToPointer());

    public virtual StackFrame[] GetFrames(StackTrace trace) => trace == null ? new StackFrame[0] : trace.GetFrames();

    public virtual unsafe void EncodeTrace(Guid[] Guids, long[] Indexes, IntPtr[] Handles)
    {
      GCHandle gcHandle1 = GCHandle.Alloc((object) Guids, GCHandleType.Pinned);
      GCHandle gcHandle2 = GCHandle.Alloc((object) Indexes, GCHandleType.Pinned);
      GCHandle gcHandle3 = GCHandle.Alloc((object) Handles, GCHandleType.Pinned);
      IntPtr num1 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Guids, 0);
      IntPtr num2 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Indexes, 0);
      IntPtr num3 = Marshal.UnsafeAddrOfPinnedArrayElement((Array) Handles, 0);
      \u0082\u00BB.\u0099(Handles.Length, num3.ToPointer(), num2.ToPointer(), num1.ToPointer());
      gcHandle1.Free();
      gcHandle2.Free();
      gcHandle3.Free();
    }
  }
}
