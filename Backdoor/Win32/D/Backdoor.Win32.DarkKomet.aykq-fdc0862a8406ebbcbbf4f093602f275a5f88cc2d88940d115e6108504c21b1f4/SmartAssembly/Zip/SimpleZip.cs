// Decompiled with JetBrains decompiler
// Type: SmartAssembly.Zip.SimpleZip
// Assembly: 5, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D96FE905-3567-4568-B7BF-8C667D038E34
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Backdoor.Win32.DarkKomet.aykq-fdc0862a8406ebbcbbf4f093602f275a5f88cc2d88940d115e6108504c21b1f4.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

namespace SmartAssembly.Zip
{
  public sealed class SimpleZip
  {
    public static string ExceptionMessage;

    private static bool PublicKeysMatch(Assembly executingAssembly, Assembly callingAssembly)
    {
label_0:
      byte[] publicKey1 = executingAssembly.GetName().GetPublicKey();
      byte[] publicKey2 = callingAssembly.GetName().GetPublicKey();
label_17:
      int num1 = publicKey2 == null ? 1 : 0;
      int num2;
      int num3;
      if (true)
      {
        num3 = publicKey1 == null ? 1 : 0;
        num2 = num1;
      }
      else
        goto label_14;
label_3:
      int index;
      if (num2 != num3)
      {
        int num4 = 0;
        if (num4 == 0)
          return num4 != 0;
        num2 = num4;
      }
      else if (publicKey2 != null)
      {
        index = 0;
        if (false)
          goto label_0;
        else
          goto label_15;
      }
      else
        goto label_16;
label_9:
      num3 = (int) publicKey1[index];
      if (true)
      {
        if (num2 != num3)
          return false;
        if (true)
          num1 = index + 1;
        else
          goto label_17;
      }
      else
        goto label_3;
label_14:
      index = num1;
label_15:
      if (index < publicKey2.Length)
      {
        num2 = (int) publicKey2[index];
        goto label_9;
      }
label_16:
      return true;
    }

    public static unsafe byte[] Unzip(byte[] buffer)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(46);
      Assembly callingAssembly = Assembly.GetCallingAssembly();
      if (true)
        goto label_47;
label_7:
      SimpleZip.ZipStream zipStream;
      *(int*) ((IntPtr) voidPtr + 12) = zipStream.ReadInt();
      byte[] buf;
      if (true)
      {
        *(int*) ((IntPtr) voidPtr + 16) = zipStream.ReadShort();
        *(int*) ((IntPtr) voidPtr + 20) = zipStream.ReadShort();
        if (*(int*) ((IntPtr) voidPtr + 16) > 0)
        {
          byte[] buffer1 = new byte[*(int*) ((IntPtr) voidPtr + 16)];
          zipStream.Read(buffer1, 0, *(int*) ((IntPtr) voidPtr + 16));
        }
        if (*(int*) ((IntPtr) voidPtr + 20) > 0)
        {
          byte[] buffer2 = new byte[*(int*) ((IntPtr) voidPtr + 20)];
          zipStream.Read(buffer2, 0, *(int*) ((IntPtr) voidPtr + 20));
        }
        long length = zipStream.Length;
        if (true)
        {
          long position = zipStream.Position;
          length -= position;
        }
        byte[] numArray = new byte[length];
        zipStream.Read(numArray, 0, numArray.Length);
        SimpleZip.Inflater inflater = new SimpleZip.Inflater(numArray);
        buf = new byte[*(int*) ((IntPtr) voidPtr + 12)];
        inflater.Inflate(buf, 0, buf.Length);
        goto label_46;
      }
label_23:
      byte[] iv1 = new byte[8]
      {
        (byte) 66,
        (byte) 36,
        (byte) 204,
        (byte) 87,
        (byte) 117,
        (byte) 2,
        (byte) 95,
        (byte) 187
      };
      DESCryptoIndirector cryptoIndirector1 = new DESCryptoIndirector();
      byte[] key1;
      try
      {
        if (true)
        {
          using (ICryptoTransform desCryptoTransform = cryptoIndirector1.GetDESCryptoTransform(key1, iv1, true))
            buf = SimpleZip.Unzip(desCryptoTransform.TransformFinalBlock(buffer, 4, buffer.Length - 4));
        }
      }
      finally
      {
        while (cryptoIndirector1 != null)
        {
          if (true)
          {
            cryptoIndirector1.Dispose();
            break;
          }
        }
      }
label_34:
      if (*(int*) ((IntPtr) voidPtr + 24) == 3)
      {
        byte[] key2 = new byte[16]
        {
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1,
          (byte) 1
        };
        byte[] iv2 = new byte[16]
        {
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2,
          (byte) 2
        };
        using (AESCryptoIndirector cryptoIndirector2 = new AESCryptoIndirector())
        {
          if (true)
          {
            using (ICryptoTransform aesCryptoTransform = cryptoIndirector2.GetAESCryptoTransform(key2, iv2, true))
              buf = SimpleZip.Unzip(aesCryptoTransform.TransformFinalBlock(buffer, 4, buffer.Length - 4));
          }
        }
      }
label_46:
      zipStream.Close();
      return buf;
label_47:
      Assembly executingAssembly = Assembly.GetExecutingAssembly();
      if ((object) callingAssembly != (object) executingAssembly && !SimpleZip.PublicKeysMatch(executingAssembly, callingAssembly))
        return (byte[]) null;
      zipStream = new SimpleZip.ZipStream(buffer);
      buf = new byte[0];
      *(int*) voidPtr = zipStream.ReadInt();
      if (*(int*) voidPtr == 67324752)
      {
        *(short*) ((IntPtr) voidPtr + 44) = (short) zipStream.ReadShort();
        *(int*) ((IntPtr) voidPtr + 4) = zipStream.ReadShort();
      }
      else
        goto label_15;
label_4:
      *(int*) ((IntPtr) voidPtr + 8) = zipStream.ReadShort();
      if (*(int*) voidPtr != 67324752 || *(short*) ((IntPtr) voidPtr + 44) != (short) 20 || *(int*) ((IntPtr) voidPtr + 4) != 0 || *(int*) ((IntPtr) voidPtr + 8) != 8)
        throw new FormatException("Wrong Header Signature");
      zipStream.ReadInt();
      zipStream.ReadInt();
      zipStream.ReadInt();
      goto label_7;
label_15:
      *(int*) ((IntPtr) voidPtr + 24) = *(int*) voidPtr >> 24;
      *(int*) voidPtr = *(int*) voidPtr - (*(int*) ((IntPtr) voidPtr + 24) << 24);
      if (*(int*) voidPtr != 8223355)
        throw new FormatException("Unknown Header");
      if (true)
      {
        if (*(int*) ((IntPtr) voidPtr + 24) == 1)
        {
          *(int*) ((IntPtr) voidPtr + 28) = zipStream.ReadInt();
          buf = new byte[*(int*) ((IntPtr) voidPtr + 28)];
          *(int*) ((IntPtr) voidPtr + 32) = 0;
          while (*(int*) ((IntPtr) voidPtr + 32) < *(int*) ((IntPtr) voidPtr + 28))
          {
            *(int*) ((IntPtr) voidPtr + 36) = zipStream.ReadInt();
            *(int*) ((IntPtr) voidPtr + 40) = zipStream.ReadInt();
            byte[] numArray = new byte[*(int*) ((IntPtr) voidPtr + 36)];
            zipStream.Read(numArray, 0, numArray.Length);
            new SimpleZip.Inflater(numArray).Inflate(buf, *(int*) ((IntPtr) voidPtr + 32), *(int*) ((IntPtr) voidPtr + 40));
            *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) + *(int*) ((IntPtr) voidPtr + 40);
          }
        }
        if (*(int*) ((IntPtr) voidPtr + 24) == 2)
        {
          key1 = new byte[8]
          {
            (byte) 101,
            (byte) 70,
            (byte) 162,
            (byte) 87,
            (byte) 56,
            (byte) 102,
            (byte) 199,
            (byte) 65
          };
          goto label_23;
        }
        else
          goto label_34;
      }
      else
        goto label_4;
    }

    public static byte[] Zip(byte[] buffer) => SimpleZip.Zip(buffer, 1, (byte[]) null, (byte[]) null);

    public static byte[] ZipAndEncrypt(byte[] buffer, byte[] key, byte[] iv) => SimpleZip.Zip(buffer, 2, key, iv);

    public static byte[] ZipAndAES(byte[] buffer, byte[] key, byte[] iv) => SimpleZip.Zip(buffer, 3, key, iv);

    private static unsafe byte[] Zip(byte[] buffer, int version, byte[] key, byte[] iv)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(64);
      try
      {
        SimpleZip.ZipStream zipStream = new SimpleZip.ZipStream();
        if (version != 0)
          goto label_14;
        else
          goto label_47;
label_5:
        int num1;
        int num2;
        uint num3 = (uint) (num1 ^ num2);
        zipStream.WriteInt(67324752);
        zipStream.WriteShort(20);
        zipStream.WriteShort(0);
        zipStream.WriteShort(8);
        zipStream.WriteInt((int) *(long*) voidPtr);
        zipStream.WriteInt((int) num3);
        *(long*) ((IntPtr) voidPtr + 8) = zipStream.Position;
        zipStream.WriteInt(0);
        zipStream.WriteInt(buffer.Length);
        byte[] bytes = Encoding.UTF8.GetBytes("{data}");
        zipStream.WriteShort(bytes.Length);
        zipStream.WriteShort(0);
        zipStream.Write(bytes, 0, bytes.Length);
        SimpleZip.Deflater deflater1;
        deflater1.SetInput(buffer);
        while (!deflater1.IsNeedingInput)
        {
          byte[] numArray = new byte[512];
          *(int*) ((IntPtr) voidPtr + 44) = deflater1.Deflate(numArray);
          if (*(int*) ((IntPtr) voidPtr + 44) > 0)
            zipStream.Write(numArray, 0, *(int*) ((IntPtr) voidPtr + 44));
          else
            break;
        }
        deflater1.Finish();
        while (!deflater1.IsFinished)
        {
          byte[] numArray = new byte[512];
          *(int*) ((IntPtr) voidPtr + 48) = deflater1.Deflate(numArray);
          if (*(int*) ((IntPtr) voidPtr + 48) > 0)
            zipStream.Write(numArray, 0, *(int*) ((IntPtr) voidPtr + 48));
          else
            break;
        }
        *(long*) ((IntPtr) voidPtr + 16) = deflater1.TotalOut;
        zipStream.WriteInt(33639248);
        zipStream.WriteShort(20);
        zipStream.WriteShort(20);
        zipStream.WriteShort(0);
        zipStream.WriteShort(8);
        zipStream.WriteInt((int) *(long*) voidPtr);
        zipStream.WriteInt((int) num3);
        zipStream.WriteInt((int) *(long*) ((IntPtr) voidPtr + 16));
        zipStream.WriteInt(buffer.Length);
        zipStream.WriteShort(bytes.Length);
        zipStream.WriteShort(0);
        zipStream.WriteShort(0);
        zipStream.WriteShort(0);
        zipStream.WriteShort(0);
        zipStream.WriteInt(0);
        zipStream.WriteInt(0);
        zipStream.Write(bytes, 0, bytes.Length);
        zipStream.WriteInt(101010256);
        zipStream.WriteShort(0);
        zipStream.WriteShort(0);
        zipStream.WriteShort(1);
        zipStream.WriteShort(1);
        zipStream.WriteInt(46 + bytes.Length);
        zipStream.WriteInt((int) ((long) (30 + bytes.Length) + *(long*) ((IntPtr) voidPtr + 16)));
        zipStream.WriteShort(0);
        zipStream.Seek(*(long*) ((IntPtr) voidPtr + 8), SeekOrigin.Begin);
        zipStream.WriteInt((int) *(long*) ((IntPtr) voidPtr + 16));
        goto label_46;
label_14:
        num1 = version;
        num2 = 1;
        if (num2 != 0)
        {
          if (num1 == num2)
          {
            zipStream.WriteInt(25000571);
            zipStream.WriteInt(buffer.Length);
            *(int*) ((IntPtr) voidPtr + 52) = 0;
            while (*(int*) ((IntPtr) voidPtr + 52) < buffer.Length)
            {
              byte[] numArray1 = new byte[Math.Min(2097151, buffer.Length - *(int*) ((IntPtr) voidPtr + 52))];
              Buffer.BlockCopy((Array) buffer, *(int*) ((IntPtr) voidPtr + 52), (Array) numArray1, 0, numArray1.Length);
              *(long*) ((IntPtr) voidPtr + 24) = zipStream.Position;
              zipStream.WriteInt(0);
              zipStream.WriteInt(numArray1.Length);
              SimpleZip.Deflater deflater2 = new SimpleZip.Deflater();
              deflater2.SetInput(numArray1);
              while (!deflater2.IsNeedingInput)
              {
                byte[] numArray2 = new byte[512];
                *(int*) ((IntPtr) voidPtr + 56) = deflater2.Deflate(numArray2);
                if (*(int*) ((IntPtr) voidPtr + 56) > 0)
                  zipStream.Write(numArray2, 0, *(int*) ((IntPtr) voidPtr + 56));
                else
                  break;
              }
              deflater2.Finish();
              while (!deflater2.IsFinished)
              {
                byte[] numArray3 = new byte[512];
                *(int*) ((IntPtr) voidPtr + 60) = deflater2.Deflate(numArray3);
                if (*(int*) ((IntPtr) voidPtr + 60) > 0)
                  zipStream.Write(numArray3, 0, *(int*) ((IntPtr) voidPtr + 60));
                else
                  break;
              }
              *(long*) ((IntPtr) voidPtr + 32) = zipStream.Position;
              zipStream.Position = *(long*) ((IntPtr) voidPtr + 24);
              zipStream.WriteInt((int) deflater2.TotalOut);
              zipStream.Position = *(long*) ((IntPtr) voidPtr + 32);
              *(int*) ((IntPtr) voidPtr + 52) = *(int*) ((IntPtr) voidPtr + 52) + numArray1.Length;
            }
          }
          else
          {
            switch (version)
            {
              case 2:
                zipStream.WriteInt(41777787);
                byte[] inputBuffer1 = SimpleZip.Zip(buffer, 1, (byte[]) null, (byte[]) null);
                using (DESCryptoIndirector cryptoIndirector = new DESCryptoIndirector())
                {
                  using (ICryptoTransform desCryptoTransform = cryptoIndirector.GetDESCryptoTransform(key, iv, false))
                  {
                    byte[] buffer1 = desCryptoTransform.TransformFinalBlock(inputBuffer1, 0, inputBuffer1.Length);
                    zipStream.Write(buffer1, 0, buffer1.Length);
                    break;
                  }
                }
              case 3:
                zipStream.WriteInt(58555003);
                byte[] inputBuffer2 = SimpleZip.Zip(buffer, 1, (byte[]) null, (byte[]) null);
                using (AESCryptoIndirector cryptoIndirector = new AESCryptoIndirector())
                {
                  using (ICryptoTransform aesCryptoTransform = cryptoIndirector.GetAESCryptoTransform(key, iv, false))
                  {
                    byte[] buffer2 = aesCryptoTransform.TransformFinalBlock(inputBuffer2, 0, inputBuffer2.Length);
                    zipStream.Write(buffer2, 0, buffer2.Length);
                    break;
                  }
                }
            }
          }
        }
        else
          goto label_5;
label_46:
        zipStream.Flush();
        zipStream.Close();
        return zipStream.ToArray();
label_47:
        deflater1 = new SimpleZip.Deflater();
        DateTime now = DateTime.Now;
        *(long*) voidPtr = (long) ((uint) ((now.Year - 1980 & (int) sbyte.MaxValue) << 25 | now.Month << 21 | now.Day << 16 | now.Hour << 11 | now.Minute << 5) | (uint) now.Second >> 1);
        uint[] numArray4 = new uint[256]
        {
          0U,
          1996959894U,
          3993919788U,
          2567524794U,
          124634137U,
          1886057615U,
          3915621685U,
          2657392035U,
          249268274U,
          2044508324U,
          3772115230U,
          2547177864U,
          162941995U,
          2125561021U,
          3887607047U,
          2428444049U,
          498536548U,
          1789927666U,
          4089016648U,
          2227061214U,
          450548861U,
          1843258603U,
          4107580753U,
          2211677639U,
          325883990U,
          1684777152U,
          4251122042U,
          2321926636U,
          335633487U,
          1661365465U,
          4195302755U,
          2366115317U,
          997073096U,
          1281953886U,
          3579855332U,
          2724688242U,
          1006888145U,
          1258607687U,
          3524101629U,
          2768942443U,
          901097722U,
          1119000684U,
          3686517206U,
          2898065728U,
          853044451U,
          1172266101U,
          3705015759U,
          2882616665U,
          651767980U,
          1373503546U,
          3369554304U,
          3218104598U,
          565507253U,
          1454621731U,
          3485111705U,
          3099436303U,
          671266974U,
          1594198024U,
          3322730930U,
          2970347812U,
          795835527U,
          1483230225U,
          3244367275U,
          3060149565U,
          1994146192U,
          31158534U,
          2563907772U,
          4023717930U,
          1907459465U,
          112637215U,
          2680153253U,
          3904427059U,
          2013776290U,
          251722036U,
          2517215374U,
          3775830040U,
          2137656763U,
          141376813U,
          2439277719U,
          3865271297U,
          1802195444U,
          476864866U,
          2238001368U,
          4066508878U,
          1812370925U,
          453092731U,
          2181625025U,
          4111451223U,
          1706088902U,
          314042704U,
          2344532202U,
          4240017532U,
          1658658271U,
          366619977U,
          2362670323U,
          4224994405U,
          1303535960U,
          984961486U,
          2747007092U,
          3569037538U,
          1256170817U,
          1037604311U,
          2765210733U,
          3554079995U,
          1131014506U,
          879679996U,
          2909243462U,
          3663771856U,
          1141124467U,
          855842277U,
          2852801631U,
          3708648649U,
          1342533948U,
          654459306U,
          3188396048U,
          3373015174U,
          1466479909U,
          544179635U,
          3110523913U,
          3462522015U,
          1591671054U,
          702138776U,
          2966460450U,
          3352799412U,
          1504918807U,
          783551873U,
          3082640443U,
          3233442989U,
          3988292384U,
          2596254646U,
          62317068U,
          1957810842U,
          3939845945U,
          2647816111U,
          81470997U,
          1943803523U,
          3814918930U,
          2489596804U,
          225274430U,
          2053790376U,
          3826175755U,
          2466906013U,
          167816743U,
          2097651377U,
          4027552580U,
          2265490386U,
          503444072U,
          1762050814U,
          4150417245U,
          2154129355U,
          426522225U,
          1852507879U,
          4275313526U,
          2312317920U,
          282753626U,
          1742555852U,
          4189708143U,
          2394877945U,
          397917763U,
          1622183637U,
          3604390888U,
          2714866558U,
          953729732U,
          1340076626U,
          3518719985U,
          2797360999U,
          1068828381U,
          1219638859U,
          3624741850U,
          2936675148U,
          906185462U,
          1090812512U,
          3747672003U,
          2825379669U,
          829329135U,
          1181335161U,
          3412177804U,
          3160834842U,
          628085408U,
          1382605366U,
          3423369109U,
          3138078467U,
          570562233U,
          1426400815U,
          3317316542U,
          2998733608U,
          733239954U,
          1555261956U,
          3268935591U,
          3050360625U,
          752459403U,
          1541320221U,
          2607071920U,
          3965973030U,
          1969922972U,
          40735498U,
          2617837225U,
          3943577151U,
          1913087877U,
          83908371U,
          2512341634U,
          3803740692U,
          2075208622U,
          213261112U,
          2463272603U,
          3855990285U,
          2094854071U,
          198958881U,
          2262029012U,
          4057260610U,
          1759359992U,
          534414190U,
          2176718541U,
          4139329115U,
          1873836001U,
          414664567U,
          2282248934U,
          4279200368U,
          1711684554U,
          285281116U,
          2405801727U,
          4167216745U,
          1634467795U,
          376229701U,
          2685067896U,
          3608007406U,
          1308918612U,
          956543938U,
          2808555105U,
          3495958263U,
          1231636301U,
          1047427035U,
          2932959818U,
          3654703836U,
          1088359270U,
          936918000U,
          2847714899U,
          3736837829U,
          1202900863U,
          817233897U,
          3183342108U,
          3401237130U,
          1404277552U,
          615818150U,
          3134207493U,
          3453421203U,
          1423857449U,
          601450431U,
          3009837614U,
          3294710456U,
          1567103746U,
          711928724U,
          3020668471U,
          3272380065U,
          1510334235U,
          755167117U
        };
        *(int*) ((IntPtr) voidPtr + 40) = -1;
        uint num4 = *(uint*) ((IntPtr) voidPtr + 40);
        int num5 = 0;
        int length = buffer.Length;
        while (--length >= 0)
          num4 = numArray4[(IntPtr) (uint) (((int) num4 ^ (int) buffer[num5++]) & (int) byte.MaxValue)] ^ num4 >> 8;
        int num6 = (int) num4;
        num2 = (int) *(uint*) ((IntPtr) voidPtr + 40);
        num1 = num6;
        goto label_5;
      }
      catch (Exception ex)
      {
        SimpleZip.ExceptionMessage = "ERR 2003: " + ex.Message;
        throw;
      }
    }

    internal sealed class Inflater
    {
      private const int DECODE_HEADER = 0;
      private const int DECODE_DICT = 1;
      private const int DECODE_BLOCKS = 2;
      private const int DECODE_STORED_LEN1 = 3;
      private const int DECODE_STORED_LEN2 = 4;
      private const int DECODE_STORED = 5;
      private const int DECODE_DYN_HEADER = 6;
      private const int DECODE_HUFFMAN = 7;
      private const int DECODE_HUFFMAN_LENBITS = 8;
      private const int DECODE_HUFFMAN_DIST = 9;
      private const int DECODE_HUFFMAN_DISTBITS = 10;
      private const int DECODE_CHKSUM = 11;
      private const int FINISHED = 12;
      private static readonly int[] CPLENS;
      private static readonly int[] CPLEXT;
      private static readonly int[] CPDIST;
      private static readonly int[] CPDEXT;
      private int mode;
      private int neededBits;
      private int repLength;
      private int repDist;
      private int uncomprLen;
      private bool isLastBlock;
      private SimpleZip.StreamManipulator input;
      private SimpleZip.OutputWindow outputWindow;
      private SimpleZip.InflaterDynHeader dynHeader;
      private SimpleZip.InflaterHuffmanTree litlenTree;
      private SimpleZip.InflaterHuffmanTree distTree;

      public Inflater(byte[] bytes)
      {
        this.input = new SimpleZip.StreamManipulator();
        this.outputWindow = new SimpleZip.OutputWindow();
        this.mode = 2;
        this.input.SetInput(bytes, 0, bytes.Length);
      }

      private unsafe bool DecodeHuffman()
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        int num1 = this.outputWindow.GetFreeSpace();
        while (true)
        {
          int abyte;
          while (num1 >= 258)
          {
            *(int*) ((IntPtr) voidPtr + 8) = this.mode;
            switch (*(int*) ((IntPtr) voidPtr + 8))
            {
              case 7:
                int num2 = this.litlenTree.GetSymbol(this.input);
                if (true)
                {
                  abyte = num2;
                  int num3;
                  for (int index = num2 & -256; index == 0; index = num3)
                  {
                    this.outputWindow.Write(abyte);
                    num3 = num1;
                    if (true)
                    {
                      if ((num1 = num3 - 1) < 258)
                        return true;
                      goto case 7;
                    }
                  }
                  int num4 = abyte;
                  num2 = 257;
                  num2 = num4;
                }
                if (num2 < num2)
                {
                  if (abyte < 0)
                    return false;
                  this.distTree = (SimpleZip.InflaterHuffmanTree) null;
                  this.litlenTree = (SimpleZip.InflaterHuffmanTree) null;
                  this.mode = 2;
                  return true;
                }
                this.repLength = SimpleZip.Inflater.CPLENS[abyte - 257];
                this.neededBits = SimpleZip.Inflater.CPLEXT[abyte - 257];
                goto case 8;
              case 8:
                if (this.neededBits > 0)
                {
                  this.mode = 8;
                  if (true)
                  {
                    *(int*) voidPtr = this.input.PeekBits(this.neededBits);
                    if (*(int*) voidPtr < 0)
                      return false;
                    this.input.DropBits(this.neededBits);
                    this.repLength += *(int*) voidPtr;
                  }
                  else
                    goto label_21;
                }
                this.mode = 9;
                goto case 9;
              case 9:
                abyte = this.distTree.GetSymbol(this.input);
                goto label_20;
              case 10:
                goto label_23;
              default:
                continue;
            }
          }
          goto label_29;
label_20:
          if (abyte >= 0)
          {
            this.repDist = SimpleZip.Inflater.CPDIST[abyte];
            this.neededBits = SimpleZip.Inflater.CPDEXT[abyte];
          }
          else
            break;
label_23:
          if (this.neededBits > 0)
          {
            this.mode = 10;
            *(int*) ((IntPtr) voidPtr + 4) = this.input.PeekBits(this.neededBits);
            if (*(int*) ((IntPtr) voidPtr + 4) >= 0)
            {
              this.input.DropBits(this.neededBits);
              this.repDist += *(int*) ((IntPtr) voidPtr + 4);
            }
            else
              goto label_25;
          }
          this.outputWindow.Repeat(this.repLength, this.repDist);
          num1 -= this.repLength;
          this.mode = 7;
          continue;
label_29:
          if (false)
            goto label_20;
          else
            goto label_30;
        }
label_21:
        return false;
label_25:
        return false;
label_30:
        return true;
      }

      private unsafe bool Decode()
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        switch (this.mode)
        {
          case 2:
            if (this.isLastBlock)
            {
              this.mode = 12;
              return false;
            }
            *(int*) voidPtr = this.input.PeekBits(3);
            if (*(int*) voidPtr < 0)
              return false;
            break;
          case 3:
            if ((this.uncomprLen = this.input.PeekBits(16)) >= 0)
            {
              this.input.DropBits(16);
              goto label_18;
            }
            else
              goto label_15;
          case 4:
label_19:
            *(int*) ((IntPtr) voidPtr + 4) = this.input.PeekBits(16);
            int num1 = *(int*) ((IntPtr) voidPtr + 4);
            if (false)
              return num1 != 0;
            if (num1 < 0)
            {
              if (true)
                return false;
              goto case 3;
            }
            else
              goto label_23;
          case 5:
label_24:
            *(int*) ((IntPtr) voidPtr + 8) = this.outputWindow.CopyStored(this.input, this.uncomprLen);
            this.uncomprLen -= *(int*) ((IntPtr) voidPtr + 8);
            if (this.uncomprLen != 0)
              return !this.input.IsNeedingInput;
            this.mode = 2;
            if (true)
              return true;
            break;
          case 6:
            if (!this.dynHeader.Decode(this.input))
              return false;
            this.litlenTree = this.dynHeader.BuildLitLenTree();
            this.distTree = this.dynHeader.BuildDistTree();
            this.mode = 7;
            goto case 7;
          case 7:
          case 8:
          case 9:
          case 10:
            return this.DecodeHuffman();
          case 12:
            return false;
          default:
            return false;
        }
        this.input.DropBits(3);
        if ((*(int*) voidPtr & 1) != 0)
          this.isLastBlock = true;
        int num2 = *(int*) voidPtr;
label_6:
        switch (num2 >> 1)
        {
          case 0:
            this.input.SkipToByteBoundary();
            this.mode = 3;
            break;
          case 1:
            this.litlenTree = SimpleZip.InflaterHuffmanTree.defLitLenTree;
            this.distTree = SimpleZip.InflaterHuffmanTree.defDistTree;
            this.mode = 7;
            if (true)
            {
              if (true)
              {
                if (false)
                  goto label_23;
                else
                  break;
              }
              else
                goto label_15;
            }
            else
              goto label_18;
          case 2:
            this.dynHeader = new SimpleZip.InflaterDynHeader();
            this.mode = 6;
            break;
        }
        return true;
label_15:
        int num3 = 0;
        if (num3 == 0)
          return num3 != 0;
        num2 = num3;
        goto label_6;
label_18:
        this.mode = 4;
        goto label_19;
label_23:
        this.input.DropBits(16);
        this.mode = 5;
        goto label_24;
      }

      public unsafe int Inflate(byte[] buf, int offset, int len)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(8);
        *(int*) voidPtr = 0;
        int num1;
        int num2;
        do
        {
          num1 = this.mode;
          num2 = 11;
          if (num2 != 0)
          {
            if (num1 != num2)
              goto label_8;
label_3:
            if (!this.Decode())
            {
              int available = this.outputWindow.GetAvailable();
              num2 = 0;
              num1 = available;
              goto label_5;
            }
            else
              continue;
label_8:
            *(int*) ((IntPtr) voidPtr + 4) = this.outputWindow.CopyOutput(buf, offset, len);
            offset += *(int*) ((IntPtr) voidPtr + 4);
            *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 4);
            len -= *(int*) ((IntPtr) voidPtr + 4);
            if (len != 0)
              goto label_3;
            else
              goto label_2;
          }
label_5:;
        }
        while (num1 > num2 && this.mode != 11);
        goto label_6;
label_2:
        return *(int*) voidPtr;
label_6:
        return *(int*) voidPtr;
      }

      static Inflater()
      {
label_0:
        int length1 = 29;
        while (true)
        {
          int[] numArray1 = new int[length1];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray1, __fieldref (\u003CPrivateImplementationDetails\u003E.\u0024\u0024method0x6000015\u002D1));
          SimpleZip.Inflater.CPLENS = numArray1;
          while (true)
          {
            SimpleZip.Inflater.CPLEXT = new int[29]
            {
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              4,
              4,
              4,
              4,
              5,
              5,
              5,
              5,
              0
            };
            if (true)
            {
              SimpleZip.Inflater.CPDIST = new int[30]
              {
                1,
                2,
                3,
                4,
                5,
                7,
                9,
                13,
                17,
                25,
                33,
                49,
                65,
                97,
                129,
                193,
                257,
                385,
                513,
                769,
                1025,
                1537,
                2049,
                3073,
                4097,
                6145,
                8193,
                12289,
                16385,
                24577
              };
              goto label_5;
            }
          }
          goto label_7;
label_5:
          int length2 = 30;
          if (length2 == 0)
          {
            length1 = length2;
            continue;
          }
          int[] numArray2 = new int[length2];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray2, __fieldref (\u003CPrivateImplementationDetails\u003E.\u0024\u0024method0x6000015\u002D4));
          SimpleZip.Inflater.CPDEXT = numArray2;
label_7:
          if (true)
          {
            if (false)
              goto label_5;
            else
              break;
          }
          else
            goto label_0;
        }
      }
    }

    internal sealed class StreamManipulator
    {
      private byte[] window;
      private int window_start = 0;
      private int window_end = 0;
      private uint buffer = 0;
      private int bits_in_buffer = 0;

      public int PeekBits(int n)
      {
        while (this.bits_in_buffer < n)
        {
          if (this.window_start == this.window_end)
          {
            if (true)
            {
              if (true)
                return -1;
            }
            else
              break;
          }
          else if (true)
          {
            SimpleZip.StreamManipulator streamManipulator1 = this;
            int buffer = (int) streamManipulator1.buffer;
            byte[] window1 = this.window;
            SimpleZip.StreamManipulator streamManipulator2 = this;
            int windowStart1;
            int num1 = windowStart1 = streamManipulator2.window_start;
            streamManipulator2.window_start = windowStart1 + 1;
            int index1 = num1;
            int num2 = (int) window1[index1] & (int) byte.MaxValue;
            byte[] window2 = this.window;
            SimpleZip.StreamManipulator streamManipulator3 = this;
            int windowStart2;
            int num3 = windowStart2 = streamManipulator3.window_start;
            streamManipulator3.window_start = windowStart2 + 1;
            int index2 = num3;
            int num4 = ((int) window2[index2] & (int) byte.MaxValue) << 8;
            int num5 = (num2 | num4) << this.bits_in_buffer;
            streamManipulator1.buffer = (uint) (buffer | num5);
          }
          else
            continue;
          this.bits_in_buffer += 16;
          break;
        }
        long buffer1 = (long) this.buffer;
        int num6 = 1;
        int num7 = n;
        int num8;
        do
        {
          if (true)
          {
            int num9 = num7 & 31;
            num8 = num6 << num9;
            if (true)
            {
              num7 = 1;
              num6 = num8;
            }
            else
              goto label_15;
          }
        }
        while (num7 == 0);
        int num10 = num6 - num7;
        goto label_13;
label_15:
        num10 = num8;
label_13:
        long num11 = (long) num10;
        return (int) (buffer1 & num11);
      }

      public void DropBits(int n)
      {
label_0:
        this.buffer >>= n;
        do
        {
          if (true)
            this.bits_in_buffer -= n;
          else
            goto label_0;
        }
        while (false);
      }

      public int AvailableBits => this.bits_in_buffer;

      public int AvailableBytes
      {
        get
        {
          int num1 = this.window_end;
          int num2;
          int num3;
          while (true)
          {
            num2 = this.window_start;
            if (true)
            {
              num3 = num1 - num2;
              if (false)
                num1 = num3;
              else
                goto label_7;
            }
            else
              break;
          }
label_2:
          do
          {
            if (true)
              num2 >>= 3;
          }
          while (false);
          return num1 + num2;
label_7:
          num2 = this.bits_in_buffer;
          num1 = num3;
          goto label_2;
        }
      }

      public void SkipToByteBoundary()
      {
        this.buffer >>= this.bits_in_buffer & 7;
        this.bits_in_buffer &= -8;
      }

      public bool IsNeedingInput => this.window_start == this.window_end;

      public unsafe int CopyBytes(byte[] output, int offset, int length)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(8);
        *(int*) voidPtr = 0;
        int num1;
        int num2;
        int num3;
        while (true)
        {
          int num4 = this.bits_in_buffer;
          int num5 = 0;
          while (true)
          {
            if (num5 == 0)
            {
              if (num4 <= num5 || length <= 0)
              {
                if (length != 0)
                {
                  *(int*) ((IntPtr) voidPtr + 4) = this.window_end - this.window_start;
                  int num6 = length;
                  num5 = *(int*) ((IntPtr) voidPtr + 4);
                  num4 = num6;
                }
                else
                  break;
              }
              else
                goto label_21;
            }
            if (num4 > num5)
              length = *(int*) ((IntPtr) voidPtr + 4);
            do
            {
              Array.Copy((Array) this.window, this.window_start, (Array) output, offset, length);
            }
            while (false);
            this.window_start += length;
            num1 = this.window_start;
            if (true)
            {
              int windowEnd = this.window_end;
              num2 = num1 - windowEnd;
              num3 = 1;
              if (num3 == 0)
              {
                num5 = num3;
                num4 = num2;
              }
              else
                goto label_15;
            }
            else
              goto label_20;
          }
          if (false)
            goto label_22;
          else
            break;
label_21:
          output[offset++] = (byte) this.buffer;
          if (true)
          {
            this.buffer >>= 8;
            this.bits_in_buffer -= 8;
            --length;
          }
          else
            goto label_16;
label_22:
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        return *(int*) voidPtr;
label_15:
        if ((num2 & num3) == 0)
          goto label_19;
label_16:
        if (true)
          this.buffer = (uint) this.window[this.window_start++] & (uint) byte.MaxValue;
        this.bits_in_buffer = 8;
label_19:
        num1 = *(int*) voidPtr;
label_20:
        int num7 = length;
        return num1 + num7;
      }

      public void Reset()
      {
        do
        {
          if (true)
            this.buffer = (uint) (this.window_start = this.window_end = this.bits_in_buffer = 0);
        }
        while (false);
      }

      public void SetInput(byte[] buf, int off, int len)
      {
        if (true)
          goto label_6;
label_4:
        this.bits_in_buffer += 8;
label_5:
        this.window = buf;
        this.window_start = off;
        int num;
        this.window_end = num;
        return;
label_6:
        if (this.window_start < this.window_end)
          throw new InvalidOperationException();
        num = off + len;
        if (0 > off || off > num || num > buf.Length)
          throw new ArgumentOutOfRangeException();
        if ((len & 1) != 0)
        {
          this.buffer |= (uint) (((int) buf[off++] & (int) byte.MaxValue) << this.bits_in_buffer);
          goto label_4;
        }
        else
          goto label_5;
      }
    }

    internal sealed class OutputWindow
    {
      private const int WINDOW_SIZE = 32768;
      private const int WINDOW_MASK = 32767;
      private byte[] window = new byte[32768];
      private int windowEnd = 0;
      private int windowFilled = 0;

      public void Write(int abyte)
      {
label_0:
        do
        {
          SimpleZip.OutputWindow outputWindow1 = this;
          int windowFilled;
          int num1 = windowFilled = outputWindow1.windowFilled;
          outputWindow1.windowFilled = windowFilled + 1;
          do
          {
            if (true)
            {
              if (num1 != 32768)
                goto label_3;
label_2:
              goto label_0;
label_3:
              if (true)
              {
                byte[] window = this.window;
                SimpleZip.OutputWindow outputWindow2 = this;
                int windowEnd;
                num1 = windowEnd = outputWindow2.windowEnd;
                outputWindow2.windowEnd = windowEnd + 1;
                int index = num1;
                int num2 = (int) (byte) abyte;
                window[index] = (byte) num2;
                if (false)
                  goto label_2;
              }
              else
                goto label_0;
            }
            else
              goto label_0;
          }
          while (false);
          goto label_5;
        }
        while (false);
        goto label_7;
label_5:
        this.windowEnd &= (int) short.MaxValue;
        return;
label_7:
        throw new InvalidOperationException();
      }

      private void SlowRepeat(int repStart, int len, int dist)
      {
        if (false)
          return;
        while (true)
        {
          int num1 = len;
          int num2;
          while (true)
          {
            num2 = num1 - 1;
            if (false)
              num1 = num2;
            else
              break;
          }
          len = num2;
          if (num1 > 0)
          {
            byte[] window = this.window;
            SimpleZip.OutputWindow outputWindow = this;
            int windowEnd;
            int num3 = windowEnd = outputWindow.windowEnd;
            outputWindow.windowEnd = windowEnd + 1;
            int index = num3;
            int num4 = (int) this.window[repStart++];
            window[index] = (byte) num4;
            this.windowEnd &= (int) short.MaxValue;
            int num5 = repStart;
            if (true)
              num5 &= (int) short.MaxValue;
            repStart = num5;
          }
          else
            break;
        }
      }

      public void Repeat(int len, int dist)
      {
        if ((this.windowFilled += len) > 32768)
          throw new InvalidOperationException();
        int num1 = this.windowEnd - dist & (int) short.MaxValue;
        int num2 = 32768 - len;
        if (num1 <= num2 && this.windowEnd < num2)
        {
          if (len <= dist)
          {
            Array.Copy((Array) this.window, num1, (Array) this.window, this.windowEnd, len);
            this.windowEnd += len;
          }
          else
          {
            while (len-- > 0)
              this.window[this.windowEnd++] = this.window[num1++];
          }
        }
        else
          this.SlowRepeat(num1, len, dist);
      }

      public unsafe int CopyStored(SimpleZip.StreamManipulator input, int len)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(8);
        int val1 = len;
        int val2 = 32768;
        if (val2 != 0)
          val2 -= this.windowFilled;
        len = Math.Min(Math.Min(val1, val2), input.AvailableBytes);
        *(int*) ((IntPtr) voidPtr + 4) = 32768 - this.windowEnd;
        if (len > *(int*) ((IntPtr) voidPtr + 4))
        {
          *(int*) voidPtr = input.CopyBytes(this.window, this.windowEnd, *(int*) ((IntPtr) voidPtr + 4));
          if (*(int*) voidPtr == *(int*) ((IntPtr) voidPtr + 4))
            *(int*) voidPtr = *(int*) voidPtr + input.CopyBytes(this.window, 0, len - *(int*) ((IntPtr) voidPtr + 4));
        }
        else
          *(int*) voidPtr = input.CopyBytes(this.window, this.windowEnd, len);
        this.windowEnd = this.windowEnd + *(int*) voidPtr & (int) short.MaxValue;
        this.windowFilled += *(int*) voidPtr;
        return *(int*) voidPtr;
      }

      public void CopyDict(byte[] dict, int offset, int len)
      {
        if (this.windowFilled > 0)
          throw new InvalidOperationException();
        int num1 = len;
label_1:
        int num2;
        for (int index = 32768; num1 > index; num1 = num2)
        {
          num2 = offset;
          if (false)
          {
            num1 = num2;
            goto label_1;
          }
          else
          {
            int num3 = len;
            if (false)
            {
              index = num3;
            }
            else
            {
              if (true)
                num3 -= 32768;
              int num4 = num2 + num3;
              if (true)
              {
                if (true)
                  goto label_15;
label_7:
                num4 = 32768;
                goto label_16;
label_15:
                offset = num4;
                goto label_7;
              }
label_16:
              len = num4;
              break;
            }
          }
        }
        do
        {
          Array.Copy((Array) dict, offset, (Array) this.window, 0, len);
          this.windowEnd = len & (int) short.MaxValue;
        }
        while (false);
      }

      public int GetFreeSpace() => 32768 - this.windowFilled;

      public int GetAvailable() => this.windowFilled;

      public unsafe int CopyOutput(byte[] output, int offset, int len)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        int num1;
        int num2;
        do
        {
          *(int*) voidPtr = this.windowEnd;
          num1 = len;
          num2 = this.windowFilled;
          if (true)
          {
            if (true)
            {
              if (num1 <= num2)
                goto label_17;
              else
                goto label_16;
label_4:
              *(int*) ((IntPtr) voidPtr + 4) = len;
              continue;
label_16:
              len = this.windowFilled;
              goto label_4;
label_17:
              *(int*) voidPtr = this.windowEnd - this.windowFilled + len & (int) short.MaxValue;
              goto label_4;
            }
            else
              goto label_10;
          }
          else
            goto label_12;
        }
        while (false);
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 8) = len - *(int*) voidPtr;
          int num3 = *(int*) ((IntPtr) voidPtr + 8);
          int num4 = 0;
          if (num4 == 0)
          {
            if (num3 > num4)
              Array.Copy((Array) this.window, 32768 - *(int*) ((IntPtr) voidPtr + 8), (Array) output, offset, *(int*) ((IntPtr) voidPtr + 8));
            else
              goto label_11;
          }
          else
          {
            num2 = num4;
            num1 = num3;
            goto label_10;
          }
        }
        int num5 = offset;
        num2 = *(int*) ((IntPtr) voidPtr + 8);
        num1 = num5;
label_10:
        offset = num1 + num2;
        len = *(int*) voidPtr;
label_11:
        Array.Copy((Array) this.window, *(int*) voidPtr - len, (Array) output, offset, len);
        this.windowFilled -= *(int*) ((IntPtr) voidPtr + 4);
        int windowFilled = this.windowFilled;
        num2 = 0;
        num1 = windowFilled;
label_12:
        if (num1 < num2)
          throw new InvalidOperationException();
        return *(int*) ((IntPtr) voidPtr + 4);
      }

      public void Reset() => this.windowFilled = this.windowEnd = 0;
    }

    internal sealed class InflaterHuffmanTree
    {
      private const int MAX_BITLEN = 15;
      private short[] tree;
      public static readonly SimpleZip.InflaterHuffmanTree defLitLenTree;
      public static readonly SimpleZip.InflaterHuffmanTree defDistTree;

      static InflaterHuffmanTree()
      {
        byte[] codeLengths = new byte[288];
label_1:
        int num1;
        while (true)
        {
          if (true)
            goto label_18;
label_3:
          if (true)
          {
            while (num1 < 144)
              codeLengths[num1++] = (byte) 8;
            if (true)
            {
              for (; num1 < 256; codeLengths[num1++] = (byte) 9)
              {
                if (false)
                  goto label_1;
              }
              goto label_7;
            }
            else
              break;
          }
          else
            goto label_10;
label_18:
          num1 = 0;
          goto label_3;
        }
        goto label_12;
label_7:
        int num2;
        int num3;
        while (true)
        {
          num2 = num1;
          num3 = 280;
          if (num3 != 0)
          {
            if (num2 < num3)
              codeLengths[num1++] = (byte) 7;
            else
              goto label_10;
          }
          else
            break;
        }
        int num4 = num3;
        int num5 = num2;
        goto label_15;
label_10:
        while (num1 < 288)
          codeLengths[num1++] = (byte) 8;
        SimpleZip.InflaterHuffmanTree.defLitLenTree = new SimpleZip.InflaterHuffmanTree(codeLengths);
        codeLengths = new byte[32];
label_12:
        num1 = 0;
label_14:
        num5 = num1;
        num4 = 32;
label_15:
        if (num5 < num4)
        {
          codeLengths[num1++] = (byte) 5;
          goto label_14;
        }
        else if (true)
          SimpleZip.InflaterHuffmanTree.defDistTree = new SimpleZip.InflaterHuffmanTree(codeLengths);
        else
          goto label_7;
      }

      public InflaterHuffmanTree(byte[] codeLengths) => this.BuildTree(codeLengths);

      private unsafe void BuildTree(byte[] codeLengths)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(68);
        int[] numArray1 = new int[16];
        int[] numArray2 = new int[16];
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < codeLengths.Length)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) codeLengths[*(int*) voidPtr];
          if (*(int*) ((IntPtr) voidPtr + 4) > 0)
          {
            int[] numArray3;
            int index;
            int num = (numArray3 = numArray1)[(IntPtr) (index = *(int*) ((IntPtr) voidPtr + 4))] + 1;
            numArray3[index] = num;
          }
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        *(int*) ((IntPtr) voidPtr + 12) = 512;
        *(int*) ((IntPtr) voidPtr + 16) = 1;
        while (*(int*) ((IntPtr) voidPtr + 16) <= 15)
        {
          numArray2[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 8);
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + (numArray1[*(int*) ((IntPtr) voidPtr + 16)] << 16 - *(int*) ((IntPtr) voidPtr + 16));
          if (*(int*) ((IntPtr) voidPtr + 16) >= 10)
          {
            *(int*) ((IntPtr) voidPtr + 20) = numArray2[*(int*) ((IntPtr) voidPtr + 16)] & 130944;
            *(int*) ((IntPtr) voidPtr + 24) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (*(int*) ((IntPtr) voidPtr + 24) - *(int*) ((IntPtr) voidPtr + 20) >> 16 - *(int*) ((IntPtr) voidPtr + 16));
          }
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        this.tree = new short[*(int*) ((IntPtr) voidPtr + 12)];
        *(int*) ((IntPtr) voidPtr + 28) = 512;
        *(int*) ((IntPtr) voidPtr + 32) = 15;
        if (true)
          goto label_15;
label_12:
        *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) + (1 << *(int*) ((IntPtr) voidPtr + 32) - 9);
        *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 44) + 128;
label_13:
        if (*(int*) ((IntPtr) voidPtr + 44) < *(int*) ((IntPtr) voidPtr + 36))
        {
          this.tree[(int) SimpleZip.DeflaterHuffman.BitReverse(*(int*) ((IntPtr) voidPtr + 44))] = (short) (-*(int*) ((IntPtr) voidPtr + 28) << 4 | *(int*) ((IntPtr) voidPtr + 32));
          goto label_12;
        }
        else
          *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
label_15:
        if (*(int*) ((IntPtr) voidPtr + 32) >= 10)
        {
          *(int*) ((IntPtr) voidPtr + 36) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (numArray1[*(int*) ((IntPtr) voidPtr + 32)] << 16 - *(int*) ((IntPtr) voidPtr + 32));
          *(int*) ((IntPtr) voidPtr + 40) = *(int*) ((IntPtr) voidPtr + 8) & 130944;
          *(int*) ((IntPtr) voidPtr + 44) = *(int*) ((IntPtr) voidPtr + 40);
          goto label_13;
        }
        else
        {
          *(int*) ((IntPtr) voidPtr + 48) = 0;
          while (*(int*) ((IntPtr) voidPtr + 48) < codeLengths.Length)
          {
            *(int*) ((IntPtr) voidPtr + 52) = (int) codeLengths[*(int*) ((IntPtr) voidPtr + 48)];
            if (*(int*) ((IntPtr) voidPtr + 52) != 0)
            {
              *(int*) ((IntPtr) voidPtr + 8) = numArray2[*(int*) ((IntPtr) voidPtr + 52)];
              *(int*) ((IntPtr) voidPtr + 56) = (int) SimpleZip.DeflaterHuffman.BitReverse(*(int*) ((IntPtr) voidPtr + 8));
              if (*(int*) ((IntPtr) voidPtr + 52) <= 9)
              {
                do
                {
                  this.tree[*(int*) ((IntPtr) voidPtr + 56)] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                  *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
                }
                while (*(int*) ((IntPtr) voidPtr + 56) < 512);
              }
              else
              {
                *(int*) ((IntPtr) voidPtr + 60) = (int) this.tree[*(int*) ((IntPtr) voidPtr + 56) & 511];
                *(int*) ((IntPtr) voidPtr + 64) = 1 << (*(int*) ((IntPtr) voidPtr + 60) & 15);
                *(int*) ((IntPtr) voidPtr + 60) = -(*(int*) ((IntPtr) voidPtr + 60) >> 4);
                do
                {
                  this.tree[*(int*) ((IntPtr) voidPtr + 60) | *(int*) ((IntPtr) voidPtr + 56) >> 9] = (short) (*(int*) ((IntPtr) voidPtr + 48) << 4 | *(int*) ((IntPtr) voidPtr + 52));
                  *(int*) ((IntPtr) voidPtr + 56) = *(int*) ((IntPtr) voidPtr + 56) + (1 << *(int*) ((IntPtr) voidPtr + 52));
                }
                while (*(int*) ((IntPtr) voidPtr + 56) < *(int*) ((IntPtr) voidPtr + 64));
              }
              numArray2[*(int*) ((IntPtr) voidPtr + 52)] = *(int*) ((IntPtr) voidPtr + 8) + (1 << 16 - *(int*) ((IntPtr) voidPtr + 52));
            }
            *(int*) ((IntPtr) voidPtr + 48) = *(int*) ((IntPtr) voidPtr + 48) + 1;
          }
        }
      }

      public unsafe int GetSymbol(SimpleZip.StreamManipulator input)
      {
        int num1;
        void* voidPtr;
        if (true)
        {
          int num2 = 16;
          int index;
          int num3;
          while (true)
          {
            // ISSUE: untyped stack allocation
            voidPtr = (void*) __untypedstackalloc(num2);
            if ((index = input.PeekBits(9)) >= 0)
            {
              if ((num1 = (int) this.tree[index]) >= 0)
              {
                if (true)
                {
                  input.DropBits(num1 & 15);
                  num3 = num1;
                  if (false)
                    num2 = num3;
                  else
                    break;
                }
                else
                  goto label_8;
              }
              else
                goto label_5;
            }
            else
              goto label_13;
          }
          return num3 >> 4;
label_5:
          *(int*) voidPtr = -(num1 >> 4);
          *(int*) ((IntPtr) voidPtr + 4) = num1 & 15;
          int num4;
          if ((num4 = input.PeekBits(*(int*) ((IntPtr) voidPtr + 4))) >= 0)
          {
            int num5 = (int) this.tree[*(int*) voidPtr | num4 >> 9];
            input.DropBits(num5 & 15);
            return num5 >> 4;
          }
          *(int*) ((IntPtr) voidPtr + 8) = input.AvailableBits;
          index = input.PeekBits(*(int*) ((IntPtr) voidPtr + 8));
          num1 = (int) this.tree[*(int*) voidPtr | index >> 9];
label_8:
          if (true)
          {
            if ((num1 & 15) > *(int*) ((IntPtr) voidPtr + 8))
              return -1;
            input.DropBits(num1 & 15);
            if (true)
              return num1 >> 4;
            goto label_14;
          }
          else
            goto label_16;
label_13:
          *(int*) ((IntPtr) voidPtr + 12) = input.AvailableBits;
          index = input.PeekBits(*(int*) ((IntPtr) voidPtr + 12));
label_14:
          num1 = (int) this.tree[index];
        }
        if (num1 < 0)
          goto label_18;
label_16:
        if ((num1 & 15) <= *(int*) ((IntPtr) voidPtr + 12))
        {
          input.DropBits(num1 & 15);
          return num1 >> 4;
        }
label_18:
        return -1;
      }
    }

    internal sealed class InflaterDynHeader
    {
      private const int LNUM = 0;
      private const int DNUM = 1;
      private const int BLNUM = 2;
      private const int BLLENS = 3;
      private const int LENS = 4;
      private const int REPS = 5;
      private static readonly int[] repMin;
      private static readonly int[] repBits;
      private byte[] blLens;
      private byte[] litdistLens;
      private SimpleZip.InflaterHuffmanTree blTree;
      private int mode;
      private int lnum;
      private int dnum;
      private int blnum;
      private int num;
      private int repSymbol;
      private byte lastLen;
      private int ptr;
      private static readonly int[] BL_ORDER;

      public unsafe bool Decode(SimpleZip.StreamManipulator input)
      {
        int num1 = 8;
        void* voidPtr;
        if (num1 != 0)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num1);
          goto label_43;
        }
label_2:
        int num2;
        int num3;
        int num4;
        int num5;
        switch (num1)
        {
          case 0:
            this.lnum = input.PeekBits(5);
            if (this.lnum < 0)
              return false;
            this.lnum += 257;
            input.DropBits(5);
            this.mode = 1;
            goto case 1;
          case 1:
            this.dnum = input.PeekBits(5);
            if (this.dnum >= 0)
            {
              ++this.dnum;
              input.DropBits(5);
              this.num = this.lnum + this.dnum;
              this.litdistLens = new byte[this.num];
              this.mode = 2;
              goto case 2;
            }
            else
              break;
          case 2:
            this.blnum = input.PeekBits(4);
            if (this.blnum < 0)
              return false;
            this.blnum += 4;
            input.DropBits(4);
            this.blLens = new byte[19];
            this.ptr = 0;
            goto label_12;
          case 3:
label_19:
            num4 = this.ptr;
            num5 = this.blnum;
            if (true)
            {
              if (num4 < num5)
              {
                *(int*) voidPtr = input.PeekBits(3);
                goto label_14;
              }
              else
              {
                this.blTree = new SimpleZip.InflaterHuffmanTree(this.blLens);
                this.blLens = (byte[]) null;
                this.ptr = 0;
                if (true)
                {
                  this.mode = 4;
                  goto case 4;
                }
                else
                  break;
              }
            }
            else
              goto label_25;
          case 4:
label_27:
            int symbol;
            if (((symbol = this.blTree.GetSymbol(input)) & -16) == 0)
            {
              if (true)
              {
                byte[] litdistLens = this.litdistLens;
                num2 = this.ptr++;
                int index = num2;
                int num6 = (int) (this.lastLen = (byte) symbol);
                litdistLens[index] = (byte) num6;
                int ptr = this.ptr;
                num5 = this.num;
                num4 = ptr;
                goto label_25;
              }
              else
                goto label_12;
            }
            else
            {
              if (symbol < 0)
                return false;
              if (symbol >= 17)
                this.lastLen = (byte) 0;
              this.repSymbol = symbol - 16;
              if (true)
              {
                this.mode = 5;
                goto case 5;
              }
              else
                goto case 5;
            }
          case 5:
            *(int*) ((IntPtr) voidPtr + 4) = SimpleZip.InflaterDynHeader.repBits[this.repSymbol];
            num3 = input.PeekBits(*(int*) ((IntPtr) voidPtr + 4));
            if (num3 < 0)
              return false;
            goto label_36;
          default:
            goto label_43;
        }
        return false;
label_12:
        this.mode = 3;
        goto label_19;
label_14:
        int num7 = *(int*) voidPtr;
        if (false)
          return num7 != 0;
        if (num7 < 0)
          return false;
        input.DropBits(3);
        if (true)
        {
          this.blLens[SimpleZip.InflaterDynHeader.BL_ORDER[this.ptr]] = (byte) *(int*) voidPtr;
          ++this.ptr;
          goto label_19;
        }
        else
          goto label_36;
label_25:
        if (num4 == num5)
          return true;
        goto label_27;
label_36:
        input.DropBits(*(int*) ((IntPtr) voidPtr + 4));
        num3 += SimpleZip.InflaterDynHeader.repMin[this.repSymbol];
        while (num3-- > 0)
        {
          byte[] litdistLens = this.litdistLens;
          num2 = this.ptr++;
          int index = num2;
          int lastLen = (int) this.lastLen;
          litdistLens[index] = (byte) lastLen;
        }
        if (true)
        {
          if (this.ptr == this.num)
            return true;
          this.mode = 4;
        }
        else
          goto label_14;
label_43:
        int mode = this.mode;
        if (true)
          num2 = mode;
        num1 = num2;
        goto label_2;
      }

      public SimpleZip.InflaterHuffmanTree BuildLitLenTree()
      {
        byte[] numArray = new byte[this.lnum];
        Array.Copy((Array) this.litdistLens, 0, (Array) numArray, 0, this.lnum);
        return new SimpleZip.InflaterHuffmanTree(numArray);
      }

      public SimpleZip.InflaterHuffmanTree BuildDistTree()
      {
        byte[] numArray = new byte[this.dnum];
        Array.Copy((Array) this.litdistLens, this.lnum, (Array) numArray, 0, this.dnum);
        return new SimpleZip.InflaterHuffmanTree(numArray);
      }

      static InflaterDynHeader()
      {
label_0:
        int length1 = 3;
        int length2;
        while (true)
        {
          int[] numArray1 = new int[length1];
          // ISSUE: field reference
          RuntimeHelpers.InitializeArray((Array) numArray1, __fieldref (\u003CPrivateImplementationDetails\u003E.\u0024\u0024method0x6000032\u002D1));
          SimpleZip.InflaterDynHeader.repMin = numArray1;
          do
          {
            if (true)
            {
              length2 = 3;
              if (length2 != 0)
              {
                int[] numArray2 = new int[length2];
                // ISSUE: field reference
                RuntimeHelpers.InitializeArray((Array) numArray2, __fieldref (\u003CPrivateImplementationDetails\u003E.\u0024\u0024method0x6000032\u002D2));
                SimpleZip.InflaterDynHeader.repBits = numArray2;
              }
              else
                goto label_6;
            }
            else
              goto label_0;
          }
          while (false);
          length2 = 19;
label_6:
          if (length2 == 0)
            length1 = length2;
          else
            break;
        }
        int[] numArray = new int[length2];
        // ISSUE: field reference
        RuntimeHelpers.InitializeArray((Array) numArray, __fieldref (\u003CPrivateImplementationDetails\u003E.\u0024\u0024method0x6000032\u002D3));
        SimpleZip.InflaterDynHeader.BL_ORDER = numArray;
      }
    }

    internal sealed class Deflater
    {
      private const int IS_FLUSHING = 4;
      private const int IS_FINISHING = 8;
      private const int BUSY_STATE = 16;
      private const int FLUSHING_STATE = 20;
      private const int FINISHING_STATE = 28;
      private const int FINISHED_STATE = 30;
      private int state = 16;
      private long totalOut = 0;
      private SimpleZip.DeflaterPending pending;
      private SimpleZip.DeflaterEngine engine;

      public Deflater()
      {
        this.pending = new SimpleZip.DeflaterPending();
        this.engine = new SimpleZip.DeflaterEngine(this.pending);
      }

      public long TotalOut => this.totalOut;

      public void Finish() => this.state |= 12;

      public bool IsFinished => this.state == 30 && this.pending.IsFlushed;

      public bool IsNeedingInput => this.engine.NeedsInput();

      public void SetInput(byte[] buffer) => this.engine.SetInput(buffer);

      public unsafe int Deflate(byte[] output)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(20);
        *(int*) voidPtr = 0;
        *(int*) ((IntPtr) voidPtr + 4) = output.Length;
        *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 4);
        int num1;
        int num2;
        int state;
        int num3;
        int num4;
        while (true)
        {
          do
          {
            *(int*) ((IntPtr) voidPtr + 12) = this.pending.Flush(output, *(int*) voidPtr, *(int*) ((IntPtr) voidPtr + 4));
            *(int*) voidPtr = *(int*) voidPtr + *(int*) ((IntPtr) voidPtr + 12);
            this.totalOut += (long) *(int*) ((IntPtr) voidPtr + 12);
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - *(int*) ((IntPtr) voidPtr + 12);
            if (*(int*) ((IntPtr) voidPtr + 4) == 0)
              goto label_17;
label_1:
            state = this.state;
            if (true)
            {
              if (state != 30)
              {
                if (!this.engine.Deflate((this.state & 4) != 0, (this.state & 8) != 0))
                {
                  if (this.state == 16)
                  {
                    num3 = *(int*) ((IntPtr) voidPtr + 8);
                    num4 = *(int*) ((IntPtr) voidPtr + 4);
                    if (false)
                    {
                      num2 = num4;
                      num1 = num3;
                      goto label_18;
                    }
                    else
                      goto label_6;
                  }
                  else if (this.state == 20)
                    *(int*) ((IntPtr) voidPtr + 16) = 8 + (-this.pending.BitCount & 7);
                  else
                    continue;
                }
                else
                  continue;
              }
              else
                goto label_17;
            }
            else
              goto label_14;
label_11:
            int num5 = *(int*) ((IntPtr) voidPtr + 16);
            num2 = 0;
            num1 = num5;
label_12:
            if (num1 > num2)
            {
              this.pending.WriteBits(2, 10);
              if (true)
              {
                *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 10;
                goto label_11;
              }
              else
                goto label_11;
            }
            else
            {
              this.state = 16;
              if (false)
                goto label_1;
              else
                continue;
            }
label_17:
            num1 = *(int*) ((IntPtr) voidPtr + 8);
            num2 = *(int*) ((IntPtr) voidPtr + 4);
label_18:
            if (false)
              goto label_12;
            else
              goto label_19;
          }
          while (this.state != 28);
          this.pending.AlignToByte();
          this.state = 30;
        }
label_14:
        return state;
label_6:
        return num3 - num4;
label_19:
        return num1 - num2;
      }
    }

    internal sealed class DeflaterHuffman
    {
      private const int BUFSIZE = 16384;
      private const int LITERAL_NUM = 286;
      private const int DIST_NUM = 30;
      private const int BITLEN_NUM = 19;
      private const int REP_3_6 = 16;
      private const int REP_3_10 = 17;
      private const int REP_11_138 = 18;
      private const int EOF_SYMBOL = 256;
      private static readonly int[] BL_ORDER;
      private static readonly byte[] bit4Reverse;
      private SimpleZip.DeflaterPending pending;
      private SimpleZip.DeflaterHuffman.Tree literalTree;
      private SimpleZip.DeflaterHuffman.Tree distTree;
      private SimpleZip.DeflaterHuffman.Tree blTree;
      private short[] d_buf;
      private byte[] l_buf;
      private int last_lit;
      private int extra_bits;
      private static readonly short[] staticLCodes;
      private static readonly byte[] staticLLength;
      private static readonly short[] staticDCodes;
      private static readonly byte[] staticDLength;

      public static short BitReverse(int toReverse) => (short) ((int) SimpleZip.DeflaterHuffman.bit4Reverse[toReverse & 15] << 12 | (int) SimpleZip.DeflaterHuffman.bit4Reverse[toReverse >> 4 & 15] << 8 | (int) SimpleZip.DeflaterHuffman.bit4Reverse[toReverse >> 8 & 15] << 4 | (int) SimpleZip.DeflaterHuffman.bit4Reverse[toReverse >> 12]);

      static DeflaterHuffman()
      {
label_0:
        SimpleZip.DeflaterHuffman.BL_ORDER = new int[19]
        {
          16,
          17,
          18,
          0,
          8,
          7,
          9,
          6,
          10,
          5,
          11,
          4,
          12,
          3,
          13,
          2,
          14,
          1,
          15
        };
label_1:
        SimpleZip.DeflaterHuffman.bit4Reverse = new byte[16]
        {
          (byte) 0,
          (byte) 8,
          (byte) 4,
          (byte) 12,
          (byte) 2,
          (byte) 10,
          (byte) 6,
          (byte) 14,
          (byte) 1,
          (byte) 9,
          (byte) 5,
          (byte) 13,
          (byte) 3,
          (byte) 11,
          (byte) 7,
          (byte) 15
        };
        SimpleZip.DeflaterHuffman.staticLCodes = new short[286];
        SimpleZip.DeflaterHuffman.staticLLength = new byte[286];
        int index;
        if (true)
        {
          index = 0;
          goto label_23;
        }
        else
          goto label_7;
label_4:
        if (true)
        {
          SimpleZip.DeflaterHuffman.staticLLength[index++] = (byte) 8;
          goto label_23;
        }
        else
          goto label_8;
label_7:
        SimpleZip.DeflaterHuffman.staticLLength[index++] = (byte) 9;
label_8:
        if (index < 256)
        {
          SimpleZip.DeflaterHuffman.staticLCodes[index] = SimpleZip.DeflaterHuffman.BitReverse(256 + index << 7);
          goto label_7;
        }
        else
        {
          if (true)
          {
            while (true)
            {
              int num1 = index;
label_13:
              if (num1 < 280)
              {
                SimpleZip.DeflaterHuffman.staticLCodes[index] = SimpleZip.DeflaterHuffman.BitReverse(index - 256 << 9);
                if (true)
                  SimpleZip.DeflaterHuffman.staticLLength[index++] = (byte) 7;
                else
                  goto label_0;
              }
              else
              {
                for (; index < 286; SimpleZip.DeflaterHuffman.staticLLength[index++] = (byte) 8)
                  SimpleZip.DeflaterHuffman.staticLCodes[index] = SimpleZip.DeflaterHuffman.BitReverse(index - 88 << 8);
                SimpleZip.DeflaterHuffman.staticDCodes = new short[30];
                SimpleZip.DeflaterHuffman.staticDLength = new byte[30];
                if (true)
                {
                  int num2;
                  for (index = 0; index < 30; index = num2 + 1)
                  {
                    SimpleZip.DeflaterHuffman.staticDCodes[index] = SimpleZip.DeflaterHuffman.BitReverse(index << 11);
                    if (true)
                    {
                      SimpleZip.DeflaterHuffman.staticDLength[index] = (byte) 5;
                      num2 = index;
                      if (false)
                      {
                        num1 = num2;
                        goto label_13;
                      }
                    }
                    else
                      goto label_1;
                  }
                  break;
                }
                goto label_4;
              }
            }
            return;
          }
          goto label_0;
        }
label_23:
        if (index < 144)
        {
          SimpleZip.DeflaterHuffman.staticLCodes[index] = SimpleZip.DeflaterHuffman.BitReverse(48 + index << 8);
          goto label_4;
        }
        else
          goto label_8;
      }

      public DeflaterHuffman(SimpleZip.DeflaterPending pending)
      {
        this.pending = pending;
        this.literalTree = new SimpleZip.DeflaterHuffman.Tree(this, 286, 257, 15);
        this.distTree = new SimpleZip.DeflaterHuffman.Tree(this, 30, 1, 15);
        this.blTree = new SimpleZip.DeflaterHuffman.Tree(this, 19, 4, 7);
        this.d_buf = new short[16384];
        this.l_buf = new byte[16384];
      }

      public void Init()
      {
        this.last_lit = 0;
        this.extra_bits = 0;
      }

      private int Lcode(int len)
      {
        int num1 = len;
        int num2;
        if (true)
        {
          if (num1 == (int) byte.MaxValue)
            return 285;
          if (true)
          {
            num2 = 257;
            goto label_14;
          }
          else
            goto label_14;
        }
        else
          goto label_12;
label_5:
        int num3;
        if (true)
          num3 >>= 1;
        len = num3;
        goto label_14;
label_12:
        num2 = num1;
        num3 = len;
        goto label_5;
label_14:
        int num4 = len;
        if (false)
        {
          num3 = num4;
          goto label_5;
        }
        else
        {
          int num5 = 8;
          if (num5 != 0)
          {
            if (num4 >= num5)
            {
              num1 = num2 + 4;
              goto label_12;
            }
            else
            {
              int num6 = num2;
              num5 = len;
              num4 = num6;
            }
          }
          return num4 + num5;
        }
      }

      private int Dcode(int distance)
      {
        int num1;
        do
        {
          if (true)
            goto label_10;
label_1:
          continue;
label_10:
          num1 = 0;
          goto label_1;
        }
        while (false);
        int num2;
        while (true)
        {
          int num3 = distance;
          int num4 = 4;
          int num5;
          int num6;
          while (true)
          {
            if (num3 >= num4)
              goto label_11;
            else
              goto label_13;
label_4:
            num6 = 1;
            int num7;
            num5 = num7;
label_5:
            if (num6 == 0)
            {
              num4 = num6;
              num3 = num5;
              continue;
            }
            break;
label_11:
            num5 = num1;
            num6 = 2;
            if (num6 != 0)
            {
              num1 = num5 + num6;
              num7 = distance;
              goto label_4;
            }
            else
              goto label_5;
label_13:
            num2 = num1 + distance;
            if (false)
            {
              num7 = num2;
              goto label_4;
            }
            else
              goto label_9;
          }
          distance = num5 >> num6;
        }
label_9:
        return num2;
      }

      public void SendAllTrees(int blTreeCodes)
      {
        SimpleZip.DeflaterHuffman.Tree blTree = this.blTree;
        if (true)
          blTree.BuildCodes();
        this.literalTree.BuildCodes();
        this.distTree.BuildCodes();
        this.pending.WriteBits(this.literalTree.numCodes - 257, 5);
        this.pending.WriteBits(this.distTree.numCodes - 1, 5);
        this.pending.WriteBits(blTreeCodes - 4, 4);
        for (int index = 0; index < blTreeCodes; ++index)
          this.pending.WriteBits((int) this.blTree.length[SimpleZip.DeflaterHuffman.BL_ORDER[index]], 3);
        this.literalTree.WriteTree(this.blTree);
        this.distTree.WriteTree(this.blTree);
      }

      public unsafe void CompressBlock()
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(20);
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < this.last_lit)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) this.l_buf[*(int*) voidPtr] & (int) byte.MaxValue;
          int num = (int) this.d_buf[*(int*) voidPtr];
          int distance = num - 1;
          if (num != 0)
          {
            *(int*) ((IntPtr) voidPtr + 8) = this.Lcode(*(int*) ((IntPtr) voidPtr + 4));
            this.literalTree.WriteSymbol(*(int*) ((IntPtr) voidPtr + 8));
            *(int*) ((IntPtr) voidPtr + 12) = (*(int*) ((IntPtr) voidPtr + 8) - 261) / 4;
            if (*(int*) ((IntPtr) voidPtr + 12) > 0 && *(int*) ((IntPtr) voidPtr + 12) <= 5)
              this.pending.WriteBits(*(int*) ((IntPtr) voidPtr + 4) & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
            *(int*) ((IntPtr) voidPtr + 16) = this.Dcode(distance);
            this.distTree.WriteSymbol(*(int*) ((IntPtr) voidPtr + 16));
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 16) / 2 - 1;
            if (*(int*) ((IntPtr) voidPtr + 12) > 0)
              this.pending.WriteBits(distance & (1 << *(int*) ((IntPtr) voidPtr + 12)) - 1, *(int*) ((IntPtr) voidPtr + 12));
          }
          else
            this.literalTree.WriteSymbol(*(int*) ((IntPtr) voidPtr + 4));
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        this.literalTree.WriteSymbol(256);
      }

      public void FlushStoredBlock(
        byte[] stored,
        int storedOffset,
        int storedLength,
        bool lastBlock)
      {
        this.pending.WriteBits(lastBlock ? 1 : 0, 3);
        this.pending.AlignToByte();
        this.pending.WriteShort(storedLength);
        this.pending.WriteShort(~storedLength);
        this.pending.WriteBlock(stored, storedOffset, storedLength);
        this.Init();
      }

      public unsafe void FlushBlock(
        byte[] stored,
        int storedOffset,
        int storedLength,
        bool lastBlock)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(24);
        short[] freqs;
        (freqs = this.literalTree.freqs)[256] = (short) ((int) freqs[256] + 1);
        this.literalTree.BuildTree();
        this.distTree.BuildTree();
        this.literalTree.CalcBLFreq(this.blTree);
        this.distTree.CalcBLFreq(this.blTree);
        this.blTree.BuildTree();
        *(int*) voidPtr = 4;
        *(int*) ((IntPtr) voidPtr + 4) = 18;
        while (*(int*) ((IntPtr) voidPtr + 4) > *(int*) voidPtr)
        {
          if (this.blTree.length[SimpleZip.DeflaterHuffman.BL_ORDER[*(int*) ((IntPtr) voidPtr + 4)]] > (byte) 0)
            *(int*) voidPtr = *(int*) ((IntPtr) voidPtr + 4) + 1;
          *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) - 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 14 + *(int*) voidPtr * 3 + this.blTree.GetEncodedLength() + this.literalTree.GetEncodedLength() + this.distTree.GetEncodedLength() + this.extra_bits;
        *(int*) ((IntPtr) voidPtr + 12) = this.extra_bits;
        *(int*) ((IntPtr) voidPtr + 16) = 0;
        while (*(int*) ((IntPtr) voidPtr + 16) < 286)
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) this.literalTree.freqs[*(int*) ((IntPtr) voidPtr + 16)] * (int) SimpleZip.DeflaterHuffman.staticLLength[*(int*) ((IntPtr) voidPtr + 16)];
          *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
        }
        *(int*) ((IntPtr) voidPtr + 20) = 0;
        while (*(int*) ((IntPtr) voidPtr + 20) < 30)
        {
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + (int) this.distTree.freqs[*(int*) ((IntPtr) voidPtr + 20)] * (int) SimpleZip.DeflaterHuffman.staticDLength[*(int*) ((IntPtr) voidPtr + 20)];
          *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
        }
        if (*(int*) ((IntPtr) voidPtr + 8) >= *(int*) ((IntPtr) voidPtr + 12))
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 12);
        if (storedOffset >= 0 && storedLength + 4 < *(int*) ((IntPtr) voidPtr + 8) >> 3)
          this.FlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
        else if (*(int*) ((IntPtr) voidPtr + 8) == *(int*) ((IntPtr) voidPtr + 12))
        {
          this.pending.WriteBits(2 + (lastBlock ? 1 : 0), 3);
          this.literalTree.SetStaticCodes(SimpleZip.DeflaterHuffman.staticLCodes, SimpleZip.DeflaterHuffman.staticLLength);
          this.distTree.SetStaticCodes(SimpleZip.DeflaterHuffman.staticDCodes, SimpleZip.DeflaterHuffman.staticDLength);
          this.CompressBlock();
          this.Init();
        }
        else
        {
          this.pending.WriteBits(4 + (lastBlock ? 1 : 0), 3);
          this.SendAllTrees(*(int*) voidPtr);
          this.CompressBlock();
          this.Init();
        }
      }

      public bool IsFull() => this.last_lit >= 16384;

      public bool TallyLit(int lit)
      {
        this.d_buf[this.last_lit] = (short) 0;
        byte[] lBuf = this.l_buf;
        SimpleZip.DeflaterHuffman deflaterHuffman = this;
        int lastLit;
        int num1 = lastLit = deflaterHuffman.last_lit;
        deflaterHuffman.last_lit = lastLit + 1;
        int index1 = num1;
        int num2 = (int) (byte) lit;
        lBuf[index1] = (byte) num2;
        short[] freqs;
        int index2;
        (freqs = this.literalTree.freqs)[index2 = lit] = (short) ((int) freqs[(IntPtr) index2] + 1);
        return this.IsFull();
      }

      public unsafe bool TallyDist(int dist, int len)
      {
        int num1 = 8;
        void* voidPtr;
        int num2;
        while (true)
        {
          // ISSUE: untyped stack allocation
          voidPtr = (void*) __untypedstackalloc(num1);
          this.d_buf[this.last_lit] = (short) dist;
          byte[] lBuf = this.l_buf;
          SimpleZip.DeflaterHuffman deflaterHuffman = this;
          int lastLit;
          int num3 = lastLit = deflaterHuffman.last_lit;
          deflaterHuffman.last_lit = lastLit + 1;
          int index1 = num3;
          int num4 = (int) (byte) (len - 3);
          lBuf[index1] = (byte) num4;
          *(int*) voidPtr = this.Lcode(len - 3);
          short[] freqs;
          IntPtr index2;
          (freqs = this.literalTree.freqs)[(int) (index2 = (IntPtr) *(int*) voidPtr)] = (short) ((int) freqs[index2] + 1);
          num2 = *(int*) voidPtr;
          if (false)
            num1 = num2;
          else
            break;
        }
        if (num2 >= 265 && *(int*) voidPtr < 285)
          this.extra_bits += (*(int*) voidPtr - 261) / 4;
        *(int*) ((IntPtr) voidPtr + 4) = this.Dcode(dist - 1);
        short[] freqs1;
        IntPtr index;
        (freqs1 = this.distTree.freqs)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 4))] = (short) ((int) freqs1[index] + 1);
        if (*(int*) ((IntPtr) voidPtr + 4) >= 4)
          this.extra_bits += *(int*) ((IntPtr) voidPtr + 4) / 2 - 1;
        return this.IsFull();
      }

      public sealed class Tree
      {
        public short[] freqs;
        public byte[] length;
        public int minNumCodes;
        public int numCodes;
        private short[] codes;
        private int[] bl_counts;
        private int maxLength;
        private SimpleZip.DeflaterHuffman dh;

        public Tree(SimpleZip.DeflaterHuffman dh, int elems, int minCodes, int maxLength)
        {
          this.dh = dh;
          this.minNumCodes = minCodes;
          this.maxLength = maxLength;
          this.freqs = new short[elems];
          this.bl_counts = new int[maxLength];
        }

        public void WriteSymbol(int code) => this.dh.pending.WriteBits((int) this.codes[code] & (int) ushort.MaxValue, (int) this.length[code]);

        public void SetStaticCodes(short[] stCodes, byte[] stLength)
        {
          this.codes = stCodes;
          this.length = stLength;
        }

        public unsafe void BuildCodes()
        {
          // ISSUE: untyped stack allocation
          void* voidPtr = (void*) __untypedstackalloc(16);
          int length = this.freqs.Length;
          int[] numArray = new int[this.maxLength];
          do
          {
            *(int*) voidPtr = 0;
            this.codes = new short[this.freqs.Length];
            *(int*) ((IntPtr) voidPtr + 4) = 0;
          }
          while (false);
          while (*(int*) ((IntPtr) voidPtr + 4) < this.maxLength)
          {
            numArray[*(int*) ((IntPtr) voidPtr + 4)] = *(int*) voidPtr;
            *(int*) voidPtr = *(int*) voidPtr + (this.bl_counts[*(int*) ((IntPtr) voidPtr + 4)] << 15 - *(int*) ((IntPtr) voidPtr + 4));
            *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
          }
          *(int*) ((IntPtr) voidPtr + 8) = 0;
          while (*(int*) ((IntPtr) voidPtr + 8) < this.numCodes)
          {
            *(int*) ((IntPtr) voidPtr + 12) = (int) this.length[*(int*) ((IntPtr) voidPtr + 8)];
            if (*(int*) ((IntPtr) voidPtr + 12) > 0)
            {
              this.codes[*(int*) ((IntPtr) voidPtr + 8)] = SimpleZip.DeflaterHuffman.BitReverse(numArray[*(int*) ((IntPtr) voidPtr + 12) - 1]);
              numArray[*(int*) ((IntPtr) voidPtr + 12) - 1] += 1 << 16 - *(int*) ((IntPtr) voidPtr + 12);
            }
            *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
          }
        }

        private unsafe void BuildLength(int[] childs)
        {
          // ISSUE: untyped stack allocation
          void* voidPtr = (void*) __untypedstackalloc(36);
          this.length = new byte[this.freqs.Length];
          *(int*) voidPtr = childs.Length / 2;
          *(int*) ((IntPtr) voidPtr + 4) = (*(int*) voidPtr + 1) / 2;
          *(int*) ((IntPtr) voidPtr + 8) = 0;
          *(int*) ((IntPtr) voidPtr + 12) = 0;
          while (true)
          {
            if (*(int*) ((IntPtr) voidPtr + 12) < this.maxLength)
              this.bl_counts[*(int*) ((IntPtr) voidPtr + 12)] = 0;
            else
              goto label_6;
label_4:
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            continue;
label_6:
            int[] numArray = new int[*(int*) voidPtr];
            numArray[*(int*) voidPtr - 1] = 0;
            *(int*) ((IntPtr) voidPtr + 16) = *(int*) voidPtr - 1;
            while (*(int*) ((IntPtr) voidPtr + 16) >= 0)
            {
              int num1 = childs[2 * *(int*) ((IntPtr) voidPtr + 16) + 1];
              int num2;
              while (true)
              {
                if (num1 != -1)
                {
                  *(int*) ((IntPtr) voidPtr + 20) = numArray[*(int*) ((IntPtr) voidPtr + 16)] + 1;
                  num2 = *(int*) ((IntPtr) voidPtr + 20);
                  if (false)
                    num1 = num2;
                  else
                    break;
                }
                else
                  goto label_14;
              }
              int maxLength = this.maxLength;
              if (num2 > maxLength)
              {
                *(int*) ((IntPtr) voidPtr + 20) = this.maxLength;
                *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
              }
              if (true)
              {
                numArray[childs[2 * *(int*) ((IntPtr) voidPtr + 16)]] = numArray[childs[2 * *(int*) ((IntPtr) voidPtr + 16) + 1]] = *(int*) ((IntPtr) voidPtr + 20);
                goto label_15;
              }
              else
                goto label_4;
label_14:
              *(int*) ((IntPtr) voidPtr + 24) = numArray[*(int*) ((IntPtr) voidPtr + 16)];
              ++this.bl_counts[*(int*) ((IntPtr) voidPtr + 24) - 1];
              this.length[childs[2 * *(int*) ((IntPtr) voidPtr + 16)]] = (byte) numArray[*(int*) ((IntPtr) voidPtr + 16)];
label_15:
              *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) - 1;
            }
            break;
          }
          if (*(int*) ((IntPtr) voidPtr + 8) == 0)
            return;
          int index1;
          if (true)
            index1 = this.maxLength - 1;
          else
            goto label_23;
label_21:
          while (this.bl_counts[--index1] == 0)
            ;
label_22:
          --this.bl_counts[index1];
label_23:
          int[] blCounts;
          int[] numArray1 = blCounts = this.bl_counts;
          int index2;
          index1 = index2 = index1 + 1;
          int index3 = index2;
          int num3 = numArray1[(IntPtr) index3] + 1;
          blCounts[index2] = num3;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - (1 << this.maxLength - 1 - index1);
          if (*(int*) ((IntPtr) voidPtr + 8) <= 0 || index1 >= this.maxLength - 1)
          {
            if (*(int*) ((IntPtr) voidPtr + 8) <= 0)
            {
              this.bl_counts[this.maxLength - 1] += *(int*) ((IntPtr) voidPtr + 8);
              this.bl_counts[this.maxLength - 2] -= *(int*) ((IntPtr) voidPtr + 8);
              int num4 = 2 * *(int*) ((IntPtr) voidPtr + 4);
              *(int*) ((IntPtr) voidPtr + 28) = this.maxLength;
              while (*(int*) ((IntPtr) voidPtr + 28) != 0)
              {
                *(int*) ((IntPtr) voidPtr + 32) = this.bl_counts[*(int*) ((IntPtr) voidPtr + 28) - 1];
                while (*(int*) ((IntPtr) voidPtr + 32) > 0)
                {
                  int index4 = 2 * childs[num4++];
                  if (childs[index4 + 1] == -1)
                  {
                    this.length[childs[index4]] = (byte) *(int*) ((IntPtr) voidPtr + 28);
                    *(int*) ((IntPtr) voidPtr + 32) = *(int*) ((IntPtr) voidPtr + 32) - 1;
                  }
                }
                *(int*) ((IntPtr) voidPtr + 28) = *(int*) ((IntPtr) voidPtr + 28) - 1;
              }
            }
            else
              goto label_21;
          }
          else
            goto label_22;
        }

        public unsafe void BuildTree()
        {
          // ISSUE: untyped stack allocation
          void* voidPtr = (void*) __untypedstackalloc(36);
          *(int*) voidPtr = this.freqs.Length;
          int[] numArray1 = new int[*(int*) voidPtr];
          int num1 = 0;
          int num2 = 0;
          int[] childs;
          while (true)
          {
            int num3 = num2;
            *(int*) ((IntPtr) voidPtr + 4) = 0;
            int num4;
            while (true)
            {
              if (*(int*) ((IntPtr) voidPtr + 4) < *(int*) voidPtr)
                goto label_49;
              else
                goto label_14;
label_3:
              int num5;
              num1 = num5 + 1;
              int index1;
              int index2;
              for (index1 = num5; index1 > 0 && (int) this.freqs[numArray1[index2 = (index1 - 1) / 2]] > *(int*) ((IntPtr) voidPtr + 8); index1 = index2)
                numArray1[index1] = numArray1[index2];
              numArray1[index1] = *(int*) ((IntPtr) voidPtr + 4);
              num3 = *(int*) ((IntPtr) voidPtr + 4);
label_7:
              *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
              continue;
label_14:
              int num6;
              int num7;
              while (true)
              {
                int num8;
                int num9;
                int num10;
                if (num1 < 2)
                {
                  num8 = num3;
                  num9 = 2;
                  if (num9 != 0)
                  {
                    if (num8 < num9)
                    {
                      num10 = ++num3;
                      goto label_13;
                    }
                  }
                  else
                    goto label_17;
                }
                else
                  goto label_15;
label_11:
                num10 = 0;
label_13:
                int num11 = num10;
                numArray1[num1++] = num11;
                continue;
label_15:
                this.numCodes = Math.Max(num3 + 1, this.minNumCodes);
                *(int*) ((IntPtr) voidPtr + 12) = num1;
                num6 = 4;
                num7 = num1;
                if (true)
                {
                  childs = new int[num6 * num7 - 2];
                  num9 = num1;
                  num8 = 2;
                }
                else
                  break;
label_17:
                int[] numArray2 = new int[num8 * num9 - 1];
                int num12 = *(int*) ((IntPtr) voidPtr + 12);
                *(int*) ((IntPtr) voidPtr + 16) = 0;
                while (*(int*) ((IntPtr) voidPtr + 16) < num1)
                {
                  if (true)
                  {
                    *(int*) ((IntPtr) voidPtr + 20) = numArray1[*(int*) ((IntPtr) voidPtr + 16)];
                    childs[2 * *(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 20);
                    childs[2 * *(int*) ((IntPtr) voidPtr + 16) + 1] = -1;
                    numArray2[*(int*) ((IntPtr) voidPtr + 16)] = (int) this.freqs[*(int*) ((IntPtr) voidPtr + 20)] << 8;
                    numArray1[*(int*) ((IntPtr) voidPtr + 16)] = *(int*) ((IntPtr) voidPtr + 16);
                    *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
                  }
                  else
                    goto label_11;
                }
                int num13;
                do
                {
                  *(int*) ((IntPtr) voidPtr + 24) = numArray1[0];
                  int index3 = numArray1[--num1];
                  int index4 = 0;
                  int index5 = 1;
                  int num14;
                  int num15;
                  while (true)
                  {
                    if (index5 < num1)
                    {
                      if (index5 + 1 < num1 && numArray2[numArray1[index5]] > numArray2[numArray1[index5 + 1]])
                        ++index5;
                      numArray1[index4] = numArray1[index5];
                      index4 = index5;
                      num13 = index5;
                      if (true)
                      {
                        num14 = num13 * 2;
                        num15 = 1;
                        if (num15 != 0)
                          index5 = num14 + num15;
                        else
                          goto label_45;
                      }
                      else
                        goto label_1;
                    }
                    else
                      break;
                  }
                  int num16 = numArray2[index3];
                  while (true)
                  {
                    int num17;
                    int index6 = num17 = index4;
                    while (true)
                    {
                      if (num17 <= 0 || numArray2[numArray1[index4 = (index6 - 1) / 2]] <= num16)
                      {
                        numArray1[index6] = index3;
                        *(int*) ((IntPtr) voidPtr + 28) = numArray1[0];
                        index3 = num12++;
                        childs[2 * index3] = *(int*) ((IntPtr) voidPtr + 24);
                        childs[2 * index3 + 1] = *(int*) ((IntPtr) voidPtr + 28);
                        *(int*) ((IntPtr) voidPtr + 32) = Math.Min(numArray2[*(int*) ((IntPtr) voidPtr + 24)] & (int) byte.MaxValue, numArray2[*(int*) ((IntPtr) voidPtr + 28)] & (int) byte.MaxValue);
                        numArray2[index3] = num16 = numArray2[*(int*) ((IntPtr) voidPtr + 24)] + numArray2[*(int*) ((IntPtr) voidPtr + 28)] - *(int*) ((IntPtr) voidPtr + 32) + 1;
                        if (true)
                          index4 = 0;
                        index6 = 1;
                        int num18;
                        while (true)
                        {
                          if (true)
                          {
                            num4 = index6;
                            if (true)
                            {
                              int num19 = num1;
                              if (num4 < num19)
                              {
                                if (index6 + 1 < num1 && numArray2[numArray1[index6]] > numArray2[numArray1[index6 + 1]])
                                {
                                  num18 = index6 + 1;
                                  if (true)
                                    index6 = num18;
                                  else
                                    break;
                                }
                                numArray1[index4] = numArray1[index6];
                                index4 = index6;
                                index6 = index4 * 2 + 1;
                              }
                              else
                                goto label_43;
                            }
                            else
                              goto label_51;
                          }
                          else
                            goto label_15;
                        }
                        num17 = num18;
                      }
                      else
                        break;
                    }
                    numArray1[index6] = numArray1[index4];
                  }
label_43:
                  if ((index5 = index4) > 0)
                  {
                    int num20 = numArray2[numArray1[index4 = (index5 - 1) / 2]];
                    num15 = num16;
                    num14 = num20;
                  }
                  else
                    goto label_46;
label_45:
                  if (num14 > num15)
                  {
                    numArray1[index5] = numArray1[index4];
                    goto label_43;
                  }
label_46:
                  numArray1[index5] = index3;
                }
                while (num1 > 1);
                goto label_47;
label_1:
                num10 = num13;
                goto label_13;
              }
              num5 = num7;
              num5 = num6;
              goto label_3;
label_49:
              *(int*) ((IntPtr) voidPtr + 8) = (int) this.freqs[*(int*) ((IntPtr) voidPtr + 4)];
              if (*(int*) ((IntPtr) voidPtr + 8) != 0)
              {
                num5 = num1;
                goto label_3;
              }
              else
                goto label_7;
            }
label_51:
            num2 = num4;
          }
label_47:
          this.BuildLength(childs);
        }

        public unsafe int GetEncodedLength()
        {
          int encodedLength = 8;
          if (encodedLength == 0)
            return encodedLength;
          // ISSUE: untyped stack allocation
          IntPtr num = __untypedstackalloc(encodedLength);
          void* voidPtr;
          if (true)
            voidPtr = (void*) num;
          do
          {
            *(int*) voidPtr = 0;
            *(int*) ((IntPtr) voidPtr + 4) = 0;
            while (*(int*) ((IntPtr) voidPtr + 4) < this.freqs.Length)
            {
              *(int*) voidPtr = *(int*) voidPtr + (int) this.freqs[*(int*) ((IntPtr) voidPtr + 4)] * (int) this.length[*(int*) ((IntPtr) voidPtr + 4)];
              *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
            }
          }
          while (false);
          return *(int*) voidPtr;
        }

        public unsafe void CalcBLFreq(SimpleZip.DeflaterHuffman.Tree blTree)
        {
          void* voidPtr;
          if (true)
          {
            // ISSUE: untyped stack allocation
            voidPtr = (void*) __untypedstackalloc(20);
            *(int*) ((IntPtr) voidPtr + 8) = -1;
            *(int*) ((IntPtr) voidPtr + 12) = 0;
            goto label_17;
          }
label_5:
          *(int*) ((IntPtr) voidPtr + 4) = 3;
          int num;
          if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
          {
            short[] freqs;
            IntPtr index;
            (freqs = blTree.freqs)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 16))] = (short) ((int) freqs[index] + 1);
            num = 0;
          }
label_7:
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
          *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
          while (*(int*) ((IntPtr) voidPtr + 12) < this.numCodes && *(int*) ((IntPtr) voidPtr + 8) == (int) this.length[*(int*) ((IntPtr) voidPtr + 12)])
          {
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            if (++num >= *(int*) voidPtr)
              break;
          }
          if (num < *(int*) ((IntPtr) voidPtr + 4))
          {
            short[] freqs;
            IntPtr index;
            (freqs = blTree.freqs)[(int) (index = (IntPtr) *(int*) ((IntPtr) voidPtr + 8))] = (short) ((int) freqs[index] + (int) (short) num);
          }
          else if (*(int*) ((IntPtr) voidPtr + 8) != 0)
          {
            short[] freqs;
            (freqs = blTree.freqs)[16] = (short) ((int) freqs[16] + 1);
          }
          else if (num <= 10)
          {
            short[] freqs;
            (freqs = blTree.freqs)[17] = (short) ((int) freqs[17] + 1);
          }
          else
          {
            short[] freqs;
            (freqs = blTree.freqs)[18] = (short) ((int) freqs[18] + 1);
          }
label_17:
          if (*(int*) ((IntPtr) voidPtr + 12) >= this.numCodes)
            return;
          num = 1;
          *(int*) ((IntPtr) voidPtr + 16) = (int) this.length[*(int*) ((IntPtr) voidPtr + 12)];
          if (*(int*) ((IntPtr) voidPtr + 16) != 0)
          {
            *(int*) voidPtr = 6;
            goto label_5;
          }
          else
          {
            *(int*) voidPtr = 138;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            goto label_7;
          }
        }

        public unsafe void WriteTree(SimpleZip.DeflaterHuffman.Tree blTree)
        {
          // ISSUE: untyped stack allocation
          void* voidPtr = (void*) __untypedstackalloc(20);
          *(int*) ((IntPtr) voidPtr + 8) = -1;
          *(int*) ((IntPtr) voidPtr + 12) = 0;
          while (*(int*) ((IntPtr) voidPtr + 12) < this.numCodes)
          {
            int num = 1;
            *(int*) ((IntPtr) voidPtr + 16) = (int) this.length[*(int*) ((IntPtr) voidPtr + 12)];
            if (*(int*) ((IntPtr) voidPtr + 16) != 0)
            {
              *(int*) voidPtr = 6;
              *(int*) ((IntPtr) voidPtr + 4) = 3;
              if (*(int*) ((IntPtr) voidPtr + 8) != *(int*) ((IntPtr) voidPtr + 16))
              {
                blTree.WriteSymbol(*(int*) ((IntPtr) voidPtr + 16));
                num = 0;
              }
            }
            else
              goto label_17;
label_4:
            *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 16);
            *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
            while (*(int*) ((IntPtr) voidPtr + 12) < this.numCodes && *(int*) ((IntPtr) voidPtr + 8) == (int) this.length[*(int*) ((IntPtr) voidPtr + 12)])
            {
              *(int*) ((IntPtr) voidPtr + 12) = *(int*) ((IntPtr) voidPtr + 12) + 1;
              if (++num >= *(int*) voidPtr)
                break;
            }
            if (num < *(int*) ((IntPtr) voidPtr + 4))
            {
              while (num-- > 0)
                blTree.WriteSymbol(*(int*) ((IntPtr) voidPtr + 8));
              continue;
            }
            if (*(int*) ((IntPtr) voidPtr + 8) != 0)
            {
              blTree.WriteSymbol(16);
              this.dh.pending.WriteBits(num - 3, 2);
              continue;
            }
            if (num <= 10)
            {
              blTree.WriteSymbol(17);
              this.dh.pending.WriteBits(num - 3, 3);
              continue;
            }
            blTree.WriteSymbol(18);
            this.dh.pending.WriteBits(num - 11, 7);
            continue;
label_17:
            *(int*) voidPtr = 138;
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            goto label_4;
          }
        }
      }
    }

    internal sealed class DeflaterEngine
    {
      private const int MAX_MATCH = 258;
      private const int MIN_MATCH = 3;
      private const int WSIZE = 32768;
      private const int WMASK = 32767;
      private const int HASH_SIZE = 32768;
      private const int HASH_MASK = 32767;
      private const int HASH_SHIFT = 5;
      private const int MIN_LOOKAHEAD = 262;
      private const int MAX_DIST = 32506;
      private const int TOO_FAR = 4096;
      private int ins_h;
      private short[] head;
      private short[] prev;
      private int matchStart;
      private int matchLen;
      private bool prevAvailable;
      private int blockStart;
      private int strstart;
      private int lookahead;
      private byte[] window;
      private byte[] inputBuf;
      private int totalIn;
      private int inputOff;
      private int inputEnd;
      private SimpleZip.DeflaterPending pending;
      private SimpleZip.DeflaterHuffman huffman;

      public DeflaterEngine(SimpleZip.DeflaterPending pending)
      {
        this.pending = pending;
        this.huffman = new SimpleZip.DeflaterHuffman(pending);
        this.window = new byte[65536];
        this.head = new short[32768];
        this.prev = new short[32768];
        this.blockStart = this.strstart = 1;
      }

      private void UpdateHash() => this.ins_h = (int) this.window[this.strstart] << 5 ^ (int) this.window[this.strstart + 1];

      private int InsertString()
      {
        int index;
        short num1;
        int num2;
        int maxValue;
        do
        {
          num2 = this.ins_h << 5;
          maxValue = (int) this.window[this.strstart + 2];
          if (true)
          {
            index = (num2 ^ maxValue) & (int) short.MaxValue;
            this.prev[this.strstart & (int) short.MaxValue] = num1 = this.head[index];
          }
          else
            goto label_3;
        }
        while (false);
        this.head[index] = (short) this.strstart;
        this.ins_h = index;
        int num3 = (int) num1;
        maxValue = (int) ushort.MaxValue;
        num2 = num3;
label_3:
        return num2 & maxValue;
      }

      private unsafe void SlideWindow()
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(16);
        Array.Copy((Array) this.window, 32768, (Array) this.window, 0, 32768);
        this.matchStart -= 32768;
        this.strstart -= 32768;
        this.blockStart -= 32768;
        *(int*) voidPtr = 0;
        while (*(int*) voidPtr < 32768)
        {
          *(int*) ((IntPtr) voidPtr + 4) = (int) this.head[*(int*) voidPtr] & (int) ushort.MaxValue;
          this.head[*(int*) voidPtr] = *(int*) ((IntPtr) voidPtr + 4) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 4) - 32768) : (short) 0;
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        *(int*) ((IntPtr) voidPtr + 8) = 0;
        while (*(int*) ((IntPtr) voidPtr + 8) < 32768)
        {
          *(int*) ((IntPtr) voidPtr + 12) = (int) this.prev[*(int*) ((IntPtr) voidPtr + 8)] & (int) ushort.MaxValue;
          this.prev[*(int*) ((IntPtr) voidPtr + 8)] = *(int*) ((IntPtr) voidPtr + 12) >= 32768 ? (short) (*(int*) ((IntPtr) voidPtr + 12) - 32768) : (short) 0;
          *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) + 1;
        }
      }

      public void FillWindow()
      {
label_0:
        int num1 = this.strstart;
        int num2 = 65274;
        if (num2 != 0)
        {
          if (num1 >= num2)
          {
            this.SlideWindow();
            goto label_11;
          }
          else
            goto label_11;
        }
        else
          goto label_14;
label_10:
        int length;
        this.totalIn += length;
        this.lookahead += length;
label_11:
        if (this.lookahead >= 262)
          goto label_15;
label_12:
        int num3 = this.inputOff;
        if (true)
        {
          num2 = this.inputEnd;
          num1 = num3;
        }
        else
          goto label_19;
label_14:
        if (num1 < num2)
        {
          if (true)
          {
            num3 = 65536 - this.lookahead - this.strstart;
            goto label_19;
          }
          else
            goto label_10;
        }
label_15:
        if (true)
        {
          if (this.lookahead < 3)
            return;
          this.UpdateHash();
          return;
        }
        goto label_12;
label_19:
        length = num3;
        if (length > this.inputEnd - this.inputOff)
        {
          int inputEnd = this.inputEnd;
          int inputOff = this.inputOff;
          if (true)
          {
            length = inputEnd - inputOff;
          }
          else
          {
            num2 = inputOff;
            num1 = inputEnd;
            goto label_14;
          }
        }
        Array.Copy((Array) this.inputBuf, this.inputOff, (Array) this.window, this.strstart + this.lookahead, length);
        if (true)
        {
          this.inputOff += length;
          goto label_10;
        }
        else
          goto label_0;
      }

      private unsafe bool FindLongestMatch(int curMatch)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(22);
        int num1 = 128;
        *(int*) voidPtr = 128;
        short[] prev = this.prev;
        int strstart = this.strstart;
        *(int*) ((IntPtr) voidPtr + 4) = this.strstart + this.matchLen;
        *(int*) ((IntPtr) voidPtr + 8) = Math.Max(this.matchLen, 2);
        *(int*) ((IntPtr) voidPtr + 12) = Math.Max(this.strstart - 32506, 0);
        *(int*) ((IntPtr) voidPtr + 16) = this.strstart + 258 - 1;
        *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) this.window[*(int*) ((IntPtr) voidPtr + 4) - 1];
        *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) this.window[*(int*) ((IntPtr) voidPtr + 4)];
        if (*(int*) ((IntPtr) voidPtr + 8) >= 8)
          num1 >>= 2;
        if (*(int*) voidPtr > this.lookahead)
          *(int*) voidPtr = this.lookahead;
        int num2;
        int num3;
        do
        {
          if ((int) this.window[curMatch + *(int*) ((IntPtr) voidPtr + 8)] == (int) *(byte*) ((IntPtr) voidPtr + 21) && (int) this.window[curMatch + *(int*) ((IntPtr) voidPtr + 8) - 1] == (int) *(byte*) ((IntPtr) voidPtr + 20) && (int) this.window[curMatch] == (int) this.window[strstart] && (int) this.window[curMatch + 1] == (int) this.window[strstart + 1])
          {
            int num4 = curMatch + 2;
            int num5 = strstart + 2;
            int num6;
            int num7;
            int num8;
            int num9;
            int num10;
            int num11;
            int num12;
            do
              ;
            while ((int) this.window[++num5] == (int) this.window[num6 = num4 + 1] && (int) this.window[++num5] == (int) this.window[num7 = num6 + 1] && (int) this.window[++num5] == (int) this.window[num8 = num7 + 1] && (int) this.window[++num5] == (int) this.window[num9 = num8 + 1] && (int) this.window[++num5] == (int) this.window[num10 = num9 + 1] && (int) this.window[++num5] == (int) this.window[num11 = num10 + 1] && (int) this.window[++num5] == (int) this.window[num12 = num11 + 1] && (int) this.window[++num5] == (int) this.window[num4 = num12 + 1] && num5 < *(int*) ((IntPtr) voidPtr + 16));
            if (num5 > *(int*) ((IntPtr) voidPtr + 4))
            {
              this.matchStart = curMatch;
              *(int*) ((IntPtr) voidPtr + 4) = num5;
              *(int*) ((IntPtr) voidPtr + 8) = num5 - this.strstart;
              if (*(int*) ((IntPtr) voidPtr + 8) < *(int*) voidPtr)
              {
                *(sbyte*) ((IntPtr) voidPtr + 20) = (sbyte) this.window[*(int*) ((IntPtr) voidPtr + 4) - 1];
                *(sbyte*) ((IntPtr) voidPtr + 21) = (sbyte) this.window[*(int*) ((IntPtr) voidPtr + 4)];
              }
              else
                break;
            }
            strstart = this.strstart;
          }
          if ((curMatch = (int) prev[curMatch & (int) short.MaxValue] & (int) ushort.MaxValue) > *(int*) ((IntPtr) voidPtr + 12))
          {
            num2 = num1;
            num3 = 1;
            if (num3 == 0)
              goto label_1;
          }
          else
            break;
        }
        while ((num1 = num2 - num3) != 0);
        this.matchLen = Math.Min(*(int*) ((IntPtr) voidPtr + 8), this.lookahead);
        int num13 = this.matchLen;
        int num14 = 3;
label_16:
        return num13 >= num14;
label_1:
        num14 = num3;
        num13 = num2;
        goto label_16;
      }

      private unsafe bool DeflateSlow(bool flush, bool finish)
      {
        // ISSUE: untyped stack allocation
        void* voidPtr = (void*) __untypedstackalloc(12);
        if (this.lookahead < 262 && !flush)
          return false;
label_33:
        int num1 = this.lookahead;
        if (false)
          goto label_11;
        else
          goto label_34;
label_7:
        int matchLen;
        int len = matchLen;
        if (this.lookahead >= 3)
        {
          *(int*) ((IntPtr) voidPtr + 4) = this.InsertString();
          if (true)
          {
            if (*(int*) ((IntPtr) voidPtr + 4) != 0 && this.strstart - *(int*) ((IntPtr) voidPtr + 4) <= 32506 && this.FindLongestMatch(*(int*) ((IntPtr) voidPtr + 4)))
              num1 = this.matchLen;
            else
              goto label_15;
          }
          else
            goto label_24;
        }
        else
          goto label_15;
label_11:
        int num2;
        if (num1 <= 5)
          num2 = this.matchLen;
        else
          goto label_15;
label_13:
        if (num2 == 3 && this.strstart - this.matchStart > 4096)
          this.matchLen = 2;
label_15:
        int num3;
        if (len >= 3)
        {
          matchLen = this.matchLen;
          if (true)
          {
            int num4 = len;
            if (matchLen <= num4)
            {
              this.huffman.TallyDist(this.strstart - 1 - *(int*) voidPtr, len);
              num3 = len;
              goto label_19;
            }
          }
          else
            goto label_7;
        }
        if (this.prevAvailable)
        {
          num2 = this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue) ? 1 : 0;
          if (false)
            goto label_13;
        }
        this.prevAvailable = true;
        ++this.strstart;
        --this.lookahead;
        goto label_29;
label_19:
        len = num3 - 2;
        do
        {
          ++this.strstart;
          --this.lookahead;
          if (this.lookahead >= 3)
            this.InsertString();
        }
        while (--len > 0);
        ++this.strstart;
        --this.lookahead;
label_24:
        this.prevAvailable = false;
        if (true)
          this.matchLen = 2;
        else
          goto label_32;
label_29:
        if (this.huffman.IsFull())
        {
          *(int*) ((IntPtr) voidPtr + 8) = this.strstart - this.blockStart;
          if (this.prevAvailable)
            *(int*) ((IntPtr) voidPtr + 8) = *(int*) ((IntPtr) voidPtr + 8) - 1;
        }
        else
          goto label_33;
label_32:
        bool lastBlock = finish && this.lookahead == 0 && !this.prevAvailable;
        this.huffman.FlushBlock(this.window, this.blockStart, *(int*) ((IntPtr) voidPtr + 8), lastBlock);
        this.blockStart += *(int*) ((IntPtr) voidPtr + 8);
        num3 = !lastBlock ? 1 : 0;
        if (true)
          return num3 != 0;
        goto label_19;
label_34:
        if (num1 < 262 && !flush)
          return true;
        if (this.lookahead != 0)
        {
          if (this.strstart >= 65274)
            this.SlideWindow();
          *(int*) voidPtr = this.matchStart;
          matchLen = this.matchLen;
          goto label_7;
        }
        else
        {
          if (this.prevAvailable)
            goto label_38;
label_3:
          this.prevAvailable = false;
          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, finish);
          this.blockStart = this.strstart;
          return false;
label_38:
          this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
          goto label_3;
        }
      }

      public bool Deflate(bool flush, bool finish)
      {
        bool flag;
        do
        {
          this.FillWindow();
          int num = flush ? 1 : 0;
          if (true)
          {
            if (num == 0)
            {
              if (true)
                num = 0;
              else
                continue;
            }
            else
              goto label_9;
          }
label_4:
          if (true)
            goto label_10;
label_6:
          flag = num != 0;
label_7:
          continue;
label_10:
          bool flush1 = num != 0;
          if (true)
          {
            if (true)
            {
              num = this.DeflateSlow(flush1, finish) ? 1 : 0;
              goto label_6;
            }
          }
          else
            goto label_7;
label_9:
          num = this.inputOff == this.inputEnd ? 1 : 0;
          goto label_4;
        }
        while (this.pending.IsFlushed && flag);
        return flag;
      }

      public void SetInput(byte[] buffer)
      {
        if (true)
          this.inputBuf = buffer;
        do
        {
          this.inputOff = 0;
          this.inputEnd = buffer.Length;
        }
        while (false);
      }

      public bool NeedsInput() => this.inputEnd == this.inputOff;
    }

    internal sealed class DeflaterPending
    {
      protected byte[] buf = new byte[65536];
      private int start = 0;
      private int end = 0;
      private uint bits = 0;
      private int bitCount = 0;

      public void WriteShort(int s)
      {
        byte[] buf1 = this.buf;
        SimpleZip.DeflaterPending deflaterPending1 = this;
        int end1;
        int num1 = end1 = deflaterPending1.end;
        deflaterPending1.end = end1 + 1;
        int index1 = num1;
        int num2 = (int) (byte) s;
        buf1[index1] = (byte) num2;
        byte[] buf2 = this.buf;
        SimpleZip.DeflaterPending deflaterPending2 = this;
        int end2;
        int num3 = end2 = deflaterPending2.end;
        deflaterPending2.end = end2 + 1;
        int index2 = num3;
        int num4 = (int) (byte) (s >> 8);
        buf2[index2] = (byte) num4;
      }

      public void WriteBlock(byte[] block, int offset, int len)
      {
label_0:
        Array.Copy((Array) block, offset, (Array) this.buf, this.end, len);
        do
        {
          if (true)
            this.end += len;
          else
            goto label_0;
        }
        while (false);
      }

      public int BitCount => this.bitCount;

      public void AlignToByte()
      {
        if (this.bitCount > 0)
          goto label_2;
label_1:
        this.bits = 0U;
        this.bitCount = 0;
        return;
label_2:
        byte[] buf1 = this.buf;
        SimpleZip.DeflaterPending deflaterPending1 = this;
        int end1;
        int num1 = end1 = deflaterPending1.end;
        deflaterPending1.end = end1 + 1;
        int index1 = num1;
        int bits = (int) (byte) this.bits;
        buf1[index1] = (byte) bits;
        if (this.bitCount > 8)
        {
          byte[] buf2 = this.buf;
          SimpleZip.DeflaterPending deflaterPending2 = this;
          int end2;
          int num2 = end2 = deflaterPending2.end;
          deflaterPending2.end = end2 + 1;
          int index2 = num2;
          int num3 = (int) (byte) (this.bits >> 8);
          buf2[index2] = (byte) num3;
          goto label_1;
        }
        else
          goto label_1;
      }

      public void WriteBits(int b, int count)
      {
        do
        {
          this.bits |= (uint) (b << this.bitCount);
          this.bitCount += count;
          if (this.bitCount >= 16)
            goto label_5;
label_4:
          continue;
label_5:
          byte[] buf = this.buf;
          SimpleZip.DeflaterPending deflaterPending = this;
          int end;
          int num = end = deflaterPending.end;
          deflaterPending.end = end + 1;
          int index = num;
          int bits = (int) (byte) this.bits;
          buf[index] = (byte) bits;
label_1:
          if (true)
          {
            this.buf[this.end++] = (byte) (this.bits >> 8);
            this.bits >>= 16;
            if (true)
            {
              this.bitCount -= 16;
              goto label_4;
            }
            else
              goto label_1;
          }
        }
        while (false);
      }

      public bool IsFlushed => this.end == 0;

      public int Flush(byte[] output, int offset, int length)
      {
        int num1 = this.bitCount;
        int num2 = 8;
        int end1;
        int start;
        while (true)
        {
          if (num1 >= num2)
          {
            byte[] buf = this.buf;
            SimpleZip.DeflaterPending deflaterPending = this;
            int end2;
            int num3 = end2 = deflaterPending.end;
            deflaterPending.end = end2 + 1;
            int index = num3;
            int bits = (int) (byte) this.bits;
            buf[index] = (byte) bits;
            if (true)
            {
              this.bits >>= 8;
              this.bitCount -= 8;
            }
            else
              goto label_6;
          }
          if (length > this.end - this.start)
          {
            end1 = this.end;
            start = this.start;
            if (false)
            {
              num2 = start;
              num1 = end1;
            }
            else
              break;
          }
          else
            goto label_5;
        }
        length = end1 - start;
        Array.Copy((Array) this.buf, this.start, (Array) output, offset, length);
        this.start = 0;
        this.end = 0;
        goto label_6;
label_5:
        Array.Copy((Array) this.buf, this.start, (Array) output, offset, length);
        this.start += length;
label_6:
        return length;
      }
    }

    internal sealed class ZipStream : MemoryStream
    {
      public void WriteShort(int value)
      {
        this.WriteByte((byte) (value & (int) byte.MaxValue));
        this.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
      }

      public void WriteInt(int value)
      {
        this.WriteShort(value);
        this.WriteShort(value >> 16);
      }

      public int ReadShort() => this.ReadByte() | this.ReadByte() << 8;

      public int ReadInt() => this.ReadShort() | this.ReadShort() << 16;

      public ZipStream()
      {
      }

      public ZipStream(byte[] buffer)
        : base(buffer, false)
      {
      }
    }
  }
}
