// Decompiled with JetBrains decompiler
// Type: AstroChart.SkyView
// Assembly: IUnionSemanticCodeGr, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 54936E77-57E9-4A01-8A40-CDD9C21A9B24
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4a11f3ee9b7abe32546655a9f702013b42b9f162a262dca3052e2761c20ed447.exe

using AstroMath;
using System;
using System.Drawing;

namespace AstroChart
{
  public class SkyView
  {
    private Graphics gpho;
    private Rectangle skyMapRectangle;
    private Point smCenter;
    private double smRadius;
    private double smObsLatD;
    private Point northPoint;
    private Point southPoint;
    private Point eastPoint;
    private Point westPoint;
    private Point northPole;

    public SkyView(Graphics fcntl, Point centerPoint, float gRadius, float observersLatitude)
    {
      this.gpho = fcntl;
      this.smCenter = centerPoint;
      this.smRadius = (double) gRadius;
      this.smObsLatD = (double) observersLatitude;
      this.skyMapRectangle = new Rectangle(new Point(centerPoint.X - (int) gRadius, centerPoint.Y - (int) gRadius), new Size((int) (2.0 * (double) gRadius), (int) (2.0 * (double) gRadius)));
      this.northPoint = new Point(centerPoint.X, (int) ((double) centerPoint.Y - (double) gRadius));
      this.southPoint = new Point(centerPoint.X, (int) ((double) centerPoint.Y + (double) gRadius));
      this.westPoint = new Point((int) ((double) centerPoint.X + (double) gRadius), centerPoint.Y);
      this.eastPoint = new Point((int) ((double) centerPoint.X - (double) gRadius), centerPoint.Y);
      this.northPole = new Point(centerPoint.X, (int) ((double) centerPoint.Y - (double) gRadius * Math.Cos(Transform.DegreesToRadians((double) observersLatitude))));
      Rectangle rectangle = new Rectangle(this.northPole, new Size(this.northPole.X - this.eastPoint.X, this.eastPoint.Y - this.northPole.Y));
      this.gpho.FillEllipse((Brush) new SolidBrush(Color.Navy), this.skyMapRectangle);
    }

    public Point[] HourLine(double hourAngleH)
    {
      float polarAngle = (float) Transform.HourAngleToPolarAngle(hourAngleH);
      float radians = (float) Transform.DegreesToRadians(this.smObsLatD);
      Polar3D.Polar3[] spts = new Polar3D.Polar3[100];
      float num1 = 3.14159274f / (float) spts.Length;
      float num2 = 0.0f;
      for (int index = 0; index < spts.Length; ++index)
      {
        float thetaVal = num1 * (float) index + num2;
        spts[index] = new Polar3D.Polar3((float) this.smRadius, thetaVal, polarAngle);
        spts[index] = spts[index].RotateX(radians);
      }
      Point[] pointArray = Polar3D.ProjectXY(spts);
      for (int index = 0; index < pointArray.Length; ++index)
        pointArray[index].Offset(this.smCenter.X, this.smCenter.Y);
      return pointArray;
    }

    public Point[] DecLine(double decAngleD)
    {
      float radians1 = (float) Transform.DegreesToRadians(decAngleD);
      float radians2 = (float) Transform.DegreesToRadians(this.smObsLatD);
      Polar3D.Polar3[] spts = new Polar3D.Polar3[100];
      float num1 = 6.28318548f / (float) spts.Length;
      float num2 = -1.57079637f;
      for (int index = 0; index < spts.Length; ++index)
      {
        float phiVal = num1 * (float) index + num2;
        spts[index] = new Polar3D.Polar3((float) this.smRadius, radians1, phiVal);
        spts[index] = spts[index].RotateX(radians2);
      }
      Point[] pointArray = Polar3D.ProjectXY(spts);
      for (int index = 0; index < pointArray.Length; ++index)
        pointArray[index].Offset(this.smCenter.X, this.smCenter.Y);
      return pointArray;
    }

    public Point[] TrackLine(
      double startHourAngleH,
      double endHourAngleH,
      double declinationD)
    {
      float polarAngle1 = (float) Transform.HourAngleToPolarAngle(startHourAngleH);
      float polarAngle2 = (float) Transform.HourAngleToPolarAngle(endHourAngleH);
      float radians1 = (float) Transform.DegreesToRadians(declinationD);
      float radians2 = (float) Transform.DegreesToRadians(this.smObsLatD);
      Polar3D.Polar3[] spts = new Polar3D.Polar3[100];
      float num = (float) Transform.NormalizeHours(endHourAngleH - startHourAngleH) / (float) spts.Length;
      for (int index = 0; index < spts.Length; ++index)
      {
        float polarAngle3 = (float) Transform.HourAngleToPolarAngle((double) num * (double) index + startHourAngleH);
        spts[index] = new Polar3D.Polar3((float) this.smRadius, radians1, polarAngle3);
        spts[index] = spts[index].RotateX(radians2);
      }
      Point[] pointArray = Polar3D.ProjectXY(spts);
      for (int index = 0; index < pointArray.Length; ++index)
        pointArray[index].Offset(this.smCenter.X, this.smCenter.Y);
      return pointArray;
    }

    public static Point LocationOffset(Point Center, double Diameter)
    {
      Center.X = (int) ((double) Center.X - Diameter / 2.0);
      Center.Y = (int) ((double) Center.Y - Diameter / 2.0);
      return Center;
    }
  }
}
