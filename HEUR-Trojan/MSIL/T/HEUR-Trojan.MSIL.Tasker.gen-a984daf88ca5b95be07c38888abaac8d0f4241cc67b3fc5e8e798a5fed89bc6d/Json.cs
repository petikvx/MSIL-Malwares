// Decompiled with JetBrains decompiler
// Type: Json
// Assembly: PunisherMiner, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 5E38855F-8014-4FAB-90F8-2AFCCACBC0F6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Tasker.gen-a984daf88ca5b95be07c38888abaac8d0f4241cc67b3fc5e8e798a5fed89bc6d.exe

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Security.Cryptography;
using System.Text;
using System.Xml.Serialization;

public static class Json
{
  private const string _null = "null";
  private const string _true = "true";
  private const string _false = "false";
  private const string _zeroArg = "{0}";
  private const string _dateStartJs = "new Date(";
  private const string _dateEndJs = ")";
  private const string _dateStart = "\"\\/Date(";
  private const string _dateStart2 = "/Date(";
  private const string _dateEnd = ")\\/\"";
  private const string _dateEnd2 = ")/";
  private const string _roundTripFormat = "R";
  private const string _enumFormat = "D";
  private const string _x4Format = "{0:X4}";
  private const string _d2Format = "D2";
  private const string _scriptIgnore = "ScriptIgnore";
  private const string _serializationTypeToken = "__type";
  private static readonly string[] _dateFormatsUtc = new string[4]
  {
    "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff'Z'",
    "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'",
    "yyyy'-'MM'-'dd'T'HH':'mm'Z'",
    "yyyyMMdd'T'HH':'mm':'ss'Z'"
  };
  private static readonly DateTime _minDateTime = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
  private static readonly long _minDateTimeTicks = Json._minDateTime.Ticks;
  private static readonly FormatterConverter _defaultFormatterConverter = new FormatterConverter();

  public static string Serialize(object value, JsonOptions options = null)
  {
    using (StringWriter writer = new StringWriter())
    {
      Json.Serialize((TextWriter) writer, value, options);
      return writer.ToString();
    }
  }

  public static void Serialize(TextWriter writer, object value, JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    options = options ?? new JsonOptions();
    string str = options.JsonPCallback.Nullify();
    if (str != null)
    {
      writer.Write(options.JsonPCallback);
      writer.Write('(');
    }
    Json.WriteValue(writer, value, (IDictionary<object, object>) new Dictionary<object, object>((IEqualityComparer<object>) Json.ReferenceComparer._current), options);
    if (str == null)
      return;
    writer.Write(')');
    writer.Write(';');
  }

  public static object Deserialize(string text, Type targetType = null, JsonOptions options = null)
  {
    if (text == null)
    {
      if (targetType == (Type) null)
        return (object) null;
      return !targetType.IsValueType ? (object) null : Json.CreateInstance((object) null, targetType, 0, options, (object) text);
    }
    using (StringReader reader = new StringReader(text))
      return Json.Deserialize((TextReader) reader, targetType, options);
  }

  public static T Deserialize<T>(TextReader reader, JsonOptions options = null) => (T) Json.Deserialize(reader, typeof (T), options);

  public static T Deserialize<T>(string text, JsonOptions options = null) => (T) Json.Deserialize(text, typeof (T), options);

  public static object Deserialize(TextReader reader, Type targetType = null, JsonOptions options = null)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    options = options ?? new JsonOptions();
    if (targetType == (Type) null || targetType == typeof (object))
      return Json.ReadValue(reader, options);
    object obj = Json.ReadValue(reader, options);
    if (obj != null)
      return Json.ChangeType((object) null, obj, targetType, options);
    return targetType.IsValueType ? Json.CreateInstance((object) null, targetType, 0, options, obj) : (object) null;
  }

  public static void DeserializeToTarget(string text, object target, JsonOptions options = null)
  {
    if (text == null)
      return;
    using (StringReader reader = new StringReader(text))
      Json.DeserializeToTarget((TextReader) reader, target, options);
  }

  public static void DeserializeToTarget(TextReader reader, object target, JsonOptions options = null)
  {
    if (reader == null)
      throw new ArgumentNullException(nameof (reader));
    if (target == null)
      throw new ArgumentNullException(nameof (target));
    Json.Apply(Json.ReadValue(reader, options), target, options);
  }

  public static void Apply(object input, object target, JsonOptions options = null)
  {
    options = options ?? new JsonOptions();
    if (target is Array target1 && !target1.IsReadOnly)
      Json.Apply(input as IEnumerable, target1, options);
    else if (input is IDictionary dictionary)
    {
      Json.Apply(dictionary, target, options);
    }
    else
    {
      if (target == null)
        return;
      Json.ListObject listObject = Json.GetListObject(target.GetType(), options, target, input, (IDictionary) null, (string) null);
      if (listObject == null)
        return;
      listObject.List = target;
      Json.ApplyToListTarget(target, input as IEnumerable, listObject, options);
    }
  }

  private static object CreateInstance(
    object target,
    Type type,
    int elementsCount,
    JsonOptions options,
    object value)
  {
    try
    {
      if (options.CreateInstanceCallback != null)
      {
        JsonEventArgs e = new JsonEventArgs((TextWriter) null, (object) type, (IDictionary<object, object>) new Dictionary<object, object>()
        {
          [(object) nameof (elementsCount)] = (object) elementsCount,
          [(object) nameof (value)] = value
        }, options, (string) null, target);
        e.EventType = JsonEventType.CreateInstance;
        options.CreateInstanceCallback(e);
        if (e.Handled)
          return e.Value;
      }
      return type.IsArray ? (object) Array.CreateInstance(type.GetElementType(), elementsCount) : Activator.CreateInstance(type);
    }
    catch (Exception ex)
    {
      Json.HandleException((Exception) new JsonException("JSO0001: JSON error detected. Cannot create an instance of the '" + type.Name + "' type.", ex), options);
      return (object) null;
    }
  }

  private static Json.ListObject GetListObject(
    Type type,
    JsonOptions options,
    object target,
    object value,
    IDictionary dictionary,
    string key)
  {
    if (options.GetListObjectCallback != null)
    {
      Dictionary<object, object> objectGraph = new Dictionary<object, object>();
      objectGraph[(object) nameof (dictionary)] = (object) dictionary;
      objectGraph[(object) nameof (type)] = (object) type;
      JsonEventArgs e = new JsonEventArgs((TextWriter) null, value, (IDictionary<object, object>) objectGraph, options, key, target);
      e.EventType = JsonEventType.GetListObject;
      options.GetListObjectCallback(e);
      if (e.Handled)
      {
        object listObject;
        objectGraph.TryGetValue((object) nameof (type), out listObject);
        return listObject as Json.ListObject;
      }
    }
    if (type == typeof (byte[]))
      return (Json.ListObject) null;
    if (typeof (IList).IsAssignableFrom(type))
      return (Json.ListObject) new Json.IListObject();
    if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof (ICollection<>))
      return (Json.ListObject) Activator.CreateInstance(typeof (Json.ICollectionTObject<>).MakeGenericType(type.GetGenericArguments()[0]));
    foreach (Type type1 in type.GetInterfaces())
    {
      if (type1.IsGenericType && type1.GetGenericTypeDefinition() == typeof (ICollection<>))
        return (Json.ListObject) Activator.CreateInstance(typeof (Json.ICollectionTObject<>).MakeGenericType(type1.GetGenericArguments()[0]));
    }
    return (Json.ListObject) null;
  }

  private static void ApplyToListTarget(
    object target,
    IEnumerable input,
    Json.ListObject list,
    JsonOptions options)
  {
    if (list.List == null)
      return;
    if (list.Context != null)
    {
      list.Context["action"] = (object) "init";
      list.Context[nameof (target)] = target;
      list.Context[nameof (input)] = (object) input;
      list.Context[nameof (options)] = (object) options;
    }
    if (input != null)
    {
      Array list1 = list.List as Array;
      int num1 = 0;
      int num2 = 0;
      if (list1 != null)
      {
        num2 = list1.GetLowerBound(0);
        num1 = list1.GetUpperBound(0);
      }
      Type itemType = Json.GetItemType(list.List.GetType());
      foreach (object obj1 in input)
      {
        if (list1 != null)
        {
          if (num2 - 1 != num1)
            list1.SetValue(Json.ChangeType(target, obj1, itemType, options), num2++);
          else
            break;
        }
        else
        {
          object obj2 = Json.ChangeType(target, obj1, itemType, options);
          if (list.Context != null)
          {
            list.Context["action"] = (object) "add";
            list.Context["itemType"] = (object) itemType;
            list.Context["value"] = obj1;
            list.Context["cvalue"] = obj2;
            object obj3;
            if (list.Context.TryGetValue("cvalue", out obj3))
              obj2 = obj3;
            else
              continue;
          }
          list.Add(obj2, options);
        }
      }
    }
    else
    {
      if (list.Context != null)
        list.Context["action"] = (object) "clear";
      list.Clear();
    }
    if (list.Context == null)
      return;
    list.Context.Clear();
  }

  private static void Apply(IEnumerable input, Array target, JsonOptions options)
  {
    if (target == null || target.Rank != 1)
      return;
    Type elementType = target.GetType().GetElementType();
    int num = 0;
    if (input != null)
    {
      foreach (object obj in input)
        target.SetValue(Json.ChangeType((object) target, obj, elementType, options), num++);
    }
    else
      Array.Clear(target, 0, target.Length);
  }

  private static bool AreValuesEqual(object o1, object o2)
  {
    if (o1 == o2)
      return true;
    return o1 == null ? o2 == null : o1.Equals(o2);
  }

  private static bool TryGetObjectDefaultValue(Attribute att, out object value)
  {
    switch (att)
    {
      case JsonAttribute jsonAttribute when jsonAttribute.HasDefaultValue:
        value = jsonAttribute.DefaultValue;
        return true;
      case DefaultValueAttribute defaultValueAttribute:
        value = defaultValueAttribute.Value;
        return true;
      default:
        value = (object) null;
        return false;
    }
  }

  private static string GetObjectName(Attribute att)
  {
    switch (att)
    {
      case JsonAttribute jsonAttribute when !string.IsNullOrEmpty(jsonAttribute.Name):
        return jsonAttribute.Name;
      case XmlAttributeAttribute attributeAttribute when !string.IsNullOrEmpty(attributeAttribute.AttributeName):
        return attributeAttribute.AttributeName;
      case XmlElementAttribute elementAttribute when !string.IsNullOrEmpty(elementAttribute.ElementName):
        return elementAttribute.ElementName;
      default:
        return (string) null;
    }
  }

  private static bool TryGetObjectDefaultValue(MemberInfo mi, out object value)
  {
    object[] customAttributes = mi.GetCustomAttributes(true);
    if (customAttributes != null)
    {
      foreach (Attribute att in customAttributes.Cast<Attribute>())
      {
        if (Json.TryGetObjectDefaultValue(att, out value))
          return true;
      }
    }
    value = (object) null;
    return false;
  }

  private static string GetObjectName(MemberInfo mi, string defaultName)
  {
    object[] customAttributes = mi.GetCustomAttributes(true);
    if (customAttributes == null)
      return defaultName;
    foreach (Attribute att in customAttributes.Cast<Attribute>())
    {
      string objectName = Json.GetObjectName(att);
      if (objectName != null)
        return objectName;
    }
    return defaultName;
  }

  private static bool TryGetObjectDefaultValue(PropertyDescriptor pd, out object value)
  {
    foreach (Attribute att in pd.Attributes.Cast<Attribute>())
    {
      if (Json.TryGetObjectDefaultValue(att, out value))
        return true;
    }
    value = (object) null;
    return false;
  }

  private static string GetObjectName(PropertyDescriptor pd, string defaultName)
  {
    foreach (Attribute att in pd.Attributes.Cast<Attribute>())
    {
      string objectName = Json.GetObjectName(att);
      if (objectName != null)
        return objectName;
    }
    return defaultName;
  }

  private static bool HasScriptIgnore(PropertyDescriptor pd)
  {
    if (pd.Attributes == null)
      return false;
    foreach (object attribute in pd.Attributes)
    {
      if (attribute.GetType().Name != null && attribute.GetType().Name.StartsWith("ScriptIgnore"))
        return true;
    }
    return false;
  }

  private static bool HasScriptIgnore(MemberInfo mi)
  {
    object[] customAttributes = mi.GetCustomAttributes(true);
    if (customAttributes == null || customAttributes.Length == 0)
      return false;
    foreach (object obj in customAttributes)
    {
      if (obj is Attribute attribute && attribute.GetType().Name != null && attribute.GetType().Name.StartsWith("ScriptIgnore"))
        return true;
    }
    return false;
  }

  private static void Apply(IDictionary dictionary, object target, JsonOptions options)
  {
    if (dictionary == null || target == null)
      return;
    if (target is IDictionary dictionary1)
    {
      Type itemType = Json.GetItemType(dictionary1.GetType());
      foreach (DictionaryEntry dictionaryEntry in dictionary)
      {
        if (dictionaryEntry.Key != null)
          dictionary1[dictionaryEntry.Key] = !(itemType == typeof (object)) ? Json.ChangeType(target, dictionaryEntry.Value, itemType, options) : dictionaryEntry.Value;
      }
    }
    else
    {
      Json.TypeDef typeDef = Json.TypeDef.Get(target.GetType(), options);
      foreach (DictionaryEntry dictionaryEntry in dictionary)
      {
        if (dictionaryEntry.Key != null)
        {
          string str = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
          {
            dictionaryEntry.Key
          });
          object obj = dictionaryEntry.Value;
          if (options.MapEntryCallback != null)
          {
            JsonEventArgs e = new JsonEventArgs((TextWriter) null, obj, (IDictionary<object, object>) new Dictionary<object, object>()
            {
              [(object) nameof (dictionary)] = (object) dictionary
            }, options, str, target);
            e.EventType = JsonEventType.MapEntry;
            options.MapEntryCallback(e);
            if (!e.Handled)
            {
              str = e.Name;
              obj = e.Value;
            }
            else
              continue;
          }
          typeDef.ApplyEntry(dictionary, target, str, obj, options);
        }
      }
    }
  }

  private static JsonAttribute GetJsonAttribute(MemberInfo pi)
  {
    object[] customAttributes = pi.GetCustomAttributes(true);
    if (customAttributes == null || customAttributes.Length == 0)
      return (JsonAttribute) null;
    foreach (object obj in customAttributes)
    {
      if (obj is Attribute attribute && attribute is JsonAttribute jsonAttribute)
        return jsonAttribute;
    }
    return (JsonAttribute) null;
  }

  public static Type GetItemType(Type collectionType)
  {
    if (collectionType == (Type) null)
      throw new ArgumentNullException(nameof (collectionType));
    foreach (Type type in collectionType.GetInterfaces())
    {
      if (type.IsGenericType)
      {
        if (type.GetGenericTypeDefinition() == typeof (IDictionary<,>))
          return type.GetGenericArguments()[1];
        if (type.GetGenericTypeDefinition() == typeof (IList<>) || type.GetGenericTypeDefinition() == typeof (ICollection<>) || type.GetGenericTypeDefinition() == typeof (IEnumerable<>))
          return type.GetGenericArguments()[0];
      }
    }
    return typeof (object);
  }

  public static object ChangeType(object value, Type conversionType, JsonOptions options) => Json.ChangeType((object) null, value, conversionType, options);

  public static object ChangeType(
    object target,
    object value,
    Type conversionType,
    JsonOptions options = null)
  {
    if (conversionType == (Type) null)
      throw new ArgumentNullException(nameof (conversionType));
    if (conversionType == typeof (object))
      return value;
    options = options ?? new JsonOptions();
    if (!(value is string))
    {
      if (conversionType.IsArray && value is IEnumerable enumerable)
      {
        Type elementType = conversionType.GetElementType();
        List<object> objectList = new List<object>();
        foreach (object obj in enumerable)
          objectList.Add(Json.ChangeType(target, obj, elementType, options));
        Array instance = Array.CreateInstance(elementType, objectList.Count);
        if (instance != null)
          Array.Copy((Array) objectList.ToArray(), instance, objectList.Count);
        return (object) instance;
      }
      Json.ListObject listObject = Json.GetListObject(conversionType, options, target, value, (IDictionary) null, (string) null);
      if (listObject != null && value is IEnumerable input)
      {
        listObject.List = Json.CreateInstance(target, conversionType, input is ICollection collection ? collection.Count : 0, options, value);
        Json.ApplyToListTarget(target, input, listObject, options);
        return listObject.List;
      }
    }
    if (value is IDictionary dictionary)
    {
      object instance = Json.CreateInstance(target, conversionType, 0, options, value);
      if (instance != null)
        Json.Apply(dictionary, instance, options);
      return instance;
    }
    if (conversionType == typeof (byte[]) && value is string s1)
    {
      if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.ByteArrayAsBase64))
      {
        try
        {
          return (object) Convert.FromBase64String(s1);
        }
        catch (Exception ex)
        {
          Json.HandleException((Exception) new JsonException("JSO0013: JSON deserialization error with a base64 array as string.", ex), options);
          return (object) null;
        }
      }
    }
    if (conversionType == typeof (DateTime))
    {
      if (value is DateTime)
        return value;
      string text = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
      {
        value
      });
      DateTime dt;
      if (!string.IsNullOrEmpty(text) && Json.TryParseDateTime(text, options.DateTimeStyles, out dt))
        return (object) dt;
    }
    if (conversionType == typeof (TimeSpan))
    {
      string s2 = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
      {
        value
      });
      long result;
      if (!string.IsNullOrEmpty(s2) && long.TryParse(s2, out result))
        return (object) new TimeSpan(result);
    }
    return Json.Conversions.ChangeType(value, conversionType);
  }

  private static object[] ReadArray(TextReader reader, JsonOptions options)
  {
    if (!Json.ReadWhitespaces(reader))
      return (object[]) null;
    reader.Read();
    List<object> objectList = new List<object>();
    do
    {
      bool arrayEnd;
      object obj = Json.ReadValue(reader, options, true, out arrayEnd);
      if (!Convert.IsDBNull(obj))
        objectList.Add(obj);
      if (arrayEnd)
        return objectList.ToArray();
    }
    while (reader.Peek() >= 0);
    Json.HandleException((Exception) Json.GetExpectedCharacterException(Json.GetPosition(reader), ']'), options);
    return objectList.ToArray();
  }

  private static JsonException GetExpectedCharacterException(long pos, char c)
  {
    if (pos < 0L)
      return new JsonException("JSO0002: JSON deserialization error detected. Expecting '" + c.ToString() + "' character.");
    return new JsonException("JSO0003: JSON deserialization error detected at position " + pos.ToString() + ". Expecting '" + c.ToString() + "' character.");
  }

  private static JsonException GetUnexpectedCharacterException(long pos, char c)
  {
    if (pos < 0L)
      return new JsonException("JSO0004: JSON deserialization error detected. Unexpected '" + c.ToString() + "' character.");
    return new JsonException("JSO0005: JSON deserialization error detected at position " + pos.ToString() + ". Unexpected '" + c.ToString() + "' character.");
  }

  private static JsonException GetExpectedHexaCharacterException(long pos) => pos < 0L ? new JsonException("JSO0006: JSON deserialization error detected. Expecting hexadecimal character.") : new JsonException("JSO0007: JSON deserialization error detected at position " + pos.ToString() + ". Expecting hexadecimal character.");

  private static JsonException GetTypeException(
    long pos,
    string typeName,
    Exception inner)
  {
    if (pos < 0L)
      return new JsonException("JSO0010: JSON deserialization error detected for '" + typeName + "' type.", inner);
    return new JsonException("JSO0011: JSON deserialization error detected for '" + typeName + "' type at position " + pos.ToString() + ".", inner);
  }

  private static JsonException GetEofException(char c) => new JsonException("JSO0012: JSON deserialization error detected at end of text. Expecting '" + c.ToString() + "' character.");

  private static long GetPosition(TextReader reader)
  {
    if (reader == null)
      return -1;
    if (reader is StreamReader streamReader)
    {
      if (streamReader.BaseStream != null)
      {
        try
        {
          return streamReader.BaseStream.Position;
        }
        catch
        {
          return -1;
        }
      }
    }
    if (reader is StringReader stringReader)
    {
      FieldInfo field = typeof (StringReader).GetField("_pos", BindingFlags.Instance | BindingFlags.NonPublic);
      if (field != (FieldInfo) null)
        return (long) (int) field.GetValue((object) stringReader);
    }
    return -1;
  }

  private static Dictionary<string, object> ReadDictionary(
    TextReader reader,
    JsonOptions options)
  {
    if (!Json.ReadWhitespaces(reader))
      return (Dictionary<string, object>) null;
    reader.Read();
    Dictionary<string, object> dictionary = new Dictionary<string, object>();
    while (reader.Peek() >= 0)
    {
      char c = (char) reader.Read();
      switch (c)
      {
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        case ',':
          continue;
        case '"':
          string key = Json.ReadString(reader, options);
          if (!Json.ReadWhitespaces(reader))
          {
            Json.HandleException((Exception) Json.GetExpectedCharacterException(Json.GetPosition(reader), ':'), options);
            return dictionary;
          }
          if ((char) reader.Peek() != ':')
          {
            Json.HandleException((Exception) Json.GetExpectedCharacterException(Json.GetPosition(reader), ':'), options);
            return dictionary;
          }
          reader.Read();
          dictionary[key] = Json.ReadValue(reader, options);
          continue;
        case '}':
          return dictionary;
        default:
          Json.HandleException((Exception) Json.GetUnexpectedCharacterException(Json.GetPosition(reader), c), options);
          return dictionary;
      }
    }
    Json.HandleException((Exception) Json.GetEofException('}'), options);
    return dictionary;
  }

  private static string ReadString(TextReader reader, JsonOptions options)
  {
    StringBuilder stringBuilder = new StringBuilder();
    while (reader.Peek() >= 0)
    {
      char ch1 = (char) reader.Read();
      switch (ch1)
      {
        case '"':
          return stringBuilder.ToString();
        case '\\':
          if (reader.Peek() < 0)
          {
            Json.HandleException((Exception) Json.GetEofException('"'), options);
            return (string) null;
          }
          char ch2 = (char) reader.Read();
          switch (ch2)
          {
            case '"':
            case '/':
            case '\\':
              stringBuilder.Append(ch2);
              continue;
            case 'b':
              stringBuilder.Append('\b');
              continue;
            case 'f':
              stringBuilder.Append('\f');
              continue;
            case 'n':
              stringBuilder.Append('\n');
              continue;
            case 'r':
              stringBuilder.Append('\r');
              continue;
            case 't':
              stringBuilder.Append('\t');
              continue;
            case 'u':
              ushort num = Json.ReadX4(reader, options);
              stringBuilder.Append((char) num);
              continue;
            default:
              stringBuilder.Append(ch1);
              stringBuilder.Append(ch2);
              continue;
          }
        default:
          stringBuilder.Append(ch1);
          continue;
      }
    }
    Json.HandleException((Exception) Json.GetEofException('"'), options);
    return (string) null;
  }

  private static ISerializable ReadSerializable(
    TextReader reader,
    JsonOptions options,
    string typeName,
    Dictionary<string, object> values)
  {
    Type type;
    try
    {
      type = Type.GetType(typeName, true);
    }
    catch (Exception ex)
    {
      Json.HandleException((Exception) Json.GetTypeException(Json.GetPosition(reader), typeName, ex), options);
      return (ISerializable) null;
    }
    ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, (Binder) null, new Type[2]
    {
      typeof (SerializationInfo),
      typeof (StreamingContext)
    }, (ParameterModifier[]) null);
    SerializationInfo serializationInfo = new SerializationInfo(type, (IFormatterConverter) Json._defaultFormatterConverter);
    foreach (KeyValuePair<string, object> keyValuePair in values)
      serializationInfo.AddValue(keyValuePair.Key, keyValuePair.Value);
    StreamingContext streamingContext = new StreamingContext(StreamingContextStates.Remoting, (object) null);
    try
    {
      return (ISerializable) constructor.Invoke(new object[2]
      {
        (object) serializationInfo,
        (object) streamingContext
      });
    }
    catch (Exception ex)
    {
      Json.HandleException((Exception) Json.GetTypeException(Json.GetPosition(reader), typeName, ex), options);
      return (ISerializable) null;
    }
  }

  private static object ReadValue(TextReader reader, JsonOptions options) => Json.ReadValue(reader, options, false, out bool _);

  private static object ReadValue(
    TextReader reader,
    JsonOptions options,
    bool arrayMode,
    out bool arrayEnd)
  {
    arrayEnd = false;
    int num;
    while (true)
    {
      num = reader.Peek();
      if (num >= 0)
      {
        if (num == 10 || num == 13 || num == 9 || num == 32)
          reader.Read();
        else
          goto label_5;
      }
      else
        break;
    }
    return (object) null;
label_5:
    char c = (char) num;
    switch (c)
    {
      case '"':
        reader.Read();
        string text = Json.ReadString(reader, options);
        DateTime dt;
        return options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.AutoParseDateTime) && Json.TryParseDateTime(text, options.DateTimeStyles, out dt) ? (object) dt : (object) text;
      case '[':
        return (object) Json.ReadArray(reader, options);
      case 'n':
        return Json.ReadNew(reader, options, out arrayEnd);
      case '{':
        Dictionary<string, object> values = Json.ReadDictionary(reader, options);
        object obj;
        if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseISerializable) && values.TryGetValue("__type", out obj))
        {
          string typeName = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
          {
            obj
          });
          if (!string.IsNullOrEmpty(typeName))
          {
            values.Remove("__type");
            return (object) Json.ReadSerializable(reader, options, typeName, values);
          }
        }
        return (object) values;
      default:
        if (char.IsLetterOrDigit(c) || c == '.' || c == '-' || c == '+')
          return Json.ReadNumberOrLiteral(reader, options, out arrayEnd);
        if (arrayMode && c == ']')
        {
          reader.Read();
          arrayEnd = true;
          return (object) DBNull.Value;
        }
        if (arrayMode && c == ',')
        {
          reader.Read();
          return (object) DBNull.Value;
        }
        Json.HandleException((Exception) Json.GetUnexpectedCharacterException(Json.GetPosition(reader), c), options);
        return (object) null;
    }
  }

  private static object ReadNew(TextReader reader, JsonOptions options, out bool arrayEnd)
  {
    arrayEnd = false;
    StringBuilder stringBuilder = new StringBuilder();
    while (true)
    {
      int num = reader.Peek();
      if (num >= 0 && (ushort) num != (ushort) 125)
      {
        char ch = (char) reader.Read();
        switch (ch)
        {
          case ',':
            goto label_5;
          case ']':
            goto label_3;
          default:
            stringBuilder.Append(ch);
            continue;
        }
      }
      else
        goto label_5;
    }
label_3:
    arrayEnd = true;
label_5:
    string str = stringBuilder.ToString();
    if (string.Compare("null", str.Trim(), StringComparison.OrdinalIgnoreCase) == 0)
      return (object) null;
    long result;
    if (str.StartsWith("new Date(") && str.EndsWith(")") && long.TryParse(str.Substring("new Date(".Length, str.Length - "new Date(".Length - ")".Length), out result))
      return (object) new DateTime(result * 10000L + Json._minDateTimeTicks, DateTimeKind.Utc);
    Json.HandleException((Exception) Json.GetUnexpectedCharacterException(Json.GetPosition(reader), str[0]), options);
    return (object) null;
  }

  private static object ReadNumberOrLiteral(
    TextReader reader,
    JsonOptions options,
    out bool arrayEnd)
  {
    arrayEnd = false;
    StringBuilder stringBuilder = new StringBuilder();
    while (true)
    {
      int num = reader.Peek();
      if (num >= 0 && (ushort) num != (ushort) 125)
      {
        char c = (char) reader.Read();
        if (!char.IsWhiteSpace(c))
        {
          switch (c)
          {
            case ',':
              goto label_6;
            case ']':
              goto label_4;
            default:
              stringBuilder.Append(c);
              continue;
          }
        }
        else
          goto label_6;
      }
      else
        goto label_6;
    }
label_4:
    arrayEnd = true;
label_6:
    string str = stringBuilder.ToString();
    if (string.Compare("null", str, StringComparison.OrdinalIgnoreCase) == 0)
      return (object) null;
    if (string.Compare("true", str, StringComparison.OrdinalIgnoreCase) == 0)
      return (object) true;
    if (string.Compare("false", str, StringComparison.OrdinalIgnoreCase) == 0)
      return (object) false;
    if (str.LastIndexOf("e", StringComparison.OrdinalIgnoreCase) >= 0)
    {
      double result;
      if (double.TryParse(str, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        return (object) result;
    }
    else if (str.IndexOf(".", StringComparison.OrdinalIgnoreCase) >= 0)
    {
      Decimal result;
      if (Decimal.TryParse(str, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result))
        return (object) result;
    }
    else
    {
      int result1;
      if (int.TryParse(str, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result1))
        return (object) result1;
      long result2;
      if (long.TryParse(str, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result2))
        return (object) result2;
      Decimal result3;
      if (Decimal.TryParse(str, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result3))
        return (object) result3;
    }
    Json.HandleException((Exception) Json.GetUnexpectedCharacterException(Json.GetPosition(reader), str[0]), options);
    return (object) null;
  }

  public static DateTime? TryParseDateTime(string text)
  {
    DateTime dt;
    return !Json.TryParseDateTime(text, out dt) ? new DateTime?() : new DateTime?(dt);
  }

  public static DateTime? TryParseDateTime(string text, DateTimeStyles styles)
  {
    DateTime dt;
    return !Json.TryParseDateTime(text, styles, out dt) ? new DateTime?() : new DateTime?(dt);
  }

  public static bool TryParseDateTime(string text, out DateTime dt) => Json.TryParseDateTime(text, JsonOptions._defaultDateTimeStyles, out dt);

  public static bool TryParseDateTime(string text, DateTimeStyles styles, out DateTime dt)
  {
    dt = DateTime.MinValue;
    if (text == null)
      return false;
    if (text.Length > 2 && text[0] == '"' && text[text.Length - 1] == '"')
    {
      using (StringReader reader = new StringReader(text))
      {
        reader.Read();
        text = Json.ReadString((TextReader) reader, new JsonOptions()
        {
          ThrowExceptions = false
        });
      }
    }
    if (text.EndsWith("Z", StringComparison.OrdinalIgnoreCase) && DateTime.TryParseExact(text, Json._dateFormatsUtc, (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.AllowWhiteSpaces | DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out dt))
      return true;
    int num1 = 0;
    int num2 = 0;
    DateTimeKind kind = DateTimeKind.Utc;
    if (text.Length >= 19 && text[4] == '-' && text[7] == '-' && (text[10] == 'T' || text[10] == 't') && text[13] == ':' && text[16] == ':')
    {
      if (DateTime.TryParseExact(text, "o", (IFormatProvider) null, DateTimeStyles.AssumeUniversal, out dt))
        return true;
      int num3 = text.Substring(19).IndexOfAny(new char[2]
      {
        '+',
        '-'
      });
      string s = text;
      if (num3 >= 0)
      {
        num3 += 19;
        int result;
        if (int.TryParse(text.Substring(num3 + 1).Trim(), out result))
        {
          kind = DateTimeKind.Local;
          num1 = result / 100;
          num2 = result % 100;
          if (text[num3] == '-')
          {
            num1 = -num1;
            num2 = -num2;
          }
          s = text.Substring(0, num3);
        }
      }
      if (num3 >= 0)
      {
        if (DateTime.TryParseExact(s, "s", (IFormatProvider) null, DateTimeStyles.AssumeLocal, out dt))
        {
          if (num1 != 0)
            dt = dt.AddHours((double) num1);
          if (num2 != 0)
            dt = dt.AddMinutes((double) num2);
          return true;
        }
      }
      else if (DateTime.TryParseExact(text, "s", (IFormatProvider) null, DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out dt))
        return true;
    }
    if (text != null && text.Length == 17 && (text[8] == 'T' || text[8] == 't') && text[11] == ':' && text[14] == ':')
    {
      int result1;
      int.TryParse(text.Substring(0, 4), out result1);
      int result2;
      int.TryParse(text.Substring(4, 2), out result2);
      int result3;
      int.TryParse(text.Substring(6, 2), out result3);
      int result4;
      int.TryParse(text.Substring(9, 2), out result4);
      int result5;
      int.TryParse(text.Substring(12, 2), out result5);
      int result6;
      int.TryParse(text.Substring(15, 2), out result6);
      if (result2 > 0 && result2 < 13 && result3 > 0 && result3 < 32 && result1 >= 0 && result4 >= 0 && result4 < 24 && result5 >= 0 && result5 < 60 && result6 >= 0)
      {
        if (result6 < 60)
        {
          try
          {
            dt = new DateTime(result1, result2, result3, result4, result5, result6);
            return true;
          }
          catch
          {
          }
        }
      }
    }
    string s1 = (string) null;
    if (text.StartsWith("new Date(") && text.EndsWith(")"))
      s1 = text.Substring("new Date(".Length, text.Length - "new Date(".Length - ")".Length).Trim();
    else if (text.StartsWith("/Date(", StringComparison.OrdinalIgnoreCase) && text.EndsWith(")/", StringComparison.OrdinalIgnoreCase))
      s1 = text.Substring("/Date(".Length, text.Length - ")/".Length - "/Date(".Length).Trim();
    if (!string.IsNullOrEmpty(s1))
    {
      int startIndex = s1[0] == '-' || s1[0] == '+' ? 1 : 0;
      int num4 = s1.IndexOfAny(new char[2]{ '+', '-' }, startIndex);
      if (num4 >= 0)
      {
        bool flag = s1[num4] == '-';
        string s2 = s1.Substring(num4 + 1).Trim();
        s1 = s1.Substring(0, num4).Trim();
        int num5;
        ref int local = ref num5;
        if (int.TryParse(s2, out local))
        {
          kind = DateTimeKind.Local;
          num1 = num5 / 100;
          num2 = num5 % 100;
          if (flag)
          {
            num1 = -num1;
            num2 = -num2;
          }
        }
      }
      long result;
      if (long.TryParse(s1, NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out result))
      {
        dt = new DateTime(result * 10000L + Json._minDateTimeTicks, kind);
        if (num1 != 0)
          dt = dt.AddHours((double) num1);
        if (num2 != 0)
          dt = dt.AddMinutes((double) num2);
        return true;
      }
    }
    if (text.Length != 8 || text[2] != ':' || text[5] != ':')
      return DateTime.TryParse(text, (IFormatProvider) null, styles, out dt);
    dt = DateTime.MinValue;
    return false;
  }

  private static void HandleException(Exception ex, JsonOptions options)
  {
    if (options == null || options.ThrowExceptions)
      throw ex;
    options.AddException(ex);
  }

  private static byte GetHexValue(TextReader reader, char c, JsonOptions options)
  {
    c = char.ToLower(c);
    if (c < '0')
    {
      Json.HandleException((Exception) Json.GetExpectedHexaCharacterException(Json.GetPosition(reader)), options);
      return 0;
    }
    if (c <= '9')
      return (byte) ((uint) c - 48U);
    if (c < 'a')
    {
      Json.HandleException((Exception) Json.GetExpectedHexaCharacterException(Json.GetPosition(reader)), options);
      return 0;
    }
    if (c <= 'f')
      return (byte) ((int) c - 97 + 10);
    Json.HandleException((Exception) Json.GetExpectedHexaCharacterException(Json.GetPosition(reader)), options);
    return 0;
  }

  private static ushort ReadX4(TextReader reader, JsonOptions options)
  {
    int num1 = 0;
    for (int index = 0; index < 4; ++index)
    {
      int num2 = num1 * 16;
      if (reader.Peek() < 0)
      {
        Json.HandleException((Exception) new JsonException("JSO0008: JSON deserialization error detected at end of stream. Expecting hexadecimal character."), options);
        return 0;
      }
      num1 = num2 + (int) Json.GetHexValue(reader, (char) reader.Read(), options);
    }
    return (ushort) num1;
  }

  private static bool ReadWhitespaces(TextReader reader) => Json.ReadWhile(reader, new Predicate<char>(char.IsWhiteSpace));

  private static bool ReadWhile(TextReader reader, Predicate<char> cont)
  {
    while (true)
    {
      int num = reader.Peek();
      if (num >= 0)
      {
        if (cont((char) num))
          reader.Read();
        else
          goto label_4;
      }
      else
        break;
    }
    return false;
label_4:
    return true;
  }

  public static void WriteValue(
    TextWriter writer,
    object value,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    objectGraph = objectGraph ?? (IDictionary<object, object>) new Dictionary<object, object>();
    options = options ?? new JsonOptions();
    if (options.WriteValueCallback != null)
    {
      JsonEventArgs e = new JsonEventArgs(writer, value, objectGraph, options);
      e.EventType = JsonEventType.WriteValue;
      options.WriteValueCallback(e);
      if (e.Handled)
        return;
    }
    if (value == null || Convert.IsDBNull(value))
    {
      writer.Write("null");
    }
    else
    {
      switch (value)
      {
        case string text:
          Json.WriteString(writer, text);
          break;
        case bool flag:
          writer.Write(flag ? "true" : "false");
          break;
        case float f:
          if (float.IsInfinity(f) || float.IsNaN(f))
          {
            writer.Write("null");
            break;
          }
          writer.Write(f.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture));
          break;
        case double d:
          if (double.IsInfinity(d) || double.IsNaN(d))
          {
            writer.Write("null");
            break;
          }
          writer.Write(d.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture));
          break;
        case char ch:
          if (ch == char.MinValue)
          {
            writer.Write("null");
            break;
          }
          Json.WriteString(writer, ch.ToString());
          break;
        case Enum @enum:
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.EnumAsText))
          {
            Json.WriteString(writer, value.ToString());
            break;
          }
          writer.Write(@enum.ToString("D"));
          break;
        case TimeSpan timeSpan:
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.TimeSpanAsText))
          {
            Json.WriteString(writer, timeSpan.ToString("g", (IFormatProvider) CultureInfo.InvariantCulture));
            break;
          }
          writer.Write(timeSpan.Ticks);
          break;
        case DateTimeOffset dateTimeOffset:
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatJs))
          {
            writer.Write("new Date(");
            writer.Write((dateTimeOffset.ToUniversalTime().Ticks - Json._minDateTimeTicks) / 10000L);
            writer.Write(")");
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateTimeOffsetFormatCustom) && !string.IsNullOrEmpty(options.DateTimeOffsetFormat))
          {
            Json.WriteString(writer, dateTimeOffset.ToUniversalTime().ToString(options.DateTimeOffsetFormat));
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatIso8601))
          {
            Json.WriteString(writer, dateTimeOffset.ToUniversalTime().ToString("s"));
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatRoundtripUtc))
          {
            Json.WriteString(writer, dateTimeOffset.ToUniversalTime().ToString("o"));
            break;
          }
          writer.Write("\"\\/Date(");
          writer.Write((dateTimeOffset.ToUniversalTime().Ticks - Json._minDateTimeTicks) / 10000L);
          writer.Write(")\\/\"");
          break;
        case DateTime dt:
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatJs))
          {
            writer.Write("new Date(");
            writer.Write((dt.ToUniversalTime().Ticks - Json._minDateTimeTicks) / 10000L);
            writer.Write(")");
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatCustom) && !string.IsNullOrEmpty(options.DateTimeFormat))
          {
            Json.WriteString(writer, dt.ToUniversalTime().ToString(options.DateTimeFormat));
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatIso8601))
          {
            writer.Write('"');
            writer.Write(Json.EscapeString(dt.ToUniversalTime().ToString("s")), (object) options);
            Json.AppendTimeZoneUtcOffset(writer, dt);
            writer.Write('"');
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.DateFormatRoundtripUtc))
          {
            Json.WriteString(writer, dt.ToUniversalTime().ToString("o"));
            break;
          }
          writer.Write("\"\\/Date(");
          writer.Write((dt.ToUniversalTime().Ticks - Json._minDateTimeTicks) / 10000L);
          Json.AppendTimeZoneUtcOffset(writer, dt);
          writer.Write(")\\/\"");
          break;
        case int _:
        case uint _:
        case short _:
        case ushort _:
        case long _:
        case ulong _:
        case byte _:
        case sbyte _:
        case Decimal _:
          writer.Write(string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
          {
            value
          }));
          break;
        case Guid guid:
          if (options.GuidFormat != null)
          {
            Json.WriteUnescapedString(writer, guid.ToString(options.GuidFormat));
            break;
          }
          Json.WriteUnescapedString(writer, guid.ToString());
          break;
        default:
          Uri uri = value as Uri;
          if (uri != (Uri) null)
          {
            Json.WriteString(writer, uri.GetComponents(UriComponents.SerializationInfoString, UriFormat.UriEscaped));
            break;
          }
          if (value is Array array)
          {
            Json.WriteArray(writer, array, objectGraph, options);
            break;
          }
          if (objectGraph.ContainsKey(value))
          {
            if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.ContinueOnCycle))
            {
              writer.Write("null");
              break;
            }
            Json.HandleException((Exception) new JsonException("JSO0009: Cyclic JSON serialization detected."), options);
            break;
          }
          objectGraph.Add(value, (object) null);
          if (value is IDictionary dictionary)
          {
            Json.WriteDictionary(writer, dictionary, objectGraph, options);
            break;
          }
          if (Json.TypeDef.IsKeyValuePairEnumerable(value.GetType(), out Type _, out Type _))
          {
            Json.WriteDictionary(writer, (IDictionary) new Json.KeyValueTypeDictionary(value), objectGraph, options);
            break;
          }
          if (value is IEnumerable enumerable)
          {
            Json.WriteEnumerable(writer, enumerable, objectGraph, options);
            break;
          }
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.StreamsAsBase64) && value is Stream stream)
          {
            Json.WriteBase64Stream(writer, stream, objectGraph, options);
            break;
          }
          Json.WriteObject(writer, value, objectGraph, options);
          break;
      }
    }
  }

  public static long WriteBase64Stream(
    TextWriter writer,
    Stream stream,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (stream == null)
      throw new ArgumentNullException(nameof (stream));
    objectGraph = objectGraph ?? (IDictionary<object, object>) new Dictionary<object, object>();
    options = options ?? new JsonOptions();
    long num = 0;
    switch (writer)
    {
      case StreamWriter streamWriter when streamWriter.BaseStream != null:
        streamWriter.Flush();
        return Json.WriteBase64Stream(stream, streamWriter.BaseStream, options);
      case IndentedTextWriter indentedTextWriter when indentedTextWriter.InnerWriter != null:
        indentedTextWriter.Flush();
        return Json.WriteBase64Stream(indentedTextWriter.InnerWriter, stream, objectGraph, options);
      default:
        using (MemoryStream memoryStream = new MemoryStream())
        {
          byte[] buffer = new byte[options.FinalStreamingBufferChunkSize];
          while (true)
          {
            int count = stream.Read(buffer, 0, buffer.Length);
            if (count != 0)
            {
              memoryStream.Write(buffer, 0, count);
              num += (long) count;
            }
            else
              break;
          }
          writer.Write('"');
          writer.Write(Convert.ToBase64String(memoryStream.ToArray()));
          writer.Write('"');
          return num;
        }
    }
  }

  private static long WriteBase64Stream(
    Stream inputStream,
    Stream outputStream,
    JsonOptions options)
  {
    outputStream.WriteByte((byte) 34);
    CryptoStream cryptoStream = new CryptoStream(outputStream, (ICryptoTransform) new ToBase64Transform(), CryptoStreamMode.Write);
    long num = 0;
    byte[] buffer = new byte[options.FinalStreamingBufferChunkSize];
    while (true)
    {
      int count = inputStream.Read(buffer, 0, buffer.Length);
      if (count != 0)
      {
        cryptoStream.Write(buffer, 0, count);
        num += (long) count;
      }
      else
        break;
    }
    cryptoStream.FlushFinalBlock();
    cryptoStream.Flush();
    outputStream.WriteByte((byte) 34);
    return num;
  }

  private static bool InternalIsKeyValuePairEnumerable(
    Type type,
    out Type keyType,
    out Type valueType)
  {
    keyType = (Type) null;
    valueType = (Type) null;
    foreach (Type type1 in type.GetInterfaces())
    {
      if (type1.IsGenericType && typeof (IEnumerable<>).IsAssignableFrom(type1.GetGenericTypeDefinition()))
      {
        Type[] genericArguments1 = type1.GetGenericArguments();
        if (genericArguments1.Length == 1)
        {
          Type type2 = genericArguments1[0];
          if (type2.IsGenericType && typeof (KeyValuePair<,>).IsAssignableFrom(type2.GetGenericTypeDefinition()))
          {
            Type[] genericArguments2 = type2.GetGenericArguments();
            if (genericArguments2.Length == 2)
            {
              keyType = genericArguments2[0];
              valueType = genericArguments2[1];
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  private static void AppendTimeZoneUtcOffset(TextWriter writer, DateTime dt)
  {
    if (dt.Kind == DateTimeKind.Utc)
      return;
    TimeSpan utcOffset = TimeZoneInfo.Local.GetUtcOffset(dt);
    writer.Write(utcOffset.Ticks >= 0L ? '+' : '-');
    writer.Write(Math.Abs(utcOffset.Hours).ToString("D2"));
    writer.Write(Math.Abs(utcOffset.Minutes).ToString("D2"));
  }

  public static void WriteArray(
    TextWriter writer,
    Array array,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (array == null)
      throw new ArgumentNullException(nameof (array));
    objectGraph = objectGraph ?? (IDictionary<object, object>) new Dictionary<object, object>();
    options = options ?? new JsonOptions();
    if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.ByteArrayAsBase64) && array is byte[] buffer)
    {
      using (MemoryStream memoryStream = new MemoryStream(buffer))
      {
        memoryStream.Position = 0L;
        Json.WriteBase64Stream(writer, (Stream) memoryStream, objectGraph, options);
      }
    }
    else
      Json.WriteArray(writer, array, objectGraph, options, new int[0]);
  }

  private static void WriteArray(
    TextWriter writer,
    Array array,
    IDictionary<object, object> objectGraph,
    JsonOptions options,
    int[] indices)
  {
    int[] indices1 = new int[indices.Length + 1];
    for (int index = 0; index < indices.Length; ++index)
      indices1[index] = indices[index];
    writer.Write('[');
    for (int index = 0; index < array.GetLength(indices.Length); ++index)
    {
      if (index > 0)
        writer.Write(',');
      indices1[indices.Length] = index;
      if (array.Rank == indices1.Length)
        Json.WriteValue(writer, array.GetValue(indices1), objectGraph, options);
      else
        Json.WriteArray(writer, array, objectGraph, options, indices1);
    }
    writer.Write(']');
  }

  public static void WriteEnumerable(
    TextWriter writer,
    IEnumerable enumerable,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (enumerable == null)
      throw new ArgumentNullException(nameof (enumerable));
    objectGraph = objectGraph ?? (IDictionary<object, object>) new Dictionary<object, object>();
    options = options ?? new JsonOptions();
    writer.Write('[');
    bool flag = true;
    foreach (object obj in enumerable)
    {
      if (!flag)
        writer.Write(',');
      else
        flag = false;
      Json.WriteValue(writer, obj, objectGraph, options);
    }
    writer.Write(']');
  }

  public static void WriteDictionary(
    TextWriter writer,
    IDictionary dictionary,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (dictionary == null)
      throw new ArgumentNullException(nameof (dictionary));
    objectGraph = objectGraph ?? (IDictionary<object, object>) new Dictionary<object, object>();
    options = options ?? new JsonOptions();
    writer.Write('{');
    bool flag = true;
    foreach (DictionaryEntry dictionaryEntry in dictionary)
    {
      if (dictionaryEntry.Key != null)
      {
        string text = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
        {
          dictionaryEntry.Key
        });
        if (!flag)
          writer.Write(',');
        else
          flag = false;
        if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.WriteKeysWithoutQuotes))
          writer.Write(Json.EscapeString(text));
        else
          Json.WriteString(writer, text);
        writer.Write(':');
        Json.WriteValue(writer, dictionaryEntry.Value, objectGraph, options);
      }
    }
    writer.Write('}');
  }

  private static void WriteSerializable(
    TextWriter writer,
    ISerializable serializable,
    IDictionary<object, object> objectGraph,
    JsonOptions options)
  {
    SerializationInfo info = new SerializationInfo(serializable.GetType(), (IFormatterConverter) Json._defaultFormatterConverter);
    StreamingContext context = new StreamingContext(StreamingContextStates.Remoting, (object) null);
    serializable.GetObjectData(info, context);
    info.AddValue("__type", (object) serializable.GetType().AssemblyQualifiedName);
    bool flag = true;
    foreach (SerializationEntry serializationEntry in info)
    {
      if (!flag)
        writer.Write(',');
      else
        flag = false;
      if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.WriteKeysWithoutQuotes))
        writer.Write(Json.EscapeString(serializationEntry.Name));
      else
        Json.WriteString(writer, serializationEntry.Name);
      writer.Write(':');
      Json.WriteValue(writer, serializationEntry.Value, objectGraph, options);
    }
  }

  private static bool ForceSerializable(object obj) => obj is Exception;

  public static void WriteObject(
    TextWriter writer,
    object value,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (value == null)
      throw new ArgumentNullException(nameof (value));
    objectGraph = objectGraph ?? (IDictionary<object, object>) new Dictionary<object, object>();
    options = options ?? new JsonOptions();
    ISerializable serializable = (ISerializable) null;
    if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseISerializable) || Json.ForceSerializable(value))
      serializable = value as ISerializable;
    writer.Write('{');
    if (options.BeforeWriteObjectCallback != null)
    {
      JsonEventArgs e = new JsonEventArgs(writer, value, objectGraph, options);
      e.EventType = JsonEventType.BeforeWriteObject;
      options.BeforeWriteObjectCallback(e);
      if (e.Handled)
        return;
    }
    Type type = value.GetType();
    if (serializable != null)
      Json.WriteSerializable(writer, serializable, objectGraph, options);
    else
      Json.TypeDef.Get(type, options).WriteValues(writer, value, objectGraph, options);
    if (options.AfterWriteObjectCallback != null)
      options.AfterWriteObjectCallback(new JsonEventArgs(writer, value, objectGraph, options)
      {
        EventType = JsonEventType.AfterWriteObject
      });
    writer.Write('}');
  }

  public static bool IsZeroValueType(object value)
  {
    if (value == null)
      return false;
    Type type = value.GetType();
    return type.IsValueType && value.Equals(Activator.CreateInstance(type));
  }

  public static void WriteNameValue(
    TextWriter writer,
    string name,
    object value,
    IDictionary<object, object> objectGraph,
    JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    name = name ?? string.Empty;
    options = options ?? new JsonOptions();
    if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.WriteKeysWithoutQuotes))
      writer.Write(Json.EscapeString(name));
    else
      Json.WriteString(writer, name);
    writer.Write(':');
    Json.WriteValue(writer, value, objectGraph, options);
  }

  public static void WriteString(TextWriter writer, string text)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (text == null)
    {
      writer.Write("null");
    }
    else
    {
      writer.Write('"');
      writer.Write(Json.EscapeString(text));
      writer.Write('"');
    }
  }

  public static void WriteUnescapedString(TextWriter writer, string text)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    if (text == null)
    {
      writer.Write("null");
    }
    else
    {
      writer.Write('"');
      writer.Write(text);
      writer.Write('"');
    }
  }

  private static void AppendCharAsUnicode(StringBuilder sb, char c)
  {
    sb.Append('\\');
    sb.Append('u');
    sb.AppendFormat((IFormatProvider) CultureInfo.InvariantCulture, "{0:X4}", new object[1]
    {
      (object) (ushort) c
    });
  }

  public static string SerializeFormatted(object value, JsonOptions options = null)
  {
    using (StringWriter writer = new StringWriter())
    {
      Json.SerializeFormatted((TextWriter) writer, value, options);
      return writer.ToString();
    }
  }

  public static void SerializeFormatted(TextWriter writer, object value, JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    options = options ?? new JsonOptions();
    object jsonObject = Json.Deserialize(Json.Serialize(value, options), typeof (object), options);
    Json.WriteFormatted(writer, jsonObject, options);
  }

  public static string WriteFormatted(object jsonObject, JsonOptions options = null)
  {
    using (StringWriter writer = new StringWriter())
    {
      Json.WriteFormatted((TextWriter) writer, jsonObject, options);
      return writer.ToString();
    }
  }

  public static void WriteFormatted(TextWriter writer, object jsonObject, JsonOptions options = null)
  {
    if (writer == null)
      throw new ArgumentNullException(nameof (writer));
    options = options ?? new JsonOptions();
    Json.WriteFormatted(new IndentedTextWriter(writer, options.FormattingTab), jsonObject, options);
  }

  private static void WriteFormatted(
    IndentedTextWriter writer,
    object jsonObject,
    JsonOptions options)
  {
    switch (jsonObject)
    {
      case DictionaryEntry dictionaryEntry:
        string str = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
        {
          dictionaryEntry.Key
        });
        if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.WriteKeysWithoutQuotes))
        {
          writer.Write(str);
          writer.Write(": ");
        }
        else
        {
          writer.Write('"');
          writer.Write(str);
          writer.Write("\": ");
        }
        ++writer.Indent;
        Json.WriteFormatted(writer, dictionaryEntry.Value, options);
        --writer.Indent;
        break;
      case IDictionary dictionary:
        writer.WriteLine('{');
        bool flag1 = true;
        ++writer.Indent;
        foreach (DictionaryEntry jsonObject1 in dictionary)
        {
          if (!flag1)
            writer.WriteLine(',');
          else
            flag1 = false;
          Json.WriteFormatted(writer, (object) jsonObject1, options);
        }
        --writer.Indent;
        writer.WriteLine();
        writer.Write('}');
        break;
      case string text:
        Json.WriteString((TextWriter) writer, text);
        break;
      case IEnumerable enumerable:
        writer.WriteLine('[');
        bool flag2 = true;
        ++writer.Indent;
        foreach (object jsonObject2 in enumerable)
        {
          if (!flag2)
            writer.WriteLine(',');
          else
            flag2 = false;
          Json.WriteFormatted(writer, jsonObject2, options);
        }
        --writer.Indent;
        writer.WriteLine();
        writer.Write(']');
        break;
      default:
        Json.WriteValue((TextWriter) writer, jsonObject, (IDictionary<object, object>) null, options);
        break;
    }
  }

  public static string EscapeString(string value)
  {
    if (string.IsNullOrEmpty(value))
      return (string) null;
    StringBuilder sb = (StringBuilder) null;
    int startIndex = 0;
    int count = 0;
    for (int index = 0; index < value.Length; ++index)
    {
      char c = value[index];
      switch (c)
      {
        case '\b':
        case '\t':
        case '\n':
        case '\f':
        case '\r':
        case '"':
        case '\'':
        case '<':
        case '>':
        case '\\':
          if (sb == null)
            sb = new StringBuilder(value.Length + 5);
          if (count > 0)
            sb.Append(value, startIndex, count);
          startIndex = index + 1;
          count = 0;
          break;
        default:
          if (c >= ' ')
            break;
          goto case '\b';
      }
      switch (c)
      {
        case '\b':
          sb.Append("\\b");
          break;
        case '\t':
          sb.Append("\\t");
          break;
        case '\n':
          sb.Append("\\n");
          break;
        case '\f':
          sb.Append("\\f");
          break;
        case '\r':
          sb.Append("\\r");
          break;
        case '"':
          sb.Append("\\\"");
          break;
        case '\'':
        case '<':
        case '>':
          Json.AppendCharAsUnicode(sb, c);
          break;
        case '\\':
          sb.Append("\\\\");
          break;
        default:
          if (c < ' ')
          {
            Json.AppendCharAsUnicode(sb, c);
            break;
          }
          ++count;
          break;
      }
    }
    if (sb == null)
      return value;
    if (count > 0)
      sb.Append(value, startIndex, count);
    return sb.ToString();
  }

  private static T GetAttribute<T>(this PropertyDescriptor descriptor) where T : Attribute => descriptor.Attributes.GetAttribute<T>();

  private static T GetAttribute<T>(this AttributeCollection attributes) where T : Attribute
  {
    foreach (object attribute in attributes)
    {
      if (typeof (T).IsAssignableFrom(attribute.GetType()))
        return (T) attribute;
    }
    return default (T);
  }

  private static bool EqualsIgnoreCase(this string str, string text, bool trim = false)
  {
    if (trim)
    {
      str = str.Nullify();
      text = text.Nullify();
    }
    if (str == null)
      return text == null;
    return text != null && str.Length == text.Length && string.Compare(str, text, StringComparison.OrdinalIgnoreCase) == 0;
  }

  private static string Nullify(this string str)
  {
    if (str == null)
      return (string) null;
    if (string.IsNullOrWhiteSpace(str))
      return (string) null;
    string str1 = str.Trim();
    return str1.Length != 0 ? str1 : (string) null;
  }

  public abstract class ListObject
  {
    public virtual object List { get; set; }

    public virtual IDictionary<string, object> Context => (IDictionary<string, object>) null;

    public abstract void Clear();

    public abstract void Add(object value, JsonOptions options = null);
  }

  public interface IMemberAccessor
  {
    object Get(object component);

    void Set(object component, object value);
  }

  public class MemberDefinition
  {
    private string _name;
    private string _wireName;
    private string _escapedWireName;
    private Json.IMemberAccessor _accessor;
    private Type _type;

    public string Name
    {
      get => this._name;
      set => this._name = !string.IsNullOrEmpty(value) ? value : throw new ArgumentException((string) null, nameof (value));
    }

    public string WireName
    {
      get => this._wireName;
      set => this._wireName = !string.IsNullOrEmpty(value) ? value : throw new ArgumentException((string) null, nameof (value));
    }

    public string EscapedWireName
    {
      get => this._escapedWireName;
      set => this._escapedWireName = !string.IsNullOrEmpty(value) ? value : throw new ArgumentException((string) null, nameof (value));
    }

    public bool HasDefaultValue { get; set; }

    public object DefaultValue { get; set; }

    public Json.IMemberAccessor Accessor
    {
      get => this._accessor;
      set => this._accessor = value != null ? value : throw new ArgumentNullException(nameof (value));
    }

    public Type Type
    {
      get => this._type;
      set => this._type = !(value == (Type) null) ? value : throw new ArgumentNullException(nameof (value));
    }

    public override string ToString() => this.Name;

    public virtual object GetOrCreateInstance(
      object target,
      int elementsCount,
      JsonOptions options = null)
    {
      object instance;
      if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.ContinueOnValueError))
      {
        try
        {
          instance = this.Accessor.Get(target);
        }
        catch
        {
          return (object) null;
        }
      }
      else
        instance = this.Accessor.Get(target);
      if (instance == null || instance is Array array && array.GetLength(0) < elementsCount)
      {
        if (this.Type.IsInterface)
          return (object) null;
        instance = Json.CreateInstance(target, this.Type, elementsCount, options, instance);
        if (instance != null)
          this.Accessor.Set(target, instance);
      }
      return instance;
    }

    public virtual void ApplyEntry(
      IDictionary dictionary,
      object target,
      string key,
      object value,
      JsonOptions options = null)
    {
      if (options.ApplyEntryCallback != null)
      {
        JsonEventArgs e = new JsonEventArgs((TextWriter) null, value, (IDictionary<object, object>) new Dictionary<object, object>()
        {
          [(object) nameof (dictionary)] = (object) dictionary,
          [(object) "member"] = (object) this
        }, options, key, target);
        e.EventType = JsonEventType.ApplyEntry;
        options.ApplyEntryCallback(e);
        if (e.Handled)
          return;
        value = e.Value;
      }
      if (value is IDictionary dictionary1)
      {
        object instance = this.GetOrCreateInstance(target, dictionary1.Count, options);
        Json.Apply(dictionary1, instance, options);
      }
      else
      {
        Json.ListObject listObject = Json.GetListObject(this.Type, options, target, value, dictionary, key);
        if (listObject != null && value is IEnumerable input)
        {
          listObject.List = this.GetOrCreateInstance(target, input is ICollection collection ? collection.Count : 0, options);
          Json.ApplyToListTarget(target, input, listObject, options);
        }
        else
        {
          object obj = Json.ChangeType(target, value, this.Type, options);
          this.Accessor.Set(target, obj);
        }
      }
    }

    public virtual bool IsNullDateTimeValue(object value) => value == null || DateTime.MinValue.Equals(value);

    public virtual bool IsZeroValue(object value) => value != null && !(value.GetType() != this.Type) && Json.IsZeroValueType(value);

    public virtual bool EqualsDefaultValue(object value) => Json.AreValuesEqual(this.DefaultValue, value);

    public static bool RemoveDeserializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      if (member == null)
        throw new ArgumentNullException(nameof (member));
      options = options ?? new JsonOptions();
      return Json.TypeDef.RemoveDeserializationMember(type, options, member);
    }

    public static bool RemoveSerializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      if (member == null)
        throw new ArgumentNullException(nameof (member));
      options = options ?? new JsonOptions();
      return Json.TypeDef.RemoveSerializationMember(type, options, member);
    }

    public static void AddDeserializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      if (member == null)
        throw new ArgumentNullException(nameof (member));
      options = options ?? new JsonOptions();
      Json.TypeDef.AddDeserializationMember(type, options, member);
    }

    public static void AddSerializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      if (member == null)
        throw new ArgumentNullException(nameof (member));
      options = options ?? new JsonOptions();
      Json.TypeDef.AddSerializationMember(type, options, member);
    }

    public static Json.MemberDefinition[] GetSerializationMembers(
      Type type,
      JsonOptions options = null)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      options = options ?? new JsonOptions();
      return Json.TypeDef.GetSerializationMembers(type, options);
    }

    public static Json.MemberDefinition[] GetDeserializationMembers(
      Type type,
      JsonOptions options = null)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      options = options ?? new JsonOptions();
      return Json.TypeDef.GetDeserializationMembers(type, options);
    }

    public static void UsingLock<T>(Action<T> action, T state)
    {
      if (action == null)
        throw new ArgumentNullException(nameof (action));
      Json.TypeDef.Lock<T>(action, state);
    }
  }

  private class KeyValueTypeEnumerator : IDictionaryEnumerator, IEnumerator
  {
    private readonly IEnumerator _enumerator;
    private PropertyInfo _keyProp;
    private PropertyInfo _valueProp;

    public DictionaryEntry Entry
    {
      get
      {
        if (this._keyProp == (PropertyInfo) null)
        {
          this._keyProp = this._enumerator.Current.GetType().GetProperty("Key");
          this._valueProp = this._enumerator.Current.GetType().GetProperty("Value");
        }
        return new DictionaryEntry(this._keyProp.GetValue(this._enumerator.Current, (object[]) null), this._valueProp.GetValue(this._enumerator.Current, (object[]) null));
      }
    }

    public object Key => this.Entry.Key;

    public object Value => this.Entry.Value;

    public object Current => (object) this.Entry;

    public KeyValueTypeEnumerator(object value) => this._enumerator = ((IEnumerable) value).GetEnumerator();

    public bool MoveNext() => this._enumerator.MoveNext();

    public void Reset() => this._enumerator.Reset();
  }

  private class KeyValueTypeDictionary : IDictionary, ICollection, IEnumerable
  {
    private readonly Json.KeyValueTypeEnumerator _enumerator;

    public int Count => throw new NotSupportedException();

    public bool IsSynchronized => throw new NotSupportedException();

    public object SyncRoot => throw new NotSupportedException();

    public bool IsFixedSize => throw new NotSupportedException();

    public bool IsReadOnly => throw new NotSupportedException();

    public ICollection Keys => throw new NotSupportedException();

    public ICollection Values => throw new NotSupportedException();

    public object this[object key]
    {
      get => throw new NotSupportedException();
      set => throw new NotSupportedException();
    }

    public KeyValueTypeDictionary(object value) => this._enumerator = new Json.KeyValueTypeEnumerator(value);

    public void Add(object key, object value) => throw new NotSupportedException();

    public void Clear() => throw new NotSupportedException();

    public bool Contains(object key) => throw new NotSupportedException();

    public IDictionaryEnumerator GetEnumerator() => (IDictionaryEnumerator) this._enumerator;

    public void Remove(object key) => throw new NotSupportedException();

    public void CopyTo(Array array, int index) => throw new NotSupportedException();

    IEnumerator IEnumerable.GetEnumerator() => throw new NotSupportedException();
  }

  private class KeyValueType
  {
    public Type KeyType;
    public Type ValueType;
  }

  private class TypeDef
  {
    private static readonly Dictionary<string, Json.TypeDef> _defs = new Dictionary<string, Json.TypeDef>();
    private static readonly Dictionary<Type, Json.KeyValueType> _iskvpe = new Dictionary<Type, Json.KeyValueType>();
    private static readonly object _lock = new object();
    private readonly List<Json.MemberDefinition> _serializationMembers = new List<Json.MemberDefinition>();
    private readonly List<Json.MemberDefinition> _deserializationMembers = new List<Json.MemberDefinition>();
    private readonly Type _type;

    private TypeDef(Type type, JsonOptions options)
    {
      this._type = type;
      this._serializationMembers = new List<Json.MemberDefinition>(options.FinalizeSerializationMembers(type, !options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseReflection) ? Json.TypeDef.EnumerateDefinitionsUsingTypeDescriptors(true, type, options) : Json.TypeDef.EnumerateDefinitionsUsingReflection(true, type, options)));
      this._deserializationMembers = new List<Json.MemberDefinition>(options.FinalizeDeserializationMembers(type, !options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseReflection) ? Json.TypeDef.EnumerateDefinitionsUsingTypeDescriptors(false, type, options) : Json.TypeDef.EnumerateDefinitionsUsingReflection(false, type, options)));
    }

    private Json.MemberDefinition GetDeserializationMember(string key)
    {
      if (key == null)
        return (Json.MemberDefinition) null;
      foreach (Json.MemberDefinition deserializationMember in this._deserializationMembers)
      {
        if (string.Compare(deserializationMember.WireName, key, StringComparison.OrdinalIgnoreCase) == 0)
          return deserializationMember;
      }
      return (Json.MemberDefinition) null;
    }

    public void ApplyEntry(
      IDictionary dictionary,
      object target,
      string key,
      object value,
      JsonOptions options)
    {
      this.GetDeserializationMember(key)?.ApplyEntry(dictionary, target, key, value, options);
    }

    public void WriteValues(
      TextWriter writer,
      object component,
      IDictionary<object, object> objectGraph,
      JsonOptions options)
    {
      bool flag1 = true;
      foreach (Json.MemberDefinition serializationMember in this._serializationMembers)
      {
        bool flag2 = false;
        string name = serializationMember.WireName;
        object obj = serializationMember.Accessor.Get(component);
        if (options.WriteNamedValueObjectCallback != null)
        {
          JsonEventArgs e = new JsonEventArgs(writer, obj, objectGraph, options, name, component);
          e.EventType = JsonEventType.WriteNamedValueObject;
          e.First = flag1;
          options.WriteNamedValueObjectCallback(e);
          flag1 = e.First;
          if (!e.Handled)
          {
            flag2 = name != e.Name;
            name = e.Name;
            obj = e.Value;
          }
          else
            continue;
        }
        if ((!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.SkipNullPropertyValues) || obj != null) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.SkipZeroValueTypes) || !serializationMember.IsZeroValue(obj)) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.SkipNullDateTimeValues) || !serializationMember.IsNullDateTimeValue(obj)) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.SkipDefaultValues) || !serializationMember.HasDefaultValue || !serializationMember.EqualsDefaultValue(obj)))
        {
          if (!flag1)
            writer.Write(',');
          else
            flag1 = false;
          if (flag2)
          {
            Json.WriteNameValue(writer, name, obj, objectGraph, options);
          }
          else
          {
            if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.WriteKeysWithoutQuotes))
            {
              writer.Write(serializationMember.EscapedWireName);
            }
            else
            {
              writer.Write('"');
              writer.Write(serializationMember.EscapedWireName);
              writer.Write('"');
            }
            writer.Write(':');
            Json.WriteValue(writer, obj, objectGraph, options);
          }
        }
      }
    }

    public override string ToString() => this._type.AssemblyQualifiedName;

    private static string GetKey(Type type, JsonOptions options) => type.AssemblyQualifiedName + "\0" + options.GetCacheKey();

    private static Json.TypeDef UnlockedGet(Type type, JsonOptions options)
    {
      string key = Json.TypeDef.GetKey(type, options);
      Json.TypeDef typeDef;
      if (!Json.TypeDef._defs.TryGetValue(key, out typeDef))
      {
        typeDef = new Json.TypeDef(type, options);
        Json.TypeDef._defs.Add(key, typeDef);
      }
      return typeDef;
    }

    public static void Lock<T>(Action<T> action, T state)
    {
      lock (Json.TypeDef._lock)
        action(state);
    }

    public static bool RemoveDeserializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      lock (Json.TypeDef._lock)
        return Json.TypeDef.UnlockedGet(type, options)._deserializationMembers.Remove(member);
    }

    public static bool RemoveSerializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      lock (Json.TypeDef._lock)
        return Json.TypeDef.UnlockedGet(type, options)._serializationMembers.Remove(member);
    }

    public static void AddDeserializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      lock (Json.TypeDef._lock)
        Json.TypeDef.UnlockedGet(type, options)._deserializationMembers.Add(member);
    }

    public static void AddSerializationMember(
      Type type,
      JsonOptions options,
      Json.MemberDefinition member)
    {
      lock (Json.TypeDef._lock)
        Json.TypeDef.UnlockedGet(type, options)._serializationMembers.Add(member);
    }

    public static Json.MemberDefinition[] GetDeserializationMembers(
      Type type,
      JsonOptions options)
    {
      lock (Json.TypeDef._lock)
        return Json.TypeDef.UnlockedGet(type, options)._deserializationMembers.ToArray();
    }

    public static Json.MemberDefinition[] GetSerializationMembers(
      Type type,
      JsonOptions options)
    {
      lock (Json.TypeDef._lock)
        return Json.TypeDef.UnlockedGet(type, options)._serializationMembers.ToArray();
    }

    public static Json.TypeDef Get(Type type, JsonOptions options)
    {
      lock (Json.TypeDef._lock)
        return Json.TypeDef.UnlockedGet(type, options);
    }

    public static bool IsKeyValuePairEnumerable(Type type, out Type keyType, out Type valueType)
    {
      lock (Json.TypeDef._lock)
      {
        Json.KeyValueType keyValueType;
        if (!Json.TypeDef._iskvpe.TryGetValue(type, out keyValueType))
        {
          keyValueType = new Json.KeyValueType();
          Json.InternalIsKeyValuePairEnumerable(type, out keyValueType.KeyType, out keyValueType.ValueType);
          Json.TypeDef._iskvpe.Add(type, keyValueType);
        }
        keyType = keyValueType.KeyType;
        valueType = keyValueType.ValueType;
        return keyValueType.KeyType != (Type) null;
      }
    }

    private static IEnumerable<Json.MemberDefinition> EnumerateDefinitionsUsingReflection(
      bool serialization,
      Type type,
      JsonOptions options)
    {
      PropertyInfo[] propertyInfoArray = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
      int index;
      for (index = 0; index < propertyInfoArray.Length; ++index)
      {
        PropertyInfo propertyInfo = propertyInfoArray[index];
        if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseJsonAttribute))
        {
          JsonAttribute jsonAttribute = Json.GetJsonAttribute((MemberInfo) propertyInfo);
          if (jsonAttribute != null && (serialization && jsonAttribute.IgnoreWhenSerializing || !serialization && jsonAttribute.IgnoreWhenDeserializing))
            continue;
        }
        if ((!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseXmlIgnore) || !propertyInfo.IsDefined(typeof (XmlIgnoreAttribute), true)) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseScriptIgnore) || !Json.HasScriptIgnore((MemberInfo) propertyInfo)))
        {
          if (serialization)
          {
            if (propertyInfo.CanRead)
            {
              MethodInfo getMethod = propertyInfo.GetGetMethod();
              if (getMethod == (MethodInfo) null || getMethod.GetParameters().Length != 0)
                continue;
            }
            else
              continue;
          }
          string objectName = Json.GetObjectName((MemberInfo) propertyInfo, propertyInfo.Name);
          Json.MemberDefinition memberDefinition = new Json.MemberDefinition();
          memberDefinition.Type = propertyInfo.PropertyType;
          memberDefinition.Name = propertyInfo.Name;
          if (serialization)
          {
            memberDefinition.WireName = objectName;
            memberDefinition.EscapedWireName = Json.EscapeString(objectName);
          }
          else
            memberDefinition.WireName = objectName;
          object obj;
          memberDefinition.HasDefaultValue = Json.TryGetObjectDefaultValue((MemberInfo) propertyInfo, out obj);
          memberDefinition.DefaultValue = obj;
          memberDefinition.Accessor = (Json.IMemberAccessor) Activator.CreateInstance(typeof (Json.PropertyInfoAccessor<,>).MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType), (object) propertyInfo);
          yield return memberDefinition;
        }
      }
      propertyInfoArray = (PropertyInfo[]) null;
      if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.SerializeFields))
      {
        FieldInfo[] fieldInfoArray = type.GetFields(BindingFlags.Instance | BindingFlags.Public);
        for (index = 0; index < fieldInfoArray.Length; ++index)
        {
          FieldInfo fieldInfo = fieldInfoArray[index];
          if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseJsonAttribute))
          {
            JsonAttribute jsonAttribute = Json.GetJsonAttribute((MemberInfo) fieldInfo);
            if (jsonAttribute != null && (serialization && jsonAttribute.IgnoreWhenSerializing || !serialization && jsonAttribute.IgnoreWhenDeserializing))
              continue;
          }
          if ((!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseXmlIgnore) || !fieldInfo.IsDefined(typeof (XmlIgnoreAttribute), true)) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseScriptIgnore) || !Json.HasScriptIgnore((MemberInfo) fieldInfo)))
          {
            string objectName = Json.GetObjectName((MemberInfo) fieldInfo, fieldInfo.Name);
            Json.MemberDefinition memberDefinition = new Json.MemberDefinition();
            memberDefinition.Type = fieldInfo.FieldType;
            memberDefinition.Name = fieldInfo.Name;
            if (serialization)
            {
              memberDefinition.WireName = objectName;
              memberDefinition.EscapedWireName = Json.EscapeString(objectName);
            }
            else
              memberDefinition.WireName = objectName;
            object obj;
            memberDefinition.HasDefaultValue = Json.TryGetObjectDefaultValue((MemberInfo) fieldInfo, out obj);
            memberDefinition.DefaultValue = obj;
            memberDefinition.Accessor = (Json.IMemberAccessor) Activator.CreateInstance(typeof (Json.FieldInfoAccessor), (object) fieldInfo);
            yield return memberDefinition;
          }
        }
        fieldInfoArray = (FieldInfo[]) null;
      }
    }

    private static IEnumerable<Json.MemberDefinition> EnumerateDefinitionsUsingTypeDescriptors(
      bool serialization,
      Type type,
      JsonOptions options)
    {
      foreach (PropertyDescriptor propertyDescriptor in TypeDescriptor.GetProperties(type).Cast<PropertyDescriptor>())
      {
        if (options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseJsonAttribute))
        {
          JsonAttribute attribute = propertyDescriptor.GetAttribute<JsonAttribute>();
          if (attribute != null && (serialization && attribute.IgnoreWhenSerializing || !serialization && attribute.IgnoreWhenDeserializing))
            continue;
        }
        if ((!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseXmlIgnore) || propertyDescriptor.GetAttribute<XmlIgnoreAttribute>() == null) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.UseScriptIgnore) || !Json.HasScriptIgnore(propertyDescriptor)) && (!options.SerializationOptions.HasFlag((Enum) JsonSerializationOptions.SkipGetOnly) || !propertyDescriptor.IsReadOnly))
        {
          string objectName = Json.GetObjectName(propertyDescriptor, propertyDescriptor.Name);
          Json.MemberDefinition memberDefinition = new Json.MemberDefinition();
          memberDefinition.Type = propertyDescriptor.PropertyType;
          memberDefinition.Name = propertyDescriptor.Name;
          if (serialization)
          {
            memberDefinition.WireName = objectName;
            memberDefinition.EscapedWireName = Json.EscapeString(objectName);
          }
          else
            memberDefinition.WireName = objectName;
          object obj;
          memberDefinition.HasDefaultValue = Json.TryGetObjectDefaultValue(propertyDescriptor, out obj);
          memberDefinition.DefaultValue = obj;
          memberDefinition.Accessor = (Json.IMemberAccessor) Activator.CreateInstance(typeof (Json.PropertyDescriptorAccessor), (object) propertyDescriptor);
          yield return memberDefinition;
        }
      }
    }
  }

  private class ReferenceComparer : IEqualityComparer<object>
  {
    internal static readonly Json.ReferenceComparer _current = new Json.ReferenceComparer();

    bool IEqualityComparer<object>.Equals(object x, object y) => x == y;

    int IEqualityComparer<object>.GetHashCode(object obj) => RuntimeHelpers.GetHashCode(obj);
  }

  private class ICollectionTObject<T> : Json.ListObject
  {
    private ICollection<T> _coll;

    public override object List
    {
      get => base.List;
      set
      {
        base.List = value;
        this._coll = (ICollection<T>) value;
      }
    }

    public override void Clear() => this._coll.Clear();

    public override void Add(object value, JsonOptions options = null)
    {
      if (value == null && typeof (T).IsValueType)
        Json.HandleException((Exception) new JsonException("JSO0014: JSON error detected. Cannot add null to a collection of '" + typeof (T)?.ToString() + "' elements."), options);
      this._coll.Add((T) value);
    }
  }

  private class IListObject : Json.ListObject
  {
    private IList _list;

    public override object List
    {
      get => base.List;
      set
      {
        base.List = value;
        this._list = (IList) value;
      }
    }

    public override void Clear() => this._list.Clear();

    public override void Add(object value, JsonOptions options = null) => this._list.Add(value);
  }

  private class FieldInfoAccessor : Json.IMemberAccessor
  {
    private readonly FieldInfo _fi;

    public FieldInfoAccessor(FieldInfo fi) => this._fi = fi;

    public object Get(object component) => this._fi.GetValue(component);

    public void Set(object component, object value) => this._fi.SetValue(component, value);
  }

  private class PropertyDescriptorAccessor : Json.IMemberAccessor
  {
    private readonly PropertyDescriptor _pd;

    public PropertyDescriptorAccessor(PropertyDescriptor pd) => this._pd = pd;

    public object Get(object component) => this._pd.GetValue(component);

    public void Set(object component, object value)
    {
      if (this._pd.IsReadOnly)
        return;
      this._pd.SetValue(component, value);
    }
  }

  private delegate TResult JFunc<T, TResult>(T arg);

  private delegate void JAction<T1, T2>(T1 arg1, T2 arg2);

  private class PropertyInfoAccessor<TComponent, TMember> : Json.IMemberAccessor
  {
    private readonly Json.JFunc<TComponent, TMember> _get;
    private readonly Json.JAction<TComponent, TMember> _set;

    public PropertyInfoAccessor(PropertyInfo pi)
    {
      MethodInfo getMethod = pi.GetGetMethod();
      if (getMethod != (MethodInfo) null)
        this._get = (Json.JFunc<TComponent, TMember>) Delegate.CreateDelegate(typeof (Json.JFunc<TComponent, TMember>), getMethod);
      MethodInfo setMethod = pi.GetSetMethod();
      if (!(setMethod != (MethodInfo) null))
        return;
      this._set = (Json.JAction<TComponent, TMember>) Delegate.CreateDelegate(typeof (Json.JAction<TComponent, TMember>), setMethod);
    }

    public object Get(object component) => this._get == null ? (object) null : (object) this._get((TComponent) component);

    public void Set(object component, object value)
    {
      if (this._set == null)
        return;
      this._set((TComponent) component, (TMember) value);
    }
  }

  private static class Conversions
  {
    private static readonly char[] _enumSeparators = new char[5]
    {
      ',',
      ';',
      '+',
      '|',
      ' '
    };
    private static readonly string[] _dateFormatsUtc = new string[3]
    {
      "yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'",
      "yyyy'-'MM'-'dd'T'HH':'mm'Z'",
      "yyyyMMdd'T'HH':'mm':'ss'Z'"
    };

    private static bool IsValid(DateTime dt) => dt != DateTime.MinValue && dt != DateTime.MaxValue && dt.Kind != 0;

    public static T ChangeType<T>(object input, T defaultValue = null, IFormatProvider provider = null)
    {
      T obj;
      return !Json.Conversions.TryChangeType<T>(input, provider, out obj) ? defaultValue : obj;
    }

    public static bool TryChangeType<T>(object input, out T value) => Json.Conversions.TryChangeType<T>(input, (IFormatProvider) null, out value);

    public static bool TryChangeType<T>(object input, IFormatProvider provider, out T value)
    {
      object obj;
      if (!Json.Conversions.TryChangeType(input, typeof (T), provider, out obj))
      {
        value = default (T);
        return false;
      }
      value = (T) obj;
      return true;
    }

    public static object ChangeType(
      object input,
      Type conversionType,
      object defaultValue = null,
      IFormatProvider provider = null)
    {
      object obj1;
      if (Json.Conversions.TryChangeType(input, conversionType, provider, out obj1))
        return obj1;
      object obj2;
      if (Json.Conversions.TryChangeType(defaultValue, conversionType, provider, out obj2))
        return obj2;
      return Json.Conversions.IsReallyValueType(conversionType) ? Activator.CreateInstance(conversionType) : (object) null;
    }

    public static bool TryChangeType(object input, Type conversionType, out object value) => Json.Conversions.TryChangeType(input, conversionType, (IFormatProvider) null, out value);

    public static bool TryChangeType(
      object input,
      Type conversionType,
      IFormatProvider provider,
      out object value)
    {
      if (conversionType == (Type) null)
        throw new ArgumentNullException(nameof (conversionType));
      if (conversionType == typeof (object))
      {
        value = input;
        return true;
      }
      if (Json.Conversions.IsNullable(conversionType))
      {
        if (input == null)
        {
          value = (object) null;
          return true;
        }
        Type genericArgument = conversionType.GetGenericArguments()[0];
        object obj;
        if (Json.Conversions.TryChangeType(input, genericArgument, provider, out obj))
        {
          Type type = typeof (Nullable<>).MakeGenericType(genericArgument);
          value = Activator.CreateInstance(type, obj);
          return true;
        }
        value = (object) null;
        return false;
      }
      value = Json.Conversions.IsReallyValueType(conversionType) ? Activator.CreateInstance(conversionType) : (object) null;
      if (input == null)
        return !Json.Conversions.IsReallyValueType(conversionType);
      Type type1 = input.GetType();
      if (conversionType.IsAssignableFrom(type1))
      {
        value = input;
        return true;
      }
      if (conversionType.IsEnum)
        return Json.Conversions.EnumTryParse(conversionType, input, out value);
      if (type1.IsEnum)
      {
        TypeCode typeCode = Type.GetTypeCode(type1);
        if (conversionType == typeof (int))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (int) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (int) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (int) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (int) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (int) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (int) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (int) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (short))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (short) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (short) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (short) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (short) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (short) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (short) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (short) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (long))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (long) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (long) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (long) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (long) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (long) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (long) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (long) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (uint))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (uint) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (uint) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (uint) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (uint) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (uint) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (uint) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (uint) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (ushort))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (ushort) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (ushort) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (ushort) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (ushort) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (ushort) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (ushort) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (ushort) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (ulong))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (ulong) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (ulong) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (ulong) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (ulong) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (ulong) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (ulong) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (ulong) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (byte))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (byte) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (byte) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (byte) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (byte) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (byte) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (byte) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (byte) (ulong) input;
              return true;
            default:
              return false;
          }
        }
        else if (conversionType == typeof (sbyte))
        {
          switch (typeCode)
          {
            case TypeCode.SByte:
              value = (object) (sbyte) input;
              return true;
            case TypeCode.Byte:
              value = (object) (sbyte) (byte) input;
              return true;
            case TypeCode.Int16:
              value = (object) (sbyte) (short) input;
              return true;
            case TypeCode.UInt16:
              value = (object) (sbyte) (ushort) input;
              return true;
            case TypeCode.Int32:
              value = (object) (sbyte) (int) input;
              return true;
            case TypeCode.UInt32:
              value = (object) (sbyte) (uint) input;
              return true;
            case TypeCode.Int64:
              value = (object) (sbyte) (long) input;
              return true;
            case TypeCode.UInt64:
              value = (object) (sbyte) (ulong) input;
              return true;
            default:
              return false;
          }
        }
      }
      if (conversionType == typeof (Guid))
      {
        string input1 = string.Format(provider, "{0}", new object[1]
        {
          input
        }).Nullify();
        Guid result;
        if (input1 == null || !Guid.TryParse(input1, out result))
          return false;
        value = (object) result;
        return true;
      }
      if (conversionType == typeof (Uri))
      {
        string uriString = string.Format(provider, "{0}", new object[1]
        {
          input
        }).Nullify();
        Uri result;
        if (uriString == null || !Uri.TryCreate(uriString, UriKind.RelativeOrAbsolute, out result))
          return false;
        value = (object) result;
        return true;
      }
      if (conversionType == typeof (IntPtr))
      {
        if (IntPtr.Size == 8)
        {
          long num;
          if (Json.Conversions.TryChangeType<long>(input, provider, out num))
          {
            value = (object) new IntPtr(num);
            return true;
          }
        }
        else
        {
          int num;
          if (Json.Conversions.TryChangeType<int>(input, provider, out num))
          {
            value = (object) new IntPtr(num);
            return true;
          }
        }
        return false;
      }
      if (conversionType == typeof (int))
      {
        if (type1 == typeof (uint))
        {
          value = (object) (int) (uint) input;
          return true;
        }
        if (type1 == typeof (ulong))
        {
          value = (object) (int) (ulong) input;
          return true;
        }
        if (type1 == typeof (ushort))
        {
          value = (object) (int) (ushort) input;
          return true;
        }
        if (type1 == typeof (byte))
        {
          value = (object) (int) (byte) input;
          return true;
        }
      }
      if (conversionType == typeof (long))
      {
        if (type1 == typeof (uint))
        {
          value = (object) (long) (uint) input;
          return true;
        }
        if (type1 == typeof (ulong))
        {
          value = (object) (long) (ulong) input;
          return true;
        }
        if (type1 == typeof (ushort))
        {
          value = (object) (long) (ushort) input;
          return true;
        }
        if (type1 == typeof (byte))
        {
          value = (object) (long) (byte) input;
          return true;
        }
        if (type1 == typeof (TimeSpan))
        {
          value = (object) ((TimeSpan) input).Ticks;
          return true;
        }
      }
      if (conversionType == typeof (short))
      {
        if (type1 == typeof (uint))
        {
          value = (object) (short) (uint) input;
          return true;
        }
        if (type1 == typeof (ulong))
        {
          value = (object) (short) (ulong) input;
          return true;
        }
        if (type1 == typeof (ushort))
        {
          value = (object) (short) (ushort) input;
          return true;
        }
        if (type1 == typeof (byte))
        {
          value = (object) (short) (byte) input;
          return true;
        }
      }
      if (conversionType == typeof (sbyte))
      {
        if (type1 == typeof (uint))
        {
          value = (object) (sbyte) (uint) input;
          return true;
        }
        if (type1 == typeof (ulong))
        {
          value = (object) (sbyte) (ulong) input;
          return true;
        }
        if (type1 == typeof (ushort))
        {
          value = (object) (sbyte) (ushort) input;
          return true;
        }
        if (type1 == typeof (byte))
        {
          value = (object) (sbyte) (byte) input;
          return true;
        }
      }
      if (conversionType == typeof (uint))
      {
        if (type1 == typeof (int))
        {
          value = (object) (uint) (int) input;
          return true;
        }
        if (type1 == typeof (long))
        {
          value = (object) (uint) (long) input;
          return true;
        }
        if (type1 == typeof (short))
        {
          value = (object) (uint) (short) input;
          return true;
        }
        if (type1 == typeof (sbyte))
        {
          value = (object) (uint) (sbyte) input;
          return true;
        }
      }
      if (conversionType == typeof (ulong))
      {
        if (type1 == typeof (int))
        {
          value = (object) (ulong) (int) input;
          return true;
        }
        if (type1 == typeof (long))
        {
          value = (object) (ulong) (long) input;
          return true;
        }
        if (type1 == typeof (short))
        {
          value = (object) (ulong) (short) input;
          return true;
        }
        if (type1 == typeof (sbyte))
        {
          value = (object) (ulong) (sbyte) input;
          return true;
        }
      }
      if (conversionType == typeof (ushort))
      {
        if (type1 == typeof (int))
        {
          value = (object) (ushort) (int) input;
          return true;
        }
        if (type1 == typeof (long))
        {
          value = (object) (ushort) (long) input;
          return true;
        }
        if (type1 == typeof (short))
        {
          value = (object) (ushort) (short) input;
          return true;
        }
        if (type1 == typeof (sbyte))
        {
          value = (object) (ushort) (sbyte) input;
          return true;
        }
      }
      if (conversionType == typeof (byte))
      {
        if (type1 == typeof (int))
        {
          value = (object) (byte) (int) input;
          return true;
        }
        if (type1 == typeof (long))
        {
          value = (object) (byte) (long) input;
          return true;
        }
        if (type1 == typeof (short))
        {
          value = (object) (byte) (short) input;
          return true;
        }
        if (type1 == typeof (sbyte))
        {
          value = (object) (byte) (sbyte) input;
          return true;
        }
      }
      if (conversionType == typeof (DateTime))
      {
        if (type1 == typeof (long))
        {
          value = (object) new DateTime((long) input, DateTimeKind.Utc);
          return true;
        }
        if (type1 == typeof (DateTimeOffset))
        {
          value = (object) ((DateTimeOffset) input).DateTime;
          return true;
        }
      }
      if (conversionType == typeof (DateTimeOffset))
      {
        if (type1 == typeof (long))
        {
          value = (object) new DateTimeOffset(new DateTime((long) input, DateTimeKind.Utc));
          return true;
        }
        if (type1 == typeof (DateTime) && Json.Conversions.IsValid((DateTime) input))
        {
          value = (object) new DateTimeOffset((DateTime) input);
          return true;
        }
      }
      if (conversionType == typeof (TimeSpan))
      {
        if (type1 == typeof (long))
        {
          value = (object) new TimeSpan((long) input);
          return true;
        }
        if (type1 == typeof (DateTime))
        {
          value = (object) ((DateTime) value).TimeOfDay;
          return true;
        }
        if (type1 == typeof (DateTimeOffset))
        {
          value = (object) ((DateTimeOffset) value).TimeOfDay;
          return true;
        }
        string input2;
        TimeSpan result;
        if (Json.Conversions.TryChangeType<string>(input, provider, out input2) && TimeSpan.TryParse(input2, provider, out result))
        {
          value = (object) result;
          return true;
        }
      }
      Type elementType;
      bool flag1 = Json.Conversions.IsGenericList(conversionType, out elementType);
      if (conversionType.IsArray | flag1 && input is IEnumerable enumerable)
      {
        if (!flag1)
          elementType = conversionType.GetElementType();
        IList instance = (IList) Activator.CreateInstance(typeof (List<>).MakeGenericType(elementType));
        int num = 0;
        foreach (object input3 in enumerable)
        {
          ++num;
          Type conversionType1 = elementType;
          IFormatProvider provider1 = provider;
          object obj;
          ref object local = ref obj;
          if (Json.Conversions.TryChangeType(input3, conversionType1, provider1, out local))
            instance.Add(obj);
        }
        if (num > 0 && instance.Count > 0)
        {
          value = !flag1 ? instance.GetType().GetMethod("ToArray").Invoke((object) instance, (object[]) null) : (object) instance;
          return true;
        }
      }
      if (conversionType == typeof (CultureInfo) || conversionType == typeof (IFormatProvider))
      {
        try
        {
          if (input is int culture)
          {
            value = (object) CultureInfo.GetCultureInfo(culture);
            return true;
          }
          string str = input?.ToString();
          if (str != null)
          {
            int result;
            if (int.TryParse(str, out result))
            {
              value = (object) CultureInfo.GetCultureInfo(result);
              return true;
            }
            value = (object) CultureInfo.GetCultureInfo(str);
            return true;
          }
        }
        catch
        {
        }
        return false;
      }
      if (conversionType == typeof (bool))
      {
        bool flag2 = true;
        if (flag2.Equals(input))
        {
          value = (object) true;
          return true;
        }
        flag2 = false;
        if (flag2.Equals(input))
        {
          value = (object) false;
          return true;
        }
        string str = string.Format(provider, "{0}", new object[1]
        {
          input
        }).Nullify();
        if (str == null)
          return false;
        bool result;
        if (bool.TryParse(str, out result))
        {
          value = (object) result;
          return true;
        }
        if (str.EqualsIgnoreCase("y") || str.EqualsIgnoreCase("yes"))
        {
          value = (object) true;
          return true;
        }
        if (str.EqualsIgnoreCase("n") || str.EqualsIgnoreCase("no"))
        {
          value = (object) false;
          return true;
        }
        long num;
        if (!Json.Conversions.TryChangeType<long>(input, out num))
          return false;
        value = (object) (num != 0L);
        return true;
      }
      if (isWellKnownConvertible())
      {
        if (input is IConvertible convertible)
        {
          try
          {
            value = convertible.ToType(conversionType, provider);
            return !(value is DateTime dt) || Json.Conversions.IsValid(dt);
          }
          catch
          {
          }
        }
      }
      if (input != null)
      {
        TypeConverter converter = TypeDescriptor.GetConverter(input);
        if (converter != null)
        {
          if (converter.CanConvertTo(conversionType))
          {
            try
            {
              value = converter.ConvertTo((ITypeDescriptorContext) null, provider as CultureInfo, input, conversionType);
              return true;
            }
            catch
            {
            }
          }
        }
      }
      TypeConverter converter1 = TypeDescriptor.GetConverter(conversionType);
      if (converter1 != null)
      {
        if (converter1.CanConvertTo(conversionType))
        {
          try
          {
            value = converter1.ConvertTo((ITypeDescriptorContext) null, provider as CultureInfo, input, conversionType);
            return true;
          }
          catch
          {
          }
        }
        if (converter1.CanConvertFrom(type1))
        {
          try
          {
            value = converter1.ConvertFrom((ITypeDescriptorContext) null, provider as CultureInfo, input);
            return true;
          }
          catch
          {
          }
        }
      }
      if (!(conversionType == typeof (string)))
        return false;
      value = (object) string.Format(provider, "{0}", new object[1]
      {
        input
      });
      return true;

      bool isWellKnownConvertible() => conversionType == typeof (short) || conversionType == typeof (int) || conversionType == typeof (string) || conversionType == typeof (byte) || conversionType == typeof (char) || conversionType == typeof (DateTime) || conversionType == typeof (DBNull) || conversionType == typeof (Decimal) || conversionType == typeof (double) || conversionType.IsEnum || conversionType == typeof (short) || conversionType == typeof (int) || conversionType == typeof (long) || conversionType == typeof (sbyte) || conversionType == typeof (bool) || conversionType == typeof (float) || conversionType == typeof (ushort) || conversionType == typeof (uint) || conversionType == typeof (ulong);
    }

    public static ulong EnumToUInt64(object value)
    {
      if (value == null)
        throw new ArgumentNullException(nameof (value));
      switch (Convert.GetTypeCode(value))
      {
        case TypeCode.SByte:
        case TypeCode.Int16:
        case TypeCode.Int32:
        case TypeCode.Int64:
          return (ulong) Convert.ToInt64(value, (IFormatProvider) CultureInfo.InvariantCulture);
        case TypeCode.Byte:
        case TypeCode.UInt16:
        case TypeCode.UInt32:
        case TypeCode.UInt64:
          return Convert.ToUInt64(value, (IFormatProvider) CultureInfo.InvariantCulture);
        default:
          return Json.Conversions.ChangeType<ulong>(value, provider: ((IFormatProvider) CultureInfo.InvariantCulture));
      }
    }

    private static bool StringToEnum(
      Type type,
      string[] names,
      Array values,
      string input,
      out object value)
    {
      for (int index = 0; index < names.Length; ++index)
      {
        if (names[index].EqualsIgnoreCase(input))
        {
          value = values.GetValue(index);
          return true;
        }
      }
      for (int index = 0; index < values.GetLength(0); ++index)
      {
        object obj = values.GetValue(index);
        if (input.Length > 0 && input[0] == '-')
        {
          if (((long) Json.Conversions.EnumToUInt64(obj)).ToString().EqualsIgnoreCase(input))
          {
            value = obj;
            return true;
          }
        }
        else if (Json.Conversions.EnumToUInt64(obj).ToString().EqualsIgnoreCase(input))
        {
          value = obj;
          return true;
        }
      }
      if (char.IsDigit(input[0]) || input[0] == '-' || input[0] == '+')
      {
        object obj = Json.Conversions.EnumToObject(type, (object) input);
        if (obj == null)
        {
          value = Activator.CreateInstance(type);
          return false;
        }
        value = obj;
        return true;
      }
      value = Activator.CreateInstance(type);
      return false;
    }

    public static object EnumToObject(Type enumType, object value)
    {
      if (enumType == (Type) null)
        throw new ArgumentNullException(nameof (enumType));
      if (!enumType.IsEnum)
        throw new ArgumentException((string) null, nameof (enumType));
      if (value == null)
        throw new ArgumentNullException(nameof (value));
      Type underlyingType = Enum.GetUnderlyingType(enumType);
      if (underlyingType == typeof (long))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<long>(value));
      if (underlyingType == typeof (ulong))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<ulong>(value));
      if (underlyingType == typeof (int))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<int>(value));
      if (underlyingType == typeof (uint))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<uint>(value));
      if (underlyingType == typeof (short))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<short>(value));
      if (underlyingType == typeof (ushort))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<ushort>(value));
      if (underlyingType == typeof (byte))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<byte>(value));
      if (underlyingType == typeof (sbyte))
        return Enum.ToObject(enumType, Json.Conversions.ChangeType<sbyte>(value));
      throw new ArgumentException((string) null, nameof (enumType));
    }

    public static object ToEnum(string text, Type enumType)
    {
      if (enumType == (Type) null)
        throw new ArgumentNullException(nameof (enumType));
      object obj;
      Json.Conversions.EnumTryParse(enumType, (object) text, out obj);
      return obj;
    }

    public static bool EnumTryParse(Type type, object input, out object value)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      if (!type.IsEnum)
        throw new ArgumentException((string) null, nameof (type));
      if (input == null)
      {
        value = Activator.CreateInstance(type);
        return false;
      }
      string input1 = string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}", new object[1]
      {
        input
      }).Nullify();
      if (input1 == null)
      {
        value = Activator.CreateInstance(type);
        return false;
      }
      ulong result;
      if (input1.StartsWith("0x", StringComparison.OrdinalIgnoreCase) && ulong.TryParse(input1.Substring(2), NumberStyles.HexNumber, (IFormatProvider) null, out result))
      {
        value = Json.Conversions.ToEnum(result.ToString((IFormatProvider) CultureInfo.InvariantCulture), type);
        return true;
      }
      string[] names = Enum.GetNames(type);
      if (names.Length == 0)
      {
        value = Activator.CreateInstance(type);
        return false;
      }
      Array values = Enum.GetValues(type);
      if (!type.IsDefined(typeof (FlagsAttribute), true) && input1.IndexOfAny(Json.Conversions._enumSeparators) < 0)
        return Json.Conversions.StringToEnum(type, names, values, input1, out value);
      string[] strArray = input1.Split(Json.Conversions._enumSeparators, StringSplitOptions.RemoveEmptyEntries);
      if (strArray.Length == 0)
      {
        value = Activator.CreateInstance(type);
        return false;
      }
      ulong num1 = 0;
      foreach (string str in strArray)
      {
        string input2 = str.Nullify();
        if (input2 != null)
        {
          object obj;
          if (!Json.Conversions.StringToEnum(type, names, values, input2, out obj))
          {
            value = Activator.CreateInstance(type);
            return false;
          }
          ulong num2;
          switch (Convert.GetTypeCode(obj))
          {
            case TypeCode.SByte:
            case TypeCode.Int16:
            case TypeCode.Int32:
            case TypeCode.Int64:
              num2 = (ulong) Convert.ToInt64(obj, (IFormatProvider) CultureInfo.InvariantCulture);
              break;
            default:
              num2 = Convert.ToUInt64(obj, (IFormatProvider) CultureInfo.InvariantCulture);
              break;
          }
          num1 |= num2;
        }
      }
      value = Enum.ToObject(type, num1);
      return true;
    }

    public static bool IsGenericList(Type type, out Type elementType)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof (List<>))
      {
        elementType = type.GetGenericArguments()[0];
        return true;
      }
      elementType = (Type) null;
      return false;
    }

    private static bool IsReallyValueType(Type type)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      return type.IsValueType && !Json.Conversions.IsNullable(type);
    }

    public static bool IsNullable(Type type)
    {
      if (type == (Type) null)
        throw new ArgumentNullException(nameof (type));
      return type.IsGenericType && type.GetGenericTypeDefinition() == typeof (Nullable<>);
    }
  }
}
