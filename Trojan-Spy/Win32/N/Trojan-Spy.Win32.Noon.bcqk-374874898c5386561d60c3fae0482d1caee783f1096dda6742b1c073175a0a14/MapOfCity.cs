// Decompiled with JetBrains decompiler
// Type: mmxAH.MapOfCity
// Assembly: IAsyncLocalValue, Version=1.0.2.2, Culture=neutral, PublicKeyToken=null
// MVID: 5C4F3FBF-C751-4B18-BBEA-B1DDBC6F76B9
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcqk-374874898c5386561d60c3fae0482d1caee783f1096dda6742b1c073175a0a14.exe

using System.IO;
using System.Windows.Forms;

namespace mmxAH
{
  public class MapOfCity
  {
    private short StartIndex;
    private byte Count;
    private GameEngine en;
    private MapOfCity.MapRow[] rows;
    private byte rowCount;

    public MapOfCity(GameEngine eng)
    {
      this.en = eng;
      this.StartIndex = (short) this.en.locs.Count;
    }

    public bool FromText(TextFileParser prs, TextFileParser text)
    {
      if (!byte.TryParse(prs.GetToken(), out this.rowCount))
        return false;
      this.rows = new MapOfCity.MapRow[(int) this.rowCount];
      if (!byte.TryParse(prs.GetToken(), out this.Count))
        return false;
      for (int index = 0; index < (int) this.Count; ++index)
      {
        string upper1 = prs.GetToken().Trim().ToUpper();
        if (upper1 == null)
          return false;
        string upper2 = prs.GetToken().Trim().ToUpper();
        ArchemArea archemArea;
        if (upper1 == "STREET")
        {
          archemArea = (ArchemArea) new ArchemStreet(this.en, upper2);
          if (!this.ReadPossithionFromText(prs))
            return true;
        }
        else if (upper1 == "STAB")
          archemArea = (ArchemArea) new ArchemStableLoc(this.en, upper2);
        else if (upper1 == "UNSTAB")
        {
          archemArea = (ArchemArea) new ArchemUnstableLoc(this.en, upper2);
        }
        else
        {
          int num = (int) MessageBox.Show(" Unknow loc type: " + upper1);
          return false;
        }
        archemArea.SetLocIndex((short) this.en.locs.Count);
        this.en.locs.Add((Locathion) archemArea);
      }
      for (short index = 0; (int) index < (int) this.Count; ++index)
      {
        if (!this.en.locs[(int) index + (int) this.StartIndex].FromText(prs, text))
          return false;
      }
      return true;
    }

    public short GetDistricktStreetNumber(byte dis)
    {
      for (short index = 0; (int) index < (int) this.Count; ++index)
      {
        Locathion loc = this.en.locs[(int) index + (int) this.StartIndex];
        if (loc.GetLocType() == LocathionType.ArchamStreet && (int) ((ArchemArea) loc).GetDistrickt() == (int) dis)
          return (short) ((int) index + (int) this.StartIndex);
      }
      return -1;
    }

    public short GetNumberByCodeName(string cn)
    {
      cn = cn.ToUpper();
      for (short index = 0; (int) index < (int) this.Count; ++index)
      {
        if (this.en.locs[(int) index + (int) this.StartIndex].GetCodeName() == cn)
          return (short) ((int) index + (int) this.StartIndex);
      }
      return -1;
    }

    private bool ReadPossithionFromText(TextFileParser prs)
    {
      short count = (short) this.en.locs.Count;
      byte result;
      if (!byte.TryParse(prs.GetToken(), out result) || (int) result >= (int) this.rowCount)
        return false;
      string upper = prs.GetToken().Trim().ToUpper();
      if (!(upper == "L"))
      {
        if (!(upper == "M"))
        {
          if (!(upper == "R"))
          {
            if (!(upper == "LM"))
            {
              if (!(upper == "MR"))
                return false;
              this.rows[(int) result].Meddium = count;
              this.rows[(int) result].Right = -count;
            }
            else
            {
              this.rows[(int) result].Left = count;
              this.rows[(int) result].Meddium = -count;
            }
          }
          else
            this.rows[(int) result].Right = count;
        }
        else
          this.rows[(int) result].Meddium = count;
      }
      else
        this.rows[(int) result].Left = count;
      return true;
    }

    public void Print()
    {
      this.en.io.Set3LabelView();
      for (byte row = 0; (int) row < (int) this.rowCount; ++row)
      {
        if (this.rows[(int) row].Left != (short) 0)
          ((ArchemStreet) this.en.locs[(int) this.rows[(int) row].Left]).PrintDistrickt((byte) 1, row);
        if (this.rows[(int) row].Meddium > (short) 0)
          ((ArchemStreet) this.en.locs[(int) this.rows[(int) row].Meddium]).PrintDistrickt((byte) 2, row);
        if (this.rows[(int) row].Meddium < (short) 0)
          this.en.io.Print(((int) row + 1).ToString() + ". [ " + this.en.locs[(int) -this.rows[(int) row].Meddium].GetTitle() + " ]", (byte) 16, true, label: (byte) 2);
        if (this.rows[(int) row].Right != (short) 0)
          ((ArchemStreet) this.en.locs[(int) this.rows[(int) row].Right]).PrintDistrickt((byte) 3, row);
        this.en.io.ArrengeLabels();
      }
    }

    public void ToBin(BinaryWriter wr)
    {
      wr.Write(this.Count);
      for (int startIndex = (int) this.StartIndex; startIndex < (int) this.StartIndex + (int) this.Count; ++startIndex)
        this.en.locs[startIndex].ToBin(wr);
      wr.Write(this.rowCount);
      foreach (MapOfCity.MapRow row in this.rows)
      {
        wr.Write(row.Left);
        wr.Write(row.Meddium);
        wr.Write(row.Right);
      }
    }

    public void FromBin(BinaryReader rd)
    {
      this.Count = rd.ReadByte();
      for (int startIndex = (int) this.StartIndex; startIndex < (int) this.StartIndex + (int) this.Count; ++startIndex)
      {
        LocathionType locathionType = (LocathionType) rd.ReadInt32();
        rd.BaseStream.Position -= 4L;
        Locathion locathion;
        switch (locathionType)
        {
          case LocathionType.ArchamStreet:
            locathion = (Locathion) new ArchemStreet(this.en, "AAA");
            break;
          case LocathionType.ArchamStable:
            locathion = (Locathion) new ArchemStableLoc(this.en, "AAA");
            break;
          case LocathionType.ArchamUnstable:
            locathion = (Locathion) new ArchemUnstableLoc(this.en, "AAA");
            break;
          default:
            locathion = (Locathion) new Litas(this.en);
            break;
        }
        locathion.SetLocIndex((short) this.en.locs.Count);
        locathion.FromBin(rd);
        this.en.locs.Add(locathion);
      }
      this.rowCount = rd.ReadByte();
      this.rows = new MapOfCity.MapRow[(int) this.rowCount];
      for (int index = 0; index < (int) this.rowCount; ++index)
      {
        this.rows[index].Left = rd.ReadInt16();
        this.rows[index].Meddium = rd.ReadInt16();
        this.rows[index].Right = rd.ReadInt16();
      }
    }

    private struct MapRow
    {
      public short Left;
      public short Meddium;
      public short Right;
    }
  }
}
