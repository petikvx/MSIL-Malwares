// Decompiled with JetBrains decompiler
// Type: RiskManagement.Rules
// Assembly: MemberAccessExcepti, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 46220647-D1CE-4792-A51F-9B328C1E60FB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.02-msil\Backdoor.MSIL.Crysan.dst-d95fbf8fa85f2534926c1be2d0a82ad2fc89b2ed31ad42155ca0b92b9d959ccf.exe

using SimpleJSON;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;

namespace RiskManagement
{
  public class Rules
  {
    public int SprintCount { get; private set; }

    public int MaxImpact { get; private set; }

    public Card[] Cards { get; private set; }

    public int InitialResources { get; private set; }

    public int NormalPlanningCount { get; private set; }

    public int NormalPlanningCost { get; private set; }

    public int OverPlanningCost { get; private set; }

    public int SprintsWonWithoutPlanning { get; private set; }

    public float[] RiskChances { get; private set; }

    public bool EconomicsAffectsAll { get; private set; }

    public int StayOnSprintMinDiff { get; private set; }

    public bool OnlyOneWinner { get; private set; }

    private Rules()
    {
    }

    public static Rules Deserialize(JSONNode json)
    {
      int asInt = json[\u003CModule\u003E.\u200C‪⁪‎‏‍‬‬‪‮‎‮⁯⁯‮⁫⁪‬‭⁫​⁭​‏⁯⁬⁪⁮⁮⁯‬‭‏‌‏‭⁪⁪‍‮<string>(274736484U)].AsInt;
      return new Rules()
      {
        SprintCount = json[\u003CModule\u003E.\u200B⁫⁯⁫⁪‏‪⁯⁬‏‍‮‭⁯‎⁬‍⁫⁮⁪‌‮‏‬⁮‭⁮⁯⁬‭‎‍‪​⁭‎‬⁮⁮‎‮<string>(2526912148U)].AsInt,
        MaxImpact = asInt,
        Cards = Rules.ParseDeck(json[\u003CModule\u003E.\u206C⁭⁭⁪‫⁮‭‍⁮‏⁬‫⁬‎⁯⁭⁬​⁯‌‮‪‫‎⁫⁪​‏‌⁮⁯​⁫‮‌⁮‍‫‪⁭‮<string>(2452894115U)], asInt),
        InitialResources = json[\u003CModule\u003E.\u200C​‏⁮‪⁪‍‍‎‎‌‎‎‫‌‬⁫⁮‮‌⁮‌‎⁭‮‌‌‬⁪⁬‭⁮‮‪⁭⁪‭‬‏‬‮<string>(1410890697U)].AsInt,
        NormalPlanningCount = json[\u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(2780976996U)].AsInt,
        NormalPlanningCost = json[\u003CModule\u003E.\u200C​‏⁮‪⁪‍‍‎‎‌‎‎‫‌‬⁫⁮‮‌⁮‌‎⁭‮‌‌‬⁪⁬‭⁮‮‪⁭⁪‭‬‏‬‮<string>(3449020420U)].AsInt,
        OverPlanningCost = json[\u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(3190362961U)].AsInt,
        SprintsWonWithoutPlanning = json[\u003CModule\u003E.\u200C​‏⁮‪⁪‍‍‎‎‌‎‎‫‌‬⁫⁮‮‌⁮‌‎⁭‮‌‌‬⁪⁬‭⁮‮‪⁭⁪‭‬‏‬‮<string>(3868838408U)].AsInt,
        RiskChances = Rules.ParseRiskChances(json[\u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(548863687U)]),
        EconomicsAffectsAll = json[\u003CModule\u003E.\u206C⁭⁭⁪‫⁮‭‍⁮‏⁬‫⁬‎⁯⁭⁬​⁯‌‮‪‫‎⁫⁪​‏‌⁮⁯​⁫‮‌⁮‍‫‪⁭‮<string>(201397138U)].AsBool,
        StayOnSprintMinDiff = json[\u003CModule\u003E.\u206C⁭⁭⁪‫⁮‭‍⁮‏⁬‫⁬‎⁯⁭⁬​⁯‌‮‪‫‎⁫⁪​‏‌⁮⁯​⁫‮‌⁮‍‫‪⁭‮<string>(2459610945U)].AsInt,
        OnlyOneWinner = json[\u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(3912219505U)].AsBool
      };
    }

    private static float[] ParseRiskChances(JSONNode json)
    {
      float[] riskChances = new float[json.Count];
label_1:
      int num1 = -436537170;
      int aIndex;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -910489651)) % 6U)
        {
          case 1:
            aIndex = 0;
            num1 = (int) num2 * 20866690 ^ -1107013324;
            continue;
          case 2:
            int num3;
            num1 = num3 = aIndex < riskChances.Length ? -642900590 : (num3 = -1140043745);
            continue;
          case 3:
            num1 = (int) num2 * -363461411 ^ -160288034;
            continue;
          case 4:
            goto label_1;
          case 5:
            riskChances[aIndex] = json[aIndex].AsFloat;
            ++aIndex;
            num1 = -913050051;
            continue;
          default:
            goto label_7;
        }
      }
label_7:
      return riskChances;
    }

    private static Card[] ParseDeck(JSONNode json, int maxImpact)
    {
      int count = json.Count;
      List<Card> cardList = new List<Card>();
      int aIndex1 = 0;
label_1:
      int num1 = 765675189;
      JSONNode jsonNode;
      int aIndex2;
      int num2;
      bool flag;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num1 ^ 1993745138)) % 13U)
        {
          case 0:
            ++aIndex1;
            num1 = (int) num3 * -1886500834 ^ 988966824;
            continue;
          case 1:
            jsonNode = json[aIndex1];
            num1 = 942676013;
            continue;
          case 2:
            cardList.Add(new Card()
            {
              Impact = flag ? -(maxImpact - aIndex2) : maxImpact * 2 - aIndex2,
              Type = aIndex1
            });
            ++num2;
            num1 = 899075367;
            continue;
          case 3:
            goto label_1;
          case 5:
            aIndex2 = 0;
            num1 = (int) num3 * -1931533339 ^ 1640432053;
            continue;
          case 6:
            num2 = 0;
            num1 = 899075367;
            continue;
          case 7:
            int num4;
            num1 = num4 = aIndex1 < count ? 150776201 : (num4 = 1144978316);
            continue;
          case 8:
            ++aIndex2;
            num1 = (int) num3 * -1876541133 ^ 260003924;
            continue;
          case 9:
            num1 = (int) num3 * -1994748557 ^ -1422503971;
            continue;
          case 10:
            int num5;
            num1 = num5 = num2 >= jsonNode[aIndex2].AsInt ? 406640396 : (num5 = 1026003126);
            continue;
          case 11:
            flag = aIndex2 < maxImpact;
            num1 = 834140384;
            continue;
          case 12:
            int num6;
            num1 = num6 = aIndex2 >= maxImpact * 2 ? 1877426890 : (num6 = 505260067);
            continue;
          default:
            goto label_14;
        }
      }
label_14:
      return cardList.ToArray();
    }

    public override string ToString() => Rules.\u200C⁬‏⁯‪‏⁭⁮​‎‫‬‌‎⁭⁫⁭‫‫‏⁭⁯⁪‮‍‌‍‮‌⁯‮‫‫⁭‌⁭⁯⁪⁮‫‮(\u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(2192207806U), new object[12]
    {
      (object) this.SprintCount,
      (object) this.MaxImpact,
      (object) this.CardsToString(),
      (object) this.InitialResources,
      (object) this.NormalPlanningCount,
      (object) this.NormalPlanningCost,
      (object) this.OverPlanningCost,
      (object) this.SprintsWonWithoutPlanning,
      (object) this.RiskChancesToString(),
      (object) this.EconomicsAffectsAll,
      (object) this.StayOnSprintMinDiff,
      (object) this.OnlyOneWinner
    });

    private string CardsToString()
    {
      string str1 = \u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(2905417062U);
      int num1 = 0;
label_1:
      int num2 = -468781659;
      Card[] cards;
      int index;
      Card card1;
      while (true)
      {
        uint num3;
        switch ((num3 = (uint) (num2 ^ -2007406476)) % 11U)
        {
          case 1:
            cards = this.Cards;
            index = 0;
            num2 = (int) num3 * -2146628983 ^ 1049049573;
            continue;
          case 2:
            string str2 = str1;
            Card card2 = card1;
            string str3 = card2 != null ? Rules.\u202B‬‪‫‫‏⁫‬‬‬‫‫⁯​‫‮⁭‪‭‮‬​​‪⁬‏⁫‫⁮‭‌⁬‭⁭‫‪‏‍⁭⁭‮((object) card2) : (string) null;
            string str4 = \u003CModule\u003E.\u202D​‎⁫‭‏​‬‍⁪‭‌‪⁭‫‮⁯‫‎‪‬‍‎‮‍​‫‌‬‫‌‭‫⁫⁮‎‎⁬⁯‎‮<string>(1250472425U);
            str1 = Rules.\u200B‏⁯‬⁬⁬‫‭⁭‪⁯‎​⁬⁮‬‫‬‪⁮⁬‫⁬‭⁬‫⁪⁪‫⁮⁪⁮‌⁮‏‮‮⁫⁮⁬‮(str2, str3, str4);
            num2 = -1338888617;
            continue;
          case 3:
            ++index;
            num2 = (int) num3 * -66499980 ^ -966440352;
            continue;
          case 4:
            str1 = Rules.\u206B‬‏‫⁯⁭⁪⁬​‫‎‬⁭‫⁫‌‫⁮‮⁪‮⁪‌‏‮⁪‮‪⁬‌⁭⁬‫⁯‪‮⁯⁬⁯‍‮(str1, \u003CModule\u003E.\u200C‪⁪‎‏‍‬‬‪‮‎‮⁯⁯‮⁫⁪‬‭⁫​⁭​‏⁯⁬⁪⁮⁮⁯‬‭‏‌‏‭⁪⁪‍‮<string>(168432939U));
            num2 = (int) num3 * 1207154127 ^ -1537215769;
            continue;
          case 5:
            int num4;
            num2 = num4 = index >= cards.Length ? -152244986 : (num4 = -504263829);
            continue;
          case 6:
            int num5 = num1 == card1.Type ? -1487278246 : (num5 = -298979734);
            num2 = num5 ^ (int) num3 * -229163633;
            continue;
          case 7:
            num1 = card1.Type;
            num2 = (int) num3 * 23338096 ^ -1160384802;
            continue;
          case 8:
            num2 = (int) num3 * 2075946647 ^ 850304196;
            continue;
          case 9:
            goto label_1;
          case 10:
            card1 = cards[index];
            num2 = -410547848;
            continue;
          default:
            goto label_12;
        }
      }
label_12:
      return Rules.\u206B‬‏‫⁯⁭⁪⁬​‫‎‬⁭‫⁫‌‫⁮‮⁪‮⁪‌‏‮⁪‮‪⁬‌⁭⁬‫⁯‪‮⁯⁬⁯‍‮(str1, \u003CModule\u003E.\u200B⁫⁯⁫⁪‏‪⁯⁬‏‍‮‭⁯‎⁬‍⁫⁮⁪‌‮‏‬⁮‭⁮⁯⁬‭‎‍‪​⁭‎‬⁮⁮‎‮<string>(2621115669U));
    }

    private string RiskChancesToString()
    {
      string str = Rules.\u206B‬‏‫⁯⁭⁪⁬​‫‎‬⁭‫⁫‌‫⁮‮⁪‮⁪‌‏‮⁪‮‪⁬‌⁭⁬‫⁯‪‮⁯⁬⁯‍‮(\u003CModule\u003E.\u206C⁭⁭⁪‫⁮‭‍⁮‏⁬‫⁬‎⁯⁭⁬​⁯‌‮‪‫‎⁫⁪​‏‌⁮⁯​⁫‮‌⁮‍‫‪⁭‮<string>(3140832742U), this.RiskChances[0].ToString((IFormatProvider) Rules.\u206A‌⁫⁬‍‍⁯⁫‌‎‏​​‭‏⁯⁪‏​‮‍‍‎‮‏‬⁭⁭⁮‭‏⁪‎‭⁫‏‏‫⁪⁪‮()));
label_1:
      int num1 = 2053672952;
      int index;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 55497610)) % 6U)
        {
          case 0:
            int num3;
            num1 = num3 = index < this.RiskChances.Length ? 634131531 : (num3 = 1669642861);
            continue;
          case 2:
            index = 1;
            num1 = (int) num2 * -1513002931 ^ -1642801916;
            continue;
          case 3:
            ++index;
            num1 = (int) num2 * -1320378516 ^ 846001410;
            continue;
          case 4:
            goto label_1;
          case 5:
            str = Rules.\u200B‏⁯‬⁬⁬‫‭⁭‪⁯‎​⁬⁮‬‫‬‪⁮⁬‫⁬‭⁬‫⁪⁪‫⁮⁪⁮‌⁮‏‮‮⁫⁮⁬‮(str, \u003CModule\u003E.\u200C​‏⁮‪⁪‍‍‎‎‌‎‎‫‌‬⁫⁮‮‌⁮‌‎⁭‮‌‌‬⁪⁬‭⁮‮‪⁭⁪‭‬‏‬‮<string>(4105143970U), this.RiskChances[index].ToString((IFormatProvider) Rules.\u206A‌⁫⁬‍‍⁯⁫‌‎‏​​‭‏⁯⁪‏​‮‍‍‎‮‏‬⁭⁭⁮‭‏⁪‎‭⁫‏‏‫⁪⁪‮()));
            num1 = 1583289123;
            continue;
          default:
            goto label_7;
        }
      }
label_7:
      return Rules.\u206B‬‏‫⁯⁭⁪⁬​‫‎‬⁭‫⁫‌‫⁮‮⁪‮⁪‌‏‮⁪‮‪⁬‌⁭⁬‫⁯‪‮⁯⁬⁯‍‮(str, \u003CModule\u003E.\u200B⁫⁯⁫⁪‏‪⁯⁬‏‍‮‭⁯‎⁬‍⁫⁮⁪‌‮‏‬⁮‭⁮⁯⁬‭‎‍‪​⁭‎‬⁮⁮‎‮<string>(492422062U));
    }

    static string \u200C⁬‏⁯‪‏⁭⁮​‎‫‬‌‎⁭⁫⁭‫‫‏⁭⁯⁪‮‍‌‍‮‌⁯‮‫‫⁭‌⁭⁯⁪⁮‫‮([In] string obj0, [In] object[] obj1) => string.Format(obj0, obj1);

    static string \u206B‬‏‫⁯⁭⁪⁬​‫‎‬⁭‫⁫‌‫⁮‮⁪‮⁪‌‏‮⁪‮‪⁬‌⁭⁬‫⁯‪‮⁯⁬⁯‍‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static string \u202B‬‪‫‫‏⁫‬‬‬‫‫⁯​‫‮⁭‪‭‮‬​​‪⁬‏⁫‫⁮‭‌⁬‭⁭‫‪‏‍⁭⁭‮([In] object obj0) => obj0.ToString();

    static string \u200B‏⁯‬⁬⁬‫‭⁭‪⁯‎​⁬⁮‬‫‬‪⁮⁬‫⁬‭⁬‫⁪⁪‫⁮⁪⁮‌⁮‏‮‮⁫⁮⁬‮(
      [In] string obj0,
      [In] string obj1,
      [In] string obj2)
    {
      return obj0 + obj1 + obj2;
    }

    static CultureInfo \u206A‌⁫⁬‍‍⁯⁫‌‎‏​​‭‏⁯⁪‏​‮‍‍‎‮‏‬⁭⁭⁮‭‏⁪‎‭⁫‏‏‫⁪⁪‮() => CultureInfo.InvariantCulture;
  }
}
