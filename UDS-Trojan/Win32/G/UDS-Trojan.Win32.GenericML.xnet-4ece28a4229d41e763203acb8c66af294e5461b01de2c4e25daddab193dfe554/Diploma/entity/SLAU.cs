// Decompiled with JetBrains decompiler
// Type: Diploma.entity.SLAU
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using System;
using System.Collections.Generic;

namespace Diploma.entity
{
  public class SLAU
  {
    private Vector b;
    private Matrix A;
    private Vector x;
    private Stack<int> logChanges;
    private int dim;
    private double eps;

    public SLAU(double[,] massA, double[] massb, double epsilon)
    {
      this.eps = epsilon;
      this.dim = massb.Length;
      this.A = new Matrix(massA);
      this.b = new Vector(massb);
      this.x = new Vector(this.dim);
      this.logChanges = new Stack<int>();
      if (this.dim * this.dim != massA.Length)
        throw new Exception("try to solve different dimension!");
    }

    public SLAU(Matrix A, Vector b, double epsilon)
    {
      this.eps = epsilon;
      this.dim = (int) A.length;
      this.A = new Matrix(A);
      this.b = new Vector(b);
      this.x = new Vector(this.dim);
      this.logChanges = new Stack<int>();
      if (this.dim != (int) A.length)
        throw new Exception("try to solve different dimension!");
    }

    public Vector getResult()
    {
      this.solve();
      if (this.checkResult())
        return this.x;
      Console.WriteLine("");
      Console.ReadKey();
      Environment.Exit(1);
      return (Vector) null;
    }

    private bool checkResult()
    {
      bool flag = true;
      for (int index = 0; index < this.dim; ++index)
      {
        double num = this.x[index];
        if (false)
          flag = false;
      }
      return flag;
    }

    private void solve()
    {
      for (int index1 = 0; index1 < this.dim; ++index1)
      {
        this.findMax(index1, index1);
        for (int index2 = index1 + 1; index2 < this.dim; ++index2)
        {
          double num = this.A[index2, index1] / this.A[index1, index1];
          for (int j = index1; j < this.dim; ++j)
            this.A[index2, j] -= num * this.A[index1, j];
          this.b[index2] -= num * this.b[index1];
        }
      }
      for (int index3 = this.dim - 1; index3 > -1; --index3)
      {
        if (index3 == this.dim - 1)
        {
          this.x[index3] = this.b[index3] / this.A[index3, index3];
        }
        else
        {
          double num = 0.0;
          for (int index4 = this.dim - 1; index4 > index3; --index4)
            num += this.x[index4] * this.A[index3, index4];
          this.x[index3] = (this.b[index3] - num) / this.A[index3, index3];
        }
      }
      int index = this.dim - 1;
      foreach (int logChange in this.logChanges)
      {
        if (logChange != -1)
        {
          double num = this.x[index];
          this.x[index] = this.x[logChange];
          this.x[logChange] = num;
        }
        --index;
      }
    }

    private void findMax(int cur_i, int cur_j)
    {
      int num1 = cur_i;
      int num2 = cur_j;
      for (int i = cur_i; i < this.dim; ++i)
      {
        for (int j = cur_j; j < this.dim; ++j)
        {
          if (Math.Abs(this.A[i, j]) > Math.Abs(this.A[num1, num2]))
          {
            num1 = i;
            num2 = j;
          }
        }
      }
      if (cur_i == num1)
      {
        if (cur_j == num2)
        {
          this.logChanges.Push(-1);
        }
        else
        {
          this.changeTab(cur_j, num2);
          this.logChanges.Push(num2);
        }
      }
      else
      {
        this.changeRow(cur_i, num1);
        this.changeTab(cur_j, num2);
        this.logChanges.Push(num2);
      }
    }

    private void changeRow(int up_i, int down_i)
    {
      double num1 = this.b[up_i];
      this.b[up_i] = this.b[down_i];
      this.b[down_i] = num1;
      for (int j = 0; j < this.dim; ++j)
      {
        double num2 = this.A[up_i, j];
        this.A[up_i, j] = this.A[down_i, j];
        this.A[down_i, j] = num2;
      }
    }

    private void changeTab(int left_j, int right_j)
    {
      for (int i = 0; i < this.dim; ++i)
      {
        double num = this.A[i, left_j];
        this.A[i, left_j] = this.A[i, right_j];
        this.A[i, right_j] = num;
      }
    }

    public string ToString(int tabAmount)
    {
      try
      {
        string str1 = "";
        for (int index = 0; index < tabAmount + 1; ++index)
          str1 += "\t";
        string str2 = "";
        for (int index = 0; index < this.dim; ++index)
        {
          string str3 = str2 + str1;
          for (int j = 0; j < this.dim; ++j)
          {
            str3 += string.Format("{0,20:0.00000000}   ", (object) this.A[index, j]);
            if (j == this.dim - 1)
              str3 += string.Format("|{0,15:0.00000000}", (object) this.b[index]);
          }
          str2 = str3 + "\n";
        }
        return str2;
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty some massive!");
        return (string) null;
      }
    }

    public void print()
    {
      try
      {
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty some massive!");
      }
    }
  }
}
