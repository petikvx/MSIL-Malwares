// Decompiled with JetBrains decompiler
// Type: RagnarokHUD.ProcessMemoryReader
// Assembly: BinaryAssem, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C3D41CFC-8277-4BEE-9AD4-AC67F2756AFC
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-5ba70e2cf6910636ffaf66657996ddfd7bdec1d21ac89015a4935a31825106ae.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace RagnarokHUD
{
  public class ProcessMemoryReader : IDisposable
  {
    private Process process;
    private IntPtr hProcess;

    public IntPtr BaseAddress => this.process.MainModule.BaseAddress;

    public ProcessMemoryReader(Process process) => this.OpenProcess(process);

    public ProcessMemoryReader(string processName) => this.OpenProcess(ProcessMemoryReader.GetProcessByName(processName));

    ~ProcessMemoryReader()
    {
      if (this.process != null)
      {
        this.process.Close();
        this.process.Dispose();
      }
      this.hProcess = IntPtr.Zero;
    }

    private void OpenProcess(Process _process)
    {
      this.process = _process;
      this.hProcess = _process.Handle;
    }

    public static Process GetProcessByName(string processName)
    {
      Process[] processesByName = Process.GetProcessesByName(processName);
      return processesByName.Length != 0 ? processesByName[0] : throw new Exception(string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0} isn't running!", new object[1]
      {
        (object) processName
      }));
    }

    public byte[] Read(IntPtr offset, int length)
    {
      byte[] lpBuffer = new byte[length];
      WinApi.ReadProcessMemory(this.hProcess, offset, lpBuffer, new IntPtr(length), IntPtr.Zero);
      return lpBuffer;
    }

    public string ReadCString(IntPtr offset, int maxLen) => Encoding.UTF8.GetString(((IEnumerable<byte>) this.Read(offset, maxLen)).TakeWhile<byte>((Func<byte, bool>) (ret => ret > (byte) 0)).ToArray<byte>());

    public T Read<T>(IntPtr offset) where T : struct
    {
      byte[] lpBuffer = new byte[Marshal.SizeOf(typeof (T))];
      WinApi.ReadProcessMemory(this.hProcess, offset, lpBuffer, new IntPtr(lpBuffer.Length), IntPtr.Zero);
      GCHandle gcHandle = GCHandle.Alloc((object) lpBuffer, GCHandleType.Pinned);
      T structure = (T) Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), typeof (T));
      gcHandle.Free();
      return structure;
    }

    public void Dispose()
    {
      this.process.Close();
      this.process.Dispose();
      GC.SuppressFinalize((object) this);
    }
  }
}
