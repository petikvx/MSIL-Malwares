// Decompiled with JetBrains decompiler
// Type: TemporalToolkit.TemporalExpressions.TEHour
// Assembly: AssertFilt, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: D82097A6-A4CE-4A4A-9933-E78378BA7CC6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.05\Backdoor.MSIL.SpyGate.amea-62dfbde9c630c2de686534eccbc9ef292733b1781d867bdf9a0be9db3072eac3.exe

using System;

namespace TemporalToolkit.TemporalExpressions
{
  public class TEHour : TemporalExpression
  {
    public int Start { get; set; }

    public int? End { get; set; }

    public TEHour(int hour)
    {
      this.Start = hour;
      this.End = new int?();
    }

    public TEHour(int startHour, int endHour)
    {
label_1:
      int num1 = 1336865636;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ 1380886599)) % 6U)
        {
          case 0:
            num1 = (int) num2 * -1956059174 ^ 1809273555;
            continue;
          case 1:
            num1 = (int) num2 * -1932847724 ^ 1991943548;
            continue;
          case 2:
            this.End = new int?(endHour);
            num1 = (int) num2 * 268081011 ^ -77991665;
            continue;
          case 3:
            this.Start = startHour;
            num1 = (int) num2 * 1073530181 ^ 1211868136;
            continue;
          case 4:
            goto label_3;
          case 5:
            goto label_1;
          default:
            goto label_8;
        }
      }
label_3:
      return;
label_8:;
    }

    public override bool Includes(DateTime aDate)
    {
      int? end = this.End;
label_1:
      int num1 = -1992826052;
      bool flag1;
      while (true)
      {
        uint num2;
        bool hasValue;
        bool flag2;
        int num3;
        int num4;
        switch ((num2 = (uint) (num1 ^ -1613313303)) % 13U)
        {
          case 0:
            flag2 = this.Start == aDate.Hour;
            num1 = -45165246;
            continue;
          case 1:
            int hour1 = aDate.Hour;
            end = this.End;
            int num5 = end.Value;
            num3 = hour1 <= num5 ? 1 : 0;
            goto label_11;
          case 2:
            num1 = (int) num2 * 2125422334 ^ -1037647059;
            continue;
          case 3:
            flag1 = flag2;
            num1 = -192078882;
            continue;
          case 4:
            end = this.End;
            int num6 = end.Value > this.Start ? 1634990051 : (num6 = 2095513860);
            num1 = num6 ^ (int) num2 * -725809689;
            continue;
          case 5:
            hasValue = end.HasValue;
            num1 = (int) num2 * 636244161 ^ 426325714;
            continue;
          case 6:
            int hour2 = aDate.Hour;
            end = this.End;
            int num7 = end.Value;
            num4 = hour2 <= num7 ? 1 : 0;
            break;
          case 7:
            if (aDate.Hour < this.Start)
            {
              num1 = -2058025998;
              continue;
            }
            num4 = 1;
            break;
          case 8:
            if (aDate.Hour < this.Start)
            {
              num3 = 0;
              goto label_11;
            }
            else
            {
              num1 = (int) num2 * -582684568 ^ 2079135373;
              continue;
            }
          case 9:
            num1 = -45165246;
            continue;
          case 10:
            int num8 = !hasValue ? -393212697 : (num8 = -2073551006);
            num1 = num8 ^ (int) num2 * 1909412985;
            continue;
          case 12:
            goto label_1;
          default:
            goto label_20;
        }
        flag2 = num4 != 0;
        num1 = -809472012;
        continue;
label_11:
        flag2 = num3 != 0;
        num1 = -809472012;
      }
label_20:
      return flag1;
    }
  }
}
