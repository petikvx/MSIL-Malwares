// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLite3
// Assembly: sysrt, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F2102D52-57B0-4622-A1CB-9DE0B00E107F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\Trojan-Ransom.Win32.Blocker.hehh-e9e3600777f319c90d3c06bee4af8f501eba42a876d1d5ed7d3de045ff7cba31.exe

using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

namespace System.Data.SQLite
{
  internal class SQLite3 : SQLiteBase
  {
    protected SQLiteConnectionHandle _sql;
    protected string _fileName;
    protected bool _usePool;
    protected int _poolVersion;
    private bool _buildingSchema;
    protected SQLiteFunction[] _functionsArray;

    internal SQLite3(SQLiteDateFormats fmt)
      : base(fmt)
    {
    }

    protected override void Dispose(bool bDisposing)
    {
      if (!bDisposing)
        return;
      this.Close();
    }

    internal override void Close()
    {
      if (this._sql != null)
      {
        if (this._usePool)
        {
          SQLiteBase.ResetConnection(this._sql);
          SQLiteConnectionPool.Add(this._fileName, this._sql, this._poolVersion);
        }
        else
          this._sql.Dispose();
      }
      this._sql = (SQLiteConnectionHandle) null;
    }

    internal override void Cancel() => UnsafeNativeMethods.sqlite3_interrupt((IntPtr) this._sql);

    internal override string Version => SQLite3.SQLiteVersion;

    internal static string SQLiteVersion => SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_libversion(), -1);

    internal override bool AutoCommit => SQLiteBase.IsAutocommit(this._sql);

    internal override int Changes => UnsafeNativeMethods.sqlite3_changes((IntPtr) this._sql);

    internal override void Open(
      string strFilename,
      SQLiteOpenFlagsEnum flags,
      int maxPoolSize,
      bool usePool)
    {
      if (this._sql != null)
        return;
      this._usePool = usePool;
      if (usePool)
      {
        this._fileName = strFilename;
        this._sql = SQLiteConnectionPool.Remove(strFilename, maxPoolSize, out this._poolVersion);
      }
      if (this._sql == null)
      {
        IntPtr db;
        int errorCode = UnsafeNativeMethods.sqlite3_open_interop(SQLiteConvert.ToUTF8(strFilename), (int) flags, out db);
        if (errorCode > 0)
          throw new SQLiteException(errorCode, (string) null);
        this._sql = (SQLiteConnectionHandle) db;
      }
      this._functionsArray = SQLiteFunction.BindFunctions((SQLiteBase) this);
      this.SetTimeout(0);
    }

    internal override void ClearPool() => SQLiteConnectionPool.ClearPool(this._fileName);

    internal override void SetTimeout(int nTimeoutMS)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_busy_timeout((IntPtr) this._sql, nTimeoutMS);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override bool Step(SQLiteStatement stmt)
    {
      Random random = (Random) null;
      uint tickCount = (uint) Environment.TickCount;
      uint num = (uint) (stmt._command._commandTimeout * 1000);
      int errorCode1;
      while (true)
      {
        do
        {
          int errorCode2;
          do
          {
            errorCode2 = UnsafeNativeMethods.sqlite3_step((IntPtr) stmt._sqlite_stmt);
            switch (errorCode2)
            {
              case 100:
                return true;
              case 101:
                return false;
              default:
                continue;
            }
          }
          while (errorCode2 <= 0);
          errorCode1 = this.Reset(stmt);
          switch (errorCode1)
          {
            case 0:
              throw new SQLiteException(errorCode2, this.SQLiteLastError());
            case 5:
            case 6:
              continue;
            default:
              continue;
          }
        }
        while (stmt._command == null);
        if (random == null)
          random = new Random();
        if ((uint) Environment.TickCount - tickCount <= num)
          Thread.Sleep(random.Next(1, 150));
        else
          break;
      }
      throw new SQLiteException(errorCode1, this.SQLiteLastError());
    }

    internal override int Reset(SQLiteStatement stmt)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_reset_interop((IntPtr) stmt._sqlite_stmt);
      switch (errorCode)
      {
        case 5:
        case 6:
          return errorCode;
        case 17:
          using (SQLiteStatement sqLiteStatement = this.Prepare((SQLiteConnection) null, stmt._sqlStatement, (SQLiteStatement) null, (uint) (stmt._command._commandTimeout * 1000), out string _))
          {
            stmt._sqlite_stmt.Dispose();
            stmt._sqlite_stmt = sqLiteStatement._sqlite_stmt;
            sqLiteStatement._sqlite_stmt = (SQLiteStatementHandle) null;
            stmt.BindParameters();
          }
          return -1;
        default:
          if (errorCode > 0)
            throw new SQLiteException(errorCode, this.SQLiteLastError());
          return 0;
      }
    }

    internal override string SQLiteLastError() => SQLiteBase.SQLiteLastError(this._sql);

    internal override SQLiteStatement Prepare(
      SQLiteConnection cnn,
      string strSql,
      SQLiteStatement previous,
      uint timeoutMS,
      out string strRemain)
    {
      IntPtr stmt = IntPtr.Zero;
      IntPtr ptrRemain = IntPtr.Zero;
      int nRemain = 0;
      int errorCode = 17;
      int num1 = 0;
      byte[] utF8 = SQLiteConvert.ToUTF8(strSql);
      SQLiteStatement sqLiteStatement = (SQLiteStatement) null;
      Random random = (Random) null;
      uint tickCount = (uint) Environment.TickCount;
      GCHandle gcHandle = GCHandle.Alloc((object) utF8, GCHandleType.Pinned);
      IntPtr pSql = gcHandle.AddrOfPinnedObject();
      try
      {
        while ((errorCode == 17 || errorCode == 6 || errorCode == 5) && num1 < 3)
        {
          errorCode = UnsafeNativeMethods.sqlite3_prepare_interop((IntPtr) this._sql, pSql, utF8.Length - 1, out stmt, out ptrRemain, out nRemain);
          switch (errorCode)
          {
            case 1:
              if (string.Compare(this.SQLiteLastError(), "near \"TYPES\": syntax error", StringComparison.OrdinalIgnoreCase) == 0)
              {
                int num2 = strSql.IndexOf(';');
                if (num2 == -1)
                  num2 = strSql.Length - 1;
                string typedefs = strSql.Substring(0, num2 + 1);
                strSql = strSql.Substring(num2 + 1);
                strRemain = "";
                for (; sqLiteStatement == null && strSql.Length > 0; strSql = strRemain)
                  sqLiteStatement = this.Prepare(cnn, strSql, previous, timeoutMS, out strRemain);
                sqLiteStatement?.SetTypes(typedefs);
                return sqLiteStatement;
              }
              if (!this._buildingSchema && string.Compare(this.SQLiteLastError(), 0, "no such table: TEMP.SCHEMA", 0, 26, StringComparison.OrdinalIgnoreCase) == 0)
              {
                strRemain = "";
                this._buildingSchema = true;
                try
                {
                  if (((IServiceProvider) SQLiteFactory.Instance).GetService(typeof (ISQLiteSchemaExtensions)) is ISQLiteSchemaExtensions service)
                    service.BuildTempSchema(cnn);
                  for (; sqLiteStatement == null && strSql.Length > 0; strSql = strRemain)
                    sqLiteStatement = this.Prepare(cnn, strSql, previous, timeoutMS, out strRemain);
                  return sqLiteStatement;
                }
                finally
                {
                  this._buildingSchema = false;
                }
              }
              else
                continue;
            case 17:
              ++num1;
              continue;
            default:
              if (errorCode == 6 || errorCode == 5)
              {
                if (random == null)
                  random = new Random();
                if ((uint) Environment.TickCount - tickCount > timeoutMS)
                  throw new SQLiteException(errorCode, this.SQLiteLastError());
                Thread.Sleep(random.Next(1, 150));
                continue;
              }
              continue;
          }
        }
        if (errorCode > 0)
          throw new SQLiteException(errorCode, this.SQLiteLastError());
        strRemain = SQLiteConvert.UTF8ToString(ptrRemain, nRemain);
        if (stmt != IntPtr.Zero)
          sqLiteStatement = new SQLiteStatement((SQLiteBase) this, (SQLiteStatementHandle) stmt, strSql.Substring(0, strSql.Length - strRemain.Length), previous);
        return sqLiteStatement;
      }
      finally
      {
        gcHandle.Free();
      }
    }

    internal override void Bind_Double(SQLiteStatement stmt, int index, double value)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_bind_double((IntPtr) stmt._sqlite_stmt, index, value);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void Bind_Int32(SQLiteStatement stmt, int index, int value)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_bind_int((IntPtr) stmt._sqlite_stmt, index, value);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void Bind_Int64(SQLiteStatement stmt, int index, long value)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_bind_int64((IntPtr) stmt._sqlite_stmt, index, value);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void Bind_Text(SQLiteStatement stmt, int index, string value)
    {
      byte[] utF8 = SQLiteConvert.ToUTF8(value);
      int errorCode = UnsafeNativeMethods.sqlite3_bind_text((IntPtr) stmt._sqlite_stmt, index, utF8, utF8.Length - 1, (IntPtr) -1);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void Bind_DateTime(SQLiteStatement stmt, int index, DateTime dt)
    {
      byte[] utF8 = this.ToUTF8(dt);
      int errorCode = UnsafeNativeMethods.sqlite3_bind_text((IntPtr) stmt._sqlite_stmt, index, utF8, utF8.Length - 1, (IntPtr) -1);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void Bind_Blob(SQLiteStatement stmt, int index, byte[] blobData)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_bind_blob((IntPtr) stmt._sqlite_stmt, index, blobData, blobData.Length, (IntPtr) -1);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void Bind_Null(SQLiteStatement stmt, int index)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_bind_null((IntPtr) stmt._sqlite_stmt, index);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override int Bind_ParamCount(SQLiteStatement stmt) => UnsafeNativeMethods.sqlite3_bind_parameter_count((IntPtr) stmt._sqlite_stmt);

    internal override string Bind_ParamName(SQLiteStatement stmt, int index)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_bind_parameter_name_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override int Bind_ParamIndex(SQLiteStatement stmt, string paramName) => UnsafeNativeMethods.sqlite3_bind_parameter_index((IntPtr) stmt._sqlite_stmt, SQLiteConvert.ToUTF8(paramName));

    internal override int ColumnCount(SQLiteStatement stmt) => UnsafeNativeMethods.sqlite3_column_count((IntPtr) stmt._sqlite_stmt);

    internal override string ColumnName(SQLiteStatement stmt, int index)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_name_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override TypeAffinity ColumnAffinity(SQLiteStatement stmt, int index) => UnsafeNativeMethods.sqlite3_column_type((IntPtr) stmt._sqlite_stmt, index);

    internal override string ColumnType(
      SQLiteStatement stmt,
      int index,
      out TypeAffinity nAffinity)
    {
      int len;
      IntPtr nativestring = UnsafeNativeMethods.sqlite3_column_decltype_interop((IntPtr) stmt._sqlite_stmt, index, out len);
      nAffinity = this.ColumnAffinity(stmt, index);
      if (nativestring != IntPtr.Zero)
        return SQLiteConvert.UTF8ToString(nativestring, len);
      string[] typeDefinitions = stmt.TypeDefinitions;
      return typeDefinitions != null && index < typeDefinitions.Length && typeDefinitions[index] != null ? typeDefinitions[index] : string.Empty;
    }

    internal override int ColumnIndex(SQLiteStatement stmt, string columnName)
    {
      int num = this.ColumnCount(stmt);
      for (int index = 0; index < num; ++index)
      {
        if (string.Compare(columnName, this.ColumnName(stmt, index), StringComparison.OrdinalIgnoreCase) == 0)
          return index;
      }
      return -1;
    }

    internal override string ColumnOriginalName(SQLiteStatement stmt, int index)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_origin_name_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override string ColumnDatabaseName(SQLiteStatement stmt, int index)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_database_name_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override string ColumnTableName(SQLiteStatement stmt, int index)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_table_name_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override void ColumnMetaData(
      string dataBase,
      string table,
      string column,
      out string dataType,
      out string collateSequence,
      out bool notNull,
      out bool primaryKey,
      out bool autoIncrement)
    {
      IntPtr ptrDataType;
      IntPtr ptrCollSeq;
      int notNull1;
      int primaryKey1;
      int autoInc;
      int dtLen;
      int csLen;
      int errorCode = UnsafeNativeMethods.sqlite3_table_column_metadata_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(dataBase), SQLiteConvert.ToUTF8(table), SQLiteConvert.ToUTF8(column), out ptrDataType, out ptrCollSeq, out notNull1, out primaryKey1, out autoInc, out dtLen, out csLen);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
      dataType = SQLiteConvert.UTF8ToString(ptrDataType, dtLen);
      collateSequence = SQLiteConvert.UTF8ToString(ptrCollSeq, csLen);
      notNull = notNull1 == 1;
      primaryKey = primaryKey1 == 1;
      autoIncrement = autoInc == 1;
    }

    internal override double GetDouble(SQLiteStatement stmt, int index) => UnsafeNativeMethods.sqlite3_column_double((IntPtr) stmt._sqlite_stmt, index);

    internal override int GetInt32(SQLiteStatement stmt, int index) => UnsafeNativeMethods.sqlite3_column_int((IntPtr) stmt._sqlite_stmt, index);

    internal override long GetInt64(SQLiteStatement stmt, int index) => UnsafeNativeMethods.sqlite3_column_int64((IntPtr) stmt._sqlite_stmt, index);

    internal override string GetText(SQLiteStatement stmt, int index)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_text_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override DateTime GetDateTime(SQLiteStatement stmt, int index)
    {
      int len;
      return this.ToDateTime(UnsafeNativeMethods.sqlite3_column_text_interop((IntPtr) stmt._sqlite_stmt, index, out len), len);
    }

    internal override long GetBytes(
      SQLiteStatement stmt,
      int index,
      int nDataOffset,
      byte[] bDest,
      int nStart,
      int nLength)
    {
      int length = nLength;
      int bytes = UnsafeNativeMethods.sqlite3_column_bytes((IntPtr) stmt._sqlite_stmt, index);
      IntPtr num = UnsafeNativeMethods.sqlite3_column_blob((IntPtr) stmt._sqlite_stmt, index);
      if (bDest == null)
        return (long) bytes;
      if (length + nStart > bDest.Length)
        length = bDest.Length - nStart;
      if (length + nDataOffset > bytes)
        length = bytes - nDataOffset;
      if (length > 0)
        Marshal.Copy((IntPtr) (num.ToInt64() + (long) nDataOffset), bDest, nStart, length);
      else
        length = 0;
      return (long) length;
    }

    internal override long GetChars(
      SQLiteStatement stmt,
      int index,
      int nDataOffset,
      char[] bDest,
      int nStart,
      int nLength)
    {
      int count = nLength;
      string text = this.GetText(stmt, index);
      int length = text.Length;
      if (bDest == null)
        return (long) length;
      if (count + nStart > bDest.Length)
        count = bDest.Length - nStart;
      if (count + nDataOffset > length)
        count = length - nDataOffset;
      if (count > 0)
        text.CopyTo(nDataOffset, bDest, nStart, count);
      else
        count = 0;
      return (long) count;
    }

    internal override bool IsNull(SQLiteStatement stmt, int index) => this.ColumnAffinity(stmt, index) == TypeAffinity.Null;

    internal override int AggregateCount(IntPtr context) => UnsafeNativeMethods.sqlite3_aggregate_count(context);

    internal override void CreateFunction(
      string strFunction,
      int nArgs,
      bool needCollSeq,
      SQLiteCallback func,
      SQLiteCallback funcstep,
      SQLiteFinalCallback funcfinal)
    {
      int functionInterop = UnsafeNativeMethods.sqlite3_create_function_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(strFunction), nArgs, 4, IntPtr.Zero, func, funcstep, funcfinal, needCollSeq ? 1 : 0);
      if (functionInterop == 0)
        functionInterop = UnsafeNativeMethods.sqlite3_create_function_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(strFunction), nArgs, 1, IntPtr.Zero, func, funcstep, funcfinal, needCollSeq ? 1 : 0);
      if (functionInterop > 0)
        throw new SQLiteException(functionInterop, this.SQLiteLastError());
    }

    internal override void CreateCollation(
      string strCollation,
      SQLiteCollation func,
      SQLiteCollation func16)
    {
      int collation = UnsafeNativeMethods.sqlite3_create_collation((IntPtr) this._sql, SQLiteConvert.ToUTF8(strCollation), 2, IntPtr.Zero, func16);
      if (collation == 0)
        collation = UnsafeNativeMethods.sqlite3_create_collation((IntPtr) this._sql, SQLiteConvert.ToUTF8(strCollation), 1, IntPtr.Zero, func);
      if (collation > 0)
        throw new SQLiteException(collation, this.SQLiteLastError());
    }

    internal override int ContextCollateCompare(
      CollationEncodingEnum enc,
      IntPtr context,
      string s1,
      string s2)
    {
      Encoding encoding = (Encoding) null;
      switch (enc)
      {
        case CollationEncodingEnum.UTF8:
          encoding = Encoding.UTF8;
          break;
        case CollationEncodingEnum.UTF16LE:
          encoding = Encoding.Unicode;
          break;
        case CollationEncodingEnum.UTF16BE:
          encoding = Encoding.BigEndianUnicode;
          break;
      }
      byte[] bytes1 = encoding.GetBytes(s1);
      byte[] bytes2 = encoding.GetBytes(s2);
      return UnsafeNativeMethods.sqlite3_context_collcompare(context, bytes1, bytes1.Length, bytes2, bytes2.Length);
    }

    internal override int ContextCollateCompare(
      CollationEncodingEnum enc,
      IntPtr context,
      char[] c1,
      char[] c2)
    {
      Encoding encoding = (Encoding) null;
      switch (enc)
      {
        case CollationEncodingEnum.UTF8:
          encoding = Encoding.UTF8;
          break;
        case CollationEncodingEnum.UTF16LE:
          encoding = Encoding.Unicode;
          break;
        case CollationEncodingEnum.UTF16BE:
          encoding = Encoding.BigEndianUnicode;
          break;
      }
      byte[] bytes1 = encoding.GetBytes(c1);
      byte[] bytes2 = encoding.GetBytes(c2);
      return UnsafeNativeMethods.sqlite3_context_collcompare(context, bytes1, bytes1.Length, bytes2, bytes2.Length);
    }

    internal override CollationSequence GetCollationSequence(
      SQLiteFunction func,
      IntPtr context)
    {
      CollationSequence collationSequence = new CollationSequence();
      int type;
      int enc;
      int len;
      IntPtr nativestring = UnsafeNativeMethods.sqlite3_context_collseq(context, out type, out enc, out len);
      collationSequence.Name = SQLiteConvert.UTF8ToString(nativestring, len);
      collationSequence.Type = (CollationTypeEnum) type;
      collationSequence._func = func;
      collationSequence.Encoding = (CollationEncodingEnum) enc;
      return collationSequence;
    }

    internal override long GetParamValueBytes(
      IntPtr p,
      int nDataOffset,
      byte[] bDest,
      int nStart,
      int nLength)
    {
      int length = nLength;
      int paramValueBytes = UnsafeNativeMethods.sqlite3_value_bytes(p);
      IntPtr num = UnsafeNativeMethods.sqlite3_value_blob(p);
      if (bDest == null)
        return (long) paramValueBytes;
      if (length + nStart > bDest.Length)
        length = bDest.Length - nStart;
      if (length + nDataOffset > paramValueBytes)
        length = paramValueBytes - nDataOffset;
      if (length > 0)
        Marshal.Copy((IntPtr) (num.ToInt32() + nDataOffset), bDest, nStart, length);
      else
        length = 0;
      return (long) length;
    }

    internal override double GetParamValueDouble(IntPtr ptr) => UnsafeNativeMethods.sqlite3_value_double(ptr);

    internal override int GetParamValueInt32(IntPtr ptr) => UnsafeNativeMethods.sqlite3_value_int(ptr);

    internal override long GetParamValueInt64(IntPtr ptr) => UnsafeNativeMethods.sqlite3_value_int64(ptr);

    internal override string GetParamValueText(IntPtr ptr)
    {
      int len;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_value_text_interop(ptr, out len), len);
    }

    internal override TypeAffinity GetParamValueType(IntPtr ptr) => UnsafeNativeMethods.sqlite3_value_type(ptr);

    internal override void ReturnBlob(IntPtr context, byte[] value) => UnsafeNativeMethods.sqlite3_result_blob(context, value, value.Length, (IntPtr) -1);

    internal override void ReturnDouble(IntPtr context, double value) => UnsafeNativeMethods.sqlite3_result_double(context, value);

    internal override void ReturnError(IntPtr context, string value) => UnsafeNativeMethods.sqlite3_result_error(context, SQLiteConvert.ToUTF8(value), value.Length);

    internal override void ReturnInt32(IntPtr context, int value) => UnsafeNativeMethods.sqlite3_result_int(context, value);

    internal override void ReturnInt64(IntPtr context, long value) => UnsafeNativeMethods.sqlite3_result_int64(context, value);

    internal override void ReturnNull(IntPtr context) => UnsafeNativeMethods.sqlite3_result_null(context);

    internal override void ReturnText(IntPtr context, string value)
    {
      byte[] utF8 = SQLiteConvert.ToUTF8(value);
      UnsafeNativeMethods.sqlite3_result_text(context, SQLiteConvert.ToUTF8(value), utF8.Length - 1, (IntPtr) -1);
    }

    internal override IntPtr AggregateContext(IntPtr context) => UnsafeNativeMethods.sqlite3_aggregate_context(context, 1);

    internal override void SetPassword(byte[] passwordBytes)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_key((IntPtr) this._sql, passwordBytes, passwordBytes.Length);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void ChangePassword(byte[] newPasswordBytes)
    {
      int errorCode = UnsafeNativeMethods.sqlite3_rekey((IntPtr) this._sql, newPasswordBytes, newPasswordBytes == null ? 0 : newPasswordBytes.Length);
      if (errorCode > 0)
        throw new SQLiteException(errorCode, this.SQLiteLastError());
    }

    internal override void SetUpdateHook(SQLiteUpdateCallback func) => UnsafeNativeMethods.sqlite3_update_hook((IntPtr) this._sql, func, IntPtr.Zero);

    internal override void SetCommitHook(SQLiteCommitCallback func) => UnsafeNativeMethods.sqlite3_commit_hook((IntPtr) this._sql, func, IntPtr.Zero);

    internal override void SetRollbackHook(SQLiteRollbackCallback func) => UnsafeNativeMethods.sqlite3_rollback_hook((IntPtr) this._sql, func, IntPtr.Zero);

    internal override object GetValue(SQLiteStatement stmt, int index, SQLiteType typ)
    {
      if (this.IsNull(stmt, index))
        return (object) DBNull.Value;
      TypeAffinity affinity = typ.Affinity;
      Type type = (Type) null;
      if (typ.Type != DbType.Object)
      {
        type = SQLiteConvert.SQLiteTypeToType(typ);
        affinity = SQLiteConvert.TypeToAffinity(type);
      }
      switch (affinity)
      {
        case TypeAffinity.Int64:
          return (object) type == null ? (object) this.GetInt64(stmt, index) : Convert.ChangeType((object) this.GetInt64(stmt, index), type, (IFormatProvider) null);
        case TypeAffinity.Double:
          return (object) type == null ? (object) this.GetDouble(stmt, index) : Convert.ChangeType((object) this.GetDouble(stmt, index), type, (IFormatProvider) null);
        case TypeAffinity.Blob:
          if (typ.Type == DbType.Guid && typ.Affinity == TypeAffinity.Text)
            return (object) new Guid(this.GetText(stmt, index));
          int bytes = (int) this.GetBytes(stmt, index, 0, (byte[]) null, 0, 0);
          byte[] numArray = new byte[bytes];
          this.GetBytes(stmt, index, 0, numArray, 0, bytes);
          return typ.Type == DbType.Guid && bytes == 16 ? (object) new Guid(numArray) : (object) numArray;
        case TypeAffinity.DateTime:
          return (object) this.GetDateTime(stmt, index);
        default:
          return (object) this.GetText(stmt, index);
      }
    }

    internal override int GetCursorForTable(SQLiteStatement stmt, int db, int rootPage) => UnsafeNativeMethods.sqlite3_table_cursor((IntPtr) stmt._sqlite_stmt, db, rootPage);

    internal override long GetRowIdForCursor(SQLiteStatement stmt, int cursor)
    {
      long rowid;
      return UnsafeNativeMethods.sqlite3_cursor_rowid((IntPtr) stmt._sqlite_stmt, cursor, out rowid) == 0 ? rowid : 0L;
    }

    internal override void GetIndexColumnExtendedInfo(
      string database,
      string index,
      string column,
      out int sortMode,
      out int onError,
      out string collationSequence)
    {
      IntPtr Collation;
      int colllen;
      int errorCode = UnsafeNativeMethods.sqlite3_index_column_info_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(database), SQLiteConvert.ToUTF8(index), SQLiteConvert.ToUTF8(column), out sortMode, out onError, out Collation, out colllen);
      if (errorCode != 0)
        throw new SQLiteException(errorCode, "");
      collationSequence = SQLiteConvert.UTF8ToString(Collation, colllen);
    }
  }
}
