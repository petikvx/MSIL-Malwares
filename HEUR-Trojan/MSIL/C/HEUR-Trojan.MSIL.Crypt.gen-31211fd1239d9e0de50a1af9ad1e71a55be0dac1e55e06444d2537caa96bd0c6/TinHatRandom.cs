// Decompiled with JetBrains decompiler
// Type: TinHatRandom
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Digests;
using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Threading;

public sealed class TinHatRandom : RandomNumberGenerator
{
  private const int TrueInt = 1;
  private const int FalseInt = 0;
  private static TinHatRandom _StaticInstance = new TinHatRandom();
  private EventHandler EntropyFileRNG_Reseeded_Handler;
  private EventHandler EntropyFileRNG_BecameAvailable_Handler;
  private int disposed;
  private List<EntropyHasher> EntropyHashers;
  private int HashLengthInBytes;

  public static TinHatRandom StaticInstance => TinHatRandom._StaticInstance;

  public event EventHandler EntropyIncreased;

  public TinHatRandom()
  {
    this.EntropyHashers = new List<EntropyHasher>();
    this.EntropyHashers.Add(new EntropyHasher((RandomNumberGenerator) new SystemRNGCryptoServiceProvider(), new HashAlgorithmWrapper((HashAlgorithm) SHA256.Create())));
    this.EntropyHashers.Add(new EntropyHasher((RandomNumberGenerator) new ThreadedSeedGeneratorRNG(), new List<HashAlgorithmWrapper>()
    {
      new HashAlgorithmWrapper((HashAlgorithm) SHA256.Create()),
      new HashAlgorithmWrapper((IDigest) new RipeMD256Digest())
    }));
    EntropyFileRNG RNG = (EntropyFileRNG) null;
    try
    {
      RNG = new EntropyFileRNG();
    }
    catch
    {
    }
    if (RNG == null)
    {
      this.EntropyFileRNG_BecameAvailable_Handler = new EventHandler(this.HasPermissionGetPermissions\u003CInitialize\u003Eb__13_0);
      EntropyFileRNG.BecameAvailable += this.EntropyFileRNG_BecameAvailable_Handler;
    }
    else
    {
      HashAlgorithmWrapper HashWrapper = new HashAlgorithmWrapper((HashAlgorithm) SHA256.Create());
      this.EntropyHashers.Add(new EntropyHasher((RandomNumberGenerator) RNG, HashWrapper));
      this.EntropyFileRNG_Reseeded_Handler = new EventHandler(this.AwakeDeleteGroup_invoke);
      RNG.Reseeded += this.EntropyFileRNG_Reseeded_Handler;
    }
    this.ParseUriInitializeAddGroup();
  }

  public TinHatRandom(List<EntropyHasher> EntropyHashers)
  {
    this.EntropyHashers = EntropyHashers;
    foreach (EntropyHasher entropyHasher in EntropyHashers)
    {
      if (entropyHasher.RNG is EntropyFileRNG)
      {
        this.EntropyFileRNG_Reseeded_Handler = new EventHandler(this.AwakeDeleteGroup_invoke);
        ((EntropyFileRNG) entropyHasher.RNG).Reseeded += this.EntropyFileRNG_Reseeded_Handler;
      }
    }
    this.ParseUriInitializeAddGroup();
  }

  private void ParseUriInitializeAddGroup()
  {
    if (this.EntropyHashers == null)
      throw new ArgumentNullException("EntropyHashers");
    if (this.EntropyHashers.Count < 1)
      throw new ArgumentException("EntropyHashers.Count cannot be < 1");
    int num = -1;
    foreach (EntropyHasher entropyHasher in this.EntropyHashers)
    {
      if (entropyHasher.RNG == null)
        throw new ArgumentException("RNG cannot be null");
      if (entropyHasher.HashWrappers == null)
        throw new ArgumentException("HashWrappers cannot be null");
      if (entropyHasher.HashWrappers.Count < 1)
        throw new ArgumentException("HashWrappers.Count cannot be < 1");
      foreach (HashAlgorithmWrapper hashWrapper in entropyHasher.HashWrappers)
      {
        if (num == -1)
          num = hashWrapper.HashSizeInBits;
        else if (num != hashWrapper.HashSizeInBits)
          throw new ArgumentException("Hash functions must all return the same size digest");
      }
    }
    this.HashLengthInBytes = num / 8;
  }

  private void AwakeDeleteGroup_invoke(object sender, EventArgs e)
  {
    if (this.EntropyIncreased == null)
      return;
    this.EntropyIncreased((object) this, EventArgs.Empty);
  }

  private void HasPermissionGetPermissions\u003CInitialize\u003Eb__13_0(object sender, EventArgs e)
  {
    EntropyFileRNG RNG = new EntropyFileRNG();
    HashAlgorithmWrapper HashWrapper = new HashAlgorithmWrapper((HashAlgorithm) SHA256.Create());
    lock (this.EntropyHashers)
    {
      this.EntropyHashers.Add(new EntropyHasher((RandomNumberGenerator) RNG, HashWrapper));
      this.EntropyFileRNG_Reseeded_Handler = new EventHandler(this.AwakeDeleteGroup_invoke);
      RNG.Reseeded += this.EntropyFileRNG_Reseeded_Handler;
    }
    EntropyFileRNG.BecameAvailable -= this.EntropyFileRNG_BecameAvailable_Handler;
    if (this.EntropyIncreased == null)
      return;
    this.EntropyIncreased((object) this, EventArgs.Empty);
  }

  private byte[] IsDependencyLoadedset_MemberSinceset_SteamID(List<byte[]> byteArrays)
  {
    if (byteArrays == null)
      throw new ArgumentNullException(nameof (byteArrays));
    if (byteArrays.Count < 1)
      throw new ArgumentException("byteArrays.Count < 1");
    byte[] destinationArray = new byte[this.HashLengthInBytes];
    if (byteArrays.Count == 1)
    {
      if (byteArrays[0].Length != this.HashLengthInBytes)
        throw new ArgumentException("byteArray.Length != HashLengthInBytes");
      Array.Copy((Array) byteArrays[0], (Array) destinationArray, this.HashLengthInBytes);
    }
    else
    {
      Array.Clear((Array) destinationArray, 0, destinationArray.Length);
      foreach (byte[] byteArray in byteArrays)
      {
        if (byteArray.Length != this.HashLengthInBytes)
          throw new ArgumentException("byteArray.Length != HashLengthInBytes");
        for (int index = 0; index < this.HashLengthInBytes; ++index)
          destinationArray[index] ^= byteArray[index];
      }
    }
    return destinationArray;
  }

  private bool DeregisterFromAssemblyInitializeget_Syntax(byte[] first, byte[] second)
  {
    if (first == null || second == null)
      throw new CryptographicException("null byte array in allByteArraysThatMustBeUnique");
    if (first.Length != this.HashLengthInBytes || second.Length != this.HashLengthInBytes)
      throw new CryptographicException("byte array in allByteArraysThatMustBeUnique with wrong length");
    for (int index = 0; index < this.HashLengthInBytes; ++index)
    {
      if ((int) first[index] != (int) second[index])
        return false;
    }
    return true;
  }

  public override void GetBytes(byte[] data)
  {
    if (data == null)
      throw new ArgumentNullException(nameof (data));
    if (data.Length == 0)
      return;
    int index1 = 0;
    bool flag = false;
    while (!flag)
    {
      List<byte[]> numArrayList = new List<byte[]>();
      List<byte[]> byteArrays1 = new List<byte[]>();
      lock (this.EntropyHashers)
      {
        foreach (EntropyHasher entropyHasher in this.EntropyHashers)
        {
          List<byte[]> byteArrays2 = new List<byte[]>();
          byte[] data1 = new byte[this.HashLengthInBytes];
          entropyHasher.RNG.GetBytes(data1);
          numArrayList.Add(data1);
          if (entropyHasher.HashWrappers == null || entropyHasher.HashWrappers.Count < 1)
            throw new CryptographicException("eHasher.HashWrappers == null || eHasher.HashWrappers.Count < 1");
          foreach (HashAlgorithmWrapper hashWrapper in entropyHasher.HashWrappers)
          {
            byte[] command = hashWrapper.LogErrorExecuteGetCommand(data1);
            byteArrays2.Add(command);
            numArrayList.Add(command);
          }
          if (byteArrays2.Count == 1)
          {
            byteArrays1.Add(byteArrays2[0]);
          }
          else
          {
            byte[] numArray = byteArrays2.Count > 1 ? this.IsDependencyLoadedset_MemberSinceset_SteamID(byteArrays2) : throw new Exception("Impossible Exception # A0B276734D");
            numArrayList.Add(numArray);
            byteArrays1.Add(numArray);
          }
        }
      }
      byte[] numArray1 = this.IsDependencyLoadedset_MemberSinceset_SteamID(byteArrays1);
      numArrayList.Add(numArray1);
      for (int index2 = 0; index2 < numArrayList.Count - 1; ++index2)
      {
        byte[] first = numArrayList[index2];
        for (int index3 = index2 + 1; index3 < numArrayList.Count; ++index3)
        {
          byte[] second = numArrayList[index3];
          if (this.DeregisterFromAssemblyInitializeget_Syntax(first, second))
            throw new CryptographicException("non-unique arrays in allByteArraysThatMustBeUnique");
        }
      }
      for (int index4 = 0; index4 < numArray1.Length; ++index4)
      {
        data[index1] = numArray1[index4];
        ++index1;
        if (index1 == data.Length)
        {
          flag = true;
          break;
        }
      }
      foreach (byte[] numArray2 in numArrayList)
        Array.Clear((Array) numArray2, 0, numArray2.Length);
    }
  }

  public override void GetNonZeroBytes(byte[] data)
  {
    if (data == null)
      throw new ArgumentNullException(nameof (data));
    if (data.Length == 0)
      return;
    int index1 = 0;
label_4:
    byte[] data1 = new byte[(int) (1.05 * (double) (data.Length - index1))];
    this.GetBytes(data1);
    for (int index2 = 0; index2 < data1.Length; ++index2)
    {
      if (data1[index2] != (byte) 0)
      {
        data[index1] = data1[index2];
        ++index1;
        if (index1 == data.Length)
        {
          Array.Clear((Array) data1, 0, data1.Length);
          return;
        }
      }
    }
    goto label_4;
  }

  protected override void Dispose(bool disposing)
  {
    if (Interlocked.Exchange(ref this.disposed, 1) == 1)
      return;
    try
    {
      EntropyFileRNG.BecameAvailable -= this.EntropyFileRNG_BecameAvailable_Handler;
    }
    catch
    {
    }
    if (this.EntropyHashers != null)
    {
      List<EntropyHasher> entropyHashers = this.EntropyHashers;
      this.EntropyHashers = (List<EntropyHasher>) null;
      try
      {
        foreach (EntropyHasher entropyHasher in entropyHashers)
        {
          if (entropyHasher.RNG is EntropyFileRNG)
          {
            try
            {
              ((EntropyFileRNG) entropyHasher.RNG).Reseeded -= this.EntropyFileRNG_Reseeded_Handler;
            }
            catch
            {
            }
          }
          try
          {
            entropyHasher.Dispose();
          }
          catch
          {
          }
        }
      }
      catch
      {
      }
    }
    base.Dispose(disposing);
  }

  ~TinHatRandom() => this.Dispose(false);
}
