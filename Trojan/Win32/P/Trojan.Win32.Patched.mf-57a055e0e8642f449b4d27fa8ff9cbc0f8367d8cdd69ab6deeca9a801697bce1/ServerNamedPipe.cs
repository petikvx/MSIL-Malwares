// Decompiled with JetBrains decompiler
// Type: Tvsu.Service.Server.ServerNamedPipe
// Assembly: SUService, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C794206D-ECC0-4CFA-AB4E-5C06FB2FD4CC
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00001-msil\Trojan.Win32.Patched.mf-57a055e0e8642f449b4d27fa8ff9cbc0f8367d8cdd69ab6deeca9a801697bce1.exe

using System;
using System.Threading;
using Tvsu.Service.Common.NamedPipes;

namespace Tvsu.Service.Server
{
  public sealed class ServerNamedPipe : IDisposable
  {
    internal Thread PipeThread;
    internal ServerPipeConnection PipeConnection;
    internal bool Listen = true;
    internal DateTime LastAction;
    private bool disposed = false;

    private void PipeListener()
    {
      this.CheckIfDisposed();
      try
      {
        this.Listen = TvsuService.PipeManager.Listen;
        Console.WriteLine("Pipe " + ((APipeConnection) this.PipeConnection).NativeHandle.ToString() + ": new pipe started" + Environment.NewLine);
        while (this.Listen)
        {
          this.LastAction = DateTime.Now;
          string str = ((APipeConnection) this.PipeConnection).Read();
          this.LastAction = DateTime.Now;
          int nativeHandle;
          if (str.Trim() != "")
          {
            ((APipeConnection) this.PipeConnection).Write(TvsuService.PipeManager.HandleRequest(str));
            nativeHandle = ((APipeConnection) this.PipeConnection).NativeHandle;
            Console.WriteLine("Pipe " + nativeHandle.ToString() + ": request handled" + Environment.NewLine);
          }
          else
            ((APipeConnection) this.PipeConnection).Write("Error: bad request");
          this.LastAction = DateTime.Now;
          this.PipeConnection.Disconnect();
          if (this.Listen)
          {
            nativeHandle = ((APipeConnection) this.PipeConnection).NativeHandle;
            Console.WriteLine("Pipe " + nativeHandle.ToString() + ": listening" + Environment.NewLine);
            this.Connect();
          }
          TvsuService.PipeManager.WakeUp();
        }
      }
      catch (ThreadAbortException ex)
      {
        Console.WriteLine(ex.StackTrace.ToString());
      }
      catch (ThreadStateException ex)
      {
        Console.WriteLine(ex.StackTrace.ToString());
      }
      catch (Exception ex)
      {
        Console.WriteLine(ex.StackTrace.ToString());
      }
      finally
      {
        this.Close();
      }
    }

    internal void Connect()
    {
      this.CheckIfDisposed();
      ((APipeConnection) this.PipeConnection).Connect();
    }

    internal void Close()
    {
      this.CheckIfDisposed();
      this.Listen = false;
      TvsuService.PipeManager.RemoveServerChannel((object) ((APipeConnection) this.PipeConnection).NativeHandle);
      this.Dispose();
    }

    internal void Start()
    {
      this.CheckIfDisposed();
      this.PipeThread.Start();
    }

    private void CheckIfDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(nameof (ServerNamedPipe));
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void Dispose(bool disposing)
    {
      if (!this.disposed)
      {
        ((APipeConnection) this.PipeConnection).Dispose();
        if (this.PipeThread != null)
        {
          try
          {
            this.PipeThread.Abort();
          }
          catch (ThreadAbortException ex)
          {
            Console.WriteLine(ex.StackTrace.ToString());
          }
          catch (ThreadStateException ex)
          {
            Console.WriteLine(ex.StackTrace.ToString());
          }
          catch (Exception ex)
          {
            Console.WriteLine(ex.StackTrace.ToString());
          }
        }
      }
      this.disposed = true;
    }

    ~ServerNamedPipe() => this.Dispose(false);

    internal ServerNamedPipe(
      string name,
      uint outBuffer,
      uint inBuffer,
      int maxReadBytes,
      bool secure)
    {
      this.PipeConnection = new ServerPipeConnection(name, outBuffer, inBuffer, maxReadBytes, secure);
      this.PipeThread = new Thread(new ThreadStart(this.PipeListener));
      this.PipeThread.IsBackground = true;
      this.PipeThread.Name = "Pipe Thread " + ((APipeConnection) this.PipeConnection).NativeHandle.ToString();
      this.LastAction = DateTime.Now;
    }
  }
}
