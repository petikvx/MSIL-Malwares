// Decompiled with JetBrains decompiler
// Type: Aura.MainWindow
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using Aura.Protection.CtrlFlow;
using Aura.Protection.INT;
using Aura.Protection.InvalidMD;
using Aura.Protection.LocalF;
using Aura.Protection.Other;
using Aura.Protection.Proxy;
using Aura.Protection.Software;
using Aura.Protection.String;
using Aura.Protection.StringOnline;
using ControlzEx.Theming;
using dnlib.DotNet;
using dnlib.DotNet.Writer;
using MahApps.Metro.Controls;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Markup;
using System.Windows.Media;

namespace Aura
{
  public partial class MainWindow : MetroWindow, IComponentConnector
  {
    public static MethodDef Init;
    public static MethodDef Init2;
    public string DirectoryName = string.Empty;
    public byte MaxValue = byte.MaxValue;
    internal TextBox ConsoleLog;
    internal TextBox Program;
    internal CheckBox String_Encryption;
    internal CheckBox Online_Decryption;
    internal CheckBox Cflow;
    internal CheckBox IntConf;
    internal CheckBox Ahri;
    internal CheckBox LF;
    internal CheckBox LFV2;
    internal CheckBox Calli_;
    internal CheckBox Proxy_String;
    internal CheckBox ProxyConstants;
    internal CheckBox Proxy_Meth;
    internal CheckBox Index_Fields;
    internal CheckBox JumpCflow;
    internal CheckBox AntiDebug;
    internal CheckBox Anti_Dump;
    internal CheckBox AntiTamper;
    internal CheckBox Anti_De4dot;
    internal CheckBox InvalidMD;
    internal CheckBox SUC;
    internal CheckBox RES;
    private bool _contentLoaded;

    public MainWindow()
    {
      this.InitializeComponent();
      ThemeManager.Current.ThemeSyncMode = (ThemeSyncMode) 0;
      ThemeManager.Current.SyncTheme();
    }

    private void Button_Click(object sender, RoutedEventArgs e)
    {
      string str1 = DateTime.Now.ToString("hh:mm:ss");
      ModuleDefMD moduleDefMd1 = ModuleDefMD.Load(this.Program.Text, ModuleDef.CreateModuleContext());
      this.ConsoleLog.Foreground = (Brush) Brushes.Black;
      this.ConsoleLog.AppendText(str1 + " Starting obfuscation" + Environment.NewLine);
      bool? isChecked1 = this.String_Encryption.IsChecked;
      bool flag1 = true;
      if (isChecked1.GetValueOrDefault() == flag1 & isChecked1.HasValue)
      {
        StringEncPhase.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing string encryption" + Environment.NewLine);
      }
      bool? isChecked2 = this.Online_Decryption.IsChecked;
      bool flag2 = true;
      if (isChecked2.GetValueOrDefault() == flag2 & isChecked2.HasValue)
      {
        OnlinePhase.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing online decryption" + Environment.NewLine);
      }
      bool? isChecked3 = this.Cflow.IsChecked;
      bool flag3 = true;
      if (isChecked3.GetValueOrDefault() == flag3 & isChecked3.HasValue)
      {
        ControlFlowObfuscation.Execute(moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing control flow" + Environment.NewLine);
      }
      bool? isChecked4 = this.IntConf.IsChecked;
      bool flag4 = true;
      if (isChecked4.GetValueOrDefault() == flag4 & isChecked4.HasValue)
      {
        AddIntPhase.Execute2((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing integer confusion" + Environment.NewLine);
      }
      bool? isChecked5 = this.SUC.IsChecked;
      bool flag5 = true;
      if (isChecked5.GetValueOrDefault() == flag5 & isChecked5.HasValue)
      {
        StackUnfConfusion.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing stack confusion" + Environment.NewLine);
      }
      bool? isChecked6 = this.Ahri.IsChecked;
      bool flag6 = true;
      if (isChecked6.GetValueOrDefault() == flag6 & isChecked6.HasValue)
      {
        Aura.Protection.Arithmetic.Arithmetic.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing math calculations" + Environment.NewLine);
      }
      bool? isChecked7 = this.LF.IsChecked;
      bool flag7 = true;
      if (isChecked7.GetValueOrDefault() == flag7 & isChecked7.HasValue)
      {
        L2F.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing constant fields" + Environment.NewLine);
      }
      bool? isChecked8 = this.LFV2.IsChecked;
      bool flag8 = true;
      if (isChecked8.GetValueOrDefault() == flag8 & isChecked8.HasValue)
      {
        L2FV2.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing local fields" + Environment.NewLine);
      }
      bool? isChecked9 = this.Calli_.IsChecked;
      bool flag9 = true;
      if (isChecked9.GetValueOrDefault() == flag9 & isChecked9.HasValue)
      {
        Calli.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing calli conversion" + Environment.NewLine);
      }
      bool? isChecked10 = this.Proxy_String.IsChecked;
      bool flag10 = true;
      if (isChecked10.GetValueOrDefault() == flag10 & isChecked10.HasValue)
      {
        ProxyString.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing proxy strings" + Environment.NewLine);
      }
      bool? isChecked11 = this.ProxyConstants.IsChecked;
      bool flag11 = true;
      if (isChecked11.GetValueOrDefault() == flag11 & isChecked11.HasValue)
      {
        ProxyINT.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing proxy constants" + Environment.NewLine);
      }
      bool? isChecked12 = this.Proxy_Meth.IsChecked;
      bool flag12 = true;
      if (isChecked12.GetValueOrDefault() == flag12 & isChecked12.HasValue)
      {
        ProxyMeth.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing proxy methods" + Environment.NewLine);
      }
      bool? isChecked13 = this.Anti_De4dot.IsChecked;
      bool flag13 = true;
      if (isChecked13.GetValueOrDefault() == flag13 & isChecked13.HasValue)
      {
        AntiDecompile.Execute(((ModuleDef) moduleDefMd1).Assembly);
        this.ConsoleLog.AppendText(str1 + " Processing anti-decompile" + Environment.NewLine);
      }
      bool? isChecked14 = this.JumpCflow.IsChecked;
      bool flag14 = true;
      if (isChecked14.GetValueOrDefault() == flag14 & isChecked14.HasValue)
      {
        JumpCFlow.Execute(moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing flow conversion" + Environment.NewLine);
      }
      bool? isChecked15 = this.AntiDebug.IsChecked;
      bool flag15 = true;
      if (isChecked15.GetValueOrDefault() == flag15 & isChecked15.HasValue)
      {
        Anti_Debug.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing anti-debug" + Environment.NewLine);
      }
      bool? isChecked16 = this.Anti_Dump.IsChecked;
      bool flag16 = true;
      if (isChecked16.GetValueOrDefault() == flag16 & isChecked16.HasValue)
      {
        AntiDump.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing anti-dump" + Environment.NewLine);
      }
      bool? isChecked17 = this.AntiTamper.IsChecked;
      bool flag17 = true;
      if (isChecked17.GetValueOrDefault() == flag17 & isChecked17.HasValue)
      {
        Aura.Protection.Software.AntiTamper.Execute((ModuleDef) moduleDefMd1);
        this.ConsoleLog.AppendText(str1 + " Processing anti-tamper" + Environment.NewLine);
      }
      bool? isChecked18 = this.InvalidMD.IsChecked;
      bool flag18 = true;
      if (isChecked18.GetValueOrDefault() == flag18 & isChecked18.HasValue)
      {
        InvalidMDPhase.Execute(((ModuleDef) moduleDefMd1).Assembly);
        this.ConsoleLog.AppendText(str1 + " Processing invalid metadata" + Environment.NewLine);
      }
      string directoryName = Path.GetDirectoryName(this.Program.Text);
      if (directoryName != null && !directoryName.EndsWith("\\"))
        directoryName += "\\";
      string filePath = directoryName + Path.GetFileNameWithoutExtension(this.Program.Text) + "_protected" + Path.GetExtension(this.Program.Text);
      ModuleDefMD moduleDefMd2 = moduleDefMd1;
      string str2 = filePath;
      ModuleWriterOptions moduleWriterOptions = new ModuleWriterOptions((ModuleDef) moduleDefMd1);
      ((ModuleWriterOptionsBase) moduleWriterOptions).PEHeadersOptions.NumberOfRvaAndSizes = new uint?(13U);
      ((ModuleWriterOptionsBase) moduleWriterOptions).Logger = (ILogger) DummyLogger.NoThrowInstance;
      ((ModuleDef) moduleDefMd2).Write(str2, moduleWriterOptions);
      this.ConsoleLog.AppendText(str1 + " File: " + filePath + Environment.NewLine + Environment.NewLine);
      bool? isChecked19 = this.AntiTamper.IsChecked;
      bool flag19 = true;
      if (!(isChecked19.GetValueOrDefault() == flag19 & isChecked19.HasValue))
        return;
      Aura.Protection.Software.AntiTamper.Sha256(filePath);
    }

    private void LoadBox_DragEnter(object sender, DragEventArgs e) => e.Effects = e.Data.GetDataPresent(DataFormats.FileDrop) ? DragDropEffects.Copy : DragDropEffects.None;

    private void LoadBox_Drop(object sender, DragEventArgs e)
    {
      try
      {
        Array data = (Array) e.Data.GetData(DataFormats.FileDrop);
        if (data == null)
          return;
        string str = data.GetValue(0).ToString();
        int startIndex1 = str.LastIndexOf(".", StringComparison.Ordinal);
        if (startIndex1 == -1)
          return;
        string lower = str.Substring(startIndex1).ToLower();
        if (string.Compare(lower, ".exe", StringComparison.Ordinal) != 0 && string.Compare(lower, ".dll", StringComparison.Ordinal) != 0)
          return;
        ((Window) this).Activate();
        this.Program.Text = str;
        int startIndex2 = str.LastIndexOf("\\", StringComparison.Ordinal);
        if (startIndex2 != -1)
          this.DirectoryName = str.Remove(startIndex2, str.Length - startIndex2);
        if (this.DirectoryName.Length != 2)
          return;
        this.DirectoryName += "\\";
      }
      catch
      {
      }
    }

    private void LoadBox_PreviewDragOver(object sender, DragEventArgs e) => e.Handled = true;

    private void MetroAnimatedTabControl_SelectionChanged(
      object sender,
      SelectionChangedEventArgs e)
    {
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/Kudeta Crypter;component/mainwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((Selector) target).SelectionChanged += new SelectionChangedEventHandler(this.MetroAnimatedTabControl_SelectionChanged);
          break;
        case 2:
          ((ButtonBase) target).Click += new RoutedEventHandler(this.Button_Click);
          break;
        case 3:
          this.ConsoleLog = (TextBox) target;
          break;
        case 4:
          this.Program = (TextBox) target;
          this.Program.DragEnter += new DragEventHandler(this.LoadBox_DragEnter);
          this.Program.Drop += new DragEventHandler(this.LoadBox_Drop);
          this.Program.PreviewDragOver += new DragEventHandler(this.LoadBox_PreviewDragOver);
          break;
        case 5:
          this.String_Encryption = (CheckBox) target;
          break;
        case 6:
          this.Online_Decryption = (CheckBox) target;
          break;
        case 7:
          this.Cflow = (CheckBox) target;
          break;
        case 8:
          this.IntConf = (CheckBox) target;
          break;
        case 9:
          this.Ahri = (CheckBox) target;
          break;
        case 10:
          this.LF = (CheckBox) target;
          break;
        case 11:
          this.LFV2 = (CheckBox) target;
          break;
        case 12:
          this.Calli_ = (CheckBox) target;
          break;
        case 13:
          this.Proxy_String = (CheckBox) target;
          break;
        case 14:
          this.ProxyConstants = (CheckBox) target;
          break;
        case 15:
          this.Proxy_Meth = (CheckBox) target;
          break;
        case 16:
          this.Index_Fields = (CheckBox) target;
          break;
        case 17:
          this.JumpCflow = (CheckBox) target;
          break;
        case 18:
          this.AntiDebug = (CheckBox) target;
          break;
        case 19:
          this.Anti_Dump = (CheckBox) target;
          break;
        case 20:
          this.AntiTamper = (CheckBox) target;
          break;
        case 21:
          this.Anti_De4dot = (CheckBox) target;
          break;
        case 22:
          this.InvalidMD = (CheckBox) target;
          break;
        case 23:
          this.SUC = (CheckBox) target;
          break;
        case 24:
          this.RES = (CheckBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}
