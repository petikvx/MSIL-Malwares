// Decompiled with JetBrains decompiler
// Type: ChessBoard.Chessmens.Queen
// Assembly: IArraySortHel, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B08900B5-C53F-4995-B311-D7E8DC4113C6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\Trojan-Spy.Win32.Noon.bcrg-fe8d5c5d892bac95b940a26cf50aacf262dd40e3394fc1ba8444ab3842a16fda.exe

using System.Collections.Generic;

namespace ChessBoard.Chessmens
{
  public class Queen : BaseChessman
  {
    public override ChessmenType Type => ChessmenType.Queen;

    public Queen()
    {
    }

    public Queen(Colorz color)
      : base(color)
    {
    }

    public override bool Equals(object obj)
    {
      bool flag1 = !(obj is Queen);
label_1:
      int num1 = -1726815838;
      bool flag2;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -567635962)) % 5U)
        {
          case 0:
            goto label_1;
          case 2:
            flag2 = false;
            num1 = (int) num2 * 1234162697 ^ 309322908;
            continue;
          case 3:
            flag2 = base.Equals(obj);
            num1 = -1745046902;
            continue;
          case 4:
            int num3 = flag1 ? 1066102256 : (num3 = 2014510586);
            num1 = num3 ^ (int) num2 * -392341468;
            continue;
          default:
            goto label_6;
        }
      }
label_6:
      return flag2;
    }

    public override int GetHashCode()
    {
label_1:
      int num1 = -2071654249;
      int hashCode;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -2128216090)) % 4U)
        {
          case 0:
            goto label_1;
          case 1:
            hashCode = base.GetHashCode();
            num1 = (int) num2 * 1578691885 ^ 1486957236;
            continue;
          case 3:
            num1 = (int) num2 * -1893723333 ^ 1561662249;
            continue;
          default:
            goto label_5;
        }
      }
label_5:
      return hashCode;
    }

    public override List<Cell> GetAcceptableCells(
      BoardCell[,] boardCells,
      Cell currentCell,
      bool needToCheckShah = true)
    {
label_1:
      int num1 = -789968906;
      List<Cell> cellsForDirections;
      List<Cell> acceptableCells;
      bool flag;
      while (true)
      {
        uint num2;
        switch ((num2 = (uint) (num1 ^ -1836904941)) % 6U)
        {
          case 1:
            cellsForDirections = this.GetAcceptableCellsForDirections(boardCells, this.AnyDirections, currentCell);
            flag = needToCheckShah;
            num1 = (int) num2 * -1217696601 ^ -1001557222;
            continue;
          case 2:
            int num3 = !flag ? -2004141162 : (num3 = -1501458621);
            num1 = num3 ^ (int) num2 * -585092112;
            continue;
          case 3:
            goto label_1;
          case 4:
            this.AdjustAcceptableCellsInCaseShah(boardCells, cellsForDirections, currentCell);
            num1 = (int) num2 * 1250316768 ^ 117494006;
            continue;
          case 5:
            acceptableCells = cellsForDirections;
            num1 = -379506195;
            continue;
          default:
            goto label_7;
        }
      }
label_7:
      return acceptableCells;
    }
  }
}
