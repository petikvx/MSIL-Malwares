// Decompiled with JetBrains decompiler
// Type: forces.PointBaemForce
// Assembly: MuiResourceTypeIdIntEn, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2C7C9528-88C0-45FF-AB6A-2AC0C29EABCB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-0e10e646be7b3f9857a2994bedc1b808fabc112009cda3192df15b8eb4980ef8.exe

using System;

namespace forces
{
  public class PointBaemForce : Force, BeamForce, Force_
  {
    private double position;
    private double beamLength;
    private ReflectionBeamForce ReflectionLeft;
    private ReflectionBeamForce ReflectionRight;

    public double Position => this.position;

    public double BeamLength => this.beamLength;

    public PointBaemForce(double power, double position, double beamLenght)
      : base(power)
    {
      this.position = position;
      this.beamLength = beamLenght;
      this.calculReflectionLeft();
      this.calculReflectionRight();
    }

    protected PointBaemForce(double power, double position, double beamLenght, bool calc)
      : base(power)
    {
      this.position = position;
      this.beamLength = beamLenght;
      if (!calc)
        return;
      this.calculReflectionLeft();
      this.calculReflectionRight();
    }

    public virtual double getMomentom(double distance) => distance <= this.position ? 0.0 : -(distance - this.position) * this.Power * 1.0;

    public virtual double getShaer(double distance) => distance <= this.position ? this.ReflectionLeft.Power : -this.ReflectionRight.Power;

    public virtual double getfMomentomd2x(double distance)
    {
      double num = this.Power * Math.Pow(this.beamLength - this.position, 3.0) / (6.0 * this.beamLength);
      return distance <= this.position ? num * distance * 1.0 : (-this.Power * Math.Pow(distance - this.position, 3.0) / 6.0 + num * distance) * 1.0;
    }

    public virtual ReflectionBeamForce getReflection(int x)
    {
      switch (x)
      {
        case 0:
          return this.ReflectionLeft;
        case 1:
          return this.ReflectionRight;
        default:
          throw new ArgumentOutOfRangeException(nameof (x), (object) x, "x is to be in [0,1]");
      }
    }

    public override void add(Force_ force)
    {
      if (!this.canAdd(force))
        return;
      this.addPower(force);
      this.calculReflectionRight();
      this.calculReflectionLeft();
    }

    public override bool canAdd(Force_ force) => this.sameType(force) && this.position == ((PointBaemForce) force).position;

    private void calculReflectionLeft() => this.ReflectionLeft = new ReflectionBeamForce(this.Power * (this.BeamLength - this.position) / this.BeamLength, 0.0, this.beamLength);

    private void calculReflectionRight() => this.ReflectionRight = new ReflectionBeamForce(this.Power * this.position / this.BeamLength, 0.0, this.beamLength);
  }
}
