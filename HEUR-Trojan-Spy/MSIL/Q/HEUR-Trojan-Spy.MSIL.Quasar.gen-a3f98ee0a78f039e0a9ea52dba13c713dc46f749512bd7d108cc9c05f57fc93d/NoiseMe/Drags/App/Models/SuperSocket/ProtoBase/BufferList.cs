// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ProtoBase.BufferList
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Collections;
using System.Collections.Generic;

namespace NoiseMe.Drags.App.Models.SuperSocket.ProtoBase
{
  public sealed class BufferList : 
    IList<ArraySegment<byte>>,
    ICollection<ArraySegment<byte>>,
    IEnumerable<ArraySegment<byte>>,
    IEnumerable
  {
    private List<ArraySegment<byte>> m_List = new List<ArraySegment<byte>>();
    private int m_Total;

    public ArraySegment<byte> Last
    {
      get
      {
        int count = this.Count;
        return count == 0 ? new ArraySegment<byte>() : this.m_List[count - 1];
      }
    }

    public int IndexOf(ArraySegment<byte> item) => throw new NotSupportedException();

    public void Insert(int index, ArraySegment<byte> item) => throw new NotSupportedException();

    public void RemoveAt(int index) => throw new NotSupportedException();

    public ArraySegment<byte> this[int index]
    {
      get => this.m_List[index];
      set => throw new NotSupportedException();
    }

    public void Add(ArraySegment<byte> item)
    {
      this.m_List.Add(item);
      this.m_Total += item.Count;
    }

    public void SetLastItemLength(int length)
    {
      int index = this.m_List.Count - 1;
      ArraySegment<byte> arraySegment = this.m_List[index];
      this.m_List[index] = new ArraySegment<byte>(arraySegment.Array, arraySegment.Offset, length);
      this.m_Total += length - arraySegment.Count;
    }

    public void Clear()
    {
      this.m_List.Clear();
      this.m_Total = 0;
    }

    public bool Contains(ArraySegment<byte> item) => throw new NotSupportedException();

    public void CopyTo(ArraySegment<byte>[] array, int arrayIndex) => throw new NotSupportedException();

    public int Total => this.m_Total;

    public int Count => this.m_List.Count;

    public bool IsReadOnly => true;

    public bool Remove(ArraySegment<byte> item) => throw new NotSupportedException();

    public IEnumerator<ArraySegment<byte>> GetEnumerator()
    {
      int length = this.m_List.Count;
      for (int i = 0; i < length; ++i)
        yield return this.m_List[i];
    }

    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();

    public IList<ArraySegment<byte>> GetAllCachedItems() => (IList<ArraySegment<byte>>) this.m_List;

    public BufferList Clone(int index, int segmentOffset, int length)
    {
      BufferList bufferList = new BufferList();
      int val2 = length;
      List<ArraySegment<byte>> list = this.m_List;
      for (int index1 = index; index1 < list.Count; ++index1)
      {
        ArraySegment<byte> arraySegment = list[index1];
        int offset = arraySegment.Offset;
        int val1 = arraySegment.Count;
        if (index1 == index)
        {
          offset = segmentOffset;
          val1 = arraySegment.Count - (segmentOffset - arraySegment.Offset);
        }
        int count = Math.Min(val1, val2);
        bufferList.Add(new ArraySegment<byte>(arraySegment.Array, offset, count));
        val2 -= count;
        if (val2 <= 0)
          break;
      }
      return bufferList;
    }
  }
}
