// Decompiled with JetBrains decompiler
// Type: j
// Assembly: Fugi, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BEDD3B0B-7024-4DCA-82E7-4DC806657EA8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00002-msil\Trojan-Dropper.Win32.Dapato.adjp-c7222843a23fc031926828311c4204ba181271a1dde91017bc4695dc95b5fc46.exe

using System;
using System.IO;

internal sealed class j
{
  public static void a(Stream a1, Stream a2)
  {
    byte[] numArray = new byte[4096];
    j.a a = new j.a(a1);
    while (true)
    {
      int count = a.a(numArray, 0, numArray.Length);
      if ((count <= 0 ? 0 : 1) != 0)
        a2.Write(numArray, 0, count);
      else
        break;
    }
  }

  public sealed class a
  {
    private j.c a = new j.c(32769);
    private j.b b;
    private i c;
    private int d = -1;
    private int e = -1;
    private bool f;
    private int g;
    private long h;
    private long i;
    private bool j;
    private int k;
    private bool l;

    public a(Stream a) => this.b = new j.b(a);

    public int a(byte[] a1, int a2, int a3)
    {
      if ((a1 == null ? 0 : 1) == 0)
        throw new ArgumentNullException();
      if (a3 == 0 || this.j)
        return 0;
      int num1 = 0;
label_15:
      while (num1 < a3)
      {
        while (this.d < 0 && !this.j)
          this.j = !this.a();
        if (!this.j)
        {
          int num2 = this.b(a1, a2 + num1, a3 - num1);
label_10:
          int num3 = 0;
          while (true)
          {
            switch (num3)
            {
              case 0:
                if (num2 > 0)
                {
                  num3 = 1;
                  continue;
                }
                goto label_14;
              case 1:
                num1 += num2;
                num3 = 2;
                continue;
              case 2:
                goto label_15;
              default:
                goto label_10;
            }
          }
label_14:
          this.d = -1;
        }
        else
          break;
      }
      return num1;
    }

    private bool a()
    {
      if ((!this.f ? 1 : 0) == 0)
        return false;
      this.h = this.b.e;
label_4:
      int num1 = 2;
      int d;
      while (true)
      {
        switch (num1)
        {
          case 0:
            switch (d)
            {
              case 0:
                goto label_10;
              case 1:
                goto label_13;
              case 2:
                goto label_14;
              default:
                num1 = 4;
                continue;
            }
          case 1:
            this.d = this.b.a(2);
            num1 = 3;
            continue;
          case 2:
            this.f = this.b.a(1) > 0;
            num1 = 1;
            continue;
          case 3:
            d = this.d;
            num1 = 0;
            continue;
          case 4:
            goto label_15;
          default:
            goto label_4;
        }
      }
label_10:
      this.b.a();
      int num2 = this.b.a(16);
      int num3 = this.b.a(16);
      this.g = (num2 & ~num3) == num2 ? num2 : throw new InvalidOperationException();
      this.c = (i) null;
      this.l = true;
      goto label_16;
label_13:
      g[] r = f.r;
      g[] s = f.s;
      this.g = 0;
      this.c = f.t;
      this.l = false;
      goto label_16;
label_14:
      g[] a1;
      g[] a2;
      this.a(this.b, out a1, out a2);
      this.g = 0;
      this.c = f.a(a1, a2);
      this.l = false;
      goto label_16;
label_15:
      throw new InvalidOperationException();
label_16:
      this.i = this.b.e;
      return true;
    }

    private int b(byte[] a1, int a2, int a3)
    {
      int num1 = a2;
      if ((this.d == 0 ? 0 : 1) == 0)
      {
        if (this.g > 0)
        {
          int a = Math.Min(a3, this.g);
label_4:
          int num2 = 3;
          while (true)
          {
            switch (num2)
            {
              case 0:
                a2 += a;
                num2 = 5;
                continue;
              case 1:
                a3 -= a;
                num2 = 0;
                continue;
              case 2:
                this.a.a(a1, a2, a);
                num2 = 4;
                continue;
              case 3:
                this.b.a(a1, a2, a);
                num2 = 2;
                continue;
              case 4:
                this.g -= a;
                num2 = 1;
                continue;
              case 5:
                goto label_22;
              default:
                goto label_4;
            }
          }
        }
      }
      else if (!this.l)
      {
        if (this.k > 0)
          this.a(a1, ref a2, ref a3);
        if (a3 > 0)
        {
          do
          {
            int a = j.a.a(this.b, this.c.a);
            this.l = a == 256;
            if (!this.l)
            {
              if (a < 256)
              {
                a1[a2++] = (byte) a;
                this.a.a((byte) a);
                --a3;
              }
              else if (a <= 285)
              {
                int num3 = j.a.a(this.b, a);
                int num4 = j.a.b(this.b, this.c.b);
                if ((long) num4 > this.a.d)
                  throw new InvalidOperationException();
                this.e = num4;
                this.k = num3;
                this.a(a1, ref a2, ref a3);
              }
            }
            else
              break;
          }
          while (a3 > 0);
        }
      }
label_22:
      this.i = this.b.e;
      return a2 - num1;
    }

    private void a(byte[] a1, ref int a2, ref int a3)
    {
      int num1 = Math.Min(this.k, a3);
      byte[] numArray = this.a.a(this.e, Math.Min(num1, this.e));
      a3 -= num1;
      this.k -= num1;
      while ((num1 <= numArray.Length ? 0 : 1) != 0)
      {
        Array.Copy((Array) numArray, 0, (Array) a1, a2, numArray.Length);
label_3:
        int num2 = 0;
        while (true)
        {
          switch (num2)
          {
            case 0:
              a2 += numArray.Length;
              num2 = 1;
              continue;
            case 1:
              num1 -= numArray.Length;
              num2 = 2;
              continue;
            case 2:
              goto label_6;
            default:
              goto label_3;
          }
        }
label_6:
        this.a.a(numArray, 0, numArray.Length);
      }
      Array.Copy((Array) numArray, 0, (Array) a1, a2, num1);
      a2 += num1;
      this.a.a(numArray, 0, num1);
    }

    public bool a(int a)
    {
      byte[] a1 = new byte[1024];
      int num;
      while (a > 0 && ((num = this.a(a1, 0, Math.Min(1024, a))) <= 0 ? 0 : 1) != 0)
        a -= num;
      return a <= 0;
    }

    public void a()
    {
      byte[] a = new byte[1024];
      do
        ;
      while (this.a(a, 0, 1024) > 0);
    }

    private static int a(j.b a1, h a2)
    {
      while (true)
      {
        if (a2 == null)
          goto label_7;
        else
          goto label_4;
label_3:
        int num;
        while (true)
        {
          switch (num)
          {
            case 0:
              if (a2.a)
              {
                num = 1;
                continue;
              }
              goto label_1;
            case 1:
              goto label_7;
            case 2:
              goto label_9;
            default:
              goto label_4;
          }
        }
label_1:
        a2 = (a1.a(1) <= 0 ? 0 : 1) != 0 ? a2.d : a2.c;
        continue;
label_4:
        num = 0;
        goto label_3;
label_7:
        if (a2 == null)
        {
          num = 2;
          goto label_3;
        }
        else
          goto label_10;
      }
label_9:
      throw new InvalidOperationException();
label_10:
      return (int) a2.b;
    }

    private static int a(j.b a1, int a2)
    {
      int a3;
      int a4;
      f.a(a2, out a3, out a4);
label_2:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            if (a4 > 0)
            {
              num = 1;
              continue;
            }
            goto label_6;
          case 1:
            goto label_5;
          default:
            goto label_2;
        }
      }
label_5:
      return a3 + a1.a(a4);
label_6:
      return a3;
    }

    private static int b(j.b a1, h a2)
    {
      int index = j.a.a(a1, a2);
      int num1 = index <= 29 ? f.x[index] : throw new InvalidOperationException();
label_4:
      int num2 = 1;
      int a;
      int num3;
      while (true)
      {
        switch (num2)
        {
          case 0:
            if (a > 0)
            {
              num2 = 4;
              continue;
            }
            goto label_15;
          case 1:
            a = f.y[index];
            num2 = 0;
            continue;
          case 2:
            if (index == 284)
            {
              num2 = 3;
              continue;
            }
            goto label_14;
          case 3:
            if (num3 > 30)
            {
              num2 = 5;
              continue;
            }
            goto label_14;
          case 4:
            num3 = a1.a(a);
            num2 = 2;
            continue;
          case 5:
            goto label_13;
          default:
            goto label_4;
        }
      }
label_13:
      throw new InvalidOperationException();
label_14:
      return num1 + num3;
label_15:
      return num1;
    }

    private void a(j.b a1, out g[] a2, out g[] a3)
    {
      int length1 = a1.a(5) + 257;
label_2:
      int num1 = 1;
      int num2;
      int length2;
      while (true)
      {
        switch (num1)
        {
          case 0:
            num2 = a1.a(4) + 4;
            num1 = 2;
            continue;
          case 1:
            length2 = a1.a(5) + 1;
            num1 = 0;
            continue;
          case 2:
            if (length1 > 286)
            {
              num1 = 3;
              continue;
            }
            goto label_8;
          case 3:
            goto label_7;
          default:
            goto label_2;
        }
      }
label_7:
      throw new InvalidOperationException();
label_8:
      int[] u = f.u;
      int[] a4 = new int[19];
      int index1 = 0;
      if ((index1 == 0 ? 1 : 0) != 0)
        goto label_10;
label_9:
      a4[u[index1]] = a1.a(3);
      ++index1;
label_10:
      if (index1 >= num2)
      {
        h a5 = f.a(f.a(a4));
        int[] numArray = j.a.a(a1, a5, length1 + length2);
        a2 = new g[length1];
        for (int index2 = 0; index2 < length1; ++index2)
          a2[index2].b = numArray[index2];
        f.a(a2);
        a3 = new g[length2];
        for (int index3 = 0; index3 < length2; ++index3)
          a3[index3].b = numArray[index3 + length1];
        f.a(a3);
      }
      else
        goto label_9;
    }

    private static int[] a(j.b a1, h a2, int a3)
    {
      int[] numArray = new int[a3];
      int index1 = 0;
      if ((index1 == 0 ? 1 : 0) != 0)
        goto label_22;
label_1:
      int num1 = j.a.a(a1, a2);
label_3:
      int num2 = 1;
      while (true)
      {
        switch (num2)
        {
          case 0:
            numArray[index1] = num1;
            num2 = 2;
            continue;
          case 1:
            if (num1 < 16)
            {
              num2 = 0;
              continue;
            }
            goto label_7;
          case 2:
            goto label_21;
          default:
            goto label_3;
        }
      }
label_7:
      switch (num1)
      {
        case 16:
          int num3 = a1.a(2) + 3;
          if (num3 + index1 > numArray.Length)
            throw new InvalidOperationException();
          for (int index2 = 0; index2 < num3; ++index2)
            numArray[index1 + index2] = numArray[index1 - 1];
          index1 += num3 - 1;
          break;
        case 17:
          int num4 = a1.a(3) + 3;
          if (num4 + index1 > numArray.Length)
            throw new InvalidOperationException();
          index1 += num4 - 1;
          break;
        case 18:
          int num5 = a1.a(7) + 11;
          if (num5 + index1 > numArray.Length)
            throw new InvalidOperationException();
          index1 += num5 - 1;
          break;
        default:
          throw new InvalidOperationException();
      }
label_21:
      ++index1;
label_22:
      if (index1 >= a3)
        return numArray;
      goto label_1;
    }
  }

  private sealed class b
  {
    private uint a;
    private int b;
    private int c;
    private Stream d;
    internal long e;

    internal b(Stream a) => this.d = a;

    internal int a(int a)
    {
      this.e += (long) a;
      for (int index = a - (this.c - this.b); (index <= 0 ? 0 : 1) != 0; index -= 8)
      {
        this.a |= checked ((uint) this.d.ReadByte()) << this.c;
        this.c += 8;
      }
      int num1 = (int) (this.a >> this.b) & (1 << a) - 1;
label_5:
      int num2 = 2;
      while (true)
      {
        switch (num2)
        {
          case 0:
            this.c = this.b = 0;
            num2 = 1;
            continue;
          case 1:
            this.a = 0U;
            num2 = 4;
            continue;
          case 2:
            this.b += a;
            num2 = 3;
            continue;
          case 3:
            if (this.c == this.b)
            {
              num2 = 0;
              continue;
            }
            goto label_11;
          case 4:
            goto label_13;
          default:
            goto label_5;
        }
      }
label_11:
      if (this.b >= 8)
      {
        this.a >>= this.b;
        this.c -= this.b;
        this.b = 0;
      }
label_13:
      return num1;
    }

    internal void a()
    {
      if (this.c != this.b)
        this.e += (long) (this.c - this.b);
      this.c = this.b = 0;
label_4:
      int num = 0;
      while (true)
      {
        switch (num)
        {
          case 0:
            this.a = 0U;
            num = 1;
            continue;
          case 1:
            goto label_6;
          default:
            goto label_4;
        }
      }
label_6:;
    }

    internal void a(byte[] a1, int a2, int a3)
    {
      if (this.c != this.b)
        throw new InvalidOperationException();
      int num1 = this.d.Read(a1, a2, a3);
label_4:
      int num2 = 0;
      while (true)
      {
        switch (num2)
        {
          case 0:
            this.e += (long) (num1 << 3);
            num2 = 1;
            continue;
          case 1:
            if (num1 != a3)
            {
              num2 = 2;
              continue;
            }
            goto label_7;
          case 2:
            goto label_9;
          default:
            goto label_4;
        }
      }
label_7:
      return;
label_9:
      throw new InvalidOperationException();
    }
  }

  private sealed class c
  {
    private byte[] a;
    private int b;
    internal int c;
    internal long d;

    internal c(int a)
    {
      this.c = a;
      this.a = new byte[a];
    }

    internal void a(byte a)
    {
      this.a[this.b++] = a;
      if ((this.b >= this.c ? 0 : 1) == 0)
        this.b = 0;
      ++this.d;
    }

    internal void a(byte[] a1, int a2, int a3)
    {
      this.d += (long) a3;
      if ((a3 >= this.c ? 0 : 1) == 0)
      {
        Array.Copy((Array) a1, a2, (Array) this.a, 0, this.c);
        this.b = 0;
      }
      else if (this.b + a3 > this.c)
      {
        int length1 = this.c - this.b;
label_5:
        int num = 2;
        int length2;
        while (true)
        {
          switch (num)
          {
            case 0:
              Array.Copy((Array) a1, a2 + length1, (Array) this.a, 0, length2);
              num = 1;
              continue;
            case 1:
              this.b = length2;
              num = 4;
              continue;
            case 2:
              length2 = this.b + a3 - this.c;
              num = 3;
              continue;
            case 3:
              Array.Copy((Array) a1, a2, (Array) this.a, this.b, length1);
              num = 0;
              continue;
            case 4:
              goto label_12;
            default:
              goto label_5;
          }
        }
label_12:;
      }
      else
      {
        Array.Copy((Array) a1, a2, (Array) this.a, this.b, a3);
        this.b += a3;
        if (this.b != this.c)
          return;
        this.b = 0;
      }
    }

    internal byte[] a(int a1, int a2)
    {
      byte[] destinationArray = new byte[a2];
      if ((this.b >= a1 ? 0 : 1) == 0)
      {
        Array.Copy((Array) this.a, this.b - a1, (Array) destinationArray, 0, a2);
      }
      else
      {
        int num1 = a1 - this.b;
label_4:
        int num2 = 1;
        while (true)
        {
          switch (num2)
          {
            case 0:
              Array.Copy((Array) this.a, 0, (Array) destinationArray, num1, a2 - num1);
              num2 = 3;
              continue;
            case 1:
              if (num1 < a2)
              {
                num2 = 2;
                continue;
              }
              goto label_9;
            case 2:
              Array.Copy((Array) this.a, this.c - num1, (Array) destinationArray, 0, num1);
              num2 = 0;
              continue;
            case 3:
              goto label_10;
            default:
              goto label_4;
          }
        }
label_9:
        Array.Copy((Array) this.a, this.c - num1, (Array) destinationArray, 0, a2);
      }
label_10:
      return destinationArray;
    }
  }
}
