// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Description.FormatSelectingMessageInspector
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Mime;
using System.ServiceModel.Channels;
using System.ServiceModel.Diagnostics;
using System.ServiceModel.Dispatcher;
using System.ServiceModel.Web;

namespace System.ServiceModel.Description
{
  internal class FormatSelectingMessageInspector : IDispatchMessageInspector
  {
    private static readonly IEnumerable<string> wildcardMediaTypes = (IEnumerable<string>) new List<string>()
    {
      "application",
      "text"
    };
    private List<MultiplexingFormatMapping> mappings;
    private Dictionary<string, MultiplexingDispatchMessageFormatter> formatters;
    private Dictionary<string, NameValueCache<FormatSelectingMessageInspector.FormatContentTypePair>> caches;
    private bool automaticFormatSelectionEnabled;
    private static readonly int maxCachedAcceptHeaders = 25;

    public FormatSelectingMessageInspector(
      WebHttpBehavior webHttpBehavior,
      List<MultiplexingFormatMapping> mappings)
    {
      if (webHttpBehavior == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (webHttpBehavior));
      if (mappings == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (mappings));
      this.automaticFormatSelectionEnabled = webHttpBehavior.AutomaticFormatSelectionEnabled;
      this.formatters = new Dictionary<string, MultiplexingDispatchMessageFormatter>();
      this.caches = new Dictionary<string, NameValueCache<FormatSelectingMessageInspector.FormatContentTypePair>>();
      this.mappings = mappings;
    }

    public void RegisterOperation(
      string operationName,
      MultiplexingDispatchMessageFormatter formatter)
    {
      if (formatter == null)
        throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (formatter));
      this.formatters.Add(operationName, formatter);
      this.caches.Add(operationName, new NameValueCache<FormatSelectingMessageInspector.FormatContentTypePair>(FormatSelectingMessageInspector.maxCachedAcceptHeaders));
    }

    public object AfterReceiveRequest(
      ref Message request,
      IClientChannel channel,
      InstanceContext instanceContext)
    {
      if (this.automaticFormatSelectionEnabled)
      {
        MessageProperties messageProperties = OperationContext.Current.IncomingMessageProperties;
        if (messageProperties.ContainsKey("HttpOperationName"))
        {
          string str = messageProperties["HttpOperationName"] as string;
          if (!string.IsNullOrEmpty(str) && this.formatters.ContainsKey(str))
          {
            string accept = WebOperationContext.Current.IncomingRequest.Accept;
            if (!string.IsNullOrEmpty(accept) && (this.TrySetFormatFromCache(str, accept) || this.TrySetFormatFromAcceptHeader(str, accept, true) || this.TrySetFormatFromAcceptHeader(str, accept, false)))
              return (object) null;
            if (this.TrySetFormatFromContentType(str))
              return (object) null;
            this.SetFormatFromDefault(str);
          }
        }
      }
      return (object) null;
    }

    public void BeforeSendReply(ref Message reply, object correlationState)
    {
    }

    private bool TrySetFormatFromCache(string operationName, string acceptHeader)
    {
      FormatSelectingMessageInspector.FormatContentTypePair formatContentTypePair = this.caches[operationName].Lookup(acceptHeader.ToUpperInvariant());
      if (formatContentTypePair == null)
        return false;
      this.SetFormatAndContentType(formatContentTypePair.Format, formatContentTypePair.ContentType);
      return true;
    }

    private bool TrySetFormatFromAcceptHeader(
      string operationName,
      string acceptHeader,
      bool matchCharSet)
    {
      IList<ContentType> acceptHeaderElements = (IList<ContentType>) WebOperationContext.Current.IncomingRequest.GetAcceptHeaderElements();
      for (int index = 0; index < acceptHeaderElements.Count; ++index)
      {
        string[] strArray = acceptHeaderElements[index].MediaType.Split('/');
        string lowerInvariant = strArray[0].Trim().ToLowerInvariant();
        string str = strArray[1].Trim();
        if (str[0] == '*' && str.Length == 1 && (lowerInvariant[0] == '*' && lowerInvariant.Length == 1 || FormatSelectingMessageInspector.wildcardMediaTypes.Contains<string>(lowerInvariant)))
        {
          this.SetFormatFromDefault(operationName, acceptHeader);
          return true;
        }
        foreach (MultiplexingFormatMapping mapping in this.mappings)
        {
          WebMessageFormat messageFormat = mapping.MessageFormat;
          ContentType contentType1;
          if (this.formatters[operationName].SupportsMessageFormat(messageFormat) && mapping.CanFormatResponse(acceptHeaderElements[index], matchCharSet, out contentType1))
          {
            string contentType2 = contentType1.ToString();
            this.caches[operationName].AddOrUpdate(acceptHeader.ToUpperInvariant(), new FormatSelectingMessageInspector.FormatContentTypePair(messageFormat, contentType2));
            this.SetFormatAndContentType(messageFormat, contentType2);
            return true;
          }
        }
      }
      return false;
    }

    private bool TrySetFormatFromContentType(string operationName)
    {
      string contentType1 = WebOperationContext.Current.IncomingRequest.ContentType;
      if (contentType1 != null)
      {
        ContentType contentType2 = System.ServiceModel.Web.Utility.GetContentType(contentType1);
        if (contentType2 != null)
        {
          foreach (MultiplexingFormatMapping mapping in this.mappings)
          {
            ContentType contentType3;
            if (this.formatters[operationName].SupportsMessageFormat(mapping.MessageFormat) && mapping.CanFormatResponse(contentType2, false, out contentType3))
            {
              this.SetFormatAndContentType(mapping.MessageFormat, contentType3.ToString());
              return true;
            }
          }
        }
      }
      return false;
    }

    private void SetFormatFromDefault(string operationName) => this.SetFormatFromDefault(operationName, (string) null);

    private void SetFormatFromDefault(string operationName, string acceptHeader)
    {
      WebMessageFormat defaultFormat = this.formatters[operationName].DefaultFormat;
      if (!string.IsNullOrEmpty(acceptHeader))
        this.caches[operationName].AddOrUpdate(acceptHeader.ToUpperInvariant(), new FormatSelectingMessageInspector.FormatContentTypePair(defaultFormat, (string) null));
      WebOperationContext.Current.OutgoingResponse.Format = new WebMessageFormat?(defaultFormat);
      if (!DiagnosticUtility.ShouldTraceInformation)
        return;
      // ISSUE: reference to a compiler-generated method
      TraceUtility.TraceEvent(TraceEventType.Information, 983088, SR2.GetString(SR2.TraceCodeAutomaticFormatSelectedOperationDefault, (object) defaultFormat.ToString()));
    }

    private void SetFormatAndContentType(WebMessageFormat format, string contentType)
    {
      OutgoingWebResponseContext outgoingResponse = WebOperationContext.Current.OutgoingResponse;
      outgoingResponse.Format = new WebMessageFormat?(format);
      outgoingResponse.AutomatedFormatSelectionContentType = contentType;
      if (!DiagnosticUtility.ShouldTraceInformation)
        return;
      // ISSUE: reference to a compiler-generated method
      TraceUtility.TraceEvent(TraceEventType.Information, 983089, SR2.GetString(SR2.TraceCodeAutomaticFormatSelectedRequestBased, (object) format.ToString(), (object) contentType));
    }

    private class FormatContentTypePair
    {
      private WebMessageFormat format;
      private string contentType;

      public FormatContentTypePair(WebMessageFormat format, string contentType)
      {
        this.format = format;
        this.contentType = contentType;
      }

      public WebMessageFormat Format => this.format;

      public string ContentType => this.contentType;
    }
  }
}
