// Decompiled with JetBrains decompiler
// Type: .
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u0015;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace \u0006
{
  internal class \u0005 : 
    \u0013,
    IEquatable<\u0006.\u0005>,
    IComparable<\u0006.\u0005>,
    IFormattable,
    IComparable,
    IConvertible
  {
    internal JTokenType \u0001;
    internal new object \u0001;
    [NonSerialized]
    internal static GetString \u0002;

    internal \u0005([In] object obj0, [In] JTokenType obj1)
    {
      this.\u0001 = obj0;
      this.\u0001 = obj1;
    }

    public \u0005([In] \u0006.\u0005 obj0)
      : this(obj0.\u0001, ((\u0013) obj0).\u0001())
    {
    }

    public \u0005([In] object obj0)
    {
      object obj = obj0;
      JTokenType? nullable = new JTokenType?();
      int num = (int) \u0014.\u0006.\u0001(obj0, nullable);
      // ISSUE: explicit constructor call
      this.\u002Ector(obj, (JTokenType) num);
    }

    [SpecialName]
    public override bool \u0001() => false;

    internal static unsafe int \u0001([In] JTokenType obj0, [In] object obj1, [In] object obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(10);
      if (false)
        goto label_15;
      else
        goto label_39;
label_3:
      int num = 1;
      return num == 0 ? num : num;
label_15:
      *(sbyte*) ((IntPtr) voidPtr + 9) = (sbyte) \u0090\u0003.\u0081\u0007(obj2, (IFormatProvider) \u0098.\u0002\u0004());
      if (true)
        return ((bool*) ((IntPtr) voidPtr + 8))->CompareTo((bool) *(sbyte*) ((IntPtr) voidPtr + 9));
      goto label_3;
label_39:
      if (obj1 == null)
      {
        if (true)
        {
          if (obj2 == null)
            return 0;
          goto label_41;
        }
      }
      else
        goto label_41;
label_9:
      if (!(obj2 is double))
      {
        *(long*) voidPtr = \u0082\u0003.\u0014\u0007(obj1, (IFormatProvider) \u0098.\u0002\u0004());
        return ((long*) voidPtr)->CompareTo(\u0082\u0003.\u0014\u0007(obj2, (IFormatProvider) \u0098.\u0002\u0004()));
      }
label_10:
      return \u0006.\u0005.\u0001(obj1, obj2);
label_41:
      if (obj1 == null || obj2 != null)
      {
        if (obj1 == null && obj2 != null)
          return -1;
        switch (obj0)
        {
          case JTokenType.Comment:
          case JTokenType.String:
          case JTokenType.Raw:
            return \u008E\u0005.\u008A\u000E(\u0095\u0002.\u0017\u0006(obj1, (IFormatProvider) \u0098.\u0002\u0004()), \u0095\u0002.\u0017\u0006(obj2, (IFormatProvider) \u0098.\u0002\u0004()));
          case JTokenType.Integer:
            if (obj1 is ulong || obj2 is ulong || obj1 is Decimal || obj2 is Decimal)
              return \u008A\u0002.\u0001\u0006(obj1, (IFormatProvider) \u0098.\u0002\u0004()).CompareTo(\u008A\u0002.\u0001\u0006(obj2, (IFormatProvider) \u0098.\u0002\u0004()));
            if (obj1 is float || obj2 is float || obj1 is double)
              goto label_10;
            else
              goto label_9;
          case JTokenType.Float:
            return \u0006.\u0005.\u0001(obj1, obj2);
          case JTokenType.Boolean:
            *(sbyte*) ((IntPtr) voidPtr + 8) = (sbyte) \u0090\u0003.\u0081\u0007(obj1, (IFormatProvider) \u0098.\u0002\u0004());
            goto label_15;
          case JTokenType.Date:
            if (obj1 is DateTime dateTime1)
            {
              DateTime dateTime = !(obj2 is DateTimeOffset dateTimeOffset) ? \u0091\u0003.\u0082\u0007(obj2, (IFormatProvider) \u0098.\u0002\u0004()) : dateTimeOffset.DateTime;
              return dateTime1.CompareTo(dateTime);
            }
            DateTimeOffset dateTimeOffset1 = (DateTimeOffset) obj1;
            if (!(obj2 is DateTimeOffset other))
              other = new DateTimeOffset(\u0091\u0003.\u0082\u0007(obj2, (IFormatProvider) \u0098.\u0002\u0004()));
            return dateTimeOffset1.CompareTo(other);
          case JTokenType.Bytes:
            if (!(obj2 is byte[]))
              throw new ArgumentException(\u0006.\u0005.\u0002(27342));
            byte[] numArray1 = obj1 as byte[];
            byte[] numArray2 = obj2 as byte[];
            if (numArray1 == null)
              return -1;
            return numArray2 == null ? 1 : \u0008.\u0008.\u0001(numArray1, numArray2);
          case JTokenType.Guid:
            return obj2 is Guid guid ? ((Guid) obj1).CompareTo(guid) : throw new ArgumentException(\u0006.\u0005.\u0002(27383));
          case JTokenType.Uri:
            if (!(obj2 is Uri))
              throw new ArgumentException(\u0006.\u0005.\u0002(27424));
            Uri uri1 = (Uri) obj1;
            Uri uri2 = (Uri) obj2;
            return Comparer<string>.Default.Compare(\u0001.\u007E\u0001((object) uri1), \u0001.\u007E\u0001((object) uri2));
          case JTokenType.TimeSpan:
            return obj2 is TimeSpan timeSpan ? ((TimeSpan) obj1).CompareTo(timeSpan) : throw new ArgumentException(\u0006.\u0005.\u0002(27461));
          default:
            throw \u0014.\u0006.\u0001(\u0006.\u0005.\u0002(27506), (object) obj0, \u0002.\u0002.\u0001(\u0006.\u0005.\u0002(27519), (IFormatProvider) \u0098.\u0002\u0004(), (object) obj0));
        }
      }
      else
        goto label_3;
    }

    private static unsafe int \u0001([In] object obj0, [In] object obj1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(16);
      *(double*) voidPtr = \u008B\u0002.\u0002\u0006(obj0, (IFormatProvider) \u0098.\u0002\u0004());
      *(double*) ((IntPtr) voidPtr + 8) = \u008B\u0002.\u0002\u0006(obj1, (IFormatProvider) \u0098.\u0002\u0004());
      return \u0014.\u0006.\u0001(*(double*) voidPtr, *(double*) ((IntPtr) voidPtr + 8)) ? 0 : ((double*) voidPtr)->CompareTo(*(double*) ((IntPtr) voidPtr + 8));
    }

    internal override \u0013 \u0001() => (\u0013) new \u0006.\u0005(this);

    [SpecialName]
    public override JTokenType \u0001() => this.\u0001;

    public override void \u0001([In] JsonWriter obj0, [In] \u0005.\u0005[] obj1)
    {
      if (obj1 != null && obj1.Length != 0 && this.\u0001 != null)
        goto label_32;
label_2:
      switch (this.\u0001)
      {
        case JTokenType.Comment:
          obj0.\u0005(this.\u0001 != null ? \u0001.\u007E\u0001(this.\u0001) : (string) null);
          return;
        case JTokenType.Integer:
          if (this.\u0001 is int)
          {
            obj0.\u0001((int) this.\u0001);
            return;
          }
          if (this.\u0001 is long)
          {
            obj0.\u0001((long) this.\u0001);
            return;
          }
          if (this.\u0001 is ulong)
          {
            obj0.\u0001((ulong) this.\u0001);
            return;
          }
          obj0.\u0001(\u0082\u0003.\u0014\u0007(this.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        case JTokenType.Float:
          if (this.\u0001 is Decimal)
          {
            obj0.\u0001((Decimal) this.\u0001);
            return;
          }
          if (this.\u0001 is double)
          {
            obj0.\u0001((double) this.\u0001);
            return;
          }
          if (this.\u0001 is float)
          {
            obj0.\u0001((float) this.\u0001);
            return;
          }
          obj0.\u0001(\u008B\u0002.\u0002\u0006(this.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        case JTokenType.String:
          obj0.\u0004(this.\u0001 != null ? \u0001.\u007E\u0001(this.\u0001) : (string) null);
          return;
        case JTokenType.Boolean:
          obj0.\u0001(\u0090\u0003.\u0081\u0007(this.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        case JTokenType.Null:
          obj0.\u0008();
          if (false)
            ;
          return;
        case JTokenType.Undefined:
          obj0.\u000E();
          return;
        case JTokenType.Date:
          if (this.\u0001 is DateTimeOffset)
          {
            obj0.\u0001((DateTimeOffset) this.\u0001);
            return;
          }
          obj0.\u0001(\u0091\u0003.\u0082\u0007(this.\u0001, (IFormatProvider) \u0098.\u0002\u0004()));
          return;
        case JTokenType.Raw:
          obj0.\u0006(this.\u0001 != null ? \u0001.\u007E\u0001(this.\u0001) : (string) null);
          return;
        case JTokenType.Bytes:
          obj0.\u0001((byte[]) this.\u0001);
          return;
        case JTokenType.Guid:
        case JTokenType.TimeSpan:
          obj0.\u0004(this.\u0001 != null ? \u0001.\u007E\u0001(this.\u0001) : (string) null);
          return;
        case JTokenType.Uri:
          obj0.\u0004(this.\u0001 != null ? \u0001.\u007E\u0007((object) (Uri) this.\u0001) : (string) null);
          return;
        default:
          throw \u0014.\u0006.\u0001(\u0006.\u0005.\u0002(27556), (object) this.\u0001, \u0006.\u0005.\u0002(13961));
      }
label_32:
      \u0005.\u0005 obj = \u0014.\u0006.\u0001((IList<\u0005.\u0005>) obj1, \u0001\u0002.\u007E\u0017\u0004(this.\u0001));
      if (obj != null && obj.\u0001())
        obj.\u0001(obj0, this.\u0001, \u0014.\u0006.\u0001());
      else
        goto label_2;
    }

    public bool \u0001([In] \u0006.\u0005 obj0) => obj0 != null && \u0014.\u0006.\u0001(this, obj0);

    public override bool Equals([In] object obj0)
    {
      while (obj0 == null)
      {
        if (true)
          return false;
      }
      \u0006.\u0005 obj;
      do
      {
        if (true)
          obj = obj0 as \u0006.\u0005;
        if (obj == null)
          goto label_7;
      }
      while (false);
      goto label_10;
label_7:
      int num = \u0006\u0002.\u0089\u0004((object) this, obj0) ? 1 : 0;
      return false ? num != 0 : num != 0;
label_10:
      return this.\u0001(obj);
    }

    public override int GetHashCode() => this.\u0001 == null ? 0 : \u001F.\u007E\u0014\u0003(this.\u0001);

    public override string ToString() => this.\u0001 == null ? string.Empty : \u0001.\u007E\u0001(this.\u0001);

    public string \u0001([In] IFormatProvider obj0) => this.\u0001((string) null, obj0);

    public string \u0001([In] string obj0, [In] IFormatProvider obj1)
    {
      while (this.\u0001 != null)
      {
        if (true)
        {
          IFormattable formattable = this.\u0001 as IFormattable;
          while (formattable == null)
          {
            if (true)
              return \u0001.\u007E\u0001(this.\u0001);
          }
          return \u0002\u0002.\u007E\u0082\u0004((object) formattable, obj0, obj1);
        }
      }
      return string.Empty;
    }

    int IComparable.\u0001([In] object obj0)
    {
      while (obj0 != null)
      {
        if (true)
        {
          object obj1;
          if (!(obj0 is \u0006.\u0005))
          {
            if (true)
              obj1 = obj0;
            else
              goto label_10;
          }
          else
            obj1 = ((\u0006.\u0005) obj0).\u0001;
          object obj2 = obj1;
label_10:
          return \u0006.\u0005.\u0001(this.\u0001, this.\u0001, obj2);
        }
      }
      int num = 1;
      return num == 0 ? num : num;
    }

    public int \u0001([In] \u0006.\u0005 obj0)
    {
      if (obj0 == null)
        return 1;
      int num = \u0006.\u0005.\u0001(this.\u0001, this.\u0001, obj0.\u0001);
      return false ? num : num;
    }

    TypeCode IConvertible.\u0001()
    {
      if (this.\u0001 == null)
        return TypeCode.Empty;
      IConvertible convertible = this.\u0001 as IConvertible;
      while (convertible != null)
      {
        if (true)
          return \u0018\u0004.\u007E\u0010\u0008((object) convertible);
      }
      return TypeCode.Object;
    }

    bool IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    char IConvertible.\u0001([In] IFormatProvider obj0) => \u0013.\u0001((\u0013) this);

    sbyte IConvertible.\u0001([In] IFormatProvider obj0) => \u0013.\u0001((\u0013) this);

    byte IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    short IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    ushort IConvertible.\u0001([In] IFormatProvider obj0) => \u0013.\u0001((\u0013) this);

    int IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    uint IConvertible.\u0001([In] IFormatProvider obj0) => \u0013.\u0001((\u0013) this);

    long IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    ulong IConvertible.\u0001([In] IFormatProvider obj0) => \u0013.\u0001((\u0013) this);

    float IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    double IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    Decimal IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    DateTime IConvertible.\u0001([In] IFormatProvider obj0) => \u0014.\u0006.\u0001((\u0013) this);

    object IConvertible.\u0001([In] Type obj0, [In] IFormatProvider obj1) => \u0014.\u0006.\u0001((\u0013) this, obj0);

    static \u0005() => Strings.CreateGetStringDelegate(typeof (\u0006.\u0005));
  }
}
