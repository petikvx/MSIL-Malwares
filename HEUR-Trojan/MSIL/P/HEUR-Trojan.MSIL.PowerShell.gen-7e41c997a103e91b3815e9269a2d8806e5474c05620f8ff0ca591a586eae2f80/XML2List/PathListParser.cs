// Decompiled with JetBrains decompiler
// Type: XML2List.PathListParser
// Assembly: LeaseMana, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 529A6AA6-AEB5-47F3-B86B-C5E3C5F9FA62
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-7e41c997a103e91b3815e9269a2d8806e5474c05620f8ff0ca591a586eae2f80.exe

using MyExtensions;
using PathLibrary;
using System;
using System.Collections.Generic;
using System.Linq;

namespace XML2List
{
  public class PathListParser
  {
    public CommandLists ParsePaths(string[] pathsToParse)
    {
      if (pathsToParse.Length == 0)
        throw new ArgumentException("Array is empty");
      CommandLists commandLists = new CommandLists();
      return pathsToParse.Length != 1 ? this.parseManyPaths(pathsToParse) : this.parseOnePath(pathsToParse);
    }

    private CommandLists parseOnePath(string[] pathsToParse)
    {
      CommandLists commandLists = new CommandLists();
      string str = pathsToParse[0];
      string commonParent = str.Substring(0, str.LastIndexOf('/'));
      pathsToParse[0] = ((IEnumerable<string>) pathsToParse[0].Split('/')).Last<string>();
      return this.createCommands(pathsToParse, commonParent);
    }

    private CommandLists parseManyPaths(string[] pathsToParse)
    {
      CommandLists commandLists = new CommandLists();
      string commonParent = PathTools.GetCommonParent(pathsToParse);
      pathsToParse = PathTools.FilterNotCommonParent(commonParent, pathsToParse);
      return this.createCommands(pathsToParse, commonParent);
    }

    private CommandLists createCommands(string[] pathsToParse, string commonParent)
    {
      CommandLists commands = new CommandLists();
      foreach (string pathPart in ((IEnumerable<string>) commonParent.Split('/')).Where<string>((Func<string, bool>) (x => x.IsNotEmptyOrNull())))
      {
        IElementGroupSelect groupCommand = this.getGroupCommand(pathPart);
        if (groupCommand.IsNotNull())
          commands.GroupSelectCommands.Add(groupCommand);
      }
      foreach (string pathPart in pathsToParse)
      {
        IItemSelect itemCommand = this.getItemCommand(pathPart);
        if (itemCommand.IsNotNull())
          commands.ItemSelectCommands.Add(itemCommand);
      }
      return commands;
    }

    private IItemSelect getItemCommand(string pathPart)
    {
      string attributes = PathTools.GetAttributes(pathPart);
      if (attributes == null)
        return (IItemSelect) new ElementSelector(pathPart);
      PathAttributeValueGroup[] attributeValue = PathTools.GetAttributeValue(attributes);
      return (IItemSelect) new ElementAttributeValueSelector(PathTools.RemoveAttributes(pathPart), attributeValue);
    }

    private IElementGroupSelect getGroupCommand(string pathPart) => (IElementGroupSelect) new ElementsGroupSelector(PathTools.RemoveAttributes(pathPart));
  }
}
