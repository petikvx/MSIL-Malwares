// Decompiled with JetBrains decompiler
// Type: SmartAssembly.Zip.SimpleZip
// Assembly: Worker-0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6E50A6D0-CF23-40BF-9617-750EB84D00C0
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.Win32.Generic-122df846a943e419c3a31f65b6e67e7570134612b2dfd45638e0edd23e214036.exe

using System;
using System.IO;
using System.Security.Cryptography;

namespace SmartAssembly.Zip
{
  public static class SimpleZip
  {
    private static ICryptoTransform GetAesTransform(byte[] p0, byte[] p1, bool p2)
    {
      using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
        return p2 ? cryptoServiceProvider.CreateDecryptor(p0, p1) : cryptoServiceProvider.CreateEncryptor(p0, p1);
    }

    public static byte[] Unzip(byte[] p0)
    {
      SimpleZip.ZipStream zipStream = new SimpleZip.ZipStream(p0);
      byte[] p0_1 = new byte[0];
      int num = zipStream.ReadInt();
      int actualValue = num >> 24;
      if (num - (actualValue << 24) != 8223355)
        throw new FormatException("Unknown Header");
      switch (actualValue)
      {
        case 1:
          int length1 = zipStream.ReadInt();
          p0_1 = new byte[length1];
          int p2;
          for (int p1 = 0; p1 < length1; p1 += p2)
          {
            int length2 = zipStream.ReadInt();
            p2 = zipStream.ReadInt();
            byte[] numArray = new byte[length2];
            zipStream.Read(numArray, 0, numArray.Length);
            new SimpleZip.Inflater(numArray).Inflate(p0_1, p1, p2);
          }
          break;
        case 3:
          using (ICryptoTransform aesTransform = SimpleZip.GetAesTransform(new byte[16]
          {
            (byte) 209,
            (byte) 187,
            (byte) 86,
            (byte) 181,
            (byte) 128,
            (byte) 102,
            (byte) 49,
            (byte) 174,
            (byte) 50,
            (byte) 170,
            (byte) 253,
            (byte) 108,
            (byte) 83,
            (byte) 33,
            (byte) 38,
            (byte) 254
          }, new byte[16]
          {
            (byte) 181,
            (byte) 187,
            (byte) 11,
            (byte) 196,
            (byte) 157,
            (byte) 207,
            (byte) 41,
            (byte) 3,
            (byte) 133,
            (byte) 123,
            (byte) 241,
            (byte) 71,
            (byte) 115,
            (byte) 220,
            (byte) 139,
            (byte) 10
          }, true))
          {
            p0_1 = SimpleZip.Unzip(aesTransform.TransformFinalBlock(p0, 4, p0.Length - 4));
            break;
          }
        default:
          throw new ArgumentOutOfRangeException("version", (object) actualValue, "Selected compression algorithm is not supported.");
      }
      zipStream.Close();
      return p0_1;
    }

    internal sealed class Inflater
    {
      private static readonly int[] CPLENS = new int[29]
      {
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258
      };
      private static readonly int[] CPLEXT = new int[29]
      {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0
      };
      private static readonly int[] CPDIST = new int[30]
      {
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577
      };
      private static readonly int[] CPDEXT = new int[30]
      {
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13
      };
      private int mode;
      private int neededBits;
      private int repLength;
      private int repDist;
      private int uncomprLen;
      private bool isLastBlock;
      private SimpleZip.StreamManipulator input;
      private SimpleZip.OutputWindow outputWindow;
      private SimpleZip.InflaterDynHeader dynHeader;
      private SimpleZip.InflaterHuffmanTree litlenTree;
      private SimpleZip.InflaterHuffmanTree distTree;

      public Inflater(byte[] p0)
      {
        this.input = new SimpleZip.StreamManipulator();
        this.outputWindow = new SimpleZip.OutputWindow();
        this.mode = 2;
        this.input.SetInput(p0, 0, p0.Length);
      }

      private bool DecodeHuffmen()
      {
        int freeSpace = this.outputWindow.GetFreeSpace();
        while (freeSpace >= 258)
        {
          switch (this.mode)
          {
            case 7:
              int symbol1;
              while (((symbol1 = this.litlenTree.GetSymbol(this.input)) & -256) == 0)
              {
                this.outputWindow.Write(symbol1);
                if (--freeSpace < 258)
                  return true;
              }
              if (symbol1 >= 257)
              {
                this.repLength = SimpleZip.Inflater.CPLENS[symbol1 - 257];
                this.neededBits = SimpleZip.Inflater.CPLEXT[symbol1 - 257];
                goto case 8;
              }
              else
              {
                if (symbol1 < 0)
                  return false;
                this.distTree = (SimpleZip.InflaterHuffmanTree) null;
                this.litlenTree = (SimpleZip.InflaterHuffmanTree) null;
                this.mode = 2;
                return true;
              }
            case 8:
              if (this.neededBits > 0)
              {
                this.mode = 8;
                int num = this.input.PeekBits(this.neededBits);
                if (num < 0)
                  return false;
                this.input.DropBits(this.neededBits);
                this.repLength += num;
              }
              this.mode = 9;
              goto case 9;
            case 9:
              int symbol2 = this.distTree.GetSymbol(this.input);
              if (symbol2 < 0)
                return false;
              this.repDist = SimpleZip.Inflater.CPDIST[symbol2];
              this.neededBits = SimpleZip.Inflater.CPDEXT[symbol2];
              goto case 10;
            case 10:
              if (this.neededBits > 0)
              {
                this.mode = 10;
                int num = this.input.PeekBits(this.neededBits);
                if (num < 0)
                  return false;
                this.input.DropBits(this.neededBits);
                this.repDist += num;
              }
              this.outputWindow.Repeat(this.repLength, this.repDist);
              freeSpace -= this.repLength;
              this.mode = 7;
              continue;
            default:
              continue;
          }
        }
        return true;
      }

      private bool Decode()
      {
        switch (this.mode)
        {
          case 2:
            if (this.isLastBlock)
            {
              this.mode = 12;
              return false;
            }
            int num = this.input.PeekBits(3);
            if (num < 0)
              return false;
            this.input.DropBits(3);
            if ((num & 1) != 0)
              this.isLastBlock = true;
            switch (num >> 1)
            {
              case 0:
                this.input.SkipToByteBoundary();
                this.mode = 3;
                break;
              case 1:
                this.litlenTree = SimpleZip.InflaterHuffmanTree.defLitLenTree;
                this.distTree = SimpleZip.InflaterHuffmanTree.defDistTree;
                this.mode = 7;
                break;
              case 2:
                this.dynHeader = new SimpleZip.InflaterDynHeader();
                this.mode = 6;
                break;
            }
            return true;
          case 3:
            if ((this.uncomprLen = this.input.PeekBits(16)) < 0)
              return false;
            this.input.DropBits(16);
            this.mode = 4;
            goto case 4;
          case 4:
            if (this.input.PeekBits(16) < 0)
              return false;
            this.input.DropBits(16);
            this.mode = 5;
            goto case 5;
          case 5:
            this.uncomprLen -= this.outputWindow.CopyStored(this.input, this.uncomprLen);
            if (this.uncomprLen != 0)
              return !this.input.IsNeedingInput;
            this.mode = 2;
            return true;
          case 6:
            if (!this.dynHeader.Decode(this.input))
              return false;
            this.litlenTree = this.dynHeader.BuildLitLenTree();
            this.distTree = this.dynHeader.BuildDistTree();
            this.mode = 7;
            goto case 7;
          case 7:
          case 8:
          case 9:
          case 10:
            return this.DecodeHuffmen();
          case 12:
            return false;
          default:
            return false;
        }
      }

      public int Inflate(byte[] p0, int p1, int p2)
      {
        int num1 = 0;
        do
        {
          if (this.mode != 11)
            goto label_2;
label_1:
          continue;
label_2:
          int num2 = this.outputWindow.CopyOutput(p0, p1, p2);
          p1 += num2;
          num1 += num2;
          p2 -= num2;
          if (p2 != 0)
            goto label_1;
          else
            goto label_4;
        }
        while (this.Decode() || this.outputWindow.GetAvailable() > 0 && this.mode != 11);
        goto label_5;
label_4:
        return num1;
label_5:
        return num1;
      }
    }

    internal sealed class StreamManipulator
    {
      private byte[] window;
      private int window_start;
      private int window_end;
      private uint buffer;
      private int bits_in_buffer;

      public int PeekBits(int p0)
      {
        if (this.bits_in_buffer < p0)
        {
          if (this.window_start == this.window_end)
            return -1;
          this.buffer |= (uint) (((int) this.window[this.window_start++] & (int) byte.MaxValue | ((int) this.window[this.window_start++] & (int) byte.MaxValue) << 8) << this.bits_in_buffer);
          this.bits_in_buffer += 16;
        }
        return (int) ((long) this.buffer & (long) ((1 << p0) - 1));
      }

      public void DropBits(int p0)
      {
        this.buffer >>= p0;
        this.bits_in_buffer -= p0;
      }

      public int AvailableBits => this.bits_in_buffer;

      public int AvailableBytes => this.window_end - this.window_start + (this.bits_in_buffer >> 3);

      public void SkipToByteBoundary()
      {
        this.buffer >>= this.bits_in_buffer & 7;
        this.bits_in_buffer &= -8;
      }

      public bool IsNeedingInput => this.window_start == this.window_end;

      public int CopyBytes(byte[] p0, int p1, int p2)
      {
        int num1 = 0;
        while (this.bits_in_buffer > 0 && p2 > 0)
        {
          p0[p1++] = (byte) this.buffer;
          this.buffer >>= 8;
          this.bits_in_buffer -= 8;
          --p2;
          ++num1;
        }
        if (p2 == 0)
          return num1;
        int num2 = this.window_end - this.window_start;
        if (p2 > num2)
          p2 = num2;
        Array.Copy((Array) this.window, this.window_start, (Array) p0, p1, p2);
        this.window_start += p2;
        if ((this.window_start - this.window_end & 1) != 0)
        {
          this.buffer = (uint) this.window[this.window_start++] & (uint) byte.MaxValue;
          this.bits_in_buffer = 8;
        }
        return num1 + p2;
      }

      public void SetInput(byte[] p0, int p1, int p2)
      {
        if (this.window_start < this.window_end)
          throw new InvalidOperationException();
        int num = p1 + p2;
        if (0 > p1 || p1 > num || num > p0.Length)
          throw new ArgumentOutOfRangeException();
        if ((p2 & 1) != 0)
        {
          this.buffer |= (uint) (((int) p0[p1++] & (int) byte.MaxValue) << this.bits_in_buffer);
          this.bits_in_buffer += 8;
        }
        this.window = p0;
        this.window_start = p1;
        this.window_end = num;
      }
    }

    internal sealed class OutputWindow
    {
      private byte[] window = new byte[32768];
      private int windowEnd;
      private int windowFilled;

      public void Write(int p0)
      {
        if (this.windowFilled++ == 32768)
          throw new InvalidOperationException();
        this.window[this.windowEnd++] = (byte) p0;
        this.windowEnd &= (int) short.MaxValue;
      }

      private void SlowRepeat(int p0, int p1)
      {
        while (p1-- > 0)
        {
          this.window[this.windowEnd++] = this.window[p0++];
          this.windowEnd &= (int) short.MaxValue;
          p0 &= (int) short.MaxValue;
        }
      }

      public void Repeat(int p0, int p1)
      {
        if ((this.windowFilled += p0) > 32768)
          throw new InvalidOperationException();
        int num1 = this.windowEnd - p1 & (int) short.MaxValue;
        int num2 = 32768 - p0;
        if (num1 <= num2 && this.windowEnd < num2)
        {
          if (p0 <= p1)
          {
            Array.Copy((Array) this.window, num1, (Array) this.window, this.windowEnd, p0);
            this.windowEnd += p0;
          }
          else
          {
            while (p0-- > 0)
              this.window[this.windowEnd++] = this.window[num1++];
          }
        }
        else
          this.SlowRepeat(num1, p0);
      }

      public int CopyStored(SimpleZip.StreamManipulator p0, int p1)
      {
        p1 = Math.Min(Math.Min(p1, 32768 - this.windowFilled), p0.AvailableBytes);
        int p2 = 32768 - this.windowEnd;
        int num;
        if (p1 > p2)
        {
          num = p0.CopyBytes(this.window, this.windowEnd, p2);
          if (num == p2)
            num += p0.CopyBytes(this.window, 0, p1 - p2);
        }
        else
          num = p0.CopyBytes(this.window, this.windowEnd, p1);
        this.windowEnd = this.windowEnd + num & (int) short.MaxValue;
        this.windowFilled += num;
        return num;
      }

      public int GetFreeSpace() => 32768 - this.windowFilled;

      public int GetAvailable() => this.windowFilled;

      public int CopyOutput(byte[] p0, int p1, int p2)
      {
        int num1 = this.windowEnd;
        if (p2 > this.windowFilled)
          p2 = this.windowFilled;
        else
          num1 = this.windowEnd - this.windowFilled + p2 & (int) short.MaxValue;
        int num2 = p2;
        int length = p2 - num1;
        if (length > 0)
        {
          Array.Copy((Array) this.window, 32768 - length, (Array) p0, p1, length);
          p1 += length;
          p2 = num1;
        }
        Array.Copy((Array) this.window, num1 - p2, (Array) p0, p1, p2);
        this.windowFilled -= num2;
        if (this.windowFilled < 0)
          throw new InvalidOperationException();
        return num2;
      }
    }

    internal sealed class InflaterHuffmanTree
    {
      private short[] tree;
      public static readonly SimpleZip.InflaterHuffmanTree defLitLenTree;
      public static readonly SimpleZip.InflaterHuffmanTree defDistTree;

      static InflaterHuffmanTree()
      {
        byte[] p0_1 = new byte[288];
        int num1 = 0;
        while (num1 < 144)
          p0_1[num1++] = (byte) 8;
        while (num1 < 256)
          p0_1[num1++] = (byte) 9;
        while (num1 < 280)
          p0_1[num1++] = (byte) 7;
        while (num1 < 288)
          p0_1[num1++] = (byte) 8;
        SimpleZip.InflaterHuffmanTree.defLitLenTree = new SimpleZip.InflaterHuffmanTree(p0_1);
        byte[] p0_2 = new byte[32];
        int num2 = 0;
        while (num2 < 32)
          p0_2[num2++] = (byte) 5;
        SimpleZip.InflaterHuffmanTree.defDistTree = new SimpleZip.InflaterHuffmanTree(p0_2);
      }

      public InflaterHuffmanTree(byte[] p0) => this.BuildTree(p0);

      private void BuildTree(byte[] p0)
      {
        int[] numArray1 = new int[16];
        int[] numArray2 = new int[16];
        for (int index1 = 0; index1 < p0.Length; ++index1)
        {
          int index2 = (int) p0[index1];
          if (index2 > 0)
            ++numArray1[index2];
        }
        int num1 = 0;
        int length = 512;
        for (int index = 1; index <= 15; ++index)
        {
          numArray2[index] = num1;
          num1 += numArray1[index] << 16 - index;
          if (index >= 10)
          {
            int num2 = numArray2[index] & 130944;
            int num3 = num1 & 130944;
            length += num3 - num2 >> 16 - index;
          }
        }
        this.tree = new short[length];
        int num4 = 512;
        for (int index = 15; index >= 10; --index)
        {
          int num5 = num1 & 130944;
          num1 -= numArray1[index] << 16 - index;
          for (int p0_1 = num1 & 130944; p0_1 < num5; p0_1 += 128)
          {
            this.tree[(int) SimpleZip.DeflaterHuffman.BitReverse(p0_1)] = (short) (-num4 << 4 | index);
            num4 += 1 << index - 9;
          }
        }
        for (int index3 = 0; index3 < p0.Length; ++index3)
        {
          int index4 = (int) p0[index3];
          if (index4 != 0)
          {
            int p0_2 = numArray2[index4];
            int index5 = (int) SimpleZip.DeflaterHuffman.BitReverse(p0_2);
            if (index4 <= 9)
            {
              do
              {
                this.tree[index5] = (short) (index3 << 4 | index4);
                index5 += 1 << index4;
              }
              while (index5 < 512);
            }
            else
            {
              int num6 = (int) this.tree[index5 & 511];
              int num7 = 1 << (num6 & 15);
              int num8 = -(num6 >> 4);
              do
              {
                this.tree[num8 | index5 >> 9] = (short) (index3 << 4 | index4);
                index5 += 1 << index4;
              }
              while (index5 < num7);
            }
            numArray2[index4] = p0_2 + (1 << 16 - index4);
          }
        }
      }

      public int GetSymbol(SimpleZip.StreamManipulator p0)
      {
        int index;
        if ((index = p0.PeekBits(9)) >= 0)
        {
          int num1;
          if ((num1 = (int) this.tree[index]) >= 0)
          {
            p0.DropBits(num1 & 15);
            return num1 >> 4;
          }
          int num2 = -(num1 >> 4);
          int p0_1 = num1 & 15;
          int num3;
          if ((num3 = p0.PeekBits(p0_1)) >= 0)
          {
            int num4 = (int) this.tree[num2 | num3 >> 9];
            p0.DropBits(num4 & 15);
            return num4 >> 4;
          }
          int availableBits = p0.AvailableBits;
          int num5 = p0.PeekBits(availableBits);
          int num6 = (int) this.tree[num2 | num5 >> 9];
          if ((num6 & 15) > availableBits)
            return -1;
          p0.DropBits(num6 & 15);
          return num6 >> 4;
        }
        int availableBits1 = p0.AvailableBits;
        int num = (int) this.tree[p0.PeekBits(availableBits1)];
        if (num < 0 || (num & 15) > availableBits1)
          return -1;
        p0.DropBits(num & 15);
        return num >> 4;
      }
    }

    internal sealed class InflaterDynHeader
    {
      private static readonly int[] repMin = new int[3]
      {
        3,
        3,
        11
      };
      private static readonly int[] repBits = new int[3]
      {
        2,
        3,
        7
      };
      private byte[] blLens;
      private byte[] litdistLens;
      private SimpleZip.InflaterHuffmanTree blTree;
      private int mode;
      private int lnum;
      private int dnum;
      private int blnum;
      private int num;
      private int repSymbol;
      private byte lastLen;
      private int ptr;
      private static readonly int[] BL_ORDER = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };

      public bool Decode(SimpleZip.StreamManipulator p0)
      {
        while (true)
        {
          switch (this.mode)
          {
            case 0:
              this.lnum = p0.PeekBits(5);
              if (this.lnum >= 0)
              {
                this.lnum += 257;
                p0.DropBits(5);
                this.mode = 1;
                goto case 1;
              }
              else
                goto label_23;
            case 1:
              this.dnum = p0.PeekBits(5);
              if (this.dnum >= 0)
              {
                ++this.dnum;
                p0.DropBits(5);
                this.num = this.lnum + this.dnum;
                this.litdistLens = new byte[this.num];
                this.mode = 2;
                goto case 2;
              }
              else
                goto label_24;
            case 2:
              this.blnum = p0.PeekBits(4);
              if (this.blnum >= 0)
              {
                this.blnum += 4;
                p0.DropBits(4);
                this.blLens = new byte[19];
                this.ptr = 0;
                this.mode = 3;
                goto case 3;
              }
              else
                goto label_25;
            case 3:
              for (; this.ptr < this.blnum; ++this.ptr)
              {
                int num = p0.PeekBits(3);
                if (num < 0)
                  return false;
                p0.DropBits(3);
                this.blLens[SimpleZip.InflaterDynHeader.BL_ORDER[this.ptr]] = (byte) num;
              }
              this.blTree = new SimpleZip.InflaterHuffmanTree(this.blLens);
              this.blLens = (byte[]) null;
              this.ptr = 0;
              this.mode = 4;
              goto case 4;
            case 4:
              int symbol;
              while (((symbol = this.blTree.GetSymbol(p0)) & -16) == 0)
              {
                this.litdistLens[this.ptr++] = this.lastLen = (byte) symbol;
                if (this.ptr == this.num)
                  return true;
              }
              if (symbol >= 0)
              {
                if (symbol >= 17)
                  this.lastLen = (byte) 0;
                this.repSymbol = symbol - 16;
                this.mode = 5;
                goto case 5;
              }
              else
                goto label_27;
            case 5:
              int repBit = SimpleZip.InflaterDynHeader.repBits[this.repSymbol];
              int num1 = p0.PeekBits(repBit);
              if (num1 >= 0)
              {
                p0.DropBits(repBit);
                int num2 = num1 + SimpleZip.InflaterDynHeader.repMin[this.repSymbol];
                while (num2-- > 0)
                  this.litdistLens[this.ptr++] = this.lastLen;
                if (this.ptr != this.num)
                {
                  this.mode = 4;
                  continue;
                }
                goto label_30;
              }
              else
                goto label_29;
            default:
              continue;
          }
        }
label_23:
        return false;
label_24:
        return false;
label_25:
        return false;
label_27:
        return false;
label_29:
        return false;
label_30:
        return true;
      }

      public SimpleZip.InflaterHuffmanTree BuildLitLenTree()
      {
        byte[] numArray = new byte[this.lnum];
        Array.Copy((Array) this.litdistLens, 0, (Array) numArray, 0, this.lnum);
        return new SimpleZip.InflaterHuffmanTree(numArray);
      }

      public SimpleZip.InflaterHuffmanTree BuildDistTree()
      {
        byte[] numArray = new byte[this.dnum];
        Array.Copy((Array) this.litdistLens, this.lnum, (Array) numArray, 0, this.dnum);
        return new SimpleZip.InflaterHuffmanTree(numArray);
      }
    }

    internal sealed class DeflaterHuffman
    {
      private static readonly int[] BL_ORDER = new int[19]
      {
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      };
      private static readonly byte[] bit4Reverse = new byte[16]
      {
        (byte) 0,
        (byte) 8,
        (byte) 4,
        (byte) 12,
        (byte) 2,
        (byte) 10,
        (byte) 6,
        (byte) 14,
        (byte) 1,
        (byte) 9,
        (byte) 5,
        (byte) 13,
        (byte) 3,
        (byte) 11,
        (byte) 7,
        (byte) 15
      };
      private static readonly short[] staticLCodes = new short[286];
      private static readonly byte[] staticLLength = new byte[286];
      private static readonly short[] staticDCodes;
      private static readonly byte[] staticDLength;

      public static short BitReverse(int p0) => (short) ((int) SimpleZip.DeflaterHuffman.bit4Reverse[p0 & 15] << 12 | (int) SimpleZip.DeflaterHuffman.bit4Reverse[p0 >> 4 & 15] << 8 | (int) SimpleZip.DeflaterHuffman.bit4Reverse[p0 >> 8 & 15] << 4 | (int) SimpleZip.DeflaterHuffman.bit4Reverse[p0 >> 12]);

      static DeflaterHuffman()
      {
        int index1;
        for (index1 = 0; index1 < 144; SimpleZip.DeflaterHuffman.staticLLength[index1++] = (byte) 8)
          SimpleZip.DeflaterHuffman.staticLCodes[index1] = SimpleZip.DeflaterHuffman.BitReverse(48 + index1 << 8);
        for (; index1 < 256; SimpleZip.DeflaterHuffman.staticLLength[index1++] = (byte) 9)
          SimpleZip.DeflaterHuffman.staticLCodes[index1] = SimpleZip.DeflaterHuffman.BitReverse(256 + index1 << 7);
        for (; index1 < 280; SimpleZip.DeflaterHuffman.staticLLength[index1++] = (byte) 7)
          SimpleZip.DeflaterHuffman.staticLCodes[index1] = SimpleZip.DeflaterHuffman.BitReverse(index1 - 256 << 9);
        for (; index1 < 286; SimpleZip.DeflaterHuffman.staticLLength[index1++] = (byte) 8)
          SimpleZip.DeflaterHuffman.staticLCodes[index1] = SimpleZip.DeflaterHuffman.BitReverse(index1 - 88 << 8);
        SimpleZip.DeflaterHuffman.staticDCodes = new short[30];
        SimpleZip.DeflaterHuffman.staticDLength = new byte[30];
        for (int index2 = 0; index2 < 30; ++index2)
        {
          SimpleZip.DeflaterHuffman.staticDCodes[index2] = SimpleZip.DeflaterHuffman.BitReverse(index2 << 11);
          SimpleZip.DeflaterHuffman.staticDLength[index2] = (byte) 5;
        }
      }
    }

    internal sealed class ZipStream : MemoryStream
    {
      public int ReadShort() => this.ReadByte() | this.ReadByte() << 8;

      public int ReadInt() => this.ReadShort() | this.ReadShort() << 16;

      public ZipStream(byte[] p0)
        : base(p0, false)
      {
      }
    }
  }
}
