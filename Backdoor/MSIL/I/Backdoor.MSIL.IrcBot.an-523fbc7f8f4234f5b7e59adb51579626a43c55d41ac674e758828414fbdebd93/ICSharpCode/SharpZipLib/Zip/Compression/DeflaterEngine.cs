// Decompiled with JetBrains decompiler
// Type: ICSharpCode.SharpZipLib.Zip.Compression.DeflaterEngine
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using ICSharpCode.SharpZipLib.Checksums;
using System;

namespace ICSharpCode.SharpZipLib.Zip.Compression
{
  public class DeflaterEngine : DeflaterConstants
  {
    private const int \uE017 = 4096;
    private int \uE016;
    private short[] \uE015;
    private short[] \uE014;
    private int \uE013;
    private int \uE012;
    private bool \uE011;
    private int \uE010;
    private int \uE00F;
    private int \uE00E;
    private byte[] \uE00D;
    private DeflateStrategy \uE00C;
    private int \uE00B;
    private int \uE00A;
    private int \uE009;
    private int \uE008;
    private int \uE007;
    private byte[] \uE006;
    private long \uE005;
    private int \uE004;
    private int \uE003;
    private DeflaterPending \uE002;
    private DeflaterHuffman \uE001;
    private Adler32 \uE000;

    public DeflaterEngine(DeflaterPending pending)
    {
      this.\uE002 = pending;
      this.\uE001 = new DeflaterHuffman(pending);
      this.\uE000 = new Adler32();
      this.\uE00D = new byte[65536];
      this.\uE015 = new short[32768];
      this.\uE014 = new short[32768];
      this.\uE010 = this.\uE00F = 1;
    }

    public bool Deflate(bool flush, bool finish)
    {
      bool flag1;
      do
      {
        this.FillWindow();
        bool flag2 = flush && this.\uE004 == this.\uE003;
        switch (this.\uE007)
        {
          case 0:
            flag1 = this.\uE002(flag2, finish);
            break;
          case 1:
            flag1 = this.\uE001(flag2, finish);
            break;
          case 2:
            flag1 = this.\uE000(flag2, finish);
            break;
          default:
            throw new InvalidOperationException(\uE01B.\uE000("\uEDBD\uEDA6\uEDA3\uEDA6\uEDA7\uEDBF\uEDA6\uEDE8\uEDAB\uEDA7\uEDA5\uEDB8\uEDBA\uEDAD\uEDBB\uEDBB\uEDA1\uEDA7\uEDA6\uED8E\uEDBD\uEDA6\uEDAB\uEDBC\uEDA1\uEDA7\uEDA6", 60872));
        }
      }
      while (this.\uE002.IsFlushed && flag1);
      return flag1;
    }

    public void SetInput(byte[] buffer, int offset, int count)
    {
      if (buffer == null)
        throw new ArgumentNullException(\uE01B.\uE000("\uEDC8\uEDDF\uEDCC\uEDCC\uEDCF\uEDD8", 60842));
      if (offset < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uF201\uF208\uF208\uF21D\uF20B\uF21A", 62062));
      if (count < 0)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uED5B\uED57\uED4D\uED56\uED4C", 60728));
      if (this.\uE004 < this.\uE003)
        throw new InvalidOperationException(\uE01B.\uE000("\uEC35\uEC16\uEC1E\uEC5A\uEC13\uEC14\uEC0A\uEC0F\uEC0E\uEC5A\uEC0D\uEC1B\uEC09\uEC5A\uEC14\uEC15\uEC0E\uEC5A\uEC19\uEC15\uEC17\uEC0A\uEC16\uEC1F\uEC0E\uEC1F\uEC16\uEC03\uEC5A\uEC0A\uEC08\uEC15\uEC19\uEC1F\uEC09\uEC09\uEC1F\uEC1E", 60538));
      int num = offset + count;
      if (offset > num || num > buffer.Length)
        throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uED5B\uED57\uED4D\uED56\uED4C", 60728));
      this.\uE006 = buffer;
      this.\uE004 = offset;
      this.\uE003 = num;
    }

    public bool NeedsInput() => this.\uE003 == this.\uE004;

    public void SetDictionary(byte[] buffer, int offset, int length)
    {
      this.\uE000.Update(buffer, offset, length);
      if (length < 3)
        return;
      if (length > 32506)
      {
        offset += length - 32506;
        length = 32506;
      }
      Array.Copy((Array) buffer, offset, (Array) this.\uE00D, this.\uE00F, length);
      this.\uE003();
      --length;
      while (--length > 0)
      {
        this.\uE000();
        ++this.\uE00F;
      }
      this.\uE00F += 2;
      this.\uE010 = this.\uE00F;
    }

    public void Reset()
    {
      this.\uE001.Reset();
      this.\uE000.Reset();
      this.\uE010 = this.\uE00F = 1;
      this.\uE00E = 0;
      this.\uE005 = 0L;
      this.\uE011 = false;
      this.\uE012 = 2;
      for (int index = 0; index < 32768; ++index)
        this.\uE015[index] = (short) 0;
      for (int index = 0; index < 32768; ++index)
        this.\uE014[index] = (short) 0;
    }

    public void ResetAdler() => this.\uE000.Reset();

    public int Adler => (int) this.\uE000.Value;

    public long TotalIn => this.\uE005;

    public DeflateStrategy Strategy
    {
      get => this.\uE00C;
      set => this.\uE00C = value;
    }

    public void SetLevel(int level)
    {
      this.\uE008 = level >= 0 && level <= 9 ? DeflaterConstants.GOOD_LENGTH[level] : throw new ArgumentOutOfRangeException(\uE01B.\uE000("\uE06D\uE064\uE077\uE064\uE06D", 57345));
      this.\uE00A = DeflaterConstants.MAX_LAZY[level];
      this.\uE009 = DeflaterConstants.NICE_LENGTH[level];
      this.\uE00B = DeflaterConstants.MAX_CHAIN[level];
      if (DeflaterConstants.COMPR_FUNC[level] == this.\uE007)
        return;
      switch (this.\uE007)
      {
        case 0:
          if (this.\uE00F > this.\uE010)
          {
            this.\uE001.FlushStoredBlock(this.\uE00D, this.\uE010, this.\uE00F - this.\uE010, false);
            this.\uE010 = this.\uE00F;
          }
          this.\uE003();
          break;
        case 1:
          if (this.\uE00F > this.\uE010)
          {
            this.\uE001.FlushBlock(this.\uE00D, this.\uE010, this.\uE00F - this.\uE010, false);
            this.\uE010 = this.\uE00F;
            break;
          }
          break;
        case 2:
          if (this.\uE011)
            this.\uE001.TallyLit((int) this.\uE00D[this.\uE00F - 1] & (int) byte.MaxValue);
          if (this.\uE00F > this.\uE010)
          {
            this.\uE001.FlushBlock(this.\uE00D, this.\uE010, this.\uE00F - this.\uE010, false);
            this.\uE010 = this.\uE00F;
          }
          this.\uE011 = false;
          this.\uE012 = 2;
          break;
      }
      this.\uE007 = DeflaterConstants.COMPR_FUNC[level];
    }

    public void FillWindow()
    {
      if (this.\uE00F >= 65274)
        this.\uE000();
      int num;
      for (; this.\uE00E < 262 && this.\uE004 < this.\uE003; this.\uE00E += num)
      {
        num = 65536 - this.\uE00E - this.\uE00F;
        if (num > this.\uE003 - this.\uE004)
          num = this.\uE003 - this.\uE004;
        Array.Copy((Array) this.\uE006, this.\uE004, (Array) this.\uE00D, this.\uE00F + this.\uE00E, num);
        this.\uE000.Update(this.\uE006, this.\uE004, num);
        this.\uE004 += num;
        this.\uE005 += (long) num;
      }
      if (this.\uE00E < 3)
        return;
      this.\uE003();
    }

    private void \uE003() => this.\uE016 = (int) this.\uE00D[this.\uE00F] << 5 ^ (int) this.\uE00D[this.\uE00F + 1];

    private int \uE000()
    {
      int index = (this.\uE016 << 5 ^ (int) this.\uE00D[this.\uE00F + 2]) & (int) short.MaxValue;
      short num;
      this.\uE014[this.\uE00F & (int) short.MaxValue] = num = this.\uE015[index];
      this.\uE015[index] = (short) this.\uE00F;
      this.\uE016 = index;
      return (int) num & (int) ushort.MaxValue;
    }

    private void \uE000()
    {
      Array.Copy((Array) this.\uE00D, 32768, (Array) this.\uE00D, 0, 32768);
      this.\uE013 -= 32768;
      this.\uE00F -= 32768;
      this.\uE010 -= 32768;
      for (int index = 0; index < 32768; ++index)
      {
        int num = (int) this.\uE015[index] & (int) ushort.MaxValue;
        this.\uE015[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
      }
      for (int index = 0; index < 32768; ++index)
      {
        int num = (int) this.\uE014[index] & (int) ushort.MaxValue;
        this.\uE014[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
      }
    }

    private bool \uE000(int _param1)
    {
      int num1 = this.\uE00B;
      int num2 = this.\uE009;
      short[] numArray = this.\uE014;
      int index1 = this.\uE00F;
      int index2 = this.\uE00F + this.\uE012;
      int val1 = Math.Max(this.\uE012, 2);
      int num3 = Math.Max(this.\uE00F - 32506, 0);
      int num4 = this.\uE00F + 258 - 1;
      byte num5 = this.\uE00D[index2 - 1];
      byte num6 = this.\uE00D[index2];
      if (val1 >= this.\uE008)
        num1 >>= 2;
      if (num2 > this.\uE00E)
        num2 = this.\uE00E;
      do
      {
        if ((int) this.\uE00D[_param1 + val1] == (int) num6 && (int) this.\uE00D[_param1 + val1 - 1] == (int) num5 && (int) this.\uE00D[_param1] == (int) this.\uE00D[index1] && (int) this.\uE00D[_param1 + 1] == (int) this.\uE00D[index1 + 1])
        {
          int num7 = _param1 + 2;
          int num8 = index1 + 2;
          int num9;
          int num10;
          int num11;
          int num12;
          int num13;
          int num14;
          int num15;
          do
            ;
          while ((int) this.\uE00D[++num8] == (int) this.\uE00D[num9 = num7 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num10 = num9 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num11 = num10 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num12 = num11 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num13 = num12 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num14 = num13 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num15 = num14 + 1] && (int) this.\uE00D[++num8] == (int) this.\uE00D[num7 = num15 + 1] && num8 < num4);
          if (num8 > index2)
          {
            this.\uE013 = _param1;
            index2 = num8;
            val1 = num8 - this.\uE00F;
            if (val1 < num2)
            {
              num5 = this.\uE00D[index2 - 1];
              num6 = this.\uE00D[index2];
            }
            else
              break;
          }
          index1 = this.\uE00F;
        }
      }
      while ((_param1 = (int) numArray[_param1 & (int) short.MaxValue] & (int) ushort.MaxValue) > num3 && --num1 != 0);
      this.\uE012 = Math.Min(val1, this.\uE00E);
      return this.\uE012 >= 3;
    }

    private bool \uE002(bool _param1, bool _param2)
    {
      if (!_param1 && this.\uE00E == 0)
        return false;
      this.\uE00F += this.\uE00E;
      this.\uE00E = 0;
      int storedLength = this.\uE00F - this.\uE010;
      if (storedLength < DeflaterConstants.MAX_BLOCK_SIZE && (this.\uE010 >= 32768 || storedLength < 32506) && !_param1)
        return true;
      bool lastBlock = _param2;
      if (storedLength > DeflaterConstants.MAX_BLOCK_SIZE)
      {
        storedLength = DeflaterConstants.MAX_BLOCK_SIZE;
        lastBlock = false;
      }
      this.\uE001.FlushStoredBlock(this.\uE00D, this.\uE010, storedLength, lastBlock);
      this.\uE010 += storedLength;
      return !lastBlock;
    }

    private bool \uE001(bool _param1, bool _param2)
    {
      if (this.\uE00E < 262 && !_param1)
        return false;
      while (this.\uE00E >= 262 || _param1)
      {
        if (this.\uE00E == 0)
        {
          this.\uE001.FlushBlock(this.\uE00D, this.\uE010, this.\uE00F - this.\uE010, _param2);
          this.\uE010 = this.\uE00F;
          return false;
        }
        if (this.\uE00F > 65274)
          this.\uE000();
        int num;
        if (this.\uE00E >= 3 && (num = this.\uE000()) != 0 && this.\uE00C != DeflateStrategy.HuffmanOnly && this.\uE00F - num <= 32506 && this.\uE000(num))
        {
          bool flag = this.\uE001.TallyDist(this.\uE00F - this.\uE013, this.\uE012);
          this.\uE00E -= this.\uE012;
          if (this.\uE012 <= this.\uE00A && this.\uE00E >= 3)
          {
            while (--this.\uE012 > 0)
            {
              ++this.\uE00F;
              this.\uE000();
            }
            ++this.\uE00F;
          }
          else
          {
            this.\uE00F += this.\uE012;
            if (this.\uE00E >= 2)
              this.\uE003();
          }
          this.\uE012 = 2;
          if (!flag)
            continue;
        }
        else
        {
          this.\uE001.TallyLit((int) this.\uE00D[this.\uE00F] & (int) byte.MaxValue);
          ++this.\uE00F;
          --this.\uE00E;
        }
        if (this.\uE001.IsFull())
        {
          bool lastBlock = _param2 && this.\uE00E == 0;
          this.\uE001.FlushBlock(this.\uE00D, this.\uE010, this.\uE00F - this.\uE010, lastBlock);
          this.\uE010 = this.\uE00F;
          return !lastBlock;
        }
      }
      return true;
    }

    private bool \uE000(bool _param1, bool _param2)
    {
      if (this.\uE00E < 262 && !_param1)
        return false;
      while (this.\uE00E >= 262 || _param1)
      {
        if (this.\uE00E == 0)
        {
          if (this.\uE011)
            this.\uE001.TallyLit((int) this.\uE00D[this.\uE00F - 1] & (int) byte.MaxValue);
          this.\uE011 = false;
          this.\uE001.FlushBlock(this.\uE00D, this.\uE010, this.\uE00F - this.\uE010, _param2);
          this.\uE010 = this.\uE00F;
          return false;
        }
        if (this.\uE00F >= 65274)
          this.\uE000();
        int num1 = this.\uE013;
        int length = this.\uE012;
        if (this.\uE00E >= 3)
        {
          int num2 = this.\uE000();
          if (this.\uE00C != DeflateStrategy.HuffmanOnly && num2 != 0 && this.\uE00F - num2 <= 32506 && this.\uE000(num2) && this.\uE012 <= 5 && (this.\uE00C == DeflateStrategy.Filtered || this.\uE012 == 3 && this.\uE00F - this.\uE013 > 4096))
            this.\uE012 = 2;
        }
        if (length >= 3 && this.\uE012 <= length)
        {
          this.\uE001.TallyDist(this.\uE00F - 1 - num1, length);
          int num3 = length - 2;
          do
          {
            ++this.\uE00F;
            --this.\uE00E;
            if (this.\uE00E >= 3)
              this.\uE000();
          }
          while (--num3 > 0);
          ++this.\uE00F;
          --this.\uE00E;
          this.\uE011 = false;
          this.\uE012 = 2;
        }
        else
        {
          if (this.\uE011)
            this.\uE001.TallyLit((int) this.\uE00D[this.\uE00F - 1] & (int) byte.MaxValue);
          this.\uE011 = true;
          ++this.\uE00F;
          --this.\uE00E;
        }
        if (this.\uE001.IsFull())
        {
          int storedLength = this.\uE00F - this.\uE010;
          if (this.\uE011)
            --storedLength;
          bool lastBlock = _param2 && this.\uE00E == 0 && !this.\uE011;
          this.\uE001.FlushBlock(this.\uE00D, this.\uE010, storedLength, lastBlock);
          this.\uE010 += storedLength;
          return !lastBlock;
        }
      }
      return true;
    }
  }
}
