// Decompiled with JetBrains decompiler
// Type: Microsoft.Windows.PowerShell.GuiExe.Internal.NamedPipeClient
// Assembly: powershell_ise, Version=1.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 8E61B2A9-9D1B-4E14-B095-A239B1610C71
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Virus.Win32.Virut.ce-b6360ae4521e85fbd7f2b938b3e5fe1e56f276f5d09db575e1615d4d070fb380.exe

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading;

namespace Microsoft.Windows.PowerShell.GuiExe.Internal
{
  internal static class NamedPipeClient
  {
    private const int ServerBusyTimeout = 3000;
    private static NamedPipeSafeHandle pipeHandle;
    private static AutoResetEvent testClientPauseEvent;
    private static AutoResetEvent testPauseEvent;

    internal static NamedPipeSafeHandle PipeHandle => NamedPipeClient.pipeHandle;

    internal static AutoResetEvent TestClientPauseEvent
    {
      get => NamedPipeClient.testClientPauseEvent;
      set => NamedPipeClient.testClientPauseEvent = value;
    }

    internal static AutoResetEvent TestPauseEvent
    {
      get => NamedPipeClient.testPauseEvent;
      set => NamedPipeClient.testPauseEvent = value;
    }

    internal static bool SendString(string str)
    {
      string pipeName;
      bool flag;
      int lastWin32Error1;
      do
      {
        pipeName = NamedPipeClient.GetPipeName();
        if (pipeName == null)
        {
          NamedPipeServer.Tracer.TraceError("Client: could not retrieve a pipe name");
          return false;
        }
        NamedPipeClient.pipeHandle = NativeMethods.CreateFile(pipeName, 1073741824U, 0U, IntPtr.Zero, 3U, 0U, IntPtr.Zero);
        int lastWin32Error2 = Marshal.GetLastWin32Error();
        NamedPipeClient.TestPause();
        if (!NamedPipeClient.pipeHandle.IsInvalid)
        {
          NamedPipeServer.Tracer.WriteLine("Client: Successfully opened the pipe without waiting.");
          byte[] bytes = Encoding.Unicode.GetBytes(str);
          uint lpNumberOfBytesWritten;
          flag = NativeMethods.WriteFile(NamedPipeClient.pipeHandle, bytes, (uint) bytes.Length, out lpNumberOfBytesWritten, IntPtr.Zero) && (long) lpNumberOfBytesWritten == (long) bytes.Length;
          lastWin32Error1 = Marshal.GetLastWin32Error();
          if (!flag)
            goto label_9;
          else
            goto label_8;
        }
        else if (lastWin32Error2 != 231)
        {
          NamedPipeServer.Tracer.TraceError("Client: Invalid Handle and error is not ERROR_PIPE_BUSY, it is {0}.", (object) lastWin32Error2);
          return false;
        }
      }
      while (NativeMethods.WaitNamedPipe(pipeName, 3000U));
      int lastWin32Error3 = Marshal.GetLastWin32Error();
      NamedPipeServer.Tracer.TraceError("Client: Timed out while waiting for the server. Error: {0}", (object) lastWin32Error3);
      return false;
label_8:
      NamedPipeServer.Tracer.WriteLine("Client: Successfully sent message");
      goto label_10;
label_9:
      NamedPipeServer.Tracer.TraceError("Client: Could not send message. Error: {0}", (object) lastWin32Error1);
label_10:
      NamedPipeClient.TestPause();
      NamedPipeClient.pipeHandle.Close();
      return flag;
    }

    private static void TestPause()
    {
      if (NamedPipeClient.testClientPauseEvent == null || NamedPipeClient.testPauseEvent == null)
        return;
      NamedPipeClient.testPauseEvent.Set();
      NamedPipeClient.testClientPauseEvent.WaitOne();
    }

    private static string GetPipeName()
    {
      if (NamedPipeServer.LogonSid == (SecurityIdentifier) null)
        return (string) null;
      DirectoryInfo applicationDataPath = NamedPipeServer.GetApplicationDataPath(NamedPipeServer.GetLogonSidPath());
      if (applicationDataPath == null)
        return (string) null;
      FileInfo infoStartingWith = NamedPipeServer.GetFirstFileInfoStartingWith(applicationDataPath, NamedPipeServer.GetPipeNameStart());
      return infoStartingWith != null ? "\\\\.\\pipe\\" + infoStartingWith.Name : (string) null;
    }
  }
}
