// Decompiled with JetBrains decompiler
// Type: Diploma.methods.NewtonMethod
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using Diploma.entity;
using System;
using System.Collections.Generic;

namespace Diploma.methods
{
  internal class NewtonMethod
  {
    private MainProblem callMain;
    private double delT = 1.0;
    private double delPsi = 0.001;
    private PsiTime currentPsiTime;
    private List<double> xi = new List<double>() { 1.0 };

    public NewtonMethod(MainProblem CallFrom, Quaternion psiStart, double T_start)
    {
      Console.WriteLine("\n\t* NewtonMethod created!");
      this.callMain = CallFrom;
      this.currentPsiTime = new PsiTime(psiStart, T_start);
    }

    public void RunProcess()
    {
      Console.WriteLine("\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% МЕТОД НЬЮТОНА %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
      int num = 1;
      while (true)
      {
        Console.WriteLine("\n\t\tМЕТОДА НЬЮТОНА {0} ИТЕРАЦИЯ:", (object) num);
        while (this.currentPsiTime.T / (double) this.callMain.N >= 0.01)
          this.callMain.N *= 2;
        Vector N0 = this.countN(this.currentPsiTime);
        Vector result = this.createSLAU(N0, this.callMain.Epsilon).getResult();
        Console.WriteLine("\t\tПОЛУЧЕННЫЕ ПОПРАВКИ: " + result.ToString());
        this.getNextAndChangePsiT(result, N0);
        ++num;
      }
    }

    private void showResults(Vector Nnext, Vector N0)
    {
      Console.WriteLine("\t%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
      Console.Write("\n\t\t OK SEE CURRENT T= {0}; Psi: ", (object) this.currentPsiTime.T);
      this.currentPsiTime.psi.print();
      double num = Nnext.norm();
      string str1 = num.ToString();
      num = N0.norm();
      string str2 = num.ToString();
      Console.WriteLine("\t\t ТЕПЕРЬ:" + str1 + "  БЫЛО:" + str2);
      Console.WriteLine("\n\t%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
    }

    private void getNextAndChangePsiT(Vector corrects, Vector N0)
    {
      PsiTime psiTime1 = new PsiTime((object) null);
      Console.WriteLine("\n\t\tПРИМЕНЯНЕМ ПОПРАВКИ:");
      int index = 0;
      PsiTime psiTime2;
      Vector vector;
      do
      {
        try
        {
          Console.Write("\t\t -> XI={0} ", (object) this.xi[index]);
        }
        catch (Exception ex)
        {
          this.xi.Add(this.xi[index - 1] / 2.0);
          if (index > 15)
          {
            Console.WriteLine("\t\tНЕЛЬЗЯ УМЕНЬШИТЬ НОРМУ НЕВЯЗКИ!");
            Console.ReadKey();
          }
          Console.Write("\t\t -> XI={0} ", (object) this.xi[index]);
        }
        psiTime2 = this.upgradePsiTime(corrects, this.xi[index]);
        vector = this.countN(psiTime2);
        ++index;
      }
      while (vector.norm() > N0.norm());
      this.currentPsiTime = new PsiTime(psiTime2);
      Console.WriteLine("\t\tOK! ТЕПЕРЬ: " + this.currentPsiTime.ToString() + "\n\t\tНОРМА НЕВЯЗКИ ПОСЛЕ ИТЕРАЦИИ: " + vector.norm().ToString());
      Console.WriteLine("\t\tНОРМА УМЕНЬШИЛАСЬ НА " + (N0.norm() - vector.norm()).ToString());
    }

    private PsiTime upgradePsiTime(Vector corrects, double xi)
    {
      PsiTime psiTime = new PsiTime(this.currentPsiTime);
      for (int index = 0; index < 5; ++index)
      {
        if (index == 0)
          psiTime.T += xi * corrects[index];
        else
          psiTime.psi[index - 1] += xi * corrects[index];
      }
      return psiTime;
    }

    private Matrix createNMatrix()
    {
      Vector[] vmass = new Vector[5];
      for (int index = 0; index < 5; ++index)
      {
        if (index == 0)
        {
          PsiTime currentPsiTime = this.currentPsiTime;
          currentPsiTime.T += this.delT;
          vmass[index] = this.countN(currentPsiTime);
        }
        else
        {
          PsiTime psiTimeRequest = new PsiTime(this.currentPsiTime.psi, this.currentPsiTime.T);
          psiTimeRequest.psi[index - 1] += this.delPsi;
          vmass[index] = this.countN(psiTimeRequest);
        }
      }
      Matrix nmatrix = new Matrix(vmass);
      Console.WriteLine("\n\t\tМАТРИЦА НЕВЯЗОК:\n" + nmatrix.ToString(2));
      return nmatrix;
    }

    private Matrix createNmatrixForSLau(Matrix N, Vector N0)
    {
      Matrix nmatrixForSlau = new Matrix((short) N0.length);
      for (int index = 0; index < (int) nmatrixForSlau.length; ++index)
      {
        for (int j = 0; j < (int) nmatrixForSlau.length; ++j)
          nmatrixForSlau[index, j] = index != 0 ? (N[index, j] - N0[index]) / this.delPsi : (N[index, j] - N0[index]) / this.delT;
      }
      Console.WriteLine("\t\tМАТРИЦА ПРОИЗВОДНЫХ НЕВЯЗОК:\n" + nmatrixForSlau.ToString(2));
      return nmatrixForSlau;
    }

    private SLAU createSLAU(Vector N0, double precision)
    {
      SLAU slau = new SLAU(this.createNmatrixForSLau(this.createNMatrix(), N0), -1 * N0, precision);
      Console.WriteLine("\t\tСЛАУ ПО НЕВЯЗКАМ:\n" + slau.ToString(2));
      return slau;
    }

    private Vector countN(PsiTime psiTimeRequest)
    {
      Vector vector = new Vector(5);
      Tuple<double, Quaternion> tuple = RungeKutta.Run(psiTimeRequest, this.callMain);
      vector[0] = tuple.Item1;
      Quaternion quaternion = tuple.Item2 - this.callMain.LambdaT;
      for (int index = 0; index < 4; ++index)
        vector[index + 1] = quaternion[index];
      Console.WriteLine("\n\t\tПОЛУЧЕННАЯ НЕВЯЗКА: {0} С НОРМОЙ: {1}", (object) vector.ToString(), (object) vector.norm());
      return vector;
    }

    private double SummAbs(Vector vector)
    {
      double num = 0.0;
      for (int index = 0; index < vector.length; ++index)
        num += Math.Abs(vector[index]);
      return num;
    }
  }
}
