// Decompiled with JetBrains decompiler
// Type: Aura.Protection.CtrlFlow.BlockParser
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;

namespace Aura.Protection.CtrlFlow
{
  public class BlockParser
  {
    public static List<Block> ParseMethod(MethodDef method)
    {
      List<Block> method1 = new List<Block>();
      Block block1 = new Block();
      int num1 = 0;
      int num2 = 0;
      block1.Number = num1;
      block1.Instructions.Add(Instruction.Create(OpCodes.Nop));
      method1.Add(block1);
      Block block2 = new Block();
      Stack<ExceptionHandler> exceptionHandlerStack = new Stack<ExceptionHandler>();
      foreach (Instruction instruction in (IEnumerable<Instruction>) method.Body.Instructions)
      {
        foreach (ExceptionHandler exceptionHandler in (IEnumerable<ExceptionHandler>) method.Body.ExceptionHandlers)
        {
          if (exceptionHandler.HandlerStart == instruction || exceptionHandler.TryStart == instruction || exceptionHandler.FilterStart == instruction)
            exceptionHandlerStack.Push(exceptionHandler);
        }
        foreach (ExceptionHandler exceptionHandler in (IEnumerable<ExceptionHandler>) method.Body.ExceptionHandlers)
        {
          if (exceptionHandler.HandlerEnd == instruction || exceptionHandler.TryEnd == instruction)
            exceptionHandlerStack.Pop();
        }
        int num3;
        int num4;
        instruction.CalculateStackUsage(ref num3, ref num4);
        block2.Instructions.Add(instruction);
        num2 += num3 - num4;
        if (num3 == 0 && instruction.OpCode != OpCodes.Nop && (num2 == 0 || instruction.OpCode == OpCodes.Ret) && exceptionHandlerStack.Count == 0)
        {
          block2.Number = ++num1;
          method1.Add(block2);
          block2 = new Block();
        }
      }
      return method1;
    }
  }
}
