// Decompiled with JetBrains decompiler
// Type: Mario_KS.Bot
// Assembly: OnSerializingAttribute, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F72B5184-77D9-4DBB-B29C-2F3B04C48CCD
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-8c2eb36fc68b33fc269eaa5f42a303b63ee25bccdd99c0c424285aee9317d94c.exe

using Mario_KS.My;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;

namespace Mario_KS
{
  public class Bot
  {
    private char player;
    private char enemy;
    private Part[,] grid;

    public Bot(char pl)
    {
      this.player = pl;
      this.grid = MyProject.Forms.Game.grid;
      if (Operators.CompareString(Conversions.ToString(pl), "X", false) == 0)
        this.enemy = 'O';
      else
        this.enemy = 'X';
    }

    public void Play()
    {
      VBMath.Randomize();
      float x = 0.5f;
      char[,] charGrid = new char[3, 3];
      int[] numArray = new int[3]
      {
        int.MinValue,
        0,
        int.MaxValue
      };
      int index1 = 0;
      do
      {
        int index2 = 0;
        do
        {
          charGrid[index1, index2] = Conversions.ToChar(this.grid[index1, index2].Text);
          checked { ++index2; }
        }
        while (index2 <= 2);
        checked { ++index1; }
      }
      while (index1 <= 2);
      int index3 = 0;
      Part part;
      do
      {
        int index4 = 0;
        do
        {
          if (Operators.CompareString(Conversions.ToString(charGrid[index3, index4]), "\0", false) == 0)
          {
            charGrid[index3, index4] = this.player;
            if ((int) this.Check_Win(charGrid) == (int) this.player)
            {
              part = this.grid[index3, index4];
            }
            else
            {
              int[] bestMove = this.Find_Best_Move(charGrid, this.enemy);
              if (bestMove[2] < numArray[2] || bestMove[2] == numArray[2] && bestMove[0] > numArray[0])
              {
                numArray = bestMove;
                part = this.grid[index3, index4];
              }
              if (bestMove[0] == numArray[0] && bestMove[2] == numArray[2] && (double) VBMath.Rnd() > (double) x)
              {
                part = this.grid[index3, index4];
                x = (float) Math.Pow((double) x, 2.0);
              }
            }
            charGrid[index3, index4] = char.MinValue;
          }
          checked { ++index4; }
        }
        while (index4 <= 2);
        checked { ++index3; }
      }
      while (index3 <= 2);
      MyProject.Forms.Game.Enable_Grid();
      part.PerformClick();
    }

    private int[] Find_Best_Move(char[,] charGrid, char playerTurn, int depth = 1)
    {
      int[] bestMove1 = new int[3];
      int index1 = 0;
      do
      {
        int index2 = 0;
        do
        {
          if (Operators.CompareString(Conversions.ToString(charGrid[index1, index2]), "\0", false) == 0 && depth <= 2)
          {
            charGrid[index1, index2] = playerTurn;
            char ch = this.Check_Win(charGrid);
            if ((int) ch == (int) this.player)
            {
              // ISSUE: variable of a reference type
              int& local;
              // ISSUE: explicit reference operation
              int num = checked (^(local = ref bestMove1[0]) + 1);
              local = num;
            }
            else if (ch == 'A')
            {
              char playerTurn1 = (int) playerTurn != (int) this.player ? this.player : this.enemy;
              int[] bestMove2 = this.Find_Best_Move(charGrid, playerTurn1, checked (depth + 1));
              // ISSUE: variable of a reference type
              int& local1;
              // ISSUE: explicit reference operation
              int num1 = checked (^(local1 = ref bestMove1[0]) + bestMove2[0]);
              local1 = num1;
              // ISSUE: variable of a reference type
              int& local2;
              // ISSUE: explicit reference operation
              int num2 = checked (^(local2 = ref bestMove1[1]) + bestMove2[1]);
              local2 = num2;
              // ISSUE: variable of a reference type
              int& local3;
              // ISSUE: explicit reference operation
              int num3 = checked (^(local3 = ref bestMove1[2]) + bestMove2[2]);
              local3 = num3;
            }
            else if ((int) ch == (int) this.enemy)
              bestMove1[2] = checked (bestMove1[2] + 1);
            else if (ch == 'D')
            {
              // ISSUE: variable of a reference type
              int& local;
              // ISSUE: explicit reference operation
              int num = checked (^(local = ref bestMove1[1]) + 1);
              local = num;
            }
            charGrid[index1, index2] = char.MinValue;
          }
          checked { ++index2; }
        }
        while (index2 <= 2);
        checked { ++index1; }
      }
      while (index1 <= 2);
      return bestMove1;
    }

    private char Check_Win(char[,] charGrid)
    {
      char ch = 'D';
      foreach (object obj in (Array) charGrid)
      {
        if (Operators.CompareString(Conversions.ToString(Conversions.ToChar(obj)), "\0", false) == 0)
          ch = 'A';
      }
      int index = 0;
      do
      {
        if ((int) charGrid[index, 0] == (int) charGrid[index, 1] && (int) charGrid[index, 0] == (int) charGrid[index, 2] && Operators.CompareString(Conversions.ToString(charGrid[index, 0]), "\0", false) != 0)
          ch = charGrid[index, 0];
        if ((int) charGrid[0, index] == (int) charGrid[1, index] && (int) charGrid[0, index] == (int) charGrid[2, index] && Operators.CompareString(Conversions.ToString(charGrid[0, index]), "\0", false) != 0)
          ch = charGrid[0, index];
        checked { ++index; }
      }
      while (index <= 2);
      if (((int) charGrid[0, 0] == (int) charGrid[1, 1] && (int) charGrid[0, 0] == (int) charGrid[2, 2] || (int) charGrid[0, 2] == (int) charGrid[1, 1] && (int) charGrid[0, 2] == (int) charGrid[2, 0]) && Operators.CompareString(Conversions.ToString(charGrid[1, 1]), "\0", false) != 0)
        ch = charGrid[1, 1];
      return ch;
    }
  }
}
