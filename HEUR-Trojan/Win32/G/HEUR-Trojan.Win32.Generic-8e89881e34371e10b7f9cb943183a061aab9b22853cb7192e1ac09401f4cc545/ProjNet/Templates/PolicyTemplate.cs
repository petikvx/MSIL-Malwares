// Decompiled with JetBrains decompiler
// Type: ProjNet.Templates.PolicyTemplate
// Assembly: IRefl, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A29A65F6-B7ED-422C-83D4-B9EFD61E5F13
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-8e89881e34371e10b7f9cb943183a061aab9b22853cb7192e1ac09401f4cc545.exe

using IRefl.Pools;
using IRefl.Watchers;
using ProjNet.Structs;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace ProjNet.Templates
{
  internal class PolicyTemplate : ServiceObserverWatcher
  {
    private double creatorRegistry;
    private double m_CollectionRegistry;
    private double m_WrapperRegistry;
    private double specificationRegistry;
    private double _SystemRegistry;
    private double serializerRegistry;
    private double m_QueueRegistry;
    private double proccesorRegistry;
    private double m_PredicateRegistry;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public PolicyTemplate(List<Config> i)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      // ISSUE: explicit constructor call
      this.\u002Ector(i, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public PolicyTemplate(List<Config> first, bool writemap)
    {
      PageAdvisorStructBuilder.PrepareCreator();
      this.m_WrapperRegistry = 0.0;
      this.specificationRegistry = 0.0;
      this._SystemRegistry = 0.0;
      this.serializerRegistry = 0.0;
      this.m_QueueRegistry = 0.0;
      this.proccesorRegistry = 0.0;
      this.m_PredicateRegistry = 0.0;
      // ISSUE: explicit constructor call
      base.\u002Ector(first, writemap);
      this.Name = "Lambert_Conformal_Conic_2SP";
      this.MapAdvisor("EPSG");
      this.PrintAdvisor(9802L);
      Config config1 = this.PushMerchant("latitude_of_origin");
      Config config2 = this.PushMerchant("central_meridian");
      Config config3 = this.PushMerchant("standard_parallel_1");
      Config config4 = this.PushMerchant("standard_parallel_2");
      Config config5 = this.PushMerchant("false_easting");
      Config config6 = this.PushMerchant("false_northing");
      if (config1 == null)
        throw new ArgumentException("Missing projection parameter 'latitude_of_origin'");
      if (config2 == null)
        throw new ArgumentException("Missing projection parameter 'central_meridian'");
      if (config3 == null)
        throw new ArgumentException("Missing projection parameter 'standard_parallel_1'");
      if (config4 == null)
        throw new ArgumentException("Missing projection parameter 'standard_parallel_2'");
      if (config5 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (config6 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      double num1 = ValueObserverWatcher.PopAdvisor(config1.CountRegistry());
      double num2 = ValueObserverWatcher.PopAdvisor(config2.CountRegistry());
      double num3 = ValueObserverWatcher.PopAdvisor(config3.CountRegistry());
      double num4 = ValueObserverWatcher.PopAdvisor(config4.CountRegistry());
      this.creatorRegistry = config5.CountRegistry() * this.refRegistry;
      this.m_CollectionRegistry = config6.CountRegistry() * this.refRegistry;
      if (Math.Abs(num3 + num4) < 1E-10)
        throw new ArgumentException("Equal latitudes for St. Parallels on opposite sides of equator.");
      this.m_WrapperRegistry = 1.0 - Math.Pow(this._ConfigurationRegistry / this._InterpreterRegistry, 2.0);
      this.specificationRegistry = Math.Sqrt(this.m_WrapperRegistry);
      this._SystemRegistry = num2;
      this.serializerRegistry = num1;
      double map;
      double dic;
      ServiceObserverWatcher.ConcatAdvisor(num3, out map, out dic);
      double num5 = map;
      double num6 = ServiceObserverWatcher.CustomizeAdvisor(this.specificationRegistry, map, dic);
      double x1 = ServiceObserverWatcher.CheckAdvisor(this.specificationRegistry, num3, map);
      ServiceObserverWatcher.ConcatAdvisor(num4, out map, out dic);
      double num7 = ServiceObserverWatcher.CustomizeAdvisor(this.specificationRegistry, map, dic);
      double num8 = ServiceObserverWatcher.CheckAdvisor(this.specificationRegistry, num4, map);
      double x2 = ServiceObserverWatcher.CheckAdvisor(this.specificationRegistry, this.serializerRegistry, Math.Sin(this.serializerRegistry));
      this.m_QueueRegistry = Math.Abs(num3 - num4) <= 1E-10 ? num5 : Math.Log(num6 / num7) / Math.Log(x1 / num8);
      this.proccesorRegistry = num6 / (this.m_QueueRegistry * Math.Pow(x1, this.m_QueueRegistry));
      this.m_PredicateRegistry = this._InterpreterRegistry * this.proccesorRegistry * Math.Pow(x2, this.m_QueueRegistry);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ComputeMerchant(double[] task)
    {
      int num1 = 1;
      if (PolicyTemplate.TestModel())
        ;
      double num2;
      double num3;
      double[] merchant;
      while (true)
      {
        double x;
        double num4;
        double num5;
        int num6;
        double num7;
        switch (num1)
        {
          case 0:
            num2 = ValueObserverWatcher.PopAdvisor(task[1]);
            num6 = 8;
            break;
          case 1:
            num3 = ValueObserverWatcher.PopAdvisor(task[0]);
            num6 = 0;
            break;
          case 2:
          case 8:
            num5 = Math.Abs(Math.Abs(num2) - Math.PI / 2.0);
            num6 = 3;
            break;
          case 3:
            if (num5 <= 1E-10)
            {
              num5 = num2 * this.m_QueueRegistry;
              if (num5 > 0.0)
              {
                num4 = 0.0;
                num6 = 7;
                break;
              }
              goto label_3;
            }
            else
            {
              double consumer = Math.Sin(num2);
              x = ServiceObserverWatcher.CheckAdvisor(this.specificationRegistry, num2, consumer);
              goto case 5;
            }
          case 4:
          case 6:
            num2 = this.m_PredicateRegistry - num4 * Math.Cos(num7) + this.m_CollectionRegistry;
            if (task.Length != 2)
            {
              merchant = new double[3]
              {
                num3 / this.refRegistry,
                num2 / this.refRegistry,
                task[2]
              };
              num1 = 9;
              continue;
            }
            goto label_13;
          case 5:
            num4 = this._InterpreterRegistry * this.proccesorRegistry * Math.Pow(x, this.m_QueueRegistry);
            goto case 7;
          case 7:
            num7 = this.m_QueueRegistry * ServiceObserverWatcher.MoveAdvisor(num3 - this._SystemRegistry);
            num3 = num4 * Math.Sin(num7) + this.creatorRegistry;
            num1 = 4;
            continue;
          case 9:
            goto label_17;
          default:
            num1 = 5;
            continue;
        }
        num1 = num6;
      }
label_3:
      throw new ArgumentException();
label_13:
      merchant = new double[2]
      {
        num3 / this.refRegistry,
        num2 / this.refRegistry
      };
label_17:
      return merchant;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ConcatMerchant(double[] var1)
    {
      int num1 = 5;
      if (true)
        goto label_4;
label_1:
      double num2;
      double num3;
      double num4;
      double num5;
      if (this.m_QueueRegistry > 0.0)
      {
        num4 = Math.Sqrt(num2 * num2 + num3 * num3);
        goto label_19;
      }
      else
      {
        num4 = -Math.Sqrt(num2 * num2 + num3 * num3);
        num5 = -1.0;
        goto label_21;
      }
label_3:
      int num6;
      num1 = num6;
label_4:
      while (true)
      {
        switch (num1)
        {
          case 0:
            goto label_6;
          case 1:
          case 2:
            goto label_11;
          case 3:
          case 6:
            goto label_25;
          case 4:
            goto label_10;
          case 5:
            goto label_18;
          case 7:
            goto label_12;
          case 8:
            goto label_1;
          case 9:
            goto label_26;
          case 10:
            goto label_19;
          case 11:
            goto label_28;
          default:
            if (true)
            {
              num1 = 10;
              continue;
            }
            goto label_6;
        }
      }
label_6:
      int num7 = this.m_QueueRegistry > 0.0 ? 1 : 0;
      goto label_8;
label_11:
      double key1 = double.NaN;
      num6 = 4;
      goto label_3;
label_12:
      bool flag;
      if (flag)
        throw new ArgumentException();
      goto label_16;
label_25:
      num2 = var1[0] * this.refRegistry - this.creatorRegistry;
      num3 = this.m_PredicateRegistry - var1[1] * this.refRegistry + this.m_CollectionRegistry;
      num6 = 8;
      goto label_3;
label_26:
      double key2;
      double[] numArray = new double[2]
      {
        ValueObserverWatcher.SetAdvisor(key2),
        ValueObserverWatcher.SetAdvisor(key1)
      };
label_28:
      return numArray;
label_8:
      long res;
      if (num7 != 0)
      {
        double y = 1.0 / this.m_QueueRegistry;
        key1 = ServiceObserverWatcher.UpdateAdvisor(this.specificationRegistry, Math.Pow(num4 / (this._InterpreterRegistry * this.proccesorRegistry), y), out res);
        flag = res != 0L;
        if (PolicyTemplate.PopModel())
        {
          num1 = 7;
          goto label_4;
        }
      }
      else
      {
        key1 = -1.0 * Math.PI / 2.0;
        goto label_16;
      }
label_10:
      res = 0L;
      num6 = 6;
      goto label_3;
label_16:
      double num8;
      key2 = ServiceObserverWatcher.MoveAdvisor(num8 / this.m_QueueRegistry + this._SystemRegistry);
      if (var1.Length == 2)
      {
        if (true)
        {
          num1 = 9;
          goto label_4;
        }
      }
      else
      {
        numArray = new double[3]
        {
          ValueObserverWatcher.SetAdvisor(key2),
          ValueObserverWatcher.SetAdvisor(key1),
          var1[2]
        };
        num1 = 11;
        goto label_4;
      }
label_18:
      key2 = double.NaN;
      num6 = 2;
      goto label_3;
label_19:
      num5 = 1.0;
label_21:
      num8 = 0.0;
      if (num4 != 0.0)
        num8 = Math.Atan2(num5 * num2, num5 * num3);
      if (num4 != 0.0)
      {
        num7 = 1;
        goto label_8;
      }
      else
      {
        num6 = 0;
        goto label_3;
      }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override OrderValuePool ManageItem()
    {
      int num = 4;
      bool flag;
      OrderValuePool interceptorRegistry;
      while (true)
      {
        switch (num)
        {
          case 0:
          case 4:
            flag = this.m_InterceptorRegistry == null;
            num = 1;
            continue;
          case 1:
            if (flag)
            {
              this.m_InterceptorRegistry = (ValueObserverWatcher) new PolicyTemplate(this.globalRegistry, !this._PropertyRegistry);
              goto case 2;
            }
            else
              goto case 2;
          case 2:
          case 3:
            interceptorRegistry = (OrderValuePool) this.m_InterceptorRegistry;
            if (true)
            {
              num = 5;
              continue;
            }
            goto label_7;
          case 5:
            goto label_7;
          default:
            num = 3;
            continue;
        }
      }
label_7:
      return interceptorRegistry;
    }

    internal static bool PopModel() => true;

    internal static bool TestModel() => false;
  }
}
