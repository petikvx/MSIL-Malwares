// Decompiled with JetBrains decompiler
// Type: PATH_F.Astar
// Assembly: PATH_F, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 83C76E89-0EC0-4556-AC03-47BAF793022C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Exploit.MSIL.Shellcode.gen-3e61ff7da9c135135af8936d7fb362a285b02c6431c8614eda55d2cce3bf3ff7.exe

using System;
using System.Collections.Generic;
using System.Linq;

namespace PATH_F
{
  public class Astar
  {
    private static List<Cell> Dostepne_cell(
      int rozmiar,
      Cell aktualna,
      Cell szukana,
      List<Cell> lista_cell)
    {
      List<Cell> potencjalnaCell = new List<Cell>()
      {
        new Cell()
        {
          x = aktualna.x + 1,
          y = aktualna.y,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 10
        },
        new Cell()
        {
          x = aktualna.x - 1,
          y = aktualna.y,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 10
        },
        new Cell()
        {
          x = aktualna.x,
          y = aktualna.y + 1,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 10
        },
        new Cell()
        {
          x = aktualna.x,
          y = aktualna.y - 1,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 10
        },
        new Cell()
        {
          x = aktualna.x - 1,
          y = aktualna.y - 1,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 14
        },
        new Cell()
        {
          x = aktualna.x - 1,
          y = aktualna.y + 1,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 14
        },
        new Cell()
        {
          x = aktualna.x + 1,
          y = aktualna.y - 1,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 14
        },
        new Cell()
        {
          x = aktualna.x + 1,
          y = aktualna.y + 1,
          Rodzic = aktualna,
          Koszt = aktualna.Koszt + 14
        }
      };
      potencjalnaCell.ForEach((Action<Cell>) (cell =>
      {
        if (cell.y >= 0 && cell.y <= rozmiar - 1 && cell.x >= 0 && cell.x <= rozmiar - 1)
        {
          cell.start = lista_cell[cell.x + cell.y * rozmiar].start;
          cell.end = lista_cell[cell.x + cell.y * rozmiar].end;
          cell.przeszkoda = lista_cell[cell.x + cell.y * rozmiar].przeszkoda;
          cell.main = lista_cell[cell.x + cell.y * rozmiar].main;
          cell.SetDistance(szukana.x, szukana.y);
          cell.KosztDystansu = cell.Dystans + (double) cell.Koszt;
          cell.index = cell.x + cell.y * rozmiar;
          int num = cell.start ? 0 : (!cell.przeszkoda ? 1 : 0);
          cell.walkable = num != 0;
          if (cell.x == aktualna.x - 1 && cell.y == aktualna.y - 1 && potencjalnaCell[1].przeszkoda && potencjalnaCell[3].przeszkoda)
            cell.walkable = false;
          if (cell.x == aktualna.x - 1 && cell.y == aktualna.y + 1 && potencjalnaCell[1].przeszkoda && potencjalnaCell[2].przeszkoda)
            cell.walkable = false;
          if (cell.x == aktualna.x + 1 && cell.y == aktualna.y - 1 && potencjalnaCell[0].przeszkoda && potencjalnaCell[3].przeszkoda)
            cell.walkable = false;
          if (cell.x != aktualna.x + 1 || cell.y != aktualna.y + 1 || !potencjalnaCell[0].przeszkoda || !potencjalnaCell[2].przeszkoda)
            return;
          cell.walkable = false;
        }
        else
          cell.walkable = false;
      }));
      return potencjalnaCell.Where<Cell>((Func<Cell, bool>) (cell => cell.walkable)).ToList<Cell>();
    }
  }
}
