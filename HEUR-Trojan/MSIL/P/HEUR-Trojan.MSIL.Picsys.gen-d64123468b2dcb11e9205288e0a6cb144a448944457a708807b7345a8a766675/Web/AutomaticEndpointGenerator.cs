// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Web.AutomaticEndpointGenerator
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Collections.Generic;
using System.Configuration;
using System.Net;
using System.ServiceModel.Activation;
using System.ServiceModel.Channels;
using System.ServiceModel.Configuration;
using System.ServiceModel.Description;

namespace System.ServiceModel.Web
{
  internal abstract class AutomaticEndpointGenerator
  {
    private IDictionary<string, ContractDescription> implementedContracts;
    private string multipleContractsErrorMessage;
    private string noContractErrorMessage;
    private string standardEndpointKind;
    private System.Type singleImplementedContract;

    protected AutomaticEndpointGenerator(
      IDictionary<string, ContractDescription> implementedContracts,
      string multipleContractsErrorMessage,
      string noContractErrorMessage,
      string standardEndpointKind)
    {
      this.implementedContracts = implementedContracts;
      this.multipleContractsErrorMessage = multipleContractsErrorMessage;
      this.noContractErrorMessage = noContractErrorMessage;
      this.standardEndpointKind = standardEndpointKind;
    }

    protected abstract string BindingCollectionElementName { get; }

    public ServiceEndpoint GenerateServiceEndpoint(
      ServiceHostBase serviceHost,
      Uri baseAddress)
    {
      AuthenticationSchemes authenticationSchemes = AutomaticEndpointGenerator.GetAuthenticationSchemes(baseAddress);
      System.Type implementedContract = this.GetSingleImplementedContract();
      ConfigLoader configLoader = new ConfigLoader(serviceHost.GetContractResolver(this.implementedContracts));
      ServiceEndpointElement serviceEndpointElement = new ServiceEndpointElement();
      serviceEndpointElement.Contract = implementedContract.FullName;
      this.SetBindingConfiguration(baseAddress.Scheme, serviceEndpointElement);
      serviceEndpointElement.Kind = this.standardEndpointKind;
      ServiceEndpoint endpoint = configLoader.LookupEndpoint(serviceEndpointElement, (ContextInformation) null, serviceHost, serviceHost.Description, true);
      this.ConfigureBinding(endpoint.Binding, baseAddress.Scheme, authenticationSchemes, AspNetEnvironment.Enabled);
      ConfigLoader.ConfigureEndpointAddress(serviceEndpointElement, serviceHost, endpoint);
      ConfigLoader.ConfigureEndpointListenUri(serviceEndpointElement, serviceHost, endpoint);
      return endpoint;
    }

    protected abstract void ConfigureBinding(
      Binding binding,
      string uriScheme,
      AuthenticationSchemes supportedAuthenticationSchemes,
      bool hostedEnvironment);

    private static AuthenticationSchemes GetAuthenticationSchemes(
      Uri baseAddress)
    {
      AuthenticationSchemes authenticationSchemes = AspNetEnvironment.Current.GetAuthenticationSchemes(baseAddress);
      if (AspNetEnvironment.Current.IsSimpleApplicationHost && authenticationSchemes == (AuthenticationSchemes.Ntlm | AuthenticationSchemes.Anonymous))
        authenticationSchemes = !AspNetEnvironment.Current.IsWindowsAuthenticationConfigured() ? AuthenticationSchemes.Anonymous : AuthenticationSchemes.Ntlm;
      return authenticationSchemes;
    }

    private System.Type GetSingleImplementedContract()
    {
      if (this.singleImplementedContract == (System.Type) null)
      {
        if (this.implementedContracts.Count > 1)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new InvalidOperationException(this.multipleContractsErrorMessage));
        if (this.implementedContracts.Count == 0)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new InvalidOperationException(this.noContractErrorMessage));
        using (IEnumerator<ContractDescription> enumerator = this.implementedContracts.Values.GetEnumerator())
        {
          if (enumerator.MoveNext())
            this.singleImplementedContract = enumerator.Current.ContractType;
        }
      }
      return this.singleImplementedContract;
    }

    private void SetBindingConfiguration(
      string uriScheme,
      ServiceEndpointElement serviceEndpointElement)
    {
      ProtocolMappingItem protocolMappingItem = ConfigLoader.LookupProtocolMapping(uriScheme);
      if (protocolMappingItem == null || !string.Equals(protocolMappingItem.Binding, this.BindingCollectionElementName, StringComparison.Ordinal))
        return;
      serviceEndpointElement.BindingConfiguration = protocolMappingItem.BindingConfiguration;
    }
  }
}
