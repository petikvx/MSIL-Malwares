// Decompiled with JetBrains decompiler
// Type: VenomRAT_HVNC.StreamLibrary.UnsafeCodecs.UnsafeStreamCodec
// Assembly: VenomRAT_HVNC, Version=5.0.4.0, Culture=neutral, PublicKeyToken=null
// MVID: 364FC72B-4DB8-403E-BB7F-732199A12380
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-666d190a7059c03b3572dd66e51b8232537a8650bbdcbfbe3f8335c830f3aeae.exe

using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace VenomRAT_HVNC.StreamLibrary.UnsafeCodecs
{
  public class UnsafeStreamCodec : IUnsafeCodec
  {
    private byte[] EncodeBuffer;
    private Bitmap decodedBitmap;
    private PixelFormat EncodedFormat;
    private int EncodedWidth;
    private int EncodedHeight;
    private bool UseJPEG;

    public override ulong CachedSize { get; internal set; }

    public override int BufferCount => 1;

    public override CodecOption CodecOptions => CodecOption.RequireSameSize;

    public Size CheckBlock { get; private set; }

    public override event IVideoCodec.VideoDebugScanningDelegate onCodeDebugScan;

    public override event IVideoCodec.VideoDebugScanningDelegate onDecodeDebugScan;

    public UnsafeStreamCodec(int ImageQuality = 100, bool UseJPEG = true)
      : base(ImageQuality)
    {
      this.CheckBlock = new Size(50, 1);
      this.UseJPEG = UseJPEG;
    }

    public override unsafe void CodeImage(
      IntPtr Scan0,
      Rectangle ScanArea,
      Size ImageSize,
      PixelFormat Format,
      Stream outStream)
    {
      lock (this.ImageProcessLock)
      {
        int int32 = Scan0.ToInt32();
        if (!outStream.CanWrite)
          throw new Exception("Must have access to Write in the Stream");
        int num1;
        if (Format <= PixelFormat.Format32bppRgb)
        {
          if (Format == PixelFormat.Format24bppRgb || Format == PixelFormat.Format32bppRgb)
          {
            num1 = 3;
            goto label_9;
          }
        }
        else if (Format == PixelFormat.Format32bppPArgb || Format == PixelFormat.Format32bppArgb)
        {
          num1 = 4;
          goto label_9;
        }
        throw new NotSupportedException(Format.ToString());
label_9:
        int stride = ImageSize.Width * num1;
        int count1 = stride * ImageSize.Height;
        if (this.EncodeBuffer == null)
        {
          this.EncodedFormat = Format;
          this.EncodedWidth = ImageSize.Width;
          this.EncodedHeight = ImageSize.Height;
          this.EncodeBuffer = new byte[count1];
          byte[] encodeBuffer;
          byte* numPtr = (encodeBuffer = this.EncodeBuffer) != null && encodeBuffer.Length != 0 ? (byte*) encodeBuffer[0] : (byte*) null;
          byte[] buffer = (byte[]) null;
          using (Bitmap bmp = new Bitmap(ImageSize.Width, ImageSize.Height, stride, Format, Scan0))
            buffer = this.jpgCompression.Compress(bmp);
          outStream.Write(BitConverter.GetBytes(buffer.Length), 0, 4);
          outStream.Write(buffer, 0, buffer.Length);
          VenomRAT_HVNC.StreamLibrary.src.NativeMethods.memcpy(new IntPtr((void*) numPtr), Scan0, (uint) count1);
        }
        else
        {
          long position1 = outStream.Position;
          outStream.Write(new byte[4], 0, 4);
          int num2 = 0;
          if (this.EncodedFormat != Format)
            throw new Exception("PixelFormat is not equal to previous Bitmap");
          if (this.EncodedWidth != ImageSize.Width || this.EncodedHeight != ImageSize.Height)
            throw new Exception("Bitmap width/height are not equal to previous bitmap");
          List<Rectangle> rectangleList1 = new List<Rectangle>();
          Size size1 = new Size(ScanArea.Width, this.CheckBlock.Height);
          Size size2 = new Size(ScanArea.Width % this.CheckBlock.Width, ScanArea.Height % this.CheckBlock.Height);
          int num3 = ScanArea.Height - size2.Height;
          int num4 = ScanArea.Width - size2.Width;
          Rectangle ScanArea1 = new Rectangle();
          List<Rectangle> rectangleList2 = new List<Rectangle>();
          size1 = new Size(ScanArea.Width, size1.Height);
          byte[] encodeBuffer;
          byte* numPtr = (encodeBuffer = this.EncodeBuffer) != null && encodeBuffer.Length != 0 ? (byte*) encodeBuffer[0] : (byte*) null;
          Rectangle rectangle1;
          for (int y1 = ScanArea.Y; y1 != ScanArea.Height; y1 += size1.Height)
          {
            if (y1 == num3)
              size1 = new Size(ScanArea.Width, size2.Height);
            ScanArea1 = new Rectangle(ScanArea.X, y1, ScanArea.Width, size1.Height);
            if (this.onCodeDebugScan != null)
              this.onCodeDebugScan(ScanArea1);
            int num5 = y1 * stride + ScanArea.X * num1;
            int index = rectangleList1.Count - 1;
            int num6;
            if (rectangleList1.Count != 0)
            {
              rectangle1 = rectangleList1[index];
              int y2 = rectangle1.Y;
              rectangle1 = rectangleList1[index];
              int height = rectangle1.Height;
              num6 = y2 + height == ScanArea1.Y ? 1 : 0;
            }
            else
              num6 = 0;
            if (num6 != 0)
            {
              ref Rectangle local = ref ScanArea1;
              rectangle1 = rectangleList1[index];
              int x = rectangle1.X;
              rectangle1 = rectangleList1[index];
              int y3 = rectangle1.Y;
              rectangle1 = rectangleList1[index];
              int width = rectangle1.Width;
              rectangle1 = rectangleList1[index];
              int height = rectangle1.Height + ScanArea1.Height;
              local = new Rectangle(x, y3, width, height);
              rectangleList1[index] = ScanArea1;
            }
            else
              rectangleList1.Add(ScanArea1);
          }
          int index1 = 0;
          int x1 = ScanArea.X;
          for (; index1 < rectangleList1.Count; ++index1)
          {
            ref Size local1 = ref size1;
            int width1 = this.CheckBlock.Width;
            rectangle1 = rectangleList1[index1];
            int height1 = rectangle1.Height;
            local1 = new Size(width1, height1);
            for (int x2 = ScanArea.X; x2 != ScanArea.Width; x2 += size1.Width)
            {
              if (x2 == num4)
              {
                ref Size local2 = ref size1;
                int width2 = size2.Width;
                rectangle1 = rectangleList1[index1];
                int height2 = rectangle1.Height;
                local2 = new Size(width2, height2);
              }
              ref Rectangle local3 = ref ScanArea1;
              int x3 = x2;
              rectangle1 = rectangleList1[index1];
              int y = rectangle1.Y;
              int width3 = size1.Width;
              rectangle1 = rectangleList1[index1];
              int height3 = rectangle1.Height;
              local3 = new Rectangle(x3, y, width3, height3);
              bool flag = false;
              int count2 = num1 * ScanArea1.Width;
              for (int index2 = 0; index2 < ScanArea1.Height; ++index2)
              {
                int num7 = stride * (ScanArea1.Y + index2) + num1 * ScanArea1.X;
                flag = true;
                VenomRAT_HVNC.StreamLibrary.src.NativeMethods.memcpy((void*) (numPtr + num7), (void*) (int32 + num7), (uint) count2);
              }
              if (this.onCodeDebugScan != null)
                this.onCodeDebugScan(ScanArea1);
              if (flag)
              {
                int index3 = rectangleList2.Count - 1;
                int num8;
                if (rectangleList2.Count > 0)
                {
                  rectangle1 = rectangleList2[index3];
                  int x4 = rectangle1.X;
                  rectangle1 = rectangleList2[index3];
                  int width4 = rectangle1.Width;
                  num8 = x4 + width4 == ScanArea1.X ? 1 : 0;
                }
                else
                  num8 = 0;
                if (num8 != 0)
                {
                  Rectangle rectangle2 = rectangleList2[index3];
                  int width5 = ScanArea1.Width + rectangle2.Width;
                  ScanArea1 = new Rectangle(rectangle2.X, rectangle2.Y, width5, rectangle2.Height);
                  rectangleList2[index3] = ScanArea1;
                }
                else
                  rectangleList2.Add(ScanArea1);
              }
            }
          }
          for (int index4 = 0; index4 < rectangleList2.Count; ++index4)
          {
            Rectangle rectangle3 = rectangleList2[index4];
            int count3 = num1 * rectangle3.Width;
            Bitmap bmp = new Bitmap(rectangle3.Width, rectangle3.Height, Format);
            BitmapData bitmapdata = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadWrite, bmp.PixelFormat);
            int num9 = 0;
            int num10 = 0;
            for (; num9 < rectangle3.Height; ++num9)
            {
              int num11 = stride * (rectangle3.Y + num9) + num1 * rectangle3.X;
              VenomRAT_HVNC.StreamLibrary.src.NativeMethods.memcpy((void*) ((IntPtr) bitmapdata.Scan0.ToPointer() + num10), (void*) (int32 + num11), (uint) count3);
              num10 += count3;
            }
            bmp.UnlockBits(bitmapdata);
            outStream.Write(BitConverter.GetBytes(rectangle3.X), 0, 4);
            outStream.Write(BitConverter.GetBytes(rectangle3.Y), 0, 4);
            outStream.Write(BitConverter.GetBytes(rectangle3.Width), 0, 4);
            outStream.Write(BitConverter.GetBytes(rectangle3.Height), 0, 4);
            outStream.Write(new byte[4], 0, 4);
            long length = outStream.Length;
            long position2 = outStream.Position;
            if (this.UseJPEG)
              this.jpgCompression.Compress(bmp, ref outStream);
            else
              this.lzwCompression.Compress(bmp, outStream);
            long num12 = outStream.Position - length;
            outStream.Position = position2 - 4L;
            outStream.Write(BitConverter.GetBytes((int) num12), 0, 4);
            outStream.Position += num12;
            bmp.Dispose();
            num2 += (int) num12 + 20;
          }
          outStream.Position = position1;
          outStream.Write(BitConverter.GetBytes(num2), 0, 4);
          rectangleList1.Clear();
          rectangleList2.Clear();
        }
      }
    }

    public override unsafe Bitmap DecodeData(IntPtr CodecBuffer, uint Length)
    {
      if (Length < 4U)
        return this.decodedBitmap;
      int count = *(int*) (void*) CodecBuffer;
      if (this.decodedBitmap != null)
        return this.decodedBitmap;
      byte[] buffer = new byte[count];
      byte[] numArray;
      VenomRAT_HVNC.StreamLibrary.src.NativeMethods.memcpy(new IntPtr((numArray = buffer) != null && numArray.Length != 0 ? (void*) numArray[0] : (void*) null), new IntPtr(CodecBuffer.ToInt32() + 4), (uint) count);
      this.decodedBitmap = (Bitmap) Image.FromStream((Stream) new MemoryStream(buffer));
      return this.decodedBitmap;
    }

    public override Bitmap DecodeData(Stream inStream)
    {
      Bitmap bitmap1;
      try
      {
        byte[] buffer1 = new byte[4];
        inStream.Read(buffer1, 0, 4);
        int int32_1 = BitConverter.ToInt32(buffer1, 0);
        if (this.decodedBitmap == null)
        {
          byte[] buffer2 = new byte[int32_1];
          inStream.Read(buffer2, 0, buffer2.Length);
          this.decodedBitmap = (Bitmap) Image.FromStream((Stream) new MemoryStream(buffer2));
          bitmap1 = this.decodedBitmap;
        }
        else
        {
          int int32_2;
          using (Graphics graphics = Graphics.FromImage((Image) this.decodedBitmap))
          {
            for (; int32_1 > 0; int32_1 -= int32_2 + 20)
            {
              byte[] buffer3 = new byte[20];
              inStream.Read(buffer3, 0, buffer3.Length);
              Rectangle ScanArea = new Rectangle(BitConverter.ToInt32(buffer3, 0), BitConverter.ToInt32(buffer3, 4), BitConverter.ToInt32(buffer3, 8), BitConverter.ToInt32(buffer3, 12));
              int32_2 = BitConverter.ToInt32(buffer3, 16);
              byte[] buffer4 = new byte[int32_2];
              inStream.Read(buffer4, 0, buffer4.Length);
              if (this.onDecodeDebugScan != null)
                this.onDecodeDebugScan(ScanArea);
              using (MemoryStream memoryStream = new MemoryStream(buffer4))
              {
                using (Bitmap bitmap2 = (Bitmap) Image.FromStream((Stream) memoryStream))
                  graphics.DrawImage((Image) bitmap2, ScanArea.Location);
              }
            }
          }
          bitmap1 = this.decodedBitmap;
        }
      }
      catch
      {
        bitmap1 = (Bitmap) null;
      }
      return bitmap1;
    }
  }
}
