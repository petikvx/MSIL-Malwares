// Decompiled with JetBrains decompiler
// Type: BlackNET_Builder.ThemeControl154
// Assembly: BlackNET Builder, Version=3.7.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 4B8A14F4-2444-48A4-BCEA-3077100A9E22
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Agent.gen-f4461e8b0f3831b6ee77d57f52dd74f28e79114bc5bb29d6b7ab5ca3adbf27f6.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Windows.Forms;

namespace BlackNET_Builder
{
  internal abstract class ThemeControl154 : Control
  {
    protected Graphics G;
    protected Bitmap B;
    private bool DoneCreation;
    private bool InPosition;
    protected MouseState State;
    private bool _BackColor;
    private bool _NoRounding;
    private Image _Image;
    private bool _Transparent;
    private Dictionary<string, Color> Items;
    private string _Customization;
    private Size _ImageSize;
    private int _LockWidth;
    private int _LockHeight;
    private bool _IsAnimated;
    private Rectangle OffsetReturnRectangle;
    private Size OffsetReturnSize;
    private Point OffsetReturnPoint;
    private Point CenterReturn;
    private Bitmap MeasureBitmap;
    private Graphics MeasureGraphics;
    private SolidBrush DrawPixelBrush;
    private SolidBrush DrawCornersBrush;
    private Point DrawTextPoint;
    private Size DrawTextSize;
    private Point DrawImagePoint;
    private LinearGradientBrush DrawGradientBrush;
    private Rectangle DrawGradientRectangle;
    private GraphicsPath DrawRadialPath;
    private PathGradientBrush DrawRadialBrush1;
    private LinearGradientBrush DrawRadialBrush2;
    private Rectangle DrawRadialRectangle;
    private GraphicsPath CreateRoundPath;
    private Rectangle CreateRoundRectangle;

    public ThemeControl154()
    {
      this.Items = new Dictionary<string, Color>();
      this.SetStyle(ControlStyles.UserPaint | ControlStyles.Opaque | ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, true);
      this._ImageSize = Size.Empty;
      this.Font = new Font("Verdana", 8f);
      this.MeasureBitmap = new Bitmap(1, 1);
      this.MeasureGraphics = Graphics.FromImage((Image) this.MeasureBitmap);
      this.DrawRadialPath = new GraphicsPath();
      this.InvalidateCustimization();
    }

    protected override sealed void OnHandleCreated(EventArgs e)
    {
      this.InvalidateCustimization();
      this.ColorHook();
      if (this._LockWidth != 0)
        this.Width = this._LockWidth;
      if (this._LockHeight != 0)
        this.Height = this._LockHeight;
      this.Transparent = this._Transparent;
      if (this._Transparent && this._BackColor)
        this.BackColor = Color.Transparent;
      base.OnHandleCreated(e);
    }

    protected override sealed void OnParentChanged(EventArgs e)
    {
      if (this.Parent != null)
      {
        this.OnCreation();
        this.DoneCreation = true;
        this.InvalidateTimer();
      }
      base.OnParentChanged(e);
    }

    private void DoAnimation(bool i)
    {
      this.OnAnimation();
      if (!i)
        return;
      this.Invalidate();
    }

    protected override sealed void OnPaint(PaintEventArgs e)
    {
      if (this.Width == 0 || this.Height == 0)
        return;
      if (this._Transparent)
      {
        this.PaintHook();
        e.Graphics.DrawImage((Image) this.B, 0, 0);
      }
      else
      {
        this.G = e.Graphics;
        this.PaintHook();
      }
    }

    protected override void OnHandleDestroyed(EventArgs e)
    {
      ThemeShare.RemoveAnimationCallback(new ThemeShare.AnimationDelegate(this.DoAnimation));
      base.OnHandleDestroyed(e);
    }

    protected override sealed void OnSizeChanged(EventArgs e)
    {
      if (this._Transparent)
        this.InvalidateBitmap();
      this.Invalidate();
      base.OnSizeChanged(e);
    }

    protected override void SetBoundsCore(
      int x,
      int y,
      int width,
      int height,
      BoundsSpecified specified)
    {
      if (this._LockWidth != 0)
        width = this._LockWidth;
      if (this._LockHeight != 0)
        height = this._LockHeight;
      base.SetBoundsCore(x, y, width, height, specified);
    }

    protected override void OnMouseEnter(EventArgs e)
    {
      this.InPosition = true;
      this.SetState(MouseState.Over);
      base.OnMouseEnter(e);
    }

    protected override void OnMouseUp(MouseEventArgs e)
    {
      if (this.InPosition)
        this.SetState(MouseState.Over);
      base.OnMouseUp(e);
    }

    protected override void OnMouseDown(MouseEventArgs e)
    {
      if (e.Button == MouseButtons.Left)
        this.SetState(MouseState.Down);
      base.OnMouseDown(e);
    }

    protected override void OnMouseLeave(EventArgs e)
    {
      this.InPosition = false;
      this.SetState(MouseState.None);
      base.OnMouseLeave(e);
    }

    protected override void OnEnabledChanged(EventArgs e)
    {
      if (this.Enabled)
        this.SetState(MouseState.None);
      else
        this.SetState(MouseState.Block);
      base.OnEnabledChanged(e);
    }

    private void SetState(MouseState current)
    {
      this.State = current;
      this.Invalidate();
    }

    [EditorBrowsable(EditorBrowsableState.Never)]
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override Color ForeColor
    {
      get => Color.Empty;
      set
      {
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override Image BackgroundImage
    {
      get => (Image) null;
      set
      {
      }
    }

    [EditorBrowsable(EditorBrowsableState.Never)]
    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override ImageLayout BackgroundImageLayout
    {
      get => ImageLayout.None;
      set
      {
      }
    }

    public override string Text
    {
      get => base.Text;
      set
      {
        base.Text = value;
        this.Invalidate();
      }
    }

    public override Font Font
    {
      get => base.Font;
      set
      {
        base.Font = value;
        this.Invalidate();
      }
    }

    [Category("Misc")]
    public override Color BackColor
    {
      get => base.BackColor;
      set
      {
        if (!this.IsHandleCreated && value == Color.Transparent)
        {
          this._BackColor = true;
        }
        else
        {
          base.BackColor = value;
          if (this.Parent == null)
            return;
          this.ColorHook();
        }
      }
    }

    public bool NoRounding
    {
      get => this._NoRounding;
      set
      {
        this._NoRounding = value;
        this.Invalidate();
      }
    }

    public Image Image
    {
      get => this._Image;
      set
      {
        this._ImageSize = value != null ? value.Size : Size.Empty;
        this._Image = value;
        this.Invalidate();
      }
    }

    public bool Transparent
    {
      get => this._Transparent;
      set
      {
        this._Transparent = value;
        if (!this.IsHandleCreated)
          return;
        if (!value && this.BackColor.A != byte.MaxValue)
          throw new Exception("Unable to change value to false while a transparent BackColor is in use.");
        this.SetStyle(ControlStyles.Opaque, !value);
        this.SetStyle(ControlStyles.SupportsTransparentBackColor, value);
        if (value)
          this.InvalidateBitmap();
        else
          this.B = (Bitmap) null;
        this.Invalidate();
      }
    }

    public Bloom[] Colors
    {
      get
      {
        List<Bloom> bloomList = new List<Bloom>();
        Dictionary<string, Color>.Enumerator enumerator = this.Items.GetEnumerator();
        while (enumerator.MoveNext())
          bloomList.Add(new Bloom(enumerator.Current.Key, enumerator.Current.Value));
        return bloomList.ToArray();
      }
      set
      {
        Bloom[] bloomArray = value;
        int index = 0;
        while (index < bloomArray.Length)
        {
          Bloom bloom = bloomArray[index];
          if (this.Items.ContainsKey(bloom.Name))
            this.Items[bloom.Name] = bloom.Value;
          checked { ++index; }
        }
        this.InvalidateCustimization();
        this.ColorHook();
        this.Invalidate();
      }
    }

    public string Customization
    {
      get => this._Customization;
      set
      {
        if (Operators.CompareString(value, this._Customization, false) == 0)
          return;
        Bloom[] colors = this.Colors;
        try
        {
          byte[] numArray = Convert.FromBase64String(value);
          int num = checked (colors.Length - 1);
          int index = 0;
          while (index <= num)
          {
            colors[index].Value = Color.FromArgb(BitConverter.ToInt32(numArray, checked (index * 4)));
            checked { ++index; }
          }
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
          return;
        }
        this._Customization = value;
        this.Colors = colors;
        this.ColorHook();
        this.Invalidate();
      }
    }

    protected Size ImageSize => this._ImageSize;

    protected int LockWidth
    {
      get => this._LockWidth;
      set
      {
        this._LockWidth = value;
        if (this.LockWidth == 0 || !this.IsHandleCreated)
          return;
        this.Width = this.LockWidth;
      }
    }

    protected int LockHeight
    {
      get => this._LockHeight;
      set
      {
        this._LockHeight = value;
        if (this.LockHeight == 0 || !this.IsHandleCreated)
          return;
        this.Height = this.LockHeight;
      }
    }

    protected bool IsAnimated
    {
      get => this._IsAnimated;
      set
      {
        this._IsAnimated = value;
        this.InvalidateTimer();
      }
    }

    protected Pen GetPen(string name) => new Pen(this.Items[name]);

    protected Pen GetPen(string name, float width) => new Pen(this.Items[name], width);

    protected SolidBrush GetBrush(string name) => new SolidBrush(this.Items[name]);

    protected Color GetColor(string name) => this.Items[name];

    protected void SetColor(string name, Color value)
    {
      if (this.Items.ContainsKey(name))
        this.Items[name] = value;
      else
        this.Items.Add(name, value);
    }

    protected void SetColor(string name, byte r, byte g, byte b) => this.SetColor(name, Color.FromArgb((int) r, (int) g, (int) b));

    protected void SetColor(string name, byte a, byte r, byte g, byte b) => this.SetColor(name, Color.FromArgb((int) a, (int) r, (int) g, (int) b));

    protected void SetColor(string name, byte a, Color value) => this.SetColor(name, Color.FromArgb((int) a, value));

    private void InvalidateBitmap()
    {
      if (this.Width == 0 || this.Height == 0)
        return;
      this.B = new Bitmap(this.Width, this.Height, PixelFormat.Format32bppPArgb);
      this.G = Graphics.FromImage((Image) this.B);
    }

    private void InvalidateCustimization()
    {
      MemoryStream memoryStream = new MemoryStream(checked (this.Items.Count * 4));
      Bloom[] colors = this.Colors;
      int index = 0;
      while (index < colors.Length)
      {
        Bloom bloom = colors[index];
        memoryStream.Write(BitConverter.GetBytes(bloom.Value.ToArgb()), 0, 4);
        checked { ++index; }
      }
      memoryStream.Close();
      this._Customization = Convert.ToBase64String(memoryStream.ToArray());
    }

    private void InvalidateTimer()
    {
      if (this.DesignMode || !this.DoneCreation)
        return;
      if (this._IsAnimated)
        ThemeShare.AddAnimationCallback(new ThemeShare.AnimationDelegate(this.DoAnimation));
      else
        ThemeShare.RemoveAnimationCallback(new ThemeShare.AnimationDelegate(this.DoAnimation));
    }

    protected abstract void ColorHook();

    protected abstract void PaintHook();

    protected virtual void OnCreation()
    {
    }

    protected virtual void OnAnimation()
    {
    }

    protected Rectangle Offset(Rectangle r, int amount)
    {
      this.OffsetReturnRectangle = new Rectangle(checked (r.X + amount), checked (r.Y + amount), checked (r.Width - amount * 2), checked (r.Height - amount * 2));
      return this.OffsetReturnRectangle;
    }

    protected Size Offset(Size s, int amount)
    {
      this.OffsetReturnSize = new Size(checked (s.Width + amount), checked (s.Height + amount));
      return this.OffsetReturnSize;
    }

    protected Point Offset(Point p, int amount)
    {
      this.OffsetReturnPoint = new Point(checked (p.X + amount), checked (p.Y + amount));
      return this.OffsetReturnPoint;
    }

    protected Point Center(Rectangle p, Rectangle c)
    {
      this.CenterReturn = new Point(checked (unchecked (p.Width / 2) - unchecked (c.Width / 2) + p.X + c.X), checked (unchecked (p.Height / 2) - unchecked (c.Height / 2) + p.Y + c.Y));
      return this.CenterReturn;
    }

    protected Point Center(Rectangle p, Size c)
    {
      this.CenterReturn = new Point(checked (unchecked (p.Width / 2) - unchecked (c.Width / 2) + p.X), checked (unchecked (p.Height / 2) - unchecked (c.Height / 2) + p.Y));
      return this.CenterReturn;
    }

    protected Point Center(Rectangle child) => this.Center(this.Width, this.Height, child.Width, child.Height);

    protected Point Center(Size child) => this.Center(this.Width, this.Height, child.Width, child.Height);

    protected Point Center(int childWidth, int childHeight) => this.Center(this.Width, this.Height, childWidth, childHeight);

    protected Point Center(Size p, Size c) => this.Center(p.Width, p.Height, c.Width, c.Height);

    protected Point Center(int pWidth, int pHeight, int cWidth, int cHeight)
    {
      this.CenterReturn = new Point(checked (unchecked (pWidth / 2) - unchecked (cWidth / 2)), checked (unchecked (pHeight / 2) - unchecked (cHeight / 2)));
      return this.CenterReturn;
    }

    protected Size Measure() => this.MeasureGraphics.MeasureString(this.Text, this.Font, this.Width).ToSize();

    protected Size Measure(string text) => this.MeasureGraphics.MeasureString(text, this.Font, this.Width).ToSize();

    protected void DrawPixel(Color c1, int x, int y)
    {
      if (this._Transparent)
      {
        this.B.SetPixel(x, y, c1);
      }
      else
      {
        this.DrawPixelBrush = new SolidBrush(c1);
        this.G.FillRectangle((Brush) this.DrawPixelBrush, x, y, 1, 1);
      }
    }

    protected void DrawCorners(Color c1, int offset) => this.DrawCorners(c1, 0, 0, this.Width, this.Height, offset);

    protected void DrawCorners(Color c1, Rectangle r1, int offset) => this.DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height, offset);

    protected void DrawCorners(Color c1, int x, int y, int width, int height, int offset) => this.DrawCorners(c1, checked (x + offset), checked (y + offset), checked (width - offset * 2), checked (height - offset * 2));

    protected void DrawCorners(Color c1) => this.DrawCorners(c1, 0, 0, this.Width, this.Height);

    protected void DrawCorners(Color c1, Rectangle r1) => this.DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height);

    protected void DrawCorners(Color c1, int x, int y, int width, int height)
    {
      if (this._NoRounding)
        return;
      if (this._Transparent)
      {
        this.B.SetPixel(x, y, c1);
        this.B.SetPixel(checked (x + width - 1), y, c1);
        this.B.SetPixel(x, checked (y + height - 1), c1);
        this.B.SetPixel(checked (x + width - 1), checked (y + height - 1), c1);
      }
      else
      {
        this.DrawCornersBrush = new SolidBrush(c1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, x, y, 1, 1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, checked (x + width - 1), y, 1, 1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, x, checked (y + height - 1), 1, 1);
        this.G.FillRectangle((Brush) this.DrawCornersBrush, checked (x + width - 1), checked (y + height - 1), 1, 1);
      }
    }

    protected void DrawBorders(Pen p1, int offset) => this.DrawBorders(p1, 0, 0, this.Width, this.Height, offset);

    protected void DrawBorders(Pen p1, Rectangle r, int offset) => this.DrawBorders(p1, r.X, r.Y, r.Width, r.Height, offset);

    protected void DrawBorders(Pen p1, int x, int y, int width, int height, int offset) => this.DrawBorders(p1, checked (x + offset), checked (y + offset), checked (width - offset * 2), checked (height - offset * 2));

    protected void DrawBorders(Pen p1) => this.DrawBorders(p1, 0, 0, this.Width, this.Height);

    protected void DrawBorders(Pen p1, Rectangle r) => this.DrawBorders(p1, r.X, r.Y, r.Width, r.Height);

    protected void DrawBorders(Pen p1, int x, int y, int width, int height) => this.G.DrawRectangle(p1, x, y, checked (width - 1), checked (height - 1));

    protected void DrawText(Brush b1, HorizontalAlignment a, int x, int y) => this.DrawText(b1, this.Text, a, x, y);

    protected void DrawText(Brush b1, string text, HorizontalAlignment a, int x, int y)
    {
      if (text.Length == 0)
        return;
      this.DrawTextSize = this.Measure(text);
      this.DrawTextPoint = this.Center(this.DrawTextSize);
      switch (a)
      {
        case HorizontalAlignment.Left:
          this.G.DrawString(text, this.Font, b1, (float) x, (float) checked (this.DrawTextPoint.Y + y));
          break;
        case HorizontalAlignment.Right:
          this.G.DrawString(text, this.Font, b1, (float) checked (this.Width - this.DrawTextSize.Width - x), (float) checked (this.DrawTextPoint.Y + y));
          break;
        case HorizontalAlignment.Center:
          this.G.DrawString(text, this.Font, b1, (float) checked (this.DrawTextPoint.X + x), (float) checked (this.DrawTextPoint.Y + y));
          break;
      }
    }

    protected void DrawText(Brush b1, Point p1)
    {
      if (this.Text.Length == 0)
        return;
      this.G.DrawString(this.Text, this.Font, b1, (PointF) p1);
    }

    protected void DrawText(Brush b1, int x, int y)
    {
      if (this.Text.Length == 0)
        return;
      this.G.DrawString(this.Text, this.Font, b1, (float) x, (float) y);
    }

    protected void DrawImage(HorizontalAlignment a, int x, int y) => this.DrawImage(this._Image, a, x, y);

    protected void DrawImage(Image image, HorizontalAlignment a, int x, int y)
    {
      if (image == null)
        return;
      this.DrawImagePoint = this.Center(image.Size);
      switch (a)
      {
        case HorizontalAlignment.Left:
          this.G.DrawImage(image, x, checked (this.DrawImagePoint.Y + y), image.Width, image.Height);
          break;
        case HorizontalAlignment.Right:
          this.G.DrawImage(image, checked (this.Width - image.Width - x), checked (this.DrawImagePoint.Y + y), image.Width, image.Height);
          break;
        case HorizontalAlignment.Center:
          this.G.DrawImage(image, checked (this.DrawImagePoint.X + x), checked (this.DrawImagePoint.Y + y), image.Width, image.Height);
          break;
      }
    }

    protected void DrawImage(Point p1) => this.DrawImage(this._Image, p1.X, p1.Y);

    protected void DrawImage(int x, int y) => this.DrawImage(this._Image, x, y);

    protected void DrawImage(Image image, Point p1) => this.DrawImage(image, p1.X, p1.Y);

    protected void DrawImage(Image image, int x, int y)
    {
      if (image == null)
        return;
      this.G.DrawImage(image, x, y, image.Width, image.Height);
    }

    protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(blend, this.DrawGradientRectangle);
    }

    protected void DrawGradient(
      ColorBlend blend,
      int x,
      int y,
      int width,
      int height,
      float angle)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(blend, this.DrawGradientRectangle, angle);
    }

    protected void DrawGradient(ColorBlend blend, Rectangle r)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, 90f);
      this.DrawGradientBrush.InterpolationColors = blend;
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawGradient(ColorBlend blend, Rectangle r, float angle)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, angle);
      this.DrawGradientBrush.InterpolationColors = blend;
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(c1, c2, this.DrawGradientRectangle);
    }

    protected void DrawGradient(
      Color c1,
      Color c2,
      int x,
      int y,
      int width,
      int height,
      float angle)
    {
      this.DrawGradientRectangle = new Rectangle(x, y, width, height);
      this.DrawGradient(c1, c2, this.DrawGradientRectangle, angle);
    }

    protected void DrawGradient(Color c1, Color c2, Rectangle r)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, c1, c2, 90f);
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    protected void DrawGradient(Color c1, Color c2, Rectangle r, float angle)
    {
      this.DrawGradientBrush = new LinearGradientBrush(r, c1, c2, angle);
      this.G.FillRectangle((Brush) this.DrawGradientBrush, r);
    }

    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(blend, this.DrawRadialRectangle, width / 2, height / 2);
    }

    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, Point center)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(blend, this.DrawRadialRectangle, center.X, center.Y);
    }

    public void DrawRadial(
      ColorBlend blend,
      int x,
      int y,
      int width,
      int height,
      int cx,
      int cy)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(blend, this.DrawRadialRectangle, cx, cy);
    }

    public void DrawRadial(ColorBlend blend, Rectangle r) => this.DrawRadial(blend, r, r.Width / 2, r.Height / 2);

    public void DrawRadial(ColorBlend blend, Rectangle r, Point center) => this.DrawRadial(blend, r, center.X, center.Y);

    public void DrawRadial(ColorBlend blend, Rectangle r, int cx, int cy)
    {
      this.DrawRadialPath.Reset();
      this.DrawRadialPath.AddEllipse(r.X, r.Y, checked (r.Width - 1), checked (r.Height - 1));
      this.DrawRadialBrush1 = new PathGradientBrush(this.DrawRadialPath);
      this.DrawRadialBrush1.CenterPoint = (PointF) new Point(checked (r.X + cx), checked (r.Y + cy));
      this.DrawRadialBrush1.InterpolationColors = blend;
      if (this.G.SmoothingMode == SmoothingMode.AntiAlias)
        this.G.FillEllipse((Brush) this.DrawRadialBrush1, checked (r.X + 1), checked (r.Y + 1), checked (r.Width - 3), checked (r.Height - 3));
      else
        this.G.FillEllipse((Brush) this.DrawRadialBrush1, r);
    }

    protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(c1, c2, this.DrawRadialRectangle);
    }

    protected void DrawRadial(
      Color c1,
      Color c2,
      int x,
      int y,
      int width,
      int height,
      float angle)
    {
      this.DrawRadialRectangle = new Rectangle(x, y, width, height);
      this.DrawRadial(c1, c2, this.DrawRadialRectangle, angle);
    }

    protected void DrawRadial(Color c1, Color c2, Rectangle r)
    {
      this.DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, 90f);
      this.G.FillEllipse((Brush) this.DrawRadialBrush2, r);
    }

    protected void DrawRadial(Color c1, Color c2, Rectangle r, float angle)
    {
      this.DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, angle);
      this.G.FillEllipse((Brush) this.DrawRadialBrush2, r);
    }

    public GraphicsPath CreateRound(int x, int y, int width, int height, int slope)
    {
      this.CreateRoundRectangle = new Rectangle(x, y, width, height);
      return this.CreateRound(this.CreateRoundRectangle, slope);
    }

    public GraphicsPath CreateRound(Rectangle r, int slope)
    {
      this.CreateRoundPath = new GraphicsPath(FillMode.Winding);
      this.CreateRoundPath.AddArc(r.X, r.Y, slope, slope, 180f, 90f);
      this.CreateRoundPath.AddArc(checked (r.Right - slope), r.Y, slope, slope, 270f, 90f);
      this.CreateRoundPath.AddArc(checked (r.Right - slope), checked (r.Bottom - slope), slope, slope, 0.0f, 90f);
      this.CreateRoundPath.AddArc(r.X, checked (r.Bottom - slope), slope, slope, 90f, 90f);
      this.CreateRoundPath.CloseFigure();
      return this.CreateRoundPath;
    }
  }
}
