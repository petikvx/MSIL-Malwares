// Decompiled with JetBrains decompiler
// Type: Diploma.entity.Matrix
// Assembly: FirstMatchCodeGr, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: F6EA4DA3-79DC-4E24-BB6F-C97A77DCC118
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ece28a4229d41e763203acb8c66af294e5461b01de2c4e25daddab193dfe554.exe

using System;

namespace Diploma.entity
{
  public class Matrix
  {
    private short dim;
    private double[,] matr;

    public Matrix(short dimension)
    {
      this.dim = dimension;
      this.matr = new double[(int) this.dim, (int) this.dim];
    }

    public Matrix(double[,] mass)
    {
      this.dim = (short) Math.Sqrt((double) mass.Length);
      this.matr = new double[(int) this.dim, (int) this.dim];
      for (int index1 = 0; index1 < (int) this.dim; ++index1)
      {
        for (int index2 = 0; index2 < (int) this.dim; ++index2)
          this.matr[index1, index2] = mass[index1, index2];
      }
    }

    public Matrix(Matrix m)
    {
      this.dim = m.length;
      this.matr = new double[(int) this.dim, (int) this.dim];
      for (int i = 0; i < (int) this.dim; ++i)
      {
        for (int j = 0; j < (int) this.dim; ++j)
          this.matr[i, j] = m[i, j];
      }
    }

    public Matrix(Vector[] vmass)
    {
      this.dim = (short) vmass.Length;
      this.matr = new double[(int) this.dim, (int) this.dim];
      for (int index1 = 0; index1 < (int) this.dim; ++index1)
      {
        for (int index2 = 0; index2 < (int) this.dim; ++index2)
          this.matr[index1, index2] = vmass[index1][index2];
      }
    }

    public void print()
    {
      try
      {
        for (int index1 = 0; index1 < (int) this.dim; ++index1)
        {
          if (index1 == 0)
            Console.WriteLine("Matrix:");
          for (int index2 = 0; index2 < (int) this.dim; ++index2)
          {
            if (index2 == 0)
              Console.Write("\t");
            Console.Write("\t {0:0.000}", (object) this.matr[index1, index2]);
          }
          Console.WriteLine("\n");
        }
      }
      catch (NullReferenceException ex)
      {
        Console.WriteLine("Empty Vect massive!");
      }
    }

    public string ToString(int tabAmount)
    {
      string str1 = "";
      for (int index = 0; index < tabAmount + 1; ++index)
        str1 += "\t";
      string str2 = "";
      for (int index1 = 0; index1 < (int) this.length; ++index1)
      {
        string str3 = str2 + str1;
        for (int index2 = 0; index2 < (int) this.length; ++index2)
          str3 += string.Format("{0,20:0.00000000}   ", (object) this.matr[index1, index2]);
        str2 = str3 + "\n";
      }
      return str2;
    }

    public short length => this.dim;

    public double this[int i, int j]
    {
      get => this.matr[i, j];
      set => this.matr[i, j] = value;
    }

    public static Matrix operator +(Matrix obj1, Matrix obj2)
    {
      Matrix matrix = new Matrix(obj1.length);
      for (int i = 0; i < (int) obj1.length; ++i)
      {
        for (int j = 0; j < (int) obj1.length; ++j)
          matrix[i, j] = obj1[i, j] + obj2[i, j];
      }
      return matrix;
    }

    public static Matrix operator *(double a, Matrix obj)
    {
      Matrix matrix = new Matrix(obj.length);
      for (int i = 0; i < (int) obj.length; ++i)
      {
        for (int j = 0; j < (int) obj.length; ++j)
          matrix[i, j] = a * obj[i, j];
      }
      return matrix;
    }

    public static Matrix operator -(Matrix obj1, Matrix obj2)
    {
      Matrix matrix = new Matrix(obj1.length);
      for (int i = 0; i < (int) obj1.length; ++i)
      {
        for (int j = 0; j < (int) obj1.length; ++j)
          matrix[i, j] = obj1[i, j] - obj2[i, j];
      }
      return matrix;
    }

    public static Matrix operator *(Matrix obj1, Matrix obj2)
    {
      Matrix matrix = new Matrix(obj1.length);
      if ((int) obj1.length != (int) obj2.length)
      {
        Console.WriteLine("допускается перемножение только квадратных матриц одной размерности");
        Environment.Exit(0);
      }
      for (int i = 0; i < (int) obj1.length; ++i)
      {
        for (int j = 0; j < (int) obj1.length; ++j)
        {
          for (int index = 0; index < (int) obj1.length; ++index)
            matrix[i, j] += obj1[i, index] * obj2[index, j];
        }
      }
      return matrix;
    }

    public static IVector operator *(Matrix mat, IVector vec)
    {
      IVector vector = vec.length != 3 ? (IVector) new Vector(vec.length) : (IVector) new Vector3();
      if (vec.length != (int) mat.length)
      {
        Console.WriteLine("допускается перемножение только квадратных матриц на вектор одной размерности");
        Environment.Exit(0);
      }
      for (int index1 = 0; index1 < vec.length; ++index1)
      {
        double num = 0.0;
        for (int index2 = 0; index2 < vec.length; ++index2)
          num += mat[index1, index2] * vec[index2];
        vector[index1] = num;
      }
      return vector;
    }

    public double getNorm()
    {
      double norm = 0.0;
      for (int index1 = 0; index1 < (int) this.length; ++index1)
      {
        double num = 0.0;
        for (int index2 = 0; index2 < (int) this.length; ++index2)
          num += Math.Abs(this.matr[index1, index2]);
        if (num > norm)
          norm = num;
      }
      return norm;
    }

    public bool notNoolDiag()
    {
      bool flag = true;
      for (int index = 0; index < (int) this.dim; ++index)
      {
        if (this.matr[index, index] == 0.0)
          flag = false;
      }
      return flag;
    }

    public double getMaxAboveDiag()
    {
      double maxAboveDiag = 0.0;
      for (int index1 = 0; index1 < (int) this.length; ++index1)
      {
        for (int index2 = index1 + 1; index2 < (int) this.length; ++index2)
        {
          if (Math.Abs(this.matr[index1, index2]) > maxAboveDiag)
            maxAboveDiag = Math.Abs(this.matr[index1, index2]);
        }
      }
      return maxAboveDiag;
    }

    public double getDeterminant()
    {
      Matrix matrix = new Matrix(this.length);
      for (int i = 0; i < (int) this.length; ++i)
      {
        for (int j = 0; j < (int) this.length; ++j)
          matrix[i, j] = this.matr[i, j];
      }
      double determinant = 1.0;
      for (int index = 0; index < (int) this.length; ++index)
      {
        for (int i = index + 1; i < (int) this.length; ++i)
        {
          for (int j = index + 1; j < (int) this.length; ++j)
            matrix[i, j] += matrix[index, j] * (-matrix[i, index] / matrix[index, index]);
          matrix[i, index] = 0.0;
        }
      }
      for (int index = 0; index < (int) this.length; ++index)
        determinant *= matrix[index, index];
      return determinant;
    }

    public IVector getRowAsVector(int line)
    {
      IVector rowAsVector = this.dim != (short) 3 ? (IVector) new Vector((int) this.dim) : (IVector) new Vector3();
      for (int index = 0; index < (int) this.length; ++index)
        rowAsVector[index] = this.matr[line, index];
      return rowAsVector;
    }
  }
}
