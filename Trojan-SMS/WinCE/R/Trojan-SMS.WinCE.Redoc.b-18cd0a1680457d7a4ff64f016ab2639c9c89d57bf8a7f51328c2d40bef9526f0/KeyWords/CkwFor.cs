// Decompiled with JetBrains decompiler
// Type: Dbasic.KeyWords.CkwFor
// Assembly: B4Pruntime, Version=1.0.3056.20520, Culture=neutral, PublicKeyToken=null
// MVID: BED81B59-7EDE-4B04-983E-56C0010CF881
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Trojan-SMS.WinCE.Redoc.b-18cd0a1680457d7a4ff64f016ab2639c9c89d57bf8a7f51328c2d40bef9526f0.exe

using System;
using System.Collections;

namespace Dbasic.KeyWords
{
  public class CkwFor : CkeyWords
  {
    public CkwFor(CRunner CRunner)
      : base(CRunner)
    {
    }

    public override MethodReturn Method(Place place, ref Locals locals)
    {
      double num1 = 0.0;
      int index = 0;
      bool flag = false;
      this.CRunner.blnExitFlag = false;
      int level = this.CRunner.GetWord(place.LineI, place.WordI).Level;
      string key = this.CRunner.GetWord(place.LineI, place.WordI + 1).Value;
      if (this.CRunner.GetWord(place.LineI, place.WordI + 2).Value == "(")
        this.CRunner.ThrowError("Index cannot be an array variable.", place.LineI);
      place = this.CRunner.RunCode(place, true, true, ref locals).place;
      ++place.WordI;
      RunReturn runReturn1 = this.CRunner.RunCode(place, false, true, ref locals);
      double vDouble = runReturn1.vDouble;
      place = runReturn1.place;
      RunReturn runReturn2;
      if (this.CRunner.CheckNextWord(place))
      {
        if (this.CRunner.nextWord(true, ref place).Value == "step")
        {
          runReturn2 = this.CRunner.RunCode(place, false, true, ref locals);
          num1 = runReturn2.vDouble;
          place = runReturn2.place;
        }
      }
      else
        num1 = 1.0;
      Hashtable hashtable;
      double num2;
      if (!flag)
      {
        hashtable = !locals.Reg.Contains((object) key) ? this.CRunner.globals.Reg : locals.Reg;
        num2 = double.Parse((string) hashtable[(object) key], (IFormatProvider) CRunner.cul);
      }
      else
      {
        hashtable = this.CRunner.globals.Arrays;
        num2 = double.Parse(((string[]) this.CRunner.globals.Arrays[(object) key])[index], (IFormatProvider) CRunner.cul);
      }
      if (!flag)
      {
        if (num1 > 0.0)
        {
          while (num2 <= vDouble)
          {
            runReturn2 = this.CRunner.RunCode(place, true, false, ref locals);
            if (!this.CRunner.blnReturnFlag && !this.CRunner.blnExitFlag)
            {
              if (runReturn2.word.Value != "next")
                this.CRunner.ThrowError("Syntax Error", runReturn2.place.LineI);
              num2 = double.Parse((string) hashtable[(object) key], (IFormatProvider) CRunner.cul) + num1;
              hashtable[(object) key] = (object) num2.ToString((IFormatProvider) CRunner.cul);
            }
            else
              break;
          }
        }
        else if (num1 < 0.0)
        {
          while (num2 >= vDouble)
          {
            runReturn2 = this.CRunner.RunCode(place, true, false, ref locals);
            if (!this.CRunner.blnReturnFlag && !this.CRunner.blnExitFlag)
            {
              if (runReturn2.word.Value != "next")
                this.CRunner.ThrowError("Syntax Error", runReturn2.place.LineI);
              num2 = double.Parse((string) hashtable[(object) key], (IFormatProvider) CRunner.cul) + num1;
              hashtable[(object) key] = (object) num2.ToString((IFormatProvider) CRunner.cul);
            }
            else
              break;
          }
        }
      }
      else if (num1 > 0.0)
      {
        while (num2 <= vDouble)
        {
          runReturn2 = this.CRunner.RunCode(place, true, false, ref locals);
          if (!this.CRunner.blnReturnFlag && !this.CRunner.blnExitFlag)
          {
            if (runReturn2.word.Value != "next")
              this.CRunner.ThrowError("Syntax Error", runReturn2.place.LineI);
            num2 = double.Parse(((string[]) this.CRunner.globals.Arrays[(object) key])[index], (IFormatProvider) CRunner.cul);
            num2 += num1;
            ((string[]) this.CRunner.globals.Arrays[(object) key])[index] = num2.ToString((IFormatProvider) CRunner.cul);
          }
          else
            break;
        }
      }
      else if (num1 < 0.0)
      {
        while (num2 >= vDouble)
        {
          runReturn2 = this.CRunner.RunCode(place, true, false, ref locals);
          if (!this.CRunner.blnReturnFlag && !this.CRunner.blnExitFlag)
          {
            if (runReturn2.word.Value != "next")
              this.CRunner.ThrowError("Syntax Error", runReturn2.place.LineI);
            num2 = double.Parse(((string[]) this.CRunner.globals.Arrays[(object) key])[index], (IFormatProvider) CRunner.cul);
            num2 += num1;
            ((string[]) this.CRunner.globals.Arrays[(object) key])[index] = num2.ToString((IFormatProvider) CRunner.cul);
          }
          else
            break;
        }
      }
      this.CRunner.blnExitFlag = false;
      place = (Place) this.CRunner.alGotoWords[level];
      return new MethodReturn(place);
    }
  }
}
