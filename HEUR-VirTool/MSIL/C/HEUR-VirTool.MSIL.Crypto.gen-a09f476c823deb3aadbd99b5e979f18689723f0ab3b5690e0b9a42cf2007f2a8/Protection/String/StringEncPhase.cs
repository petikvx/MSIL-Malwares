// Decompiled with JetBrains decompiler
// Type: Aura.Protection.String.StringEncPhase
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using Aura.Services;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using dnlib.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Aura.Protection.String
{
  public static class StringEncPhase
  {
    private const string PasswordHash = "p7K95451qB88sZ7J";
    private const string SaltKey = "2GM23j301t60Z96T";
    private const string VIKey = "IzTdhG6S8uwg141S";
    public static List<string> Str = new List<string>();

    public static void InjectClass(ModuleDef module)
    {
      IEnumerable<IDnlibDef> source = InjectHelper.Inject(ModuleDefMD.Load(typeof (EncryptionHelper).Module).ResolveTypeDef(MDToken.ToRID(typeof (EncryptionHelper).MetadataToken)), module.GlobalType, module);
      MainWindow.Init = (MethodDef) source.Single<IDnlibDef>((Func<IDnlibDef, bool>) (method => UTF8String.op_Equality(((IFullName) method).Name, "Decrypt")));
      MethodDef staticConstructor = module.GlobalType.FindStaticConstructor();
      MainWindow.Init2 = (MethodDef) source.Single<IDnlibDef>((Func<IDnlibDef, bool>) (method => UTF8String.op_Equality(((IFullName) method).Name, "Search")));
      MethodDef methodDef = (MethodDef) source.Single<IDnlibDef>((Func<IDnlibDef, bool>) (method => UTF8String.op_Equality(((IFullName) method).Name, "Generate")));
      staticConstructor.Body.Instructions.Insert(((ICollection<Instruction>) staticConstructor.Body.Instructions).Count - 1, Instruction.Create(OpCodes.Call, (IMethod) methodDef));
      foreach (MethodDef method in (IEnumerable<MethodDef>) module.GlobalType.Methods)
      {
        if (UTF8String.op_Equality(method.Name, ".ctor"))
        {
          module.GlobalType.Remove(method);
          break;
        }
      }
    }

    public static void Execute(ModuleDef module)
    {
      StringEncPhase.InjectClass(module);
      foreach (TypeDef type in module.GetTypes())
      {
        if (!type.IsGlobalModuleType)
        {
          foreach (MethodDef method in (IEnumerable<MethodDef>) type.Methods)
          {
            if (method.HasBody)
            {
              IList<Instruction> instructions = method.Body.Instructions;
              for (int index = 0; index < ((ICollection<Instruction>) instructions).Count; ++index)
              {
                if (instructions[index].OpCode == OpCodes.Ldstr)
                {
                  string str = StringEncPhase.Encrypt(instructions[index].Operand as string);
                  instructions[index].Operand = (object) str;
                  StringEncPhase.Str.Add(str);
                  instructions.Insert(index + 1, Instruction.Create(OpCodes.Ldc_I4, StringEncPhase.Str.LastIndexOf(str)));
                  instructions.Insert(index + 2, Instruction.Create(OpCodes.Call, (IMethod) MainWindow.Init2));
                  instructions.Insert(index + 3, Instruction.Create(OpCodes.Call, (IMethod) MainWindow.Init));
                  instructions.RemoveAt(index);
                }
              }
              method.Body.SimplifyBranches();
            }
          }
        }
      }
      File.WriteAllLines(Path.GetTempPath() + "List.txt", (IEnumerable<string>) StringEncPhase.Str);
      byte[] text = File.ReadAllBytes(Path.GetTempPath() + "List.txt");
      ((LazyList<Resource>) module.Resources).Add((Resource) new EmbeddedResource(UTF8String.op_Implicit("Aura.zero"), StringEncPhase.Hush(text), (ManifestResourceAttributes) 1));
      File.Delete(Path.GetTempPath() + "List.txt");
    }

    public static byte[] Hush(byte[] text)
    {
      byte[] bytes = new Rfc2898DeriveBytes("p7K95451qB88sZ7J", Encoding.ASCII.GetBytes("2GM23j301t60Z96T")).GetBytes(32);
      byte[] numArray = new byte[text.Length];
      for (int index = 0; index < text.Length; ++index)
        numArray[index] = (byte) ((uint) text[index] ^ (uint) bytes[index % bytes.Length]);
      return numArray;
    }

    public static string Encrypt(string plainText)
    {
      byte[] bytes1 = Encoding.UTF8.GetBytes(plainText);
      byte[] bytes2 = new Rfc2898DeriveBytes("p7K95451qB88sZ7J", Encoding.ASCII.GetBytes("2GM23j301t60Z96T")).GetBytes(32);
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      rijndaelManaged.Mode = CipherMode.CBC;
      rijndaelManaged.Padding = PaddingMode.PKCS7;
      ICryptoTransform encryptor = rijndaelManaged.CreateEncryptor(bytes2, Encoding.ASCII.GetBytes("IzTdhG6S8uwg141S"));
      byte[] array;
      using (MemoryStream memoryStream = new MemoryStream())
      {
        using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, encryptor, CryptoStreamMode.Write))
        {
          cryptoStream.Write(bytes1, 0, bytes1.Length);
          cryptoStream.FlushFinalBlock();
          array = memoryStream.ToArray();
          cryptoStream.Close();
        }
        memoryStream.Close();
      }
      return Convert.ToBase64String(array);
    }
  }
}
