// Decompiled with JetBrains decompiler
// Type: Org.BouncyCastle.Utilities.Arrays
// Assembly: Poullight, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: A9555FC6-4E86-4D22-9A29-AD3955B2BC52
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\Trojan-PSW.MSIL.Poul.gen-67cfa95ccaa06c437e04f38c3ef890986c1885c61636b84bf51d16b0d7bf957c.exe

using System;

namespace Org.BouncyCastle.Utilities
{
  public abstract class Arrays
  {
    public static bool AreEqual(byte[] a, byte[] b)
    {
      if (a == b)
        return true;
      return a != null && b != null && Arrays.HaveSameContents(a, b);
    }

    public static bool ConstantTimeAreEqual(byte[] a, byte[] b)
    {
      if (a == null || b == null)
        return false;
      if (a == b)
        return true;
      int num1 = Math.Min(a.Length, b.Length);
      int num2 = a.Length ^ b.Length;
      for (int index = 0; index < num1; ++index)
        num2 |= (int) a[index] ^ (int) b[index];
      for (int index = num1; index < b.Length; ++index)
        num2 |= (int) b[index] ^ (int) ~b[index];
      return num2 == 0;
    }

    public static bool AreEqual(uint[] a, uint[] b)
    {
      if (a == b)
        return true;
      return a != null && b != null && Arrays.HaveSameContents(a, b);
    }

    private static bool HaveSameContents(byte[] a, byte[] b)
    {
      int length = a.Length;
      if (length != b.Length)
        return false;
      while (length != 0)
      {
        --length;
        if ((int) a[length] != (int) b[length])
          return false;
      }
      return true;
    }

    private static bool HaveSameContents(uint[] a, uint[] b)
    {
      int length = a.Length;
      if (length != b.Length)
        return false;
      while (length != 0)
      {
        --length;
        if ((int) a[length] != (int) b[length])
          return false;
      }
      return true;
    }

    public static byte[] Clone(byte[] data) => data != null ? (byte[]) data.Clone() : (byte[]) null;

    public static uint[] Clone(uint[] data) => data != null ? (uint[]) data.Clone() : (uint[]) null;

    public static void Fill(byte[] buf, byte b)
    {
      int length = buf.Length;
      while (length > 0)
        buf[--length] = b;
    }

    public static byte[] CopyOfRange(byte[] data, int from, int to)
    {
      int length = Arrays.GetLength(from, to);
      byte[] destinationArray = new byte[length];
      Array.Copy((Array) data, from, (Array) destinationArray, 0, Math.Min(length, data.Length - from));
      return destinationArray;
    }

    private static int GetLength(int from, int to)
    {
      int num = to - from;
      return num >= 0 ? num : throw new ArgumentException(from.ToString() + " > " + (object) to);
    }
  }
}
