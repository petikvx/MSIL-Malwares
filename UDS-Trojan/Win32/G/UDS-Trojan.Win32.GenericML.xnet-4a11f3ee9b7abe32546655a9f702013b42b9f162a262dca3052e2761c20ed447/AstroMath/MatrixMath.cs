// Decompiled with JetBrains decompiler
// Type: AstroMath.MatrixMath
// Assembly: IUnionSemanticCodeGr, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 54936E77-57E9-4A01-8A40-CDD9C21A9B24
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4a11f3ee9b7abe32546655a9f702013b42b9f162a262dca3052e2761c20ed447.exe

namespace AstroMath
{
  internal class MatrixMath
  {
    public static double DotProduct(double[] a, double[] b)
    {
      double num = 0.0;
      if (a.Length == b.Length)
      {
        for (int index = 0; index < a.Length; ++index)
          num += a[index] * b[index];
      }
      return num;
    }

    public static double[,] MatrixProduct(double[,] a, double[,] b)
    {
      int length1 = a.GetLength(0);
      int length2 = a.GetLength(1);
      int length3 = b.GetLength(0);
      int length4 = b.GetLength(1);
      double[,] numArray = new double[length1, length4];
      if (length2 == length3)
      {
        for (int index1 = 0; index1 < length1; ++index1)
        {
          for (int index2 = 0; index2 < length2; ++index2)
          {
            for (int index3 = 0; index3 < length2; ++index3)
              numArray[index1, index2] += a[index1, index3] * b[index3, index1];
          }
        }
      }
      return numArray;
    }

    public static double[] CrossProduct(double[] a, double[] b) => new double[3]
    {
      a[1] * b[2] - a[2] * b[1],
      a[2] * b[0] - a[0] * b[2],
      a[0] * b[1] - a[1] * b[0]
    };
  }
}
