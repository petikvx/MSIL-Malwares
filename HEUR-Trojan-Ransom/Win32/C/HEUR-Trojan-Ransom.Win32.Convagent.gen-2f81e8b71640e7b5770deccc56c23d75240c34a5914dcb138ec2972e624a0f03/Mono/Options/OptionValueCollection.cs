// Decompiled with JetBrains decompiler
// Type: Mono.Options.OptionValueCollection
// Assembly: FUNCD, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 38B3918C-7BBD-4048-BF6D-F5A856A1A18A
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan-Ransom.Win32.Convagent.gen-2f81e8b71640e7b5770deccc56c23d75240c34a5914dcb138ec2972e624a0f03.exe

using System;
using System.Collections;
using System.Collections.Generic;

namespace Mono.Options
{
  public class OptionValueCollection : 
    IList,
    ICollection,
    IEnumerable,
    IList<string>,
    ICollection<string>,
    IEnumerable<string>
  {
    private List<string> values = new List<string>();
    private OptionContext c;

    internal OptionValueCollection(OptionContext c) => this.c = c;

    void ICollection.CopyTo(Array array, int index) => ((ICollection) this.values).CopyTo(array, index);

    bool ICollection.IsSynchronized => ((ICollection) this.values).IsSynchronized;

    object ICollection.SyncRoot => ((ICollection) this.values).SyncRoot;

    public void Add(string item) => this.values.Add(item);

    public void Clear() => this.values.Clear();

    public bool Contains(string item) => this.values.Contains(item);

    public void CopyTo(string[] array, int arrayIndex) => this.values.CopyTo(array, arrayIndex);

    public bool Remove(string item) => this.values.Remove(item);

    public int Count => this.values.Count;

    public bool IsReadOnly => false;

    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.values.GetEnumerator();

    public IEnumerator<string> GetEnumerator() => (IEnumerator<string>) this.values.GetEnumerator();

    int IList.Add(object value) => ((IList) this.values).Add(value);

    bool IList.Contains(object value) => ((IList) this.values).Contains(value);

    int IList.IndexOf(object value) => ((IList) this.values).IndexOf(value);

    void IList.Insert(int index, object value) => ((IList) this.values).Insert(index, value);

    void IList.Remove(object value) => ((IList) this.values).Remove(value);

    void IList.RemoveAt(int index) => this.values.RemoveAt(index);

    bool IList.IsFixedSize => false;

    object IList.this[int index]
    {
      get => (object) this[index];
      set => ((IList) this.values)[index] = value;
    }

    public int IndexOf(string item) => this.values.IndexOf(item);

    public void Insert(int index, string item) => this.values.Insert(index, item);

    public void RemoveAt(int index) => this.values.RemoveAt(index);

    private void AssertValid(int index)
    {
      if (this.c.Option == null)
        throw new InvalidOperationException("OptionContext.Option is null.");
      if (index >= this.c.Option.MaxValueCount)
        throw new ArgumentOutOfRangeException(nameof (index));
      if (this.c.Option.OptionValueType == OptionValueType.Required && index >= this.values.Count)
        throw new OptionException(string.Format(this.c.OptionSet.MessageLocalizer("Missing required value for option '{0}'."), (object) this.c.OptionName), this.c.OptionName);
    }

    public string this[int index]
    {
      get
      {
        this.AssertValid(index);
        return index < this.values.Count ? this.values[index] : (string) null;
      }
      set => this.values[index] = value;
    }

    public List<string> ToList() => new List<string>((IEnumerable<string>) this.values);

    public string[] ToArray() => this.values.ToArray();

    public override string ToString() => string.Join(", ", this.values.ToArray());
  }
}
