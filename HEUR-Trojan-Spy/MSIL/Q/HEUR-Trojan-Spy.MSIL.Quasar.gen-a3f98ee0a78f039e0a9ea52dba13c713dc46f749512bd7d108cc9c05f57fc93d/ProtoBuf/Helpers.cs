// Decompiled with JetBrains decompiler
// Type: ProtoBuf.Helpers
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System;
using System.Diagnostics;
using System.Reflection;
using System.Text;

namespace ProtoBuf
{
  internal sealed class Helpers
  {
    public static readonly Type[] EmptyTypes = Type.EmptyTypes;

    private Helpers()
    {
    }

    public static StringBuilder AppendLine(StringBuilder builder) => builder.AppendLine();

    public static bool IsNullOrEmpty(string value) => value == null || value.Length == 0;

    [Conditional("DEBUG")]
    public static void DebugWriteLine(string message, object obj)
    {
    }

    [Conditional("DEBUG")]
    public static void DebugWriteLine(string message)
    {
    }

    [Conditional("TRACE")]
    public static void TraceWriteLine(string message) => Trace.WriteLine(message);

    [Conditional("DEBUG")]
    public static void DebugAssert(bool condition, string message)
    {
    }

    [Conditional("DEBUG")]
    public static void DebugAssert(bool condition, string message, params object[] args)
    {
    }

    [Conditional("DEBUG")]
    public static void DebugAssert(bool condition)
    {
    }

    public static void Sort(int[] keys, object[] values)
    {
      bool flag;
      do
      {
        flag = false;
        for (int index = 1; index < keys.Length; ++index)
        {
          if (keys[index - 1] > keys[index])
          {
            int key = keys[index];
            keys[index] = keys[index - 1];
            keys[index - 1] = key;
            object obj = values[index];
            values[index] = values[index - 1];
            values[index - 1] = obj;
            flag = true;
          }
        }
      }
      while (flag);
    }

    public static void BlockCopy(byte[] from, int fromIndex, byte[] to, int toIndex, int count) => Buffer.BlockCopy((Array) from, fromIndex, (Array) to, toIndex, count);

    public static bool IsInfinity(float value) => float.IsInfinity(value);

    internal static MethodInfo GetInstanceMethod(Type declaringType, string name) => declaringType.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

    internal static MethodInfo GetStaticMethod(Type declaringType, string name) => declaringType.GetMethod(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);

    internal static MethodInfo GetInstanceMethod(
      Type declaringType,
      string name,
      Type[] types)
    {
      if (types == null)
        types = Helpers.EmptyTypes;
      return declaringType.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, (Binder) null, types, (ParameterModifier[]) null);
    }

    internal static bool IsSubclassOf(Type type, Type baseClass) => type.IsSubclassOf(baseClass);

    public static bool IsInfinity(double value) => double.IsInfinity(value);

    public static ProtoTypeCode GetTypeCode(Type type)
    {
      TypeCode typeCode = Type.GetTypeCode(type);
      switch (typeCode)
      {
        case TypeCode.Empty:
        case TypeCode.Boolean:
        case TypeCode.Char:
        case TypeCode.SByte:
        case TypeCode.Byte:
        case TypeCode.Int16:
        case TypeCode.UInt16:
        case TypeCode.Int32:
        case TypeCode.UInt32:
        case TypeCode.Int64:
        case TypeCode.UInt64:
        case TypeCode.Single:
        case TypeCode.Double:
        case TypeCode.Decimal:
        case TypeCode.DateTime:
        case TypeCode.String:
          return (ProtoTypeCode) typeCode;
        default:
          if ((object) type == (object) typeof (TimeSpan))
            return ProtoTypeCode.TimeSpan;
          if ((object) type == (object) typeof (Guid))
            return ProtoTypeCode.Guid;
          if ((object) type == (object) typeof (Uri))
            return ProtoTypeCode.Uri;
          if ((object) type == (object) typeof (byte[]))
            return ProtoTypeCode.ByteArray;
          return (object) type == (object) typeof (Type) ? ProtoTypeCode.Type : ProtoTypeCode.Unknown;
      }
    }

    internal static Type GetUnderlyingType(Type type) => Nullable.GetUnderlyingType(type);

    internal static bool IsValueType(Type type) => type.IsValueType;

    internal static bool IsEnum(Type type) => type.IsEnum;

    internal static MethodInfo GetGetMethod(
      PropertyInfo property,
      bool nonPublic,
      bool allowInternal)
    {
      if ((object) property == null)
        return (MethodInfo) null;
      MethodInfo getMethod = property.GetGetMethod(nonPublic);
      if ((((object) getMethod != null ? 0 : (!nonPublic ? 1 : 0)) & (allowInternal ? 1 : 0)) != 0)
      {
        getMethod = property.GetGetMethod(true);
        if ((object) getMethod == null && !getMethod.IsAssembly && !getMethod.IsFamilyOrAssembly)
          getMethod = (MethodInfo) null;
      }
      return getMethod;
    }

    internal static MethodInfo GetSetMethod(
      PropertyInfo property,
      bool nonPublic,
      bool allowInternal)
    {
      if ((object) property == null)
        return (MethodInfo) null;
      MethodInfo setMethod = property.GetSetMethod(nonPublic);
      if ((((object) setMethod != null ? 0 : (!nonPublic ? 1 : 0)) & (allowInternal ? 1 : 0)) != 0)
      {
        setMethod = property.GetGetMethod(true);
        if ((object) setMethod == null && !setMethod.IsAssembly && !setMethod.IsFamilyOrAssembly)
          setMethod = (MethodInfo) null;
      }
      return setMethod;
    }

    internal static ConstructorInfo GetConstructor(
      Type type,
      Type[] parameterTypes,
      bool nonPublic)
    {
      return type.GetConstructor(nonPublic ? BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic : BindingFlags.Instance | BindingFlags.Public, (Binder) null, parameterTypes, (ParameterModifier[]) null);
    }

    internal static ConstructorInfo[] GetConstructors(Type type, bool nonPublic) => type.GetConstructors(nonPublic ? BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic : BindingFlags.Instance | BindingFlags.Public);

    internal static PropertyInfo GetProperty(Type type, string name, bool nonPublic) => type.GetProperty(name, nonPublic ? BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic : BindingFlags.Instance | BindingFlags.Public);

    internal static object ParseEnum(Type type, string value) => Enum.Parse(type, value, true);

    internal static MemberInfo[] GetInstanceFieldsAndProperties(
      Type type,
      bool publicOnly)
    {
      BindingFlags bindingAttr = publicOnly ? BindingFlags.Instance | BindingFlags.Public : BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
      PropertyInfo[] properties = type.GetProperties(bindingAttr);
      FieldInfo[] fields = type.GetFields(bindingAttr);
      MemberInfo[] fieldsAndProperties = new MemberInfo[fields.Length + properties.Length];
      properties.CopyTo((Array) fieldsAndProperties, 0);
      fields.CopyTo((Array) fieldsAndProperties, properties.Length);
      return fieldsAndProperties;
    }

    internal static Type GetMemberType(MemberInfo member)
    {
      switch (member.MemberType)
      {
        case MemberTypes.Field:
          return ((FieldInfo) member).FieldType;
        case MemberTypes.Property:
          return ((PropertyInfo) member).PropertyType;
        default:
          return (Type) null;
      }
    }

    internal static bool IsAssignableFrom(Type target, Type type) => target.IsAssignableFrom(type);
  }
}
