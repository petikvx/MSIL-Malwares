// Decompiled with JetBrains decompiler
// Type: WindowsFormsApp1.G
// Assembly: Kffxmjkup, Version=0.0.52.0, Culture=neutral, PublicKeyToken=null
// MVID: A3D42A33-7E04-4546-0720-DC34BF455AE6
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.05-msil\HEUR-Trojan.MSIL.Witch.gen-6bbdcec0763847706f9b75674aad231ff23afd2b212138fc630a86f69f8180d8.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace WindowsFormsApp1
{
  internal static class G
  {
    private static G.a a;

    static G()
    {
      G.a a = new G.a();
      if (false)
        return;
      G.a = a;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static long a()
    {
      if ((object) Assembly.GetCallingAssembly() != (object) typeof (G).Assembly || !G.a())
        return 0;
      G.a a1 = G.a;
      if (true)
        goto label_4;
label_3:
      if (true)
        Monitor.Enter((object) a1);
      G.a a2;
      try
      {
        long num1 = G.a.a();
        if (true)
          goto label_8;
label_7:
        long a3;
        if (a3 == 0L)
        {
          Assembly executingAssembly = Assembly.GetExecutingAssembly();
          if (true)
            goto label_11;
label_10:
          List<byte> byteList1 = new List<byte>();
          List<byte> byteList2;
          if (true)
            byteList2 = byteList1;
          Assembly assembly;
          AssemblyName assemblyName;
          try
          {
            assemblyName = assembly.GetName();
          }
          catch
          {
            assemblyName = new AssemblyName(assembly.FullName);
          }
          byte[] collection = assemblyName.GetPublicKeyToken();
          if (collection != null && collection.Length == 0)
            collection = (byte[]) null;
          if (collection != null)
            byteList2.AddRange((IEnumerable<byte>) collection);
          byteList2.AddRange((IEnumerable<byte>) Encoding.Unicode.GetBytes(assemblyName.Name));
          int num2 = G.a(typeof (G));
          int num3 = G.c.a();
          byteList2.Add((byte) (num2 >> 8));
          byteList2.Add((byte) (num3 >> 24));
          byteList2.Add((byte) (num2 >> 16));
          byteList2.Add((byte) (num3 >> 8));
          byteList2.Add((byte) (num2 >> 24));
          byteList2.Add((byte) (num3 >> 16));
          byteList2.Add((byte) num2);
          byteList2.Add((byte) num3);
          int count = byteList2.Count;
          ulong num4 = 0;
          for (int index = 0; index != count; ++index)
          {
            ulong num5 = num4 + (ulong) byteList2[index];
            ulong num6 = num5 + (num5 << 20);
            num4 = num6 ^ num6 >> 12;
            byteList2[index] = (byte) 0;
          }
          ulong num7 = num4 + (num4 << 6);
          ulong num8 = num7 ^ num7 >> 22;
          a3 = (long) (num8 + (num8 << 30)) ^ -863520318186220816L;
          G.a.a(a3);
          goto label_23;
label_11:
          assembly = executingAssembly;
          goto label_10;
        }
label_23:
        return a3;
label_8:
        a3 = num1;
        goto label_7;
      }
      finally
      {
        Monitor.Exit((object) a2);
      }
label_4:
      a2 = a1;
      goto label_3;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool a() => G.b();

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static bool b()
    {
      StackTrace stackTrace1 = new StackTrace();
      if (true)
        goto label_3;
label_1:
      StackTrace stackTrace2;
      StackFrame frame = stackTrace2.GetFrame(3);
      if (true)
        goto label_4;
label_2:
      StackFrame stackFrame;
      MethodBase methodBase1 = stackFrame == null ? (MethodBase) null : stackFrame.GetMethod();
      if (true)
        goto label_6;
label_5:
      MethodBase methodBase2;
      Type type = (object) methodBase2 == null ? (Type) null : methodBase2.DeclaringType;
      return (object) type != (object) typeof (RuntimeMethodHandle) && (object) type != null && (object) type.Assembly == (object) typeof (G).Assembly;
label_6:
      methodBase2 = methodBase1;
      goto label_5;
label_4:
      stackFrame = frame;
      goto label_2;
label_3:
      stackTrace2 = stackTrace1;
      goto label_1;
    }

    private static int a(Type a)
    {
      Type type = a;
      if (true)
        ;
      return type.MetadataToken;
    }

    private sealed class a
    {
      private int a;
      private int b;

      internal a()
      {
        if (false)
          return;
        this.a(0L);
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal long a()
      {
        if ((object) Assembly.GetCallingAssembly() != (object) typeof (G.a).Assembly || !G.a())
          return 2918384;
        int[] numArray1 = new int[4];
        if (true)
          goto label_8;
label_3:
        int[] numArray2;
        numArray2[3] = -~~--~-~~-334340749;
        numArray2[1] = ~--~~-~-~2020242196;
        numArray2[2] = -~-~-~~-~-~884680990;
        numArray2[0] = -~-~~--~~-121596582;
        int a = this.a;
        if (true)
          goto label_9;
label_4:
        int b = this.b;
        if (true)
          goto label_10;
label_5:
        int num1 = -~-~~--~-~~1640531529;
        if (true)
          goto label_11;
label_6:
        int num2 = -~-~~--~~957401313;
        if (true)
          goto label_12;
label_7:
        int num3;
        int num4;
        int num5;
        int num6;
        for (int index = 0; index != 32; ++index)
        {
          num4 -= (num3 << 4 ^ num3 >> 5) + num3 ^ num6 + numArray2[num6 >> 11 & 3];
          num6 -= num5;
          num3 -= (num4 << 4 ^ num4 >> 5) + num4 ^ num6 + numArray2[num6 & 3];
        }
        for (int index = 0; index != 4; ++index)
          numArray2[index] = 0;
        return (long) ((ulong) num4 << 32 | (ulong) (uint) num3);
label_12:
        num6 = num2;
        goto label_7;
label_11:
        num5 = num1;
        goto label_6;
label_10:
        num4 = b;
        goto label_5;
label_9:
        num3 = a;
        goto label_4;
label_8:
        numArray2 = numArray1;
        goto label_3;
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal void a(long a)
      {
        if ((object) Assembly.GetCallingAssembly() != (object) typeof (G.a).Assembly || !G.a())
          return;
        int[] numArray1 = new int[4];
        if (true)
          goto label_7;
label_2:
        int[] numArray2;
        numArray2[1] = -~-~-~~-~2020242200;
        numArray2[0] = -~-~~--~~-121596582;
        numArray2[2] = -~-~-~~--~~884680992;
        numArray2[3] = -~~--~-~~-334340749;
        int num1 = -~-~-~~-~1640531528;
        if (true)
          goto label_8;
label_3:
        int num2 = (int) a;
        if (true)
          goto label_9;
label_4:
        int num3 = (int) (a >> 32);
        if (true)
          goto label_10;
label_5:
        if (true)
          goto label_11;
label_6:
        int num4;
        int num5;
        int num6;
        int num7;
        for (int index = 0; index != 32; ++index)
        {
          num5 += (num6 << 4 ^ num6 >> 5) + num6 ^ num7 + numArray2[num7 & 3];
          num7 += num4;
          num6 += (num5 << 4 ^ num5 >> 5) + num5 ^ num7 + numArray2[num7 >> 11 & 3];
        }
        for (int index = 0; index != 4; ++index)
          numArray2[index] = 0;
        this.a = num5;
        this.b = num6;
        return;
label_11:
        num7 = 0;
        goto label_6;
label_10:
        num6 = num3;
        goto label_5;
label_9:
        num5 = num2;
        goto label_4;
label_8:
        num4 = num1;
        goto label_3;
label_7:
        numArray2 = numArray1;
        goto label_2;
      }
    }

    private static class b
    {
      internal static int a(int a, int b)
      {
        int num1 = a;
        if (true)
          ;
        int num2 = b;
        if (true)
          ;
        int num3 = -~-~~-~--~~566942261;
        int num4 = num2 - num3;
        return num1 ^ num4;
      }

      internal static int b(int a, int b)
      {
        int num1 = a;
        if (true)
          ;
        int num2 = -~-~~-~--~~1249762410;
        int num3 = num1 - num2;
        int num4 = b;
        if (true)
          ;
        int num5 = -~-~-~~-~1598681681;
        int num6 = num4 + num5;
        return num3 ^ num6;
      }

      internal static int c(int a, int b)
      {
        int num1 = a;
        if (true)
          ;
        int num2 = b;
        if (true)
          ;
        int num3 = -~-~-~~-~-1229528225;
        int num4 = num2 - num3;
        int num5 = a;
        if (true)
          ;
        int num6 = b;
        int num7 = num5 - num6;
        int num8 = num4 ^ num7;
        return num1 ^ num8;
      }
    }

    private sealed class c
    {
      public c()
      {
        if (true)
          ;
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal static int a() => G.b.c(G.b.b(G.a(typeof (G.e)), G.b.c(G.a(typeof (G.c)), G.a(typeof (G.g)))), G.h.a());
    }

    private sealed class d
    {
      public d()
      {
        if (true)
          ;
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal static int a() => G.b.c(G.b.a(G.e.a() ^ -~-~-~~-~-527758445, G.a(typeof (G.f))), G.b.b(G.a(typeof (G.c)) ^ G.a(typeof (G.h)), -~-~~--~-~~-1654629566));
    }

    private sealed class e
    {
      public e()
      {
        if (true)
          ;
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal static int a() => G.b.a(G.a(typeof (G.d)), G.a(typeof (G.f)) ^ G.b.b(G.a(typeof (G.e)), G.b.c(G.a(typeof (G.h)), G.f.a())));
    }

    private sealed class f
    {
      public f()
      {
        if (true)
          ;
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal static int a() => G.b.c(G.a(typeof (G.f)), G.b.a(G.a(typeof (G.c)), G.b.b(G.a(typeof (G.e)), G.b.c(G.a(typeof (G.d)), G.b.a(G.a(typeof (G.g)), G.a(typeof (G.h)))))));
    }

    private sealed class g
    {
      public g()
      {
        if (true)
          ;
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal static int a() => G.b.b(G.b.b(G.d.a(), G.b.a(G.a(typeof (G.g)), G.e.a())), G.a(typeof (G.h)));
    }

    private sealed class h
    {
      public h()
      {
        if (true)
          ;
        // ISSUE: explicit constructor call
        base.\u002Ector();
      }

      [MethodImpl(MethodImplOptions.NoInlining)]
      internal static int a() => G.b.a(G.a(typeof (G.h)), G.b.c(G.b.b(G.a(typeof (G.g)), G.a(typeof (G.c))), G.b.c(G.a(typeof (G.d)) ^ -~-~-~~-~-1802889669, G.g.a())));
    }
  }
}
