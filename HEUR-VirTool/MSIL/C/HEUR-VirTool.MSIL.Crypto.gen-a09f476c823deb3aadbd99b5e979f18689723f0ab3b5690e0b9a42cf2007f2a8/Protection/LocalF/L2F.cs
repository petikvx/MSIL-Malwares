// Decompiled with JetBrains decompiler
// Type: Aura.Protection.LocalF.L2F
// Assembly: Kudeta Crypter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 16F9F4AC-EE0C-4DE1-A1E6-B297F2D4338B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-VirTool.MSIL.Crypto.gen-a09f476c823deb3aadbd99b5e979f18689723f0ab3b5690e0b9a42cf2007f2a8.exe

using Aura.Protection.Renamer;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aura.Protection.LocalF
{
  internal class L2F
  {
    private static Dictionary<Local, FieldDef> convertedLocals = new Dictionary<Local, FieldDef>();

    public static void Execute(ModuleDef Module)
    {
      foreach (TypeDef typeDef in ((IEnumerable<TypeDef>) Module.Types).Where<TypeDef>((Func<TypeDef, bool>) (x => x != Module.GlobalType)))
      {
        foreach (MethodDef method in ((IEnumerable<MethodDef>) typeDef.Methods).Where<MethodDef>((Func<MethodDef, bool>) (x => x.HasBody && x.Body.HasInstructions && !x.IsConstructor)))
        {
          L2F.convertedLocals = new Dictionary<Local, FieldDef>();
          L2F.Process(Module, method);
        }
      }
    }

    public static void Process(ModuleDef module, MethodDef method)
    {
      foreach (Instruction instruction in (IEnumerable<Instruction>) method.Body.Instructions)
      {
        if (instruction.Operand is Local operand)
        {
          FieldDef fieldDef;
          if (!L2F.convertedLocals.ContainsKey(operand))
          {
            fieldDef = (FieldDef) new FieldDefUser(UTF8String.op_Implicit(RenamerPhase.GenerateString(RenamerPhase.RenameMode.Normal)), new FieldSig(operand.Type), (FieldAttributes) 22);
            ((ICollection<FieldDef>) module.GlobalType.Fields).Add(fieldDef);
            L2F.convertedLocals.Add(operand, fieldDef);
          }
          else
            fieldDef = L2F.convertedLocals[operand];
          OpCode opCode = (OpCode) null;
          Code code = instruction.OpCode.Code;
          switch (code - 6)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 11:
label_8:
              opCode = OpCodes.Ldsfld;
              goto case 8;
            case 4:
            case 5:
            case 6:
            case 7:
            case 13:
label_10:
              opCode = OpCodes.Stsfld;
              goto case 8;
            case 8:
            case 9:
            case 10:
label_11:
              instruction.OpCode = opCode;
              instruction.Operand = (object) fieldDef;
              continue;
            case 12:
label_9:
              opCode = OpCodes.Ldsflda;
              goto case 8;
            default:
              switch (code - 65036)
              {
                case 0:
                  goto label_8;
                case 1:
                  goto label_9;
                case 2:
                  goto label_10;
                default:
                  goto label_11;
              }
          }
        }
      }
    }
  }
}
