// Decompiled with JetBrains decompiler
// Type: TYPELIBA.Listeners.AdvisorRefListener
// Assembly: TYPELIBA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 97BB50BA-9882-4DFE-999C-7A4E4B448F1C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-080eff3ceefca287dc59d176676559ae1aa3f1faec807805114bae214a11f586.exe

using ProjNet.Roles;
using ProjNet.Rules;
using ProjNet.Shared;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TYPELIBA.Identifiers;
using TYPELIBA.Importers;

namespace TYPELIBA.Listeners
{
  internal class AdvisorRefListener : MerchantEventRole
  {
    private double _ListenerProcess;
    private double collectionProcess;
    private double m_StubProcess;
    private double printerProcess;
    private double _AdvisorProcess;
    private double _WorkerProcess;
    private double requestProcess;

    [MethodImpl(MethodImplOptions.NoInlining)]
    public AdvisorRefListener(List<Interceptor> value)
    {
      ManagerParamsID.NewExpression();
      // ISSUE: explicit constructor call
      this.\u002Ector(value, false);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public AdvisorRefListener(List<Interceptor> value, bool isreg)
    {
      ManagerParamsID.NewExpression();
      // ISSUE: explicit constructor call
      base.\u002Ector(value, isreg);
      this.ConnectConsumer("EPSG");
      Interceptor interceptor1 = this.VisitConfiguration("central_meridian");
      Interceptor interceptor2 = this.VisitConfiguration("latitude_of_origin");
      Interceptor interceptor3 = this.VisitConfiguration("scale_factor");
      Interceptor interceptor4 = this.VisitConfiguration("false_easting");
      Interceptor interceptor5 = this.VisitConfiguration("false_northing");
      if (interceptor1 == null)
        throw new ArgumentException("Missing projection parameter 'central_meridian'");
      if (interceptor2 == null)
        throw new ArgumentException("Missing projection parameter 'latitude_of_origin'");
      if (interceptor4 == null)
        throw new ArgumentException("Missing projection parameter 'false_easting'");
      if (interceptor5 == null)
        throw new ArgumentException("Missing projection parameter 'false_northing'");
      this.m_StubProcess = StateProcess.PopConsumer(interceptor1.LoginProcess());
      this.printerProcess = StateProcess.PopConsumer(interceptor2.LoginProcess());
      this._ListenerProcess = interceptor4.LoginProcess() * this.m_ServerProcess;
      this.collectionProcess = interceptor5.LoginProcess() * this.m_ServerProcess;
      double num = this._AnnotationProcess / this.proxyProcess;
      this._WorkerProcess = 1.0 - num * num;
      this._AdvisorProcess = Math.Sqrt(this._WorkerProcess);
      if (interceptor3 == null)
      {
        this.requestProcess = Math.Cos(this.printerProcess) / Math.Sqrt(1.0 - this._WorkerProcess * Math.Sin(this.printerProcess) * Math.Sin(this.printerProcess));
        this.CountConsumer(9805L);
        this.Name = "Mercator_2SP";
      }
      else
      {
        this.requestProcess = interceptor3.LoginProcess();
        this.Name = "Mercator_1SP";
      }
      this.ConnectConsumer("EPSG");
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] InvokeConfiguration(double[] task)
    {
      int num1 = 3;
      if (true)
        goto label_14;
label_1:
      double a;
      double num2;
      double num3 = this.collectionProcess + this.proxyProcess * this.requestProcess * Math.Log(Math.Tan(Math.PI / 4.0 + a * 0.5) * Math.Pow((1.0 - num2) / (1.0 + num2), this._AdvisorProcess * 0.5));
      double num4;
      double[] numArray;
      int num5;
      if (task.Length < 3)
      {
        numArray = new double[2]
        {
          num4 / this.m_ServerProcess,
          num3 / this.m_ServerProcess
        };
        goto label_19;
      }
      else
      {
        numArray = new double[3]
        {
          num4 / this.m_ServerProcess,
          num3 / this.m_ServerProcess,
          task[2]
        };
        num5 = 8;
      }
label_13:
      num1 = num5;
label_14:
      double num6;
      while (true)
      {
        int num7;
        switch (num1)
        {
          case 0:
          case 2:
            goto label_16;
          case 1:
          case 6:
            num7 = double.IsNaN(task[1]) ? 1 : 0;
            break;
          case 3:
            if (double.IsNaN(task[0]))
            {
              num7 = 1;
              break;
            }
            goto label_10;
          case 4:
            goto label_8;
          case 5:
            goto label_11;
          case 7:
            goto label_1;
          case 8:
            goto label_19;
          default:
            if (true)
            {
              num1 = 4;
              continue;
            }
            goto label_16;
        }
        if (num7 == 0)
        {
          num6 = StateProcess.PopConsumer(task[0]);
          a = StateProcess.PopConsumer(task[1]);
          if (Math.Abs(Math.Abs(a) - Math.PI / 2.0) <= 1E-10)
          {
            if (AdvisorRefListener.SelectCreator())
              num1 = 5;
            else
              goto label_19;
          }
          else
            goto label_12;
        }
        else
          break;
      }
      num5 = 0;
      goto label_13;
label_8:
      num4 = this._ListenerProcess + this.proxyProcess * this.requestProcess * (num6 - this.m_StubProcess);
      num5 = 7;
      goto label_13;
label_10:
      num5 = 6;
      goto label_13;
label_11:
      throw new ArgumentException("Transformation cannot be computed at the poles.");
label_12:
      num2 = this._AdvisorProcess * Math.Sin(a);
      goto label_8;
label_16:
      numArray = new double[2]{ double.NaN, double.NaN };
label_19:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override double[] ReadConfiguration(double[] task)
    {
      int num1 = 5;
      double[] numArray;
      while (true)
      {
        int num2 = num1;
        double instance1;
        double num3;
        double num4;
        double instance2;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 2:
              goto label_6;
            case 1:
            case 3:
              goto label_1;
            case 4:
              double num5 = Math.PI / 2.0 - 2.0 * Math.Atan(Math.Exp(-num3 / (this.proxyProcess * this.requestProcess)));
              double num6 = Math.Pow(this._AdvisorProcess, 4.0);
              double num7 = Math.Pow(this._AdvisorProcess, 6.0);
              double num8 = Math.Pow(this._AdvisorProcess, 8.0);
              instance1 = num5 + (this._WorkerProcess * 0.5 + 5.0 * num6 / 24.0 + num7 / 12.0 + 13.0 * num8 / 360.0) * Math.Sin(2.0 * num5) + (7.0 * num6 / 48.0 + 29.0 * num7 / 240.0 + 811.0 * num8 / 11520.0) * Math.Sin(4.0 * num5) + (7.0 * num7 / 120.0 + 81.0 * num8 / 1120.0) * Math.Sin(6.0 * num5) + 4279.0 * num8 / 161280.0 * Math.Sin(8.0 * num5);
              goto case 7;
            case 5:
              num2 = 3;
              continue;
            case 6:
            case 8:
              goto label_11;
            case 7:
              instance2 = num4 / (this.proxyProcess * this.requestProcess) + this.m_StubProcess;
              if (task.Length < 3)
              {
                numArray = new double[2]
                {
                  StateProcess.CheckConsumer(instance2),
                  StateProcess.CheckConsumer(instance1)
                };
                if (!AdvisorRefListener.MapCreator())
                {
                  num2 = 6;
                  continue;
                }
                goto label_11;
              }
              else
                goto label_8;
            default:
              if (true)
              {
                num2 = 7;
                continue;
              }
              goto label_6;
          }
        }
label_1:
        instance1 = double.NaN;
        num1 = 0;
        continue;
label_6:
        num4 = task[0] * this.m_ServerProcess - this._ListenerProcess;
        num3 = task[1] * this.m_ServerProcess - this.collectionProcess;
        num1 = 4;
        continue;
label_8:
        numArray = new double[3]
        {
          StateProcess.CheckConsumer(instance2),
          StateProcess.CheckConsumer(instance1),
          task[2]
        };
        num1 = 8;
      }
label_11:
      return numArray;
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public override RepositoryProcess CreateState()
    {
      int num1 = 3;
      RepositoryProcess tagProcess;
      while (true)
      {
        int num2 = num1;
        bool flag;
        while (true)
        {
          switch (num2)
          {
            case 0:
            case 3:
              goto label_6;
            case 1:
            case 4:
              if (flag)
              {
                this.tagProcess = (StateProcess) new AdvisorRefListener(this._IteratorProcess, !this._ReaderProcess);
                goto case 2;
              }
              else
                goto case 2;
            case 2:
              tagProcess = (RepositoryProcess) this.tagProcess;
              num2 = 5;
              continue;
            case 5:
              goto label_8;
            default:
              if (AdvisorRefListener.SelectCreator())
              {
                num2 = 2;
                continue;
              }
              goto label_6;
          }
        }
label_6:
        flag = this.tagProcess == null;
        num1 = 4;
      }
label_8:
      return tagProcess;
    }

    internal static bool SelectCreator() => true;

    internal static bool MapCreator() => false;
  }
}
