// Decompiled with JetBrains decompiler
// Type: RagnarokHUD.Clock
// Assembly: BinaryAssem, Version=1.1.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C3D41CFC-8277-4BEE-9AD4-AC67F2756AFC
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-5ba70e2cf6910636ffaf66657996ddfd7bdec1d21ac89015a4935a31825106ae.exe

using System;
using System.Drawing;
using System.Windows.Forms;

namespace RagnarokHUD
{
  internal class Clock : ContainerControl
  {
    private DateTime dateTime;
    private float fRadius;
    private float fCenterX;
    private float fCenterY;
    private float fCenterCircleRadius;
    private float fHourLength;
    private float fMinLength;
    private float fSecLength;
    private float fHourThickness = 3f;
    private float fMinThickness = 2f;
    private float fSecThickness = 1f;
    private bool bDraw5MinuteTicks = true;
    private bool bDraw1MinuteTicks = true;
    private float fTicksThickness = 2f;
    private Color hrColor = Color.Black;
    private Color minColor = Color.Black;
    private Color secColor = Color.Black;
    private Color circleColor = Color.Black;
    private Color ticksColor = Color.Black;

    public Clock() => this.SetStyle(ControlStyles.OptimizedDoubleBuffer, true);

    public Color HourHandColor
    {
      get => this.hrColor;
      set => this.hrColor = value;
    }

    public Color MinuteHandColor
    {
      get => this.minColor;
      set => this.minColor = value;
    }

    public Color SecondHandColor
    {
      get => this.secColor;
      set
      {
        this.secColor = value;
        this.circleColor = value;
      }
    }

    public Color TicksColor
    {
      get => this.ticksColor;
      set => this.ticksColor = value;
    }

    public bool Draw1MinuteTicks
    {
      get => this.bDraw1MinuteTicks;
      set => this.bDraw1MinuteTicks = value;
    }

    public bool Draw5MinuteTicks
    {
      get => this.bDraw5MinuteTicks;
      set => this.bDraw5MinuteTicks = value;
    }

    protected override void OnPaint(PaintEventArgs e)
    {
      this.fRadius = (float) (this.Height / 2);
      this.fCenterX = (float) (this.ClientSize.Width / 2);
      this.fCenterY = (float) (this.ClientSize.Height / 2);
      this.fHourLength = (float) ((double) this.Height / 3.0 / 1.8500000238418579);
      this.fMinLength = (float) ((double) this.Height / 3.0 / 1.2000000476837158);
      this.fSecLength = (float) ((double) this.Height / 3.0 / 1.1499999761581421);
      this.fHourThickness = (float) this.Height / 100f;
      this.fMinThickness = (float) this.Height / 150f;
      this.fSecThickness = (float) this.Height / 200f;
      this.fCenterCircleRadius = (float) (this.Height / 50);
      this.dateTime = DateTime.Now;
      double fRadians1 = ((double) (this.dateTime.Hour % 12) + (double) this.dateTime.Minute / 60.0) * 30.0 * Math.PI / 180.0;
      double fRadians2 = (double) (this.dateTime.Minute * 6) * Math.PI / 180.0;
      double fRadians3 = (double) (this.dateTime.Second * 6) * Math.PI / 180.0;
      this.DrawPolygon((double) this.fHourThickness, (double) this.fHourLength, this.hrColor, fRadians1, e);
      this.DrawPolygon((double) this.fMinThickness, (double) this.fMinLength, this.minColor, fRadians2, e);
      this.DrawLine((double) this.fSecThickness, (double) this.fSecLength, this.secColor, fRadians3, e);
      for (int index = 0; index < 60; ++index)
      {
        if (this.bDraw5MinuteTicks && index % 5 == 0)
          e.Graphics.DrawLine(new Pen(this.ticksColor, this.fTicksThickness), this.fCenterX + (float) ((double) this.fRadius / 1.5 * Math.Sin((double) (index * 6) * Math.PI / 180.0)), this.fCenterY - (float) ((double) this.fRadius / 1.5 * Math.Cos((double) (index * 6) * Math.PI / 180.0)), this.fCenterX + (float) ((double) this.fRadius / 1.6499999761581421 * Math.Sin((double) (index * 6) * Math.PI / 180.0)), this.fCenterY - (float) ((double) this.fRadius / 1.6499999761581421 * Math.Cos((double) (index * 6) * Math.PI / 180.0)));
        else if (this.bDraw1MinuteTicks)
          e.Graphics.DrawLine(new Pen(this.ticksColor, this.fTicksThickness), this.fCenterX + (float) ((double) this.fRadius / 1.5 * Math.Sin((double) (index * 6) * Math.PI / 180.0)), this.fCenterY - (float) ((double) this.fRadius / 1.5 * Math.Cos((double) (index * 6) * Math.PI / 180.0)), this.fCenterX + (float) ((double) this.fRadius / 1.5499999523162842 * Math.Sin((double) (index * 6) * Math.PI / 180.0)), this.fCenterY - (float) ((double) this.fRadius / 1.5499999523162842 * Math.Cos((double) (index * 6) * Math.PI / 180.0)));
      }
      e.Graphics.FillEllipse((Brush) new SolidBrush(this.circleColor), this.fCenterX - this.fCenterCircleRadius / 2f, this.fCenterY - this.fCenterCircleRadius / 2f, this.fCenterCircleRadius, this.fCenterCircleRadius);
    }

    private void DrawLine(
      double fThickness,
      double fLength,
      Color color,
      double fRadians,
      PaintEventArgs e)
    {
      e.Graphics.DrawLine(new Pen(color, (float) fThickness), this.fCenterX - (float) (fLength / 9.0 * Math.Sin(fRadians)), this.fCenterY + (float) (fLength / 9.0 * Math.Cos(fRadians)), this.fCenterX + (float) (fLength * Math.Sin(fRadians)), this.fCenterY - (float) (fLength * Math.Cos(fRadians)));
    }

    private void DrawPolygon(
      double fThickness,
      double fLength,
      Color color,
      double fRadians,
      PaintEventArgs e)
    {
      PointF pointF1 = new PointF(this.fCenterX + (float) (fThickness * 2.0 * Math.Sin(fRadians + Math.PI / 2.0)), this.fCenterY - (float) (fThickness * 2.0 * Math.Cos(fRadians + Math.PI / 2.0)));
      PointF pointF2 = new PointF(this.fCenterX + (float) (fThickness * 2.0 * Math.Sin(fRadians - Math.PI / 2.0)), this.fCenterY - (float) (fThickness * 2.0 * Math.Cos(fRadians - Math.PI / 2.0)));
      PointF pointF3 = new PointF(this.fCenterX + (float) (fLength * Math.Sin(fRadians)), this.fCenterY - (float) (fLength * Math.Cos(fRadians)));
      PointF pointF4 = new PointF(this.fCenterX - (float) (fThickness * 4.0 * Math.Sin(fRadians)), this.fCenterY + (float) (fThickness * 4.0 * Math.Cos(fRadians)));
      PointF[] points = new PointF[4]
      {
        pointF1,
        pointF4,
        pointF2,
        pointF3
      };
      e.Graphics.FillPolygon((Brush) new SolidBrush(color), points);
    }

    public void Tick() => this.Invalidate();
  }
}
