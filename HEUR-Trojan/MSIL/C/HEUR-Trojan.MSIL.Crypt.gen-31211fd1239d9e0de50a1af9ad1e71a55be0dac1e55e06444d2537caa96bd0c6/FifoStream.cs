// Decompiled with JetBrains decompiler
// Type: FifoStream
// Assembly: wacYTAgLgQAjexermaa, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 8B2A0664-5AE5-48FF-9B05-FC8D65B8BF2C
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.MSIL.Crypt.gen-31211fd1239d9e0de50a1af9ad1e71a55be0dac1e55e06444d2537caa96bd0c6.exe

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Threading;

public class FifoStream : Stream
{
  private bool _IOException;
  private bool closed;
  private byte[] currentBlock;
  private int currentBlockPosition;
  private Queue<byte[]> queue = new Queue<byte[]>();
  private object readLockObj = new object();
  private AutoResetEvent readerARE = new AutoResetEvent(false);
  private AutoResetEvent flushARE = new AutoResetEvent(false);
  private long _length;

  public bool IOException
  {
    get => this._IOException;
    set
    {
      if (!value)
        throw new ArgumentException();
      this._IOException = true;
      this.readerARE.Set();
      this.flushARE.Set();
    }
  }

  public bool Zeroize { get; private set; }

  public FifoStream() => this.Zeroize = true;

  public FifoStream(bool Zeroize) => this.Zeroize = Zeroize;

  public override bool CanRead => true;

  public override bool CanSeek => false;

  public override bool CanWrite => !this.closed;

  public override long Length => this._length;

  public override long Position
  {
    get => throw new NotSupportedException();
    set => throw new NotSupportedException();
  }

  public override long Seek(long offset, SeekOrigin origin) => throw new NotSupportedException();

  public override void SetLength(long value) => throw new NotSupportedException();

  public override void Flush()
  {
    while (this._length > 0L)
      this.flushARE.WaitOne();
    if (this._IOException)
      throw new System.IO.IOException();
  }

  public override void Write(byte[] buffer, int offset, int count)
  {
    if (buffer == null)
      throw new ArgumentNullException();
    int num = offset + count;
    if (buffer.Length < num || offset < 0 || count < 0)
      throw new ArgumentException();
    if (this.closed || this._IOException)
      throw new System.IO.IOException();
    byte[] destinationArray = new byte[count];
    Array.Copy((Array) buffer, offset, (Array) destinationArray, 0, count);
    lock (this.queue)
    {
      this.queue.Enqueue(destinationArray);
      this._length += (long) destinationArray.Length;
      this.readerARE.Set();
    }
  }

  public override int Read(byte[] buffer, int offset, int count)
  {
    if (buffer == null)
      throw new ArgumentNullException();
    int num1 = offset + count;
    if (buffer.Length < num1 || offset < 0 || count <= 0)
      throw new ArgumentException();
    if (this._IOException)
      throw new System.IO.IOException();
    if (this.closed && this._length == 0L)
      return 0;
    int destinationIndex = offset;
    int num2 = 0;
    lock (this.readLockObj)
    {
      long length1 = this._length;
      while (destinationIndex < num1)
      {
        if (this.closed)
          goto label_27;
label_10:
        if (this.currentBlock == null)
        {
          lock (this.queue)
          {
            if (this.queue.Count > 0)
              this.currentBlock = this.queue.Dequeue();
          }
        }
        if (this.currentBlock == null)
        {
          if (!this.closed)
          {
            this.readerARE.WaitOne();
            if (this._IOException)
              throw new System.IO.IOException();
            continue;
          }
          continue;
        }
        int num3 = num1 - destinationIndex;
        int num4 = this.currentBlock.Length - this.currentBlockPosition;
        int length2 = num3 > num4 ? num4 : num3;
        Array.Copy((Array) this.currentBlock, this.currentBlockPosition, (Array) buffer, destinationIndex, length2);
        if (this.Zeroize)
          Array.Clear((Array) this.currentBlock, this.currentBlockPosition, length2);
        length1 -= (long) length2;
        destinationIndex += length2;
        this.currentBlockPosition += length2;
        num2 += length2;
        if (this.currentBlockPosition == this.currentBlock.Length)
        {
          this.currentBlock = (byte[]) null;
          this.currentBlockPosition = 0;
          continue;
        }
        continue;
label_27:
        if (length1 > 0L)
          goto label_10;
        else
          break;
      }
    }
    this.flushARE.Set();
    this._length -= (long) num2;
    return num2;
  }

  [SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", MessageId = "flushARE")]
  [SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", MessageId = "writerARE")]
  [SuppressMessage("Microsoft.Usage", "CA2213:DisposableFieldsShouldBeDisposed", MessageId = "readerARE")]
  protected override void Dispose(bool disposing)
  {
    this.closed = true;
    this.readerARE.Set();
    base.Dispose(disposing);
  }
}
