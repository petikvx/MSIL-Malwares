// Decompiled with JetBrains decompiler
// Type: forces.DistributedBeamForce
// Assembly: MuiResourceTypeIdIntEn, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2C7C9528-88C0-45FF-AB6A-2AC0C29EABCB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-0e10e646be7b3f9857a2994bedc1b808fabc112009cda3192df15b8eb4980ef8.exe

using System;

namespace forces
{
  public class DistributedBeamForce : Force, BeamForce, Force_
  {
    private double start;
    private double end;
    private double beamLength;
    private ReflectionBeamForce ReflectionLeft;
    private ReflectionBeamForce ReflectionRight;

    public double BeamLength => this.beamLength;

    public double Start => this.start;

    public double End => this.end;

    public DistributedBeamForce(double power, double start, double end, double beamLength)
      : base(power)
    {
      this.start = start;
      this.end = end;
      this.beamLength = beamLength;
      this.calculReflectionLeft();
      this.calculReflectionRight();
    }

    public double getMomentom(double distance)
    {
      if (distance <= this.start)
        return 0.0;
      double x = distance >= this.end ? this.end : distance;
      return -this.Power * (distance * (x - this.start) - Math.Pow(x, 2.0) / 2.0 + Math.Pow(this.start, 2.0) / 2.0) * 1.0;
    }

    public double getShaer(double distance)
    {
      if (distance <= this.start)
        return this.ReflectionLeft.Power;
      return distance >= this.end ? -this.ReflectionRight.Power : (this.ReflectionLeft.Power + this.ReflectionRight.Power) / (this.start - this.end) * (distance - this.start) + this.ReflectionLeft.Power;
    }

    public double getfMomentomd2x(double distance)
    {
      double num1 = this.Power * Math.Pow(this.beamLength - this.start, 4.0) / (24.0 * this.beamLength) + -this.Power * Math.Pow(this.beamLength - this.end, 4.0) / (24.0 * this.beamLength);
      if (distance <= this.start)
        return num1 * distance * 1.0;
      double num2 = 0.0;
      double num3 = this.Power * Math.Pow(distance - this.start, 4.0) / 24.0;
      if (distance > this.end)
        num2 = this.Power * Math.Pow(distance - this.end, 4.0) / 24.0;
      return (-(num3 - num2) + num1 * distance) * 1.0;
    }

    public ReflectionBeamForce getReflection(int x)
    {
      switch (x)
      {
        case 0:
          return this.ReflectionLeft;
        case 1:
          return this.ReflectionRight;
        default:
          throw new ArgumentOutOfRangeException(nameof (x), (object) x, "x is to be in [0,1]");
      }
    }

    public override void add(Force_ force)
    {
      if (!this.canAdd(force))
        return;
      this.addPower(force);
      this.calculReflectionRight();
      this.calculReflectionLeft();
    }

    public override bool canAdd(Force_ force) => this.sameType(force) && this.start == ((DistributedBeamForce) force).start && this.end == ((DistributedBeamForce) force).end;

    private void calculReflectionLeft() => this.ReflectionLeft = new ReflectionBeamForce(this.Power * (Math.Pow(this.start, 2.0) - Math.Pow(this.end, 2.0) + 2.0 * this.BeamLength * (this.end - this.start)) / (2.0 * this.BeamLength), 0.0, this.beamLength);

    private void calculReflectionRight() => this.ReflectionRight = new ReflectionBeamForce(this.Power * (Math.Pow(this.end, 2.0) - Math.Pow(this.start, 2.0)) / (2.0 * this.BeamLength), this.BeamLength, this.beamLength);
  }
}
