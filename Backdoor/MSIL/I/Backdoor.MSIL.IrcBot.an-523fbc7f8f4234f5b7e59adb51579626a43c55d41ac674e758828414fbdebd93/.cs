// Decompiled with JetBrains decompiler
// Type: 
// Assembly: TheBot, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 7E6D888C-8D83-46CE-907A-18F99381A0FA
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Backdoor.MSIL.IrcBot.an-523fbc7f8f4234f5b7e59adb51579626a43c55d41ac674e758828414fbdebd93.exe

using ICSharpCode.SharpZipLib;
using ICSharpCode.SharpZipLib.Zip.Compression;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System;

internal class \uE017
{
  private const int \uE013 = 0;
  private const int \uE012 = 1;
  private const int \uE011 = 2;
  private const int \uE010 = 3;
  private const int \uE00F = 4;
  private const int \uE00E = 5;
  private static readonly int[] \uE00D = new int[3]
  {
    3,
    3,
    11
  };
  private static readonly int[] \uE00C = new int[3]
  {
    2,
    3,
    7
  };
  private static readonly int[] \uE00B = new int[19]
  {
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
  };
  private byte[] \uE00A;
  private byte[] \uE009;
  private InflaterHuffmanTree \uE008;
  private int \uE007;
  private int \uE006;
  private int \uE005;
  private int \uE004;
  private int \uE003;
  private int \uE002;
  private byte \uE001;
  private int \uE000;

  public bool \uE000(StreamManipulator _param1)
  {
    while (true)
    {
      switch (this.\uE007)
      {
        case 0:
          this.\uE006 = _param1.PeekBits(5);
          if (this.\uE006 >= 0)
          {
            this.\uE006 += 257;
            _param1.DropBits(5);
            this.\uE007 = 1;
            goto case 1;
          }
          else
            goto label_3;
        case 1:
          this.\uE005 = _param1.PeekBits(5);
          if (this.\uE005 >= 0)
          {
            ++this.\uE005;
            _param1.DropBits(5);
            this.\uE003 = this.\uE006 + this.\uE005;
            this.\uE009 = new byte[this.\uE003];
            this.\uE007 = 2;
            goto case 2;
          }
          else
            goto label_6;
        case 2:
          this.\uE004 = _param1.PeekBits(4);
          if (this.\uE004 >= 0)
          {
            this.\uE004 += 4;
            _param1.DropBits(4);
            this.\uE00A = new byte[19];
            this.\uE000 = 0;
            this.\uE007 = 3;
            goto case 3;
          }
          else
            goto label_9;
        case 3:
          for (; this.\uE000 < this.\uE004; ++this.\uE000)
          {
            int num = _param1.PeekBits(3);
            if (num < 0)
              return false;
            _param1.DropBits(3);
            this.\uE00A[\uE017.\uE00B[this.\uE000]] = (byte) num;
          }
          this.\uE008 = new InflaterHuffmanTree(this.\uE00A);
          this.\uE00A = (byte[]) null;
          this.\uE000 = 0;
          this.\uE007 = 4;
          goto case 4;
        case 4:
          int symbol;
          while (((symbol = this.\uE008.GetSymbol(_param1)) & -16) == 0)
          {
            this.\uE009[this.\uE000++] = this.\uE001 = (byte) symbol;
            if (this.\uE000 == this.\uE003)
              return true;
          }
          if (symbol >= 0)
          {
            if (symbol >= 17)
              this.\uE001 = (byte) 0;
            else if (this.\uE000 == 0)
              goto label_24;
            this.\uE002 = symbol - 16;
            this.\uE007 = 5;
            goto case 5;
          }
          else
            goto label_20;
        case 5:
          int bitCount = \uE017.\uE00C[this.\uE002];
          int num1 = _param1.PeekBits(bitCount);
          if (num1 >= 0)
          {
            _param1.DropBits(bitCount);
            int num2 = num1 + \uE017.\uE00D[this.\uE002];
            if (this.\uE000 + num2 <= this.\uE003)
            {
              while (num2-- > 0)
                this.\uE009[this.\uE000++] = this.\uE001;
              if (this.\uE000 != this.\uE003)
              {
                this.\uE007 = 4;
                continue;
              }
              goto label_33;
            }
            else
              goto label_29;
          }
          else
            goto label_27;
        default:
          continue;
      }
    }
label_3:
    return false;
label_6:
    return false;
label_9:
    return false;
label_20:
    return false;
label_24:
    throw new SharpZipBaseException();
label_27:
    return false;
label_29:
    throw new SharpZipBaseException();
label_33:
    return true;
  }

  public InflaterHuffmanTree \uE001()
  {
    byte[] numArray = new byte[this.\uE006];
    Array.Copy((Array) this.\uE009, 0, (Array) numArray, 0, this.\uE006);
    return new InflaterHuffmanTree(numArray);
  }

  public InflaterHuffmanTree \uE000()
  {
    byte[] numArray = new byte[this.\uE005];
    Array.Copy((Array) this.\uE009, this.\uE006, (Array) numArray, 0, this.\uE005);
    return new InflaterHuffmanTree(numArray);
  }
}
