// Decompiled with JetBrains decompiler
// Type: Microsoft.MediaCenter.TV.Tuners.MarshalHelper
// Assembly: Microsoft.MediaCenter.TV.Tuners.Interop, Version=6.1.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
// MVID: 4545DFBD-7834-4511-B0E8-46F2D6BF39B8
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00007-msil\Virus.Win32.Xpaj.gena-cd1c6eac0092a3981efe696f4cd6bf740246c6dcb9698d78918623e86d74734f.exe

using ATL;
using System;
using System.Runtime.InteropServices;

namespace Microsoft.MediaCenter.TV.Tuners
{
  public static class MarshalHelper
  {
    public static unsafe ushort* StringToBSTR(string s) => (ushort*) Marshal.StringToBSTR(s).ToPointer();

    public static unsafe Guid GUIDToGuid(_GUID* g)
    {
      Guid guid = new Guid();
      // ISSUE: cpblk instruction
      __memcpy(ref guid, (IntPtr) g, sizeof (Guid));
      return guid;
    }

    public static unsafe Guid BSTRToGuid(ushort* b, [MarshalAs(UnmanagedType.U1)] bool fFree)
    {
      Guid empty = Guid.Empty;
      try
      {
        _GUID guidNull = \u003CModule\u003E.GUID_NULL;
        MarshalHelper.ComException(\u003CModule\u003E.CLSIDFromString(b, &guidNull));
        return MarshalHelper.GUIDToGuid(&guidNull);
      }
      finally
      {
        if (fFree && IntPtr.Zero != (IntPtr) b)
          \u003CModule\u003E.SysFreeString(b);
      }
    }

    [CLSCompliant(false)]
    public static unsafe int CoTaskStrCpy(ushort** ppDest, string pSrc)
    {
      if (IntPtr.Zero == (IntPtr) ppDest || (string) null == pSrc)
        return -2147467261;
      IntPtr coTaskMemUni = Marshal.StringToCoTaskMemUni(pSrc);
      *(int*) ppDest = (int) coTaskMemUni.ToPointer();
      return 0;
    }

    [CLSCompliant(false)]
    public static unsafe byte[] BSTRToByteArray(ushort* b)
    {
      int length = (int) \u003CModule\u003E.SysStringByteLen(b);
      byte[] destination = new byte[length];
      Marshal.Copy((IntPtr) (void*) b, destination, 0, length);
      return destination;
    }

    [CLSCompliant(false)]
    public static unsafe void ByteArrayToBSTR(ushort** to, byte[] from)
    {
      int length = from.Length;
      ushort* numPtr = \u003CModule\u003E.SysAllocStringByteLen((sbyte*) 0, (uint) length);
      *(int*) to = (int) numPtr;
      IntPtr destination = IntPtr.Zero != (IntPtr) numPtr ? (IntPtr) (void*) numPtr : throw new OutOfMemoryException("SysAllocString failed");
      Marshal.Copy(from, 0, destination, length);
    }

    public static void ThrowExceptionForHR(string errorMessage, int hr)
    {
      if (hr == -2147467263)
        throw new NotImplementedException();
      if (hr == -2147352571)
        throw new ArrayTypeMismatchException(errorMessage);
      if (hr == -2147024882)
        throw new OutOfMemoryException(errorMessage);
      if (hr == -2147024809)
        throw new ArgumentException(errorMessage);
      Marshal.ThrowExceptionForHR(hr);
    }

    public static unsafe void ComException(int hr)
    {
      if (hr < 0)
      {
        string message = string.Empty;
        IErrorInfo* ierrorInfoPtr1 = (IErrorInfo*) 0;
        if (0 == \u003CModule\u003E.GetErrorInfo(0U, &ierrorInfoPtr1))
        {
          CComBSTR ccomBstr;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(int&) ref ccomBstr = 0;
          // ISSUE: fault handler
          try
          {
            IErrorInfo* ierrorInfoPtr2 = ierrorInfoPtr1;
            ref CComBSTR local = ref ccomBstr;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            if (__calli((__FnPtr<int (IntPtr, ushort**)>) *(int*) (*(int*) ierrorInfoPtr1 + 20))((ushort**) ierrorInfoPtr2, (IntPtr) ref local) >= 0 && ^(int&) ref ccomBstr != 0)
            {
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              message = Marshal.PtrToStringBSTR((IntPtr) (void*) ^(int&) ref ccomBstr);
            }
            \u003CModule\u003E.SetErrorInfo(0U, (IErrorInfo*) 0);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(ATL\u002ECComBSTR\u002E\u007Bdtor\u007D), (void*) &ccomBstr);
          }
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          \u003CModule\u003E.SysFreeString((ushort*) ^(int&) ref ccomBstr);
        }
        throw new COMException(message, hr);
      }
    }

    public static uint VariantTypeToPB2Type(ushort vt)
    {
      int num = (int) vt;
      if (num <= 13)
      {
        if (num != 13)
        {
          if (num >= 2)
          {
            if (num > 3 && num != 8)
            {
              if (num != 9)
                goto label_8;
            }
            else
              goto label_7;
          }
          else
            goto label_8;
        }
        return 3;
      }
      if (num < 16 || num > 21 && num != 4095)
        goto label_8;
label_7:
      return 1;
label_8:
      throw new ArgumentException("The variant type is not supported", nameof (vt));
    }

    public static ushort VariantTypeToCFType(ushort vt) => vt == (ushort) 8 ? (ushort) 1 : (ushort) 0;
  }
}
