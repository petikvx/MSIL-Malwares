// Decompiled with JetBrains decompiler
// Type: Path_Finder.Source.Managers.LogicManager
// Assembly: TypeDelega, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: FEF18FA9-51E7-447C-8FC7-9441C6E3C0DE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\UDS-Trojan.Win32.GenericML.xnet-4ea8f9cb5ff79d56b4e171e5c4f7a0869f06cf580c04b5dec7148db42dc9188b.exe

using Path_Finder.DataTypes;
using Path_Finder.Source.Algorithms;
using Path_Finder.Source.UI;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Windows;
using System.Windows.Controls;

namespace Path_Finder.Source.Managers
{
  internal class LogicManager
  {
    public GraphCity graphToVisualize;
    public CitiesLocations citiesLocations;
    public CitiesConnections citiesConnections;
    public CitiesLocations defaultCitiesLocations;
    public CitiesConnections defaultCitiesConnections;
    private CitiesLocations algCitiesLocations;
    public VertexCity startCity;
    public VertexCity finalCity;
    public Alg_Speed algSpeed;
    public Heuristic algHeuristic;
    public GraphManager graphManager;
    private ResourceDictionary resources;
    private Algorithm algorithm;
    private Thread algThread;
    private bool isRunningAlg;
    private MainWindow window;

    public bool IsRunningAlg
    {
      get => this.algorithm != null ? this.algorithm.IsRunning : this.isRunningAlg;
      set => this.isRunningAlg = value;
    }

    public LogicManager(MainWindow _window)
    {
      this.graphToVisualize = (GraphCity) null;
      this.citiesLocations = (CitiesLocations) null;
      this.citiesConnections = (CitiesConnections) null;
      this.defaultCitiesLocations = new CitiesLocations();
      this.defaultCitiesConnections = new CitiesConnections();
      this.algCitiesLocations = new CitiesLocations();
      this.startCity = (VertexCity) null;
      this.finalCity = (VertexCity) null;
      this.algSpeed = Alg_Speed.Fast;
      this.algHeuristic = Heuristic.Distance;
      this.resources = ((FrameworkElement) _window).Resources;
      this.window = _window;
      this.graphManager = new GraphManager(this.window);
      this.algorithm = (Algorithm) null;
      this.algThread = (Thread) null;
      this.IsRunningAlg = false;
    }

    private void RecoverGraphData()
    {
      this.citiesLocations.Copy(this.defaultCitiesLocations);
      this.citiesConnections.Copy(this.defaultCitiesConnections);
    }

    private bool NoDelete()
    {
      foreach (City key in this.defaultCitiesLocations.locations.Keys)
      {
        if (!this.citiesLocations.locations.ContainsKey(key))
          return false;
      }
      return true;
    }

    private void ResetCitiesLocations()
    {
      if (this.citiesLocations == null || this.defaultCitiesLocations == null)
        return;
      foreach (City key in this.citiesLocations.locations.Keys)
      {
        Coordinates coordinates1;
        this.citiesLocations.locations.TryGetValue(key, out coordinates1);
        Coordinates coordinates2;
        this.defaultCitiesLocations.locations.TryGetValue(key, out coordinates2);
        coordinates1.setX(coordinates2.getX());
        coordinates1.setY(coordinates2.getY());
      }
    }

    private bool VerifyAlgorithmDataConsistency(GraphLayoutCity graphLayout)
    {
      this.CaptureCurrentGraph(graphLayout);
      return this.citiesLocations.Equals(this.algCitiesLocations);
    }

    private void DeleteCityFromData(City cityToDelete)
    {
      if (this.citiesLocations.locations.ContainsKey(cityToDelete))
        this.citiesLocations.locations.Remove(cityToDelete);
      if (this.citiesConnections.connections.ContainsKey(cityToDelete))
        this.citiesConnections.connections.Remove(cityToDelete);
      foreach (City key in this.citiesConnections.connections.Keys)
      {
        List<City> cityList;
        this.citiesConnections.connections.TryGetValue(key, out cityList);
        if (cityList.Contains(cityToDelete))
          cityList.Remove(cityToDelete);
      }
    }

    public void CleanGraph(ref GraphLayoutCity graphLayout)
    {
      Style resource = (Style) this.resources[(object) "DefaultCityStyle"];
      this.graphManager.SetStyleToAll(graphLayout, resource);
    }

    public void StartAlgorithm(
      ref GraphLayoutCity graphLayout,
      ref TextBox richTextBoxLog,
      MainWindow window)
    {
      if (this.IsRunningAlg)
      {
        this.algorithm.WaitMutex.WaitOne();
        this.algorithm.CanContinue = true;
        this.algorithm.WaitMutex.ReleaseMutex();
      }
      else
      {
        this.algorithm = new Algorithm(this.citiesLocations, this.citiesConnections, this.startCity.City, this.finalCity.City, this.algSpeed, this.algHeuristic, ref graphLayout, ref richTextBoxLog, this.resources, this.graphManager);
        this.algorithm.Window = window;
        this.algorithm.WaitMutex = new Mutex();
        this.startCity = (VertexCity) null;
        this.finalCity = (VertexCity) null;
        this.algThread = new Thread(new ThreadStart(this.algorithm.RunAlgThread));
        this.algThread.SetApartmentState(ApartmentState.STA);
        this.algThread.Start();
        this.algorithm.WaitMutex.WaitOne();
        this.algorithm.CanContinue = true;
        this.algorithm.WaitMutex.ReleaseMutex();
      }
    }

    public void StopAlgorithm()
    {
      if (this.algThread != null)
        this.algThread.Abort();
      if (this.algorithm == null)
        return;
      this.algorithm.IsRunning = false;
      this.algorithm = (Algorithm) null;
    }

    public void Exit()
    {
      if (this.algThread != null)
        this.algThread.Abort();
      Application.Current.Shutdown();
    }

    public void UpdateVertexInfo(VertexCity vertex, ref GraphLayoutCity graphLayout)
    {
      this.graphManager.UpdateVertexInfo(ref vertex, ref graphLayout);
      Coordinates coordinates;
      if (vertex == null || !this.citiesLocations.locations.TryGetValue(vertex.City, out coordinates))
        return;
      coordinates.setX(vertex.CityCoordinates.getX());
      coordinates.setY(vertex.CityCoordinates.getY());
    }

    public void DeleteCity(VertexCity cityToDelete, ref GraphLayoutCity graphLayout)
    {
      this.graphManager.DeleteCity(cityToDelete, ref graphLayout);
      this.DeleteCityFromData(cityToDelete.City);
    }

    public void MarkStartCity(VertexCity vertex, ref GraphLayoutCity graphLayout)
    {
      if (this.startCity != null)
      {
        Style resource = (Style) this.resources[(object) "DefaultCityStyle"];
        this.graphManager.SetStyle(this.startCity, graphLayout, resource);
      }
      if (this.finalCity != null && this.finalCity.Equals(vertex))
        this.finalCity = (VertexCity) null;
      this.startCity = vertex;
      Style resource1 = (Style) this.resources[(object) "StartCityStyle"];
      this.graphManager.SetStyle(vertex, graphLayout, resource1);
    }

    public void MarkFinalCity(VertexCity vertex, ref GraphLayoutCity graphLayout)
    {
      if (this.finalCity != null)
      {
        Style resource = (Style) this.resources[(object) "DefaultCityStyle"];
        this.graphManager.SetStyle(this.finalCity, graphLayout, resource);
      }
      if (this.startCity != null && this.startCity.Equals(vertex))
        this.startCity = (VertexCity) null;
      this.finalCity = vertex;
      Style resource1 = (Style) this.resources[(object) "FinalCityStyle"];
      this.graphManager.SetStyle(vertex, graphLayout, resource1);
    }

    public void OpenHelp()
    {
      if (File.Exists("Path Finder.chm"))
      {
        Process.Start("Path Finder.chm");
      }
      else
      {
        int num = (int) MessageBox.Show("Help file not found! Check that file Path Finder.chm is in the program's directory.", "Path Finder", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
    }

    public void ResetGraphToDefault(ref GraphLayoutCity graphLayout)
    {
      if (this.NoDelete())
      {
        this.ResetGraph(ref graphLayout);
      }
      else
      {
        this.RecoverGraphData();
        this.CreateGraph();
        this.RefreshGraph(ref graphLayout);
        this.EstablishGraphCoordinates(ref graphLayout);
      }
    }

    public void ResetGraph(ref GraphLayoutCity graphLayout)
    {
      this.ResetCitiesLocations();
      this.EstablishGraphCoordinates(ref graphLayout);
    }

    public void CreateGraph() => this.graphToVisualize = this.graphManager.CreateGraph(this.citiesLocations, this.citiesConnections);

    public bool ReadyToStart() => this.algorithm != null && this.algorithm.IsRunning || this.citiesLocations != null && this.citiesConnections != null && this.startCity != null && this.finalCity != null;

    public void CaptureCurrentGraph(GraphLayoutCity graphLayout) => this.graphManager.GetCurrentGraph(graphLayout, ref this.citiesLocations);

    public void EstablishGraphCoordinates(ref GraphLayoutCity graphLayout) => this.graphManager.EstablishCoordinates(ref graphLayout, this.citiesLocations);

    public void RefreshGraph(ref GraphLayoutCity graphLayout) => graphLayout.Graph = this.graphToVisualize;

    public void LoadGraphFromFile(ref GraphLayoutCity graphLayout)
    {
      OpenGraphWindow openGraphWindow = new OpenGraphWindow();
      openGraphWindow.ShowDialog();
      if (!openGraphWindow.getResult())
        return;
      this.citiesLocations = openGraphWindow.getLocations();
      this.citiesConnections = openGraphWindow.getConnections();
      this.defaultCitiesLocations.Copy(this.citiesLocations);
      this.defaultCitiesConnections.Copy(this.citiesConnections);
      this.CreateGraph();
      this.RefreshGraph(ref graphLayout);
      this.EstablishGraphCoordinates(ref graphLayout);
    }
  }
}
