// Decompiled with JetBrains decompiler
// Type: beam.RenforcedBeem
// Assembly: MuiResourceTypeIdIntEn, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2C7C9528-88C0-45FF-AB6A-2AC0C29EABCB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Backdoor.MSIL.Androm.gen-0e10e646be7b3f9857a2994bedc1b808fabc112009cda3192df15b8eb4980ef8.exe

using beam.forms;
using beam.helper;
using beam.reinforcement;
using System;

namespace beam
{
  public abstract class RenforcedBeem
  {
    public const double Ecu = 0.003;
    private Form form;
    private Reinforcement reinforcement;
    protected string failureWay;
    private double cP;
    private double cF;
    private double emC;
    private double l;
    private double b;
    private double iF;
    private double muSmin;
    private double b1;
    private double ey;
    private double es;
    private double n;
    private double muSb;

    public RenforcedBeem(double cP, double iF, double b, double l, double es)
    {
      this.B = b;
      this.L = l;
      this.CP = cP;
      this.IF = iF;
      this.Es = es;
      this.b1 = this.calcB1();
      this.emC = this.calcEmc();
      this.cF = this.calcCF();
      this.muSmin = this.calcMuSmin();
      this.ey = this.calcEy();
      this.n = this.ratioOfStandard();
      this.muSb = this.calcMuSb();
    }

    public Form Form
    {
      get => this.form;
      set => this.form = value;
    }

    public Reinforcement Reinforcement
    {
      get => this.reinforcement;
      set => this.reinforcement = value;
    }

    public double MuSb => this.muSb;

    public double Es
    {
      get => this.es;
      private set => this.es = value > 0.0 ? value : throw new ArgumentException("Es can't be <=  0");
    }

    public double Ey => this.ey;

    public double B1 => this.b1;

    public double MuSmin => this.muSmin;

    public double IF
    {
      get => this.iF;
      private set => this.iF = value > 0.0 ? value : throw new ArgumentException("iF can't be < 0");
    }

    public double B
    {
      get => this.b;
      private set => this.b = value > 0.0 ? value : throw new ArgumentException("B can't ne <= 0 ");
    }

    public double L
    {
      get => this.l;
      private set => this.l = value > 0.0 ? value : throw new ArgumentException("L can't be < 0 ");
    }

    public double CP
    {
      get => this.cP;
      private set => this.cP = value > 0.0 ? value : throw new ArgumentException("cP can't be <= 0 ");
    }

    public double CF
    {
      get => this.cF;
      private set => this.cF = value > 0.0 ? value : throw new ArgumentException("cF can't be < 0 ");
    }

    public double EMC => this.emC;

    protected double getCrossSectionalArea() => this.Form.crossSectionalArea();

    protected double getDistanceCenterGravity() => this.Form.distanceCenterGravity();

    protected double getMomentInertiaNonCrackedSection() => this.form.momentInertiaNonCrackedSection();

    protected double getRatioOfStandard() => this.n;

    protected double getSpaceTensileReinforcement() => this.reinforcement.spaceTensileReinforcement();

    protected double getSpaceCompressionReinforcement() => this.Reinforcement.spaceCompressionReinforcement();

    protected double getTeta(byte choese, double x, double D)
    {
      if (this.et(D) >= 0.005)
        return 0.9;
      if (this.et(D) <= 0.002)
        return 0.7;
      return choese == (byte) 1 ? (0.7 + (this.et(D) - this.IF / this.Es) * 66.0 <= 0.9 ? 0.7 + (this.et(D) - this.IF / this.Es) * 66.0 : 0.9) : (0.75 + (this.et(D) - this.IF / this.Es) * 50.0 <= 0.9 ? 0.75 + (this.et(D) - this.IF / this.Es) * 50.0 : 0.9);
    }

    protected double getX() => this.calcY() / this.B1;

    protected double calcMcr() => this.CF * this.getMomentInertiaNonCrackedSection() * Math.Pow(10.0, -8.0) / (this.getDistanceCenterGravity() * Math.Pow(10.0, -2.0));

    protected double et(double D) => (D - this.getX()) / this.getX() * 0.003;

    protected double calcMuS(double As, double D) => As / (D * this.B);

    protected double calcAsb(double D) => this.MuSb * this.B * D;

    protected double depthNeutralAxisSectionEquivalent(double As, double Aas, double D, double Da) => MathHelper.sESDRP(this.B / 2.0, this.getRatioOfStandard() * As + (this.getRatioOfStandard() - 1.0) * Aas, -(this.getRatioOfStandard() * As * D) - (this.getRatioOfStandard() - 1.0) * Aas * Da);

    protected double momentInertiaEquivalentCrackedSection(
      double x,
      double As,
      double Aas,
      double D,
      double Da)
    {
      return this.B * Math.Pow(x, 3.0) / 3.0 + this.getRatioOfStandard() * As * Math.Pow(D - x, 2.0) + (this.getRatioOfStandard() - 1.0) * Aas * Math.Pow(x - Da, 2.0);
    }

    public double Ie(double Ma, double Mcr, double Ig, double Icr)
    {
      Ma *= Math.Pow(10.0, -6.0);
      return Ma <= Mcr ? Ig : Math.Pow(Mcr / Ma, 3.0) * Ig + (1.0 - Math.Pow(Mcr / Ma, 3.0)) * Icr;
    }

    private double getXbDivisionD() => 0.003 / (0.003 + this.Ey);

    private double calcMuSmin() => 0.9 / this.IF;

    private double calcB1() => this.CP <= 28.0 ? 0.9 : 0.8;

    private double calcEmc() => Math.Sqrt(this.cP) * 6645.0;

    private double calcCF() => 0.74 * Math.Sqrt(this.cP);

    private double calcEy() => this.IF / this.Es;

    private double ratioOfStandard() => this.Es / this.EMC;

    private double calcMuSb() => this.B1 * this.CP * 0.85 * this.getXbDivisionD() / this.IF;

    public abstract double getIe(double Ma);

    protected abstract double calcY();

    protected abstract double calcRM();

    public abstract double ERM { get; }

    public abstract double Mcr { protected set; get; }

    public abstract double Teta { get; }

    public abstract double AsMax { get; }

    public abstract string getFailureWay();
  }
}
