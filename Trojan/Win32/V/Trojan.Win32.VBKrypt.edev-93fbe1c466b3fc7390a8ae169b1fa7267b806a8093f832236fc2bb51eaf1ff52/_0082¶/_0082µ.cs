// Decompiled with JetBrains decompiler
// Type: ¶.µ
// Assembly: Cursor, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 930472FF-67D1-4C45-9557-6B554B9B69EB
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00008-msil\Trojan.Win32.VBKrypt.edev-93fbe1c466b3fc7390a8ae169b1fa7267b806a8093f832236fc2bb51eaf1ff52.exe

using \u0082\u00B6;
using ç;
using PvLogiciels.dotNetProtector;
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;
using Ú;

namespace \u0082\u00B6
{
  internal class \u0082µ
  {
    internal static \u00BB Ü;
    [FixedAddressValueType]
    internal static int Ø;
    internal static __FnPtr<void ()> Æ;
    internal static \u00BB ª;
    [FixedAddressValueType]
    internal static \u00A9.\u0097 \u00A5;
    internal static __FnPtr<void ()> \u0090;
    [FixedAddressValueType]
    internal static bool \u0082\u00A9;
    internal static __FnPtr<void ()> \u0082\u0091;
    internal static \u00BB \u0081\u009D;
    [FixedAddressValueType]
    internal static \u00A9.\u0097 \u0081î;
    internal static __FnPtr<void ()> \u0081Ñ;
    [FixedAddressValueType]
    internal static int \u0081\u00B4;
    internal static __FnPtr<void ()> \u0081\u00A2;
    internal static \u00BB \u0081\u0087;
    [FixedAddressValueType]
    internal static \u00A9.\u0097 \u0081\u0080;
    internal static __FnPtr<void ()> è;
    internal static \u00BB Õ;
    [FixedAddressValueType]
    internal static \u00A9.\u0097 Ì;
    internal static __FnPtr<void ()> \u0082\u0096;
    internal static bool \u0081õ;
    internal static bool \u0089;
    internal static bool \u0082\u00AD;
    internal static int \u0082\u009A;
    internal static uint \u0082\u008A;
    internal static uint \u0081\u00F7;
    internal static \u008F.\u0097 \u0081æ;
    internal static uint \u0081Ï;
    internal static uint ã;
    internal static uint \u0081\u00AF;
    internal static \u008F.\u0097 \u0081\u009B;
    internal static bool \u0081\u0086;
    internal static \u00BB \u009E;
    public static unsafe int** ì;
    public static unsafe int** Ý;
    internal static __FnPtr<int ()> Å;
    [FixedAddressValueType]
    internal static uint \u00BE;
    [FixedAddressValueType]
    internal static \u0082\u0090 \u00B7;
    internal static __FnPtr<void ()> \u00A0;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u008C;
    internal static uint \u0085;
    internal static unsafe __FnPtr<void ()>* \u0082\u00B2;
    internal static unsafe __FnPtr<void ()>* \u0082\u00AB;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0082\u00A1;
    internal static int \u0082\u009B;
    internal static int \u0081\u00AB;
    internal static int \u0082\u0093;
    internal static int \u0082\u008D;
    internal static int \u0082\u0088;
    internal static int \u0082\u0082;
    internal static int \u0082\u0081;
    public static \u00A6 \u0081ç;
    public static volatile uint \u0081ñ;
    public static \u00A6 \u009C;
    public static \u0092 \u0081Û;
    public static volatile \u0095 \u0081Ù;
    public static \u0092 í;
    public static unsafe void* é;
    public static volatile uint \u0081Ê;
    public static unsafe __FnPtr<void ()>* \u0081Â;
    public static unsafe __FnPtr<void ()>* \u0081\u00BE;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool Ñ() => \u0082µ.\u0081Ê != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool Â() => \u0082µ.\u0081Ê == 1U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool µ() => \u0082µ.\u0081Ê == 0U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u00A4() => \u0082µ.\u0081ñ != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0099() => (\u0082µ.\u0081Ê != uint.MaxValue ? 1 : 0) == 0 || (\u0082µ.\u0081ñ != uint.MaxValue ? 1 : 0) != 0 || \u0082µ.\u0081Ê != 1U && \u0082µ.\u0081Ê != 0U;

    internal static unsafe int \u0082\u00A3(void* _param0)
    {
      GC.KeepAlive((object) int.MaxValue);
      return 0;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082\u00B0()
    {
      if (\u0082µ.\u0081\u009B != (\u008F.\u0097) 2)
        return \u0082µ.\u0081\u009B == (\u008F.\u0097) -1;
      void** voidPtr = (void**) &\u0082µ.\u009E;
      if (ref \u0082µ.\u009E < ref \u0082µ.Ü)
      {
        while (*(int*) voidPtr == 0)
        {
          voidPtr += 4;
          if ((IntPtr) voidPtr >= ref \u0082µ.Ü)
            goto label_5;
        }
        \u0082µ.\u0081\u009B = (\u008F.\u0097) -1;
        return true;
      }
label_5:
      \u0082µ.\u0081\u009B = (\u008F.\u0097) 0;
      return false;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082\u009F()
    {
      if (\u0082µ.\u0081æ != (\u008F.\u0097) 2)
        return \u0082µ.\u0081æ == (\u008F.\u0097) -1;
      void** voidPtr1 = (void**) &\u0082µ.\u0081Û;
      if (ref \u0082µ.\u0081Û < ref \u0082µ.í)
      {
        while (*(int*) voidPtr1 == 0)
        {
          voidPtr1 += 4;
          if ((IntPtr) voidPtr1 >= ref \u0082µ.í)
            goto label_5;
        }
        \u0082µ.\u0081æ = (\u008F.\u0097) -1;
        return true;
      }
label_5:
      void** voidPtr2 = (void**) &\u0082µ.\u009C;
      if (ref \u0082µ.\u009C < ref \u0082µ.\u0081ç)
      {
        while (*(int*) voidPtr2 == 0)
        {
          voidPtr2 += 4;
          if ((IntPtr) voidPtr2 >= ref \u0082µ.\u0081ç)
            goto label_9;
        }
        \u0082µ.\u0081æ = (\u008F.\u0097) -1;
        return true;
      }
label_9:
      \u0082µ.\u0081æ = (\u008F.\u0097) 0;
      return false;
    }

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0082\u008F() => \u0082µ.\u0082\u00B0() && !\u0082µ.\u0081õ || \u0082µ.\u0082\u009F() && !\u0082µ.\u0082\u00AD && \u0082µ.\u0081Ù == (\u0095) 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081û() => \u0082µ.\u0089;

    internal static unsafe void \u0081é() => \u0082µ.ò((__FnPtr<int (void*)>) (IntPtr) \u0082µ.ì, (void*) 0);

    internal static void \u0081µ() => \u0082µ.\u0081\u00B4 = 0;

    internal static void \u0081\u00BC() => \u0082µ.Ø = 0;

    internal static void \u0081\u00A6() => \u0082µ.\u0082\u00A9 = false;

    internal static void \u0081\u0089() => \u0082µ.\u0081\u0080 = (\u00A9.\u0097) 0;

    internal static void ë() => \u0082µ.\u0081î = (\u00A9.\u0097) 0;

    internal static void \u00B0() => \u0082µ.Ì = (\u00A9.\u0097) 0;

    internal static void \u00B4() => \u0082µ.\u00A5 = (\u00A9.\u0097) 0;

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u00A5([In] Ê* obj0)
    {
      \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load during vtable initialization.\n");
      \u0082µ.\u0081\u0080 = (\u00A9.\u0097) 1;
      \u0082µ.\u0082\u0087((__FnPtr<void* ()>*) &\u0082µ.ª, (__FnPtr<void* ()>*) &\u0082µ.Õ);
      \u0082µ.\u0081\u0080 = (\u00A9.\u0097) 2;
    }

    internal static unsafe void \u0086([In] Ê* obj0)
    {
      \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
      \u0082µ.\u0081é();
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u00A7([In] Ê* obj0)
    {
      \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load during native initialization.\n");
      \u0082µ.\u0081\u00B8();
      \u0082µ.\u0082\u00AD = true;
      if (!\u0082µ.\u0099())
        \u0082µ.\u0081\u00BB(33);
      switch (\u0082µ.\u0081Ù)
      {
        case (\u0095) 0:
          \u0082µ.\u0081î = (\u00A9.\u0097) 1;
          \u0082µ.\u0081Ù = (\u0095) 1;
          if (\u0082µ.\u0081à((__FnPtr<int ()>*) &\u0082µ.\u0081Û, (__FnPtr<int ()>*) &\u0082µ.í) != 0)
            \u0082µ.ó(\u0082µ.\u00A3((Ç*) obj0));
          \u0082µ.\u0082\u0099((__FnPtr<void ()>*) &\u0082µ.\u009C, (__FnPtr<void ()>*) &\u0082µ.\u0081ç);
          \u0082µ.\u0081Ù = (\u0095) 2;
          \u0082µ.\u0081\u0086 = true;
          \u0082µ.\u0081î = (\u00A9.\u0097) 2;
          break;
        case (\u0095) 1:
          \u0082µ.\u0081\u00BB(33);
          break;
      }
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0092([In] Ê* obj0)
    {
      \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load during process initialization.\n");
      \u0082µ.Ì = (\u00A9.\u0097) 1;
      \u0082µ.\u0081\u0091();
      \u0082µ.\u0082\u0087((__FnPtr<void* ()>*) &\u0082µ.\u009E, (__FnPtr<void* ()>*) &\u0082µ.Ü);
      \u0082µ.Ì = (\u00A9.\u0097) 2;
      \u0082µ.\u0081õ = true;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0081Ò([In] Ê* obj0)
    {
      \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load during appdomain initialization.\n");
      \u0082µ.\u00A5 = (\u00A9.\u0097) 1;
      \u0082µ.\u0081\u0084();
      \u0082µ.\u0082\u0087((__FnPtr<void* ()>*) &\u0082µ.\u0081\u009D, (__FnPtr<void* ()>*) &\u0082µ.\u0081\u0087);
      \u0082µ.\u00A5 = (\u00A9.\u0097) 2;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0081ë([In] Ê* obj0)
    {
      \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load during registration for the unload events.\n");
      \u0082µ.\u0081\u0082(new EventHandler(\u0082µ.\u0081\u008A));
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0081Ö([In] Ê* obj0)
    {
      \u0082µ.\u0082\u00A9 = AppDomain.CurrentDomain.IsDefaultAppDomain();
      if (\u0082µ.\u0082\u00A9)
        \u0082µ.\u0089 = true;
      \u0082µ.\u0081\u00A4();
      void* voidPtr1 = \u0082µ.\u0081Á();
      int num1 = 0;
      int num2 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        while (num2 == 0)
        {
          try
          {
          }
          finally
          {
            IntPtr comparand = (IntPtr) 0;
            IntPtr num3 = (IntPtr) voidPtr1;
            // ISSUE: cast to a reference type
            void* voidPtr2 = (void*) Interlocked.CompareExchange((IntPtr&) ref \u0082µ.é, num3, comparand);
            if ((IntPtr) voidPtr2 == IntPtr.Zero)
              num2 = 1;
            else if (voidPtr2 == voidPtr1)
            {
              num1 = 1;
              num2 = 1;
            }
          }
          if (num2 == 0)
            \u0082µ.\u0081\u00B3(1000U);
        }
        if (!\u0082µ.\u0082\u00A9)
        {
          if (\u0082µ.\u0082\u008F())
            \u0082µ.\u0086(obj0);
        }
      }
      finally
      {
        if (num1 == 0)
        {
          IntPtr num4 = (IntPtr) 0;
          // ISSUE: cast to a reference type
          Interlocked.Exchange((IntPtr&) ref \u0082µ.é, num4);
        }
      }
      \u0082µ.\u0082\u00A5(obj0);
      if (\u0082µ.\u0082\u00A9)
      {
        \u0082µ.\u0082\u00A7(obj0);
        \u0082µ.\u0082\u0092(obj0);
      }
      \u0082µ.\u0081Ò(obj0);
      \u0082µ.\u0081\u00B4 = 1;
      \u0082µ.\u0081ë(obj0);
    }

    internal static void \u0081Å() => \u0082µ.\u0024();

    internal static unsafe int \u0081\u00B0(void* _param0)
    {
      \u0082µ.\u0081\u0095();
      \u0082µ.\u0081õ = false;
      if (\u0082µ.\u0081\u0086)
      {
        \u0082µ.å();
        \u0082µ.\u0081Ù = (\u0095) 0;
        \u0082µ.\u0081\u0086 = false;
      }
      \u0082µ.\u0082\u00AD = false;
      return 0;
    }

    internal static unsafe void \u0081\u009C()
    {
      if (!\u0082µ.\u0089)
        return;
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        \u0082µ.\u0081\u00B0((void*) 0);
      }
      else
      {
        // ISSUE: cast to a function pointer type
        \u0082µ.ò((__FnPtr<int (void*)>) (IntPtr) \u0082µ.Ý, (void*) 0);
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [PrePrepareMethod]
    internal static void \u0081\u008A(object _param0, EventArgs _param1)
    {
      if (\u0082µ.\u0081\u00B4 == 0 || Interlocked.Exchange(ref \u0082µ.Ø, 1) != 0)
        return;
      int num = Interlocked.Decrement(ref \u0082µ.\u0082\u009A) == 0 ? 1 : 0;
      \u0082µ.\u0024();
      if ((byte) num == (byte) 0)
        return;
      \u0082µ.\u0081\u009C();
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void ö([In] Ê* obj0, Exception _param1)
    {
      try
      {
        bool flag = Interlocked.Decrement(ref \u0082µ.\u0082\u009A) == 0;
        \u0082µ.\u0081Å();
        if (!flag)
          return;
        \u0082µ.\u0081\u009C();
      }
      catch (Exception ex)
      {
        \u0082µ.\u0081\u0092(_param1, ex);
      }
      catch
      {
        \u0082µ.\u0081\u0092(_param1, (Exception) null);
      }
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void ä([In] Ê* obj0)
    {
      bool flag = false;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        \u0082µ.\u00AB((Ç*) obj0, "The C++ module failed to load.\n");
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          Interlocked.Increment(ref \u0082µ.\u0082\u009A);
          flag = true;
        }
        \u0082µ.\u0081Ö(obj0);
      }
      catch (Exception ex)
      {
        if (flag)
          \u0082µ.ö(obj0, ex);
        \u0082µ.ó(\u0082µ.\u00A3((Ç*) obj0), ex);
      }
      catch
      {
        if (flag)
          \u0082µ.ö(obj0, (Exception) null);
        \u0082µ.ó(\u0082µ.\u00A3((Ç*) obj0), (Exception) null);
      }
    }

    [DebuggerStepThrough]
    static unsafe \u0082µ()
    {
      Ê ê;
      \u0082µ.\u0084(&ê);
      // ISSUE: fault handler
      try
      {
        \u0082µ.ä(&ê);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u0082µ.\u0082\u00A8((__FnPtr<void (void*)>) __methodptr(\u009F), (void*) &ê);
      }
      \u0082µ.\u00B6((Ç*) &ê);
    }

    internal static unsafe Ê* \u0084([In] Ê* obj0)
    {
      \u0082µ.\u00BD((Ç*) obj0);
      return obj0;
    }

    internal static unsafe void \u009F([In] Ê* obj0) => \u0082µ.\u00B6((Ç*) obj0);

    [DebuggerStepThrough]
    internal static unsafe Ç* \u00BD([In] Ç* obj0)
    {
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      *(int*) obj0 = (int) num.ToPointer();
      return obj0;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u00B6([In] Ç* obj0)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
      *(int*) obj0 = 0;
    }

    [DebuggerStepThrough]
    internal static unsafe Ç* \u00AB([In] Ç* obj0, string _param1)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) _param1;
      return obj0;
    }

    internal static unsafe string \u00A3([In] Ç* obj0) => (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;

    [STAThread]
    internal static unsafe int \u0098(string[] _param0)
    {
      try
      {
        \u0082µ.Þ(1);
        *\u0082µ.É() = \u0082µ.\u0082\u0082;
        *\u0082µ.Ó() = \u0082µ.\u0082\u0088;
        \u0082µ.\u0081\u00BF();
        \u0082µ.\u0081Ä();
        if (\u0082µ.\u0082\u0093 == -1)
          \u0082µ.Û(-1);
        \u0082\u00B4 obj;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref obj = \u0082µ.\u0081\u00AB;
        int num;
        char** chPtr1;
        char** chPtr2;
        if (\u0082µ.È(&num, &chPtr1, &chPtr2, \u0082µ.\u0082\u009B, &obj) < 0)
          \u0082µ.\u0081\u00BB(8);
        \u0082µ.\u0093();
        return \u0082µ.\u0081Î(_param0);
      }
      catch (Exception ex) when (\u0082µ.Í((uint) Marshal.GetExceptionCode(), (\u0083*) Marshal.GetExceptionPointers()) != 0)
      {
        return Marshal.GetExceptionCode();
      }
    }

    internal static unsafe void \u0093()
    {
      \u0082\u0085* objPtr1 = (\u0082\u0085*) \u0082µ.\u00D7((sbyte*) 0);
      if (*(ushort*) objPtr1 != (ushort) 23117)
        return;
      \u0082\u00A0* objPtr2 = (\u0082\u00A0*) (*(int*) ((IntPtr) objPtr1 + 60) + (IntPtr) objPtr1);
      if (*(int*) objPtr2 != 17744 || *(ushort*) ((IntPtr) objPtr2 + 24) != (ushort) 267)
        return;
      if (*(ushort*) ((IntPtr) objPtr2 + 24 + 68) != (ushort) 3)
        \u0082µ.Þ(2);
      else
        \u0082µ.Þ(1);
    }

    [DebuggerStepThrough]
    internal static unsafe void \u008B()
    {
      object obj = new object();
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref \u0082µ.\u00B7 = 0;
      \u0082µ.\u00B2(&\u0082µ.\u00B7, obj);
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082\u00B3() => \u0082µ.ß(&\u0082µ.\u00B7) != null;

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u00A2() => Monitor.Enter(\u0082µ.ß(&\u0082µ.\u00B7));

    [DebuggerStepThrough]
    internal static unsafe void \u0081Ý() => Monitor.Exit(\u0082µ.ß(&\u0082µ.\u00B7));

    internal static void \u0082\u0086() => \u0082µ.Ä((__FnPtr<void ()>) __methodptr(\u0081â));

    internal static unsafe void \u0081â() => \u0082µ.Ô(&\u0082µ.\u00B7);

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081Ã()
    {
      bool flag = false;
      if (\u0082µ.\u0082\u00B3())
      {
        Monitor.Enter(\u0082µ.ß(&\u0082µ.\u00B7));
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0081\u00B9()
    {
      bool flag = false;
      if (\u0082µ.\u0082\u00B3())
      {
        Monitor.Exit(\u0082µ.ß(&\u0082µ.\u00B7));
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00B1()
    {
      if (!\u0082µ.\u0082\u00B3())
        \u0082µ.\u008B();
      return \u0082µ.\u0082\u00B3();
    }

    internal static unsafe int \u0081ª(
      __FnPtr<void ()> _param0,
      uint* _param1,
      __FnPtr<void ()>** _param2,
      __FnPtr<void ()>** _param3)
    {
      // ISSUE: cast to a function pointer type
      __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
      if (_param0 == null)
        return -1;
      int num1;
      if (\u0082µ.\u0081Ã())
      {
        try
        {
          if (*_param1 - 1U < (uint) (*(int*) _param2 - *(int*) _param3) >> 2)
          {
            try
            {
              uint num2 = *_param1 * 4U;
              uint num3 = num2 >= 2048U ? 2048U : num2;
              IntPtr cb = new IntPtr((int) num2 + (int) num3);
              IntPtr num4 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) _param3), cb);
              __FnPtr<void ()>** local2 = _param2;
              IntPtr num5 = *(int*) local2 + ((IntPtr) num4.ToPointer() - *(int*) _param3);
              *(int*) local2 = (int) num5;
              *(int*) _param3 = (int) num4.ToPointer();
              uint num6 = *_param1;
              uint num7 = 512U >= num6 ? num6 : 512U;
              *_param1 = num6 + num7;
            }
            catch (OutOfMemoryException ex)
            {
              IntPtr cb = new IntPtr((int) *_param1 * 4 + 8);
              IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) *(int*) _param3), cb);
              __FnPtr<void ()>** local3 = _param2;
              IntPtr num9 = *(int*) local3 + ((IntPtr) num8.ToPointer() - *(int*) _param3);
              *(int*) local3 = (int) num9;
              *(int*) _param3 = (int) num8.ToPointer();
              uint* numPtr = _param1;
              int num10 = (int) *numPtr + 4;
              *numPtr = (uint) num10;
            }
          }
          *(int*) *(int*) _param2 = (int) _param0;
          __FnPtr<void ()>** local4 = _param2;
          int num11 = *(int*) local4 + 4;
          *(int*) local4 = num11;
          local1 = _param0;
        }
        catch (OutOfMemoryException ex)
        {
        }
        finally
        {
          \u0082µ.\u0081\u00B9();
        }
        if (local1 != null)
        {
          num1 = 0;
          goto label_12;
        }
      }
      num1 = -1;
label_12:
      return num1;
    }

    internal static unsafe void \u0081\u0095()
    {
      if ((IntPtr) \u0082µ.\u0082\u00AB == new IntPtr(-1) || (IntPtr) \u0082µ.\u0082\u00AB == IntPtr.Zero || (IntPtr) \u0082µ.\u0082\u00B2 == IntPtr.Zero)
        return;
      \u0082µ.\u0082\u00B2 -= 4;
      if (\u0082µ.\u0082\u00B2 >= \u0082µ.\u0082\u00AB)
      {
        do
        {
          if (*(int*) \u0082µ.\u0082\u00B2 != 0)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void ()>) *(int*) \u0082µ.\u0082\u00B2)();
          }
          \u0082µ.\u0082\u00B2 -= 4;
        }
        while (\u0082µ.\u0082\u00B2 >= \u0082µ.\u0082\u00AB);
      }
      Marshal.FreeHGlobal(new IntPtr((void*) \u0082µ.\u0082\u00AB));
    }

    [DebuggerStepThrough]
    internal static unsafe int \u0081\u0091()
    {
      if (!\u0082µ.\u0081\u00B1())
        return 0;
      \u0082µ.\u0082\u00AB = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
      \u0082µ.\u0082\u00B2 = \u0082µ.\u0082\u00AB;
      \u0082µ.\u0085 = 32U;
      return 1;
    }

    internal static __FnPtr<int ()> \u0081\u008E(__FnPtr<int ()> _param0) => \u0082µ.\u0081\u0088((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    internal static unsafe int \u0081\u0088(__FnPtr<void ()> _param0) => \u0082µ.\u0081ª(_param0, &\u0082µ.\u0085, &\u0082µ.\u0082\u00B2, &\u0082µ.\u0082\u00AB);

    [DebuggerStepThrough]
    internal static unsafe int \u0081\u0084()
    {
      if (\u0082µ.\u0081\u00B1())
      {
        \u0082µ.\u008C = (__FnPtr<void ()>*) Marshal.AllocHGlobal(128).ToPointer();
        \u0082µ.\u0082\u00A1 = \u0082µ.\u008C;
        \u0082µ.\u00BE = 32U;
      }
      return 1;
    }

    internal static unsafe void \u0024()
    {
      if ((IntPtr) \u0082µ.\u008C == new IntPtr(-1) || (IntPtr) \u0082µ.\u008C == IntPtr.Zero)
        return;
      if ((IntPtr) \u0082µ.\u0082\u00A1 == IntPtr.Zero)
        return;
      try
      {
        while (true)
        {
          do
          {
            \u0082µ.\u0082\u00A1 -= 4;
            if (\u0082µ.\u0082\u00A1 < \u0082µ.\u008C)
              goto label_8;
          }
          while (*(int*) \u0082µ.\u0082\u00A1 == 0);
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) *(int*) \u0082µ.\u0082\u00A1)();
        }
label_8:;
      }
      finally
      {
        Marshal.FreeHGlobal(new IntPtr((void*) \u0082µ.\u008C));
      }
    }

    internal static __FnPtr<int ()> ù(__FnPtr<int ()> _param0) => \u0082µ.Ä((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [DebuggerStepThrough]
    internal static unsafe int Ä(__FnPtr<void ()> _param0) => \u0082µ.\u0081ª(_param0, &\u0082µ.\u00BE, &\u0082µ.\u0082\u00A1, &\u0082µ.\u008C);

    [DebuggerStepThrough]
    internal static unsafe void \u00BF([In] \u0082\u0090* obj0, object _param1)
    {
      *(int*) obj0 = 0;
      \u0082µ.\u00B2(obj0, _param1);
    }

    [DebuggerStepThrough]
    internal static unsafe object ß([In] \u0082\u0090* obj0)
    {
      ValueType valueType = \u0082µ.Á(obj0);
      return valueType != null ? ((GCHandle) valueType).Target : (object) null;
    }

    internal static unsafe void Ô([In] \u0082\u0090* obj0)
    {
      ValueType valueType = \u0082µ.Á(obj0);
      if (valueType == null)
        return;
      ((GCHandle) valueType).Free();
      *(int*) obj0 = 0;
    }

    [DebuggerStepThrough]
    internal static unsafe ValueType Á([In] \u0082\u0090* obj0)
    {
      uint num = (uint) *(int*) obj0;
      return num != 0U ? (ValueType) GCHandle.FromIntPtr(new IntPtr((void*) num)) : (ValueType) null;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u00B2([In] \u0082\u0090* obj0, object _param1)
    {
      ValueType valueType = \u0082µ.Á(obj0);
      if (valueType == null)
      {
        IntPtr intPtr = GCHandle.ToIntPtr(GCHandle.Alloc(_param1));
        *(int*) obj0 = (int) intPtr.ToPointer();
      }
      else
        ((GCHandle) valueType).Target = _param1;
    }

    [DebuggerStepThrough]
    internal static unsafe int \u0081à(__FnPtr<int ()>* _param0, __FnPtr<int ()>* _param1)
    {
      int num1 = 0;
      if (_param0 < _param1)
      {
        while (num1 == 0)
        {
          uint num2 = (uint) *(int*) _param0;
          if (num2 != 0U)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            num1 = __calli((__FnPtr<int ()>) (int) num2)();
          }
          _param0 += 4;
          if (_param0 >= _param1)
            break;
        }
      }
      return num1;
    }

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0099(__FnPtr<void ()>* _param0, __FnPtr<void ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (int) num)();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static ModuleHandle \u009A() => typeof (\u0082\u0089).Module.ModuleHandle;

    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0087(__FnPtr<void* ()>* _param0, __FnPtr<void* ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli(\u0082µ.\u008D((__FnPtr<void* ()>) (int) num))();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static unsafe __FnPtr<void* ()> \u008D(__FnPtr<void* ()> _param0) => (__FnPtr<void* ()>) (IntPtr) \u0082µ.\u009A().ResolveMethodHandle((int) _param0).GetFunctionPointer().ToPointer();

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0082\u00A8(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0082µ.Ã((\u0083*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0082\u009D(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0082µ.Ã((\u0083*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    internal static unsafe void \u0082\u0095(
      __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> _param0,
      void* _param1,
      uint _param2,
      int _param3,
      __FnPtr<void (void*)> _param4)
    {
      try
      {
        void* voidPtr = _param1;
        int num1 = (int) _param2;
        int num2 = _param3;
        __FnPtr<void (void*)> local = _param4;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli(_param0)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
      }
      catch (Exception ex) when (\u0082µ.Ã((\u0083*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    internal static void \u0081Ä()
    {
      if (\u0082µ.\u0082\u008D != 0)
        return;
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u0082µ.\u0082((__FnPtr<int (\u0081è*)>) __methodptr(\u0081ý));
    }

    internal static int \u0081\u00BF() => 0;

    internal static unsafe int \u0081ý(\u0081è* _param0) => 0;

    internal static unsafe Assembly \u0081ø(string _param0)
    {
      string str = _param0.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      int length = str.IndexOf(',');
      if (length >= 0)
        str = str.Substring(0, length).Trim();
      bool flag = str == "PvLogiciels.dotNetProtector.Runtime";
      byte[] numArray = !flag ? new byte[\u0082µ.\u00AD()] : new byte[\u0082µ.\u00A8()];
      if (numArray == null || numArray.Length == 0)
        return (Assembly) null;
      GCHandle gcHandle = GCHandle.Alloc((object) numArray, GCHandleType.Pinned);
      byte* pointer = (byte*) Marshal.UnsafeAddrOfPinnedArrayElement((Array) numArray, 0).ToPointer();
      if (flag)
        \u0082µ.\u00B1(pointer);
      else
        \u0082µ.\u00B8(pointer);
      gcHandle.Free();
      return Assembly.Load(numArray);
    }

    internal static unsafe void* \u0081ó(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      Module module = Assembly.GetExecutingAssembly().LoadModule("embedded.netmodule", numArray);
      AppDomain.CurrentDomain.SetData("PvLogiciels.dotNetProtector.embedded.netmodule", (object) module);
      return Marshal.GetHINSTANCE(module).ToPointer();
    }

    internal static unsafe void* \u0081ê(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      return Marshal.GetHINSTANCE(Assembly.Load(numArray).GetLoadedModules()[0]).ToPointer();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int \u0081á(string[] _param0) => \u003CdotNetProtector\u003E.Main(_param0);

    internal static int \u0081Þ(string[] _param0)
    {
      Module data = (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");
      if ((object) data == null)
        return \u0082µ.\u0081á(_param0);
      Type type = data.GetType("<dotNetProtector>");
      if ((object) type == null)
        return \u0082µ.\u0081á(_param0);
      MethodBase method = (MethodBase) type.GetMethod("Main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
      if ((object) method == null)
        return \u0082µ.\u0081á(_param0);
      object[] parameters = new object[1]
      {
        (object) _param0
      };
      return (int) method.Invoke((object) null, parameters);
    }

    internal static Assembly \u0081Ü(object _param0, ResolveEventArgs _param1)
    {
      string str = _param1.Name.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      int index = 0;
      if (0 < assemblies.Length)
      {
        Assembly assembly;
        do
        {
          assembly = assemblies[index];
          if (!(assembly.FullName == str))
            ++index;
          else
            goto label_5;
        }
        while (index < assemblies.Length);
        goto label_6;
label_5:
        return assembly;
      }
label_6:
      return (Assembly) null;
    }

    internal static Module \u0081Õ(object _param0, ResolveEventArgs _param1) => (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int \u0081Ð(string[] _param0)
    {
      PvLogiciels.dotNetProtector.Runtime.ExeInit(typeof (RuntimeInterop), IntPtr.Zero, 0);
      Assembly.GetExecutingAssembly().ModuleResolve += new ModuleResolveEventHandler(\u0082µ.\u0081Õ);
      return \u0082µ.\u0081Þ(_param0);
    }

    [STAThread]
    internal static int \u0081Î(string[] _param0)
    {
      \u0082µ.º();
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0082µ.\u0081Ü);
      return \u0082µ.\u0081Ð(_param0);
    }

    internal static void \u0081Í()
    {
    }

    internal static int \u0081É() => 0;

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081Á();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00BB([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00B8();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00B3([In] uint obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void ó([In] string obj0, [In] Exception obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void ó([In] string obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00A4();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u0092([In] Exception obj0, [In] Exception obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u0082([In] EventHandler obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void ò([In] __FnPtr<int (void*)> obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void å();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int â();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void Þ([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern int Û([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe \u00B3* \u00D7([In] sbyte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int* Ó();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Í([In] uint obj0, [In] \u0083* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int* É();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int È(
      [In] int* obj0,
      [In] char*** obj1,
      [In] char*** obj2,
      [In] int obj3,
      [In] \u0082\u00B4* obj4);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int Ã([In] \u0083* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0082([In] __FnPtr<int (\u0081è*)> obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void º();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u00B8([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u00B1([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u00AD();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u00A8();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u00A1([In] int obj0, [In] void* obj1, [In] void* obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u009D([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u009B([In] byte* obj0, [In] void** obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u0094([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0091();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe uint \u0081ö([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0087([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00B1([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u00AC([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00D7([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u0098([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0082\u008E([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0082\u0084([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ü(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3,
      [In] byte obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ü(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6,
      [In] byte obj7);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ô([In] byte* obj0, [In] void* obj1, [In] void* obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ô(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ï(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte** obj5);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ï(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte* obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081ï(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] byte* obj5,
      [In] ushort obj6,
      [In] ushort obj7,
      [In] sbyte** obj8);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081å([In] byte* obj0, [In] uint obj1, [In] ushort obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081å(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte* obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081å(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] byte* obj3,
      [In] ushort obj4,
      [In] ushort obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u0096([In] byte* obj0, [In] void* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u008D([In] byte* obj0, [In] void* obj1, [In] sbyte* obj2, [In] byte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ì([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2, [In] ulong* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Ì([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Æ(
      [In] byte* obj0,
      [In] void* obj1,
      [In] uint obj2,
      [In] ulong obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081Æ([In] byte* obj0, [In] void* obj1, [In] uint obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081À([In] byte* obj0, [In] ulong obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u00B7([In] byte* obj0, [In] sbyte* obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u0081\u00B2([In] byte* obj0, [In] sbyte* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int \u0081\u00AD();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern ulong \u0081\u00A9();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void \u0081\u00A0();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u009A(
      [In] byte* obj0,
      [In] void* obj1,
      [In] int* obj2,
      [In] sbyte* obj3,
      [In] int obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int \u0081\u009A([In] byte* obj0, [In] void* obj1, [In] int obj2, [In] int obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081\u0098([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern void Ò();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* Ë([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void* \u0081\u0083([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    public static extern int ü([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe void \u00B9([In] void* obj0, [In] int obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern int ï();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int ê([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int æ([In] void* obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    public static extern unsafe int à([In] void* obj0, [In] void* obj1, [In] int obj2, [In] void* obj3);
  }
}
