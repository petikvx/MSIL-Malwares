// Decompiled with JetBrains decompiler
// Type: 033836223889.663470273561
// Assembly: 919255703032, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: F1AD5918-0B7E-492E-9A94-09EF01F479FE
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.04\HEUR-Trojan.MSIL.PowerShell.gen-3f4b670e0031ca65278218e918a28415aaa7ff1d11945b124206e7afa8294ecf.exe

using \u003033836223889;
using \u003335564603810;
using System;
using System.Collections.Generic;
using System.IO;

namespace \u003033836223889
{
  public static class \u003663470273561
  {
    public static IEnumerable<string> \u003525183754381(string _param0)
    {
      // ISSUE: object of a compiler-generated type is created
      // ISSUE: variable of a compiler-generated type
      \u003104394995500.\u003373322672008 obj = new \u003104394995500.\u003373322672008(-2);
      // ISSUE: reference to a compiler-generated field
      ((\u003663470273561.\u003228287663814) obj).\u003196712962800 = _param0;
      return (IEnumerable<string>) obj;
    }

    public static IEnumerable<string> \u003922568554477(
      string[] _param0,
      SearchOption _param1 = SearchOption.TopDirectoryOnly)
    {
      // ISSUE: object of a compiler-generated type is created
      // ISSUE: variable of a compiler-generated type
      \u003663470273561.\u003228287663814 obj = new \u003663470273561.\u003228287663814(-2);
      // ISSUE: reference to a compiler-generated field
      ((\u003663470273561.\u003917582427146) obj).\u003519340444999 = _param0;
      // ISSUE: reference to a compiler-generated field
      ((\u003663470273561.\u003917582427146) obj).\u003719399093742 = _param1;
      return (IEnumerable<string>) obj;
    }

    public static bool \u003105665890726(string _param0)
    {
      if (Directory.Exists(_param0))
        return \u003104394995500.\u003726549074099(_param0) != 0;
      if (!File.Exists(_param0))
        return true;
      string str = _param0;
      bool flag1 = true;
      if (!str.EndsWith(".deleting", StringComparison.OrdinalIgnoreCase))
      {
        flag1 = false;
        int num = 0;
        while (true)
        {
          str = _param0 + "." + num.ToString() + ".deleting";
          if (File.Exists(str))
          {
            flag1 = true;
            ++num;
          }
          else
            break;
        }
        try
        {
          File.Move(_param0, str);
        }
        catch (Exception ex)
        {
          str = _param0;
        }
      }
      bool flag2 = false;
      try
      {
        flag2 = \u003663470273561.\u003650334940480(str);
        if (flag1)
        {
          string searchPattern = Path.GetFileName(_param0) + ".*.deleting";
          foreach (string file in Directory.GetFiles(Path.GetDirectoryName(_param0), searchPattern))
            \u003663470273561.\u003650334940480(file);
        }
      }
      catch
      {
      }
      return flag2;
    }

    public static bool \u003650334940480(string _param0)
    {
      bool flag = false;
      if (!File.Exists(_param0))
        return true;
      try
      {
        FileAttributes attributes = File.GetAttributes(_param0);
        if ((attributes & FileAttributes.ReadOnly) != (FileAttributes) 0)
        {
          FileAttributes fileAttributes = attributes & ~FileAttributes.ReadOnly;
          File.SetAttributes(_param0, fileAttributes);
        }
        File.Delete(_param0);
        flag = true;
      }
      catch (Exception ex)
      {
      }
      return flag;
    }

    public static void \u003541438950360(string _param0, string _param1)
    {
      \u003663470273561.\u003105665890726(_param1);
      File.Copy(_param0, _param1);
    }

    public static void \u003846857536043(string _param0, string _param1)
    {
      \u003663470273561.\u003105665890726(_param1);
      File.Move(_param0, _param1);
    }

    public static bool \u003924956571100(string _param0, string _param1)
    {
      byte[] buffer1 = new byte[8192];
      byte[] buffer2 = new byte[8192];
      using (FileStream fileStream1 = File.Open(_param0, FileMode.Open, FileAccess.Read))
      {
        using (FileStream fileStream2 = File.Open(_param1, FileMode.Open, FileAccess.Read))
        {
          int num1 = fileStream1.Read(buffer1, 0, buffer1.Length);
          int num2 = fileStream2.Read(buffer2, 0, buffer2.Length);
          if (num1 != num2)
            return false;
          for (int index = 0; index < num1; ++index)
          {
            if ((int) buffer1[index] != (int) buffer2[index])
              return false;
          }
        }
      }
      return true;
    }
  }
}
