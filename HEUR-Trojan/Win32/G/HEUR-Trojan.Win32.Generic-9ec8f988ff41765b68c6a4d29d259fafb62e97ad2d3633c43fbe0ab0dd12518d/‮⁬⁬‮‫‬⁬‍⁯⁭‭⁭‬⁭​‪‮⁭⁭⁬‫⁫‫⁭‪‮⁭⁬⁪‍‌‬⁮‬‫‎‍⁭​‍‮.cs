// Decompiled with JetBrains decompiler
// Type: ‮⁬⁬‮‫‬⁬‍⁯⁭‭⁭‬⁭​‪‮⁭⁭⁬‫⁫‫⁭‪‮⁭⁬⁪‍‌‬⁮‬‫‎‍⁭​‍‮
// Assembly: ReadLineS0SAT, Version=2.0.8.1, Culture=neutral, PublicKeyToken=null
// MVID: 826822DE-6F21-4D67-9238-0DAF50EB618B
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.03\HEUR-Trojan.Win32.Generic-9ec8f988ff41765b68c6a4d29d259fafb62e97ad2d3633c43fbe0ab0dd12518d.exe

using System;

public abstract class \u202E⁬⁬‮‫‬⁬‍⁯⁭‭⁭‬⁭​‪‮⁭⁭⁬‫⁫‫⁭‪‮⁭⁬⁪‍‌‬⁮‬‫‎‍⁭​‍‮
{
  private static readonly byte[] \u200E‏‎⁭‬⁯⁫‫‪⁫⁪⁭‭⁫​‬‭‍⁫⁯⁫⁭‏‬‬‮⁫‌‪‬‍⁮‏‬‎​⁬‌‫⁬‮ = new byte[6]
  {
    (byte) 116,
    (byte) 108,
    (byte) 115,
    (byte) 49,
    (byte) 51,
    (byte) 32
  };

  public static int \u200B‫‎‏‭‏‎‫‭⁯⁭⁫⁯‌⁬‮‌⁯​​‎⁭‬⁬⁮⁯‭⁭⁬‮⁭⁪‪⁯​⁪⁯⁫‮‮‮(short _param0)
  {
    switch (_param0)
    {
      case 1:
        return 1;
      case 2:
        return 2;
      case 3:
        return 3;
      case 4:
        return 4;
      case 5:
        return 5;
      case 6:
        return 6;
      default:
        throw new ArgumentException("specified HashAlgorithm invalid: " + \u202C⁬‭‬⁭‎‭‭⁯‮‎‮‍‮‍​⁬‍⁮‬‫‬‬‍‫‌⁬⁪⁮‎⁪‌⁬⁫‭‪⁬‍⁭‏‮.\u202E⁭‏‌​⁯‍⁪⁯⁬‮​‮⁪⁪⁬‬⁭⁬⁪‭⁭‍‏⁫⁫‫‎‬⁮‌‮⁫‮‍‏‎⁬⁯⁫‮(_param0));
    }
  }

  public static int \u206F⁭‌⁯⁮‏‍‮‭⁪‍⁭‎‏⁮‌​‏⁬⁭‏‎‪‏‫⁬⁬‏‫​‭‌‮⁮‍‎⁫‏‪‪‮(int _param0)
  {
    switch (_param0)
    {
      case 1:
        return 1;
      case 2:
        return 2;
      case 3:
        return 4;
      case 4:
        return 5;
      case 5:
        return 6;
      default:
        throw new ArgumentException("specified MacAlgorithm not an HMAC: " + \u200C⁯‪⁬⁮‪‌‫‍‭​‮⁯⁮​⁭‍‭⁪‏⁫‭⁭‍‭‎‪‍‎‏‮‪​⁬‫‎‪‏​‮‮.\u202E⁭‏‌​⁯‍⁪⁯⁬‮​‮⁪⁪⁬‬⁭⁬⁪‭⁭‍‏⁫⁫‫‎‬⁮‌‮⁫‮‍‏‎⁬⁯⁫‮(_param0));
    }
  }

  public static int \u202B‬⁫⁫⁫⁯‮‎‫⁬⁫⁪⁫⁯‪‎⁪‌⁭⁮‮‏‍⁬⁬‭‭‪⁫‌⁭⁬‎‮‭‮‭‭⁬‭‮(int _param0)
  {
    switch (_param0)
    {
      case 0:
      case 1:
        throw new ArgumentException("legacy PRF not a valid algorithm");
      case 2:
      case 4:
        return 4;
      case 3:
      case 5:
        return 5;
      case 7:
        return 7;
      default:
        throw new ArgumentException("unknown PrfAlgorithm: " + \u200C‬‍‏⁬‪‌‪‭‍⁫‭⁮‏⁮⁬⁫⁯⁯‏‎⁭‎‭‮⁯‏‮⁭‮⁯⁮‏‫⁫‮‪⁪‫‫‮.\u202E⁭‏‌​⁯‍⁪⁯⁬‮​‮⁪⁪⁬‬⁭⁬⁪‭⁭‍‏⁫⁫‫‎‬⁮‌‮⁫‮‍‏‎⁬⁯⁫‮(_param0));
    }
  }

  public static int \u200C‎⁭‫‏⁪⁫‏‏⁮​‌‭⁪⁫‏⁬‎‏⁫​‫‫‏‪‏⁯‪⁬‍⁬⁭​⁪‪‏⁬‪⁭‭‮(int _param0)
  {
    switch (_param0)
    {
      case 1:
        return 16;
      case 2:
        return 20;
      case 3:
        return 28;
      case 4:
      case 7:
        return 32;
      case 5:
        return 48;
      case 6:
        return 64;
      default:
        throw new ArgumentException();
    }
  }

  public static int \u200B‬⁬‌⁫‬‭‫⁫‭‎⁮⁬‌‪‏‪‫‏⁪‮⁬⁫‮‎‍⁭‎‍‏‏‍‎⁭‎⁬⁭⁮⁯‮‮(short _param0)
  {
    switch (_param0)
    {
      case 1:
        return 1;
      case 2:
        return 2;
      case 3:
        return 3;
      case 4:
        return 4;
      case 5:
        return 5;
      case 6:
        return 6;
      case 7:
        return 7;
      case 8:
        return 8;
      case 9:
        return 9;
      case 10:
        return 10;
      case 11:
        return 11;
      case 64:
        return 64;
      case 65:
        return 65;
      default:
        throw new ArgumentException("specified SignatureAlgorithm invalid: " + \u206A‌⁮⁮‮⁫‪‮‪‮⁫‏‬⁯‭‪⁬​‎‫‍‬⁮‪⁪‫‬⁪⁫⁫‮‬⁬‫⁭‍‭‫⁮‍‮.\u202E⁭‏‌​⁯‍⁪⁯⁬‮​‮⁪⁪⁬‬⁭⁬⁪‭⁭‍‏⁫⁫‫‎‬⁮‌‮⁫‮‍‏‎⁬⁯⁫‮(_param0));
    }
  }

  public static \u202E‍‫⁫⁮‏‮‏⁫‍‪⁬⁬‮‏⁮‬‫⁫‌‏‪⁯⁯‬‪⁬⁬‎⁫‌‪‬‎‪‏‌⁬⁫‪‮ \u202A‫⁪⁯⁪​‮⁪‎⁪⁮‌⁭⁯‌‬‫⁭‭⁪⁮‮‬‬⁮‮‎⁮‍​‍⁬​‎‍⁭‮‎⁮⁬‮(
    \u202E‍‫⁫⁮‏‮‏⁫‍‪⁬⁬‮‏⁮‬‫⁫‌‏‪⁯⁯‬‪⁬⁬‎⁫‌‪‬‎‪‏‌⁬⁫‪‮ _param0,
    int _param1,
    string _param2,
    byte[] _param3,
    int _param4)
  {
    int length1 = _param2.Length;
    if (length1 < 1)
      throw new \u202B‬⁪⁮⁬⁮‫‏‫⁯‮⁬‫‬‍⁬⁮⁬‬‫‫⁮‎‎⁬​‍‎‍‏​⁯‍‬‫‍‫‮⁯‏‮((short) 80);
    int length2 = _param3.Length;
    int num1 = \u202E⁬⁬‮‫‬⁬‍⁯⁭‭⁭‬⁭​‪‮⁭⁭⁬‫⁫‫⁭‪‮⁭⁬⁪‍‌‬⁮‬‫‎‍⁭​‍‮.\u200E‏‎⁭‬⁯⁫‫‪⁫⁪⁭‭⁫​‬‭‍⁫⁯⁫⁭‏‬‬‮⁫‌‪‬‍⁮‏‬‎​⁬‌‫⁬‮.Length + length1;
    byte[] destinationArray = new byte[2 + (1 + num1) + (1 + length2)];
    \u202D⁯‎‌‬⁭⁬⁫‬⁫⁪​⁫⁪⁬​⁮‌‮‌⁮‏⁫‏‏‪‪⁬‍⁫‫‮⁫⁭‬⁭‌‮‭‏‮.\u200F⁪‬‏‍⁭‬‫‬⁯‬‎‪⁪‮‫⁬‍‬⁪⁮‍‍‮‎‍⁬‮‪‏‭‬⁫‎‭‬‌‌​‭‮(_param4);
    \u202D⁯‎‌‬⁭⁬⁫‬⁫⁪​⁫⁪⁬​⁮‌‮‌⁮‏⁫‏‏‪‪⁬‍⁫‫‮⁫⁭‬⁭‌‮‭‏‮.\u200D‫‫‏​​⁮‏‪⁫​⁫⁪⁯⁭‏‏⁫‭⁮⁮⁬‮‮⁪‭‭‪⁭‬‎‫‬‎‎⁪‫‫⁯‫‮(_param4, destinationArray, 0);
    \u202D⁯‎‌‬⁭⁬⁫‬⁫⁪​⁫⁪⁬​⁮‌‮‌⁮‏⁫‏‏‪‪⁬‍⁫‫‮⁫⁭‬⁭‌‮‭‏‮.\u202B⁬⁭⁯⁪‍‫‪⁪⁯⁭‎⁮‪​‭‪​‍‬⁯​⁮‪‌⁮⁫‫‭⁬‭⁪‍⁪⁬⁬⁭‮⁮‪‮(num1);
    \u202D⁯‎‌‬⁭⁬⁫‬⁫⁪​⁫⁪⁬​⁮‌‮‌⁮‏⁫‏‏‪‪⁬‍⁫‫‮⁫⁭‬⁭‌‮‭‏‮.\u200C‭‬⁬⁭‮​⁫‏‬⁫‪‪‫‌‎⁫⁯⁯‫​⁫‍‮‪‏‬‎‍⁮‮‪⁪⁪​⁬‮⁪‮‫‮(num1, destinationArray, 2);
    Array.Copy((Array) \u202E⁬⁬‮‫‬⁬‍⁯⁭‭⁭‬⁭​‪‮⁭⁭⁬‫⁫‫⁭‪‮⁭⁬⁪‍‌‬⁮‬‫‎‍⁭​‍‮.\u200E‏‎⁭‬⁯⁫‫‪⁫⁪⁭‭⁫​‬‭‍⁫⁯⁫⁭‏‬‬‮⁫‌‪‬‍⁮‏‬‎​⁬‌‫⁬‮, 0, (Array) destinationArray, 3, \u202E⁬⁬‮‫‬⁬‍⁯⁭‭⁭‬⁭​‪‮⁭⁭⁬‫⁫‫⁭‪‮⁭⁬⁪‍‌‬⁮‬‫‎‍⁭​‍‮.\u200E‏‎⁭‬⁯⁫‫‪⁫⁪⁭‭⁫​‬‭‍⁫⁯⁫⁭‏‬‬‮⁫‌‪‬‍⁮‏‬‎​⁬‌‫⁬‮.Length);
    int num2 = 2 + (1 + \u202E⁬⁬‮‫‬⁬‍⁯⁭‭⁭‬⁭​‪‮⁭⁭⁬‫⁫‫⁭‪‮⁭⁬⁪‍‌‬⁮‬‫‎‍⁭​‍‮.\u200E‏‎⁭‬⁯⁫‫‪⁫⁪⁭‭⁫​‬‭‍⁫⁯⁫⁭‏‬‬‮⁫‌‪‬‍⁮‏‬‎​⁬‌‫⁬‮.Length);
    for (int index = 0; index < length1; ++index)
    {
      char ch = _param2[index];
      destinationArray[num2 + index] = (byte) ch;
    }
    \u202D⁯‎‌‬⁭⁬⁫‬⁫⁪​⁫⁪⁬​⁮‌‮‌⁮‏⁫‏‏‪‪⁬‍⁫‫‮⁫⁭‬⁭‌‮‭‏‮.\u200E⁯‭‎‌⁯⁮⁫‮⁬‪⁬⁮‪⁬‌⁪‎⁬⁫‍‬‭⁬‏‮⁮⁭⁮⁪‬‌‌⁯‎​‌‬‬‍‮(_param3, destinationArray, 2 + (1 + num1));
    return _param0.\u202B‏‬‎​‫‭‫‭‏⁭⁪‬⁯‍​⁮‫‎‭‪⁪‫‌⁬⁪‏⁫⁯⁯‭‏⁯‭‌‮‏‏‪‮(_param1, destinationArray, _param4);
  }
}
