// Decompiled with JetBrains decompiler
// Type: .
// Assembly: BitGenerator, Version=37.0.2.5583, Culture=neutral, PublicKeyToken=70e4c26ef2031892
// MVID: D3922F89-E00A-4D10-8BC9-9309D5539F14
// Assembly location: C:\Users\Administrateur\Downloads\VirusShare_CryptoRansom_20160715-msil\Trojan.Win32.Scar.nxii-31823040d8ccb20eab0b8653d01af370a6537017e69ead69f6f7b73d6ef7ac14.exe

using \u0004;
using \u0007;
using \u0012;
using \u0014;
using \u0015;
using Newtonsoft.Json.Utilities;
using SmartAssembly.Delegates;
using SmartAssembly.HouseOfCards;
using System;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace \u0007
{
  internal sealed class \u0001 : \u000F
  {
    public static \u0001 \u0001;
    [NonSerialized]
    internal static GetString \u0019;

    public override \u000F<object> \u0001([In] MethodBase obj0)
    {
      DynamicMethod dynamicMethod = \u0006.\u0001(obj0.ToString(), typeof (object), new Type[1]
      {
        typeof (object[])
      }, obj0.DeclaringType);
      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
      this.\u0001(obj0, ilGenerator, 0);
      return (\u000F<object>) dynamicMethod.CreateDelegate(typeof (\u000F<object>));
    }

    public override \u0010<\u0001, object> \u0001<\u0001>([In] MethodBase obj0)
    {
      DynamicMethod dynamicMethod = \u0006.\u0001(obj0.ToString(), typeof (object), new Type[2]
      {
        typeof (object),
        typeof (object[])
      }, obj0.DeclaringType);
      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
      this.\u0001(obj0, ilGenerator, 1);
      return (\u0010<\u0001, object>) dynamicMethod.CreateDelegate(typeof (\u0010<\u0001, object>));
    }

    private unsafe void \u0001([In] MethodBase obj0, [In] ILGenerator obj1, [In] int obj2)
    {
      // ISSUE: untyped stack allocation
      void* voidPtr = (void*) __untypedstackalloc(8);
      ParameterInfo[] parameterInfoArray = \u0008\u0002.\u007E\u008D\u0004((object) obj0);
      Label label1 = \u000E\u0002.\u007E\u008F\u0004((object) obj1);
      \u000F\u0002.\u007E\u0090\u0004((object) obj1, OpCodes.Ldarg, obj2);
      \u0010\u0002.\u007E\u0091\u0004((object) obj1, OpCodes.Ldlen);
      \u000F\u0002.\u007E\u0090\u0004((object) obj1, OpCodes.Ldc_I4, parameterInfoArray.Length);
      \u0011\u0002.\u007E\u0092\u0004((object) obj1, OpCodes.Beq, label1);
      // ISSUE: type reference
      \u0013\u0002.\u007E\u0094\u0004((object) obj1, OpCodes.Newobj, \u0012\u0002.\u0093\u0004((object) \u0004\u0002.\u0084\u0004(__typeref (TargetParameterCountException)), ReflectionUtils.\u0001));
      \u0010\u0002.\u007E\u0091\u0004((object) obj1, OpCodes.Throw);
      \u0014\u0002.\u007E\u0095\u0004((object) obj1, label1);
      if (!\u0015\u0002.\u007E\u0096\u0004((object) obj0) && !\u0015\u0002.\u007E\u0097\u0004((object) obj0))
        \u0003.\u0003.\u0001(obj1, \u0001\u0002.\u007E\u0018\u0004((object) obj0));
      *(int*) voidPtr = 0;
      *(int*) ((IntPtr) voidPtr + 4) = 0;
      while (*(int*) ((IntPtr) voidPtr + 4) < parameterInfoArray.Length)
      {
        ParameterInfo parameterInfo = parameterInfoArray[*(int*) ((IntPtr) voidPtr + 4)];
        Type type1 = \u0001\u0002.\u007E\u0019\u0004((object) parameterInfo);
        if (\u0015\u0002.\u007E\u0098\u0004((object) type1))
        {
          Type type2 = \u0001\u0002.\u007E\u001A\u0004((object) type1);
          LocalBuilder localBuilder = \u0016\u0002.\u007E\u0082\u0005((object) obj1, type2);
          if (!\u0015\u0002.\u007E\u0099\u0004((object) parameterInfo))
          {
            \u0003.\u0003.\u0001(obj1, obj2, *(int*) ((IntPtr) voidPtr + 4));
            if (\u000E.\u000E(type2))
            {
              Label label2 = \u000E\u0002.\u007E\u008F\u0004((object) obj1);
              Label label3 = \u000E\u0002.\u007E\u008F\u0004((object) obj1);
              \u0011\u0002.\u007E\u0092\u0004((object) obj1, OpCodes.Brtrue_S, label2);
              \u0017\u0002.\u007E\u0083\u0005((object) obj1, OpCodes.Ldloca_S, localBuilder);
              \u0018\u0002.\u007E\u0084\u0005((object) obj1, OpCodes.Initobj, type2);
              \u0011\u0002.\u007E\u0092\u0004((object) obj1, OpCodes.Br_S, label3);
              \u0014\u0002.\u007E\u0095\u0004((object) obj1, label2);
              \u0003.\u0003.\u0001(obj1, obj2, *(int*) ((IntPtr) voidPtr + 4));
              \u0003.\u0003.\u0003(obj1, type2);
              \u000F\u0002.\u007E\u0090\u0004((object) obj1, OpCodes.Stloc, *(int*) voidPtr);
              \u0014\u0002.\u007E\u0095\u0004((object) obj1, label3);
            }
            else
            {
              \u0003.\u0003.\u0003(obj1, type2);
              \u000F\u0002.\u007E\u0090\u0004((object) obj1, OpCodes.Stloc, *(int*) voidPtr);
            }
          }
          \u0017\u0002.\u007E\u0083\u0005((object) obj1, OpCodes.Ldloca_S, localBuilder);
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        else if (\u000E.\u000E(type1))
        {
          \u0003.\u0003.\u0001(obj1, obj2, *(int*) ((IntPtr) voidPtr + 4));
          Label label4 = \u000E\u0002.\u007E\u008F\u0004((object) obj1);
          Label label5 = \u000E\u0002.\u007E\u008F\u0004((object) obj1);
          \u0011\u0002.\u007E\u0092\u0004((object) obj1, OpCodes.Brtrue_S, label4);
          LocalBuilder localBuilder = \u0016\u0002.\u007E\u0082\u0005((object) obj1, type1);
          \u0017\u0002.\u007E\u0083\u0005((object) obj1, OpCodes.Ldloca_S, localBuilder);
          \u0018\u0002.\u007E\u0084\u0005((object) obj1, OpCodes.Initobj, type1);
          \u000F\u0002.\u007E\u0090\u0004((object) obj1, OpCodes.Ldloc, *(int*) voidPtr);
          \u0011\u0002.\u007E\u0092\u0004((object) obj1, OpCodes.Br_S, label5);
          \u0014\u0002.\u007E\u0095\u0004((object) obj1, label4);
          \u0003.\u0003.\u0001(obj1, obj2, *(int*) ((IntPtr) voidPtr + 4));
          \u0003.\u0003.\u0003(obj1, type1);
          \u0014\u0002.\u007E\u0095\u0004((object) obj1, label5);
          *(int*) voidPtr = *(int*) voidPtr + 1;
        }
        else
        {
          \u0003.\u0003.\u0001(obj1, obj2, *(int*) ((IntPtr) voidPtr + 4));
          \u0003.\u0003.\u0003(obj1, type1);
        }
        *(int*) ((IntPtr) voidPtr + 4) = *(int*) ((IntPtr) voidPtr + 4) + 1;
      }
      if (\u0015\u0002.\u007E\u0096\u0004((object) obj0))
        \u0013\u0002.\u007E\u0094\u0004((object) obj1, OpCodes.Newobj, (ConstructorInfo) obj0);
      else
        \u0003.\u0003.\u0001(obj1, (MethodInfo) obj0);
      Type type = \u0015\u0002.\u007E\u0096\u0004((object) obj0) ? \u0001\u0002.\u007E\u0018\u0004((object) obj0) : \u0001\u0002.\u007E\u001B\u0004((object) (MethodInfo) obj0);
      // ISSUE: type reference
      if ((object) type != (object) \u0004\u0002.\u0084\u0004(__typeref (void)))
        \u0003.\u0003.\u0002(obj1, type);
      else
        \u0010\u0002.\u007E\u0091\u0004((object) obj1, OpCodes.Ldnull);
      \u0003.\u0003.\u0001(obj1);
    }

    public override Func<\u0001> \u0001<\u0001>([In] Type obj0)
    {
      DynamicMethod dynamicMethod = \u0006.\u0001(\u0001.\u0019(4331) + obj0.FullName, typeof (\u0001), ReflectionUtils.\u0001, obj0);
      dynamicMethod.InitLocals = true;
      \u0006.\u0001(dynamicMethod.GetILGenerator(), this, obj0);
      return (Func<\u0001>) dynamicMethod.CreateDelegate(typeof (Func<\u0001>));
    }

    public override Func<\u0001, object> \u0001<\u0001>([In] PropertyInfo obj0)
    {
      DynamicMethod dynamicMethod = \u0006.\u0001(\u0001.\u0019(4340) + obj0.Name, typeof (\u0001), new Type[1]
      {
        typeof (object)
      }, obj0.DeclaringType);
      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
      \u0006.\u0001(obj0, ilGenerator, this);
      return (Func<\u0001, object>) dynamicMethod.CreateDelegate(typeof (Func<\u0001, object>));
    }

    public override Func<\u0001, object> \u0001<\u0001>([In] FieldInfo obj0)
    {
      if (obj0.IsLiteral)
      {
        // ISSUE: object of a compiler-generated type is created
        // ISSUE: reference to a compiler-generated method
        return new Func<\u0001, object>(new \u0001.\u0001<\u0001>()
        {
          \u0001 = obj0.GetValue((object) null)
        }.\u0001);
      }
      DynamicMethod dynamicMethod = \u0006.\u0001(\u0001.\u0019(4340) + obj0.Name, typeof (\u0001), new Type[1]
      {
        typeof (object)
      }, obj0.DeclaringType);
      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
      \u0006.\u0001(obj0, ilGenerator, this);
      return (Func<\u0001, object>) dynamicMethod.CreateDelegate(typeof (Func<\u0001, object>));
    }

    public override Action<\u0001, object> \u0001<\u0001>([In] FieldInfo obj0)
    {
      DynamicMethod dynamicMethod = \u0006.\u0001(\u0001.\u0019(4345) + obj0.Name, (Type) null, new Type[2]
      {
        typeof (\u0001),
        typeof (object)
      }, obj0.DeclaringType);
      \u0006.\u0001(dynamicMethod.GetILGenerator(), obj0);
      return (Action<\u0001, object>) dynamicMethod.CreateDelegate(typeof (Action<\u0001, object>));
    }

    public override Action<\u0001, object> \u0001<\u0001>([In] PropertyInfo obj0)
    {
      DynamicMethod dynamicMethod = \u0006.\u0001(\u0001.\u0019(4345) + obj0.Name, (Type) null, new Type[2]
      {
        typeof (\u0001),
        typeof (object)
      }, obj0.DeclaringType);
      \u0006.\u0001(dynamicMethod.GetILGenerator(), obj0);
      return (Action<\u0001, object>) dynamicMethod.CreateDelegate(typeof (Action<\u0001, object>));
    }

    static \u0001()
    {
      Strings.CreateGetStringDelegate(typeof (\u0001));
      \u0001.\u0001 = new \u0001();
    }
  }
}
