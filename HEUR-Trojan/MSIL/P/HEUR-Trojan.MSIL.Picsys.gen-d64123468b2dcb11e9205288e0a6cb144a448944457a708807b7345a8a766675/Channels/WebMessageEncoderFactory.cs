// Decompiled with JetBrains decompiler
// Type: System.ServiceModel.Channels.WebMessageEncoderFactory
// Assembly: Microsoft.Transactions.Bridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 51116F84-6FE2-4BD6-A908-2C88E06F45BB
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2022.07\HEUR-Trojan.MSIL.Picsys.gen-d64123468b2dcb11e9205288e0a6cb144a448944457a708807b7345a8a766675.exe

using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Runtime;
using System.ServiceModel.Diagnostics;
using System.Text;
using System.Xml;

namespace System.ServiceModel.Channels
{
  internal class WebMessageEncoderFactory : MessageEncoderFactory
  {
    private WebMessageEncoderFactory.WebMessageEncoder messageEncoder;

    public WebMessageEncoderFactory(
      Encoding writeEncoding,
      int maxReadPoolSize,
      int maxWritePoolSize,
      XmlDictionaryReaderQuotas quotas,
      WebContentTypeMapper contentTypeMapper,
      bool javascriptCallbackEnabled)
    {
      this.messageEncoder = new WebMessageEncoderFactory.WebMessageEncoder(writeEncoding, maxReadPoolSize, maxWritePoolSize, quotas, contentTypeMapper, javascriptCallbackEnabled);
    }

    public override MessageEncoder Encoder => (MessageEncoder) this.messageEncoder;

    public override MessageVersion MessageVersion => this.messageEncoder.MessageVersion;

    internal static string GetContentType(string mediaType, Encoding encoding)
    {
      string charSet = TextEncoderDefaults.EncodingToCharSet(encoding);
      if (string.IsNullOrEmpty(charSet))
        return mediaType;
      return string.Format((IFormatProvider) CultureInfo.InvariantCulture, "{0}; charset={1}", new object[2]
      {
        (object) mediaType,
        (object) charSet
      });
    }

    private class WebMessageEncoder : MessageEncoder
    {
      private const string defaultMediaType = "application/xml";
      private WebContentTypeMapper contentTypeMapper;
      private string defaultContentType;
      private volatile MessageEncoder jsonMessageEncoder;
      private int maxReadPoolSize;
      private int maxWritePoolSize;
      private volatile MessageEncoder rawMessageEncoder;
      private XmlDictionaryReaderQuotas readerQuotas;
      private volatile MessageEncoder textMessageEncoder;
      private object thisLock;
      private Encoding writeEncoding;
      private bool javascriptCallbackEnabled;

      public WebMessageEncoder(
        Encoding writeEncoding,
        int maxReadPoolSize,
        int maxWritePoolSize,
        XmlDictionaryReaderQuotas quotas,
        WebContentTypeMapper contentTypeMapper,
        bool javascriptCallbackEnabled)
      {
        if (writeEncoding == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (writeEncoding));
        this.thisLock = new object();
        TextEncoderDefaults.ValidateEncoding(writeEncoding);
        this.writeEncoding = writeEncoding;
        this.maxReadPoolSize = maxReadPoolSize;
        this.maxWritePoolSize = maxWritePoolSize;
        this.contentTypeMapper = contentTypeMapper;
        this.javascriptCallbackEnabled = javascriptCallbackEnabled;
        this.readerQuotas = new XmlDictionaryReaderQuotas();
        quotas.CopyTo(this.readerQuotas);
        this.defaultContentType = WebMessageEncoderFactory.GetContentType("application/xml", writeEncoding);
      }

      public override string ContentType => this.defaultContentType;

      public override string MediaType => "application/xml";

      public override MessageVersion MessageVersion => MessageVersion.None;

      private MessageEncoder JsonMessageEncoder
      {
        get
        {
          if (this.jsonMessageEncoder == null)
          {
            lock (this.ThisLock)
            {
              if (this.jsonMessageEncoder == null)
                this.jsonMessageEncoder = new JsonMessageEncoderFactory(this.writeEncoding, this.maxReadPoolSize, this.maxWritePoolSize, this.readerQuotas, this.javascriptCallbackEnabled).Encoder;
            }
          }
          return this.jsonMessageEncoder;
        }
      }

      private MessageEncoder RawMessageEncoder
      {
        get
        {
          if (this.rawMessageEncoder == null)
          {
            lock (this.ThisLock)
            {
              if (this.rawMessageEncoder == null)
              {
                this.rawMessageEncoder = new ByteStreamMessageEncodingBindingElement(this.readerQuotas).CreateMessageEncoderFactory().Encoder;
                ((IWebMessageEncoderHelper) this.rawMessageEncoder).EnableBodyReaderMoveToContent();
              }
            }
          }
          return this.rawMessageEncoder;
        }
      }

      private MessageEncoder TextMessageEncoder
      {
        get
        {
          if (this.textMessageEncoder == null)
          {
            lock (this.ThisLock)
            {
              if (this.textMessageEncoder == null)
                this.textMessageEncoder = new TextMessageEncoderFactory(MessageVersion.None, this.writeEncoding, this.maxReadPoolSize, this.maxWritePoolSize, this.readerQuotas).Encoder;
            }
          }
          return this.textMessageEncoder;
        }
      }

      private object ThisLock => this.thisLock;

      public override bool IsContentTypeSupported(string contentType)
      {
        if (contentType == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(nameof (contentType));
        WebContentFormat format;
        return this.TryGetContentTypeMapping(contentType, out format) && format != WebContentFormat.Default || this.RawMessageEncoder.IsContentTypeSupported(contentType) || this.JsonMessageEncoder.IsContentTypeSupported(contentType) || this.TextMessageEncoder.IsContentTypeSupported(contentType);
      }

      public override Message ReadMessage(
        ArraySegment<byte> buffer,
        BufferManager bufferManager,
        string contentType)
      {
        if (bufferManager == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (bufferManager)));
        Message message;
        switch (this.GetFormatForContentType(contentType))
        {
          case WebContentFormat.Xml:
            message = this.TextMessageEncoder.ReadMessage(buffer, bufferManager, contentType);
            message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.XmlProperty);
            break;
          case WebContentFormat.Json:
            message = this.JsonMessageEncoder.ReadMessage(buffer, bufferManager, contentType);
            message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.JsonProperty);
            break;
          case WebContentFormat.Raw:
            message = this.RawMessageEncoder.ReadMessage(buffer, bufferManager, contentType);
            message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.RawProperty);
            break;
          default:
            throw Fx.AssertAndThrow("This should never get hit because GetFormatForContentType shouldn't return a WebContentFormat other than Json, Xml, and Raw");
        }
        return message;
      }

      public override Message ReadMessage(
        Stream stream,
        int maxSizeOfHeaders,
        string contentType)
      {
        if (stream == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (stream)));
        Message message;
        switch (this.GetFormatForContentType(contentType))
        {
          case WebContentFormat.Xml:
            message = this.TextMessageEncoder.ReadMessage(stream, maxSizeOfHeaders, contentType);
            message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.XmlProperty);
            break;
          case WebContentFormat.Json:
            message = this.JsonMessageEncoder.ReadMessage(stream, maxSizeOfHeaders, contentType);
            message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.JsonProperty);
            break;
          case WebContentFormat.Raw:
            message = this.RawMessageEncoder.ReadMessage(stream, maxSizeOfHeaders, contentType);
            message.Properties.Add("WebBodyFormatMessageProperty", (object) WebBodyFormatMessageProperty.RawProperty);
            break;
          default:
            throw Fx.AssertAndThrow("This should never get hit because GetFormatForContentType shouldn't return a WebContentFormat other than Json, Xml, and Raw");
        }
        return message;
      }

      public override ArraySegment<byte> WriteMessage(
        Message message,
        int maxMessageSize,
        BufferManager bufferManager,
        int messageOffset)
      {
        if (message == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (message)));
        if (bufferManager == null)
          throw TraceUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (bufferManager)), message);
        if (maxMessageSize < 0)
        {
          // ISSUE: reference to a compiler-generated method
          throw TraceUtility.ThrowHelperError((Exception) new ArgumentOutOfRangeException(nameof (maxMessageSize), (object) maxMessageSize, SR2.GetString(SR2.ValueMustBeNonNegative)), message);
        }
        if (messageOffset < 0 || messageOffset > maxMessageSize)
        {
          // ISSUE: reference to a compiler-generated method
          throw TraceUtility.ThrowHelperError((Exception) new ArgumentOutOfRangeException(nameof (messageOffset), (object) messageOffset, SR2.GetString(SR2.JsonValueMustBeInRange, (object) 0, (object) maxMessageSize)), message);
        }
        this.ThrowIfMismatchedMessageVersion(message);
        switch (this.ExtractFormatFromMessage(message))
        {
          case WebContentFormat.Xml:
            JavascriptCallbackResponseMessageProperty property1;
            if (message.Properties.TryGetValue<JavascriptCallbackResponseMessageProperty>(JavascriptCallbackResponseMessageProperty.Name, out property1) && property1 != null && !string.IsNullOrEmpty(property1.CallbackFunctionName))
              throw TraceUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.JavascriptCallbackNotsupported), message);
            return this.TextMessageEncoder.WriteMessage(message, maxMessageSize, bufferManager, messageOffset);
          case WebContentFormat.Json:
            return this.JsonMessageEncoder.WriteMessage(message, maxMessageSize, bufferManager, messageOffset);
          case WebContentFormat.Raw:
            JavascriptCallbackResponseMessageProperty property2;
            if (message.Properties.TryGetValue<JavascriptCallbackResponseMessageProperty>(JavascriptCallbackResponseMessageProperty.Name, out property2) && property2 != null && !string.IsNullOrEmpty(property2.CallbackFunctionName))
              throw TraceUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.JavascriptCallbackNotsupported), message);
            return this.RawMessageEncoder.WriteMessage(message, maxMessageSize, bufferManager, messageOffset);
          default:
            throw Fx.AssertAndThrow("This should never get hit because GetFormatForContentType shouldn't return a WebContentFormat other than Json, Xml, and Raw");
        }
      }

      public override void WriteMessage(Message message, Stream stream)
      {
        if (message == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (message)));
        if (stream == null)
          throw TraceUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (stream)), message);
        this.ThrowIfMismatchedMessageVersion(message);
        switch (this.ExtractFormatFromMessage(message))
        {
          case WebContentFormat.Xml:
            JavascriptCallbackResponseMessageProperty property1;
            if (message.Properties.TryGetValue<JavascriptCallbackResponseMessageProperty>(JavascriptCallbackResponseMessageProperty.Name, out property1) && property1 != null && !string.IsNullOrEmpty(property1.CallbackFunctionName))
              throw TraceUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.JavascriptCallbackNotsupported), message);
            this.TextMessageEncoder.WriteMessage(message, stream);
            break;
          case WebContentFormat.Json:
            this.JsonMessageEncoder.WriteMessage(message, stream);
            break;
          case WebContentFormat.Raw:
            JavascriptCallbackResponseMessageProperty property2;
            if (message.Properties.TryGetValue<JavascriptCallbackResponseMessageProperty>(JavascriptCallbackResponseMessageProperty.Name, out property2) && property2 != null && !string.IsNullOrEmpty(property2.CallbackFunctionName))
              throw TraceUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.JavascriptCallbackNotsupported), message);
            this.RawMessageEncoder.WriteMessage(message, stream);
            break;
          default:
            throw Fx.AssertAndThrow("This should never get hit because GetFormatForContentType shouldn't return a WebContentFormat other than Json, Xml, and Raw");
        }
      }

      public override IAsyncResult BeginWriteMessage(
        Message message,
        Stream stream,
        AsyncCallback callback,
        object state)
      {
        if (message == null)
          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (message)));
        if (stream == null)
          throw TraceUtility.ThrowHelperError((Exception) new ArgumentNullException(nameof (stream)), message);
        this.ThrowIfMismatchedMessageVersion(message);
        return (IAsyncResult) new WebMessageEncoderFactory.WebMessageEncoder.WriteMessageAsyncResult(message, stream, this, callback, state);
      }

      public override void EndWriteMessage(IAsyncResult result) => ScheduleActionItemAsyncResult.End(result);

      internal override bool IsCharSetSupported(string charSet) => TextEncoderDefaults.TryGetEncoding(charSet, out Encoding _);

      private WebContentFormat ExtractFormatFromMessage(Message message)
      {
        object obj;
        message.Properties.TryGetValue("WebBodyFormatMessageProperty", out obj);
        return obj == null || !(obj is WebBodyFormatMessageProperty formatMessageProperty) || formatMessageProperty.Format == WebContentFormat.Default ? WebContentFormat.Xml : formatMessageProperty.Format;
      }

      private WebContentFormat GetFormatForContentType(string contentType)
      {
        WebContentFormat format;
        if (this.TryGetContentTypeMapping(contentType, out format) && format != WebContentFormat.Default)
        {
          if (DiagnosticUtility.ShouldTraceInformation)
          {
            if (string.IsNullOrEmpty(contentType))
              contentType = "<null>";
            // ISSUE: reference to a compiler-generated method
            TraceUtility.TraceEvent(TraceEventType.Information, 983090, SR2.GetString(SR2.TraceCodeRequestFormatSelectedFromContentTypeMapper, (object) format.ToString(), (object) contentType));
          }
          return format;
        }
        WebContentFormat formatForContentType = contentType != null ? (!this.JsonMessageEncoder.IsContentTypeSupported(contentType) ? (!this.TextMessageEncoder.IsContentTypeSupported(contentType) ? WebContentFormat.Raw : WebContentFormat.Xml) : WebContentFormat.Json) : WebContentFormat.Raw;
        if (DiagnosticUtility.ShouldTraceInformation)
        {
          // ISSUE: reference to a compiler-generated method
          TraceUtility.TraceEvent(TraceEventType.Information, 983091, SR2.GetString(SR2.TraceCodeRequestFormatSelectedByEncoderDefaults, (object) formatForContentType.ToString(), (object) contentType));
        }
        return formatForContentType;
      }

      private bool TryGetContentTypeMapping(string contentType, out WebContentFormat format)
      {
        if (this.contentTypeMapper == null)
        {
          format = WebContentFormat.Default;
          return false;
        }
        try
        {
          format = this.contentTypeMapper.GetMessageFormatForContentType(contentType);
          if (!WebContentFormatHelper.IsDefined(format))
          {
            // ISSUE: reference to a compiler-generated method
            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new ArgumentException(SR2.GetString(SR2.UnknownWebEncodingFormat, (object) contentType, (object) format)));
          }
          return true;
        }
        catch (Exception ex)
        {
          if (!Fx.IsFatal(ex))
          {
            // ISSUE: reference to a compiler-generated method
            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError((Exception) new CommunicationException(SR2.GetString(SR2.ErrorEncounteredInContentTypeMapper), ex));
          }
          throw;
        }
      }

      private new class WriteMessageAsyncResult : ScheduleActionItemAsyncResult
      {
        private Message message;
        private Stream stream;
        private MessageEncoder encoder;
        private WebMessageEncoderFactory.WebMessageEncoder webMessageEncoder;
        private static AsyncResult.AsyncCompletion handleEndWriteMessage;

        public WriteMessageAsyncResult(
          Message message,
          Stream stream,
          WebMessageEncoderFactory.WebMessageEncoder webMessageEncoder,
          AsyncCallback callback,
          object state)
          : base(callback, state)
        {
          this.message = message;
          this.stream = stream;
          this.webMessageEncoder = webMessageEncoder;
          switch (webMessageEncoder.ExtractFormatFromMessage(message))
          {
            case WebContentFormat.Xml:
              JavascriptCallbackResponseMessageProperty property1;
              if (message.Properties.TryGetValue<JavascriptCallbackResponseMessageProperty>(JavascriptCallbackResponseMessageProperty.Name, out property1) && property1 != null && !string.IsNullOrEmpty(property1.CallbackFunctionName))
                throw TraceUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.JavascriptCallbackNotsupported), message);
              this.encoder = webMessageEncoder.TextMessageEncoder;
              this.Schedule();
              break;
            case WebContentFormat.Json:
              this.encoder = webMessageEncoder.JsonMessageEncoder;
              this.Schedule();
              break;
            case WebContentFormat.Raw:
              JavascriptCallbackResponseMessageProperty property2;
              if (message.Properties.TryGetValue<JavascriptCallbackResponseMessageProperty>(JavascriptCallbackResponseMessageProperty.Name, out property2) && property2 != null && !string.IsNullOrEmpty(property2.CallbackFunctionName))
                throw TraceUtility.ThrowHelperError((Exception) new InvalidOperationException(SR2.JavascriptCallbackNotsupported), message);
              WebMessageEncoderFactory.WebMessageEncoder.WriteMessageAsyncResult.handleEndWriteMessage = new AsyncResult.AsyncCompletion(WebMessageEncoderFactory.WebMessageEncoder.WriteMessageAsyncResult.HandleEndWriteMessage);
              if (!this.SyncContinue(webMessageEncoder.RawMessageEncoder.BeginWriteMessage(message, stream, this.PrepareAsyncCompletion(new AsyncResult.AsyncCompletion(WebMessageEncoderFactory.WebMessageEncoder.WriteMessageAsyncResult.HandleEndWriteMessage)), (object) this)))
                break;
              this.Complete(true);
              break;
            default:
              throw Fx.AssertAndThrow("This should never get hit because GetFormatForContentType shouldn't return a WebContentFormat other than Json, Xml, and Raw");
          }
        }

        protected override void OnDoWork() => this.encoder.WriteMessage(this.message, this.stream);

        private static bool HandleEndWriteMessage(IAsyncResult result)
        {
          ((WebMessageEncoderFactory.WebMessageEncoder.WriteMessageAsyncResult) result.AsyncState).webMessageEncoder.RawMessageEncoder.EndWriteMessage(result);
          return true;
        }
      }
    }
  }
}
